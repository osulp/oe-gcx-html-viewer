/*
	
	Copyright (c) 2016, Latitude Geographics Group Ltd.
	All rights reserved.
	       
	Redistribution is not permitted. 
	
	Use in binary form, without modification, is permitted provided that neither 
	the name of the organization nor the names of its contributors may be used 
	to endorse or promote products derived from this software without specific 
	prior written permission.
	       
	THIS SOFTWARE IS PROVIDED BY COPYRIGHT HOLDER ''AS IS'' AND ANY
	EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	DISCLAIMED. IN NO EVENT SHALL LATITUDE GEOGRAPHICS GROUP LTD. BE LIABLE FOR ANY
	DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


/* Begin Script: dependencies.js ------------------------- */ 
dojo.require("esri.urlUtils");
dojo.require("esri.arcgis.utils");
dojo.require("esri.arcgis.Portal");
dojo.require("esri.layers.FeatureLayer");
dojo.require("esri.layers.wms");
dojo.require("esri.layers.wmts");
dojo.require("esri.layers.WebTiledLayer");
dojo.require("esri.virtualearth.VETiledLayer");
dojo.require("dojox.data.CsvStore");
dojo.require("dojo.aspect");
dojo.require("dojo.on");
dojo.require("dojox.gfx.matrix");
dojo.require("esri.toolbars.draw");
dojo.require("esri.toolbars.edit");
dojo.require("moment.moment");

// We need moment to exist under its normal namespace instead of esri's "moment.moment" for compatibility with moment-timezone
// and 3rd party code.
moment = moment.moment;

/* End Script: dependencies.js ------------------------- */ 


/* Begin Script: mapping.infrastructure_ts_out.js ------------------------- */ 
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/// <reference path="../_Definitions/Framework.d.ts" />
/**
* @namespace Base namespace for the Geocortex Essentials HTML5 Viewer mapping infrastructure commands.
*/
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        /**
         * @private
         * @docs-hide-from-nav
         */
        var Commands;
        (function (Commands) {
            /**
             * A collection of metadata for the known commands
             ****** This should be updated whenever you add a new command.******
             * NOTE: This metadata is used by the management pack to suggest command names and values for command parameters. Hence:
             * 1) Mark commands that do not make sense to be configured via the management pack as private. For instance, if a command takes in a feature,
             * it's unlikely that it can be configured from the management pack - though it's theoretically possible. Mark it as private. On the
             * other hand, it may make sense to include a command that takes in an extent - since it may be practically possible to configure this from the management pack.
             * 2) We DON'T support commands with multiple input parameters anymore - only ones that take in a complex object with multiple parameters. Mark as private.
             * 3) This may mean that the metadata is not 100% accurate with respect to the actual command signature. For example, "Alert" takes in one required string
             * parameter and two optional string parameters. However, since we dont support multiple parameters in commands anymore, we'll just let the user think it takes
             * in one required string parameter (as far as the configuration experience from the management pack is concerned).
             */
            Commands.commandsMetadata = [
                {
                    "name": "ActivateView",
                    "metadata": {
                        "arguments": "string",
                        "description": "Activates a view.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "DeactivateView",
                    "metadata": {
                        "arguments": "string",
                        "description": "Deactivates a view.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ToggleView",
                    "metadata": {
                        "arguments": "string",
                        "description": "Activates or deactivates a view.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ToggleLogView",
                    "metadata": {
                        "arguments": "none",
                        "description": "Activates or deactivates log view.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowLog",
                    "metadata": {
                        "arguments": "boolean",
                        "description": "Shows the log view if the parameter is true.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "HideLog",
                    "metadata": {
                        "arguments": "none",
                        "description": "Hides the log view.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ToggleResultsFrame",
                    "metadata": {
                        "arguments": "none",
                        "description": "Activates or deactivates Results frame.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ToggleDataFrame",
                    "metadata": {
                        "arguments": "none",
                        "description": "Activates or deactivates data frame.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "DestroyView",
                    "metadata": {
                        "arguments": "string",
                        "description": "Destroys a view, wiping out its bindings and DOM substructure.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "CloseModalRegion",
                    "metadata": {
                        "arguments": "none",
                        "description": "Closes the ModalWindowRegion.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "OpenWebPage",
                    "metadata": {
                        "arguments": "string",
                        "description": "Opens a web page in another tab/window.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "Alert",
                    "metadata": {
                        "arguments": "string",
                        "description": "Displays an alert.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "Confirm",
                    "metadata": {
                        "arguments": "list",
                        "description": "Displays a confirm.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "ConsoleDir",
                    "metadata": {
                        "arguments": "object",
                        "description": "Displays a representation of the specified parameter object in the browser's debugging console.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "Identify",
                    "metadata": {
                        "arguments": "esri.geometry.Geometry",
                        "description": "Executes an identify operation on a geometry.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "IdentifyBufferedGeometry",
                    "metadata": {
                        "arguments": "esri.geometry.Geometry",
                        "description": "Activates the Buffer Options dialog, buffers input geometry using settings specified by the user, places temporary markup on the map and identifies using the buffered geometry.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "IdentifyBufferedFeature",
                    "metadata": {
                        "arguments": "esri.Graphic|essentialsHtmlViewer.mapping.infrastructure.Feature",
                        "description": "Activates the Buffer Options dialog, buffers input feature geometry using settings specified by the user, places temporary markup on the map and identifies using the buffered geometry.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "IdentifyBufferedFeatureSet",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.FeatureSet|essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection|string",
                        "description": "Activates the Buffer Options dialog, buffers input feature set geometry using settings specified by the user, places temporary markup on the map and identifies using the buffered geometry.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "IdentifyBufferedFeatureSetCollection",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection|string",
                        "description": "Activates the Buffer Options dialog, buffers input feature set collection geometry using settings specified by the user, places temporary markup on the map and identifies using the buffered geometry.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "Prompt",
                    "metadata": {
                        "arguments": "object",
                        "description": "Displays a prompt.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "StartOfflineSyncAndShowProgress",
                    "metadata": {
                        "arguments": "string",
                        "description": "Starts downloading or syncing an offline map an displays the progress to the user.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "StepZoomIn",
                    "metadata": {
                        "arguments": "none",
                        "description": "Zooms in a step.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "StepZoomOut",
                    "metadata": {
                        "arguments": "none",
                        "description": "Zooms out a step.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "RecenterMapOnNextMapResize",
                    "metadata": {
                        "arguments": "none",
                        "description": "Recenters the map to its existing position the next time the map is resized.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "PanToPoint",
                    "metadata": {
                        "arguments": "esri.geometry.Geometry",
                        "description": "Pans to a point or other type of Geometry.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "PanUp",
                    "metadata": {
                        "arguments": "none",
                        "description": "Pans the map up.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "PlotCoordinates",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.coordinates.CoordinateBase|essentialsHtmlViewer.mapping.infrastructure.coordinates.CoordinateBase[]",
                        "description": "Plots a coordinate (or a number of coordinates) on the map.",
                        "isHyperlinkable": false,
                        "visibility": "public"
                    }
                },
                {
                    "name": "PanDown",
                    "metadata": {
                        "arguments": "none",
                        "description": "Pans the map down.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "PanLeft",
                    "metadata": {
                        "arguments": "none",
                        "description": "Pans the map left.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "PanRight",
                    "metadata": {
                        "arguments": "none",
                        "description": "Pans the map right.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ZoomToExtent",
                    "metadata": {
                        "arguments": "esri.geometry.Extent",
                        "description": "Zooms to the given extent.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ZoomToScale",
                    "metadata": {
                        "arguments": "number",
                        "description": "Zooms to the given scale.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ZoomOutToExtent",
                    "metadata": {
                        "arguments": "esri.geometry.Extent",
                        "description": "Zooms out to the given extent.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ZoomToLayerExtent",
                    "metadata": {
                        "arguments": "geocortex.essentials.Layer",
                        "description": "Zooms to the extent of all the features in a layer.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "ZoomToLayerVisibleScale",
                    "metadata": {
                        "arguments": "geocortex.essentials.Layer",
                        "description": "Zooms to the scale at which features in a layer become visible.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "InitializeSite",
                    "metadata": {
                        "arguments": "none",
                        "description": "Tells the Geocortex Essentials Site object to begin initialization.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ZoomToInitialExtent",
                    "metadata": {
                        "arguments": "none",
                        "description": "Zooms to the initial extent of the current Site.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ZoomToPreviousExtent",
                    "metadata": {
                        "arguments": "none",
                        "description": "Zooms to the previous recorded map extent if any.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ZoomToNamedExtent",
                    "metadata": {
                        "arguments": "string",
                        "description": "Zooms to the bookmarked extent with the specified name.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ZoomToNextExtent",
                    "metadata": {
                        "arguments": "none",
                        "description": "Zooms to the next recorded map extent if any.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ZoomToOfflineMapExtent",
                    "metadata": {
                        "arguments": "none",
                        "description": "Zooms to the extent of the currently active offline map.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ZoomToFullExtent",
                    "metadata": {
                        "arguments": "none",
                        "description": "Zooms to the full extent of the current Site.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "MapResize",
                    "metadata": {
                        "arguments": "none",
                        "description": "Tells the map control to resize itself. This should be called after altering the map container's dimensions.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "MaximizePanel",
                    "metadata": {
                        "arguments": "string",
                        "description": "Instructs the region hosting a view to maximize itself if it supports this action. As of v2.4, only the BottomPanelRegion and its sub regions support this action.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "RestorePanel",
                    "metadata": {
                        "arguments": "string",
                        "description": "Instructs the region hosting a view to restore itself to default dimensions if it supports this action. As of v2.4, only the BottomPanelRegion and its sub regions support this action.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "AddTemporaryMarkupGeometry",
                    "metadata": {
                        "arguments": "esri.geometry.Geometry",
                        "description": "Adds a temporary markup graphic to the map. The {@link Commands.ClearTemporaryMarkup} command will clear this piece of markup.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "ClearTemporaryMarkup",
                    "metadata": {
                        "arguments": "none",
                        "description": "Removes temporary markup created by the command 'AddTemporaryMarkupGeometry'",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ClearTrustedUrls",
                    "metadata": {
                        "arguments": "none",
                        "description": "Clears list of trusted URLs which are added by clicking 'yes' on potentially untrusted content popup",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ZoomToFeature",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.Feature",
                        "description": "Zooms to a feature.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "ZoomToFeatureIfOutsideMapExtent",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.Feature",
                        "description": "Zooms to a feature if the it's outside of the map's extent, otherwise nothing happens.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "ZoomToFeatures",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.FeatureSet",
                        "description": "Zooms to the extent of all the features in the feature set.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "ZoomToAllFeatures",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.Feature[]",
                        "description": "Zooms to the extent of all the features.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "ShowMap",
                    "metadata": {
                        "arguments": "none",
                        "description": "Activates map view.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowMapElement",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.commandArgs.ShowMapElementArgs",
                        "description": "Displays an element anchored to a specific point on the map.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "ShowMapCallout",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.commandArgs.ShowMapElementArgs",
                        "description": "Displays a map callout anchored to a given point.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "HideMapElement",
                    "metadata": {
                        "arguments": "string",
                        "description": "Removes an element previously anchored to the map using {@link Commands.ShowMapElement}.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowMapTipResults",
                    "metadata": {
                        "arguments": "string",
                        "description": "Shows map tip results for a FeatureSetCollection previously added to the FeatureSetManager.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowMapTipResultsInCallout",
                    "metadata": {
                        "arguments": "string",
                        "description": "Shows map tip results for a FeatureSetCollection previously added to the FeatureSetManager, in a floating callout window on the map (the default behavior prior to version 2.4).",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "OpenDataFrame",
                    "metadata": {
                        "arguments": "none",
                        "description": "Opens the DataRegion, if it is present in the current shell.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "CloseDataFrame",
                    "metadata": {
                        "arguments": "none",
                        "description": "Closes the DataRegion, if it is present in the current shell.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "OpenBottomRegion",
                    "metadata": {
                        "arguments": "none",
                        "description": "Opens the BottomPanelRegion, if it is present in the current shell.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "CloseBottomRegion",
                    "metadata": {
                        "arguments": "none",
                        "description": "Closes the BottomPanelRegion, if it is present in the current shell.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "RunWorkflowById",
                    "metadata": {
                        "arguments": "string",
                        "description": "Runs a workflow.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "RunWorkflowWithGeometry",
                    "metadata": {
                        "arguments": "object",
                        "description": "Runs a workflow with a geometry used as an input argument.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "RunWorkflowWithArguments",
                    "metadata": {
                        "arguments": "object",
                        "description": "Runs a workflow with a set of input arguments.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "DisplayWorkflowContainerContent",
                    "metadata": {
                        "arguments": "object",
                        "description": "Displays a view in a workflow container.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "ClearActiveTool",
                    "metadata": {
                        "arguments": "none",
                        "description": "Clears the active tool.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "SetActiveTool",
                    "metadata": {
                        "arguments": "string",
                        "description": "Sets the active tool.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "Geolocate",
                    "metadata": {
                        "arguments": "object",
                        "description": "Zooms to the current location of the device when it becomes available.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "GeolocateTrack",
                    "metadata": {
                        "arguments": "none",
                        "description": "Enables the tracking of the device's location when it is available, without panning the map.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "GeolocateFollow",
                    "metadata": {
                        "arguments": "none",
                        "description": "Enables the following of the device's location when it is available, panning the map.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "GeolocateStop",
                    "metadata": {
                        "arguments": "none",
                        "description": "Stops the tracking and following of the device's location.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "GeolocateShowBuffer",
                    "metadata": {
                        "arguments": "none",
                        "description": "Display a circular buffer showing the accuracy of the latest GPS reading.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "GeolocateHideBuffer",
                    "metadata": {
                        "arguments": "none",
                        "description": "Hide a circular buffer showing the accuracy of the latest GPS reading.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "TakeApplicationOffline",
                    "metadata": {
                        "arguments": "none",
                        "description": "Puts the application in an offline state.",
                        "isHyperlinkable": false,
                        "visibility": "public"
                    }
                },
                {
                    "name": "TapToDismiss",
                    "metadata": {
                        "arguments": "args: {view: framework.ui.ViewBase; onOtherInteracted?: (evt?: Event) => void ; onElementInteracted?: (evt?: Event) => void}",
                        "description": "Dismisses the specified view on the next tap anywhere on the screen. Optionally fires specified callbacks.",
                        "isHyperlinkable": false,
                        "visibility": "private"
                    }
                },
                {
                    "name": "TakeApplicationOnline",
                    "metadata": {
                        "arguments": "none",
                        "description": "Connects the application to the internet.",
                        "isHyperlinkable": false,
                        "visibility": "public"
                    }
                },
                {
                    "name": "SetGMAFOfflineButtonState",
                    "metadata": {
                        "arguments": "string",
                        "description": "Sets the visibility of the online/offline button in the GMAF app.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ToggleConnectivity",
                    "metadata": {
                        "arguments": "none",
                        "description": "Toggles the connectivity of the app, from offline to online or viceversa",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "RefreshOfflineMapsList",
                    "metadata": {
                        "arguments": "string",
                        "description": "Refresh the list of offline maps on the OfflineMapsList view.",
                        "isHyperlinkable": false,
                        "visibility": "public"
                    }
                },
                {
                    "name": "OpenFeatureSetCollection",
                    "metadata": {
                        "arguments": "string",
                        "description": "Opens the FeatureSetCollection.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "OpenPortalMyContentWindow",
                    "metadata": {
                        "arguments": "none",
                        "description": "Opens a new browser window to the authenticated users ArcGIS Portal 'My Content' page.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "CloseFeatureSetCollection",
                    "metadata": {
                        "arguments": "string",
                        "description": "Closes the FeatureSetCollection.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "RemoveFeatureSetCollection",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection",
                        "description": "Removes the specified collection from the FeatureSetManager.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "RemoveFeatureSetCollectionById",
                    "metadata": {
                        "arguments": "string",
                        "description": "Removes the collection specified by ID from the FeatureSetManager.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "Search",
                    "metadata": {
                        "arguments": "string",
                        "description": "Performs a search on all active providers.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "GlobalSearch",
                    "metadata": {
                        "arguments": "string",
                        "description": "Performs a search on all active providers.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "BufferGeometry",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.buffer.BufferGeometryArgs",
                        "description": "Buffers input geometry, adds buffer markup to the map, and fires the callback and event with the buffered geometry. When the source command is specified, buffers using current settings for the command.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "CancelEditCoordinate",
                    "metadata": {
                        "arguments": "none",
                        "description": "Cancels editing of a coordinate if currently active.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "CancelSearch",
                    "metadata": {
                        "arguments": "none",
                        "description": "Cancel the search on all providers.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ClearSearch",
                    "metadata": {
                        "arguments": "none",
                        "description": "Clear the search results.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ClearSelection",
                    "metadata": {
                        "arguments": "none",
                        "description": "Clears the open identify results/selection.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowExportWebMapDialog",
                    "metadata": {
                        "arguments": "none",
                        "description": "Activates the export web map view.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowFeatureDetails",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.Feature",
                        "description": "Creates and displays the Feature Details dialog for the Feature or FeatureSetCollection specified.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "ShowFeatureDetailsCompact",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.Feature",
                        "description": "Creates and displays the Feature Details dialog for the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature} in Compact View mode. If the feature is not specified, details for the last feature will be displayed.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "ShowFeatureDetailsExpanded",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.Feature",
                        "description": "Creates and displays the Feature Details dialog for the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature} in Expanded View mode. If the feature is not specified, details for the last feature will be displayed.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "SetFeatureDetailsMode",
                    "metadata": {
                        "arguments": "string",
                        "description": "Sets the feature details dialog to the specified view mode.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowFeatureParentDetails",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.Feature",
                        "description": "Shows the previously opened feature when browsing related features in the feature details view.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "ShowFeatureAttributeEditor",
                    "metadata": {
                        "arguments": "none",
                        "description": "Shows the feature attribute editor used to set feature attributes.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "HideFeatureAttributeEditor",
                    "metadata": {
                        "arguments": "none",
                        "description": "Hides the feature attribute editor used to set feature attributes.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowFeatureTemplatePicker",
                    "metadata": {
                        "arguments": "layer",
                        "description": "Shows the feature template picker used to create new features. If a layer is supplied, shows the templates for the layer.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "HideFeatureTemplatePicker",
                    "metadata": {
                        "arguments": "none",
                        "description": "Hides the feature template picker used to create new features.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "FSMCollectionSetCommand",
                    "metadata": {
                        "arguments": "string, string",
                        "description": "Set the preferred command to open the FeatureSetCollection for the given source name.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "PanToAllFeatures",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.Feature[]",
                        "description": "Pans to the extent of all the features.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "PanToFeature",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.Feature",
                        "description": "Pans to a Geocortex feature.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "PanToFeatureIfOutsideMapExtent",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.Feature",
                        "description": "Pans to a Geocortex feature if the feature is outside of the map's extent, otherwise nothing happens.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "Project",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.commandArgs.ProjectArgs",
                        "description": "Calls a geometry service to project geometries between different coordinate systems.",
                        "isHyperlinkable": false,
                        "visibility": "private"
                    }
                },
                {
                    "name": "InvokeMapTip",
                    "metadata": {
                        "arguments": "esri.geometry.Geometry",
                        "description": "Executes an Identify operation on the given geometry and sets \"MapTip\" as its source tag.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "ShowMapTip",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.Feature",
                        "description": "Displays a feature in the map tip view.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "ShowMapTipInCallout",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.Feature",
                        "description": "Displays a feature in a map tip callout anchored to the map.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "SuspendMapTips",
                    "metadata": {
                        "arguments": "none",
                        "description": "Suspends the display of map tips, allowing other components the opportunity to interact with the map without invoking map tips on click/tap events.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "SwitchToLayerTheme",
                    "metadata": {
                        "arguments": "string",
                        "description": "Switches to the specified layer theme, identified by ID or display name.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ResumeMapTips",
                    "metadata": {
                        "arguments": "none",
                        "description": "Resumes the previously suspended display of map tips.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ClearStorageForApplication",
                    "metadata": {
                        "arguments": "none",
                        "description": "Clears the offline data for the current application.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ClearStorageForDomain",
                    "metadata": {
                        "arguments": "none",
                        "description": "Clears all offline data for the current domain. This includes data for all applications loaded from the current domain.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ListReports",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection",
                        "description": "Presents a user interface for choosing to run a report from a list of reports that are available to the given reportable input (group of features).",
                        "isHyperlinkable": false,
                        "visibility": "public"
                    }
                },
                {
                    "name": "RunFeatureReport",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.Feature",
                        "description": "Alias to 'ListReports' for backwards compatibility with the Silverlight viewer.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "RunFeaturesReport",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection",
                        "description": "Alias to 'ListReports' for backwards compatibility with the Silverlight viewer.",
                        "isHyperlinkable": false,
                        "visibility": "public"
                    }
                },
                {
                    "name": "RunReport",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.commandArgs.RunReportArgs",
                        "description": "Runs a given report on the provided features, and displays the result (a download link to the report file) to the user.",
                        "isHyperlinkable": false,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowResultsList",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection",
                        "description": "Displays the list of features in the given FeatureSetCollection as a list.",
                        "isHyperlinkable": false,
                        "visibility": "private"
                    }
                },
                {
                    "name": "ShowResultsTable",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection",
                        "description": "Displays the list of features in the given FeatureSetCollection in a tabular view.",
                        "isHyperlinkable": false,
                        "visibility": "private"
                    }
                },
                {
                    "name": "SwitchToListResultsView",
                    "metadata": {
                        "arguments": "none",
                        "description": "Switches from Results Table to Results List view if the Results Table view is currently active.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "SwitchToTabularResultsView",
                    "metadata": {
                        "arguments": "none",
                        "description": "Switches from Results List to Results Table view if the Results List view is currently active.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "OpenResultsFrame",
                    "metadata": {
                        "arguments": "none",
                        "description": "Activates the ResultsRegion.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "CloseResultsFrame",
                    "metadata": {
                        "arguments": "none",
                        "description": "Deactivates the ResultsRegion.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowLayerList",
                    "metadata": {
                        "arguments": "none",
                        "description": "Displays the layer list.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "SwitchToLayerView",
                    "metadata": {
                        "arguments": "none",
                        "description": "Displays the layer list.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "SwitchToLegendView",
                    "metadata": {
                        "arguments": "none",
                        "description": "Displays the legend view.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowLayerActions",
                    "metadata": {
                        "arguments": "geocortex.essentials.Layer",
                        "description": "Shows available actions for a given layer.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "ShowMapServiceActions",
                    "metadata": {
                        "arguments": "geocortex.essentials.MapService",
                        "description": "Shows available actions for a given map service.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "HideMapServiceActions",
                    "metadata": {
                        "arguments": "none",
                        "description": "Closes the map service actions view.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "PulseStatus",
                    "metadata": {
                        "arguments": "string",
                        "description": "Resets the timer of the status view model.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "RemoveStatus",
                    "metadata": {
                        "arguments": "string",
                        "description": "Removes the status indicator from the screen with the specified ID.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "AddStatus",
                    "metadata": {
                        "arguments": "string",
                        "description": "Adds a status indicator to the screen.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "CreateHighlightLayer",
                    "metadata": {
                        "arguments": "string",
                        "description": "Creates a new highlight layer with the specified name.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "SetActiveHighlightLayer",
                    "metadata": {
                        "arguments": "string",
                        "description": "Sets the layer with the specified name as active, if there is one.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "SetActiveHighlightLayerDefault",
                    "metadata": {
                        "arguments": "none",
                        "description": "Sets the default highlight layer as the active highlight layer.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "HighlightEsriFeatureSet",
                    "metadata": {
                        "arguments": "esri.tasks.FeatureSet",
                        "description": "Highlights all of the features in the specified Esri feature set in the active highlight layer.",
                        "isHyperlinkable": false,
                        "visibility": "private"
                    }
                },
                {
                    "name": "SetHighlightBorderColor",
                    "metadata": {
                        "arguments": "string",
                        "description": "Sets the border color used for new highlights, specified in 6 or 8 digit hex in RGB or ARGB form.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "SetHighlightBorderWidth",
                    "metadata": {
                        "arguments": "number",
                        "description": "Sets the border width (in pixels) used for new highlights.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "SetHighlightFillColor",
                    "metadata": {
                        "arguments": "string",
                        "description": "Sets the current highlight fill color to use, if the feature does not specify one.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "RemoveHighlightLayer",
                    "metadata": {
                        "arguments": "string",
                        "description": "Removes the highlight layer with the specified name, if there is one.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "AddMapService",
                    "metadata": {
                        "arguments": "essentials.MapService",
                        "description": "Integrate a map service and its sub-components into the viewer and onto the map.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "RemoveMapService",
                    "metadata": {
                        "arguments": "essentials.MapService",
                        "description": "Removes a user added map service off of the map and out of the viewer.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "RemoveUserAddedLayer",
                    "metadata": {
                        "arguments": "essentials.Layer",
                        "description": "Remove a user added layer (and its parent map service) off of the map and out of the viewer.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "ClearHighlights",
                    "metadata": {
                        "arguments": "none",
                        "description": "Removes the highlights from the active highlight layer.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ClearDefaultHighlights",
                    "metadata": {
                        "arguments": "none",
                        "description": "Removes the highlights from the default highlight layer.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "HighlightFeatureSet",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.FeatureSet",
                        "description": "Highlights all of the features in the specified feature set in the active highlight layer.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "HighlightFeature",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.Feature",
                        "description": "Highlights the feature in the active highlight layer.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "HighlightFeatureDefault",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.Feature",
                        "description": "Highlights the feature in the default highlight layer.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "AddMarkup",
                    "metadata": {
                        "arguments": "esri.geometry.Geometry",
                        "description": "Adds the given geometry to the markup layer.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "AddMarkupGeometry",
                    "metadata": {
                        "arguments": "esri.geometry.Geometry",
                        "description": "Adds the given geometry to the markup layer.  (Identical to the AddMarkup command.)",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "AddTextMarkup",
                    "metadata": {
                        "arguments": "esri.geometry.Geometry",
                        "description": "Prompts the user for text to add as markup. When completed, text markup is added at the provided geometry.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "ClearMarkup",
                    "metadata": {
                        "arguments": "none",
                        "description": "Prompts the user for confirmation, and if approved, clears all of the markup from the markup layer.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ClearMarkupQuiet",
                    "metadata": {
                        "arguments": "none",
                        "description": "Clears all of the markup from the markup layer without prompting for confirmation.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "MeasureDistance",
                    "metadata": {
                        "arguments": "esri.geometry.Polyline",
                        "description": "Computes the total and segment distance measurements for the specified Polyline geometry and plots it on the map along with its measurements. NOTE: An Esri or Geocortex feature may also be provided as arguments in lieu of a polyline geometry.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "MeasureArea",
                    "metadata": {
                        "arguments": "esri.geometry.Polygon",
                        "description": "Computes the area, perimeter and individual segment distances for the specified Polylgon geometry and plots it on the map along with its measurements. NOTE: An Esri or Geocortex feature may also be provided as arguments in lieu of a polygon geometry.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "DeleteMeasurement",
                    "metadata": {
                        "arguments": "esri.geometry.Geometry",
                        "description": "Deletes measurement markup within the given geometry",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "SetMeasurementUnits",
                    "metadata": {
                        "arguments": "string, string",
                        "description": "Sets the measurement units for the measurements performed by the measurement module. Also updates existing measurements already on the map.",
                        "isHyperlinkable": false,
                        "visibility": "private"
                    }
                },
                {
                    "name": "ResizeShell",
                    "metadata": {
                        "arguments": "none",
                        "description": "Recalculate the size and layout of the shell and refresh the shell accordingly.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ActivateHomePanel",
                    "metadata": {
                        "arguments": "none",
                        "description": "Activates Home Panel if it is configured to be included.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ActivatePlotCoordinatesView",
                    "metadata": {
                        "arguments": "none",
                        "description": "Activates the Plot Coordinates view.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowHomePanel",
                    "metadata": {
                        "arguments": "none",
                        "description": "Activates Home Panel if it is configured to be included.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "HideHomePanel",
                    "metadata": {
                        "arguments": "none",
                        "description": "Deactivates/hides the Home Panel if it is configured to be included.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "AttachFileToFeature",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.Feature",
                        "description": "Checks for HTML5 FileReader / Cordova support and activates File Attachments if supported.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "ToggleToolbar",
                    "metadata": {
                        "arguments": "none",
                        "description": "Toggles the visibility of the toolbar if present.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "OpenToolbar",
                    "metadata": {
                        "arguments": "none",
                        "description": "Opens the toolbar, if present.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "CloseToolbar",
                    "metadata": {
                        "arguments": "none",
                        "description": "Closes the toolbar, if present.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "PrintMap",
                    "metadata": {
                        "arguments": "none",
                        "description": "Displays a dialog to create a printable map.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowExportMapDialog",
                    "metadata": {
                        "arguments": "none",
                        "description": "Displays a dialog to save a map image.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowLayerCatalog",
                    "metadata": {
                        "arguments": "none",
                        "description": "Shows the layer catalog view.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ActivateTimeSlider",
                    "metadata": {
                        "arguments": "none",
                        "description": "Activates and shows the Time Slider if time slider profiles are available in the site.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "DeactivateTimeSlider",
                    "metadata": {
                        "arguments": "none",
                        "description": "Deactivates time settings applied to the map and hides the Time Slider.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "HideTimeSlider",
                    "metadata": {
                        "arguments": "none",
                        "description": "Hides the time slider if currently visible but does not deactivate time settings applied to the map.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowTimeSliderSettings",
                    "metadata": {
                        "arguments": "none",
                        "description": "Shows the time slider settings view.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "HideTimeSliderSettings",
                    "metadata": {
                        "arguments": "none",
                        "description": "Hides the time slider settings view.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ToggleTimeSliderActions",
                    "metadata": {
                        "arguments": "none",
                        "description": "Toggles the time slider actions container visibility.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "SetTimeSliderProfile",
                    "metadata": {
                        "arguments": "none",
                        "description": "Validates and sets a specified time slider profile.",
                        "isHyperlinkable": false,
                        "visibility": "private"
                    }
                },
                {
                    "name": "AddCatalogLayers",
                    "metadata": {
                        "arguments": "Comma seperated string of layer ids.",
                        "description": "Adds catalog layers.",
                        "isHyperlinkable": false,
                        "visibility": "public"
                    }
                },
                {
                    "name": "AppendCatalogLayers",
                    "metadata": {
                        "arguments": "Comma seperated string of layer ids.",
                        "description": "Appends catalog layers.",
                        "isHyperlinkable": false,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ClearLayerCatalogLayers",
                    "metadata": {
                        "arguments": "none",
                        "description": "Clears all catalog layers.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "RemoveLayerCatalogIds",
                    "metadata": {
                        "arguments": "A string array of CatalogIds to be removed",
                        "description": "Removes specific catalog layers",
                        "isHyperlinkable": false,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowBookmarks",
                    "metadata": {
                        "arguments": "none",
                        "description": "Displays the Bookmarked Locations menu if the BookmarkViewModel's property, bookmarksEnabled, is set to true.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "AddBookmark",
                    "metadata": {
                        "arguments": "string",
                        "description": "Bookmark the current extent with the given name.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowAddBookmark",
                    "metadata": {
                        "arguments": "none",
                        "description": "Prompts the user to bookmark the current extent by entering a name.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowCoordinateActions",
                    "metadata": {
                        "arguments": "string",
                        "description": "Shows the configured coordinate actions.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "RemoveBookmark",
                    "metadata": {
                        "arguments": "string",
                        "description": "Removes a bookmark with the given name if exists.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "SelectBaseMap",
                    "metadata": {
                        "arguments": "string",
                        "description": "A map can have a number of basemaps associated with it. SelectBaseMap allows you to programmatically select one of the basemaps to display. All other basemaps are then faded out.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ActivateSelectLayersForIdentify",
                    "metadata": {
                        "arguments": "none",
                        "description": "Activates the Layer Selector for Identify and applies current settings.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "DeactivateSelectLayersForIdentify",
                    "metadata": {
                        "arguments": "none",
                        "description": "Deactivates the Layer Selector for Identify and enables all default identifiable layers.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ActivateBuffering",
                    "metadata": {
                        "arguments": "string|string[]",
                        "description": "Activates buffering for the specified command(s). Uses currently configured settings for the command.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ActivateBufferingAndDisplayOptions",
                    "metadata": {
                        "arguments": "string",
                        "description": "Activates buffering for the specified command and displays the associated Buffer Options dialog. ",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ActivateTransientElements",
                    "metadata": {
                        "arguments": "string",
                        "description": "Activates any transient elements configured against a specific ID in the toolbar module.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "DeactivateBuffering",
                    "metadata": {
                        "arguments": "string|string[]",
                        "description": "Deactivates buffering, if active, for the specified command(s).",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "DeactivateBufferingAndDismissOptions",
                    "metadata": {
                        "arguments": "string",
                        "description": "Deactivates buffering for the specified command and dismisses the associated Buffer Options dialog if its active. ",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "DeactivateTransientElements",
                    "metadata": {
                        "arguments": "string",
                        "description": "Deactivates any transient elements configured against a specific ID in the toolbar module.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "DeleteAllCoordinates",
                    "metadata": {
                        "arguments": "none",
                        "description": "Deletes all plotted Coordinates from the map.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "DeleteCoordinates",
                    "metadata": {
                        "arguments": "string|string[]",
                        "description": "Deletes one or many plotted Coordinates from the map.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "EditCoordinate",
                    "metadata": {
                        "arguments": "string|null",
                        "description": "Edits a plotted Coordinate on the map or creates a new coordinate in edit mode if no descriptor Id is provided.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "EditMarkup",
                    "metadata": {
                        "arguments": "esri.geometry.Geometry",
                        "description": "Edits markup that intersects the extent of the provided geometry.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "DeleteMarkup",
                    "metadata": {
                        "arguments": "esri.geometry.Geometry",
                        "description": "Deletes markup within the given geometry",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "CreateMarkupStyleView",
                    "metadata": {
                        "arguments": "string",
                        "description": "Activates the style picker if 'point', 'polyline', 'polygon', or 'text' is the string provided. If it is null, then the app will try and detect what style selector to activate.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ChangeMarkupStyle",
                    "metadata": {
                        "arguments": "MarkupTemplate",
                        "description": "Takes a MarkupTemplate, PointTemplate, PolylineTemplate, PolygonTemplate, or TextTemplate. It will change the style of the markup to suit the template provided.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "StopEditingMarkup",
                    "metadata": {
                        "arguments": "boolean",
                        "description": "Stops editing. If arg is true, clears the active tool, if arg is false, doesn't clear active tool.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "StartEditingFeature",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.Feature",
                        "description": "Shows the editing form.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "EnableSearchRefinement",
                    "metadata": {
                        "arguments": "boolean",
                        "description": "Enables or disables the refinement of a global search from within search hints (if any).",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ExportResultsTo",
                    "metadata": {
                        "arguments": "{ format: string, fsc: geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection }",
                        "description": "Enables or disables the refinement of a global search from within search hints (if any).",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "ExportMarkupLayer",
                    "metadata": {
                        "arguments": "none",
                        "description": "Exports markup layer.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ExportGraphicsLayer",
                    "metadata": {
                        "arguments": "{ args:  geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.ExportGraphicsLayerArgs}",
                        "description": "Exports graphics layer.",
                        "isHyperlinkable": false,
                        "visibility": "public"
                    }
                },
                {
                    "name": "HideAllCoordinates",
                    "metadata": {
                        "arguments": "none",
                        "description": "Hides all plotted Coordinates temporarily.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "HideCoordinates",
                    "metadata": {
                        "arguments": "string|string[]",
                        "description": "Hides one or many plotted Coordinates temporarily.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "HideCoordinateActions",
                    "metadata": {
                        "arguments": "none",
                        "description": "Hide any coordinate actions view that is currently open.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "SignIn",
                    "metadata": {
                        "arguments": "string",
                        "description": "Navigates to the sign-in page. The sign in experience can be customized by crafting a custom sign-in URL, otherwise the default sign-in URL for the site will be used.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "SignOut",
                    "metadata": {
                        "arguments": "string",
                        "description": "Navigates to the sign-out page, which will sign the current user out.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "LogOptimizerEvent",
                    "metadata": {
                        "arguments": "string, string",
                        "description": "Logs an event for Geocortex Optimizer.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "AddPushpin",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.Feature",
                        "description": "Creates and displays a pushpin for the Feature specified.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "AddPushpins",
                    "metadata": {
                        "arguments": "string",
                        "description": "Creates and displays pushpins for the FeatureSetCollection specified.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "RemovePushpin",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.Feature",
                        "description": "Removes the pushpin from the map for the given feature, if there is one.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "RemovePushpins",
                    "metadata": {
                        "arguments": "none",
                        "description": "Removes all pushpins from the map.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "EnablePushpins",
                    "metadata": {
                        "arguments": "none",
                        "description": "Enables the display of pushpins/markers on the map.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "DisablePushpins",
                    "metadata": {
                        "arguments": "none",
                        "description": "Disables the display of pushpins/markers on the map.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowPushpins",
                    "metadata": {
                        "arguments": "none",
                        "description": "Displays pushpins by setting their visibility to true, for each result in the results list or results table.  Pushpins must be enabled for this command to work.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "StopFeaturePlacementState",
                    "metadata": {
                        "arguments": "none",
                        "description": "Cancels any feature placement while a feature is being created or edited.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "HidePushpins",
                    "metadata": {
                        "arguments": "none",
                        "description": "Prevents the display of pushpins by setting their visibility to false.  Pushpins must be enabled for this command to work.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "SetCollectionOfInterest",
                    "metadata": {
                        "arguments": "string",
                        "description": "Sets the FeatureSetCollection of interest that will be used to generate data for Charts.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowChartingView",
                    "metadata": {
                        "arguments": "none",
                        "description": "Activates the charting view.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "DisplayBufferOptions",
                    "metadata": {
                        "arguments": "string",
                        "description": "Displays the Buffer Options dialog for the specified target command",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "DisplayChartById",
                    "metadata": {
                        "arguments": "string",
                        "description": "Opens the specified chart in the charting view.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "RemoveChartById",
                    "metadata": {
                        "arguments": "string",
                        "description": "Removes the specified chart from the charting view.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ClearCharts",
                    "metadata": {
                        "arguments": "none",
                        "description": "Removes all charts from the charting view.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ClearFeatureInformation",
                    "metadata": {
                        "arguments": "none",
                        "description": "Used to 'reset' the information stored within RelatedFeatures (which features are currently open, etc.)",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "DisableMapClick",
                    "metadata": {
                        "arguments": "none",
                        "description": "Prevents the commands configured to execute on map click from executing and also prevents the MapClickedEvent from firing.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "DisableMapTips",
                    "metadata": {
                        "arguments": "none",
                        "description": "Disables the display of map tips on the map.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "EnableAllLayersForIdentify",
                    "metadata": {
                        "arguments": "none",
                        "description": "Enables all identifiable layers such that they participate in Identify operations",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "DisableAllLayersForIdentify",
                    "metadata": {
                        "arguments": "none",
                        "description": "Disables all identifiable layers such that they do not participate in Identify operations",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "EnableLayerForIdentify",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.identify.LayerDescriptor",
                        "description": "Enables the specified layer, if it's identifiable, such that it participates in Identify operations.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "DisableLayerForIdentify",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.identify.LayerDescriptor",
                        "description": "Disables the specified layer, if it's in the list of identifiable layers, such that it does not participate in Identify operations.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "EnableMapClick",
                    "metadata": {
                        "arguments": "none",
                        "description": "Enables all configured commands to execute on map click and also wires up the MapClickEvent to fire when the map is clicked.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "EnableMapTips",
                    "metadata": {
                        "arguments": "none",
                        "description": "Enables the display of map tips on the map.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "HideAllMapTips",
                    "metadata": {
                        "arguments": "none",
                        "description": "Prevents the display of map tips by setting their visibility to `false`.  Map tips must be enabled for this command to work.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "HideMapTips",
                    "metadata": {
                        "arguments": "none",
                        "description": "Prevents the display of map tips by setting their visibility to `false`, and suspends displaying map tips.  Map tips must be enabled for this command to work.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "RestoreAllMapTips",
                    "metadata": {
                        "arguments": "none",
                        "description": "Displays previously hidden map tips by setting their visibility to `true`.  Map tips must be enabled for this command to work.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowAllCoordinates",
                    "metadata": {
                        "arguments": "none",
                        "description": "Shows all plotted coordinates (including temporarily hidden ones) on the map.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowCoordinates",
                    "metadata": {
                        "arguments": "string|string[]",
                        "description": "Shows one or many plotted, hidden Coordinates on the map.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowMapTips",
                    "metadata": {
                        "arguments": "none",
                        "description": "Displays previously hidden map tips by setting their visibility to `true`, and resumes displaying map tips.  Map tips must be enabled for this command to work.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ToggleMouseCoordinates",
                    "metadata": {
                        "arguments": "none",
                        "description": "Toggles the visibility of the mouse coordinates widget if present.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "SetTimeExtent",
                    "metadata": {
                        "arguments": "esri.TimeExtent",
                        "description": "Sets the time extent for the map.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowShareView",
                    "metadata": {
                        "arguments": "none",
                        "description": "Activates the share view",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShareOn",
                    "metadata": {
                        "arguments": "string",
                        "description": "Shares the Viewer url on the specified platform",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ScreenReaderNarrate",
                    "metadata": {
                        "arguments": "string",
                        "description": "If a user has screenreader software enabled, then the provided string is immediately spoken to them.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "DisableScreenReaderNarrate",
                    "metadata": {
                        "arguments": "none",
                        "description": "Disables the 'ScreenReaderNarrate' command temporarily.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "EnableScreenReaderNarrate",
                    "metadata": {
                        "arguments": "none",
                        "description": "Enables screen reader narration if it was previously disabled using DisableScreenReaderNarrate.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "BroadcastCurrentViewpoint",
                    "metadata": {
                        "arguments": "string",
                        "description": "Broadcasts the viewers current viewpoint to the specified external component.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "UpdateStatus",
                    "metadata": {
                        "arguments": "string",
                        "description": "Updates the message shown on the status indicator.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "UploadData",
                    "metadata": {
                        "arguments": "none",
                        "description": "Prompt the user to upload layers onto the map straight from their own computer.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowExternalComponentView",
                    "metadata": {
                        "arguments": "none",
                        "description": "Activates the external component view.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "DisplayDockedExternalComponentById",
                    "metadata": {
                        "arguments": "string",
                        "description": "Opens the specified external component in the external components view. If this component is open in a separate window, it will be closed.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "DisplayUndockedExternalComponentById",
                    "metadata": {
                        "arguments": "string",
                        "description": "Opens the specified external component in a separate window from the viewer. If this component is open in the viewer, it will be closed.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "RemoveExternalComponentById",
                    "metadata": {
                        "arguments": "string",
                        "description": "Removes the specified external component from the viewer. If the component is in a separate window, that window will be closed.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ToggleExternalComponentSyncById",
                    "metadata": {
                        "arguments": "string",
                        "description": "Toggle whether the specified external component is synchronized with the viewer.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "ListenToExternalComponentFrame",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.integration.ComponentFrameInfo",
                        "description": "Wires up a PostMessage Transport and enables bi-directional communication with the component.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "CreateOrEditFeatureFromBarcodeScan",
                    "metadata": {
                        "arguments": "object",
                        "description": "Launch the barcode scanner, and use the result to create a new feature or edit an existing one.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "LaunchBarcodeScannerWithCallback",
                    "metadata": {
                        "arguments": "none",
                        "description": "Lauches a QR scan, then calls the provided callback with the result.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowMarkers",
                    "metadata": {
                        "arguments": "none",
                        "description": "Displays markers by setting their visibility to `true`.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "HideMarkers",
                    "metadata": {
                        "arguments": "none",
                        "description": "Prevents the display of markers by setting their visibility to `false`.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "AddMarker",
                    "metadata": {
                        "arguments": "string",
                        "description": "Creates and displays a marker on the map.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "RemoveMarker",
                    "metadata": {
                        "arguments": "string",
                        "description": "Removes the marker from the map.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "UpdateMarker",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.commandArgs.MarkerArgs",
                        "description": "Updates the marker with the given marker arguments.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "ShowAccessibilityView",
                    "metadata": {
                        "arguments": "none",
                        "description": "Activates the accessibility view.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "AddClusterLayer",
                    "metadata": {
                        "arguments": "string",
                        "description": "Adds a cluster layer to an existing Geocortex Layer that holds an Esri FeatureLayer.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "RemoveClusterLayer",
                    "metadata": {
                        "arguments": "string",
                        "description": "Removes a cluster layer from an existing Geocortex Layer that holds an Esri FeatureLayer.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "AddHeatMap",
                    "metadata": {
                        "arguments": "string",
                        "description": "Adds a heat map visualization to a given Geocortex layer.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "Redo",
                    "metadata": {
                        "arguments": "none",
                        "description": "Reverses the last recorded undo operation or transaction.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "RemoveHeatMap",
                    "metadata": {
                        "arguments": "string",
                        "description": "Removes a heat map visualization from a Geocortex layer.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "RemoveVisualization",
                    "metadata": {
                        "arguments": "string",
                        "description": "Removes the visualization from a Geocortex layer, if one is enabled.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowVisualizationView",
                    "metadata": {
                        "arguments": "string",
                        "description": "Shows the visualization options view for a given Geocortex layer if the layer supports any visualizations.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "Undo",
                    "metadata": {
                        "arguments": "none",
                        "description": "Invokes the last recorded undo operation or transaction.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "CreateGraphicsInMemory",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.commandArgs.EditInMemoryArgs",
                        "description": "Creates new graphics. These edits are only applied to the graphics layer in memory.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "UpdateGraphicsInMemory",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.commandArgs.UpdateGraphicsArgs",
                        "description": "Updates existing graphics. These edits are only applied to the graphics layer in memory.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "DeleteGraphicsInMemory",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.commandArgs.EditInMemoryArgs",
                        "description": "Deletes graphics. These edits are only applied to the graphics layer in memory.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "CutGraphicsInMemory",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.commandArgs.CutGraphicsArgs",
                        "description": "Cut graphics using a polyline. These edits are only applied to the graphics layer in memory.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "ExplodeGraphicsInMemory",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.commandArgs.EditInMemoryArgs",
                        "description": "Separates multi-part graphics into individual graphics. These edits are only applied to the graphics layer in memory.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "UnionGraphicsInMemory",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.commandArgs.EditInMemoryArgs",
                        "description": "Merge graphics into a single graphic. These edits are only applied to the graphics layer in memory.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "DeleteProject",
                    "metadata": {
                        "arguments": "string",
                        "description": "Deletes a project.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "LoadProject",
                    "metadata": {
                        "arguments": "string",
                        "description": "Loads a project and applies it to the viewer.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ListSelections",
                    "metadata": {
                        "arguments": "none",
                        "description": "List the available selections.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "RefreshProjectsList",
                    "metadata": {
                        "arguments": "none",
                        "description": "Refresh the list of browsable projects.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "RegisterChartPointAdapter",
                    "metadata": {
                        "arguments": "object",
                        "description": "Register the chart point adapter.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "SaveAsProject",
                    "metadata": {
                        "arguments": "none",
                        "description": "Displays the user interface to fill in details about a project to be saved.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "SaveProject",
                    "metadata": {
                        "arguments": "none",
                        "description": "Save the current state of the viewer as a project or displays the user interface to fill in details about the project to be saved.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowProjectEditor",
                    "metadata": {
                        "arguments": "string",
                        "description": "Shows the user interface for editing a project.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowProjects",
                    "metadata": {
                        "arguments": "none",
                        "description": "Shows the user interface for browsing and loading projects.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowShareProject",
                    "metadata": {
                        "arguments": "string",
                        "description": "Shows the user interface for sharing projects.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "HideFeatureDetails",
                    "metadata": {
                        "arguments": "none",
                        "description": "Hides the Feature Details dialog.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ShowSaveSelectionDialog",
                    "metadata": {
                        "arguments": "string",
                        "description": "Displays a dialog to save a FeatureSetCollection as a named selection.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "CreateSelection",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.commandArgs.SelectionArgs",
                        "description": "Creates a new named, saved selection based on the supplied FeatureSetCollection.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "DeleteSelection",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.commandArgs.SelectionArgs",
                        "description": "Deletes a named selection.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "FindSelection",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.commandArgs.FindSelectionArgs",
                        "description": "Looks up a particular named selection.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "RenameSelection",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.commandArgs.RenameSelectionArgs",
                        "description": "Assigns a new name to a saved selection.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "RestoreSelection",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.commandArgs.SelectionArgs",
                        "description": "Loads a named, saved selection into the results view.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "UpdateSelection",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.commandArgs.SelectionArgs",
                        "description": "Updates an existing named, saved selection with the supplied FeatureSetCollection.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "UpdateSelectionFindAllSelectionMetadata",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.commandArgs.FindAllSelectionMetadataArgs",
                        "description": "Lists all the available metadata for named selections.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "FindMetadataForSelection",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.commandArgs.FindMetadataForSelectionArgs",
                        "description": "Looks up metadata about a particular named selection.",
                        "isHyperlinkable": true,
                        "visibility": "private"
                    }
                },
                {
                    "name": "AddFeatureToResults",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.Feature",
                        "description": "Adds an individual feature to the current FeatureSetCollection displayed in the results view.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "RemoveFeatureFromResults",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.Feature",
                        "description": "Removes an individual feature from the current FeatureSetCollection displayed in the results view.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "CombineResults",
                    "metadata": {
                        "arguments": "essentialsHtmlViewer.mapping.infrastructure.commandArgs.CombineResultsArgs",
                        "description": "Performs advanced set operations with multiple lists of results.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "CombineResultsInteractive",
                    "metadata": {
                        "arguments": "object",
                        "description": "Performs advanced set operations with multiple lists of results.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ResultsIntersect",
                    "metadata": {
                        "arguments": "string",
                        "description": "Only keeps results from the current set of results that also appear in the supplied FeatureSetCollection.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ResultsReplace",
                    "metadata": {
                        "arguments": "string",
                        "description": "Replaces the current set of results with the FeatureSetCollection supplied as argument.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ResultsSubtract",
                    "metadata": {
                        "arguments": "string",
                        "description": "Removes the supplied FeatureSetCollection from the current set of results.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "ResultsUnion",
                    "metadata": {
                        "arguments": "string",
                        "description": "Adds the supplied FeatureSetCollection to the current set of results.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "AddResultsStatus",
                    "metadata": {
                        "arguments": "string",
                        "description": "Displays a status indicator that can relay short messages in the results list or table.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                },
                {
                    "name": "RemoveResultsStatus",
                    "metadata": {
                        "arguments": "none",
                        "description": "Removes the status indicator from the results list or table.",
                        "isHyperlinkable": true,
                        "visibility": "public"
                    }
                }
            ];
            ;
            /**
             * Returns the metadata for a given command name, or null if one is not found
             * @private
             * @param commandName The name of the command of interest
             * @returns Object representing command metadata
             */
            function metadataForCommandName(commandName) {
                for (var i = 0; i < Commands.commandsMetadata.length; i++) {
                    var command = Commands.commandsMetadata[i];
                    if (command.name === commandName) {
                        return command.metadata;
                    }
                }
                return null;
            }
            Commands.metadataForCommandName = metadataForCommandName;
            /**
             * Returns the metadata for a given command name, or null if one is not found
             * @private
             */
            function publicCommands() {
                var commands = [];
                for (var i = 0; i < Commands.commandsMetadata.length; i++) {
                    var command = Commands.commandsMetadata[i];
                    if (command.metadata.visibility === "public") {
                        commands.push(command);
                    }
                }
                return commands;
            }
            Commands.publicCommands = publicCommands;
        })(Commands = essentialsHtmlViewer.Commands || (essentialsHtmlViewer.Commands = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                /** Queue of URIs requiring user input. Shared across all instances of ContentPolicy. */
                var _uriConfirmationQueue = [];
                /** Acts as a semaphore for _uriQueue so that only one instance can process it at a time. */
                var _isProcessingQueue = false;
                /**
                 * Content Policy Facility screens URIs to ensure their safety.
                 */
                var ContentPolicy = (function () {
                    function ContentPolicy(app) {
                        this._debounceInterval = 250;
                        this._flags = 0;
                        this._app = app;
                    }
                    ContentPolicy.prototype.hasFlag = function (flag) {
                        return (this._flags & flag) === flag;
                    };
                    ContentPolicy.prototype.setFlag = function (flag) {
                        this._flags |= flag;
                    };
                    /**
                     * Screen a collection of URI details.
                     */
                    ContentPolicy.prototype.screenUris = function (uris) {
                        if (!this._siteValidator) {
                            this._siteValidator = new infrastructure.validation.SiteUrlValidator(this._app);
                        }
                        var urisToValidate = [];
                        for (var _i = 0, uris_1 = uris; _i < uris_1.length; _i++) {
                            var details = uris_1[_i];
                            var uriBeforeScreening = details.uri;
                            details.uri = this._screenDataUri(details.uri);
                            if (details.uri === null) {
                                this._app.trace.debug("Skipped unknown, untrusted data URI.");
                                continue;
                            }
                            urisToValidate.push(details);
                        }
                        return this._validateUris(urisToValidate);
                    };
                    ContentPolicy.prototype.tryScreenNavLinkSynchronously = function (uri) {
                        if (!this._siteValidator) {
                            return false;
                        }
                        // Check the `SiteUrlValidator` for a Site-trusted URL first.
                        var allowed = this._siteValidator.tryValidateSynchronously(uri.uri);
                        if (allowed) {
                            return allowed;
                        }
                        // No? Look for a memoized result from the user.
                        return this._getMemoizedResult(uri) || false;
                    };
                    ContentPolicy.prototype._validateUris = function (uris) {
                        var _this = this;
                        var urisToPromptFor = [];
                        var validationPromises = [];
                        validationPromises = uris.map(function (uri) {
                            return new Promise(function (resolve, reject) {
                                var originalUri = uri.uri;
                                // GVH-10205: Allow image sources through.
                                if (_this.hasFlag(2 /* DisablePromptOnImages */) && uri.type === infrastructure.FilterUtils.UriType.Markup) {
                                    var markupUri = uri;
                                    if (markupUri.tag === "img" && markupUri.attribute === "src") {
                                        return resolve(uri);
                                    }
                                }
                                return _this._validateUriAgainstSite(uri)
                                    .then(function (result) {
                                    // If the Site URI validator scrubbed the value, we'll want to prompt the user.
                                    if (result.validatedValue == null || result.validatedValue === "") {
                                        uri.uri = originalUri;
                                        urisToPromptFor.push(uri);
                                        return resolve(null);
                                    }
                                    else {
                                        // We may need to force the prompt, since we've jumped into async code. This is to avoid
                                        // popup blockers shutting us down.
                                        if (uri.type === infrastructure.FilterUtils.UriType.NavigableLink && uri.forcePrompt) {
                                            urisToPromptFor.push(uri);
                                        }
                                        return resolve(uri);
                                    }
                                }, function (failure) {
                                    uri.uri = originalUri;
                                    urisToPromptFor.push(uri);
                                    return resolve(uri);
                                });
                            });
                        });
                        return Promise.all(validationPromises)
                            .then(function () { return _this._promptForUris(urisToPromptFor); })
                            .then(function () { return uris; });
                    };
                    ContentPolicy.prototype._validateUriAgainstSite = function (uri) {
                        if (!this._siteValidator) {
                            uri.uri = "";
                            var result = {
                                validatedValue: null
                            };
                            return Promise.resolve(result);
                        }
                        return this._siteValidator.validate(uri.uri);
                    };
                    ContentPolicy.prototype._promptForUris = function (uris) {
                        var _this = this;
                        return Promise.map(uris, function (uri, index) {
                            return new Promise(function (resolve, reject) {
                                // Enqueue a request to prompt the user. We need to ensure that these are only processed
                                // one at a time so that a user's choice can influence whether or not they are prompted
                                // again for subsequent URLs.
                                _this._enqueueConfirmation({ uriDetails: uri, resolve: resolve });
                            });
                        });
                    };
                    ContentPolicy.prototype._enqueueConfirmation = function (uriConfirmation) {
                        _uriConfirmationQueue.push(uriConfirmation);
                        this._processConfirmationQueue();
                    };
                    ContentPolicy.prototype._processConfirmationQueue = function () {
                        if (_isProcessingQueue) {
                            // Another instance is currently processing the queue.
                            return;
                        }
                        _isProcessingQueue = true;
                        try {
                            while (_uriConfirmationQueue.length) {
                                var uriConfirmation = _uriConfirmationQueue.shift();
                                var isWaitingForUserInput = this._getConfirmation(uriConfirmation);
                                if (isWaitingForUserInput) {
                                    // _processQueue will be reinvoked once the user has made a decision.
                                    return;
                                }
                            }
                        }
                        catch (e) {
                            // Release the "semaphore" so that queue processing doesn't stay locked indefinitely.
                            _isProcessingQueue = false;
                            throw e;
                        }
                        _isProcessingQueue = false;
                    };
                    ContentPolicy.prototype._getConfirmation = function (uriConfirmation) {
                        var _this = this;
                        if (!uriConfirmation.uriDetails.forcePrompt && this.hasFlag(1 /* DisableSecurityPrompt */)) {
                            uriConfirmation.resolve(uriConfirmation.uriDetails);
                            return false;
                        }
                        // Navigation URIs links will always be challenged.
                        var isNavigableLink = uriConfirmation.uriDetails.type === infrastructure.FilterUtils.UriType.NavigableLink;
                        var memoizedResult = this._getMemoizedResult(uriConfirmation.uriDetails);
                        if (!isNavigableLink && memoizedResult === true) {
                            // User previously accepted. Skip it.
                            uriConfirmation.resolve(uriConfirmation.uriDetails);
                            return false;
                        }
                        else if (!isNavigableLink && memoizedResult === false) {
                            // User previously declined. Wipe out the URI.
                            uriConfirmation.uriDetails.uri = "";
                            uriConfirmation.resolve(uriConfirmation.uriDetails);
                            return false;
                        }
                        else {
                            // Note that this callback is invoked *synchronously* from the confirmation dialog. This is critical, as we must
                            // remain in synchronous call stacks rooted from user interaction (e.g. tapping on a link) in order to navigate
                            // or otherwise open new window locations on most mobile OSes. Failure to do so invokes popup blocking.
                            var callback = function (resultFromChallenge) {
                                _isProcessingQueue = false;
                                _this._memoizeResult(uriConfirmation.uriDetails, resultFromChallenge);
                                if (resultFromChallenge === true) {
                                    uriConfirmation.resolve(uriConfirmation.uriDetails);
                                }
                                else {
                                    // We still resolve if we fail, we just wipe out the URI.
                                    uriConfirmation.uriDetails.uri = "";
                                    uriConfirmation.resolve(uriConfirmation.uriDetails);
                                }
                                try {
                                    if (isNavigableLink) {
                                        var linkChallengeCallback = uriConfirmation.uriDetails.linkChallengeCallback;
                                        if (linkChallengeCallback) {
                                            linkChallengeCallback(resultFromChallenge, uriConfirmation.uriDetails);
                                        }
                                    }
                                }
                                finally {
                                    // Now we can continue to process the queue.
                                    _this._processConfirmationQueue();
                                }
                            };
                            var confirmArgs = {
                                okLabel: this._app.getResource("Mapping.Infrastructure", "language-content-policy-prompt-uri-accept-btn"),
                                cancelLabel: this._app.getResource("Mapping.Infrastructure", "language-content-policy-prompt-uri-reject-btn")
                            };
                            var title = this._app.getResource("Mapping.Infrastructure", "language-content-policy-prompt-uri-title");
                            var description = this._app.getResource("Mapping.Infrastructure", "language-content-policy-prompt-uri-desc");
                            description = description.format(uriConfirmation.uriDetails.uri);
                            // Use the nice GVH confirm if we can. Otherwise, use an old-fashioned DOM confirm.
                            if (this._app.command("Confirm").canExecute(description, title, callback, confirmArgs)) {
                                this._app.command("Confirm").execute(description, title, callback, confirmArgs);
                            }
                            else {
                                var challengeResult = window.confirm(description);
                                callback(challengeResult);
                                // Confirm will return synchronously, so we are no longer waiting for input here.
                                return false;
                            }
                            // Indicate that we are waiting for user input.
                            return true;
                        }
                    };
                    ContentPolicy.prototype._getMemoizationKey = function (uri) {
                        // By default, If the user accepts http://imageserver.com/images/kitten.gif, then trust everything
                        // else in http://imageserver.com/images. This can be a bit dangerous in some cases (e.g. bit.ly),
                        // but in practice we don't want to spam the user with prompts for dozens of URLs that 
                        // follow a similar pattern. However, if TrustExactUrl flag is set using configuration, we will trust only the exact url
                        // and user might get spammed with multiple prompts for url.
                        var newUrl;
                        if (this.hasFlag(4 /* TrustExactUrl */)) {
                            newUrl = infrastructure.UrlUtils.parseUrl(uri.uri);
                        }
                        else {
                            newUrl = infrastructure.UrlUtils.getFolder(uri.uri);
                        }
                        var uriHash = String.quickHashCode(newUrl.toString());
                        return "uri." + infrastructure.FilterUtils.UriType[uri.type].toLowerCase() + "." + uriHash;
                    };
                    ContentPolicy.prototype._memoizeResult = function (uri, result) {
                        var key = this._getMemoizationKey(uri);
                        window.localStorage.setItem(key, result.toString());
                    };
                    ContentPolicy.prototype._getMemoizedResult = function (uri) {
                        var key = this._getMemoizationKey(uri);
                        var item = window.localStorage.getItem(key);
                        if (item === null) {
                            return null;
                        }
                        else {
                            return item === "true";
                        }
                    };
                    /**
                     * Screen a data URI.
                     */
                    ContentPolicy.prototype._screenDataUri = function (uri) {
                        // Is it a valid data URI?
                        var isDataUri = !!infrastructure.FilterUtils.DataUri.parseDataUri(uri);
                        // Is it a safe data URI?
                        var isDataUriSafe = infrastructure.FilterUtils.DataUri.isDataUriSafe(uri);
                        // Allow the URI if it's not a data URI, or it is a safe one.
                        var allow = (!isDataUri || isDataUriSafe);
                        return allow ? uri : "";
                    };
                    return ContentPolicy;
                }());
                infrastructure.ContentPolicy = ContentPolicy;
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var distances;
                (function (distances) {
                    //#regionConstants
                    var PiOver180 = Math.PI / 180.0;
                    var unitConversion = {};
                    /** Based on the the WGS84 equitorial radius of the Earth, which has a value of 3,963.191 miles.
                    * See http://en.wikipedia.org/wiki/Earth_radius#Equatorial_radius.
                    * (earth radius in km) * (meters per km) * (max precision of pi) * (2r=d)
                    * 6378.1370 * 1000 * 3.1415926535897932384626433832795 * 2
                    * / 360
                    */
                    unitConversion[geocortex.essentials.DistanceUnitType.METERS] = 1;
                    /** The number of meters in a millimeter.*/
                    unitConversion[geocortex.essentials.DistanceUnitType.MILLIMETERS] = 0.001;
                    /** The number of meters in a centimeter.*/
                    unitConversion[geocortex.essentials.DistanceUnitType.CENTIMETERS] = 0.01;
                    /** The number of meters in a decimeter.*/
                    unitConversion[geocortex.essentials.DistanceUnitType.DECIMETERS] = 0.1;
                    /** The number of meters in a kilometer.*/
                    unitConversion[geocortex.essentials.DistanceUnitType.KILOMETERS] = 1000.0;
                    /** The number of meters in an inch.*/
                    unitConversion[geocortex.essentials.DistanceUnitType.INCHES] = 0.0254;
                    /** The number of meters in a foot.*/
                    unitConversion[geocortex.essentials.DistanceUnitType.FEET] = 0.3048;
                    /** The number of meters in a U.S. Survey foot.*/
                    unitConversion[geocortex.essentials.DistanceUnitType.US_SURVEY_FEET] = 0.3048006096012192;
                    /** The number of meters in a yard.*/
                    unitConversion[geocortex.essentials.DistanceUnitType.YARDS] = 0.9144;
                    /** The number of meters in a mile.*/
                    unitConversion[geocortex.essentials.DistanceUnitType.MILES] = 1609.344;
                    /** The number of meters in a nautical mile.*/
                    unitConversion[geocortex.essentials.DistanceUnitType.NAUTICAL_MILES] = 1852.0;
                    /** The number of meters in a degree.*/
                    unitConversion[geocortex.essentials.DistanceUnitType.DEGREES] = 111319.49079327357;
                    /** The number of meters in a grad.*/
                    unitConversion[geocortex.essentials.DistanceUnitType.GRADS] = 100187.54171394621;
                    /** The number of meters in a radian.*/
                    unitConversion[geocortex.essentials.DistanceUnitType.RADIANS] = 6378136.9999999984;
                    //#endregion
                    function _getConversionFactor(targetUnit) {
                        var a = unitConversion[targetUnit];
                        if (a) {
                            return a;
                        }
                        else {
                            throw new Error("Units cannot be converted because are not supported");
                        }
                    }
                    /** @private */
                    function _convertFromMeters(targetUnit, distance) {
                        var conversionFactor = _getConversionFactor(targetUnit);
                        return distance / conversionFactor;
                    }
                    /** @private */
                    function _convertToMeters(targetUnit, distance) {
                        var conversionFactor = _getConversionFactor(targetUnit);
                        return distance * conversionFactor;
                    }
                    /**
                   * Returns true if units are convertible.
                   * @param targetUnit The type of unit we want to convert to
                   * @param sourceUnit The type of unit we are converting from
                   */
                    function canConvert(targetUnit, sourceUnit) {
                        var foundTarget = false, foundSource = false;
                        if (targetUnit === sourceUnit) {
                            return true;
                        }
                        for (var key in geocortex.essentials.DistanceUnitType) {
                            if (geocortex.essentials.DistanceUnitType.hasOwnProperty(key)) {
                                if (geocortex.essentials.DistanceUnitType[key] === targetUnit) {
                                    foundTarget = true;
                                }
                                else if (geocortex.essentials.DistanceUnitType[key] === sourceUnit) {
                                    foundSource = true;
                                }
                            }
                        }
                        return foundSource && foundTarget;
                    }
                    distances.canConvert = canConvert;
                    /**
                     * Converts an unit to another
                     * @param targetUnit The type of unit we want to convert to
                     * @param distance Distance in original unit type
                     * @param sourceUnit The type of unit we are converting from
                     */
                    function convert(targetUnit, distance, sourceUnit) {
                        // No conversion necessary for a 0 distance or if same unit.
                        if (!distance || targetUnit === sourceUnit) {
                            return distance;
                        }
                        var distanceInMeters = _convertToMeters(sourceUnit, distance);
                        //Convert to final target unit type
                        return _convertFromMeters(targetUnit, distanceInMeters);
                    }
                    distances.convert = convert;
                })(distances = infrastructure.distances || (infrastructure.distances = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var accessibility;
                (function (accessibility) {
                    var AccessibilityProviderBase = (function () {
                        function AccessibilityProviderBase(app, libraryId) {
                            this.app = app;
                            this.libraryId = libraryId;
                        }
                        AccessibilityProviderBase.prototype.initialize = function (config) {
                            if (config.id) {
                                this.id = config.id;
                            }
                        };
                        return AccessibilityProviderBase;
                    }());
                    accessibility.AccessibilityProviderBase = AccessibilityProviderBase;
                })(accessibility = infrastructure.accessibility || (infrastructure.accessibility = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var accessibility;
                (function (accessibility) {
                    var InputMethod = (function () {
                        function InputMethod() {
                        }
                        InputMethod.MOUSE = "mouse";
                        InputMethod.KEYBOARD = "keyboard";
                        return InputMethod;
                    }());
                    accessibility.InputMethod = InputMethod;
                })(accessibility = infrastructure.accessibility || (infrastructure.accessibility = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../_Definitions/framework.d.ts"/>
/// <reference path="../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../_Definitions/dojo.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var MatrixUtils = (function () {
                    function MatrixUtils() {
                    }
                    /**
                     * Translates (moves) a given polygon or polyline by a specified offset.
                     * @param geometry The Geometry to rotate.
                     * @param dx The X offset.
                     * @param dy The Y offset.
                     */
                    MatrixUtils.translate = function (geometry, map, dx, dy) {
                        if (!geometry || !map) {
                            return null;
                        }
                        switch (geometry.type) {
                            case "point":
                                var screenPoint = map.toScreen(geometry);
                                geometry = map.toMap(screenPoint.offset(dx, dy));
                                break;
                            case "polyline":
                                geometry = this._applyOffset(geometry, geometry.paths, dx, dy, map);
                                break;
                            case "polygon":
                                geometry = this._applyOffset(geometry, geometry.rings, dx, dy, map);
                        }
                        return {
                            geometry: geometry,
                            transform: dojox.gfx.matrix.translate(dx, dy)
                        };
                    };
                    /**
                     * Rotates a given polygon or polyline by a specified angle.
                     * @param geometry The Geometry to rotate.
                     * @param degreesClockwise The angle to rotate the polygon in, specified in degrees, in a clockwise direction (as is standard for esri)
                     * @param pivotMapPoint The "pivot" around which to rotate the polygon. Is not required to lie on or within the polygon.
                     */
                    MatrixUtils.rotate = function (geometry, map, degreesClockwise, pivotMapPoint) {
                        if (!geometry || !map) {
                            return null;
                        }
                        // If no pivot point provided, use the geometry centroid
                        var around = pivotMapPoint || this.getCentroid(geometry);
                        var transform = dojox.gfx.matrix.rotategAt(-degreesClockwise, around.x, around.y);
                        switch (geometry.type) {
                            case "polyline":
                                geometry = this._applyTransform(geometry, geometry.paths, transform);
                                break;
                            case "polygon":
                                geometry = this._applyTransform(geometry, geometry.rings, transform);
                        }
                        // TODO Text symbol rotation
                        // The returned transformation matrix should be in screen units as per Esri's implementation
                        var screenCoords = map.toScreen(around);
                        return {
                            geometry: geometry,
                            transform: dojox.gfx.matrix.rotategAt(-degreesClockwise, screenCoords.x, screenCoords.y)
                        };
                    };
                    /**
                     * Scales (resizes) a given polygon or polyline by a specified scaling factor.
                     * @param geometry The Geometry to rotate.
                     * @param scaleX A scaling factor used for the x coordinate, or a uniform scaling factor used for the both coordinates.
                     * @param scaleY (Optional) A scaling factor used for the y coordinate.
                     */
                    MatrixUtils.scale = function (geometry, map, scaleX, scaleY) {
                        if (scaleY === void 0) { scaleY = null; }
                        if (!geometry || !map) {
                            return null;
                        }
                        // Validate the scaling factor
                        if (isNaN(scaleX) || Infinity === scaleX || -Infinity === scaleX) {
                            scaleX = 1;
                        }
                        if (scaleY === null || typeof scaleY === "undefined") {
                            scaleY = scaleX; // ...uniform scaling
                        }
                        var centerCoords = this.getCentroid(geometry);
                        var transform = dojox.gfx.matrix.scaleAt(scaleX, scaleY, centerCoords.x, centerCoords.y);
                        switch (geometry.type) {
                            case "polyline":
                                geometry = this._applyTransform(geometry, geometry.paths, transform);
                                break;
                            case "polygon":
                                geometry = this._applyTransform(geometry, geometry.rings, transform);
                        }
                        // TODO Text symbol scaling
                        // The returned transformation matrix should be in screen units as per Esri's implementation
                        var screenCoords = map.toScreen(centerCoords);
                        return {
                            geometry: geometry,
                            transform: dojox.gfx.matrix.scaleAt(scaleX, scaleY, screenCoords.x, screenCoords.y)
                        };
                    };
                    /**
                     * Returns an approximation of the center point of the given geometry, as measured in Cartesian space.
                     * @param geometry The geometry whose center needs to be returned
                     */
                    MatrixUtils.getCentroid = function (geometry) {
                        if (!geometry || !geometry.type || !infrastructure.GeometryUtils.isValidGeometry(geometry)) {
                            return null;
                        }
                        var extent;
                        switch (geometry.type) {
                            case "point":
                                return geometry;
                            case "multipoint":
                            case "polyline":
                            case "polygon":
                                extent = geometry.getExtent();
                                if (extent) {
                                    return extent.getCenter();
                                }
                            case "extent":
                                return geometry.getCenter();
                        }
                        return null;
                    };
                    MatrixUtils._applyOffset = function (geometry, ringsOrPaths, dx, dy, map) {
                        if (geometry && ringsOrPaths) {
                            // dx holds the X offset in screen pixels. 
                            var firstVertex = geometry.getPoint(0, 0);
                            var offsetVertex = map.toMap(map.toScreen(firstVertex).offset(dx, dy));
                            // Calculate x & y offsets in map units
                            var dxInMapUnits = offsetVertex.x - firstVertex.x;
                            var dyInMapUnits = offsetVertex.y - firstVertex.y;
                            // Apply the supplied linear transformation to all vertices in the polyline or polygon
                            for (var ringIndex = 0; ringIndex < ringsOrPaths.length; ringIndex++) {
                                for (var pointIndex = 0; pointIndex < ringsOrPaths[ringIndex].length; pointIndex++) {
                                    var currentVertex = geometry.getPoint(ringIndex, pointIndex);
                                    geometry.setPoint(ringIndex, pointIndex, currentVertex.offset(dxInMapUnits, dyInMapUnits));
                                }
                            }
                        }
                        return geometry;
                    };
                    MatrixUtils._applyTransform = function (geometry, ringsOrPaths, transformation) {
                        // Apply the supplied linear transformation to all vertices in the polyline or polygon
                        if (geometry && ringsOrPaths) {
                            for (var ringIndex = 0; ringIndex < ringsOrPaths.length; ringIndex++) {
                                for (var pointIndex = 0; pointIndex < ringsOrPaths[ringIndex].length; pointIndex++) {
                                    // Apply the transformation matrix 
                                    var currPoint = geometry.getPoint(ringIndex, pointIndex);
                                    var transformedPt = dojox.gfx.matrix.multiplyPoint(transformation, currPoint.x, currPoint.y);
                                    currPoint.setX(transformedPt.x);
                                    currPoint.setY(transformedPt.y);
                                    // Update the geometry
                                    geometry.setPoint(ringIndex, pointIndex, currPoint);
                                }
                            }
                        }
                        return geometry;
                    };
                    return MatrixUtils;
                }());
                infrastructure.MatrixUtils = MatrixUtils;
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts"/>
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../../_Definitions/dojo.d.ts"/>
/// <reference path="../../../_Definitions/modernizr.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var accessibility;
                (function (accessibility) {
                    var EditCapabilityBase = (function () {
                        function EditCapabilityBase(graphic, map, owner) {
                            this.owner = null;
                            this.graphic = null;
                            this.map = null;
                            this.suspended = false;
                            this.graphic = graphic;
                            this.map = map;
                            this.owner = owner;
                        }
                        EditCapabilityBase.prototype.destroy = function () {
                            this.suspended = false;
                            this.graphic = this.map = this.owner = null;
                        };
                        EditCapabilityBase.prototype.refresh = function (force) {
                            if (force === void 0) { force = false; }
                        };
                        EditCapabilityBase.prototype.suspend = function () {
                            this.suspended = true;
                        };
                        EditCapabilityBase.prototype.resume = function () {
                            this.suspended = false;
                        };
                        return EditCapabilityBase;
                    }());
                    accessibility.EditCapabilityBase = EditCapabilityBase;
                })(accessibility = infrastructure.accessibility || (infrastructure.accessibility = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts"/>
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../../_Definitions/dojo.d.ts"/>
/// <reference path="../../../_Definitions/modernizr.d.ts"/>
/// <reference path="./EditCapabilityBase.ts"/>
/// <reference path="../MatrixUtils.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var accessibility;
                (function (accessibility) {
                    var VertexEditor = (function (_super) {
                        __extends(VertexEditor, _super);
                        function VertexEditor(graphic, map, owner, options) {
                            _super.call(this, graphic, map, owner);
                            /** Keyboard event subscriptions */
                            this._keyDownHandle = null;
                            this._keyUpHandle = null;
                            /** X-Offset, Y-Offset to apply to vertices being moved  */
                            this._keyDx = 0;
                            this._keyDy = 0;
                            this._transform = null;
                            this._isMoving = false;
                            this._isActive = false;
                            /** Array of vertices managed by this editor */
                            this._vertexControls = null;
                            /** Array of "ghost" vertices managed by this editor. Ghost vertices are located at the midpoint of every segment. */
                            this._midpointControls = null;
                            /** Flattened array of all vertices (real and ghost) in proper order. Used to determine the next and previous vertex to jump to via keyboard */
                            this._allControls = null;
                            /** Currently selected/highlighted vertex */
                            this._selectedControl = null;
                            /** The vertex anchor (red dot) */
                            this._vertexHandleGraphic = null;
                            this._options = {
                                offsetX: 10,
                                offsetY: 10,
                                preciseOffsetX: 1,
                                preciseOffsetY: 1,
                                allowAddVertices: true,
                                allowDeleteVertices: true
                            };
                            this._snappingInputMovedToken = null;
                            this._options = dojo.mixin(this._options, options || {});
                            // Initialize
                            this._init();
                            if (this.owner && this.owner.app) {
                                this._snappingInputMovedToken = this.owner.app.event("SnappingFeedbackEvent").subscribe(this, this._handleSnappingInputMovedEvent);
                            }
                        }
                        VertexEditor.create = function (graphic, map, owner, options) {
                            if (!graphic || !graphic.geometry) {
                                return null;
                            }
                            switch (graphic.geometry.type) {
                                case "multipoint":
                                    return new accessibility.MultipointVertexEditor(graphic, map, owner, options);
                                case "polyline":
                                    return new accessibility.PolylineVertexEditor(graphic, map, owner, options);
                                case "polygon":
                                    return new accessibility.PolygonVertexEditor(graphic, map, owner, options);
                            }
                            return null;
                        };
                        VertexEditor.prototype._handleSnappingInputMovedEvent = function (args) {
                            if (!args || !args.snappingPoint) {
                                return;
                            }
                            if (this.graphic && this.getSelectedVertex() && this._vertexHandleGraphic && this._vertexHandleGraphic.visible) {
                                this._updateGraphicVertex(args.snappingPoint, this.getSelectedVertex().segmentIndex, this.getSelectedVertex().pointIndex);
                                // When a points is snapped to, the graphic handles and bounding box changes. This signals a refresh to make sure it is in sync.
                                this.owner.refresh();
                            }
                        };
                        VertexEditor.prototype.isActive = function () {
                            return this._isActive;
                        };
                        VertexEditor.prototype.hideVertexHandle = function () {
                            if (this._vertexHandleGraphic) {
                                this._vertexHandleGraphic.hide();
                                if (this.owner && this.owner.app) {
                                    this.owner.app.event("VertexHandleHiddenEvent").publish();
                                }
                            }
                        };
                        VertexEditor.prototype.showVertexHandle = function () {
                            if (!this._selectedControl) {
                                return;
                            }
                            var geom = this._selectedControl.point.offset(0, 0);
                            if (!this._vertexHandleGraphic) {
                                this._vertexHandleGraphic = this.map.graphics.add(new esri.Graphic(geom, this._options.selectedVertexSymbol));
                            }
                            else {
                                this._vertexHandleGraphic.setGeometry(geom).setSymbol(this._options.selectedVertexSymbol);
                                this._vertexHandleGraphic.show();
                            }
                            if (this.owner && this.owner.app) {
                                this.owner.app.event("VertexHandleShownEvent").publish(geom);
                            }
                            var shape = this._vertexHandleGraphic.getDojoShape();
                            if (shape) {
                                shape.moveToFront();
                            }
                        };
                        VertexEditor.prototype.destroy = function () {
                            this._cleanUp();
                            _super.prototype.destroy.call(this);
                        };
                        VertexEditor.prototype.refresh = function (force) {
                            if (force === void 0) { force = false; }
                            this._transform = null;
                            if (force) {
                                // Refresh the points collection
                                this._removeControllers();
                                this._addControllers();
                            }
                            else {
                                this._refreshControllers();
                            }
                        };
                        VertexEditor.prototype.getSelectedVertex = function () {
                            return this._selectedControl;
                        };
                        /** Updates the position of the currently selected vertex whenever a vertex is added */
                        VertexEditor.prototype.onVertexAdd = function (vertexInfo) {
                            if (!vertexInfo || vertexInfo.segmentIndex !== this._selectedControl.segmentIndex) {
                                return;
                            }
                            var arr = null;
                            var segIndex = this._selectedControl.segmentIndex;
                            var ptIndex = this._selectedControl.pointIndex;
                            if (this._selectedControl.isGhost) {
                                arr = this._midpointControls;
                                if (vertexInfo.pointIndex < ptIndex + 1) {
                                    ptIndex += 1;
                                }
                                else if (vertexInfo.pointIndex === ptIndex + 1) {
                                    ptIndex = vertexInfo.pointIndex;
                                    arr = this._vertexControls;
                                }
                            }
                            else {
                                arr = this._vertexControls;
                                ptIndex += vertexInfo.pointIndex <= ptIndex ? 1 : 0;
                            }
                            this._selectedControl = arr[segIndex][ptIndex];
                        };
                        /** Updates the position of the currently selected vertex whenever a vertex is deleted */
                        VertexEditor.prototype.onVertexDelete = function (vertexInfo) {
                            if (!vertexInfo || vertexInfo.segmentIndex !== this._selectedControl.segmentIndex) {
                                return;
                            }
                            var arr = null;
                            var segIndex = this._selectedControl.segmentIndex;
                            var ptIndex = this._selectedControl.pointIndex;
                            if (this._selectedControl.isGhost) {
                                arr = this._midpointControls;
                                ptIndex -= vertexInfo.pointIndex <= ptIndex ? 1 : 0;
                            }
                            else {
                                arr = this._vertexControls;
                                ptIndex -= vertexInfo.pointIndex <= ptIndex && ptIndex > 0 ? 1 : 0;
                            }
                            this._selectedControl = arr[segIndex][ptIndex];
                        };
                        VertexEditor.prototype._init = function () {
                            // Subscribe to keyboard events
                            this._keyDownHandle = dojo.on(this.map.root, "keydown", dojo.hitch(this, "_onKeyDownHandler"));
                        };
                        VertexEditor.prototype._cleanUp = function () {
                            this._isMoving = this._isActive = false;
                            this._transform = null;
                            this._selectedControl = null;
                            this._removeControllers();
                            if (this._vertexHandleGraphic) {
                                this.map.graphics.remove(this._vertexHandleGraphic);
                                this._vertexHandleGraphic = null;
                            }
                            if (this._keyDownHandle) {
                                this._keyDownHandle.remove();
                                this._keyDownHandle = null;
                            }
                            if (this._keyUpHandle) {
                                this._keyUpHandle.remove();
                                this._keyUpHandle = null;
                            }
                            if (this.owner.app && this.owner.app && this._snappingInputMovedToken) {
                                this.owner.app.event("SnappingFeedbackEvent").unsubscribe(this._snappingInputMovedToken);
                            }
                        };
                        VertexEditor.prototype._getSegments = function (geometry) {
                            throw new Error("This method is abstract");
                        };
                        VertexEditor.prototype._getMidpointSegments = function (geometry) {
                            throw new Error("This method is abstract");
                        };
                        VertexEditor.prototype._updatePoints = function (points) {
                            throw new Error("This method is abstract");
                        };
                        VertexEditor.prototype._insertGraphicVertex = function (vertex, segmentIndex, pointIndex) {
                            throw new Error("This method is abstract");
                        };
                        VertexEditor.prototype._updateGraphicVertex = function (vertex, segmentIndex, pointIndex) {
                            throw new Error("This method is abstract");
                        };
                        VertexEditor.prototype._deleteGraphicVertex = function (segmentIndex, pointIndex) {
                            throw new Error("This method is abstract");
                        };
                        VertexEditor.prototype._findVertex = function (point, vertices) {
                            var len = vertices ? vertices.length : 0;
                            for (var i = 0; i < len; i++) {
                                var currentSegment = vertices[i];
                                for (var j = 0; j < currentSegment.length; j++) {
                                    var vertexInfo = currentSegment[j];
                                    if (vertexInfo && infrastructure.GeometryUtils.pointsAreEqual(vertexInfo.point, point)) {
                                        return vertexInfo;
                                    }
                                }
                            }
                            return null;
                        };
                        VertexEditor.prototype._addControllers = function () {
                            var _this = this;
                            this._vertexControls = this._add(this._getSegments(this.graphic.geometry));
                            if (this._options.allowAddVertices) {
                                this._midpointControls = this._add(this._getMidpointSegments(this.graphic.geometry), true);
                            }
                            // Flatten both arrays into one to facilitate jumping to next and previous vertices
                            this._allControls = [];
                            this._vertexControls.forEach(function (segment, segmentIndex) {
                                segment.forEach(function (vertex, pointIndex) {
                                    _this._allControls.push(vertex);
                                    if (_this._midpointControls && _this._midpointControls[segmentIndex] && pointIndex < _this._midpointControls[segmentIndex].length) {
                                        _this._allControls.push(_this._midpointControls[segmentIndex][pointIndex]);
                                    }
                                });
                            });
                        };
                        VertexEditor.prototype._removeControllers = function () {
                            this._remove(this._vertexControls);
                            this._remove(this._midpointControls);
                            this._vertexControls = this._midpointControls = this._allControls = null;
                        };
                        VertexEditor.prototype._refreshControllers = function () {
                            this._refresh(this._vertexControls, this._getSegments(this.graphic.geometry));
                            if (this._options.allowAddVertices) {
                                this._refresh(this._midpointControls, this._getMidpointSegments(this.graphic.geometry), true);
                            }
                        };
                        VertexEditor.prototype._add = function (segments, isGhost) {
                            if (isGhost === void 0) { isGhost = false; }
                            var infos = [];
                            for (var segIndex = 0; segIndex < segments.length; segIndex++) {
                                var points = segments[segIndex];
                                var vertices = [];
                                for (var ptIndex = 0; ptIndex < points.length; ptIndex++) {
                                    vertices.push({
                                        isGhost: isGhost,
                                        segmentIndex: segIndex,
                                        pointIndex: ptIndex,
                                        point: points[ptIndex]
                                    });
                                }
                                infos.push(vertices);
                            }
                            return infos;
                        };
                        VertexEditor.prototype._remove = function (vertices) {
                            if (vertices) {
                                vertices.forEach(function (segment) {
                                    segment.length = 0;
                                });
                                vertices.length = 0;
                            }
                        };
                        VertexEditor.prototype._refresh = function (vertices, segments, isGhost) {
                            if (isGhost === void 0) { isGhost = false; }
                            if (vertices && segments) {
                                vertices.forEach(function (s, segmentIndex) {
                                    s.forEach(function (vertex, pointIndex) {
                                        vertex.point = segments[segmentIndex][pointIndex];
                                    });
                                });
                            }
                        };
                        VertexEditor.prototype._previous = function () {
                            var idx = this._allControls.indexOf(this._selectedControl);
                            this._selectedControl = idx == 0 ? this._allControls[this._allControls.length - 1] : this._allControls[idx - 1];
                            this.showVertexHandle();
                            this._refreshControllers();
                        };
                        VertexEditor.prototype._next = function () {
                            var idx = this._allControls.indexOf(this._selectedControl);
                            this._selectedControl = this._allControls[(idx + 1) % this._allControls.length];
                            this.showVertexHandle();
                            this._refreshControllers();
                        };
                        /**
                         * Provides keyboard handling for the VertexEditor component.
                         * @private
                         */
                        VertexEditor.prototype._onKeyDownHandler = function (event) {
                            // ...don't handle keypress events while suspended
                            if (this.suspended) {
                                return;
                            }
                            if (!this._isActive) {
                                var code = event.keyCode || event.which;
                                if (code === 86) {
                                    // Cancel the event
                                    event.preventDefault();
                                    event.stopImmediatePropagation();
                                    // First time the "V" hotkey is pressed. Go into vertex editing mode
                                    this._isActive = true;
                                    // Suspend all other keyboard handlers but keep this one alive
                                    this.owner.suspend();
                                    this.resume();
                                    // Create the points collection
                                    this._addControllers();
                                    // Highlight the first controller/vertex
                                    this._selectedControl = this._vertexControls[0][0];
                                    this.showVertexHandle();
                                }
                            }
                            else {
                                this._onKeyDownWhenActive(event);
                            }
                        };
                        VertexEditor.prototype._onKeyDownWhenActive = function (event) {
                            // ALT = "precise adjustments" e.g. moving 1px instead of 10px
                            var precise = event.altKey;
                            var xOffset = precise ? this._options.preciseOffsetX : this._options.offsetX;
                            var yOffset = precise ? this._options.preciseOffsetY : this._options.offsetY;
                            var code = event.keyCode || event.which;
                            switch (code) {
                                // "V" = next vertex, SHIFT + "V" = previous vertex
                                case 86:
                                    // Cancel the event
                                    event.preventDefault();
                                    event.stopImmediatePropagation();
                                    if (event.shiftKey) {
                                        this._previous();
                                    }
                                    else {
                                        this._next();
                                    }
                                    return;
                                case dojo.keys.ENTER:
                                case dojo.keys.NUMPAD_ENTER:
                                    // Cancel the event
                                    event.preventDefault();
                                    event.stopImmediatePropagation();
                                    // Resume the keyboard handlers
                                    this.owner.resume();
                                    // Clean up
                                    this._isActive = this._isMoving = false;
                                    this._selectedControl = null;
                                    if (this._vertexHandleGraphic) {
                                        this.hideVertexHandle();
                                        this.map.graphics.remove(this._vertexHandleGraphic);
                                        this._vertexHandleGraphic = null;
                                    }
                                    return;
                                // "D" = delete vertex
                                case 68:
                                    if (this._options.allowDeleteVertices) {
                                        this._delete(this.getSelectedVertex());
                                        // Cancel the event
                                        event.preventDefault();
                                        event.stopImmediatePropagation();
                                    }
                                    return;
                                case dojo.keys.UP_ARROW:
                                case dojo.keys.NUMPAD_8:
                                    this._keyDy -= yOffset;
                                    break;
                                case dojo.keys.RIGHT_ARROW:
                                case dojo.keys.NUMPAD_6:
                                    this._keyDx += xOffset;
                                    break;
                                case dojo.keys.DOWN_ARROW:
                                case dojo.keys.NUMPAD_2:
                                    this._keyDy += yOffset;
                                    break;
                                case dojo.keys.LEFT_ARROW:
                                case dojo.keys.NUMPAD_4:
                                    this._keyDx -= xOffset;
                                    break;
                                case dojo.keys.PAGE_UP:
                                case dojo.keys.NUMPAD_9:
                                    this._keyDx += xOffset;
                                    this._keyDy -= yOffset;
                                    break;
                                case dojo.keys.PAGE_DOWN:
                                case dojo.keys.NUMPAD_3:
                                    this._keyDx += xOffset;
                                    this._keyDy += yOffset;
                                    break;
                                case dojo.keys.END:
                                case dojo.keys.NUMPAD_1:
                                    this._keyDx -= xOffset;
                                    this._keyDy += yOffset;
                                    break;
                                case dojo.keys.HOME:
                                case dojo.keys.NUMPAD_7:
                                    this._keyDx -= xOffset;
                                    this._keyDy -= yOffset;
                                    break;
                                default:
                                    return;
                            }
                            // Cancel the event
                            event.preventDefault();
                            event.stopImmediatePropagation();
                            this._move(this.getSelectedVertex(), this._keyDx, this._keyDy);
                            this._moveStop(this.getSelectedVertex(), this._keyDx, this._keyDy);
                            this._keyDx = this._keyDy = 0;
                        };
                        VertexEditor.prototype._move = function (vertexInfo, dx, dy) {
                            var info = {
                                isGhost: vertexInfo.isGhost,
                                pointIndex: vertexInfo.pointIndex,
                                segmentIndex: vertexInfo.segmentIndex
                            };
                            // Only fire move-start, first-move events once
                            if (!this._isMoving) {
                                this._isMoving = true;
                                this.owner.onVertexMoveStart(this.graphic, info);
                                this.owner.onVertexFirstMove(this.graphic, info);
                            }
                            var pt = this.map.toScreen(vertexInfo.point).offset(dx, dy);
                            this._vertexHandleGraphic.setGeometry(this.map.toMap(pt));
                            this.owner.onVertexMove(this.graphic, info, this._transform);
                            // Raise vertex moved event so tools that listen to move events are notified (e.g. snapping)
                            var editVertexMovedArgs = {
                                sender: this,
                                mapPoint: this.map.toMap(pt),
                                screenPoint: pt
                            };
                            this._raiseEditVertexMoved(editVertexMovedArgs);
                        };
                        VertexEditor.prototype._raiseEditVertexMoved = function (eventArgs) {
                            if (this.owner && this.owner.app) {
                                this.owner.app.event("EditVertexMovedEvent").publish(eventArgs);
                            }
                        };
                        VertexEditor.prototype._moveStop = function (vertexInfo, dx, dy) {
                            this._isMoving = false;
                            if (!vertexInfo || !vertexInfo.point) {
                                return;
                            }
                            var info = {
                                isGhost: vertexInfo.isGhost,
                                pointIndex: vertexInfo.pointIndex,
                                segmentIndex: vertexInfo.segmentIndex
                            };
                            var result = infrastructure.MatrixUtils.translate(vertexInfo.point, this.map, dx, dy);
                            this._transform = result.transform;
                            // Update the graphic. If the user selects a ghost vertex and moves it around, it becomes an actual vertex.
                            if (info.isGhost) {
                                info.pointIndex += 1;
                                this._insertGraphicVertex(result.geometry, info.segmentIndex, info.pointIndex);
                            }
                            else {
                                this._updateGraphicVertex(result.geometry, info.segmentIndex, info.pointIndex);
                            }
                            this.owner.refresh();
                            this.owner.onVertexMoveStop(this.graphic, info, this._transform);
                            if (info.isGhost) {
                                info.isGhost = false;
                                this.owner.onVertexAdd(this.graphic, info);
                            }
                        };
                        VertexEditor.prototype._delete = function (vertexInfo) {
                            if (!vertexInfo || vertexInfo.isGhost) {
                                return;
                            }
                            var info = {
                                isGhost: vertexInfo.isGhost,
                                pointIndex: vertexInfo.pointIndex,
                                segmentIndex: vertexInfo.segmentIndex
                            };
                            // Update the graphic
                            this._deleteGraphicVertex(vertexInfo.segmentIndex, vertexInfo.pointIndex);
                            // Refresh Esri's internal state (vertex handles, etc) when the graphic has been changed in keyboard mode
                            this.owner.refresh();
                            this.owner.onVertexDelete(this.graphic, info);
                        };
                        return VertexEditor;
                    }(accessibility.EditCapabilityBase));
                    accessibility.VertexEditor = VertexEditor;
                })(accessibility = infrastructure.accessibility || (infrastructure.accessibility = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts"/>
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../../_Definitions/dojo.d.ts"/>
/// <reference path="../../../_Definitions/modernizr.d.ts"/>
/// <reference path="../MatrixUtils.ts"/>
/// <reference path="VertexEditor.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var accessibility;
                (function (accessibility) {
                    var MultipointVertexEditor = (function (_super) {
                        __extends(MultipointVertexEditor, _super);
                        function MultipointVertexEditor() {
                            _super.apply(this, arguments);
                        }
                        MultipointVertexEditor.prototype._getSegments = function (geometry) {
                            for (var idx = 0, points = []; idx < geometry.points.length; idx++) {
                                points.push(geometry.getPoint(idx));
                            }
                            return [points];
                        };
                        MultipointVertexEditor.prototype._getMidpointSegments = function (geometry) {
                            return [];
                        };
                        MultipointVertexEditor.prototype._insertGraphicVertex = function (vertex, segmentIndex, pointIndex) {
                            // Operation not supported on multipoints
                        };
                        MultipointVertexEditor.prototype._updateGraphicVertex = function (vertex, segmentIndex, pointIndex) {
                            var geom = this.graphic.geometry;
                            geom.setPoint(pointIndex, vertex.offset(0, 0));
                            this.graphic.setGeometry(geom);
                        };
                        MultipointVertexEditor.prototype._deleteGraphicVertex = function (segmentIndex, pointIndex) {
                            var geom = this.graphic.geometry;
                            geom.removePoint(pointIndex);
                            this.graphic.setGeometry(geom);
                        };
                        return MultipointVertexEditor;
                    }(accessibility.VertexEditor));
                    accessibility.MultipointVertexEditor = MultipointVertexEditor;
                })(accessibility = infrastructure.accessibility || (infrastructure.accessibility = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts"/>
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../../_Definitions/dojo.d.ts"/>
/// <reference path="../../../_Definitions/modernizr.d.ts"/>
/// <reference path="../MatrixUtils.ts"/>
/// <reference path="VertexEditor.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var accessibility;
                (function (accessibility) {
                    var PolygonVertexEditor = (function (_super) {
                        __extends(PolygonVertexEditor, _super);
                        function PolygonVertexEditor() {
                            _super.apply(this, arguments);
                        }
                        PolygonVertexEditor.prototype._getSegments = function (geometry) {
                            var results = [];
                            for (var b = 0; b < geometry.rings.length; b++) {
                                var ringLength = geometry.rings[b].length;
                                var segment = [];
                                for (var c = 0; c < ringLength - 1; c++) {
                                    segment.push(geometry.getPoint(b, c));
                                }
                                results.push(segment);
                            }
                            return results;
                        };
                        PolygonVertexEditor.prototype._getMidpointSegments = function (geometry) {
                            var results = [];
                            for (var b = 0; b < geometry.rings.length; b++) {
                                var ringLength = geometry.rings[b].length;
                                var segment = [];
                                for (var c = 0; c < ringLength - 1; c++) {
                                    var current = geometry.getPoint(b, c);
                                    var next = geometry.getPoint(b, c + 1);
                                    var midpoint = infrastructure.GeometryUtils.getMidpoint(current, next);
                                    segment.push(midpoint);
                                }
                                results.push(segment);
                            }
                            return results;
                        };
                        PolygonVertexEditor.prototype._insertGraphicVertex = function (vertex, segmentIndex, pointIndex) {
                            var geom = this.graphic.geometry;
                            geom.insertPoint(segmentIndex, pointIndex, vertex.offset(0, 0));
                            this.graphic.setGeometry(geom);
                        };
                        PolygonVertexEditor.prototype._updateGraphicVertex = function (vertex, segmentIndex, pointIndex) {
                            var geom = this.graphic.geometry;
                            // If the first point in the ring is updated, we need to update the last point as well
                            geom.setPoint(segmentIndex, pointIndex, vertex.offset(0, 0));
                            if (pointIndex === 0) {
                                var ring = geom.rings[segmentIndex];
                                geom.setPoint(segmentIndex, ring.length - 1, vertex.offset(0, 0));
                            }
                            // ...apply changes
                            this.graphic.setGeometry(geom);
                        };
                        PolygonVertexEditor.prototype._deleteGraphicVertex = function (segmentIndex, pointIndex) {
                            var geom = this.graphic.geometry;
                            // If the first point in the ring is deleted, we need to update the last point as well
                            geom.removePoint(segmentIndex, pointIndex);
                            if (pointIndex === 0) {
                                var ring = geom.rings[segmentIndex];
                                var first = geom.getPoint(segmentIndex, 0);
                                geom.setPoint(segmentIndex, ring.length - 1, first.offset(0, 0));
                            }
                            // ...apply changes
                            this.graphic.setGeometry(geom);
                        };
                        return PolygonVertexEditor;
                    }(accessibility.VertexEditor));
                    accessibility.PolygonVertexEditor = PolygonVertexEditor;
                })(accessibility = infrastructure.accessibility || (infrastructure.accessibility = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts"/>
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../../_Definitions/dojo.d.ts"/>
/// <reference path="../../../_Definitions/modernizr.d.ts"/>
/// <reference path="../MatrixUtils.ts"/>
/// <reference path="VertexEditor.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var accessibility;
                (function (accessibility) {
                    var PolylineVertexEditor = (function (_super) {
                        __extends(PolylineVertexEditor, _super);
                        function PolylineVertexEditor() {
                            _super.apply(this, arguments);
                        }
                        PolylineVertexEditor.prototype._getSegments = function (geometry) {
                            var results = [];
                            for (var b = 0; b < geometry.paths.length; b++) {
                                var pathLength = geometry.paths[b].length;
                                var segment = [];
                                for (var c = 0; c < pathLength; c++) {
                                    segment.push(geometry.getPoint(b, c));
                                }
                                results.push(segment);
                            }
                            return results;
                        };
                        PolylineVertexEditor.prototype._getMidpointSegments = function (geometry) {
                            var results = [];
                            for (var b = 0; b < geometry.paths.length; b++) {
                                var pathLength = geometry.paths[b].length;
                                var segment = [];
                                for (var c = 0; c < pathLength - 1; c++) {
                                    var current = geometry.getPoint(b, c);
                                    var next = geometry.getPoint(b, c + 1);
                                    var midpoint = infrastructure.GeometryUtils.getMidpoint(current, next);
                                    segment.push(midpoint);
                                }
                                results.push(segment);
                            }
                            return results;
                        };
                        PolylineVertexEditor.prototype._insertGraphicVertex = function (vertex, segmentIndex, pointIndex) {
                            var geom = this.graphic.geometry;
                            geom.insertPoint(segmentIndex, pointIndex, vertex.offset(0, 0));
                            this.graphic.setGeometry(geom);
                        };
                        PolylineVertexEditor.prototype._updateGraphicVertex = function (vertex, segmentIndex, pointIndex) {
                            var geom = this.graphic.geometry;
                            geom.setPoint(segmentIndex, pointIndex, vertex.offset(0, 0));
                            this.graphic.setGeometry(geom);
                        };
                        PolylineVertexEditor.prototype._deleteGraphicVertex = function (segmentIndex, pointIndex) {
                            var geom = this.graphic.geometry;
                            geom.removePoint(segmentIndex, pointIndex);
                            this.graphic.setGeometry(geom);
                        };
                        return PolylineVertexEditor;
                    }(accessibility.VertexEditor));
                    accessibility.PolylineVertexEditor = PolylineVertexEditor;
                })(accessibility = infrastructure.accessibility || (infrastructure.accessibility = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../_Definitions/Framework.d.ts" />
/// <reference path="../../../_Definitions/framework.d.ts"/>
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var accessibility;
                (function (accessibility) {
                    /**
                     * The accessibility manager is the central access point for all things WCAG within the viewer.
                     */
                    var AccessibilityManager = (function () {
                        /**
                         * Initializes a new instance of the {@link AccessibilityManager} class.
                         * @param app The {@link framework.application.Application} that this instance belongs to.
                         */
                        function AccessibilityManager(app) {
                            /** An object map of all referenced components that can be instantiated by this factory. */
                            this._registeredComponentTypes = {
                                "esri.toolbars.draw": "esri.toolbars.Draw",
                                "esri.toolbars.edit": "esri.toolbars.Edit",
                                "geocortex.accessibility.draw": "geocortex.essentialsHtmlViewer.mapping.infrastructure.accessibility.Draw",
                                "geocortex.accessibility.edit": "geocortex.essentialsHtmlViewer.mapping.infrastructure.accessibility.Edit"
                            };
                            /** An stack of all currently active keyboard components. */
                            this._stack = [];
                            this.app = app;
                            this.app.event("AccessibleComponentStartedEvent").subscribe(this, this._handleAccessibleComponentStarted);
                            this.app.event("AccessibleComponentCompletedEvent").subscribe(this, this._handleAccessibleComponentCompleted);
                        }
                        AccessibilityManager.prototype.registerComponent = function (name, typeName) {
                            if (name == null || typeName == null) {
                                throw new Error("[AccessibilityManager::registerComponent] Null name or typeName passed to registerComponent");
                            }
                            this._registeredComponentTypes[name] = typeName;
                        };
                        AccessibilityManager.prototype.unregisterComponent = function (name) {
                            if (name && this._registeredComponentTypes.hasOwnProperty(name)) {
                                delete this._registeredComponentTypes[name];
                                return true;
                            }
                            return false;
                        };
                        AccessibilityManager.prototype.createComponent = function (name, map, options) {
                            if (name && this._registeredComponentTypes.hasOwnProperty(name)) {
                                // Get the registered type
                                var typeName = this._registeredComponentTypes[name];
                                // Create an instance of the tool
                                var ctor = dojo.getObject(typeName);
                                if (ctor) {
                                    var component = new ctor(map, options, this.app);
                                    return component;
                                }
                                else {
                                    this.app.trace.warning("Could not create component '{0}' from type name '{1}'".format(name, typeName));
                                }
                            }
                            return null;
                        };
                        /**
                         * @private
                         * A central location to ensure proper access to keyboard events. Whenever a new accessible component
                         * is activated that requests access to keyboard events, the AccessibilityManager will suspend existing tools
                         * until the current one completes execution.
                         * This is modelled with a stack structure.
                         */
                        AccessibilityManager.prototype._handleAccessibleComponentStarted = function (sender) {
                            if (!sender || !this._stack) {
                                return;
                            }
                            var ix = this._stack.indexOf(sender);
                            if (ix > -1) {
                                this._stack.splice(ix, 1);
                            }
                            // Suspend all previous tools in the stack
                            this._stack.forEach(function (x) { return !x.suspended && x.suspend(); });
                            // Add new tool to the stack
                            this._stack.push(sender);
                            sender.resume();
                        };
                        /**
                         * @private
                         * A central location to ensure proper access to keyboard events. Whenever a new accessible component
                         * is activated that requests access to keyboard events, the AccessibilityManager will suspend existing tools
                         * until the current one completes execution.
                         * This is modelled with a stack structure.
                         */
                        AccessibilityManager.prototype._handleAccessibleComponentCompleted = function (sender) {
                            if (!sender || !this._stack || this._stack.length == 0) {
                                return;
                            }
                            var ix = this._stack.indexOf(sender);
                            if (ix > -1) {
                                this._stack.splice(ix, 1);
                                !sender.suspended && sender.suspend();
                            }
                            if (this._stack.length > 0) {
                                var last = this._stack[this._stack.length - 1];
                                last.resume();
                            }
                        };
                        return AccessibilityManager;
                    }());
                    accessibility.AccessibilityManager = AccessibilityManager;
                })(accessibility = infrastructure.accessibility || (infrastructure.accessibility = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts"/>
/// <reference path="../../../_Definitions/dojo.d.ts"/>
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="./InputMethod.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var accessibility;
                (function (accessibility) {
                    /**
                     * Base class for accessible components
                     */
                    var AccessibleMapComponent = (function () {
                        function AccessibleMapComponent(map, app) {
                            /** The mode the component is running - e.g. mouse, keyboard */
                            this.inputMethod = null;
                            this.suspended = false;
                            this.isKeyboardActive = false;
                            this.id = geocortex.framework.utils.alphaNumericToken();
                            /** The map instance. */
                            this._map = null;
                            this._mapNavState = null;
                            /** Event handles */
                            this._mouseDownHandle = null;
                            this._keyDownHandle = null;
                            this._keyUpHandle = null;
                            this.setMap(map);
                            this.setApp(app);
                        }
                        AccessibleMapComponent.prototype.setMap = function (map) {
                            this._map = map;
                        };
                        AccessibleMapComponent.prototype.setApp = function (app) {
                            this.app = app;
                        };
                        /**
                         * Sets the current input method for this component (for example, mouse or keyboard).
                         * @param method The input method. See {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.accessibility.InputMethod} for valid values.
                         */
                        AccessibleMapComponent.prototype.setInputMethod = function (method) {
                            if (method !== this.inputMethod) {
                                var previousValue = this.inputMethod;
                                this.inputMethod = method;
                                // Raise event
                                this.onInputMethodChange({ previousMethod: previousValue, newMethod: this.inputMethod });
                            }
                        };
                        AccessibleMapComponent.prototype.setKeyboardActive = function (value) {
                            this.isKeyboardActive = value;
                        };
                        AccessibleMapComponent.prototype.suspend = function () {
                            this.suspended = true;
                        };
                        AccessibleMapComponent.prototype.resume = function () {
                            this.suspended = false;
                        };
                        AccessibleMapComponent.prototype.disableMapNavigation = function (hideZoomSlider, hidePanArrows, disableGraphicMouseEvents) {
                            if (hideZoomSlider === void 0) { hideZoomSlider = false; }
                            if (hidePanArrows === void 0) { hidePanArrows = false; }
                            if (disableGraphicMouseEvents === void 0) { disableGraphicMouseEvents = true; }
                            var m = this._map;
                            this._mapNavState = {
                                isDoubleClickZoom: m.isDoubleClickZoom,
                                isClickRecenter: m.isClickRecenter,
                                isPan: m.isPan,
                                isRubberBandZoom: m.isRubberBandZoom,
                                isKeyboardNavigation: m.isKeyboardNavigation,
                                isScrollWheelZoom: m.isScrollWheelZoom,
                                isShiftDoubleClickZoom: m.isShiftDoubleClickZoom,
                                isPanArrows: m.isPanArrows,
                                isZoomSlider: m.isZoomSlider
                            };
                            m.disableDoubleClickZoom();
                            m.disableClickRecenter();
                            m.disablePan();
                            m.disableRubberBandZoom();
                            m.disableKeyboardNavigation();
                            m.disableScrollWheelZoom();
                            m.disableShiftDoubleClickZoom();
                            if (hideZoomSlider && m.isZoomSlider) {
                                m.hideZoomSlider();
                            }
                            if (hidePanArrows && m.isPanArrows) {
                                m.hidePanArrows();
                            }
                            if (disableGraphicMouseEvents) {
                                m.graphics.disableMouseEvents();
                            }
                            return this._mapNavState;
                        };
                        AccessibleMapComponent.prototype.enableMapNavigation = function (showZoomSlider, showPanArrows, enableGraphicMouseEvents, mapState) {
                            if (showZoomSlider === void 0) { showZoomSlider = false; }
                            if (showPanArrows === void 0) { showPanArrows = false; }
                            if (enableGraphicMouseEvents === void 0) { enableGraphicMouseEvents = true; }
                            var m = this._map;
                            var state = mapState || this._mapNavState;
                            if (!state) {
                                return;
                            }
                            if (state.isDoubleClickZoom) {
                                m.enableDoubleClickZoom();
                            }
                            if (state.isClickRecenter) {
                                m.enableClickRecenter();
                            }
                            if (state.isPan) {
                                m.enablePan();
                            }
                            if (state.isRubberBandZoom) {
                                m.enableRubberBandZoom();
                            }
                            if (state.isKeyboardNavigation) {
                                m.enableKeyboardNavigation();
                            }
                            if (state.isScrollWheelZoom) {
                                m.enableScrollWheelZoom();
                            }
                            if (state.isShiftDoubleClickZoom) {
                                m.enableShiftDoubleClickZoom();
                            }
                            if (showZoomSlider && state.isZoomSlider) {
                                m.showZoomSlider();
                            }
                            if (showPanArrows && state.isPanArrows) {
                                m.showPanArrows();
                            }
                            if (enableGraphicMouseEvents) {
                                m.graphics.enableMouseEvents();
                            }
                        };
                        AccessibleMapComponent.prototype.getMapState = function () {
                            return this._mapNavState;
                        };
                        AccessibleMapComponent.prototype.activateMouseControls = function (resetInputMethod) {
                            var _this = this;
                            if (resetInputMethod === void 0) { resetInputMethod = true; }
                            this.deactivateMouseControls(resetInputMethod);
                            // If the mouse is used to interact with the map, the user is committed to mouse mode.
                            this._mouseDownHandle = this.app.map.on("mouse-down", function () {
                                _this._mouseDownHandle.remove();
                                _this._mouseDownHandle = null;
                                _this.setInputMethod(accessibility.InputMethod.MOUSE);
                            });
                        };
                        AccessibleMapComponent.prototype.deactivateMouseControls = function (resetInputMethod) {
                            if (resetInputMethod === void 0) { resetInputMethod = true; }
                            if (this._mouseDownHandle) {
                                this._mouseDownHandle.remove();
                                this._mouseDownHandle = null;
                            }
                            // Reset tool mode (keyboard vs mouse)
                            if (resetInputMethod && this.inputMethod === accessibility.InputMethod.MOUSE) {
                                this.setInputMethod(null);
                            }
                        };
                        AccessibleMapComponent.prototype.activateKeyboardControls = function (resetInputMode) {
                            if (resetInputMode === void 0) { resetInputMode = true; }
                            if (this.isKeyboardActive) {
                                this.deactivateKeyboardControls(resetInputMode);
                            }
                            // Subscribe to keyboard events
                            this.setKeyboardActive(true);
                            this._keyDownHandle = dojo.on(this._map.root, "keydown", dojo.hitch(this, "_onKeyDown"));
                            this._keyUpHandle = dojo.on(this._map.root, "keyup", dojo.hitch(this, "_onKeyUp"));
                            this.app.event("AccessibleComponentStartedEvent").publish(this);
                        };
                        AccessibleMapComponent.prototype.deactivateKeyboardControls = function (resetInputMethod) {
                            if (resetInputMethod === void 0) { resetInputMethod = true; }
                            this.setKeyboardActive(false);
                            if (this._keyDownHandle) {
                                this._keyDownHandle.remove();
                                this._keyDownHandle = null;
                            }
                            if (this._keyUpHandle) {
                                this._keyUpHandle.remove();
                                this._keyUpHandle = null;
                            }
                            // Reset tool mode (keyboard vs mouse)
                            if (resetInputMethod && this.inputMethod === accessibility.InputMethod.KEYBOARD) {
                                this.setInputMethod(null);
                            }
                            this.app.event("AccessibleComponentCompletedEvent").publish(this);
                        };
                        AccessibleMapComponent.prototype.toggleKeyboardMode = function () {
                            var isKeyboard = this.inputMethod === accessibility.InputMethod.KEYBOARD;
                            // Start the keyboard experience
                            if (!isKeyboard) {
                                this.onKeyboardStart();
                            }
                            else {
                                // Keyboard operation completed successfully
                                this.onKeyboardStop();
                            }
                        };
                        /**
                         * Fired when the input method for this component (e.g. keyboard, mouse) has changed.
                         */
                        AccessibleMapComponent.prototype.onInputMethodChange = function (result) {
                            this.app.event("InputMethodChangedEvent").publish(result);
                        };
                        /**
                         * Internal method that subclasses should override to provide keyboard handling.
                         */
                        AccessibleMapComponent.prototype.onKeyboardStart = function () {
                            if (this._mouseDownHandle) {
                                this._mouseDownHandle.remove();
                                this._mouseDownHandle = null;
                            }
                            this.setInputMethod(accessibility.InputMethod.KEYBOARD);
                        };
                        /**
                         * Internal method that subclasses should override to provide keyboard handling.
                         * @param cancelled Whether the operation was cancelled.
                         */
                        AccessibleMapComponent.prototype.onKeyboardStop = function (cancelled) {
                            if (cancelled === void 0) { cancelled = false; }
                            this.setInputMethod(null);
                        };
                        /**
                         * Internal method that subclasses should override to provide keyboard handling.
                         */
                        AccessibleMapComponent.prototype._onKeyDown = function (event) {
                        };
                        /**
                         * Internal method that subclasses should override to provide keyboard handling.
                         */
                        AccessibleMapComponent.prototype._onKeyUp = function (event) {
                        };
                        return AccessibleMapComponent;
                    }());
                    accessibility.AccessibleMapComponent = AccessibleMapComponent;
                })(accessibility = infrastructure.accessibility || (infrastructure.accessibility = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts"/>
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../../_Definitions/dojo.d.ts"/>
/// <reference path="../../../_Definitions/modernizr.d.ts"/>
/// <reference path="./EditCapabilityBase.ts"/>
/// <reference path="../MatrixUtils.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var accessibility;
                (function (accessibility) {
                    var BoxEditor = (function (_super) {
                        __extends(BoxEditor, _super);
                        function BoxEditor(graphic, map, owner, isTextPoint, options) {
                            _super.call(this, graphic, map, owner);
                            this._options = {
                                rotateEnabled: false,
                                scaleEnabled: false,
                                uniformScaling: false,
                                rotationAngle: 15,
                                preciseRotationAngle: 1,
                                scaleFactor: 0.2,
                                preciseScaleFactor: 0.01
                            };
                            this._scaleEnabled = false;
                            this._rotateEnabled = false;
                            this._uniformScaling = false;
                            this._isTextPoint = false;
                            this._modified = false;
                            this._isRotating = false;
                            this._isScaling = false;
                            this._lineSymbol = null;
                            this._markerSymbol = null;
                            this._transform = null;
                            /** Keyboard event subscriptions */
                            this._keyDownHandle = null;
                            this._keyUpHandle = null;
                            this._options = dojo.mixin(this._options, options || {});
                            var toolbarOptions = owner.getOptions();
                            this._markerSymbol = this._options.boxHandleSymbol ? this._options.boxHandleSymbol : toolbarOptions.boxHandleSymbol;
                            this._lineSymbol = this._options.boxLineSymbol ? this._options.boxLineSymbol : toolbarOptions.boxLineSymbol;
                            this._scaleEnabled = !!this._options.scaleEnabled;
                            this._rotateEnabled = !!this._options.rotateEnabled;
                            this._uniformScaling = !!this._options.uniformScaling;
                            this._isTextPoint = isTextPoint;
                            // Initialize
                            this._init();
                        }
                        BoxEditor.prototype.destroy = function () {
                            _super.prototype.destroy.call(this);
                            this._cleanUp();
                        };
                        BoxEditor.prototype._init = function () {
                            // Subscribe to keyboard events
                            this._keyDownHandle = dojo.on(this.map.root, "keydown", dojo.hitch(this, "_onKeyDownHandler"));
                            this._keyUpHandle = dojo.on(this.map.root, "keyup", dojo.hitch(this, "_onKeyUpHandler"));
                        };
                        BoxEditor.prototype._cleanUp = function () {
                            this._scaleEnabled = this._rotateEnabled = this._uniformScaling = this._isTextPoint = false;
                            this._isRotating = this._isScaling = this._modified = false;
                            this._lineSymbol = this._markerSymbol = this._transform = null;
                            if (this._keyDownHandle) {
                                this._keyDownHandle.remove();
                                this._keyDownHandle = null;
                            }
                            if (this._keyUpHandle) {
                                this._keyUpHandle.remove();
                                this._keyUpHandle = null;
                            }
                        };
                        /**
                         * Provides keyboard handling for the BoxEditor component.
                         * @private
                         */
                        BoxEditor.prototype._onKeyDownHandler = function (event) {
                            // ...don't handle keypress events while suspended
                            if (this.suspended) {
                                return;
                            }
                            // ALT = "precise adjustments" e.g. moving 1px instead of 10px
                            var precise = event.altKey;
                            var invert = event.shiftKey;
                            var handled = false;
                            var scaleFactor = precise ? this._options.preciseScaleFactor : this._options.scaleFactor;
                            var angle = precise ? this._options.preciseRotationAngle : this._options.rotationAngle;
                            var code = event.keyCode || event.which;
                            if (this._scaleEnabled) {
                                switch (code) {
                                    // "S"
                                    case 83:
                                        // ...scale up or down
                                        scaleFactor = invert ? scaleFactor * -1 : scaleFactor;
                                        this._scaleGraphic(1 + scaleFactor, 1 + scaleFactor);
                                        handled = true;
                                        break;
                                    default:
                                        break;
                                }
                            }
                            if (this._rotateEnabled) {
                                switch (code) {
                                    // "R"
                                    case 82:
                                        // ...rotate right or left
                                        angle = invert ? angle * -1 : angle;
                                        this._rotateGraphic(angle);
                                        handled = true;
                                        break;
                                    default:
                                        break;
                                }
                            }
                            // Cancel the event
                            if (handled) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        };
                        /**
                         * Keyboard event handler
                         * @private
                         */
                        BoxEditor.prototype._onKeyUpHandler = function (event) {
                            // ...don't handle keypress events while suspended
                            if (this.suspended) {
                                return;
                            }
                            // ALT = "precise adjustments" e.g. moving 1px instead of 10px
                            var precise = event.altKey;
                            var code = event.keyCode || event.which;
                            var handled = false;
                            if (this._scaleEnabled) {
                                switch (code) {
                                    // "S"
                                    case 83:
                                        // ...scale up or down
                                        this._isScaling = false;
                                        this.owner.onScaleStop(this.graphic, this._transform);
                                        handled = true;
                                        break;
                                    default:
                                        break;
                                }
                            }
                            if (this._rotateEnabled) {
                                switch (code) {
                                    // "R"
                                    case 82:
                                        // ...rotate right or left
                                        this._isRotating = false;
                                        this.owner.onRotateStop(this.graphic, this._transform);
                                        handled = true;
                                        break;
                                    default:
                                        break;
                                }
                            }
                            // Cancel the event
                            if (handled) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        };
                        BoxEditor.prototype._rotateGraphic = function (degreesClockwise, pivotMapPoint) {
                            // Only fire move-start, first-move events once
                            if (!this._isRotating) {
                                this.owner.onRotateStart(this.graphic);
                                this.owner.onRotateFirstMove(this.graphic);
                                this._isRotating = true;
                            }
                            // TODO WebMercator <-> WSG84
                            // e = f._geo ? s.geographicToWebMercator(b.geometry) : b.geometry
                            // If no pivot point provided, use the geometry centroid
                            var geom = this.graphic.geometry;
                            var around = pivotMapPoint || infrastructure.GeometryUtils.getMiddle(geom);
                            // Can't proceed without a proper geometry
                            if (!infrastructure.GeometryUtils.isValidGeometry(geom) || geocortex.framework.utils.isNullOrUndefined(around)) {
                                return;
                            }
                            // Apply rotation matrix
                            var result = infrastructure.MatrixUtils.rotate(geom, this.map, degreesClockwise, around);
                            this._transform = result.transform;
                            this._modified = true;
                            // Update the graphic
                            // TODO b.setGeometry(f._geo ? s.webMercatorToGeographic(e, true) : e);
                            if (this._isTextPoint) {
                                var symbol = this.graphic.symbol;
                                symbol.angle += degreesClockwise;
                                this.graphic.setSymbol(symbol);
                            }
                            else {
                                this.graphic.setGeometry(result.geometry);
                            }
                            var info = {
                                transform: result.transform,
                                angle: degreesClockwise,
                                scaleX: 1,
                                scaleY: 1,
                                around: this.map.toScreen(around)
                            };
                            // Refresh Esri's internal state (vertex handles, etc) when the graphic has been changed in keyboard mode
                            this.owner.refresh();
                            this.owner.onRotate(this.graphic, info);
                        };
                        BoxEditor.prototype._scaleGraphic = function (scaleX, scaleY) {
                            // Only fire move-start, first-move events once
                            if (!this._isScaling) {
                                this.owner.onScaleStart(this.graphic);
                                this.owner.onScaleFirstMove(this.graphic);
                                this._isScaling = true;
                            }
                            if (scaleY === null || typeof scaleY === "undefined") {
                                scaleY = scaleX; // ...uniform scaling
                            }
                            // TODO WebMercator <-> WSG84
                            // e = f._geo ? s.geographicToWebMercator(b.geometry) : b.geometry
                            var geom = this.graphic.geometry;
                            // Apply scaling matrix
                            var result = infrastructure.MatrixUtils.scale(geom, this.map, scaleX, scaleY);
                            this._transform = result.transform;
                            this._modified = true;
                            // Update the graphic
                            // TODO b.setGeometry(f._geo ? s.webMercatorToGeographic(e, true) : e);
                            if (this._isTextPoint) {
                                var symbol = this.graphic.symbol;
                                symbol.font.setSize(Math.round(100 * symbol.font.size * scaleX) / 100);
                                this.graphic.setSymbol(symbol);
                            }
                            else {
                                this.graphic.setGeometry(result.geometry);
                            }
                            var info = {
                                transform: result.transform,
                                angle: 0,
                                scaleX: scaleX,
                                scaleY: scaleY,
                                around: null
                            };
                            // Refresh Esri's internal state (vertex handles, etc) when the graphic has been changed in keyboard mode
                            this.owner.refresh();
                            this.owner.onScale(this.graphic, info);
                        };
                        return BoxEditor;
                    }(accessibility.EditCapabilityBase));
                    accessibility.BoxEditor = BoxEditor;
                })(accessibility = infrastructure.accessibility || (infrastructure.accessibility = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts"/>
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../../_Definitions/dojo.d.ts"/>
/// <reference path="../../../_Definitions/modernizr.d.ts"/>
/// <reference path="./EditCapabilityBase.ts"/>
/// <reference path="../MatrixUtils.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var accessibility;
                (function (accessibility) {
                    var GraphicMover = (function (_super) {
                        __extends(GraphicMover, _super);
                        function GraphicMover(graphic, map, owner, textAnchor, options) {
                            _super.call(this, graphic, map, owner);
                            this._options = {
                                offsetX: 10,
                                offsetY: 10,
                                preciseOffsetX: 1,
                                preciseOffsetY: 1
                            };
                            this._modified = false;
                            this._isMoving = false;
                            this._transform = null;
                            this._textAnchor = null;
                            /** Keyboard event subscriptions */
                            this._keyDownHandle = null;
                            this._keyUpHandle = null;
                            this._options = dojo.mixin(this._options, options || {});
                            this._textAnchor = textAnchor;
                            this._init();
                        }
                        GraphicMover.prototype.hasMoved = function () {
                            return this._modified;
                        };
                        GraphicMover.prototype.destroy = function () {
                            _super.prototype.destroy.call(this);
                            this._cleanUp();
                        };
                        GraphicMover.prototype.refresh = function (force) {
                            if (force === void 0) { force = false; }
                            _super.prototype.refresh.call(this, force);
                            if (this.graphic && (force || this._needsRefresh())) {
                                this._cleanUp();
                                this._init();
                            }
                        };
                        GraphicMover.prototype._needsRefresh = function () {
                            return this._keyDownHandle == null;
                        };
                        GraphicMover.prototype._init = function () {
                            // Subscribe to keyboard events
                            this._keyDownHandle = dojo.on(this.map.root, "keydown", dojo.hitch(this, "_onKeyDownHandler"));
                            this._keyUpHandle = dojo.on(this.map.root, "keyup", dojo.hitch(this, "_onKeyUpHandler"));
                        };
                        GraphicMover.prototype._cleanUp = function () {
                            this._modified = false;
                            this._isMoving = false;
                            this._textAnchor = this._transform = null;
                            if (this._keyDownHandle) {
                                this._keyDownHandle.remove();
                                this._keyDownHandle = null;
                            }
                            if (this._keyUpHandle) {
                                this._keyUpHandle.remove();
                                this._keyUpHandle = null;
                            }
                        };
                        /**
                         * Provides keyboard handling for the GraphicMover component.
                         */
                        GraphicMover.prototype._onKeyDownHandler = function (event) {
                            // ...don't handle keypress events while suspended
                            if (this.suspended) {
                                return;
                            }
                            // ALT = "precise adjustments" e.g. moving 1px instead of 10px
                            var precise = event.altKey;
                            var xOffset = precise ? this._options.preciseOffsetX : this._options.offsetX;
                            var yOffset = precise ? this._options.preciseOffsetY : this._options.offsetY;
                            var code = event.keyCode || event.which;
                            var dx = 0;
                            var dy = 0;
                            switch (code) {
                                case dojo.keys.UP_ARROW:
                                case dojo.keys.NUMPAD_8:
                                    dy = -1;
                                    break;
                                case dojo.keys.RIGHT_ARROW:
                                case dojo.keys.NUMPAD_6:
                                    dx = 1;
                                    break;
                                case dojo.keys.DOWN_ARROW:
                                case dojo.keys.NUMPAD_2:
                                    dy = 1;
                                    break;
                                case dojo.keys.LEFT_ARROW:
                                case dojo.keys.NUMPAD_4:
                                    dx = -1;
                                    break;
                                case dojo.keys.PAGE_UP:
                                case dojo.keys.NUMPAD_9:
                                    dx = 1;
                                    dy = -1;
                                    break;
                                case dojo.keys.PAGE_DOWN:
                                case dojo.keys.NUMPAD_3:
                                    dx = 1;
                                    dy = 1;
                                    break;
                                case dojo.keys.END:
                                case dojo.keys.NUMPAD_1:
                                    dx = -1;
                                    dy = 1;
                                    break;
                                case dojo.keys.HOME:
                                case dojo.keys.NUMPAD_7:
                                    dx = -1;
                                    dy = -1;
                                    break;
                                default:
                                    return;
                            }
                            this._moveGraphic(dx * xOffset, dy * yOffset);
                            // Cancel the event
                            event.preventDefault();
                            event.stopPropagation();
                        };
                        /**
                         * Keyboard event handler
                         */
                        GraphicMover.prototype._onKeyUpHandler = function (event) {
                            // ...don't handle keypress events while suspended
                            if (this.suspended) {
                                return;
                            }
                            // ALT = "precise adjustments" e.g. moving 1px instead of 10px
                            var precise = event.altKey;
                            var code = event.keyCode || event.which;
                            switch (code) {
                                case dojo.keys.UP_ARROW:
                                case dojo.keys.NUMPAD_8:
                                case dojo.keys.RIGHT_ARROW:
                                case dojo.keys.NUMPAD_6:
                                case dojo.keys.DOWN_ARROW:
                                case dojo.keys.NUMPAD_2:
                                case dojo.keys.LEFT_ARROW:
                                case dojo.keys.NUMPAD_4:
                                case dojo.keys.PAGE_UP:
                                case dojo.keys.NUMPAD_9:
                                case dojo.keys.PAGE_DOWN:
                                case dojo.keys.NUMPAD_3:
                                case dojo.keys.END:
                                case dojo.keys.NUMPAD_1:
                                case dojo.keys.HOME:
                                case dojo.keys.NUMPAD_7:
                                    // Reactivate map navigation
                                    this._isMoving = false;
                                    this.map.enableMapNavigation();
                                    // ...notify listeners
                                    this.owner.onGraphicMoveStop(this.graphic, this._transform);
                                    break;
                                default:
                                    return;
                            }
                            // Cancel the event
                            event.preventDefault();
                            event.stopPropagation();
                        };
                        GraphicMover.prototype._moveGraphic = function (dx, dy) {
                            // Only fire move-start, first-move events once
                            if (!this._isMoving) {
                                this.owner.onGraphicMoveStart(this.graphic);
                                this.owner.onGraphicFirstMove(this.graphic);
                                // Disable map navigation as it conflicts with the keyboard tools
                                this._isMoving = true;
                                this.map.disableMapNavigation();
                            }
                            // TODO WebMercator <-> WSG84
                            // e = f._geo ? s.geographicToWebMercator(b.geometry) : b.geometry
                            var result = infrastructure.MatrixUtils.translate(this.graphic.geometry, this.map, dx, dy);
                            this._transform = result.transform;
                            this._modified = true;
                            // Update the graphic
                            // TODO b.setGeometry(f._geo ? s.webMercatorToGeographic(e, true) : e);
                            this.graphic.setGeometry(result.geometry);
                            // Update the text anchor graphic (red dot on bottom-left corner)
                            if (this._textAnchor) {
                                this._textAnchor.setGeometry(new esri.geometry.Point(this.graphic.geometry.toJson()));
                            }
                            // Refresh Esri's internal state (vertex handles, etc) when the graphic has been changed in keyboard mode
                            this.owner.refresh();
                            this.owner.onGraphicMove(this.graphic, result.transform);
                            if (this.graphic.geometry instanceof esri.geometry.Point) {
                                var point = this.graphic.geometry.offset(0, 0);
                                var editVertexMovedArgs = {
                                    sender: this,
                                    mapPoint: point,
                                    screenPoint: this.map.toScreen(point)
                                };
                                this._raiseEditVertexMoved(editVertexMovedArgs);
                            }
                        };
                        GraphicMover.prototype._raiseEditVertexMoved = function (eventArgs) {
                            if (this.owner && this.owner.app) {
                                this.owner.app.event("EditVertexMovedEvent").publish(eventArgs);
                            }
                        };
                        return GraphicMover;
                    }(accessibility.EditCapabilityBase));
                    accessibility.GraphicMover = GraphicMover;
                })(accessibility = infrastructure.accessibility || (infrastructure.accessibility = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts"/>
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../../_Definitions/dojo.d.ts"/>
/// <reference path="../../../_Definitions/modernizr.d.ts"/>
/// <reference path="./AccessibleMapComponent.ts"/>
/// <reference path="./GraphicMover.ts"/>
/// <reference path="./BoxEditor.ts"/>
/// <reference path="./VertexEditor.ts"/>
/// <reference path="./InputMethod.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var accessibility;
                (function (accessibility) {
                    /**
                     * The Edit toolbar is a helper class that provides functionality to move graphics or
                     * modify individual vertices, i.e., edit the geometry of existing graphics.
                     * To add new graphics, use the Draw toolbar.
                     */
                    var Edit = (function (_super) {
                        __extends(Edit, _super);
                        /**
                         * Creates a new Edit object. A map is a required parameter.
                         * @param map Map the toolbar is associated with.
                         * @param options Optional parameters.
                         */
                        function Edit(map, options, app) {
                            _super.call(this, map, app);
                            /** The default (mouse-driven) drawing tools */
                            this._editObject = null;
                            /** The editing options */
                            this._options = null;
                            this._defaultOptions = null;
                            /** The active tool(s). Can be a combination of several tools, e.g. Edit.MOVE | Edit.SCALE */
                            this._tool = 0;
                            /** Whether the shape being edited is text markup */
                            this._isTextPoint = false;
                            this._isGeo = false;
                            /** Whether we are in a editing session */
                            this._active = false;
                            /** Whether the shape has been modified */
                            this._modified = false;
                            /** Whether the editing operation has been cancelled */
                            this._cancelled = false;
                            /** Whether the mouse handles need refreshing (e.g. the graphic was changed via the keyboard) */
                            this._needsRefresh = false;
                            /** Handles returned by dojo.aspect */
                            this._handles = [];
                            /** Snapping feedback event token */
                            this._snappingFeedbackEventToken = null;
                            /** The last found snapping point */
                            this._lastSnapPoint = null;
                            /** Editing capabilities (e.g. move, scale, rotate, vertex editing) */
                            this._graphicMover = null;
                            this._vertexEditor = null;
                            this._boxEditor = null;
                            var isTouch = Modernizr && !!Modernizr.touch;
                            var defaults = {
                                vertexSymbol: new esri.symbol.SimpleMarkerSymbol(esri.symbol.SimpleMarkerSymbol.STYLE_CIRCLE, isTouch ? 20 : 12, new esri.symbol.SimpleLineSymbol(esri.symbol.SimpleLineSymbol.STYLE_SOLID, new esri.Color([0, 0, 0, 0.5]), 1), new esri.Color([128, 128, 128])),
                                ghostVertexSymbol: new esri.symbol.SimpleMarkerSymbol(esri.symbol.SimpleMarkerSymbol.STYLE_CIRCLE, isTouch ? 18 : 10, new esri.symbol.SimpleLineSymbol(esri.symbol.SimpleLineSymbol.STYLE_SOLID, new esri.Color([0, 0, 0, 0.5]), 1), new esri.Color([255, 255, 255, 0.75])),
                                ghostLineSymbol: new esri.symbol.SimpleLineSymbol(esri.symbol.SimpleLineSymbol.STYLE_DOT, new esri.Color([128, 128, 128]), 2),
                                allowDeleteVertices: true,
                                allowAddVertices: true,
                                narrateKeyboardShortcuts: true,
                                rotateHandleOffset: isTouch ? 24 : 16,
                                boxLineSymbol: new esri.symbol.SimpleLineSymbol(esri.symbol.SimpleLineSymbol.STYLE_DASH, new esri.Color([64, 64, 64]), 1),
                                boxHandleSymbol: new esri.symbol.SimpleMarkerSymbol(esri.symbol.SimpleMarkerSymbol.STYLE_SQUARE, isTouch ? 16 : 9, new esri.symbol.SimpleLineSymbol(esri.symbol.SimpleLineSymbol.STYLE_SOLID, new esri.Color([0, 0, 0, 0.5]), 1), new esri.Color([255, 255, 255, 0.75])),
                                textAnchorSymbol: new esri.symbol.SimpleMarkerSymbol(esri.symbol.SimpleMarkerSymbol.STYLE_CIRCLE, 10, null, new esri.Color([255, 0, 0])),
                                selectedVertexSymbol: new esri.symbol.SimpleMarkerSymbol(esri.symbol.SimpleMarkerSymbol.STYLE_CIRCLE, isTouch ? 25 : 15, null, new esri.Color([0, 0, 255, 0.75]))
                            };
                            this._defaultOptions = dojo.mixin(defaults, options || {});
                            this._editObject = new esri.toolbars.Edit(map, options);
                        }
                        /**
                         * Activates the toolbar to edit the supplied graphic. After activation the toolbar is ready for user interaction using the specified tool.
                         * @param tool Specify the active tool(s). Combine tools using the | operator.
                         * @param graphic The graphic to edit.
                         * @param options See the object specifications table below for the structure of the `options` object.
                         */
                        Edit.prototype.activate = function (tool, graphic, options) {
                            var _this = this;
                            this.deactivate();
                            // Subscribe to snapping feedbak events so edit tools can be notified of snapping points.
                            if (this.app) {
                                this._snappingFeedbackEventToken = this.app.event("SnappingFeedbackEvent").subscribe(this, function (args) {
                                    if (args && args.snappingPoint) {
                                        _this._lastSnapPoint = args.snappingPoint;
                                    }
                                    else {
                                        // A `null` snapping point indicates that there is no snapping point available.
                                        _this._lastSnapPoint = null;
                                    }
                                });
                            }
                            this._active = true;
                            this._graphic = graphic;
                            this._tool = tool;
                            this._options = dojo.mixin(dojo.mixin({}, this._defaultOptions), options || {});
                            if (tool > 0) {
                                var mapSR = this._map.spatialReference;
                                var geomSR = graphic && graphic.geometry ? graphic.geometry.spatialReference : null;
                                this._isGeo = mapSR && geomSR && !mapSR.equals(geomSR) && (mapSR.isWebMercator() && 4326 === geomSR.wkid);
                                // Check if we are editing text markup
                                if (graphic && graphic.geometry && graphic.geometry.type === "point") {
                                    var symbol = this._getSymbol(graphic);
                                    this._isTextPoint = symbol && symbol.type === "textsymbol";
                                }
                                else {
                                    this._isTextPoint = false;
                                }
                                // Adding new vertices is not supported on multipoint geometries
                                if (graphic && graphic.geometry && graphic.geometry.type === "multipoint") {
                                    this._options.allowAddVertices = false;
                                }
                                // Subscribe to editing events on internal Esri mouse editing tools
                                this._handles.push(dojo.aspect.after(this._editObject, "onGraphicClick", dojo.hitch(this, "_onGraphicClickImpl"), true));
                                this._handles.push(dojo.aspect.after(this._editObject, "onGraphicFirstMove", dojo.hitch(this, "_onGraphicFirstMoveImpl"), true));
                                this._handles.push(dojo.aspect.after(this._editObject, "onGraphicMove", dojo.hitch(this, "_onGraphicMoveImpl"), true));
                                this._handles.push(dojo.aspect.after(this._editObject, "onGraphicMoveStart", dojo.hitch(this, "_onGraphicMoveStartImpl"), true));
                                this._handles.push(dojo.aspect.after(this._editObject, "onGraphicMoveStop", dojo.hitch(this, "_onGraphicMoveStopImpl"), true));
                                this._handles.push(dojo.aspect.after(this._editObject, "onRotate", dojo.hitch(this, "_onRotateImpl"), true));
                                this._handles.push(dojo.aspect.after(this._editObject, "onRotateFirstMove", dojo.hitch(this, "_onRotateFirstMoveImpl"), true));
                                this._handles.push(dojo.aspect.after(this._editObject, "onRotateStart", dojo.hitch(this, "_onRotateStartImpl"), true));
                                this._handles.push(dojo.aspect.after(this._editObject, "onRotateStop", dojo.hitch(this, "_onRotateStopImpl"), true));
                                this._handles.push(dojo.aspect.after(this._editObject, "onScale", dojo.hitch(this, "_onScaleImpl"), true));
                                this._handles.push(dojo.aspect.after(this._editObject, "onScaleFirstMove", dojo.hitch(this, "_onScaleFirstMoveImpl"), true));
                                this._handles.push(dojo.aspect.after(this._editObject, "onScaleStart", dojo.hitch(this, "_onScaleStartImpl"), true));
                                this._handles.push(dojo.aspect.after(this._editObject, "onScaleStop", dojo.hitch(this, "_onScaleStopImpl"), true));
                                this._handles.push(dojo.aspect.after(this._editObject, "onVertexAdd", dojo.hitch(this, "_onVertexAddImpl"), true));
                                this._handles.push(dojo.aspect.after(this._editObject, "onVertexClick", dojo.hitch(this, "_onVertexClickImpl"), true));
                                this._handles.push(dojo.aspect.after(this._editObject, "onVertexDelete", dojo.hitch(this, "_onVertexDeleteImpl"), true));
                                this._handles.push(dojo.aspect.after(this._editObject, "onVertexFirstMove", dojo.hitch(this, "_onVertexFirstMoveImpl"), true));
                                this._handles.push(dojo.aspect.after(this._editObject, "onVertexMouseOut", dojo.hitch(this, "_onVertexMouseOutImpl"), true));
                                this._handles.push(dojo.aspect.after(this._editObject, "onVertexMouseOver", dojo.hitch(this, "_onVertexMouseOverImpl"), true));
                                this._handles.push(dojo.aspect.after(this._editObject, "onVertexMove", dojo.hitch(this, "_onVertexMoveImpl"), true));
                                this._handles.push(dojo.aspect.after(this._editObject, "onVertexMoveStart", dojo.hitch(this, "_onVertexMoveStartImpl"), true));
                                this._handles.push(dojo.aspect.after(this._editObject, "onVertexMoveStop", dojo.hitch(this, "_onVertexMoveStopImpl"), true));
                                // Activate internal editing tools
                                this.activateMouseControls();
                                this.activateKeyboardControls();
                                var moveEnabled = false;
                                var boxEditingEnabled = false;
                                var vertexEditingEnabled = false;
                                if ((tool & Edit.MOVE) === Edit.MOVE) {
                                    moveEnabled = this._enableMove(graphic);
                                }
                                var scaleEnabled = (tool & Edit.SCALE) === Edit.SCALE;
                                var rotateEnabled = (tool & Edit.ROTATE) === Edit.ROTATE;
                                if (scaleEnabled || rotateEnabled) {
                                    boxEditingEnabled = this._enableBoxEditing(graphic, scaleEnabled, rotateEnabled);
                                }
                                if ((tool & Edit.EDIT_VERTICES) === Edit.EDIT_VERTICES) {
                                    vertexEditingEnabled = this._enableVertexEditing(graphic);
                                }
                                /**
                                 * Esri provides a way to edit text directly with their editing tools via a dojo widget (esri/dijit/SymbolEditor).
                                 * GVH provides its own UI to handle text markup so it's not worth to implement this option.
                                 */
                                if ((tool & Edit.EDIT_TEXT) === Edit.EDIT_TEXT) {
                                }
                                if (!moveEnabled && !boxEditingEnabled && !vertexEditingEnabled) {
                                    throw new Error("[esri.toolbars.Edit::activate] Unable to activate the tool. Check if the tool is valid for the given geometry type.");
                                }
                                // Activate keyboard mode. Display an status message with keyboard shortcuts available.
                                this.onKeyboardStart();
                                this._updateToolStatusMessage();
                                // Notify listeners
                                this.onActivate(tool, graphic);
                                var args = {
                                    sender: this,
                                    graphic: graphic,
                                    tool: tool
                                };
                                this.raiseGraphicEditActivated(args);
                            }
                        };
                        /**
                         * Deactivates the toolbar. Call this method to deactivate the toolbar after editing the graphic.
                         */
                        Edit.prototype.deactivate = function () {
                            var tool = this._tool;
                            this._active = false;
                            // Clean up snapping event subscription
                            if (this.app && this._snappingFeedbackEventToken) {
                                this.app.event("SnappingFeedbackEvent").unsubscribe(this._snappingFeedbackEventToken);
                                this._snappingFeedbackEventToken = null;
                            }
                            if (tool > 0) {
                                var modified = this._modified;
                                var cancelled = this._cancelled;
                                var graphic = this._graphic;
                                // Adjust the GraphicMover's point to the snapping point
                                if (this._graphicMover && this._graphicMover.hasMoved()) {
                                    this._adjustGraphicMoverPoint(graphic, this._lastSnapPoint);
                                }
                                // Clear the internal state
                                this._clear();
                                this._graphic = null;
                                this._isGeo = this._isTextPoint = false;
                                // Deactivate internal draw tools
                                this.deactivateMouseControls();
                                this.deactivateKeyboardControls();
                                // Check to see if the tool's DrawMode is extent rather than polygon.
                                // This is for the zoom based tools.
                                if (this.app.toolRegistry && this.app.toolRegistry.getActiveTool) {
                                    var activeTool = this.app.toolRegistry.getActiveTool();
                                    if (activeTool instanceof infrastructure.tools.MapTool) {
                                        var castActiveTool = activeTool;
                                        if (castActiveTool.drawMode === infrastructure.tools.DrawMode.EXTENT) {
                                            graphic.setGeometry(this._convertPolygonToExtent(graphic.geometry));
                                        }
                                    }
                                }
                                // Notify listeners
                                this.onDeactivate(tool, graphic, { isModified: modified, cancelled: cancelled });
                                var args = {
                                    sender: this,
                                    graphic: graphic,
                                    tool: tool,
                                    isModified: modified,
                                    cancelled: cancelled
                                };
                                this.raiseGraphicEditDeactivated(args);
                            }
                        };
                        /**
                         * Convert a polygon to an extent. Used for zoom operations using the keyboard.
                         * @param polygon A esri.geometry.Polygon polygon that is to be converted to an extent.
                         */
                        Edit.prototype._convertPolygonToExtent = function (polygon) {
                            // We are dealing with a polygon, probably provided by the keyboard accessibility tools.
                            if (polygon.getExtent) {
                                return polygon.getExtent();
                            }
                            else {
                                this.app.trace.warning("Tried to convert polygon to extent, but failed. Polygon object lacks getExtent() method.");
                                return null;
                            }
                        };
                        Edit.prototype.getOptions = function () {
                            return this._options || this._defaultOptions || {};
                        };
                        /**
                         * Returns an object with the following properties that describe the current state: `tool`, `graphic`, `isModified`.
                         */
                        Edit.prototype.getCurrentState = function () {
                            return {
                                tool: this._tool,
                                graphic: this._graphic,
                                isModified: this._modified
                            };
                        };
                        /**
                         * Returns an array with the available tools (for example, [MOVE tool, ROTATE tool, SCALE tool]).
                         */
                        Edit.prototype.getEnabledTools = function () {
                            return [this._graphicMover, this._boxEditor, this._vertexEditor].filter(function (x) { return !geocortex.framework.utils.isNullOrUndefined(x); });
                        };
                        /**
                         * Refreshes the internal state of the toolbar.
                         */
                        Edit.prototype.refresh = function () {
                            this._editObject.refresh();
                            this._needsRefresh = false;
                        };
                        Edit.prototype.setNeedsRefresh = function (value) {
                            this._needsRefresh = value;
                        };
                        Edit.prototype.suspend = function () {
                            _super.prototype.suspend.call(this);
                            this.getEnabledTools().forEach(function (x) { return x.suspend(); });
                        };
                        Edit.prototype.resume = function () {
                            _super.prototype.resume.call(this);
                            this.getEnabledTools().forEach(function (x) { return x.resume(); });
                        };
                        Edit.prototype.isActive = function () {
                            return this._active;
                        };
                        Edit.prototype.activateMouseControls = function (resetInputMode) {
                            if (resetInputMode === void 0) { resetInputMode = true; }
                            _super.prototype.activateMouseControls.call(this, resetInputMode);
                            // Activate Esri's editing tools (mouse-driven)
                            if (this._tool > 0) {
                                this._editObject.__attached_stopEvent = true;
                                this._editObject.activate(this._tool, this._graphic, this._options);
                            }
                            else {
                                throw new Error("[esri.toolbars.Edit::activate] Unable to activate the tool. Check if the tool is valid for the given geometry type.");
                            }
                        };
                        Edit.prototype.deactivateMouseControls = function (resetInputMode) {
                            if (resetInputMode === void 0) { resetInputMode = true; }
                            _super.prototype.deactivateMouseControls.call(this, resetInputMode);
                            // Deactivate Esri's editing tools
                            this._editObject.__attached_stopEvent = true;
                            this._editObject.deactivate();
                        };
                        Edit.prototype.on = function (type, listener) {
                            // TODO Test .on events
                            //return this._editObject.on(type, listener);
                            throw new Error("[geocortex.essentialsHtmlViewer.mapping.infrastructure.accessibility.Edit] On style events not implemented yet. Use connect instead.");
                        };
                        /**
                         * Fired when the editing tools are activated.
                         * @param tool The editing type. The constants table lists valid editing values.
                         * @param graphic The graphic to edit whose vertices will be edited or moved.
                         */
                        Edit.prototype.onActivate = function (tool, graphic) {
                        };
                        /**
                         * Fired when the editing tools are deactivated.
                         * @param tool The editing type. The constants table lists valid editing values.
                         * @param graphic The graphic the toolbar was associated with.
                         * @info An object with the following properties: isModified
                         */
                        Edit.prototype.onDeactivate = function (tool, graphic, info) {
                        };
                        /**
                         * Fired when a graphic is clicked. Applicable only when the MOVE tool is active.
                         * @param graphic The clicked graphic.
                         * @param info An object with the following properties: `mapPoint`, `screenPoint`
                         */
                        Edit.prototype.onGraphicClick = function (graphic, info) {
                        };
                        /** @private */
                        Edit.prototype._onGraphicClickImpl = function (graphic, info) {
                            // Proxy the event
                            this.onGraphicClick(graphic, info);
                        };
                        /**
                         * Fired when the user begins to move a graphic. Applicable only when the MOVE tool is active.
                         * @param graphic The graphic associated with the toolbar.
                         */
                        Edit.prototype.onGraphicFirstMove = function (graphic) {
                            this._modified = true;
                        };
                        /** @private */
                        Edit.prototype._onGraphicFirstMoveImpl = function (graphic) {
                            // Disable keyboard input while shapes are being moved, scaled or rotated with the mouse - see GVH-5693
                            this.suspend();
                            // Hide the keyboard vertex handle while the graphic is being changed via the mouse
                            if (this._vertexEditor !== null && this._vertexEditor.isActive()) {
                                this._vertexEditor.hideVertexHandle();
                            }
                            // Proxy the event
                            this.onGraphicFirstMove(graphic);
                        };
                        /**
                         * Fired continuously as the graphic moves. Applicable only when the MOVE tool is active.
                         * @param graphic The graphic associated with the toolbar.
                         * @param transform Represents the linear transformation applied to the graphic.
                         */
                        Edit.prototype.onGraphicMove = function (graphic, transform) {
                        };
                        /** @private */
                        Edit.prototype._onGraphicMoveImpl = function (graphic, transform) {
                            // Proxy the event
                            this.onGraphicMove(graphic, transform);
                        };
                        /**
                         * Fired when the mouse button is pressed down on the graphic, usually while moving a graphic. Applicable only when the MOVE tool is active.
                         * @param graphic The graphic associated with the toolbar.
                         */
                        Edit.prototype.onGraphicMoveStart = function (graphic) {
                        };
                        /** @private */
                        Edit.prototype._onGraphicMoveStartImpl = function (graphic) {
                            // Proxy the event
                            this.onGraphicMoveStart(graphic);
                        };
                        /**
                         * Fired when the mouse button is released, usually after moving the graphic. Applicable only when the MOVE tool is active.
                         * @param graphic The graphic associated with the toolbar.
                         * @param transform Represents the linear transformation applied to the graphic.
                         */
                        Edit.prototype.onGraphicMoveStop = function (graphic, transform) {
                        };
                        /** @private */
                        Edit.prototype._onGraphicMoveStopImpl = function (graphic, transform) {
                            // Resume keyboard input
                            this.resume();
                            if (this._vertexEditor !== null && this._vertexEditor.isActive()) {
                                // Suspend all other keyboard handlers but keep this one alive
                                this.suspend();
                                this._vertexEditor.resume();
                                // Refresh our internal state if the graphic was changed via the mouse
                                this._vertexEditor.refresh();
                                this._vertexEditor.showVertexHandle();
                            }
                            // Proxy the event
                            this.onGraphicMoveStop(graphic, transform);
                        };
                        /**
                         * Fired continuously as a graphic is rotated.
                         * @param graphic The rotated graphic.
                         * @param info The info object has the following properties: `transform`, `angle`, `around`
                         */
                        Edit.prototype.onRotate = function (graphic, info) {
                        };
                        /** @private */
                        Edit.prototype._onRotateImpl = function (graphic, info) {
                            // Proxy the event
                            this.onRotate(graphic, info);
                        };
                        /**
                         * Fired when the user begins to drag a handle to rotate the graphic.
                         * @param graphic The rotated graphic.
                         */
                        Edit.prototype.onRotateFirstMove = function (graphic) {
                            this._modified = true;
                        };
                        /** @private */
                        Edit.prototype._onRotateFirstMoveImpl = function (graphic) {
                            // Disable keyboard input while shapes are being moved, scaled or rotated with the mouse - see GVH-5693
                            this.suspend();
                            // Hide the keyboard vertex handle while the graphic is being changed via the mouse
                            if (this._vertexEditor !== null && this._vertexEditor.isActive()) {
                                this._vertexEditor.hideVertexHandle();
                            }
                            // Proxy the event
                            this.onRotateFirstMove(graphic);
                        };
                        /**
                         * Fired when a user clicks on the handle to begin rotating a graphic.
                         * @param graphic The rotated graphic.
                         */
                        Edit.prototype.onRotateStart = function (graphic) {
                        };
                        /** @private */
                        Edit.prototype._onRotateStartImpl = function (graphic) {
                            // Proxy the event
                            this.onRotateStart(graphic);
                        };
                        /**
                         * Fired when the mouse button is released from the rotate handle to finish rotating the graphic.
                         * @param graphic The rotated graphic.
                         * @param info The info object has the following properties: `transform`, `angle`, `around`
                         */
                        Edit.prototype.onRotateStop = function (graphic, info) {
                        };
                        /** @private */
                        Edit.prototype._onRotateStopImpl = function (graphic, info) {
                            // Resume keyboard input
                            this.resume();
                            if (this._vertexEditor !== null && this._vertexEditor.isActive()) {
                                // Suspend all other keyboard handlers but keep this one alive
                                this.suspend();
                                this._vertexEditor.resume();
                                // Refresh our internal state if the graphic was changed via the mouse
                                this._vertexEditor.refresh();
                                this._vertexEditor.showVertexHandle();
                            }
                            // Proxy the event
                            this.onRotateStop(graphic, info);
                        };
                        /**
                         * Fired continuously as the graphic is being scaled.
                         * @param graphic The scaled graphic.
                         * @param info The info object has the following properties: `transform`, `scaleX`, `scaleY`, `around`
                         */
                        Edit.prototype.onScale = function (graphic, info) {
                        };
                        /** @private */
                        Edit.prototype._onScaleImpl = function (graphic, info) {
                            // Proxy the event
                            this.onScale(graphic, info);
                        };
                        /**
                         * Fired when the user begins to drag a handle to scale the graphic.
                         * @param graphic The scaled graphic.
                         */
                        Edit.prototype.onScaleFirstMove = function (graphic) {
                            this._modified = true;
                        };
                        /** @private */
                        Edit.prototype._onScaleFirstMoveImpl = function (graphic) {
                            // Disable keyboard input while shapes are being moved, scaled or rotated with the mouse - see GVH-5693
                            this.suspend();
                            // Hide the keyboard vertex handle while the graphic is being changed via the mouse
                            if (this._vertexEditor !== null && this._vertexEditor.isActive()) {
                                this._vertexEditor.hideVertexHandle();
                            }
                            // Proxy the event
                            this.onScaleFirstMove(graphic);
                        };
                        /**
                         * Fired when a user clicks on the handle to scale or resize a graphic.
                         * @param graphic The scaled graphic.
                         */
                        Edit.prototype.onScaleStart = function (graphic) {
                        };
                        /** @private */
                        Edit.prototype._onScaleStartImpl = function (graphic) {
                            // Proxy the event
                            this.onScaleStart(graphic);
                        };
                        /**
                         * Fired when the mouse button is released from the scale handle to finish scaling the graphic.
                         * @param graphic The scaled graphic.
                         * @param info The info object has the following properties: `transform`, `scaleX`, `scaleY`, `around`
                         */
                        Edit.prototype.onScaleStop = function (graphic, info) {
                        };
                        /** @private */
                        Edit.prototype._onScaleStopImpl = function (graphic, info) {
                            // Resume keyboard input
                            this.resume();
                            if (this._vertexEditor !== null && this._vertexEditor.isActive()) {
                                // Suspend all other keyboard handlers but keep this one alive
                                this.suspend();
                                this._vertexEditor.resume();
                                // Refresh our internal state if the graphic was changed via the mouse
                                this._vertexEditor.refresh();
                                this._vertexEditor.showVertexHandle();
                            }
                            // Proxy the event
                            this.onScaleStop(graphic, info);
                        };
                        /**
                         * Fired after a new vertex is added to a polyline or polygon or a new point is added to a multipoint. Applicable only when the EDIT_VERTICES tool is active.
                         * @param graphic The graphic associated with the toolbar.
                         * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
                         */
                        Edit.prototype.onVertexAdd = function (graphic, vertexInfo) {
                            this._modified = true;
                            // Rebuild our internal state when vertices are added or removed
                            if (this._vertexEditor !== null && this._vertexEditor.isActive()) {
                                this._vertexEditor.refresh(true);
                                this._vertexEditor.onVertexAdd(vertexInfo);
                                this._vertexEditor.showVertexHandle();
                            }
                        };
                        /** @private */
                        Edit.prototype._onVertexAddImpl = function (graphic, vertexInfo) {
                            // Proxy the event
                            this.onVertexAdd(graphic, vertexInfo);
                        };
                        /**
                         * Fired when the mouse button is clicked on the vertex of a polyline or polygon or a point in a multipoint. Applicable only when the EDIT_VERTICES tool is active.
                         * @param graphic The graphic associated with the toolbar.
                         * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
                         */
                        Edit.prototype.onVertexClick = function (graphic, vertexInfo) {
                        };
                        /** @private */
                        Edit.prototype._onVertexClickImpl = function (graphic, vertexInfo) {
                            // Proxy the event
                            this.onVertexClick(graphic, vertexInfo);
                        };
                        /**
                         * Fired after a vertex(polyline, polygon) or point(multipoint) is deleted. Applicable only when the EDIT_VERTICES tool is active.
                         * @param graphic The graphic associated with the toolbar.
                         * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
                         */
                        Edit.prototype.onVertexDelete = function (graphic, vertexInfo) {
                            this._modified = true;
                            // Rebuild our internal state when vertices are added or removed
                            if (this._vertexEditor !== null && this._vertexEditor.isActive()) {
                                this._vertexEditor.refresh(true);
                                this._vertexEditor.onVertexDelete(vertexInfo);
                                this._vertexEditor.showVertexHandle();
                            }
                        };
                        /** @private */
                        Edit.prototype._onVertexDeleteImpl = function (graphic, vertexInfo) {
                            // Proxy the event
                            this.onVertexDelete(graphic, vertexInfo);
                        };
                        /**
                         * Fired when the user begins to move the vertex of a polyline or polygon or a point of a multipoint. Applicable only when the EDIT_VERTICES tool is active.
                         * @param graphic The graphic associated with the toolbar.
                         * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
                         */
                        Edit.prototype.onVertexFirstMove = function (graphic, vertexInfo) {
                            this._modified = true;
                        };
                        /** @private */
                        Edit.prototype._onVertexFirstMoveImpl = function (graphic, vertexInfo) {
                            // Disable keyboard input while shapes are being moved, scaled or rotated with the mouse - see GVH-5693
                            this.suspend();
                            // Hide the keyboard vertex handle while the graphic is being changed via the mouse
                            if (this._vertexEditor !== null && this._vertexEditor.isActive()) {
                                this._vertexEditor.hideVertexHandle();
                            }
                            // Proxy the event
                            this.onVertexFirstMove(graphic, vertexInfo);
                        };
                        /**
                         * Fired as the mouse exits a vertex(polyline, polygon) or a point(multipoint). Applicable only when the EDIT_VERTICES tool is active.
                         * @param graphic The graphic associated with the toolbar.
                         * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
                         */
                        Edit.prototype.onVertexMouseOut = function (graphic, vertexInfo) {
                        };
                        /** @private */
                        Edit.prototype._onVertexMouseOutImpl = function (graphic, vertexInfo) {
                            // Proxy the event
                            this.onVertexMouseOut(graphic, vertexInfo);
                        };
                        /**
                         * Fired when the mouse moves over a vertex (polyline, polygon) or point (multipoint). Applicable only when the EDIT_VERTICES tool is active.
                         * @param graphic The graphic associated with the toolbar.
                         * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
                         */
                        Edit.prototype.onVertexMouseOver = function (graphic, vertexInfo) {
                        };
                        /** @private */
                        Edit.prototype._onVertexMouseOverImpl = function (graphic, vertexInfo) {
                            // Proxy the event
                            this.onVertexMouseOver(graphic, vertexInfo);
                        };
                        /**
                         * Fired continuously as the user is moving a vertex (polyline, polygon) or point (multipoint). Applicable only when the EDIT_VERTICES tool is active.
                         * @param graphic The graphic associated with the toolbar.
                         * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
                         * @param transform Represents the linear transformation applied to the graphic.
                         */
                        Edit.prototype.onVertexMove = function (graphic, vertexInfo, transform) {
                            // This handler is called for both Esri map events and events which are cooked up by the Edit object.
                            // vertexInfo will have different args based on where it came from. Esri has a graphic and gcx has a point argument. 
                            // We are only interested in events that come natively from Esri here. 
                            if (vertexInfo && vertexInfo.graphic) {
                                this.app.event("EditVertexHandleMovedEvent").publish(vertexInfo.graphic);
                            }
                        };
                        /** @private */
                        Edit.prototype._onVertexMoveImpl = function (graphic, vertexInfo, transform) {
                            // Proxy the event
                            this.onVertexMove(graphic, vertexInfo, transform);
                        };
                        /**
                         * Fired when the mouse button is pressed down on a vertex (polyline, polygon) or point (multipoint). Applicable only when the EDIT_VERTICES tool is active.
                         * @param graphic The graphic associated with the toolbar.
                         * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
                         */
                        Edit.prototype.onVertexMoveStart = function (graphic, vertexInfo) {
                        };
                        /** @private */
                        Edit.prototype._onVertexMoveStartImpl = function (graphic, vertexInfo) {
                            // Proxy the event
                            this.onVertexMoveStart(graphic, vertexInfo);
                        };
                        /**
                         * Fired when the mouse button is released from a vertex (polyline, polygon) or point(multipoint). Applicable only when the EDIT_VERTICES tool is active.
                         * @param graphic The graphic associated with the toolbar.
                         * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
                         * @param transform Represents the linear transformation applied to the graphic.
                         */
                        Edit.prototype.onVertexMoveStop = function (graphic, vertexInfo, transform) {
                            // Refresh our internal state if the graphic was changed via the mouse
                            if (this._vertexEditor !== null && this._vertexEditor.isActive() && !vertexInfo.isGhost) {
                                this._vertexEditor.refresh();
                                this._vertexEditor.showVertexHandle();
                            }
                        };
                        /** @private */
                        Edit.prototype._onVertexMoveStopImpl = function (graphic, vertexInfo, transform) {
                            // Resume keyboard input
                            this.resume();
                            if (this._vertexEditor !== null && this._vertexEditor.isActive()) {
                                // Suspend all other keyboard handlers but keep this one alive
                                this.suspend();
                                this._vertexEditor.resume();
                            }
                            // Proxy the event
                            this.onVertexMoveStop(graphic, vertexInfo, transform);
                        };
                        /**
                         * Internal method that subclasses should override to provide keyboard handling.
                         */
                        Edit.prototype.onKeyboardStart = function () {
                            _super.prototype.onKeyboardStart.call(this);
                        };
                        /**
                         * Internal method that subclasses should override to provide keyboard handling.
                         * @param cancelled Whether the operation was cancelled.
                         */
                        Edit.prototype.onKeyboardStop = function (cancelled) {
                            if (cancelled === void 0) { cancelled = false; }
                            _super.prototype.onKeyboardStop.call(this, cancelled);
                            this._cancelled = cancelled;
                            this.deactivate();
                        };
                        /**
                         * Provides keyboard handling for the Edit component.
                         */
                        Edit.prototype._onKeyDown = function (event) {
                            _super.prototype._onKeyDown.call(this, event);
                            // ...don't handle keypress events while suspended
                            if (this.suspended || !this._active || this.inputMethod === accessibility.InputMethod.MOUSE) {
                                return;
                            }
                            var handled = false;
                            var code = event.keyCode || event.which;
                            switch (code) {
                                case dojo.keys.ENTER:
                                case dojo.keys.NUMPAD_ENTER:
                                    this.toggleKeyboardMode();
                                    handled = true;
                                    break;
                                case dojo.keys.ESCAPE:
                                    // Escape cancels the editing session
                                    this.onKeyboardStop(true);
                                    handled = true;
                                    break;
                                default:
                                    break;
                            }
                            // Cancel the event
                            if (handled) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        };
                        Edit.prototype.raiseGraphicEditActivated = function (eventArgs) {
                            this.app.event("GraphicEditActivatedEvent").publish(eventArgs);
                        };
                        Edit.prototype.raiseGraphicEditDeactivated = function (eventArgs) {
                            this.app.event("GraphicEditDeactivatedEvent").publish(eventArgs);
                        };
                        /**
                         * Changes the current status message to something like:
                         * "Use arrows to move, R to rotate, S to scale, V to select vertex. Combine with ALT for finer control. Combine with SHIFT to reverse."
                         * It will also narrate the above text via the ScreenReaderNarrate command.
                         * Implementors should override this method if they want to suppress this behavior.
                         */
                        Edit.prototype._updateToolStatusMessage = function () {
                            // Don't show keyboard shortcuts for point geometries - can't rotate or scale a point.
                            if (!this._graphic || !this._graphic.geometry || this._graphic.geometry.type === "point") {
                                return;
                            }
                            // Update the status message for this keyboard tool. Also narrate the message via screen readers.
                            var statusText = this.app.getResource("Mapping.Infrastructure", "language-toolbar-markup-edit-desc-shortcuts");
                            // If active tool is one of the zoom tools, broadcast modified status message
                            if (this.app.toolRegistry && this.app.toolRegistry.getActiveTool()) {
                                var activeTool = this.app.toolRegistry.getActiveTool();
                                var zoomInToolName = this.app.getResource("Mapping.Infrastructure", "language-toolbar-markup-edit-zoomin-tool");
                                var zoomOutToolName = this.app.getResource("Mapping.Infrastructure", "language-toolbar-markup-edit-zoomout-tool");
                                if (activeTool.name === zoomInToolName || activeTool.name === zoomOutToolName) {
                                    statusText = this.app.getResource("Mapping.Infrastructure", "language-toolbar-markup-edit-desc-shortcuts-zoom");
                                }
                            }
                            if (statusText) {
                                this.app.command("UpdateStatus").execute(new geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.AddStatusArgs(statusText));
                                if (!!this._options.narrateKeyboardShortcuts) {
                                    this.app.command("ScreenReaderNarrate").execute(statusText);
                                }
                            }
                        };
                        Edit.prototype._clear = function () {
                            // Disable moving, box editing, vertex editing & text editing
                            this._disableMove();
                            this._disableBoxEditing();
                            this._disableVertexEditing();
                            this._tool = 0;
                            this._modified = false;
                            this._cancelled = false;
                            this.suspended = false;
                            this.setInputMethod(null);
                            // TODO clear textAnchor
                            // this._textAnchor && (this._textAnchor.getLayer().remove(this._textAnchor), this._textAnchor = null);
                        };
                        Edit.prototype._getSymbol = function (graphic) {
                            if (graphic) {
                                var symbol = graphic.symbol;
                                if (symbol) {
                                    return symbol;
                                }
                                var renderer = graphic.getLayer() ? graphic.getLayer().renderer : null;
                                if (renderer) {
                                    return renderer.getSymbol(graphic);
                                }
                            }
                            return null;
                        };
                        // TODO Make x,y offsets configurable
                        Edit.prototype._enableMove = function (graphic) {
                            switch (graphic.geometry.type) {
                                case "point":
                                    var textAnchor = this._isTextPoint && this._editObject._textAnchor ? this._editObject._textAnchor : null;
                                    this._graphicMover = new accessibility.GraphicMover(graphic, this._map, this, textAnchor);
                                    return true;
                                case "polyline":
                                case "polygon":
                                    this._graphicMover = new accessibility.GraphicMover(graphic, this._map, this, null);
                                    return true;
                            }
                            return false;
                        };
                        // TODO Make rotation angle, scale factor configurable
                        Edit.prototype._enableBoxEditing = function (graphic, scaleEnabled, rotateEnabled) {
                            var options = {
                                scaleEnabled: scaleEnabled,
                                rotateEnabled: rotateEnabled,
                                uniformScaling: this._options.uniformScaling,
                                boxHandleSymbol: this._options.boxHandleSymbol,
                                boxLineSymbol: this._options.boxLineSymbol
                            };
                            if (this._isTextPoint || ["polyline", "polygon"].indexOf(graphic.geometry.type) > -1) {
                                this._boxEditor = new accessibility.BoxEditor(graphic, this._map, this, this._isTextPoint, options);
                                return true;
                            }
                            return false;
                        };
                        Edit.prototype._enableVertexEditing = function (graphic) {
                            var options = {
                                allowAddVertices: this._options.allowAddVertices,
                                allowDeleteVertices: this._options.allowDeleteVertices,
                                selectedVertexSymbol: this._options.selectedVertexSymbol
                            };
                            switch (graphic.geometry.type) {
                                case "multipoint":
                                case "polyline":
                                case "polygon":
                                    this._vertexEditor = accessibility.VertexEditor.create(graphic, this._map, this, options);
                                    return true;
                            }
                            return false;
                        };
                        /**
                         * Contains logic to check if there is a snapping point to replace the moved point.
                         * Snapping is difficult with points during keyboard edits as we do not have a vertex handle which is seperate from the actual graphic.
                         * This handles points when the move is finished and does a last minute geometry swap. If the geometry is swapped before this time,
                         * the point can become locked to the same point on the screen.
                         * @param editingGraphic The editing graphic.
                         * @param overridePoint The point geometry to override.
                         */
                        Edit.prototype._adjustGraphicMoverPoint = function (editingGraphic, overridePoint) {
                            if (!overridePoint || !editingGraphic) {
                                return;
                            }
                            // Make sure that the geometries are both points
                            if (!(overridePoint instanceof esri.geometry.Point) || !(editingGraphic.geometry instanceof esri.geometry.Point)) {
                                return;
                            }
                            editingGraphic.setGeometry(overridePoint);
                        };
                        Edit.prototype._disableMove = function () {
                            if (this._graphicMover) {
                                this._graphicMover.destroy();
                                this._graphicMover = null;
                            }
                        };
                        Edit.prototype._disableBoxEditing = function () {
                            if (this._boxEditor) {
                                this._boxEditor.destroy();
                                this._boxEditor = null;
                            }
                        };
                        Edit.prototype._disableVertexEditing = function () {
                            if (this._vertexEditor) {
                                this._vertexEditor.destroy();
                                this._vertexEditor = null;
                            }
                        };
                        // Static constructor
                        Edit._edit = (function () {
                            require(["esri/toolbars/edit"], function (EsriEdit) {
                                Edit.EDIT_TEXT = EsriEdit.EDIT_TEXT;
                                Edit.EDIT_VERTICES = EsriEdit.EDIT_VERTICES;
                                Edit.MOVE = EsriEdit.MOVE;
                                Edit.ROTATE = EsriEdit.ROTATE;
                                Edit.SCALE = EsriEdit.SCALE;
                            });
                        })();
                        return Edit;
                    }(accessibility.AccessibleMapComponent));
                    accessibility.Edit = Edit;
                })(accessibility = infrastructure.accessibility || (infrastructure.accessibility = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts"/>
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../../_Definitions/dojo.d.ts"/>
/// <reference path="../../../_Definitions/modernizr.d.ts"/>
/// <reference path="../../../_Definitions/bluebird.d.ts"/>
/// <reference path="./AccessibleMapComponent.ts"/>
/// <reference path="./Edit.ts"/>
/// <reference path="./InputMethod.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var accessibility;
                (function (accessibility) {
                    /**
                     * Toolbar that supports functionality to create new geometries by drawing them: points (POINT or MULTI_POINT),
                     * lines (LINE, POLYLINE, or FREEHAND_POLYLINE), polygons (FREEHAND_POLYGON or POLYGON), or rectangles (EXTENT).
                     * To edit geometries of existing graphics, use the Edit Toolbar.
                     */
                    var Draw = (function (_super) {
                        __extends(Draw, _super);
                        /**
                         * Creates a new Draw object.
                         * @param map Map the toolbar is associated with.
                         * @param options Parameters that define the functionality of the draw toolbar.
                         */
                        function Draw(map, options, app) {
                            _super.call(this, map, app);
                            /**
                             * When set to false, the geometry is modified to be topologically correct.
                             */
                            this.respectDrawingVertexOrder = false;
                            /** Templates for pre-defined shapes that can be drawn with this tool */
                            this._arrowShapeTemplate = [[0, 0], [-24, 24], [-24, 12], [-96, 12], [-96, -12], [-24, -12], [-24, -24], [0, 0]];
                            this._leftArrowShapeTemplate = [[0, 0], [24, 24], [24, 12], [96, 12], [96, -12], [24, -12], [24, -24], [0, 0]];
                            this._rightArrowShapeTemplate = [[0, 0], [-24, 24], [-24, 12], [-96, 12], [-96, -12], [-24, -12], [-24, -24], [0, 0]];
                            this._upArrowShapeTemplate = [[0, 0], [-24, 24], [-12, 24], [-12, 96], [12, 96], [12, 24], [24, 24], [0, 0]];
                            this._downArrowShapeTemplate = [[0, 0], [-24, -24], [-12, -24], [-12, -96], [12, -96], [12, -24], [24, -24], [0, 0]];
                            this._triangleShapeTemplate = [[0, -48], [41.56921938165306, 24], [-41.56921938165306, 24], [0, -48]];
                            this._rectangleShapeTemplate = [[0, -48], [96, -48], [96, 0], [0, 0], [0, -48]];
                            /** The default (mouse-driven) drawing tools */
                            this._drawObject = null;
                            /** Internal shape editing tools */
                            this._editObject = null;
                            /** The draw options */
                            this._options = null;
                            this._defaultOptions = null;
                            /** Whether we are in a drawing session */
                            this._active = false;
                            /** The shape being drawn */
                            this._graphic = null;
                            /** Deferred representing a drawing operation. It can result in either a default shape (e.g. circle) or a shape digitized via keyboard (e.g. polygon) */
                            this._createGeometryDeferred = null;
                            /** Whether polyline/polygon keyboard drawing is active */
                            this._isPlottingPolyGeometry = false;
                            /** Whether the polygon/polyline vertex anchor has been moved with the keyboard */
                            this._lastVertexPosition = null;
                            /** The polyline/polygon vertex anchor (red dot). Valid for polyline and polygon geometries */
                            this._vertexAnchor = null;
                            /** The ghost line is displayed when moving vertices. Valid for polyline and polygon geometries */
                            this._ghostLine = null;
                            /** Handles returned by dojo.aspect */
                            this._handles = [];
                            this._polyGeometryKeyDownHandle = null;
                            this._editCompletedHandle = null;
                            this._dblClickHandlerToken = null;
                            this._lastSnappingPoint = null;
                            var isTouch = Modernizr && !!Modernizr.touch;
                            var defaults = {
                                enableEditing: true,
                                vertexOffsetX: 10,
                                vertexOffsetY: 10,
                                preciseVertexOffsetX: 1,
                                preciseVertexOffsetY: 1,
                                vertexSymbol: new esri.symbol.SimpleMarkerSymbol(esri.symbol.SimpleMarkerSymbol.STYLE_CIRCLE, isTouch ? 20 : 12, new esri.symbol.SimpleLineSymbol(esri.symbol.SimpleLineSymbol.STYLE_SOLID, new esri.Color([0, 0, 0, 0.5]), 1), new esri.Color([128, 128, 128])),
                                selectedVertexSymbol: new esri.symbol.SimpleMarkerSymbol(esri.symbol.SimpleMarkerSymbol.STYLE_CIRCLE, isTouch ? 25 : 15, null, new esri.Color([0, 0, 255, 0.75]))
                            };
                            this._defaultOptions = dojo.mixin(defaults, options || {});
                            this._points = [];
                            this._drawObject = new esri.toolbars.Draw(map, options);
                            this._twoClicksWithin300MsFixup();
                            this._editObject = new Draw.EditInternal(map, null, app);
                            this.fillSymbol = this._drawObject.fillSymbol;
                            this.lineSymbol = this._drawObject.lineSymbol;
                            this.markerSymbol = this._drawObject.markerSymbol;
                            this.respectDrawingVertexOrder = this._drawObject.respectDrawingVertexOrder;
                            this.setVertexSymbol(this._defaultOptions.vertexSymbol);
                            this.setSelectedVertexSymbol(this._defaultOptions.selectedVertexSymbol);
                            if (this.app) {
                                this.app.event("SnappingFeedbackEvent").subscribe(this, this._handleSnappingEvent);
                            }
                        }
                        /** @private */
                        Draw.createEllipse = function (options) {
                            var center = options.center;
                            var longAxis = options.longAxis || 48;
                            var shortAxis = options.shortAxis || 24;
                            var totalPoints = options.numberOfPoints || 60;
                            var map = options.map;
                            var vertices = [];
                            var p = 2 * Math.PI / totalPoints;
                            for (var n = 0; n < totalPoints; n++) {
                                var cos = Math.cos(n * p);
                                var sin = Math.sin(n * p);
                                var vertex = map.toMap(new esri.geometry.ScreenPoint({
                                    x: longAxis * cos + center.x,
                                    y: shortAxis * sin + center.y
                                }));
                                vertices.push(vertex);
                            }
                            // Close the polygon
                            vertices.push(vertices[0]);
                            var poly = new esri.geometry.Polygon(map.spatialReference);
                            poly.addRing(vertices);
                            return poly;
                        };
                        /** @private */
                        Draw.createCircle = function (options) {
                            return Draw.createEllipse({
                                center: options.center,
                                longAxis: options.radius,
                                shortAxis: options.radius,
                                numberOfPoints: options.numberOfPoints,
                                map: options.map
                            });
                        };
                        /**
                         * Activates the toolbar for drawing geometries.
                         * @param geometryType The type of geometry drawn.
                         * @param options Options that define the functionality of the draw toolbar.
                         */
                        Draw.prototype.activate = function (geometryType, options) {
                            var _this = this;
                            if (this._active || this._geometryType) {
                                this.deactivate();
                            }
                            // Extra debug logging for GVH-6686
                            this._handles.push(this.app.map.on("click", function (evt) { return _this.app.trace.debug("[DrawTool] map-click"); }));
                            this._handles.push(this.app.map.on("dbl-click", function (evt) { return _this.app.trace.debug("[DrawTool] map-double-click"); }));
                            this._active = true;
                            this._geometryType = geometryType;
                            this._options = dojo.mixin(dojo.mixin({}, this._defaultOptions), options || {});
                            // No need to enable editing after drawing for multipoint geometries
                            if (geometryType === Draw.MULTI_POINT) {
                                this._options.enableEditing = false;
                            }
                            // Allow overriding of default vertex symbology
                            this.setVertexSymbol(this._options.vertexSymbol);
                            this.setSelectedVertexSymbol(this._options.selectedVertexSymbol);
                            // Subscribe to draw events
                            this._handles.push(dojo.aspect.after(this._drawObject, "onDrawEnd", dojo.hitch(this, "onDrawEnd"), true));
                            this._handles.push(dojo.aspect.after(this._drawObject, "onDrawComplete", dojo.hitch(this, "onDrawComplete"), true));
                            // Check that the private method still exists! This could break in future versions of Esri API...
                            if (this._drawObject && typeof this._drawObject._onClickHandler === "function") {
                                this._handles.push(dojo.aspect.after(this._drawObject, "_onClickHandler", dojo.hitch(this, "_onClickHandler"), true));
                            }
                            // Apply fixups/hacks required to workaround Esri API issues with drawing and touch
                            this._extraPointOnTouchDevicesFixup();
                            // Activate internal draw tools
                            this.activateMouseControls();
                            if (this._supportsKeyboardInput(this._geometryType)) {
                                this.activateKeyboardControls();
                            }
                            // Notify listeners
                            this.onActivate();
                            this.raiseGraphicDrawActivated({ sender: this, geometryType: geometryType });
                        };
                        /**
                         * Deactivates the toolbar and reactivates map navigation.
                         */
                        Draw.prototype.deactivate = function () {
                            var geometryType = this._geometryType;
                            this._active = false;
                            this._clear();
                            this.setInputMethod(null);
                            // Disconnect from map's double-click event
                            if (this._dblClickHandlerToken) {
                                this._dblClickHandlerToken.remove();
                                this._dblClickHandlerToken = null;
                            }
                            // Unsubscribe from draw events
                            this._handles.forEach(function (h) {
                                h.remove();
                            });
                            this._handles.length = 0;
                            this._geometryType = this.vertexSymbol = this.selectedVertexSymbol = null;
                            // Notify listeners
                            this.onDeactivate();
                            this.raiseGraphicDrawDeactivated({ sender: this, geometryType: geometryType });
                        };
                        /**
                         * Finishes drawing the geometry and fires the onDrawEnd event.
                         */
                        Draw.prototype.finishDrawing = function () {
                            switch (this.inputMethod) {
                                case accessibility.InputMethod.MOUSE:
                                    this._drawObject.finishDrawing();
                                    this._syncPointsCollection();
                                    break;
                                case accessibility.InputMethod.KEYBOARD:
                                    this._finishKeyboardDrawing();
                                    break;
                            }
                        };
                        /**
                         * Sets the fill symbol.
                         * @param fillSymbol The fill symbol.
                         */
                        Draw.prototype.setFillSymbol = function (fillSymbol) {
                            this.fillSymbol = fillSymbol;
                            this._drawObject.setFillSymbol(fillSymbol);
                        };
                        /**
                         * Sets the line symbol.
                         * @param lineSymbol The line symbol.
                         */
                        Draw.prototype.setLineSymbol = function (lineSymbol) {
                            this.lineSymbol = lineSymbol;
                            this._drawObject.setLineSymbol(lineSymbol);
                        };
                        /**
                         * Sets the marker symbol.
                         * @param markerSymbol The marker symbol.
                         */
                        Draw.prototype.setMarkerSymbol = function (markerSymbol) {
                            this.markerSymbol = markerSymbol;
                            this._drawObject.setMarkerSymbol(markerSymbol);
                        };
                        /**
                         * Sets whether the polygon geometry should be modified to be topologically correct.
                         * @param value When set to false, the geometry is modified to be topologically correct.
                         */
                        Draw.prototype.setRespectDrawingVertexOrder = function (value) {
                            this.respectDrawingVertexOrder = value;
                            this._drawObject.setRespectDrawingVertexOrder(value);
                        };
                        /**
                         * Sets the vertex marker symbol.
                         * @param markerSymbol The marker symbol.
                         */
                        Draw.prototype.setVertexSymbol = function (markerSymbol) {
                            this.vertexSymbol = markerSymbol;
                        };
                        /**
                         * Sets the vertex highlight marker symbol.
                         * @param markerSymbol The marker symbol.
                         */
                        Draw.prototype.setSelectedVertexSymbol = function (markerSymbol) {
                            this.selectedVertexSymbol = markerSymbol;
                        };
                        Draw.prototype.activateMouseControls = function (resetInputMode) {
                            if (resetInputMode === void 0) { resetInputMode = true; }
                            _super.prototype.activateMouseControls.call(this, resetInputMode);
                            if (!this._geometryType) {
                                // TODO log warning
                                return;
                            }
                            // Activate Esri's drawing tools (mouse-driven)
                            this._drawObject.__attached_stopEvent = true;
                            this._drawObject.activate(this._geometryType, this._options);
                        };
                        Draw.prototype.deactivateMouseControls = function (resetInputMode) {
                            if (resetInputMode === void 0) { resetInputMode = true; }
                            _super.prototype.deactivateMouseControls.call(this, resetInputMode);
                            // Deactivate Esri's drawing tools
                            this._drawObject.__attached_stopEvent = true;
                            this._drawObject.deactivate();
                        };
                        Draw.prototype.raiseGraphicDrawActivated = function (eventArgs) {
                            this.app.event("GraphicDrawActivatedEvent").publish(eventArgs);
                        };
                        Draw.prototype.raiseGraphicDrawDeactivated = function (eventArgs) {
                            this.app.event("GraphicDrawDeactivatedEvent").publish(eventArgs);
                        };
                        Draw.prototype.raiseGraphicVertexAdded = function (eventArgs) {
                            this.app.event("GraphicVertexAddedEvent").publish(eventArgs);
                        };
                        Draw.prototype.raiseGraphicVertexMoved = function (eventArgs) {
                            // this is fired when the graphic anchor is moved
                            this.app.event("GraphicVertexMovedEvent").publish(eventArgs);
                        };
                        Draw.prototype.on = function (type, listener) {
                            // TODO Test .on events
                            //return this._drawObject.on(type, listener);
                            throw new Error("[geocortex.essentialsHtmlViewer.mapping.infrastructure.accessibilit.Draw::on] On style events not implemented yet. Use connect instead.");
                        };
                        /**
                         * Fired when the drawing tools are activated.
                         */
                        Draw.prototype.onActivate = function () {
                        };
                        /**
                         * Fired when the drawing tools are deactivated.
                         */
                        Draw.prototype.onDeactivate = function () {
                        };
                        /**
                         * Fired when the user has ended drawing.
                         * @param result The event object has the following properties: geometry, geographicGeometry.
                         * `geometry` represents the shape that was drawn. Coordinates of this geometry have the same spatial reference of the map.
                         * `geographicGeometry` represents the drawn shape in geographic coordinates (latitude, longitude). Only available when the map's
                         * spatial reference is Web Mercator or Geographic (4326)
                         */
                        Draw.prototype.onDrawComplete = function (result) {
                            if (this.inputMethod == accessibility.InputMethod.MOUSE) {
                                this._clear();
                            }
                        };
                        /**
                         * Fired when drawing is complete.
                         * @param geometry Geometry drawn on the client.
                         */
                        Draw.prototype.onDrawEnd = function (geometry) {
                            // Extra debug logging for GVH-6686
                            this.app.trace.debug("[DrawTool] Number of vertices drawn " + this._vertexCount(geometry));
                            if (this.inputMethod == accessibility.InputMethod.MOUSE) {
                                this._clear();
                            }
                            // Notify listeners
                            this.app.event("GraphicDrawCompletedEvent").publish(geometry);
                        };
                        /**
                         * Internal method that subclasses should override to provide keyboard handling.
                         */
                        Draw.prototype.onKeyboardStart = function () {
                            var _this = this;
                            // Entering keyboard mode. Drop default shape on the map and deactivate mouse-driven toolbar.
                            _super.prototype.onKeyboardStart.call(this);
                            // Deactivate Esri's drawing tools
                            this.deactivateMouseControls();
                            // Enter "edit" mode once a default graphic has been drawn
                            var center = this._map.extent.getCenter();
                            this._plotShape(center, this._geometryType)
                                .then(function (geom) { return _this._editShape(geom); });
                        };
                        /**
                         * Internal method that subclasses should override to provide keyboard handling.
                         * @param cancelled Whether the operation was cancelled.
                         */
                        Draw.prototype.onKeyboardStop = function (cancelled) {
                            if (cancelled === void 0) { cancelled = false; }
                            _super.prototype.onKeyboardStop.call(this, cancelled);
                            if (this._graphic && !cancelled) {
                                // Raise draw-end event
                                var g = this._graphic.geometry;
                                this._clear();
                                this._drawEnd(g);
                            }
                            else {
                                // Clean up. Wait for new shapes to be drawn (via mouse or keyboard)
                                this._clear();
                            }
                        };
                        /**
                         * Provides keyboard handling for the Draw component.
                         */
                        Draw.prototype._onKeyDown = function (event) {
                            _super.prototype._onKeyDown.call(this, event);
                            // ...don't handle keypress events while suspended
                            if (this.suspended || !this._active || this.inputMethod === accessibility.InputMethod.MOUSE) {
                                return;
                            }
                            var handled = false;
                            var code = event.keyCode || event.which;
                            switch (code) {
                                case dojo.keys.ENTER:
                                case dojo.keys.NUMPAD_ENTER:
                                    this.toggleKeyboardMode();
                                    handled = true;
                                    break;
                                case dojo.keys.ESCAPE:
                                    // Escape cancels the drawing session
                                    this.onKeyboardStop(true);
                                    handled = true;
                                    break;
                                default:
                                    break;
                            }
                            // Cancel the event
                            if (handled) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        };
                        /**
                         * GVH measurement tools rely on private/unsupported methods of the Esri Draw object. This is one of them.
                         * @private
                         */
                        Draw.prototype._onClickHandler = function (event) {
                            if (this.inputMethod === accessibility.InputMethod.MOUSE) {
                                this._syncPointsCollection();
                            }
                        };
                        /** Whether keyboard input is supported for the specified geometry type. Keyboard input is not supported for freehand drawing. */
                        Draw.prototype._supportsKeyboardInput = function (geometryType) {
                            switch (geometryType) {
                                case Draw.ARROW:
                                case Draw.CIRCLE:
                                case Draw.DOWN_ARROW:
                                case Draw.ELLIPSE:
                                case Draw.EXTENT:
                                case Draw.LEFT_ARROW:
                                case Draw.MULTI_POINT:
                                case Draw.POINT:
                                case Draw.POLYGON:
                                case Draw.POLYLINE:
                                case Draw.RECTANGLE:
                                case Draw.RIGHT_ARROW:
                                case Draw.TRIANGLE:
                                case Draw.UP_ARROW:
                                    return true;
                            }
                            return false;
                        };
                        Draw.prototype._finishKeyboardDrawing = function (raiseDrawEndEvent) {
                            if (raiseDrawEndEvent === void 0) { raiseDrawEndEvent = true; }
                            if (!this._active) {
                                return;
                            }
                            var geom;
                            var sr = this._map.spatialReference;
                            var points = this._points.slice(0, this._points.length);
                            switch (this._geometryType) {
                                case Draw.POLYLINE:
                                    if (!this._graphic || points.length < 2) {
                                        return;
                                    }
                                    geom = new esri.geometry.Polyline(sr);
                                    geom.addPath(points);
                                    this._graphic.setGeometry(geom);
                                    break;
                                case Draw.POLYGON:
                                    if (!this._graphic || points.length < 2) {
                                        return;
                                    }
                                    points.push(points[0].offset(0, 0));
                                    if (!esri.geometry.Polygon.prototype.isClockwise(points) && !this.respectDrawingVertexOrder) {
                                        this.app.trace.debug("Polygons drawn in anti-clockwise direction will be reversed to be clockwise.");
                                        points.reverse();
                                    }
                                    geom = new esri.geometry.Polygon(sr);
                                    geom.addRing(points);
                                    this._graphic.setGeometry(geom);
                                    break;
                                case Draw.MULTI_POINT:
                                    geom = new esri.geometry.Multipoint(sr);
                                    points.forEach(function (p) {
                                        geom.addPoint(p);
                                    });
                                    this._graphic.setGeometry(geom);
                                    break;
                                default:
                                    // Default shapes (circles, stars, arrows...)
                                    if (!this._graphic || !this._graphic.geometry) {
                                        return;
                                    }
                                    geom = this._graphic.geometry;
                                    break;
                            }
                            // Raise draw-end event
                            if (raiseDrawEndEvent) {
                                this.onKeyboardStop();
                            }
                        };
                        Draw.prototype._clear = function () {
                            if (this._graphic) {
                                this._map.graphics.remove(this._graphic);
                            }
                            if (this._ghostLine) {
                                this._map.graphics.remove(this._ghostLine);
                            }
                            if (this._vertexAnchor) {
                                this._map.graphics.remove(this._vertexAnchor);
                            }
                            if (this._editCompletedHandle) {
                                this._editCompletedHandle.remove();
                            }
                            if (this._polyGeometryKeyDownHandle) {
                                this._polyGeometryKeyDownHandle.remove();
                            }
                            if (this._editObject) {
                                this._editObject.deactivate();
                            }
                            this._polyGeometryKeyDownHandle = this._editCompletedHandle = this._createGeometryDeferred = this._graphic = this._vertexAnchor = this._ghostLine = null;
                            this._isPlottingPolyGeometry = false;
                            this._lastVertexPosition = null;
                            this.suspended = false;
                            this._points.length = 0;
                            // Deactivate internal draw tools
                            this.deactivateMouseControls();
                            if (this._supportsKeyboardInput(this._geometryType)) {
                                this.deactivateKeyboardControls();
                            }
                            this.setInputMethod(null);
                            // If drawing session still active, restore the internal draw tools
                            if (this._active) {
                                this.activateMouseControls();
                                if (this._supportsKeyboardInput(this._geometryType)) {
                                    this.activateKeyboardControls();
                                }
                            }
                        };
                        /**
                         * Fires the draw-end event.
                         * @private
                         */
                        Draw.prototype._drawEnd = function (geometry) {
                            if (!geometry) {
                                return;
                            }
                            // Raise the draw-end event
                            this.onDrawEnd(geometry);
                            var geographicGeometry;
                            var sr = this._map.spatialReference;
                            if (sr) {
                                if (sr.isWebMercator()) {
                                    geographicGeometry = esri.geometry.webMercatorToGeographic(geometry);
                                }
                                else if (sr.wkid === 4326) {
                                    geographicGeometry = esri.geometry.fromJson(geometry.toJson());
                                }
                            }
                            // Raise the draw-complete event
                            this.onDrawComplete({
                                geometry: geometry,
                                geographicGeometry: geographicGeometry
                            });
                        };
                        Draw.prototype._moveVertexAnchor = function (dx, dy) {
                            if (!this._vertexAnchor || isNaN(dx) || isNaN(dy)) {
                                return;
                            }
                            var mapPoint = this._vertexAnchor.geometry;
                            var offset = this._map.toMap(this._map.toScreen(mapPoint).offset(dx, dy));
                            // Calculate x & y offsets in map units
                            var mapdx = offset.x - mapPoint.x;
                            var mapdy = offset.y - mapPoint.y;
                            var offsetMapPoint = mapPoint.offset(mapdx, mapdy);
                            // Update the ghost line, displayed when moving vertices. Valid for polyline and polygon geometries.
                            if ([Draw.POLYLINE, Draw.POLYGON].indexOf(this._geometryType) > -1) {
                                this._updateGhostLine(offsetMapPoint);
                            }
                            // Update internal state
                            this._vertexAnchor.setGeometry(offsetMapPoint).setSymbol(this.selectedVertexSymbol);
                            this._vertexAnchor.getDojoShape().moveToFront();
                            // Raise vertex moved event so tools that listen to move events are notified (e.g. snapping)
                            var vertexMovedArgs = {
                                sender: this,
                                mapPoint: offsetMapPoint,
                                screenPoint: this._map.toScreen(offsetMapPoint),
                                snappingPoint: this._lastSnappingPoint
                            };
                            this.raiseGraphicVertexMoved(vertexMovedArgs);
                        };
                        Draw.prototype._handleSnappingEvent = function (args) {
                            if (this._active && this._editObject.isActive()) {
                                return;
                            }
                            this._lastSnappingPoint = args.snappingPoint;
                            if (this._lastSnappingPoint && this._ghostLine) {
                                this._updateGhostLine(this._lastSnappingPoint);
                            }
                        };
                        /** @private Updates the ghost line, displayed when moving vertices. Valid for polyline and polygon geometries. */
                        Draw.prototype._updateGhostLine = function (vertexLocation) {
                            if (this._points && this._points.length > 0) {
                                var lastPoint = this._points[this._points.length - 1];
                                var ghostLine = this._ghostLine.geometry;
                                ghostLine.setPoint(0, 0, lastPoint.offset(0, 0));
                                ghostLine.setPoint(0, 1, vertexLocation);
                                this._ghostLine.setGeometry(ghostLine);
                            }
                        };
                        Draw.prototype._addVertex = function (vertex) {
                            var keyboardLocation = vertex;
                            // Overwrite the vertex location
                            if (this._lastSnappingPoint) {
                                vertex = this._lastSnappingPoint;
                            }
                            var polyline;
                            var polygon;
                            var multipoint;
                            var ghostLine;
                            // Add new vertex to points collection
                            this._points.push(vertex.offset(0, 0));
                            switch (this._geometryType) {
                                case Draw.POLYLINE:
                                    if (this._points.length === 1) {
                                        polyline = new esri.geometry.Polyline(this._map.spatialReference);
                                        polyline.addPath(this._points);
                                        this._graphic = this._map.graphics.add(new esri.Graphic(polyline, this.lineSymbol));
                                        ghostLine = new esri.geometry.Polyline(this._map.spatialReference);
                                        ghostLine.addPath([vertex.offset(0, 0), vertex.offset(0, 0)]);
                                        this._ghostLine = this._map.graphics.add(new esri.Graphic(ghostLine, this.lineSymbol));
                                    }
                                    else {
                                        polyline = this._graphic.geometry;
                                        polyline.insertPoint(0, polyline.paths[0].length, vertex.offset(0, 0));
                                        this._graphic.setGeometry(polyline).setSymbol(this.lineSymbol);
                                        ghostLine = this._ghostLine.geometry;
                                        ghostLine.setPoint(0, 0, vertex.offset(0, 0));
                                        ghostLine.setPoint(0, 1, vertex.offset(0, 0));
                                        this._ghostLine.setGeometry(ghostLine);
                                    }
                                    break;
                                case Draw.POLYGON:
                                    if (this._points.length === 1) {
                                        polygon = new esri.geometry.Polygon(this._map.spatialReference);
                                        polygon.addRing(this._points);
                                        this._graphic = this._map.graphics.add(new esri.Graphic(polygon, this.fillSymbol));
                                        ghostLine = new esri.geometry.Polyline(this._map.spatialReference);
                                        ghostLine.addPath([vertex.offset(0, 0), vertex.offset(0, 0)]);
                                        this._ghostLine = this._map.graphics.add(new esri.Graphic(ghostLine, this.fillSymbol));
                                    }
                                    else {
                                        polygon = this._graphic.geometry;
                                        polygon.insertPoint(0, polygon.rings[0].length, vertex.offset(0, 0));
                                        this._graphic.setGeometry(polygon).setSymbol(this.fillSymbol);
                                        ghostLine = this._ghostLine.geometry;
                                        ghostLine.setPoint(0, 0, vertex.offset(0, 0));
                                        ghostLine.setPoint(0, 1, vertex.offset(0, 0));
                                        this._ghostLine.setGeometry(ghostLine);
                                    }
                                    break;
                                case Draw.MULTI_POINT:
                                    if (this._points.length === 1) {
                                        multipoint = new esri.geometry.Multipoint(this._map.spatialReference);
                                        multipoint.addPoint(vertex.offset(0, 0));
                                        this._graphic = this._map.graphics.add(new esri.Graphic(multipoint, this.markerSymbol));
                                    }
                                    else {
                                        multipoint = this._graphic.geometry;
                                        multipoint.addPoint(vertex.offset(0, 0));
                                        this._graphic.setGeometry(multipoint).setSymbol(this.markerSymbol);
                                    }
                                    break;
                            }
                            // Refresh the map cursor/crosshair
                            this._lastVertexPosition = keyboardLocation.offset(0, 0);
                            this._vertexAnchor.setGeometry(keyboardLocation.offset(0, 0)).setSymbol(this.selectedVertexSymbol);
                            this._vertexAnchor.getDojoShape().moveToFront();
                        };
                        /** Starts digitizing polygons, polylines or multi-points via the keyboard. Returns a promise that is fulfilled once the user completes the drawing. */
                        Draw.prototype._drawPolyGeometry = function (start, geometryType) {
                            var _this = this;
                            // Abort if we are already drawing a polyline or polygon
                            if (!start || this._isPlottingPolyGeometry) {
                                return Promise.resolve(null);
                            }
                            // Overwrite the location
                            if (this._lastSnappingPoint) {
                                start = this._lastSnappingPoint;
                            }
                            // Disable map navigation as it conflicts with the keyboard tools
                            this._isPlottingPolyGeometry = true;
                            this.app.map.disableMapNavigation();
                            // Disconnect the main keyboard handler; use the one from this method instead.
                            this.suspend();
                            // Initial point/vertex anchor
                            this._lastVertexPosition = null;
                            this._vertexAnchor = this._map.graphics.add(new esri.Graphic(start.offset(0, 0), this.selectedVertexSymbol));
                            // Raise vertex moved event so tools that listen to move events are notified (e.g. snapping)
                            var vertexMovedArgs = {
                                sender: this,
                                mapPoint: start,
                                screenPoint: this._map.toScreen(start),
                                snappingPoint: this._lastSnappingPoint
                            };
                            this.raiseGraphicVertexMoved(vertexMovedArgs);
                            if (this._polyGeometryKeyDownHandle) {
                                this._polyGeometryKeyDownHandle.remove();
                                this._polyGeometryKeyDownHandle = null;
                            }
                            // Start plotting polygons with the keyboard
                            var plottedGeometry = null;
                            return new Promise(function (resolve, reject) { return _this._polyGeometryKeyDownHandle = _this._drawPolyGeometry_handleKeyDown(resolve, reject); })
                                .then(function (g) { return plottedGeometry = g; })
                                .catch(function () {
                                _this.onKeyboardStop(true);
                                plottedGeometry = null;
                                return plottedGeometry;
                            })
                                .lastly(function () {
                                // End the drawing session and reactivate map navigation
                                _this._isPlottingPolyGeometry = false;
                                _this.app.map.enableMapNavigation();
                                // Reconnect main keyboard handler
                                if (_this._polyGeometryKeyDownHandle) {
                                    _this._polyGeometryKeyDownHandle.remove();
                                    _this._polyGeometryKeyDownHandle = null;
                                }
                                _this.resume();
                                return plottedGeometry;
                            });
                        };
                        /** Handles keyboard input for plotting polygons, polylines and multipoints. */
                        Draw.prototype._drawPolyGeometry_handleKeyDown = function (resolve, reject) {
                            var _this = this;
                            // Subscribe to keyboard events
                            return dojo.on(this._map.root, "keydown", function (event) {
                                // ALT = "precise adjustments" e.g. moving 1px instead of 10px
                                var precise = event.altKey;
                                var dx = precise ? _this._options.preciseVertexOffsetX : _this._options.vertexOffsetX;
                                var dy = precise ? _this._options.preciseVertexOffsetY : _this._options.vertexOffsetY;
                                var code = event.keyCode || event.which;
                                switch (code) {
                                    case dojo.keys.UP_ARROW:
                                    case dojo.keys.NUMPAD_8:
                                        _this._moveVertexAnchor(0, -dy);
                                        break;
                                    case dojo.keys.RIGHT_ARROW:
                                    case dojo.keys.NUMPAD_6:
                                        _this._moveVertexAnchor(dx, 0);
                                        break;
                                    case dojo.keys.DOWN_ARROW:
                                    case dojo.keys.NUMPAD_2:
                                        _this._moveVertexAnchor(0, dy);
                                        break;
                                    case dojo.keys.LEFT_ARROW:
                                    case dojo.keys.NUMPAD_4:
                                        _this._moveVertexAnchor(-dx, 0);
                                        break;
                                    case dojo.keys.PAGE_UP:
                                    case dojo.keys.NUMPAD_9:
                                        _this._moveVertexAnchor(dx, -dy);
                                        break;
                                    case dojo.keys.PAGE_DOWN:
                                    case dojo.keys.NUMPAD_3:
                                        _this._moveVertexAnchor(dx, dy);
                                        break;
                                    case dojo.keys.END:
                                    case dojo.keys.NUMPAD_1:
                                        _this._moveVertexAnchor(-dx, dy);
                                        break;
                                    case dojo.keys.HOME:
                                    case dojo.keys.NUMPAD_7:
                                        _this._moveVertexAnchor(-dx, -dy);
                                        break;
                                    case dojo.keys.ENTER:
                                    case dojo.keys.NUMPAD_ENTER:
                                        // Finish drawing and reactivate map navigation if ENTER pressed twice on the same map location
                                        if (infrastructure.GeometryUtils.pointsAreEqual(_this._vertexAnchor.geometry, _this._lastVertexPosition)) {
                                            if (_this._graphic) {
                                                _this._map.graphics.remove(_this._graphic);
                                            }
                                            if (_this._vertexAnchor) {
                                                _this._map.graphics.remove(_this._vertexAnchor);
                                            }
                                            // Auto-complete the drawing and resolve the promise
                                            _this._finishKeyboardDrawing(false);
                                            resolve(_this._graphic ? _this._graphic.geometry : null);
                                        }
                                        else {
                                            // Add new vertex if ENTER was pressed on a new map location
                                            var mapPoint = _this._vertexAnchor.geometry;
                                            _this._addVertex(mapPoint);
                                            // Raise vertex added event so tools that listen to click events are notified (e.g. measurement)
                                            var vertexAddedArgs = {
                                                sender: _this,
                                                mapPoint: mapPoint,
                                                screenPoint: _this._map.toScreen(mapPoint),
                                                snappingPoint: _this._lastSnappingPoint
                                            };
                                            _this.raiseGraphicVertexAdded(vertexAddedArgs);
                                        }
                                        break;
                                    case dojo.keys.ESCAPE:
                                        // ...abort
                                        reject(null);
                                        break;
                                    default:
                                        return;
                                }
                                event.preventDefault();
                                event.stopPropagation();
                            });
                        };
                        /** Plots a shape on the map. It will produce either a default shape (e.g. circle) or a shape digitized via the keyboard (e.g. polygon) */
                        Draw.prototype._plotShape = function (location, geometryType) {
                            var screenCoords = this._map.toScreen(location);
                            switch (geometryType) {
                                case Draw.POINT:
                                    return Promise.resolve(location.offset(0, 0));
                                case Draw.POLYLINE:
                                    return this._drawPolyGeometry(location, geometryType);
                                case Draw.POLYGON:
                                    return this._drawPolyGeometry(location, geometryType);
                                case Draw.MULTI_POINT:
                                    return this._drawPolyGeometry(location, geometryType);
                                case Draw.ARROW:
                                    return Promise.resolve(this._toPolygon(this._arrowShapeTemplate, screenCoords.x, screenCoords.y));
                                case Draw.LEFT_ARROW:
                                    return Promise.resolve(this._toPolygon(this._leftArrowShapeTemplate, screenCoords.x, screenCoords.y));
                                case Draw.RIGHT_ARROW:
                                    return Promise.resolve(this._toPolygon(this._rightArrowShapeTemplate, screenCoords.x, screenCoords.y));
                                case Draw.UP_ARROW:
                                    return Promise.resolve(this._toPolygon(this._upArrowShapeTemplate, screenCoords.x, screenCoords.y));
                                case Draw.DOWN_ARROW:
                                    return Promise.resolve(this._toPolygon(this._downArrowShapeTemplate, screenCoords.x, screenCoords.y));
                                case Draw.TRIANGLE:
                                    return Promise.resolve(this._toPolygon(this._triangleShapeTemplate, screenCoords.x, screenCoords.y));
                                case Draw.RECTANGLE:
                                case Draw.EXTENT:
                                    return Promise.resolve(this._toPolygon(this._rectangleShapeTemplate, screenCoords.x - 48, screenCoords.y + 24));
                                case Draw.CIRCLE:
                                    var circle = Draw.createCircle({
                                        center: screenCoords,
                                        radius: 48,
                                        numberOfPoints: 60,
                                        map: this._map
                                    });
                                    return Promise.resolve(circle);
                                case Draw.ELLIPSE:
                                    var ellipse = Draw.createEllipse({
                                        center: screenCoords,
                                        longAxis: 48,
                                        shortAxis: 24,
                                        numberOfPoints: 60,
                                        map: this._map
                                    });
                                    return Promise.resolve(ellipse);
                            }
                            return Promise.resolve(null);
                        };
                        Draw.prototype._editShape = function (geometry) {
                            if (!geometry) {
                                // TODO log warning
                                return;
                            }
                            // If editing is disabled, raise the draw-end event and skip editing
                            if (this._options.enableEditing === false) {
                                this._clear();
                                this._drawEnd(geometry);
                                return;
                            }
                            // Suspend the draw component until editing of default shape is completed
                            this.suspend();
                            var gfxSymbol;
                            switch (geometry.type) {
                                case "point":
                                case "multipoint":
                                    gfxSymbol = this.markerSymbol;
                                    break;
                                case "polyline":
                                    gfxSymbol = this.lineSymbol;
                                    break;
                                case "polygon":
                                case "extent":
                                    gfxSymbol = this.fillSymbol;
                                    break;
                            }
                            // Add the temporary graphic to the map and activate the internal EDIT tools. 
                            var editMode = this._getEditMode(this._geometryType);
                            this._graphic = this._map.graphics.add(new esri.Graphic(geometry, gfxSymbol));
                            if (this._editCompletedHandle) {
                                this._editCompletedHandle.remove();
                                this._editCompletedHandle = null;
                            }
                            // Raise draw-end event once editing is completed.
                            this._editCompletedHandle = dojo.aspect.after(this._editObject, "onDeactivate", dojo.hitch(this, "_onEditShapeCompleted"), true);
                            // Start editing the shape
                            this._editObject.activate(editMode.mode, this._graphic, editMode.options);
                        };
                        /**
                         * Raises the draw-end event after editing is completed.
                         * @private
                         */
                        Draw.prototype._onEditShapeCompleted = function (tool, graphic, info) {
                            var isModified = info ? !!info.isModified : false;
                            var cancelled = info ? !!info.cancelled : false;
                            if (graphic && isModified) {
                                this._graphic = graphic;
                            }
                            this.resume();
                            this.onKeyboardStop(cancelled);
                        };
                        Draw.prototype._toPolygon = function (ring, dx, dy) {
                            var map = this._map;
                            var polygonRing = ring.map(function (vertex) {
                                return map.toMap(new esri.geometry.ScreenPoint(vertex[0] + dx, vertex[1] + dy));
                            });
                            var polygon = new esri.geometry.Polygon(map.spatialReference);
                            polygon.addRing(polygonRing);
                            return polygon;
                        };
                        Draw.prototype._syncPointsCollection = function () {
                            this._points = this._drawObject._points;
                        };
                        Draw.prototype._getEditMode = function (geometryType) {
                            var editMode = {
                                mode: 0,
                                options: {}
                            };
                            switch (geometryType) {
                                case Draw.POINT:
                                    editMode.mode = accessibility.Edit.MOVE;
                                    break;
                                case Draw.MULTI_POINT:
                                    editMode.mode = accessibility.Edit.EDIT_VERTICES;
                                    editMode.options.allowAddVertices = false;
                                    editMode.options.allowDeleteVertices = true;
                                    break;
                                case Draw.POLYLINE:
                                case Draw.ARROW:
                                case Draw.LEFT_ARROW:
                                case Draw.RIGHT_ARROW:
                                case Draw.UP_ARROW:
                                case Draw.DOWN_ARROW:
                                case Draw.TRIANGLE:
                                case Draw.RECTANGLE:
                                case Draw.POLYGON:
                                    editMode.mode = accessibility.Edit.MOVE | accessibility.Edit.ROTATE | accessibility.Edit.SCALE | accessibility.Edit.EDIT_VERTICES;
                                    editMode.options.allowAddVertices = true;
                                    editMode.options.allowDeleteVertices = true;
                                    editMode.options.uniformScaling = false;
                                    break;
                                case Draw.EXTENT:
                                    editMode.mode = accessibility.Edit.MOVE | accessibility.Edit.SCALE;
                                    editMode.options.allowAddVertices = false;
                                    editMode.options.allowDeleteVertices = false;
                                    editMode.options.uniformScaling = false;
                                    break;
                                case Draw.CIRCLE:
                                    editMode.mode = accessibility.Edit.MOVE | accessibility.Edit.SCALE;
                                    editMode.options.uniformScaling = true;
                                    break;
                                case Draw.ELLIPSE:
                                    editMode.mode = accessibility.Edit.MOVE | accessibility.Edit.ROTATE | accessibility.Edit.SCALE;
                                    editMode.options.uniformScaling = false;
                                    break;
                            }
                            return editMode;
                        };
                        Draw.prototype._vertexCount = function (g) {
                            if (g && g.type === "polyline") {
                                return g.paths[0].length;
                            }
                            if (g && g.type === "polygon") {
                                return g.rings[0].length - 1;
                            }
                            if (g && g.type === "multipoint") {
                                return g.points.length;
                            }
                            return 0;
                        };
                        /**
                         * Esri's JavaScript API 3.8 have caused numerous problems with markup and measurement, resulting in the need for numerous hacks
                         * and workarounds in the measurement, markup and printing modules, and possibly others as well.
                         * This is a central placeholder for all hacks and workarounds needed by the WCAG accessible tools.
                         *
                         * See GVH-3523, GVH-3535, GVH-3516, GVH-4973
                         */
                        Draw.prototype._twoClicksWithin300MsFixup = function () {
                            var _this = this;
                            var castDrawObject = this._drawObject;
                            if (castDrawObject && typeof castDrawObject._onClickHandler === "function") {
                                // GVH-3523: Don't allow Esri's _onClickHandler function to execute twice within 300ms. This should not happen anyway.
                                var origOnClickHandler = castDrawObject._onClickHandler;
                                castDrawObject._onClickHandler = function (evt) { return _this._twoClicksWithin300MsFixup_handleClick(evt, origOnClickHandler); };
                            }
                            else {
                                this.app.trace.warning("The _drawObject _onClickHandler hook is dysfunctional. Markup and Measurement (tool) functionality may be affected on touch devices.");
                            }
                        };
                        Draw.prototype._twoClicksWithin300MsFixup_handleClick = function (evt, origOnClickHandler) {
                            var disableEsriOnClickHandler = false;
                            // GVH-3535: We need to monitor previous coordinates because in Android 4.x, Esri's jsapi 3.8 throws each single click event twice. (!!!)
                            var prevXcoord = 0;
                            var prevYcoord = 0;
                            var updatePrevCoords = function (args) {
                                prevXcoord = args[0].mapPoint.x;
                                prevYcoord = args[0].mapPoint.y;
                            };
                            if (this._geometryType === Draw.POLYLINE || this._geometryType === Draw.POLYGON || this._geometryType === Draw.POINT || this._geometryType === Draw.MULTI_POINT) {
                                if (!disableEsriOnClickHandler && !(evt.mapPoint.x === prevXcoord && evt.mapPoint.y === prevYcoord)) {
                                    disableEsriOnClickHandler = true;
                                    setTimeout(function () {
                                        disableEsriOnClickHandler = false;
                                    }, 300);
                                    var vertexArgs = {
                                        sender: this,
                                        mapPoint: evt.mapPoint,
                                        screenPoint: evt.screenPoint,
                                        snappingPoint: this._lastSnappingPoint
                                    };
                                    // Invoke Esri's original click handler
                                    origOnClickHandler.apply(this._drawObject, arguments);
                                    // Raise app-wide event to notify measurement tools that a new vertex has been added
                                    this.raiseGraphicVertexAdded(vertexArgs);
                                }
                                // Keep track of previous mouse coordinates
                                updatePrevCoords(arguments);
                            }
                            else {
                                origOnClickHandler.apply(this._drawObject, arguments);
                            }
                        };
                        Draw.prototype._extraPointOnTouchDevicesFixup = function () {
                            /**
                             * Desktop browsers always send a click event before a double-click (i.e. you get one click event and then a double click event) so Esri's draw tool will add points
                             * to an internal array (_points) on every click. On double-click it will complete the geometry (e.g. closing a polygon) and fire the "draw-end" event.
                             *
                             * Contrast the above with iOS Safari where NO CLICK is fired before a double-click (that is, you get the double-click event without a prior click event). This is done
                             * by design to support an iOS feature (double-tap to zoom) which is also why mobile browsers have a 300ms delay between a tap and the firing of an actual
                             * click event (see http://blogs.telerik.com/appbuilder/posts/13-11-21/what-exactly-is.....-the-300ms-click-delay)
                             *
                             * Esri compensated for this on their API by adding the point to their internal array on a double-click only for mobile browsers so their drawing tools work as expected
                             * on their sample pages. Now, GVH has a library (Fastclick) that works around the 300ms delay by emitting synthetic click events whenever a "touch" event happens (touch events are not
                             * subject to the delay). It also normalizes click events among several platforms (iOS, Android, etc) so when Fastclick is enabled you get a click event before the double-click,
                             * just like normal desktop browsers do. This leads to having an extra point in your geometry because Esri is going to add an additional point when you double-click on touch devices.
                             *
                             * The following fix-up involves overriding the "push" function of that internal _points array so it ignores that last extra point. This works because we attach to the map's double-click
                             * event before activating Esri's tool so our handler will execute before Esri's double-click handler.
                             */
                            var _this = this;
                            // GVH-3511: In Esri's js 3.8 API, sometimes rapid double clicking will not fire the draw-end event due to the last vertex not being added. Check for this and add it manually.
                            // Note: This is a HORRIBLE fix necessitated by quirks in esri's 3.8 API - This should be reviewed in later API releases and removed if possible
                            var executeEsriVertexAddDrawEndFixup = function (args) {
                                var castDrawObject = _this._drawObject;
                                var esriTouch = !!(require && require.has && require.has("esri-touch"));
                                _this.app.trace.debug("[DrawTool] IsTouch = " + esriTouch);
                                // <asanchez> The following had to be commented out to fix GVH-6686. It doesn't seem to regress GVH-3558 on Android KitKat so seemed safe to remove/comment.
                                // GVH-3558: This will be ignored if _onClickHandler has been correctly fired as it should have been.
                                //if (castDrawObject && typeof castDrawObject._onClickHandler === "function") {
                                //    castDrawObject._onClickHandler(args);
                                //}
                                // Note: We are modifying the private "_points" property within Esri draw toolbar. The code below might break in future releases of Esri API.
                                var drawPoints = castDrawObject ? castDrawObject._points : null;
                                // Touch devices need special handling (GVH-3516)
                                if (drawPoints) {
                                    if (esriTouch) {
                                        if (drawPoints.length >= 2) {
                                            var origPush = drawPoints.push;
                                            // We're rendering the push function ineffective exactly one time. This is because esri suddenly decided to push a copy of the last
                                            // set of point on their double click handler function for touch devices which results in GVH-3516
                                            drawPoints.push = function () {
                                                _this.app.trace.debug("[DrawTool] points.length " + drawPoints.length);
                                                drawPoints.push = origPush;
                                            };
                                        }
                                    }
                                    else {
                                        if (drawPoints.length < 2 || (drawPoints[drawPoints.length - 1].x !== args.mapPoint.x && drawPoints[drawPoints.length - 1].y !== args.mapPoint.y)) {
                                            // GVH-6686
                                            // Bailout of the hotfix if we are snapping. The mouse position and last vertex position will almost never be the same.
                                            if (_this._lastSnappingPoint) {
                                                _this.app.trace.debug("[DrawTool] Bailout due to snapping");
                                                return;
                                            }
                                            drawPoints.push(args.mapPoint);
                                            // Raise app-wide event to notify measurement tools that a new vertex has been added
                                            _this.raiseGraphicVertexAdded({ sender: _this, mapPoint: args.mapPoint, screenPoint: args.screenPoint, snappingPoint: _this._lastSnappingPoint });
                                        }
                                    }
                                }
                            };
                            if (!this._dblClickHandlerToken) {
                                this._dblClickHandlerToken = this.app.map.on("dbl-click", executeEsriVertexAddDrawEndFixup); // GVH-3511, GVH-3516, GVH-3558
                            }
                            else {
                                this.app.trace.debug("[DrawTool] No double click subscribed");
                            }
                        };
                        // Static constructor
                        Draw._draw = (function () {
                            require(["esri/toolbars/draw"], function (EsriDraw) {
                                Draw.ARROW = EsriDraw.ARROW;
                                Draw.CIRCLE = EsriDraw.CIRCLE;
                                Draw.DOWN_ARROW = EsriDraw.DOWN_ARROW;
                                Draw.ELLIPSE = EsriDraw.ELLIPSE;
                                Draw.EXTENT = EsriDraw.EXTENT;
                                Draw.FREEHAND_POLYGON = EsriDraw.FREEHAND_POLYGON;
                                Draw.FREEHAND_POLYLINE = EsriDraw.FREEHAND_POLYLINE;
                                Draw.LEFT_ARROW = EsriDraw.LEFT_ARROW;
                                Draw.LINE = EsriDraw.LINE;
                                Draw.MULTI_POINT = EsriDraw.MULTI_POINT;
                                Draw.POINT = EsriDraw.POINT;
                                Draw.POLYGON = EsriDraw.POLYGON;
                                Draw.POLYLINE = EsriDraw.POLYLINE;
                                Draw.RECTANGLE = EsriDraw.RECTANGLE;
                                Draw.RIGHT_ARROW = EsriDraw.RIGHT_ARROW;
                                Draw.TRIANGLE = EsriDraw.TRIANGLE;
                                Draw.UP_ARROW = EsriDraw.UP_ARROW;
                            });
                        })();
                        return Draw;
                    }(accessibility.AccessibleMapComponent));
                    accessibility.Draw = Draw;
                    var Draw;
                    (function (Draw) {
                        /**
                         * Editing component used internally by the Draw component.
                         * It explicitly overrides a few parent methods to avoid emitting events since this component is internal.
                         */
                        var EditInternal = (function (_super) {
                            __extends(EditInternal, _super);
                            function EditInternal() {
                                _super.apply(this, arguments);
                            }
                            EditInternal.prototype.raiseGraphicEditActivated = function (eventArgs) {
                                this.app.event("GraphicDrawAccessibleEditActivatedEvent").publish(eventArgs);
                            };
                            EditInternal.prototype.raiseGraphicEditDeactivated = function (eventArgs) {
                                this.app.event("GraphicDrawAccessibleEditDeactivatedEvent").publish(eventArgs);
                            };
                            return EditInternal;
                        }(infrastructure.accessibility.Edit));
                        Draw.EditInternal = EditInternal;
                    })(Draw = accessibility.Draw || (accessibility.Draw = {}));
                })(accessibility = infrastructure.accessibility || (infrastructure.accessibility = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                /**
                 * A source for generating CancellationTokens. First create a CancellationTokenSource, then
                 * using the token property to obtain the cancellation token. The token can be cancelled by
                 * calling cancel() on the CancellationTokenSource.
                 */
                var CancellationTokenSource = (function () {
                    function CancellationTokenSource() {
                        this._tokenImpl = new CancellationTokenImpl();
                    }
                    /**
                     * Gets the cancellation token.
                     */
                    CancellationTokenSource.prototype.token = function () {
                        return this._tokenImpl;
                    };
                    /**
                     * Cancels the CancellationToken, setting isCancellationRequested to true, and invoking any registered listeners.
                     */
                    CancellationTokenSource.prototype.cancel = function () {
                        this._tokenImpl.cancel();
                    };
                    /**
                     * Removes subscriptions that were created using register().
                     */
                    CancellationTokenSource.prototype.dispose = function () {
                        this._tokenImpl.dispose();
                    };
                    /**
                     * Creates a CancellationToken that does nothing.
                     */
                    CancellationTokenSource.none = function () {
                        if (!this._none) {
                            this._none = {
                                isCancellationRequested: false,
                                register: function (action) {
                                }
                            };
                        }
                        return this._none;
                    };
                    return CancellationTokenSource;
                }());
                infrastructure.CancellationTokenSource = CancellationTokenSource;
                /**
                 * @private
                 */
                var CancellationTokenImpl = (function () {
                    function CancellationTokenImpl() {
                        this._listeners = new Array();
                        this.isCancellationRequested = false;
                    }
                    CancellationTokenImpl.prototype.register = function (action) {
                        this._listeners.push(action);
                    };
                    CancellationTokenImpl.prototype.cancel = function () {
                        this.isCancellationRequested = true;
                        for (var i = 0; i < this._listeners.length; i++) {
                            this._listeners[i]();
                        }
                    };
                    CancellationTokenImpl.prototype.dispose = function () {
                        this._listeners.length = 0;
                    };
                    return CancellationTokenImpl;
                }());
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                /**
                 * Indicates where a bookmark was loaded from.
                 */
                (function (BookmarkSource) {
                    BookmarkSource[BookmarkSource["Site"] = 0] = "Site";
                    BookmarkSource[BookmarkSource["User"] = 1] = "User";
                    BookmarkSource[BookmarkSource["Project"] = 2] = "Project";
                })(infrastructure.BookmarkSource || (infrastructure.BookmarkSource = {}));
                var BookmarkSource = infrastructure.BookmarkSource;
                /** Storage key for user-defined bookmarks. */
                var BookmarksStorageKey = "bookmarks";
                var BookmarkManager = (function () {
                    function BookmarkManager(app) {
                        /** Stores bookmarks that come from a project. */
                        this._projectBookmarks = [];
                        if (!app) {
                            throw new Error("Parameter \"app\" required.");
                        }
                        this.app = app;
                    }
                    /**
                     * Gets all bookmarks.
                     */
                    BookmarkManager.prototype.getAll = function () {
                        var _this = this;
                        return Promise.join(this.getSiteBookmarks(), this.getUserBookmarks())
                            .spread(function (siteDefined, userDefined) { return (siteDefined || []).concat(userDefined).concat(_this._projectBookmarks); });
                    };
                    /**
                     * Gets the user-defined bookmarks.
                     */
                    BookmarkManager.prototype.getUserBookmarks = function () {
                        var _this = this;
                        return new Promise(function (resolve, reject) {
                            _this.app.store.get(BookmarksStorageKey, function (storeData) {
                                var serializedBookmarks = [];
                                if (storeData) {
                                    try {
                                        serializedBookmarks = JSON.parse(storeData);
                                    }
                                    catch (error) {
                                        // Catch any parse errors and fall back to the default value
                                        _this.app.trace.warning("Unable to parse user bookmarks: {0}".format(error));
                                    }
                                }
                                var bookmarks = serializedBookmarks.map(function (b) { return _this._deserialize(b); });
                                resolve(bookmarks);
                            }, reject);
                        });
                    };
                    /**
                     * Gets the bookmarks that are defined in the site.
                     */
                    BookmarkManager.prototype.getSiteBookmarks = function () {
                        var _this = this;
                        return this.app.waitUntilSiteInitialized().then(function () {
                            return (_this.app.site.namedExtents || []).map(function (ne) {
                                return {
                                    name: ne.displayName,
                                    extent: ne.extent,
                                    source: BookmarkSource.Site
                                };
                            });
                        });
                    };
                    /**
                     * Gets the bookmarks that were restored from a project.
                     */
                    BookmarkManager.prototype.getProjectBookmarks = function () {
                        return Promise.resolve(this._projectBookmarks);
                    };
                    /**
                     * Adds a new bookmark.
                     */
                    BookmarkManager.prototype.add = function (bookmark) {
                        var _this = this;
                        if (!bookmark) {
                            throw new Error("Parameter \"bookmark\" required.");
                        }
                        bookmark.source = bookmark.source || BookmarkSource.User;
                        if (bookmark.source === BookmarkSource.Project) {
                            this._projectBookmarks.push(bookmark);
                            // The event parameter is meaningless in this case, but it's there for backward compatibility.
                            this.app.event("BookmarksModifiedEvent").publish("");
                            return Promise.resolve();
                        }
                        else {
                            return this.getUserBookmarks().then(function (bookmarks) {
                                bookmarks.push(bookmark);
                                return _this._save(bookmarks);
                            });
                        }
                    };
                    /**
                     * Removes a bookmark. Only user-defined bookmarks can be removed this way.
                     * @param bookmark The bookmark to remove, or the name of the bookmark. In the latter case,
                     *     if multiple bookmarks exist with the given name, then ALL user-defined bookmarks with
                     *     the given name will be removed.
                     */
                    BookmarkManager.prototype.remove = function (bookmark) {
                        var _this = this;
                        if (!bookmark) {
                            return;
                        }
                        // Remove from project bookmarks.
                        if (typeof bookmark === "string") {
                            this._projectBookmarks = this._projectBookmarks.filter(function (b) { return b.name !== bookmark; });
                        }
                        else if (typeof bookmark === "object") {
                            this._projectBookmarks = this._projectBookmarks.filter(function (b) { return b !== bookmark; });
                        }
                        // Remove from user storage.
                        return this.getUserBookmarks().then(function (bookmarks) {
                            if (typeof bookmark === "string") {
                                bookmarks = bookmarks.filter(function (b) { return b.name !== bookmark; });
                            }
                            else if (typeof bookmark === "object") {
                                bookmarks = bookmarks.filter(function (b) { return b !== bookmark; });
                            }
                            return _this._save(bookmarks);
                        });
                    };
                    /**
                     * Exports bookmarks in web map format.
                     */
                    BookmarkManager.prototype.export = function (sourceTypes) {
                        var _this = this;
                        sourceTypes = sourceTypes || [BookmarkSource.Site, BookmarkSource.User, BookmarkSource.Project];
                        return this.getAll().then(function (bookmarks) {
                            return bookmarks.filter(function (b) { return sourceTypes.indexOf(b.source) >= 0; })
                                .map(function (b) {
                                return {
                                    name: b.name,
                                    extent: _this.app.project.convert.fromEsriGeometry(b.extent)
                                };
                            });
                        });
                    };
                    BookmarkManager.prototype._save = function (bookmarks) {
                        var _this = this;
                        return new Promise(function (resolve, reject) {
                            var storeData = JSON.stringify((bookmarks || []).map(function (b) { return _this._serialize(b); }));
                            _this.app.store.set(BookmarksStorageKey, storeData, function (key, value) {
                                resolve();
                                _this.app.event("BookmarksModifiedEvent").publish(storeData);
                            }, reject);
                        });
                    };
                    BookmarkManager.prototype._serialize = function (bookmark) {
                        return {
                            displayName: bookmark.name,
                            extent: this.app.webMap.convert.fromEsriGeometry(bookmark.extent),
                            isUserDefined: true
                        };
                    };
                    BookmarkManager.prototype._deserialize = function (serializedBookmark) {
                        return {
                            name: serializedBookmark.displayName,
                            extent: this.app.webMap.convert.toEsriGeometry(serializedBookmark.extent),
                            source: BookmarkSource.User
                        };
                    };
                    return BookmarkManager;
                }());
                infrastructure.BookmarkManager = BookmarkManager;
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var AttributeGroup = (function () {
                    function AttributeGroup() {
                    }
                    return AttributeGroup;
                }());
                infrastructure.AttributeGroup = AttributeGroup;
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../_Definitions/framework.d.ts"/>
/// <reference path="../../_Definitions/essentials.d.ts"/>
/// <reference path="./AttributeGroup.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var DataLinkingResult = (function () {
                    /**
                     * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.DataLinkingResult} class.
                     */
                    function DataLinkingResult() {
                        /**
                         * This references the original datalink that was used to create this object
                         * @type DataLink
                         */
                        this.dataLink = new Observable();
                        /**
                         * This is the raw data from a datalinking request. This contains columns and rows.
                         * @type Object
                         */
                        this.table = new Observable();
                    }
                    /**
                     * Converts the table of the datalink to a basic attribute map.
                     */
                    DataLinkingResult.prototype.toAttributes = function () {
                        var table = this.table.get();
                        if (!table) {
                            return null;
                        }
                        var dict = {};
                        for (var i = 0; i < table.columns.length; i++) {
                            var key = table.columns[i];
                            var value = table.rows.length > 0 ? table.rows[0].row[i] : null;
                            dict[key] = value;
                        }
                        return dict;
                    };
                    /**
                     * Returns a copy of this datalink in an attribute group form.
                     */
                    DataLinkingResult.prototype.asAttributeGroup = function () {
                        if (!this._attributeGroup) {
                            this._attributeGroup = new infrastructure.AttributeGroup();
                            this._attributeGroup.owner = this;
                            this._attributeGroup.attributes = this.toAttributes();
                        }
                        return this._attributeGroup;
                    };
                    return DataLinkingResult;
                }());
                infrastructure.DataLinkingResult = DataLinkingResult;
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../_Definitions/framework.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var FeatureAttribute = (function () {
                    /**
                     * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureAttribute} class.
                     * @class
                     * <p>Represents a Geocortex Essentials FeatureAttribute.</p>
                     * @constructs
                     * @memberOf geocortex.essentialsHtmlViewer.mapping.infrastructure
                     * @param value The value of the attribute.
                     * @param name The name of the attribute.
                     * @param alias The alias name of the attribute.
                     * @param displayName The display name of the attribute.
                     */
                    function FeatureAttribute(value, name, alias, displayName, visible, presenterDelegate, dataType) {
                        this.value = new Observable(typeof value === "undefined" ? "" : value);
                        this.name = new Observable(typeof name === "undefined" ? "" : name);
                        this.alias = new Observable(typeof alias === "undefined" ? this.name.get() : alias);
                        this.displayName = new Observable(typeof displayName === "undefined" ? (this.alias.get() ? this.alias.get() : this.name.get()) : displayName); // Fallback to the alias, but prefer the name over an empty alias
                        this.visible = new Observable(typeof visible === "undefined" ? true : visible);
                        this.type = new Observable(typeof dataType === "undefined" ? "" : dataType);
                        presenterDelegate = presenterDelegate || infrastructure.PresentableDelegateFactory.valuePresenterDelegate(null, null);
                        this.presentableValue = new geocortex.framework.ui.LazyObservable(null, presenterDelegate(value), true);
                        this.displayAsUrl = geocortex.framework.utils.isUrl(value);
                    }
                    /**
                     * Matches attribute names generated by SEP that should not be visible.
                     */
                    FeatureAttribute.ignoreAttribute = function (name) {
                        return name && FeatureAttribute.ignoreAttributeMatcher.test(name);
                    };
                    FeatureAttribute.ignoreAttributeMatcher = /.*\.Name\(\)$/;
                    return FeatureAttribute;
                }());
                infrastructure.FeatureAttribute = FeatureAttribute;
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../_Definitions/moment.d.ts" />
/// <reference path="../../_Definitions/globalize.d.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                /**
                 * Pre-defined format specifiers for use with formatDate().
                 */
                var DateFormat = (function () {
                    function DateFormat() {
                    }
                    /**
                     * A localized representation of a date (e.g. "09/04/1986" for en-US locale).
                     */
                    DateFormat.DATE_SHORT = "d";
                    /**
                     * A localized long representation of a date (e.g. "September 4 1986" for en-US locale).
                     */
                    DateFormat.DATE_LONG = "D";
                    /**
                     * A localized short representation of the time (e.g. "8:30 PM" for en-US locale).
                     */
                    DateFormat.TIME_SHORT = "t";
                    /**
                     * A localized representation of the time including seconds (e.g. "8:30:25 PM" for en-US locale).
                     */
                    DateFormat.TIME_LONG = "T";
                    /**
                     * A localized representation of date and time (e.g. "Sep 4 1986 8:30 PM" for en-US locale).
                     */
                    DateFormat.DATE_TIME_SHORT = "g";
                    /**
                     * A localized long representation of date and time (e.g. "September 4 1986 8:30 PM" for en-US locale).
                     */
                    DateFormat.DATE_TIME_LONG = "G";
                    /**
                     * A localized full representation of date and time, including day of week (e.g. "Thursday, September 4 1986 8:30 PM" for en-US locale).
                     */
                    DateFormat.FULL = "f";
                    /**
                     * The date and time in ISO-8601 format (e.g. "2014-09-08T08:02:17-05:00"). Invariant.
                     */
                    DateFormat.ISO_8601 = "u";
                    /**
                     * An invariant representation of a date. Guarantees that the date can be parsed back into the same date, regardless of locale.
                     * Equivalent to ISO-8601.
                     */
                    DateFormat.ROUND_TRIP = "u";
                    /**
                     * The default representation for date values (equivalent to DATE_TIME_SHORT).
                     */
                    DateFormat.DEFAULT = "g";
                    /**
                     * The default set of formats used for parsing date values.
                     */
                    DateFormat.DEFAULT_PARSING_FORMATS = [DateFormat.ISO_8601, DateFormat.DATE_TIME_SHORT, DateFormat.DATE_TIME_LONG, DateFormat.DATE_SHORT, DateFormat.DATE_LONG];
                    return DateFormat;
                }());
                infrastructure.DateFormat = DateFormat;
                /**
                 * Pre-defined format specifiers for use with formatNumber().
                 */
                var NumberFormat = (function () {
                    function NumberFormat() {
                    }
                    /**
                     * A localized representation of a number with a decimal separator and group separators (e.g. "12,345.67", "-42" for en-US locale).
                     */
                    NumberFormat.NUMBER = "n";
                    /**
                     * A localized representation of a number with a decimal separator (e.g. "12345.67", "-42" for en-US locale).
                     */
                    NumberFormat.FIXED_POINT = "f";
                    /**
                     * A localized representation of a monetary amount in a specific currency (e.g. "$123.45" for USD, "£123.45" for GBP for en-US locale).
                     */
                    NumberFormat.CURRENCY = "c";
                    /**
                     * Same as CURRENCY, except that negative values are displayed in parentheses instead of using a "-" sign.
                     */
                    NumberFormat.ACCOUNTING = "a";
                    /**
                     * A localized representation of a percentage (e.g. 0.99 -> "99%" in the en-US locale).
                     */
                    NumberFormat.PERCENT = "p";
                    /**
                     * An invariant representation of a number (e.g. "12345.67"). Guarantees that the number can be parsed back
                     * into the same number, regardless of locale.
                     */
                    NumberFormat.ROUND_TRIP = "r";
                    /**
                     * The default representation for number values (equivalent to FIXED_POINT).
                     */
                    NumberFormat.DEFAULT = NumberFormat.FIXED_POINT;
                    return NumberFormat;
                }());
                infrastructure.NumberFormat = NumberFormat;
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var FormatUtils;
                (function (FormatUtils) {
                    /**
                     * A special date instance that signifies failure to parse a date. The timestamp
                     * for this date (obtained via getTime()) will be NaN. This way of signifying failure
                     * is in keeping with "new Date(string)" and "Date.parse(string)".
                     */
                    var invalidDate = new Date(NaN);
                    /**
                     * Formats a value for display in the current locale.
                     * @param value The value to format.
                     */
                    function format(value) {
                        if (value instanceof Date) {
                            return formatDate(value);
                        }
                        else if (typeof value === "number") {
                            return formatNumber(value);
                        }
                        else if (value === null || value === undefined) {
                            return "";
                        }
                        else {
                            // TODO: The CLDR data used by Globalize has localized versions of "Yes" and "No"
                            // that we could use here for boolean values.
                            return value.toString();
                        }
                    }
                    FormatUtils.format = format;
                    /**
                     * Formats a date for display in the current locale.
                     * @param date The date to format.
                     * @param format One of the {@link DateFormat} constants, or a custom format string.
                     *     The format string syntax is similar to this: https://msdn.microsoft.com/en-us/library/8kb3ddd4.aspx,
                     *     with the following exceptions:
                     *         - "/", and ":" are treated as literal characters.
                     *         - "y" is treated as "yy", and "yyy" is treated as "yyyy".
                     *         - "z" and "zz" and "zzz" are treated as the UTC offset
                     *         - "t" is treated the same as "tt".
                     *         - "F", "FF", "FFF" etc. will behave the same as "f", "ff", "fff", etc.
                     *           Additionally, a maximum of 3 digits (milliseconds) is supported. Longer
                     *           formatters like "fffff" are truncated to 3 digits, rather than padded with zeros.
                     *         - "g", "gg", and "K" are not supported at all and will be ignored.
                     *     The default format is DATE_TIME_SHORT.
                     * @param options {@link DateFormatOptions} specifying the timezone and display timezone of the data.
                     *     If the display timezone is specified and z's appear in the format, the UTC offset will be calculated
                     *     for the display timezone instead of the timezone of the browser.
                     */
                    function formatDate(date, format, options) {
                        if (format === void 0) { format = infrastructure.DateFormat.DEFAULT; }
                        var utcOffset = null;
                        if (!date || !date.getTime || isNaN(date.getTime())) {
                            return "";
                        }
                        if (!moment) {
                            throw new Error("Error: The \"moment.js\" library is required for formatting dates.");
                        }
                        var adjustedDate = _correctDatesForDisplay(date, options);
                        if (options) {
                            var unadjustedMomentDate = moment(date.toISOString());
                            if (options.displayTimeZoneId) {
                                utcOffset = unadjustedMomentDate.tz(options.displayTimeZoneId).format("Z");
                            }
                        }
                        return moment(adjustedDate).format(_dateFormatToMomentFormat(format, utcOffset));
                    }
                    FormatUtils.formatDate = formatDate;
                    /**
                     * Formats a date for display in the current locale using relative time.
                     * @param date The date to format.
                     */
                    function formatDateFromNow(date, options) {
                        if (!date || !date.getTime || isNaN(date.getTime())) {
                            return "";
                        }
                        if (!moment) {
                            throw new Error("Error: The \"moment.js\" library is required for formatting dates.");
                        }
                        var adjustedDate = _correctDatesForDisplay(date, options);
                        return moment(adjustedDate).fromNow();
                    }
                    FormatUtils.formatDateFromNow = formatDateFromNow;
                    function _correctDatesForDisplay(date, options) {
                        // If we dont have date format options, return the date;
                        if (!options) {
                            return date;
                        }
                        // If we have no admin-defined time zone ID, either the feature belongs to a time-aware layer that
                        // already accounts for the time differences, or an error occurred in setting the default time zone.
                        // Either way, we should bail out and continue formatting the date as though it is accurate.
                        if (!options.timeZoneId && !options.displayTimeZoneId) {
                            return date;
                        }
                        // If we have no admin-defined user time zone ID, we assume the date should be displayed in the browser's
                        // local time zone.
                        if (!options.displayTimeZoneId) {
                            return infrastructure.TimeZoneUtils.correctDatesForDisplayInLocalTime(date, options.timeZoneId);
                        }
                        else if (!options.timeZoneId) {
                            // If we have a user time zone ID but no time zone ID for the database, we proceed under the assumption
                            // that the data is in UTC (or otherwise properly accounted for by AGS) but the admin still wants to
                            // unify the presentation of the times to a single time zone.
                            return infrastructure.TimeZoneUtils.correctDatesForDisplayInDisplayTimeZone(date, infrastructure.TimeZoneUtils.UTC_ZONE_ID, options.displayTimeZoneId);
                        }
                        // We have all the information we need to properly correct dates to display in a single given time zone regardless
                        // of the time zone of the client.
                        return infrastructure.TimeZoneUtils.correctDatesForDisplayInDisplayTimeZone(date, options.timeZoneId, options.displayTimeZoneId);
                    }
                    /**
                      * Formats a number for display using the application's current locale.
                      * @param num The number to format.
                      * @param format One of the {@link NumberFormat} constants, or a custom format string.
                      *     The format string syntax is similar to this: https://msdn.microsoft.com/en-us/library/0c899ak8.aspx,
                      *     with the following exceptions:
                      *         - The per-mille placeholder (‰) is not supported.
                      *         - Exponential notation is not supported.
                      *         - Literal characters appearing in the middle of a number will not work properly (e.g "00ABC0.##").
                      * @param options Additional options that further control how numbers are formatted. These only apply
                      *     when using one of the pre-defined constants, NOT for custom formats. Options are:
                      *         - currency: The 3-letter ISO 4217 currency code (e.g "USD", "CAD"). Required when formatting
                      *           a number using NumberFormat.CURRENCY or NumberFormat.ACCOUNTING.
                      *         - fractionalDigits: The number of digits to show after the decimal point. If unspecified, an
                      *           appropriate value is determined based on the locale and currency.
                      */
                    function formatNumber(num, format, options) {
                        if (format === void 0) { format = infrastructure.NumberFormat.DEFAULT; }
                        if (options === void 0) { options = {}; }
                        if (num === null || num === undefined || isNaN(num)) {
                            return "";
                        }
                        format = format || infrastructure.NumberFormat.DEFAULT;
                        options = options || {};
                        // Special case: invariant format.
                        if (format === infrastructure.NumberFormat.ROUND_TRIP) {
                            return num.toString();
                        }
                        if (!_globalize) {
                            throw new Error("Error: The \"globalize.js\" library is required for formatting numbers.");
                        }
                        // For standard formats, combine with the options argument into a standard format string.
                        var lcFormat = format.toLowerCase();
                        if (lcFormat === infrastructure.NumberFormat.CURRENCY
                            || lcFormat === infrastructure.NumberFormat.ACCOUNTING) {
                            format = lcFormat;
                            format += (options.fractionalDigits !== undefined ? options.fractionalDigits : "");
                            format += options.currency ? "$" + options.currency.toUpperCase() : "";
                        }
                        else if (lcFormat === infrastructure.NumberFormat.NUMBER
                            || lcFormat === infrastructure.NumberFormat.FIXED_POINT
                            || lcFormat === infrastructure.NumberFormat.PERCENT) {
                            format = lcFormat;
                            format += options.fractionalDigits !== undefined ? options.fractionalDigits : "";
                        }
                        // Check the cache for a pre-existing formatter array. A formatter array is a triplet
                        // of formatter functions for handling positive values, negative values, and 0 (in that order).
                        var locale = _globalize.locale() ? _globalize.locale().locale : "en";
                        var cacheKey = locale + "|" + format;
                        var formatters = _numberFormatters[cacheKey];
                        if (!formatters) {
                            formatters = [];
                            // Break up the format string into sections and create appropriate formatters for each
                            // section. See the above link for .NET number formats for more details on sections.
                            var formatSections = format.split(";", 3);
                            if (formatSections.length === 1) {
                                formatters[0] = _createNumberFormatter(formatSections[0]);
                                formatters[1] = formatters[0];
                                formatters[2] = formatters[0];
                            }
                            else if (formatSections.length === 2) {
                                formatters[0] = _createNumberFormatter(formatSections[0]);
                                formatters[1] = _createNumberFormatter(formatSections[1]);
                                formatters[2] = formatters[0];
                            }
                            else if (formatSections.length === 3) {
                                formatters[0] = _createNumberFormatter(formatSections[0]);
                                formatters[1] = _createNumberFormatter(formatSections[1]);
                                formatters[2] = _createNumberFormatter(formatSections[2]);
                            }
                            _numberFormatters[cacheKey] = formatters;
                        }
                        return num > 0 ? formatters[0](num) : num < 0 ? formatters[1](num) : formatters[2](num);
                    }
                    FormatUtils.formatNumber = formatNumber;
                    /**
                     * Parses a value into a Date object, using the application's current locale. The input is assumed to be in local time.
                     * See also {@link parseUtcDate()}.
                     * @param input The input to parse. Numbers are treated as UNIX timestamps (always UTC).
                     * @param format The format that string input is expected to be in. Can be either a single format, or one of several
                     *     possible formats. Formats are either one of the {@link DateFormat} constants, or custom format strings
                     *     (as per {@link formatDate()}).
                     * @return A Date object corresponding to the input, which might be an Invalid Date (i.e. getTime() will be NaN).
                     */
                    function parseDate(input, format) {
                        return _parseDate(input, false, format);
                    }
                    FormatUtils.parseDate = parseDate;
                    /**
                     * Parses a value into a Date object, using the application's current locale. The input is assumed to be in UTC.
                     * See also {@link parseDate()}.
                     * @param input The input to parse. Numbers are treated as UNIX timestamps.
                     * @param format The format that string input is expected to be in. Can be either a single format, or one of several
                     *     possible formats. Formats are either one of the {@link DateFormat} constants, or custom format strings
                     *     (as per {@link formatDate()}).
                     * @return A Date object corresponding to the input, which might be an Invalid Date (i.e. getTime() will be NaN).
                     */
                    function parseUtcDate(input, format) {
                        return _parseDate(input, true, format);
                    }
                    FormatUtils.parseUtcDate = parseUtcDate;
                    /**
                     * Parses a value into a number, using the application's current locale.
                     * @param input The input to parse.
                     * @param format The format that string input is expected to be in. Can be either a single format, or one of several
                     *     possible formats. Formats are either one of the {@link NumberFormat} constants, or custom format strings
                     *     (as per {@link formatNumber()}).
                     */
                    function parseNumber(input, format) {
                        if (typeof input === "number") {
                            return input;
                        }
                        else if (typeof input === "boolean") {
                            return input ? 1 : 0;
                        }
                        else if (input === null || input === undefined) {
                            return NaN;
                        }
                        if (!_globalize) {
                            throw new Error("Error: The \"globalize.js\" library is required for parsing numbers.");
                        }
                        input = input.toString().trim();
                        // There is a bug in Globalize where it can fail to parse a number correctly for locales that use
                        // a space as a grouping character (e.g. fr). In this case, the number is formatted using a non-breaking
                        // space character (0xA0) rather than a regular space. This is fine, but it also expects this character
                        // on input; it will fail to parse correctly with a regular space. To workaround this, we can substitute
                        // regular space characters with non-breaking spaces.
                        input = input.replace(" ", "\xA0");
                        // Check the cache for an existing parser.
                        var locale = _globalize.locale() ? _globalize.locale().locale : "en";
                        var parser = _numberParsers[locale];
                        if (!parser) {
                            parser = _globalize.numberParser();
                            _numberParsers[locale] = parser;
                        }
                        // Manually handle accounting syntax, since Globalize doesn't.
                        var multiplier = 1;
                        if (input && input[0] === "(" && input[input.length - 1] === ")") {
                            multiplier = -1;
                            input = input.slice(1, -1);
                        }
                        var result = parser(input);
                        if (isNaN(result)) {
                            // If the number can't be parsed in the current locale, try parsing the number 
                            // in the invariant locale instead.
                            result = parseFloat(input);
                        }
                        if (isNaN(result)) {
                            // Can't be parsed.
                            return result;
                        }
                        result *= multiplier;
                        // Validate against supplied format(s) if present. It must match at least one.
                        var formats = [].concat(format || []);
                        var standardFormatPattern = /^([acfnp])(?:\$([a-zA-Z]{3}))?$/i;
                        var isValid = !formats.length || formats.some(function (format) {
                            var formatter = _createNumberFormatter(format, { minimumFractionDigits: 0, maximumFractionDigits: 20 });
                            if (input === formatter(result)) {
                                return true;
                            }
                            if (format.match(standardFormatPattern)) {
                                // Try with a variety of fixed fractional digits. In some cases the above test is too strict
                                // and will e.g. reject "$10" when the expected format is "c$USD", since it doesn't match the  
                                // exact formatted value of "$10.00". This only applies to standard formats with an unspecified
                                // number of fractional digits. If the format specifies an exact number of fractional digits
                                // (e.g. "n2"), then it will only accept input having exactly that number, as it should.
                                for (var i = 0; i <= 20; i++) {
                                    var formatter = _createNumberFormatter(format, { minimumFractionDigits: i, maximumFractionDigits: i });
                                    if (input === formatter(result)) {
                                        return true;
                                    }
                                }
                            }
                            return false;
                        });
                        return isValid ? result : NaN;
                    }
                    FormatUtils.parseNumber = parseNumber;
                    /**
                     * For performance reasons, Globalize number formatters are cached and reused.
                     * Each entry maps a key (locale+format) to a triplet of formatter functions that handles
                     * positive values, negative values, and 0.
                     */
                    var _numberFormatters = {};
                    /**
                     * For performance reasons, Globalize number parsers are cached and reused.
                     * Each entry maps a locale to a parser for that locale.
                     */
                    var _numberParsers = {};
                    function _parseDate(input, utc, format) {
                        if (input instanceof Date) {
                            return input;
                        }
                        else if (typeof input === "number") {
                            // Treat numeric input as a UNIX timestamp.
                            return new Date(input);
                        }
                        else if (!input || typeof input !== "string") {
                            // Invalid Date.
                            return invalidDate;
                        }
                        // If the string is numeric, and there is no format specified, then treat it as a UNIX timestamp.
                        if (format === undefined) {
                            var numericInput = parseFloat(input);
                            if (!isNaN(numericInput) && isFinite(input)) {
                                return new Date(numericInput);
                            }
                        }
                        if (!moment) {
                            throw new Error("Error: The \"moment.js\" library is required for parsing dates.");
                        }
                        format = format || infrastructure.DateFormat.DEFAULT_PARSING_FORMATS;
                        var formats = [].concat(format);
                        formats = formats.map(function (f) {
                            var momentFormat = _dateFormatToMomentFormat(f);
                            return momentFormat === undefined ? moment.ISO_8601 : momentFormat;
                        });
                        var result;
                        if (utc) {
                            result = moment.utc(input, formats);
                        }
                        else {
                            result = moment(input, formats);
                        }
                        return result.isValid() ? result.toDate() : invalidDate;
                    }
                    /**
                     * Maps date format strings accepted by formatDate() to Moment.js format strings.
                     */
                    var _momentFormatLookup = {};
                    /**
                     * Converts a format string accepted by formatDate() and parseDate() to a format string compatible with Moment.js.
                     */
                    function _dateFormatToMomentFormat(format, utcOffset) {
                        format = format || infrastructure.DateFormat.DEFAULT;
                        var lookupKey = format + (utcOffset ? utcOffset : "");
                        switch (format) {
                            case infrastructure.DateFormat.DATE_SHORT:
                                return "L";
                            case infrastructure.DateFormat.DATE_LONG:
                                return "LL";
                            case infrastructure.DateFormat.TIME_SHORT:
                                return "LT";
                            case infrastructure.DateFormat.TIME_LONG:
                                return "LTS";
                            case infrastructure.DateFormat.DATE_TIME_SHORT:
                                return "lll";
                            case infrastructure.DateFormat.DATE_TIME_LONG:
                                return "LLL";
                            case infrastructure.DateFormat.FULL:
                                return "LLLL";
                            case infrastructure.DateFormat.ISO_8601:
                                return undefined;
                            default:
                                // Custom format string. Convert from .NET syntax to Moment.js. 
                                // See https://msdn.microsoft.com/en-us/library/8kb3ddd4.aspx
                                // and http://momentjs.com/docs/#/displaying/.
                                // First, check the cache.
                                var momentFormat = _momentFormatLookup[lookupKey];
                                if (momentFormat) {
                                    return momentFormat;
                                }
                                // Tokenize the input. Each token is one of the following:
                                // - A single formatter letter, possibly repeated, e.g. "d", "MMM". Can have a leading "%".
                                // - A single literal character, escaped with a backslash, e.g. "\\d", "\\%", etc.
                                // - A string of literal characters in quotes (single or double), e.g. "'GMT'", "\"Time\"", etc.
                                // - One or more consecutive characters that do not match the above criteria.
                                var dotNetDatePattern = /%?([dfFghHKmMstyz])\1*|\\.|(["'])[^\2]+\2|[^dfFghHKmMstyz\\'"]+/g;
                                var tokens = format.match(dotNetDatePattern);
                                momentFormat = "";
                                for (var i = 0; i < tokens.length; i++) {
                                    var token = tokens[i];
                                    if (token.startsWith("%")) {
                                        // A specifier like "%d" is the same as "d", except that it serves to disambiguate between
                                        // a custom format and a predefined format (otherwise "d" for example would be interpreted 
                                        // as DATE_SHORT).
                                        token = token.slice(1);
                                    }
                                    switch (token[0]) {
                                        case "y":
                                            if (token.length <= 2) {
                                                momentFormat += "YY";
                                            }
                                            else if (token.length <= 4) {
                                                momentFormat += "YYYY";
                                            }
                                            else {
                                                momentFormat += "YYYYY";
                                            }
                                            break;
                                        case "d":
                                            if (token.length <= 2) {
                                                momentFormat += token.slice(0, 2).toUpperCase();
                                            }
                                            else {
                                                momentFormat += token.slice(0, 4);
                                            }
                                            break;
                                        case "f":
                                        case "F":
                                            // Moment.js has a bug where longer fractional second formatters like "SSSSSSS" repeat the first 3 digits,
                                            // instead of right-padding with 0's. For this reason, we only support up to 3-digit fractional
                                            // seconds (JS dates don't have resolution beyond milliseconds anyway).
                                            momentFormat += token.slice(0, 3).replace(/[Ff]/g, "S");
                                            break;
                                        case "t":
                                            momentFormat += "A";
                                            break;
                                        case "z":
                                            momentFormat += utcOffset ? "[" + utcOffset + "]" : "Z";
                                            break;
                                        case "M":
                                            momentFormat += token.slice(0, 4);
                                            break;
                                        case "h":
                                        case "H":
                                        case "m":
                                        case "s":
                                            momentFormat += token.slice(0, 2);
                                            break;
                                        case "g":
                                        case "K":
                                            // Not supported. Ignore.
                                            console.warn("The \"{0}\" date format specifier is not supported.".format(token));
                                            break;
                                        default:
                                            // Treat as a literal.
                                            if (token.startsWith("\"") || token.startsWith("'")) {
                                                // Remove surrounding quotes.
                                                token = token.slice(1, -1);
                                            }
                                            else if (token.startsWith("\\")) {
                                                // Remove backslash escape.
                                                token = token.slice(1);
                                            }
                                            // Needs to be escaped in square brackets, otherwise Moment might interpret some of the characters.
                                            momentFormat += "[" + token + "]";
                                    }
                                }
                                _momentFormatLookup[lookupKey] = momentFormat;
                                return momentFormat;
                        }
                    }
                    /**
                     * Converts a format string accepted by formatNumber() to formatter function.
                     */
                    function _createNumberFormatter(format, defaultOptions) {
                        var options = defaultOptions || {};
                        // See if the format is a standard formatter. For example: "n", "p2", "c$USD", "a4$CAD".
                        var standardFormatPattern = /^([acfnp])(\d*)(?:\$([a-zA-Z]{3}))?$/i;
                        var tokens = format.match(standardFormatPattern);
                        if (tokens) {
                            var specifier = tokens[1].toLowerCase();
                            var fractionalDigits = Math.min(20, parseInt(tokens[2]));
                            var currency = tokens[3];
                            if (specifier === infrastructure.NumberFormat.CURRENCY || specifier === infrastructure.NumberFormat.ACCOUNTING) {
                                if (!currency) {
                                    var app = geocortex.framework.applications[0];
                                    if (app && app.configuration && app.configuration.defaultCurrency) {
                                        currency = app.configuration.defaultCurrency;
                                    }
                                    else {
                                        currency = "USD";
                                    }
                                }
                            }
                            else {
                                currency = "";
                                if (options.minimumFractionDigits === undefined) {
                                    options.minimumFractionDigits = 0;
                                }
                                if (options.maximumFractionDigits === undefined) {
                                    options.maximumFractionDigits = Math.max(4, options.minimumFractionDigits);
                                }
                            }
                            if (specifier === infrastructure.NumberFormat.PERCENT) {
                                options.style = "percent";
                            }
                            else if (specifier === infrastructure.NumberFormat.ACCOUNTING) {
                                options.style = "accounting";
                            }
                            else if (specifier === infrastructure.NumberFormat.FIXED_POINT) {
                                options.useGrouping = false;
                            }
                            if (!isNaN(fractionalDigits)) {
                                options.minimumFractionDigits = fractionalDigits;
                                options.maximumFractionDigits = fractionalDigits;
                            }
                            if (currency) {
                                return _globalize.currencyFormatter(currency, options);
                            }
                            else {
                                return _globalize.numberFormatter(options);
                            }
                        }
                        // Treat the format as a custom format. See https://msdn.microsoft.com/en-us/library/0c899ak8.aspx
                        // for more details.
                        var customFormatPattern = /[0#]+|\.|,|%|\\.|(["'])[^\1]+\1|[^0#.,\\'"]+/g;
                        var tokens = format.match(customFormatPattern);
                        var decimalPointSeen = false;
                        var integerPattern = "";
                        var fractionPattern = "";
                        var prefix = "";
                        var suffix = "";
                        options.minimumFractionDigits = 0;
                        options.maximumFractionDigits = 0,
                            options.useGrouping = false;
                        for (var i = 0; i < tokens.length; i++) {
                            var token = tokens[i];
                            switch (token[0]) {
                                case ".":
                                    decimalPointSeen = true;
                                    break;
                                case ",":
                                    options.useGrouping = true;
                                    break;
                                case "%":
                                    options.style = "percent";
                                    break;
                                case "0":
                                case "#":
                                    // The token is a series of "0" and "#" characters.
                                    if (decimalPointSeen) {
                                        fractionPattern += token;
                                    }
                                    else {
                                        integerPattern += token;
                                    }
                                    break;
                                default:
                                    // Treat as a literal.
                                    if (token.startsWith("\"") || token.startsWith("'")) {
                                        // Remove surrounding quotes.
                                        token = token.slice(1, -1);
                                    }
                                    else if (token.startsWith("\\")) {
                                        // Remove backslash escape.
                                        token = token.slice(1);
                                    }
                                    if (integerPattern || fractionPattern) {
                                        suffix += token;
                                    }
                                    else {
                                        prefix += token;
                                    }
                            }
                        }
                        if (integerPattern) {
                            var leftmostZero = integerPattern.indexOf("0");
                            if (leftmostZero >= 0) {
                                options.minimumIntegerDigits = integerPattern.length - leftmostZero;
                            }
                        }
                        if (fractionPattern) {
                            var rightmostZero = fractionPattern.lastIndexOf("0");
                            if (rightmostZero >= 0) {
                                options.minimumFractionDigits = rightmostZero + 1;
                            }
                            else {
                                options.minimumFractionDigits = 0;
                            }
                            options.maximumFractionDigits = Math.min(20, fractionPattern.length);
                        }
                        if (!integerPattern && !fractionPattern) {
                            // Edge case: the pattern is just a constant string.
                            return function (n) { return prefix + suffix; };
                        }
                        else {
                            var formatter = _globalize.numberFormatter(options);
                            return function (n) {
                                if (options.minimumIntegerDigits !== undefined && n < 0) {
                                    // Globalize doesn't handle this case properly, so work around it.
                                    return prefix + "-" + formatter(n * -1) + suffix;
                                }
                                else {
                                    return prefix + formatter(n) + suffix;
                                }
                            };
                        }
                    }
                })(FormatUtils = infrastructure.FormatUtils || (infrastructure.FormatUtils = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../_Definitions/framework.d.ts"/>
/// <reference path="./FormatUtils.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var PresentableDelegateFactory = (function () {
                    function PresentableDelegateFactory() {
                    }
                    PresentableDelegateFactory.typeIdForLayerAndAttributes = function (layer, attributes) {
                        if (layer.typeIdField) {
                            return attributes[layer.typeIdField];
                        }
                        return null;
                    };
                    PresentableDelegateFactory.typeFromLayerAndId = function (layer, id) {
                        for (var i = 0; i < layer.types.length; i++) {
                            if (layer.types[i].id == id) {
                                return layer.types[i];
                            }
                        }
                        return null;
                    };
                    // GVH-2627: Features with required fields add in GVS and viewed in GVH do not display the fields properly
                    PresentableDelegateFactory.makeValueTruthy = function (value) {
                        if (value === 0) {
                            return "0";
                        }
                        if (value === false) {
                            return "false";
                        }
                        return value;
                    };
                    PresentableDelegateFactory.valuePresenterDelegate = function (field, feature) {
                        var gcxField;
                        var fieldName;
                        if (typeof field === "string") {
                            fieldName = field;
                            if (feature && feature.layer) {
                                gcxField = feature.layer.fields.filter(function (f) { return f.name === fieldName; })[0];
                            }
                        }
                        else if (field instanceof geocortex.essentials.Field) {
                            gcxField = field;
                            fieldName = gcxField.name;
                        }
                        else if (field && field.name) {
                            fieldName = field.name;
                        }
                        // We return a template that can have the value attached to it. This is consumed by the LazyObservable on the first time that we request it's value
                        return function (value) {
                            return function () {
                                var featureLayer = feature ? feature.featureLayer : null;
                                var featureType = feature ? feature.getType() : null;
                                var esriField = featureLayer ? featureLayer.getField(fieldName) : null;
                                var fieldInfo;
                                if (field instanceof infrastructure.gis.FieldInfo) {
                                    fieldInfo = field;
                                }
                                if (!esriField && !gcxField && !fieldInfo) {
                                    if (value instanceof Date) {
                                        var dateFormat = feature ? feature.defaultDateFormat : infrastructure.DateFormat.DEFAULT;
                                        return infrastructure.FormatUtils.formatDate(value, dateFormat);
                                    }
                                    else if (typeof value === "number") {
                                        var numberFormat = feature ? feature.defaultNumberFormat : infrastructure.NumberFormat.DEFAULT;
                                        return infrastructure.FormatUtils.formatNumber(value, numberFormat);
                                    }
                                    else {
                                        return PresentableDelegateFactory.makeValueTruthy(value);
                                    }
                                }
                                else if (gcxField && gcxField.hyperlinkLabel && geocortex.framework.utils.isUrl(value)) {
                                    value = gcxField.hyperlinkLabel;
                                }
                                // GVH-3473 Resolve coded domain using SEP provided attributes - if available
                                if (feature) {
                                    var esriFeature = feature.esriFeature.get();
                                    if (esriFeature && esriFeature.attributes.hasOwnProperty(fieldName + ".Name()")) {
                                        return PresentableDelegateFactory.makeValueTruthy(esriFeature.attributes[fieldName + ".Name()"]);
                                    }
                                }
                                if (!fieldInfo) {
                                    fieldInfo = esriField ? infrastructure.gis.FieldInfo.fromEsriField(esriField, featureLayer, gcxField) : infrastructure.gis.FieldInfo.fromGcxField(gcxField);
                                }
                                if (fieldInfo.isDate() && !fieldInfo.format && feature && feature.defaultDateFormat) {
                                    fieldInfo.format = "{0:" + feature.defaultDateFormat + "}";
                                }
                                else if (fieldInfo.isNumeric() && !fieldInfo.format && feature && feature.defaultNumberFormat) {
                                    fieldInfo.format = "{0:" + feature.defaultNumberFormat + "}";
                                }
                                return fieldInfo.formatValue(value, featureType ? featureType.id.toString() : null);
                            };
                        };
                    };
                    return PresentableDelegateFactory;
                }());
                infrastructure.PresentableDelegateFactory = PresentableDelegateFactory;
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../_Definitions/framework.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var AttachmentInfo = (function () {
                    /**
                     * Initializes a new instance of the {@link AttachmentInfo} class.
                     */
                    function AttachmentInfo() {
                        /**
                         * The id of the attachment.
                         * @type Number
                         */
                        this.id = new Observable();
                        /**
                         * The content type of the attachment file.
                         * @type String
                         */
                        this.contentType = new Observable();
                        /**
                         * The size of the attachment.
                         * @type Number
                         */
                        this.size = new Observable();
                        /**
                         * The name of the attachment.
                         * @type String
                         */
                        this.name = new Observable();
                        /**
                         * The url to retrieve the attachment.
                         * @type String
                         */
                        this.url = new Observable();
                    }
                    return AttachmentInfo;
                }());
                infrastructure.AttachmentInfo = AttachmentInfo;
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var commandArgs;
                (function (commandArgs) {
                    var ProjectArgs = (function () {
                        /**
                          * Initializes a new instance of the {@link ProjectArgs} class.
                          * @param geometries The geometries.
                          * @param outputSpatialReference The Spatial Reference for the output.
                          * @param callback The success handler.
                          * @param errback The error handler.
                          * @param transformation The optional transformation.
                          */
                        function ProjectArgs(geometries, callback, errback, outputSpatialReference, transformation) {
                            this.geometries = geometries;
                            this.outputSpatialReference = outputSpatialReference;
                            this.callback = callback;
                            this.errback = errback;
                            this.transformation = transformation;
                        }
                        return ProjectArgs;
                    }());
                    commandArgs.ProjectArgs = ProjectArgs;
                })(commandArgs = infrastructure.commandArgs || (infrastructure.commandArgs = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../_Definitions/essentials.d.ts"/>
/// <reference path="../../_Definitions/framework.d.ts"/>
/// <reference path="../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="./commandArgs/ProjectArgs.ts"/>
/// <reference path="../Viewer.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var MapUtils;
                (function (MapUtils) {
                    var ArrayUtils = geocortex.framework.utils.ArrayUtils;
                    /**
                     * Scales the ESRI map's extent by the given factor
                     * @param map The ESRI map
                     * @param factor The factor by which the map's extent need to be scaled
                     * @param zoomFromExtent Value of initial extent of the map
                     * @return Value of the new scaled extent
                     */
                    function stepZoom(map, factor, zoomFromExtent) {
                        if (zoomFromExtent == null) {
                            zoomFromExtent = map.extent;
                        }
                        var extent = geocortex.essentials.GeometryUtilities.scaleEnvelopeWithoutTranslation(zoomFromExtent, 1.0 / factor);
                        map.setExtent(extent, !!map["_fitTiledMapsToExtent"]); // GVH-3834
                        return extent;
                    }
                    MapUtils.stepZoom = stepZoom;
                    /**
                     * Safely scales the ESRI map's extent by the given factor with the given priority and name
                     * @param map The Essentials map
                     * @param factor The factor by which the map's extent need to be scaled
                     * @param zoomFromExtent Value of initial extent of the map
                     * @param startupPriority The priority of this extent change if called while the map is still loading
                     * @param generalPriority The priority of this extent change if called after the map has loaded
                     * @return Value of the new scaled extent
                     */
                    function stepZoomWithPriority(site, factor, zoomFromExtent, startupPriority) {
                        if (zoomFromExtent == null) {
                            zoomFromExtent = site.getMap().extent;
                        }
                        var map = site.essentialsMap.getMap();
                        var targetExtent = geocortex.essentials.GeometryUtilities.scaleEnvelopeWithoutTranslation(zoomFromExtent, 1.0 / factor);
                        var currLvl = map.getLevel();
                        if (currLvl !== undefined && currLvl !== null && currLvl > -1) {
                            var targetLvl = currLvl;
                            if (factor > 1) {
                                targetLvl = currLvl + 1;
                            }
                            else if (factor < 1) {
                                targetLvl = currLvl - 1;
                            }
                            map.setLevel(targetLvl);
                            // We use the map.setLevel method to zoom in/out in order to resolve GVH-9925. However, there's no way we can return the actual extent after the level has been altered without changing
                            // the signature of this method to return a deferred/promise. Hence we're returning a scaled extent which should be close enough to the final extent.
                            return targetExtent;
                        }
                        // Fall back on the old way of doing things if the map does not have predefined zoom levels/lod's defined.
                        site.essentialsMap.extentManager.setExtentWithPriority(targetExtent, startupPriority);
                        return targetExtent;
                    }
                    MapUtils.stepZoomWithPriority = stepZoomWithPriority;
                    /**
                     * Gets the current extent of the given geometry
                     * @param geometry The ESRI geometry whose extent is to be returned
                     * @return Extent of the given geometry
                     */
                    function getExtent(geometry) {
                        if (!geometry) {
                            return null;
                        }
                        else if (geometry.type == "point") {
                            var point = geometry;
                            return new esri.geometry.Extent(point.x, point.y, point.x, point.y, geometry.spatialReference);
                        }
                        else {
                            return geometry.getExtent();
                        }
                    }
                    MapUtils.getExtent = getExtent;
                    /**
                     * Pans to the given geometry after apply a projection if required.
                     * @param app The application which contains the map to pan
                     * @param geometry The ESRI geometry which the map should be panned to
                     * @param startupPriority The priority of this extent change if called while the map is still loading
                     * @param generalPriority The priority of this extent change if called after the map has loaded
                     */
                    function panToPointWithPriority(app, geometry, startupPriority, showMap) {
                        var doWork = function (projectedGeometries) {
                            var geometry = null;
                            var extent = null;
                            if (projectedGeometries && projectedGeometries.length > 0) {
                                geometry = projectedGeometries[0];
                            }
                            if (app.map && geometry) {
                                if (showMap || showMap === undefined) {
                                    app.command("ShowMap").execute();
                                }
                                if (geometry.type == "point") {
                                    app.site.essentialsMap.extentManager.centerAtWithPriority(geometry, startupPriority);
                                }
                                else if (geometry.type == "extent") {
                                    app.site.essentialsMap.extentManager.centerAtWithPriority(geometry.getCenter(), startupPriority);
                                }
                                else if (geometry.type == "polyline" || geometry.type == "polygon" || geometry.type == "multipoint") {
                                    extent = geometry.getExtent();
                                    if (extent) {
                                        app.site.essentialsMap.extentManager.centerAtWithPriority(extent.getCenter(), startupPriority);
                                    }
                                }
                            }
                        };
                        function errorBack(error) {
                            app.trace.warning("PanToPoint: " + error.message);
                        }
                        ;
                        // If no geometry provided, or not an geometry, nothing to do
                        if (!geometry || !geometry.isInstanceOf(esri.geometry.Geometry)) {
                            return;
                        }
                        // Perform a projection (if needed) on the geometry
                        var projectArgs = new geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.ProjectArgs([geometry], doWork, errorBack);
                        app.command("Project").execute(projectArgs);
                    }
                    MapUtils.panToPointWithPriority = panToPointWithPriority;
                    /**
                     * Zooms to the given extent after applying a projection if required.
                     * @param app The application which contains the map
                     * @param extent The ESRI extent which the map should zoom to
                     * @param showMap A boolean indicating if the map should be shown before performing the extent change
                     */
                    function zoomToExtent(app, extent, showMap) {
                        this.zoomToExtentWithPriority(app, extent, null, null, showMap);
                    }
                    MapUtils.zoomToExtent = zoomToExtent;
                    /**
                     * Zooms to the given extent with the specified priority after applying a projection if required.
                     * @param app The application which contains the map to pan
                     * @param extent The ESRI extent which the map should zoom to
                     * @param startupPriority The priority of this extent change if called while the map is still loading
                     */
                    function zoomToExtentWithPriority(app, extent, startupPriority, showMap) {
                        var doWork = function (projectedGeometries) {
                            if (projectedGeometries && projectedGeometries.length > 0) {
                                if (showMap || showMap === undefined) {
                                    app.command("ShowMap").execute();
                                }
                                // If neither the startup or the general priorities are specified, use the standard map extent change call instead of routing it through the extent manager. 
                                if (startupPriority == null) {
                                    app.map.setExtent(projectedGeometries[0], !!app.map["_fitTiledMapsToExtent"]); //GVH-3834: The 'fit' parameter gurarantees that input extent for tiled layers are shown completely on the map
                                }
                                else {
                                    //<sabubaker> The extent manager appears to choke if the map is resized rapidly a few times. The _mapResize boolean gets stuck at true, preventing the "map-resize" event
                                    //for any further extent changes from firing. This is pretty rare and intermittent condition and needs to be investigated further.
                                    app.site.essentialsMap.extentManager.setExtentWithPriority(projectedGeometries[0], startupPriority);
                                }
                                // If the view is going to recenter the map because we're still laying out it should be on this extent
                                app.event("MapStartupExtentChangedEvent").publish(projectedGeometries[0]);
                            }
                        };
                        // If no extent provided, or not an extent, nothing to do
                        if (!extent || !extent.isInstanceOf(esri.geometry.Extent)) {
                            return;
                        }
                        // If the extent doesn't have a spatial reference, we'll assume it's using the map's spatial reference 
                        if (!extent.spatialReference && app.map.spatialReference) {
                            extent.spatialReference = app.map.spatialReference;
                            // No need to project the extent
                            doWork([extent]);
                            return;
                        }
                        if (extent.spatialReference && !extent.spatialReference.toJson) {
                            if (extent.spatialReference.wkid || extent.spatialReference.wkt) {
                                extent.spatialReference = new esri.SpatialReference(extent.spatialReference);
                            }
                        }
                        var errorBack = function (error) {
                            app.trace.warning("ZoomToExtent: " + error.message);
                        };
                        // Perform a projection (if needed) on the extent
                        var projectArgs = new geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.ProjectArgs([extent], doWork, errorBack);
                        app.command("Project").execute(projectArgs);
                    }
                    MapUtils.zoomToExtentWithPriority = zoomToExtentWithPriority;
                    /**
                     * This function will only be effective when the map has a tiled base map layer. In such cases, simply determining the scale at which a
                     * layer is visible may not be sufficient as this scale may fall between two LOD scale ranges. In such cases, esri will choose the LOD with the nearest scale
                     * to zoom to - but the layer may NOT be visible at that scale. This function fetches the scale of the nearest LOD (either less than or more than the specified scale)
                     * at which the layer will be visible.
                     * @param mode An enum which can be either "lessThan" or "greaterThan"
                     * @param scale The target scale
                    *  @return The nearest LOD with scale less than or more than (depending on mode) the target scale OR the input scale if a tiled base map is not added to the map
                    */
                    function getClosestScale(map, mode, scale) {
                        // See GVH-5108, GVH-4562 for more info around this method.
                        var lods = map["__tileInfo"] && map["__tileInfo"].lods;
                        if (!lods || !lods.length) {
                            return scale;
                        }
                        var prevLodScale = 0;
                        for (var x = 0; x < lods.length; x++) {
                            if (lods[x].scale === scale) {
                                return scale;
                            }
                            if (mode === ScaleChangeMode.LessThan) {
                                if (scale < lods[x].scale) {
                                    continue;
                                }
                            }
                            else {
                                if (lods[x].scale > scale) {
                                    prevLodScale = lods[x].scale;
                                    continue;
                                }
                            }
                            return (mode === ScaleChangeMode.LessThan) ? lods[x].scale : prevLodScale;
                        }
                    }
                    MapUtils.getClosestScale = getClosestScale;
                    (function (ScaleChangeMode) {
                        ScaleChangeMode[ScaleChangeMode["LessThan"] = 0] = "LessThan";
                        ScaleChangeMode[ScaleChangeMode["GreaterThan"] = 1] = "GreaterThan";
                    })(MapUtils.ScaleChangeMode || (MapUtils.ScaleChangeMode = {}));
                    var ScaleChangeMode = MapUtils.ScaleChangeMode;
                    /* Clones an esri feature and returns a new identical instance.
                     * @param feature: The esri.Graphic to clone
                     * @return: the cloned esri.Graphic.
                     */
                    function cloneEsriFeature(feature) {
                        var clone = new esri.Graphic(feature.toJson());
                        // Doing this is somewhat hacky, but it avoids some unnecessary searching for the feature across all feature layers.
                        clone._graphicsLayer = feature._graphicsLayer;
                        return clone;
                    }
                    MapUtils.cloneEsriFeature = cloneEsriFeature;
                    function esriFeatureAttributesEqual(attributes1, attributes2, fieldsToIgnore) {
                        // Same collection
                        if (attributes1 === attributes2) {
                            return true;
                        }
                        // No attributes on left (or right)
                        if (attributes1 == null || attributes2 == null) {
                            return false;
                        }
                        var keys1 = Object.keys(attributes1);
                        var keys2 = Object.keys(attributes2);
                        // Remove fields that should be ignored from further checks
                        keys1 = ArrayUtils.difference(keys1, fieldsToIgnore);
                        keys2 = ArrayUtils.difference(keys2, fieldsToIgnore);
                        // Our comparison will be based on the following:
                        // - Same number of attributes
                        // - Same attribute names
                        if (keys1.length !== keys2.length) {
                            return false;
                        }
                        // OK, same number of attributes and names. Now check corresponding attribute values
                        for (var _i = 0, keys1_1 = keys1; _i < keys1_1.length; _i++) {
                            var key = keys1_1[_i];
                            if (attributes1[key] !== attributes2[key]) {
                                return false;
                            }
                        }
                        return true;
                    }
                    MapUtils.esriFeatureAttributesEqual = esriFeatureAttributesEqual;
                    /* Structurally compares two esri features and returns true if they're equal
                     * Note: This comparison does not take geometry into account
                     * @param graphic1: The first esri.Graphic to compare
                     * @param graphic2: The second esri.Graphic to compare against
                     * @return: Returns true if attributes for feature1 equal attributes for feature2; false otherwise
                     */
                    function esriFeaturesEqual(graphic1, graphic2) {
                        if (graphic1 === graphic2) {
                            return true;
                        }
                        // No feature on left (or right)
                        if (graphic1 == null || graphic2 == null) {
                            return false;
                        }
                        // `clusterId`, `clusterCount` and `extent` are custom attributes added to clustered features - ignore them.
                        var fieldsToIgnore = [
                            "timestamp",
                            "clusterId",
                            "clusterCount",
                            "extent"
                        ];
                        // Find out if the graphics belong to a feature layer
                        var featureLayer = graphic1.getLayer();
                        if (!featureLayer || !(featureLayer instanceof esri.layers.FeatureLayer)) {
                            featureLayer = graphic2.getLayer();
                        }
                        // Check the object Ids. If they match, return true and avoid costly attribute comparison.
                        if (featureLayer instanceof esri.layers.FeatureLayer) {
                            var objectId = featureLayer.objectIdField;
                            if (objectId && graphic1.attributes && graphic2.attributes && graphic1.attributes[objectId] === graphic2.attributes[objectId]) {
                                return true;
                            }
                            // Ignore attributes auto-populated by the feature service; e.g. created date, edited date, etc.
                            if (featureLayer.editFieldsInfo) {
                                var keys = Object.keys(featureLayer.editFieldsInfo);
                                for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                                    var info = keys_1[_i];
                                    fieldsToIgnore.push(featureLayer.editFieldsInfo[info]);
                                }
                            }
                        }
                        return esriFeatureAttributesEqual(graphic1.attributes, graphic2.attributes, fieldsToIgnore);
                    }
                    MapUtils.esriFeaturesEqual = esriFeaturesEqual;
                    function esriGeometriesEqual(g1, g2) {
                        var geomType = g1 ? g1.type : null;
                        switch (geomType) {
                            case "point":
                                return esriPointsEqual(g1, g2);
                            case "multipoint":
                                return esriMultipointsEqual(g1, g2);
                            case "polyline":
                                return esriPolylinesEqual(g1, g2);
                            case "polygon":
                                return esriPolygonsEqual(g1, g2);
                            case "extent":
                                return esriExtentsEqual(g1, g2);
                        }
                        return false;
                    }
                    MapUtils.esriGeometriesEqual = esriGeometriesEqual;
                    // Compares type & spatial references of two geometries
                    function compareTypeSR(g1, g2) {
                        return (g1 === g2) ||
                            ((g1.type === g2.type)
                                && (g1.spatialReference && g2.spatialReference && g1.spatialReference.equals(g2.spatialReference)));
                    }
                    MapUtils.compareTypeSR = compareTypeSR;
                    function esriPointsEqual(thisGeom, oGeom) {
                        return (thisGeom === oGeom) || (((thisGeom.x == oGeom.x) && (thisGeom.y == oGeom.y)) && compareTypeSR(thisGeom, oGeom));
                    }
                    MapUtils.esriPointsEqual = esriPointsEqual;
                    function esriMultipointsEqual(thisGeom, oGeom) {
                        var retVal = compareTypeSR(thisGeom, oGeom);
                        if (retVal && (thisGeom.points.length === oGeom.points.length)) {
                            for (var x = 0; retVal && (x < thisGeom.points.length); x++) {
                                retVal = (thisGeom.points[x][0] === oGeom.points[x][0]) && (thisGeom.points[x][1] === oGeom.points[x][1]);
                            }
                            return retVal;
                        }
                        return false;
                    }
                    MapUtils.esriMultipointsEqual = esriMultipointsEqual;
                    function esriPolylinesEqual(thisGeom, oGeom) {
                        var retVal = compareTypeSR(thisGeom, oGeom);
                        if (retVal) {
                            dojo.forEach(thisGeom.paths, function (thisGeomPath, i) {
                                if (thisGeomPath.length === oGeom.paths[i].length) {
                                    for (var x = 0; retVal && (x < thisGeomPath.length); x++) {
                                        retVal = (thisGeomPath[x][0] === oGeom.paths[i][x][0]) && (thisGeomPath[x][1] === oGeom.paths[i][x][1]);
                                    }
                                    if (!retVal) {
                                        return retVal;
                                    }
                                }
                                else {
                                    retVal = false;
                                    return;
                                }
                            });
                        }
                        return retVal;
                    }
                    MapUtils.esriPolylinesEqual = esriPolylinesEqual;
                    function esriPolygonsEqual(thisGeom, oGeom) {
                        var retVal = compareTypeSR(thisGeom, oGeom);
                        if (retVal) {
                            dojo.forEach(thisGeom.rings, function (thisRing, i) {
                                if (thisRing.length === oGeom.rings[i].length) {
                                    for (var x = 0; retVal && (x < thisRing.length); x++) {
                                        retVal = (thisRing[x][0] === oGeom.rings[i][x][0]) && (thisRing[x][1] === oGeom.rings[i][x][1]);
                                    }
                                    if (!retVal) {
                                        return retVal;
                                    }
                                }
                                else {
                                    retVal = false;
                                    return;
                                }
                            });
                        }
                        return retVal;
                    }
                    MapUtils.esriPolygonsEqual = esriPolygonsEqual;
                    function esriExtentsEqual(thisGeom, oGeom) {
                        var retVal = compareTypeSR(thisGeom, oGeom);
                        return retVal
                            && thisGeom.xmin == oGeom.xmin
                            && thisGeom.xmax == oGeom.xmax
                            && thisGeom.ymin == oGeom.ymin
                            && thisGeom.ymax == oGeom.ymax;
                    }
                    MapUtils.esriExtentsEqual = esriExtentsEqual;
                    /**
                     * Finds a feature on a given layer using structural comparison.
                     * @param feature The esri.Graphic to find.
                     * @param layer The feature layer to search.
                     */
                    function findFeatureInLayer(feature, layer) {
                        if (!feature || !layer) {
                            return null;
                        }
                        // NOTE: You are now entering a complete and utter hack zone. Don't judge me.
                        var attrValue = null;
                        var attrName = layer.objectIdField;
                        if (feature.attributes[attrName]) {
                            attrValue = feature.attributes[attrName];
                        }
                        var graphics = layer.graphics;
                        if (graphics.length < 1) {
                            return null;
                        }
                        // `clusterId`, `clusterCount` and `extent` are custom attributes added to clustered features - ignore them.
                        var fieldsToIgnore = [
                            "timestamp",
                            "clusterId",
                            "clusterCount",
                            "extent"
                        ];
                        if (layer.editFieldsInfo) {
                            for (var info in layer.editFieldsInfo) {
                                if (!layer.editFieldsInfo.hasOwnProperty(info)) {
                                    continue;
                                }
                                fieldsToIgnore.push(layer.editFieldsInfo[info]);
                            }
                        }
                        //
                        var shouldIgnore = function (name) {
                            return geocortex.framework.utils.ArrayUtils.contains(fieldsToIgnore, name);
                        };
                        // Before comparing all features on the layer, compare schema.
                        // Our comparison will be based on the following:
                        // - Same number of attributes
                        // - Same attribute names
                        var countAttribs = function (attribs) {
                            var count = 0;
                            for (var attribute in attribs) {
                                if (shouldIgnore(attribute) || !attribs.hasOwnProperty(attribute)) {
                                    continue;
                                }
                                ++count;
                            }
                            return count;
                        };
                        var attribs = graphics[0].attributes;
                        if (countAttribs(attribs) !== countAttribs(feature.attributes)) {
                            return null;
                        }
                        // OK, same number of attributes. Now check names.
                        var numAttrs = 0;
                        var attrsA = [];
                        var attrsB = [];
                        for (var attribute in attribs) {
                            var ignore = shouldIgnore(attribute);
                            if (!ignore && (!attribs.hasOwnProperty(attribute) || !feature.attributes.hasOwnProperty(attribute))) {
                                return null;
                            }
                            if (!ignore) {
                                attrsA.push(attribute);
                                attrsB.push(attribute);
                                ++numAttrs;
                            }
                        }
                        // Any mismatched attribute equates to the wrong layer.
                        for (var i = 0; i < numAttrs; ++i) {
                            if (attrsA[i] !== attrsB[i]) {
                                return null;
                            }
                        }
                        // Now that we've checked schemas, look for a feature instance with the same OBJECTID.
                        for (var j = 0; j < graphics.length; j++) {
                            var graphic = graphics[j];
                            if (countAttribs(attribs) !== countAttribs(feature.attributes)) {
                                continue;
                            }
                            if (graphic.attributes[attrName] === feature.attributes[attrName]) {
                                graphic._graphicsLayer = layer;
                                return graphic;
                            }
                        }
                        return null;
                    }
                    MapUtils.findFeatureInLayer = findFeatureInLayer;
                    /**
                     * Finds a feature on the map. This method is crucial for dealing with OnDemand layers, as feature instances
                     * obtained from OnDemand layers became detached from the map and we often need to re-attach to the "fresh"
                     * instance of a feature.
                     * @param feature The esri.Graphic to find.
                     * @param site The Site, containing the map.
                     * @param layerHint A layer possibly containing the feature, to search first.
                     */
                    function findFeatureInMap(feature, site, layerHint) {
                        var onMapFeature = null;
                        // To speed up looking for the feature, we first look in _lastLayer
                        if (layerHint) {
                            onMapFeature = this.findFeatureInLayer(feature, layerHint);
                            if (onMapFeature) {
                                onMapFeature._graphicsLayer = layerHint;
                                return onMapFeature;
                            }
                        }
                        var mapServices = site.getFeatureServices();
                        for (var i = 0; i < mapServices.length; i++) {
                            var service = mapServices[i];
                            var layer = service.serviceLayer;
                            // We have already searched our layer hint.
                            if (layerHint && layer === layerHint) {
                                continue;
                            }
                            onMapFeature = this.findFeatureInLayer(feature, layer);
                            if (onMapFeature) {
                                return onMapFeature;
                            }
                        }
                        //If we're at this point and were not able to find the feature in the map (possibly because it belongs to an on-demand layer which is at the incorrect extent)
                        //we'll check if the original feature (though it may be a stale instance) has the reference to the layer. If so, we'll just return the original - though a stale
                        //instance, we should still be able to apply edits to it - we'll just have to refresh the layer after that to update the current instance in the fsc
                        if (!onMapFeature && feature.getLayer && feature.getLayer()) {
                            onMapFeature = feature;
                        }
                        return onMapFeature;
                    }
                    MapUtils.findFeatureInMap = findFeatureInMap;
                    /**
                     * Get an image URI for the thumbnail. Can be a hosted image or a data URI.
                     * @param app The application which contains the map to create a thumbnail for.
                     * @param extent The extent to create the thumbnail for. Defaults to the maps current extent.
                     * @param width The width of the thumbnail.
                     * @param height The height of the thumbnail.
                     * @param dpi The DPI to use for the thumbnail resolution.
                     * @return A promise of the thumbnail.
                     */
                    function getThumbnailUri(app, extent, width, height, dpi) {
                        if (width === void 0) { width = 150; }
                        if (height === void 0) { height = 150; }
                        if (dpi === void 0) { dpi = 20; }
                        var exportParameters = new geocortex.essentials.ReportParameters();
                        exportParameters.outputFormat = "PNG";
                        exportParameters.includeData = true;
                        exportParameters.imageWidth = width;
                        exportParameters.imageHeight = height;
                        exportParameters.resolution = {
                            displayName: "custom",
                            dpi: dpi
                        };
                        exportParameters.customExtent = extent || app.map.extent;
                        exportParameters.extentType = geocortex.essentials.ReportParameters.CUSTOM_EXTENT;
                        exportParameters.populateMapGraphicsLayers(app.map);
                        return new Promise(function (resolve, reject) {
                            app.site.essentialsMap.exportMap(exportParameters, function (result) {
                                if (result.data) {
                                    resolve("data:image/png;base64,{0}".format(result.data));
                                }
                                else if (result.href) {
                                    resolve(result.href);
                                }
                                else {
                                    resolve(null);
                                }
                            }, function (error) {
                                app.trace.error("Error exporting map for thumbnail: {0}".format(error.message));
                                resolve(null);
                            });
                        });
                    }
                    MapUtils.getThumbnailUri = getThumbnailUri;
                })(MapUtils = infrastructure.MapUtils || (infrastructure.MapUtils = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../_Definitions/framework.d.ts"/>
/// <reference path="../../_Definitions/framework.ui.d.ts"/>
/// <reference path="../../_Definitions/essentials.d.ts"/>
/// <reference path="../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="./FeatureSet.ts"/>
/// <reference path="./FeatureAttribute.ts"/>
/// <reference path="./PresentableDelegateFactory.ts"/>
/// <reference path="./AttachmentInfo.ts"/>
/// <reference path="./MapUtils.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                /**
                 * Observable view model for an ESRI Feature.
                 */
                var Feature = (function () {
                    /**
                     * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature} class.
                     * @class
                     * <p>Represents a Geocortex Essentials Feature.</p>
                     * @constructs
                     * @memberOf geocortex.essentialsHtmlViewer.mapping.infrastructure
                     * @param options The options for the new Feature. (i.e. graphic / layer / resolveLayerFields / allowUnsafeContent)
                     */
                    function Feature(options) {
                        var _this = this;
                        /**
                         * Indicate if attachment infos are initialized
                         * @private
                         */
                        this._isAttachmentInfosLoaded = false;
                        /**
                         * Default format to render the fields
                         * @private
                         */
                        this._defaultFieldFormatString = "{0}: {1}";
                        /**
                        * The token that should uniquely identify this feature for a specific application instance and run
                        * @type AlphaNumeric token that *should* uniquely identify this feature
                        */
                        this.token = null;
                        /**
                         * The esri feature layer associated with the feature.
                         */
                        this.featureLayer = null;
                        /**
                         * The FeatureSet this Feature is a part of.
                         * @type FeatureSet
                         */
                        this.featureSet = null;
                        /**
                         * The label format this Feature uses to render a label.
                         * @type String
                         */
                        this.labelFormat = new geocortex.framework.ui.LazyObservable();
                        /**
                         * The configured min scale of the Feature.
                         * @type Number
                         */
                        this.minScale = new geocortex.framework.ui.LazyObservable();
                        /**
                         * The configured max scale of the Feature.
                         * @type Number
                         */
                        this.maxScale = new geocortex.framework.ui.LazyObservable();
                        /**
                         * The zoom scale of the Feature.
                         * @type Number
                         */
                        this.zoomScale = new geocortex.framework.ui.LazyObservable();
                        /**
                         * The zoom factor of the Feature.
                         * @type Number
                         */
                        this.zoomFactor = new geocortex.framework.ui.LazyObservable();
                        /**
                         * The zoom extent of the Feature.
                         * @type Extent
                         */
                        this.zoomExtent = new Observable();
                        /**
                         * The border color of the Feature.
                         * @type String
                         */
                        this.borderColor = new geocortex.framework.ui.LazyObservable();
                        /**
                        * The border width of the Feature.
                        * @type Number
                        */
                        this.borderWidth = new geocortex.framework.ui.LazyObservable();
                        /**
                         * The fill color of the Feature.
                         * @type String
                         */
                        this.fillColor = new geocortex.framework.ui.LazyObservable();
                        /**
                         * The id of the Feature.
                         * @type Number
                         */
                        this.id = new geocortex.framework.ui.LazyObservable();
                        /**
                         * The attributes for the Feature.
                         * @type FeatureAttribute[]
                         */
                        this.attributes = new ObservableCollection();
                        /**
                         * The label for the Feature.
                         * @type String
                         */
                        this.label = new geocortex.framework.ui.LazyObservable();
                        /**
                         * The plain label for the Feature, stripped of any HTML.
                         * @type String
                         */
                        this.plainLabel = new geocortex.framework.ui.LazyObservable();
                        /**
                         * The description for the Feature.
                         * @type String
                         */
                        this.description = new geocortex.framework.ui.LazyObservable();
                        /**
                         * The description format this Feature uses to render a description.
                         * @type String
                         */
                        this.descriptionFormat = new geocortex.framework.ui.LazyObservable();
                        /**
                         * The long description for the Feature.
                         * @type String
                         */
                        this.longDescription = new geocortex.framework.ui.LazyObservable();
                        /**
                         * The long description format this Feature uses to render a long description.
                         * @type String
                         */
                        this.longDescriptionFormat = new geocortex.framework.ui.LazyObservable();
                        /**
                         * The hyperlinks associated with the feature (if any)
                         * @type FeatureHyperlink[]
                         */
                        this.hyperlinks = new ObservableCollection();
                        /**
                         * The extended properties for the Feature.
                         * @type Array
                         */
                        this.extendedProperties = new ObservableCollection();
                        /**
                         * Get the attachment infos associated with the feature.
                         * @type ObservableCollection
                         */
                        this.attachmentInfos = null;
                        /**
                         * Indicates that the attachmentInfos collection has been initialized.
                         * @type Observable
                         */
                        this.attachmentInfosInitialized = new Observable(false);
                        /**
                         * Gets a value indicating whether the feature has attachments.
                         * @type Boolean
                         */
                        this.hasAttachments = new Observable(false);
                        /**
                         * Gets a value indicating whether the feature has relationships.
                         * @type Boolean
                         */
                        this.hasRelationships = new Observable(false);
                        /**
                         * Gets a value indicating whether the feature has visible relationships.
                         * @type Boolean
                         */
                        this.hasVisibleRelationships = new Observable(false);
                        /**
                         * Gets a value indicating whether the feature has geometry attached.
                         * @type Boolean
                         */
                        this.hasGeometry = new geocortex.framework.ui.LazyObservable();
                        /**
                         * Gets a value indicating whether the feature has a valid geometry attached.
                         * @type Boolean
                         */
                        this.hasValidGeometry = new geocortex.framework.ui.LazyObservable();
                        /** Observable public members - Layer config overrides */
                        this.iconUri = new geocortex.framework.ui.LazyObservable();
                        /** linked data associated with a feature's linked attributes */
                        this.linkedAttributes = new ObservableCollection();
                        /** the features related data links */
                        this.dataLinkingResults = new ObservableCollection();
                        /** The default format to use for displaying number fields that have no explicit format. */
                        this.defaultNumberFormat = infrastructure.NumberFormat.DEFAULT;
                        /** The default format to use for displaying date fields that have no explicit format. */
                        this.defaultDateFormat = infrastructure.DateFormat.DEFAULT;
                        /** Whether the feature attribute data has been locally modified. */
                        this.isModified = false;
                        /** The IANA ID of the time zone in which this feature's field data are current.
                          * Primarily used as a fallback when the FieldInfo object cannot access the appropriate ID.
                          */
                        this.timeZoneId = null;
                        /** The IANA ID of the time zone in which this feature's field data will be displayed.
                          * Primarily used as a fallback when the FieldInfo object cannot access the appropriate ID.
                          */
                        this.displayTimeZoneId = null;
                        /**
                         * Indicates if unsafe web content is allowed for rendering or not
                         * @private
                         */
                        this._allowUnsafeContent = false;
                        /**
                         * Indicates if layer fields are to be resolved or not
                         */
                        this._resolveLayerFields = false;
                        this._attributeValueBindingTokens = {};
                        var layer = null;
                        if (options && options.hasOwnProperty("graphic")) {
                            this._graphic = options.graphic;
                        }
                        if (options && options.hasOwnProperty("featureLayer")) {
                            this.featureLayer = options.featureLayer;
                        }
                        if (options && options.hasOwnProperty("layer")) {
                            layer = options.layer;
                            if (layer && !this.featureLayer) {
                                // Try to obtain the feature layer from the Essentials layer.
                                layer.getFeatureLayer().then(function (featureLayer) {
                                    _this.featureLayer = featureLayer;
                                    if (featureLayer) {
                                        // The presentable values of attributes, as well as the label, description, and long description may 
                                        // need to change if we have an associated feature layer (e.g., coded domain values will now resolve).
                                        _this._refreshPresentableValues();
                                    }
                                });
                            }
                        }
                        if (options && options.hasOwnProperty("resolveLayerFields")) {
                            this._resolveLayerFields = options.resolveLayerFields;
                        }
                        else if (layer && layer.fields) {
                            this._resolveLayerFields = true;
                        }
                        if (options && options.hasOwnProperty("allowUnsafeContent")) {
                            this._allowUnsafeContent = options.allowUnsafeContent;
                        }
                        else {
                            this._allowUnsafeContent = false;
                        }
                        if (options && options.hasOwnProperty("timeZoneId")) {
                            this.timeZoneId = options.timeZoneId;
                        }
                        if (options && options.hasOwnProperty("displayTimeZoneId")) {
                            this.displayTimeZoneId = options.displayTimeZoneId;
                        }
                        this.token = geocortex.framework.utils.alphaNumericToken();
                        this.esriFeature = new Observable(this._graphic);
                        this.esriFeature.bind(this, function () {
                            // This is in case the _graphic object needs to be replaced due to feature update or any other reason. This assumes
                            // that the associated layer for the new _graphic object remains the same.
                            _this._graphic = _this.esriFeature.get();
                            _this.loadAttributes(_this._resolveLayerFields);
                            _this._setupLinkedAttributes();
                            // Reset attachment information. The new information will only be retrieved from the server on demand
                            _this.attachmentInfos.clear();
                            _this._isAttachmentInfosLoaded = false;
                            _this.attachmentInfosInitialized.set(false);
                            // The label and descriptions may have changed.
                            _this._refreshPresentableValues();
                        });
                        this.connectDelegates();
                        if (layer) {
                            this.layer = layer;
                            this.hasAttachments.set(this.layer.hasAttachments);
                            // Check if there are relationships
                            if (this.layer.relationships && this.layer.relationships.length > 0) {
                                this.hasRelationships.set(true);
                                // Now let's check for visible relationships
                                for (var i = 0; i < this.layer.relationships.length; i++) {
                                    if (this.layer.relationships[i].visible) {
                                        this.hasVisibleRelationships.set(true);
                                        break;
                                    }
                                }
                            }
                            // Check if there are hyperlinks
                            if (layer.featureHyperlinks != null) {
                                this.hyperlinks.addItems(layer.featureHyperlinks);
                            }
                        }
                        /* Load all observables during construction */
                        //this.loadId();
                        this.loadAttributes(this._resolveLayerFields);
                        this.isModified = false;
                        this._prepAttachmentInfos();
                        // Add the esri features attributes as the first element in the linked attributes
                        if (this._graphic) {
                            this._setupLinkedAttributes();
                        }
                    }
                    /**
                     * Finds the extended property matching the specified name.
                     * @param name The name of the property to find.
                     */
                    Feature.prototype.getExtendedPropertyByName = function (name) {
                        for (var i = 0; i < this.extendedProperties.getLength(); i++) {
                            var prop = this.extendedProperties.getAt(i);
                            if (prop && prop.name == name) {
                                return prop.value;
                            }
                        }
                        return null;
                    };
                    /**
                     * Sets the extended property matching the specified name.
                     * @param name The name of the property to update.
                     * @param value The property value.
                     */
                    Feature.prototype.setExtendedProperty = function (name, value) {
                        for (var i = 0; i < this.extendedProperties.getLength(); i++) {
                            var prop = this.extendedProperties.getAt(i);
                            if (prop && prop.name == name) {
                                prop.value = value;
                                return;
                            }
                        }
                        // Property not found - add it to the collection
                        this.extendedProperties.addItem({ name: name, value: value });
                    };
                    /**
                     * Connect the delegate functions that back the LazyObservables.  Most of
                     * these don't cache but they could easily.
                     */
                    Feature.prototype.connectDelegates = function () {
                        var _this = this;
                        this.hasGeometry.delegateGetter = function () {
                            return !!(_this._graphic && _this._graphic.geometry);
                        };
                        this.hasValidGeometry.delegateGetter = function () {
                            return !!(_this._graphic && _this._graphic.geometry) && infrastructure.GeometryUtils.isValidGeometry(_this._graphic.geometry);
                        };
                        this.id.cacheDelegateResults = true;
                        this.id.delegateGetter = function () {
                            var id = "";
                            if (_this._graphic && _this.layer) {
                                var fieldName = null;
                                if (_this.layer) {
                                    fieldName = _this.layer.getObjectIdFieldName();
                                }
                                if (fieldName && _this._graphic.attributes && _this._graphic.attributes.hasOwnProperty(fieldName)) {
                                    id = _this._graphic.attributes[fieldName];
                                }
                            }
                            return id;
                        };
                        this.label.delegateGetter = function () {
                            var label = null;
                            var format = _this.labelFormat.get();
                            label = _this.formatTemplateString(format);
                            // If we didn't get a label, try the hard way
                            if (((label == null || label == undefined) || !label.toString().trim())) {
                                label = _this._getDefaultFieldValue();
                                // Tack on the layer name if available
                                if (label != undefined && label != null && _this.layer) {
                                    label = (_this.layer.displayName && _this.layer.displayName.toString().trim()) ?
                                        _this.layer.displayName + ((label.toString().trim()) ? ", " + label : "")
                                        : ((label.toString().trim()) ? label : "");
                                }
                            }
                            // SECURITY: HTML is sanitized. GVH-9760.
                            // Frames are not allowed.
                            // Link URIs are converted into command hyperlinks.
                            // NOTE: It's up to consumers to resolve the injected command hyperlink and image tag bindings.
                            var filterOptions = {
                                allowFrames: false,
                                uriTransformer: function (uri, details) {
                                    if (details.type !== infrastructure.FilterUtils.UriType.NavigableLink) {
                                        return uri;
                                    }
                                    else {
                                        // GVH-10285: Preventing double command hyperlinking.
                                        return /^mailto\:/.test(uri) ? uri : "command:OpenWebPage?" + uri;
                                    }
                                }
                            };
                            return infrastructure.FilterUtils.sanitize(label, filterOptions);
                        };
                        this.plainLabel.delegateGetter = function () {
                            // We want to strip out any HTML tags for the plainLabel, since the plainLabel
                            // is displayed as plain text, tags and all.
                            return infrastructure.FilterUtils.stripHtml(_this.label.get());
                        };
                        this.labelFormat.delegateGetter = function () {
                            if (_this.layer && _this.layer.featureLabel) {
                                return _this.layer.featureLabel;
                            }
                            else if (_this.layer && _this.layer.displayField) {
                                return "{" + _this._sanitizeFieldName(_this.layer.displayField.name) + "}";
                            }
                            else if (_this.featureSet && _this.featureSet.esriFeatureSet && _this.featureSet.esriFeatureSet.displayFieldName && _this.featureSet.layer && _this.featureSet.layer.displayName) {
                                return _this.featureSet.layer.displayName + ", {" + _this.featureSet.esriFeatureSet.displayFieldName + "}";
                            }
                            else if (_this.featureSet && _this.featureSet.esriFeatureSet && _this.featureSet.esriFeatureSet.displayFieldName) {
                                return "{" + _this._sanitizeFieldName(_this.featureSet.esriFeatureSet.displayFieldName) + "}";
                            }
                            return "";
                        };
                        this.borderColor.delegateGetter = function () {
                            if (_this.layer && _this.layer.featureBorderColor) {
                                return _this.layer.featureBorderColor;
                            }
                            return null;
                        };
                        this.borderWidth.delegateGetter = function () {
                            if (_this.layer && typeof _this.layer.featureBorderWidth == "number" && _this.layer.featureBorderWidth >= 0) {
                                return _this.layer.featureBorderWidth;
                            }
                            return null;
                        };
                        this.fillColor.delegateGetter = function () {
                            if (_this.layer && _this.layer.featureFillColor) {
                                return _this.layer.featureFillColor;
                            }
                            return null;
                        };
                        this.description.delegateGetter = function () {
                            var format = _this.descriptionFormat.get();
                            return _this.formatTemplateString(format);
                        };
                        this.descriptionFormat.delegateGetter = function () {
                            if (_this.layer && _this.layer.featureDescription) {
                                return _this.layer.featureDescription;
                            }
                            return null;
                        };
                        this.longDescription.delegateGetter = function () {
                            var format = _this.longDescriptionFormat.get();
                            return _this.formatTemplateString(format);
                        };
                        this.longDescriptionFormat.delegateGetter = function () {
                            if (_this.layer && _this.layer.featureLongDescription) {
                                return _this.layer.featureLongDescription;
                            }
                            return _this.descriptionFormat.get();
                        };
                        this.minScale.delegateGetter = function () {
                            if (_this.layer && !isNaN(_this.layer.minScale)) {
                                return _this.layer.minScale;
                            }
                            return Infinity;
                        };
                        this.maxScale.delegateGetter = function () {
                            if (_this.layer && !isNaN(_this.layer.maxScale)) {
                                return _this.layer.maxScale;
                            }
                            return null;
                        };
                        this.iconUri.delegateGetter = function () {
                            if (_this.layer && _this.layer.iconUri) {
                                return _this.layer.iconUri;
                            }
                            else if (_this.featureSet && _this.featureSet.iconUri && _this.featureSet.iconUri.get()) {
                                return _this.featureSet.iconUri.get();
                            }
                            return null;
                        };
                        this.zoomScale.delegateGetter = function () {
                            if (_this.layer && _this.layer.featureZoomScale) {
                                return _this.layer.featureZoomScale;
                            }
                            return null;
                        };
                        this.zoomFactor.delegateGetter = function () {
                            if (_this.layer && _this.layer.featureZoomFactor) {
                                return _this.layer.featureZoomFactor;
                            }
                            return null;
                        };
                    };
                    /**
                     * Determines if the specified scale is within this layer's min and max scale.
                     * @param scale The scale value to test if it is between this layer's min and max scale.
                     * If a value is not provided for this parameter, then the map's current scale value will
                     * be used.
                     */
                    Feature.prototype.withinScaleRange = function (scale) {
                        if ((this.maxScale.get() == 0 && this.minScale.get() == Infinity)
                            || (isNaN(this.maxScale.get()) && isNaN(this.minScale.get()))) {
                            return true;
                        }
                        if (!scale) {
                            return false;
                        }
                        return this.maxScale.get() <= scale && scale <= this.minScale.get();
                    };
                    /**
                     * Calculates a scale at which the layer would be visible if it's not already.
                     * @param scale The scale
                     * @return The scale at which the layer is visible, calculated to zoom in or out just enough such that the layer would be visible.  If the layer is already visible, the current map scale is returned.
                     */
                    Feature.prototype.calculateScaleToMakeVisible = function (scale) {
                        if (this.withinScaleRange(scale)) {
                            return scale;
                        }
                        else if (scale < this.maxScale.get()) {
                            return this.maxScale.get();
                        }
                        else {
                            return this.minScale.get();
                        }
                    };
                    /**
                     * Ensures that a field name can't be used for injection attacks when used to form a field token.
                     * @param fieldName The field name to sanitize.
                     */
                    Feature.prototype._sanitizeFieldName = function (fieldName) {
                        return fieldName ? fieldName.replace(/\W/g, "") : "";
                    };
                    /**
                     * @private Returns the default field value
                     */
                    Feature.prototype._getDefaultFieldValue = function () {
                        var value = "";
                        var esriFeature = this.esriFeature.get();
                        // Try the display field
                        if (esriFeature && this.layer && this.layer.displayField) {
                            value = esriFeature.attributes[this.layer.displayField.name];
                            if (value !== null && value !== undefined) {
                                value = value.toString().trim();
                            }
                        }
                        // If we don't have anything, try to get the OBJECTID
                        if (((value == null || value == undefined) || !value) && esriFeature && esriFeature.attributes) {
                            value = esriFeature.attributes["OBJECTID"];
                            if (value !== null && value !== undefined) {
                                value = value.toString().trim();
                            }
                        }
                        // If we STILL don't have anything, try to get the first non null attribute
                        if ((value == null || value == undefined || !value) && esriFeature && esriFeature.attributes) {
                            for (var attr in esriFeature.attributes) {
                                value = esriFeature.attributes[attr];
                                if (value !== null && value !== undefined) {
                                    value = value.toString().trim();
                                }
                                if (value) {
                                    break;
                                }
                            }
                        }
                        return String.escapeHtmlEncode(value);
                    };
                    /**
                     * @private Prepare the attachments
                     * @param resolveLayerFields Whether or not we should attempt to resolve the layers fields. Defaults to true.
                     */
                    Feature.prototype._prepAttachmentInfos = function () {
                        var _this = this;
                        // Because getting feature attachment is an expensive operation (it requires a request to the server), we are making the
                        // observable collection fetch the data on demand
                        var attachmentInfos = new ObservableCollection();
                        var originalGet = attachmentInfos.get;
                        attachmentInfos.get = function () {
                            // If the collection has not been initialized from the server, do it
                            if (!_this._isAttachmentInfosLoaded) {
                                _this._loadAttachmentsInfos();
                            }
                            return originalGet.call(attachmentInfos);
                        };
                        var originalGetItems = attachmentInfos.getItems;
                        attachmentInfos.getItems = function () {
                            // If the collection has not been initialized from the server, do it
                            if (!_this._isAttachmentInfosLoaded) {
                                _this._loadAttachmentsInfos();
                            }
                            return originalGetItems.call(attachmentInfos);
                        };
                        var originalGetAt = attachmentInfos.getAt;
                        attachmentInfos.getAt = function (i) {
                            // If the collection has not been initialized from the server, do it
                            if (!_this._isAttachmentInfosLoaded) {
                                _this._loadAttachmentsInfos();
                            }
                            return originalGetAt.call(attachmentInfos, i);
                        };
                        this.attachmentInfos = attachmentInfos;
                    };
                    /**
                     * Load the feature attributes with proper naming
                     * @param resolveLayerFields Whether or not we should attempt to resolve the layers fields. Defaults to true.
                     */
                    Feature.prototype.loadAttributes = function (resolveLayerFields) {
                        var _this = this;
                        // Remember previous gcx attribute values to see if anything changes as a result of refreshing the esri feature data.
                        var previousValues = {};
                        this.attributes.get().forEach(function (attribute) {
                            previousValues[attribute.name.get()] = attribute.value.get();
                            // Unbind previous listener for attribute value changes.
                            var bindingToken = _this._attributeValueBindingTokens[attribute.name.get()];
                            if (bindingToken) {
                                attribute.value.unbind(bindingToken);
                            }
                        });
                        this.attributes.clear();
                        this._attributeValueBindingTokens = {};
                        var attributes = this.getAttributesFromEsriFeature(this._graphic.attributes, resolveLayerFields);
                        attributes.forEach(function (attribute) {
                            var name = attribute.name.get();
                            var value = attribute.value.get();
                            // Listen for changes to the attribute's value.
                            _this._attributeValueBindingTokens[name] = attribute.value.bind(_this, function () {
                                _this.isModified = true;
                            });
                            // Set the isModified flag if anything was changed or added in the esri feature data.
                            _this.isModified = _this.isModified
                                || (previousValues.hasOwnProperty(name) && value !== previousValues[name])
                                || !previousValues.hasOwnProperty(name);
                        });
                        // Set the isModified flag if any attributes were deleted from the esri feature data.
                        var esriAttributes = this._graphic.attributes || {};
                        this.isModified = this.isModified || Object.keys(previousValues).some(function (key) { return !esriAttributes.hasOwnProperty(key); });
                        this.attributes.addItems(attributes);
                    };
                    /**
                     * Takes a collection of attributes from an Esri Graphic (feature) and returns a collection of feature attributes with the proper naming.
                     * @param attributes attribute Collection of name value pairs to which we will attempt to resolve names using this feature
                     * @param resolveLayerFields Whether or not we should attempt to resolve the layers fields. Defaults to true.
                     */
                    Feature.prototype.getAttributesFromEsriFeature = function (attributes, resolveLayerFields) {
                        var _this = this;
                        var featureAttributes = [];
                        // If we have a layer and the layer has fields and we haven't said otherwise, attempt to use the layers fields to resolve the names
                        if (resolveLayerFields !== false && this.layer && this.layer.fields) {
                            var serviceLayer = null;
                            if (this.layer.mapService) {
                                serviceLayer = this.layer.mapService.serviceLayer;
                            }
                            var ignoredFields = [];
                            for (var fieldIx = 0; fieldIx < this.layer.fields.length; fieldIx++) {
                                var layerField = this.layer.fields[fieldIx];
                                var graphicAttr;
                                // Make sure that we have attributes, and that the current layer field name or alias isn't empty.
                                // See GVH-5405 for use case of alias.
                                if (attributes && (layerField.name || layerField.alias)) {
                                    if (attributes.hasOwnProperty(layerField.name)) {
                                        graphicAttr = attributes[layerField.name];
                                    }
                                    else {
                                        graphicAttr = attributes[layerField.alias];
                                    }
                                }
                                // GVH-2923: Ignore resolved coded domain fields added by SEP, since we do our own substitution
                                // of coded domain values in PresentableDelegateFactory.
                                if (geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureAttribute.ignoreAttribute(layerField.name)) {
                                    ignoredFields.push(layerField);
                                    continue;
                                }
                                // We expect a attribute to match the field name, but if we don't have one, then fill it as empty
                                if (typeof graphicAttr === "undefined" || graphicAttr == null) {
                                    featureAttributes.push(new infrastructure.FeatureAttribute("", layerField.name, layerField.alias, layerField.displayName, layerField.visible, infrastructure.PresentableDelegateFactory.valuePresenterDelegate(layerField, this), layerField.dataType));
                                }
                                else {
                                    featureAttributes.push(new infrastructure.FeatureAttribute(graphicAttr, layerField.name, layerField.alias, layerField.displayName, layerField.visible, infrastructure.PresentableDelegateFactory.valuePresenterDelegate(layerField, this), layerField.dataType));
                                }
                            }
                            for (var i = 0; i < ignoredFields.length; i++) {
                                // In many cases the SEP-generated field is configured as visible in Essentials, while the original 
                                // code field is not. Since we skipped adding these fields above, we need to make the code field visible
                                // in these cases, otherwise the field just disappears altogether (see GVH-4652).
                                var nameField = ignoredFields[i];
                                if (nameField.visible) {
                                    var matches = featureAttributes.filter(function (attr) { return attr.name.get() === nameField.name.substr(0, nameField.name.length - ".Name()".length); });
                                    var codeAttribute = matches.length === 1 ? matches[0] : null;
                                    if (codeAttribute) {
                                        if (!codeAttribute.visible.get()) {
                                            codeAttribute.visible.set(true);
                                        }
                                        codeAttribute.alias.set(nameField.alias);
                                        codeAttribute.displayName.set(nameField.displayName);
                                    }
                                }
                            }
                            // For WMS layers we must see if there were any omitted attributes attached to the feature but not in the layer.
                            // This happens when a WMS layer is being run with a Query Transformation Workflow.
                            if (serviceLayer instanceof esri.layers.WMSLayer) {
                                for (var attributeName in attributes) {
                                    var found = false;
                                    var attributeValue = attributes[attributeName];
                                    for (var i = 0; i < this.layer.fields.length; i++) {
                                        if (attributeName === this.layer.fields[i].name) {
                                            found = true;
                                            break;
                                        }
                                    }
                                    if (!found) {
                                        featureAttributes.push(new infrastructure.FeatureAttribute(attributeValue, attributeName));
                                    }
                                }
                            }
                        }
                        else if (this.featureLayer) {
                            this.featureLayer.fields.forEach(function (field) {
                                var alias = field.alias ? field.alias : field.name;
                                if (field.type === geocortex.essentials.EsriFieldTypes.esriFieldTypeDate) {
                                    // If we have a date field, we make a fieldInfo object and let it apply the right offset based on timeZoneId
                                    // and displayTimeZoneId.
                                    var fieldInfo = mapping.infrastructure.gis.FieldInfo.fromEsriField(field, _this.featureLayer);
                                    if (!fieldInfo.timeZoneId) {
                                        fieldInfo.timeZoneId = _this.timeZoneId;
                                    }
                                    if (!fieldInfo.displayTimeZoneId) {
                                        fieldInfo.displayTimeZoneId = _this.displayTimeZoneId;
                                    }
                                    if (!_this.layer && _this.defaultDateFormat) {
                                        // Preserve the date format if set.
                                        fieldInfo.format = "{0:" + _this.defaultDateFormat + "}";
                                    }
                                    featureAttributes.push(new infrastructure.FeatureAttribute(attributes[field.name], field.name, alias, alias, true, infrastructure.PresentableDelegateFactory.valuePresenterDelegate(fieldInfo, null)));
                                }
                                else {
                                    featureAttributes.push(new infrastructure.FeatureAttribute(attributes[field.name], field.name, alias, alias, true, infrastructure.PresentableDelegateFactory.valuePresenterDelegate(field.name, _this)));
                                }
                            });
                        }
                        else if (this.featureSet && this.featureSet.attributes && (this.featureSet.attributes.length() > 0) && attributes) {
                            // Iterate the featureSet attributes, looking for the names
                            for (var i = 0; i < this.featureSet.attributes.length(); i++) {
                                var featureSetAttribute = this.featureSet.attributes.getAt(i);
                                var name = featureSetAttribute.name.get();
                                if (geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureAttribute.ignoreAttribute(name)) {
                                    continue;
                                }
                                // Try to find an attribute matching the featureSets naming conventions
                                if (attributes.hasOwnProperty(name)) {
                                    featureAttributes.push(new infrastructure.FeatureAttribute(attributes[name], name, featureSetAttribute.alias.get(), featureSetAttribute.displayName.get(), featureSetAttribute.visible.get(), infrastructure.PresentableDelegateFactory.valuePresenterDelegate(name, this)));
                                }
                            }
                        }
                        else if (attributes) {
                            for (var attr in attributes) {
                                featureAttributes.push(new infrastructure.FeatureAttribute(attributes[attr], attr, attr, attr, true, infrastructure.PresentableDelegateFactory.valuePresenterDelegate(attr, this)));
                            }
                        }
                        return featureAttributes;
                    };
                    /**
                     * Returns a set of all of the attributes associated with this feature
                     * @param resolveLayerFields boolean: Whether we should look at the layers fields to resolve the names.
                     * @return array an of FeatureAttribute objects where we have attempted to resolve the names using this feature
                     */
                    Feature.prototype.getAttributes = function (resolveLayerFields) {
                        var linkedAttributes = this.linkedAttributes.get();
                        var attrs = [];
                        for (var attrGroupIndex = 0; attrGroupIndex < linkedAttributes.length; attrGroupIndex++) {
                            var attributeGroup = linkedAttributes[attrGroupIndex];
                            // The first attribute group should be the Esri graphic attributes
                            if (attrGroupIndex === 0) {
                                //var featureAttributes = this.getAttributesFromEsriFeature(attributeGroup.attributes);
                                var featureAttributes = this.attributes.get();
                                for (var i = 0; i < featureAttributes.length; i++) {
                                    attrs.push(featureAttributes[i]);
                                }
                            }
                            else {
                                var attributes = attributeGroup.attributes;
                                for (var name in attributes) {
                                    if (!attributes.hasOwnProperty(name)) {
                                        continue;
                                    }
                                    // We're only supposed to have performed datalinking on visible datalinks, sowe should indicate that it's visible. Note that here would be
                                    // where we could build a FieldInfo object in order to correct linked dates for time zones, but the correction for data links has already
                                    // been applied in Essentials, and so we do not need to offset any data link dates.
                                    attrs.push(new infrastructure.FeatureAttribute(attributes[name], name, name, name, true, infrastructure.PresentableDelegateFactory.valuePresenterDelegate(null, null)));
                                }
                            }
                        }
                        return attrs;
                    };
                    /**
                     * Gets the value of the primary key field (ObjectID)
                     * @return {Object} Value of the primary key field.
                     */
                    Feature.prototype.getPrimaryKeyValue = function () {
                        var result = null;
                        if (this.layer && this.layer.primaryKeyField) {
                            var field = this.layer.primaryKeyField;
                            if (field) {
                                result = this._graphic.attributes[field.name];
                            }
                        }
                        return result;
                    };
                    /**
                     * Gets the Url to the feature.
                     * @return {String} Url to the Esri feature.
                     */
                    Feature.prototype.getFeatureUrl = function () {
                        var result = null;
                        // Ensure that getLayerUrl exists on the layer, as with related records the layer can be an Esri layer.
                        var layerUrl = this.layer.getLayerUrl ? this.layer.getLayerUrl() : this.layer.url;
                        // Since related tables make it so that Features can have an Esri layer rather than the usual Gcx Layer we need to perform
                        // some extra logic here.
                        var objectID = null;
                        if (this.layer instanceof geocortex.essentials.Layer) {
                            objectID = this.getPrimaryKeyValue();
                        }
                        else if (this.layer instanceof esri.layers.Layer) {
                            var esriLayer = this.layer;
                            objectID = this.esriFeature.get().attributes[esriLayer.objectIdField];
                        }
                        if (layerUrl && objectID) {
                            result = layerUrl + "/" + objectID;
                        }
                        return result;
                    };
                    /**
                     * Gets the feature's type as defined by its feature layer.
                     */
                    Feature.prototype.getType = function () {
                        if (!this.featureLayer) {
                            return null;
                        }
                        var typeId = infrastructure.PresentableDelegateFactory.typeIdForLayerAndAttributes(this.featureLayer, this._graphic.attributes);
                        if (typeId !== null) {
                            return infrastructure.PresentableDelegateFactory.typeFromLayerAndId(this.featureLayer, typeId);
                        }
                    };
                    /**
                     * Determines whether a Geocortex essentials feature is structurally equal to the current instance.
                     *
                     *     Structural equality means that two objects are equal because they have equal values.
                     *     It differs from reference equality, which indicates that two object references are equal because they reference the same physical object.
                     *     Note: This comparison does not take geometry into account
                     *
                     * @param o: The Geocortex essentials feature to compare with the current instance.
                     * @returns `true` if the two objects are equal; otherwise, `false`.
                     */
                    Feature.prototype.structurallyEquals = function (o) {
                        if (!o || !(o instanceof geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature)) {
                            return false;
                        }
                        // If objects are exactly equal, return true
                        if (this === o) {
                            return true;
                        }
                        else if (this._graphic && o._graphic && this._graphic === o._graphic) {
                            return true;
                        }
                        else if (this._graphic == null) {
                            return false;
                        }
                        else if (o._graphic == null) {
                            return false;
                        }
                        else {
                            // Ensure layers are not defined or are equal
                            var layerIdsEqual = this._getLayerUniqueId() == o._getLayerUniqueId();
                            if (layerIdsEqual) {
                                // Compare feature IDs if specified. 
                                // Assume features are equal if the IDs are specified and are the the same. 
                                // If specified and different, then assume not same features.
                                var featureIdsEqual = this.id.get() === o.id.get();
                                if (featureIdsEqual) {
                                    // ID specified and equal - no need to compare attributes or geometry
                                    if (!String.isNullOrEmpty(this.id.get())) {
                                        return true;
                                    }
                                    else {
                                        return infrastructure.MapUtils.esriFeaturesEqual(this._graphic, o._graphic);
                                    }
                                }
                            }
                        }
                        // Not equal
                        return false;
                    };
                    /**
                     * Checks if the given Geocortex essentials feature is equal to this feature
                     * @param o: A Geocortex essentials feature to be compared
                     */
                    Feature.prototype.equals = function (o) {
                        if (!o || !(o instanceof geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature) || !this._graphic || !o._graphic) {
                            return false;
                        }
                        // If objects are exactly equal, return true
                        if (this === o) {
                            return true;
                        }
                        var thisGeom = this._graphic.geometry;
                        var oGeom = o._graphic.geometry;
                        // Check feature id's
                        var featureIdsEqual = (this.id.get() === o.id.get())
                            || (this.id.get() && o.id.get() && this.id.get() == o.id.get());
                        // Check layer id's
                        var layerIdsEqual = (this.layer === o.layer)
                            || (this.layer && o.layer && this.layer.id == o.layer.id);
                        // Check mapservice Ids
                        var mapserviceIdsEqual = (this.layer === o.layer)
                            || (this.layer && o.layer && this.layer.mapService === o.layer.mapService)
                            || (this.layer && o.layer && this.layer.mapService && o.layer.mapService && this.layer.mapService.id == o.layer.mapService.id);
                        // Run preliminary check for geometry - are declared classes equal?
                        var geometryClassEqual = (thisGeom === oGeom)
                            || (thisGeom && oGeom && thisGeom.declaredClass == oGeom.declaredClass);
                        // Check necessary conditions
                        if (!featureIdsEqual || !layerIdsEqual || !mapserviceIdsEqual || !geometryClassEqual) {
                            return false;
                        }
                        // Check if the esri features (attribute names and length) are equal. 
                        // Note: The following mapUtils method does not currently compare geometries of the esri features
                        if (!geocortex.essentialsHtmlViewer.mapping.infrastructure.MapUtils.esriFeaturesEqual(this._graphic, o._graphic)) {
                            return false;
                        }
                        // Same geometry (or both null/undefined)
                        if (thisGeom === oGeom) {
                            return true;
                        }
                        // Analyze geometry in detail
                        switch (thisGeom.declaredClass) {
                            // As of version 3.3 of the Esri Api, if a spatial reference is not provided to Point, a default sr of 4326 will be assigned.
                            // ScreenPoint represents a point in terms of pixels relative to the top-left corner of the map control. Prior to version 3.3, 
                            // a screen point was represented using a regular Point where the point object is defined without a spatial reference. 
                            case "esri.geometry.Point":
                            case "esri.geometry.ScreenPoint":
                                return infrastructure.MapUtils.esriPointsEqual(thisGeom, oGeom);
                            // An ordered collection of points.
                            case "esri.geometry.MultiPoint":
                                return infrastructure.MapUtils.esriMultipointsEqual(thisGeom, oGeom);
                            // An array of paths where each path is an array of points.
                            case "esri.geometry.Polyline":
                                return infrastructure.MapUtils.esriPolylinesEqual(thisGeom, oGeom);
                            // An array of rings where each ring is an array of points. The first and last points of a ring must be the same.
                            case "esri.geometry.Polygon":
                                return infrastructure.MapUtils.esriPolygonsEqual(thisGeom, oGeom);
                            // The minimum and maximum X- and Y- coordinates of a bounding box.
                            case "esri.geometry.Extent":
                                return infrastructure.MapUtils.esriExtentsEqual(thisGeom, oGeom);
                            // Default behaviour if no match
                            default:
                                throw new Error("Warning: equals() in Feature.ts - declared class does not match known geometry.");
                        }
                    };
                    /** @private Load the attachment infos asynchronously */
                    Feature.prototype._loadAttachmentsInfos = function () {
                        var _this = this;
                        this._isAttachmentInfosLoaded = true;
                        if (!this.layer) {
                            throw new Error("Error fetching attachment infos: Feature was not associated with any known layer.");
                        }
                        // Esri's API treats attachments kind of strangely. You can query them via a FeatureLayer's queryAttachmentInfos method,
                        // but other layer types don't carry that method and you have to hit an attachments endpoint directly.
                        var url = this.getFeatureUrl() + "/attachments/?f=json&ts={0}".format(new Date().getTime());
                        // Must use a cache buster to ensure that accurate attachment information is retrieved every time.
                        var requestParams = {
                            url: url,
                            handleAs: "json"
                        };
                        // Do we have a token associated with this map service?
                        var token = this.layer.mapService && this.layer.mapService.serviceToken ? this.layer.mapService.serviceToken : null;
                        // If we don't have a mapService we're dealing with a table. The token should be on the layer's credential object.
                        var esriLayer = this.layer;
                        if (!this.layer.mapService && esriLayer.credential && esriLayer.credential.token) {
                            token = esriLayer.credential.token;
                        }
                        if (token) {
                            requestParams["url"] += ("&token=" + encodeURIComponent(token));
                        }
                        // On secured sites, trying to use esri.request fails as it goes through the viewer's proxy rather than contacting
                        // the site directly. If we go through the layer itself then it works OK.
                        // Needs to be in a try/catch as there is a problem in offline mode to do with the feature layer lacking _url object -
                        // there is no way to check if we are online/offline here.
                        var request = null;
                        try {
                            var castLayer = this.layer.mapService.serviceLayer;
                            request = castLayer.queryAttachmentInfos(parseInt(this.id.get()));
                        }
                        catch (error) {
                            // Fall back to original way of requesting.
                            request = esri.request(requestParams);
                        }
                        request.then(function (success) {
                            // queryAttachmentInfos returns success as a collection without .attachmentInfos as a variable.
                            // Let's do a little hack to fix that.
                            if (success.length > 0 && !success.attachmentInfos && success instanceof Array) {
                                success.attachmentInfos = [];
                                for (var i = 0; i < success.length; i++) {
                                    success.attachmentInfos[i] = success[i];
                                }
                            }
                            // If there are any attachments, process them
                            if (success && success.attachmentInfos && success.attachmentInfos.length > 0) {
                                var x;
                                // Loop through the attachments
                                for (x = 0; x < success.attachmentInfos.length; x++) {
                                    var rawAttachmentInfo = success.attachmentInfos[x];
                                    var attachmentInfo = new geocortex.essentialsHtmlViewer.mapping.infrastructure.AttachmentInfo();
                                    attachmentInfo.id.set(rawAttachmentInfo.id);
                                    attachmentInfo.contentType.set(rawAttachmentInfo.contentType);
                                    attachmentInfo.size.set(rawAttachmentInfo.size);
                                    attachmentInfo.name.set(rawAttachmentInfo.name);
                                    var attachmentUrl = "{0}/attachments/{1}".format(_this.getFeatureUrl(), rawAttachmentInfo.id);
                                    if (token) {
                                        attachmentUrl += "?token=" + token;
                                    }
                                    attachmentInfo.url.set(attachmentUrl);
                                    _this.attachmentInfos.addItem(attachmentInfo);
                                }
                            }
                            _this.attachmentInfosInitialized.set(true);
                        }, function (error) {
                            _this.attachmentInfosInitialized.set(true);
                        });
                    };
                    /** The method formatTemplateString was made public to be consistent with silverlight viewer.
                    * It is used by Hyperlink class "geocortex.essentialsHtmlViewer.mapping.modules.FeatureDetails.FeatureDetailsProviders.Hyperlink". */
                    Feature.prototype.formatTemplateString = function (template) {
                        var _this = this;
                        if (!template) {
                            return "";
                        }
                        var result = template.replace(/{{.+?}}|{.+?}/g, function (match) {
                            // check if this is a double token. if it is, remove a single layer of tokening, so that it might be resolved by token replacements further down. 
                            // This is likely occurs due to bindings in a feature description, such as the @event-onclick used  for feature command hyperlinks.
                            if (match.match(/{{.+?}}/g)) {
                                return match.substring(1, match.length - 1);
                            }
                            else {
                                var fieldName = match.substring(1, match.length - 1);
                                var replacement = "";
                                var nameMatch = fieldName.match(/(.*)\.Name\(\)$/);
                                if (nameMatch) {
                                    // If out template ends with .Name(), we want to drop it, and just use the first part
                                    fieldName = nameMatch[1];
                                }
                                // First attempt to get it from the existing feature's attributes.
                                var attributes = _this.getAttributes();
                                for (var i = 0; i < attributes.length; i++) {
                                    if ((attributes[i].name && attributes[i].name.get() === fieldName) || (attributes[i].alias && attributes[i].alias.get() === fieldName)) {
                                        // Is this object actually a hyperlink? If so, the presentable value will be the hyperlink label. What we probably
                                        // want here for token substitution is the actual URL value.
                                        if (_this.layer) {
                                            var fieldInfo = _this.layer.getFieldByName(fieldName);
                                            if (fieldInfo && geocortex.framework.utils.isUrl(attributes[i].value.get())) {
                                                replacement = attributes[i].value.get();
                                                break;
                                            }
                                        }
                                        replacement = attributes[i].presentableValue.get();
                                        break;
                                    }
                                }
                                if (!replacement && _this.layer) {
                                    replacement = geocortex.essentials.utilities.StringUtilities.replaceLayerTokens(fieldName, _this.layer);
                                }
                                if (!replacement && _this.layer && _this.layer.mapService) {
                                    replacement = geocortex.essentials.utilities.StringUtilities.replaceMapServicetokens(fieldName, _this.layer.mapService);
                                }
                                if (!replacement) {
                                    var parsed = {};
                                    // Process the fieldName into a dataLink/attributeName pair
                                    if (_this.parseDataLinkId(fieldName, parsed)) {
                                        if (_this.dataLinkingResults.get()) {
                                            // Iterate the features datalinks to look for a datalink with the correct name
                                            for (var i = 0; i < _this.dataLinkingResults.length(); i++) {
                                                var result = _this.dataLinkingResults.getAt(i);
                                                // If the the current dataLink is matches the id we're looking for
                                                if (result.dataLink.get() && result.dataLink.get().id === parsed.dataLinkId) {
                                                    // This is a special case that returns the number of rows in a datalink.
                                                    if (parsed.attributeName.toLowerCase() === "_rowcount") {
                                                        if (result.table) {
                                                            replacement = result.table.get().rows.length;
                                                        }
                                                        else {
                                                            replacement = 0;
                                                        }
                                                    }
                                                    else if (result.table.get()) {
                                                        var table = result.table.get();
                                                        for (var j = 0; j < table.columns.length; j++) {
                                                            // And if a matching column is found
                                                            if (table.columns[j].toLowerCase() === parsed.attributeName.toLowerCase()) {
                                                                // Use the first row's value for that column.
                                                                if (table.rows.length > 0) {
                                                                    replacement = table.rows[0].row[j];
                                                                }
                                                                break;
                                                            }
                                                        }
                                                    }
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                                if (!replacement && fieldName === "RestToken") {
                                    replacement = geocortex.essentials.RestHelperHTTPService.token;
                                }
                                // SECURITY: If the feature has not been tagged as unsafe content (allowed to have tags in attribute data), strip out HTML tags.
                                if (!_this._allowUnsafeContent) {
                                    replacement = (replacement || replacement === 0) ? String.escapeHtmlEncode(replacement.toString()) : "";
                                }
                                else if (replacement == null) {
                                    replacement = "";
                                }
                                if (replacement === null || replacement === undefined) {
                                    replacement = "";
                                }
                                return replacement;
                            }
                        });
                        return result;
                    };
                    /**
                     * Process the fieldName into a dataLink/attributeName pair
                     * @param fieldName String containing the value of datalink ID and attribute name
                     * @param result Empty map object used to store the datalink ID and attribute name
                     */
                    Feature.prototype.parseDataLinkId = function (fieldName, result) {
                        var index = fieldName.indexOf(".");
                        if (index < 0) {
                            return false;
                        }
                        result.dataLinkId = fieldName.substring(0, index);
                        result.attributeName = fieldName.substring(index + 1);
                        return true;
                    };
                    /**@private */
                    Feature.prototype._getLayerUniqueId = function () {
                        var layerId = "";
                        if (this.layer) {
                            layerId = this.layer.id;
                            if (this.layer.mapService) {
                                layerId = this.layer.mapService.id + "/" + layerId;
                            }
                        }
                        return layerId;
                    };
                    Feature.prototype._setupLinkedAttributes = function () {
                        var attributeGroup = new geocortex.essentialsHtmlViewer.mapping.infrastructure.AttributeGroup();
                        attributeGroup.owner = this._graphic;
                        attributeGroup.attributes = this._graphic.attributes;
                        this.linkedAttributes.clear();
                        this.linkedAttributes.addItem(attributeGroup);
                    };
                    Feature.prototype._refreshPresentableValues = function () {
                        // Clear any cached presentable values and pulse them.
                        this.attributes.get().forEach(function (attribute) {
                            attribute.presentableValue.clear();
                            attribute.presentableValue.pulse();
                        });
                        this.label.clear();
                        this.plainLabel.clear();
                        this.description.clear();
                        this.longDescription.clear();
                        this.label.pulse();
                        this.plainLabel.pulse();
                        this.description.pulse();
                        this.longDescription.pulse();
                    };
                    return Feature;
                }());
                infrastructure.Feature = Feature;
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                /** A special property added to an esri feature to indicate that it came from a KML service. */
                infrastructure.isKmlProperty = "__isKml";
                /**
                 * A {@link Feature} belonging to a KML service.
                 */
                var KmlFeature = (function (_super) {
                    __extends(KmlFeature, _super);
                    function KmlFeature(options) {
                        _super.call(this, options);
                        // For KML services, map the format strings to their appropriate KML counterparts. Unlike other types of layers, 
                        // these are hard-coded and cannot currently be configured by the administrator in Essentials. These are well-defined
                        // fields that come from the KML spec: https://developers.google.com/kml/documentation/kmlreference#feature.
                        var esriFeature = this.esriFeature.get();
                        var attributes = esriFeature ? esriFeature.attributes || {} : {};
                        this.labelFormat.set(attributes.hasOwnProperty("name") ? "{name}" : "{id}");
                        this.descriptionFormat.set("{snippet}");
                        this.longDescriptionFormat.set(attributes.hasOwnProperty("balloonStyleText") ? "{balloonStyleText}" : "{description}");
                        // Add a special flag to the esri feature to indicate that it's KML feature.
                        if (esriFeature && !esriFeature[infrastructure.isKmlProperty]) {
                            esriFeature[infrastructure.isKmlProperty] = true;
                        }
                    }
                    return KmlFeature;
                }(infrastructure.Feature));
                infrastructure.KmlFeature = KmlFeature;
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../_Definitions/framework.d.ts"/>
/// <reference path="../../_Definitions/framework.ui.d.ts"/>
/// <reference path="../../_Definitions/essentials.d.ts"/>
/// <reference path="../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="./DataLinkingResult.ts"/>
/// <reference path="./FeatureAttribute.ts"/>
/// <reference path="./Feature.ts"/>
/// <reference path="./KmlFeature.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                (function (DataLinksState) {
                    DataLinksState[DataLinksState["Unresolved"] = 0] = "Unresolved";
                    DataLinksState[DataLinksState["Resolving"] = 1] = "Resolving";
                    DataLinksState[DataLinksState["Resolved"] = 2] = "Resolved";
                })(infrastructure.DataLinksState || (infrastructure.DataLinksState = {}));
                var DataLinksState = infrastructure.DataLinksState;
                var FeatureSet = (function () {
                    /**
                     * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSet} class.
                     * @class
                     * <p>Represents a Geocortex Essentials FeatureSet.</p>
                     * @constructs
                     * @memberOf geocortex.essentialsHtmlViewer.mapping.infrastructure
                     * @param options The options for the new FeatureSet (i.e. esriFeatureSet / layer / allowUnsafeContent).
                     */
                    function FeatureSet(options) {
                        var _this = this;
                        /**
                         * An id of this feature set
                         * @type String
                         */
                        this.id = "";
                        /**
                        * The esri feature layer containing metadata about the feature attributes.
                        */
                        this.featureLayer = null;
                        /**
                         * The display name to be associated with this FeatureSet. Get display name from layer if not explicitly set.
                         * @type String
                         */
                        this.displayName = new geocortex.framework.ui.LazyObservable();
                        /**
                         * The collection of Geocortex Features.
                         * @type ObservableCollection
                         */
                        this.features = new ObservableCollection();
                        /**
                         * The collection of feature attributes
                         * @type ObservableCollection
                         */
                        this.attributes = new ObservableCollection();
                        /**
                         * The icon associated with this featureSet. If not explicitly set, obtain from layer if available
                         * @type String
                         */
                        this.iconUri = new geocortex.framework.ui.LazyObservable();
                        /**
                         * More properties of feature set
                         * @type ObservableCollection
                         */
                        this.extendedProperties = new ObservableCollection();
                        /**
                         * Only used by a particular view model.  This should be refactored out.
                         */
                        this.isSelectedInCollection = new Observable(false);
                        /**
                         * Whether the datalinks (if any) for this feature set have been resolved.
                         */
                        this.dataLinksResolved = new Observable(false);
                        /** The default format to use for displaying number fields that have no explicit format. */
                        this.defaultNumberFormat = infrastructure.NumberFormat.DEFAULT;
                        /** The default format to use for displaying date fields that have no explicit format. */
                        this.defaultDateFormat = infrastructure.DateFormat.DEFAULT;
                        /** Keeps track of objectIds to ensure we there aren't duplicate features in this FeatureSet */
                        this._objectIds = new infrastructure.Dictionary();
                        this._watchHandles = {};
                        this._dataLinksState = DataLinksState.Unresolved;
                        var esriFeatureSet = null;
                        var layer = null;
                        // GVH-9210 Make sure options object is not null
                        options = options || {};
                        if (options.hasOwnProperty("esriFeatureSet")) {
                            esriFeatureSet = options.esriFeatureSet;
                        }
                        if (options.hasOwnProperty("featureLayer")) {
                            this.featureLayer = options.featureLayer;
                        }
                        if (options.hasOwnProperty("layer")) {
                            layer = options.layer;
                        }
                        if (options.hasOwnProperty("allowUnsafeContent")) {
                            this._allowUnsafeContent = options.allowUnsafeContent;
                        }
                        else {
                            this._allowUnsafeContent = false;
                        }
                        if (options.hasOwnProperty("app")) {
                            this.app = options.app;
                        }
                        this.defaultDateFormat = options.defaultDateFormat || infrastructure.DateFormat.DEFAULT;
                        this.defaultNumberFormat = options.defaultNumberFormat || infrastructure.NumberFormat.DEFAULT;
                        this.uniqueId = "fs_" + geocortex.framework.utils.alphaNumericToken();
                        this.esriFeatureSet = esriFeatureSet;
                        if (layer) {
                            this.layer = layer;
                            if (this.layer && this.layer.mapService) {
                                this.id = "{0}/{1}".format(this.layer.mapService.id, this.layer.id);
                            }
                        }
                        this.displayName.delegateGetter = function () {
                            if (_this.layer && _this.layer.displayName) {
                                return _this.layer.displayName;
                            }
                            return "";
                        };
                        this.iconUri.delegateGetter = function () {
                            if (_this.layer && _this.layer.iconUri) {
                                return _this.layer.iconUri;
                            }
                            return "";
                        };
                        /* Load all observables during construction */
                        this.loadFeatures();
                        this.loadAttributes();
                    }
                    Object.defineProperty(FeatureSet.prototype, "dataLinksState", {
                        /**
                         * Indicates the current state with regard to resolving data links.
                         */
                        get: function () {
                            return this._dataLinksState;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    FeatureSet.prototype.setDataLinksState = function (value) {
                        this._dataLinksState = value;
                        this.dataLinksResolved.set(value === DataLinksState.Resolved);
                    };
                    /**
                     * Finds the extended property matching the specified name.
                     * @param name The name of the property to find.
                     */
                    FeatureSet.prototype.getExtendedPropertyByName = function (name) {
                        for (var i = 0; i < this.extendedProperties.getLength(); i++) {
                            var prop = this.extendedProperties.getAt(i);
                            if (prop && prop.name == name) {
                                return prop.value;
                            }
                        }
                        return null;
                    };
                    /**
                     * Sets the extended property matching the specified name.
                     * @param name The name of the property to update.
                     * @param value The property value.
                     */
                    FeatureSet.prototype.setExtendedProperty = function (name, value) {
                        for (var i = 0; i < this.extendedProperties.getLength(); i++) {
                            var prop = this.extendedProperties.getAt(i);
                            if (prop && prop.name == name) {
                                prop.value = value;
                                return;
                            }
                        }
                        // Property not found - add it to the collection
                        this.extendedProperties.addItem({ name: name, value: value });
                    };
                    /**
                     * Adds a feature to this FeatureSet.
                     * @param feature The feature to add to the featureSet.
                     * @param doNotCheckForDuplicates When `true`, the supplied feature will be added to this set without checking for duplicates. The default value is `false`.
                     */
                    FeatureSet.prototype.addFeature = function (feature, doNotCheckForDuplicates) {
                        var args = new geocortex.framework.events.CollectionChangedArgs();
                        var length = this.features.length();
                        args.type = "append";
                        args.rangeStart = length;
                        args.rangeEnd = length;
                        args.sender = this.features;
                        // Add feature, then notify change to listeners
                        var added = this._addFeatureWithoutNotification(feature, doNotCheckForDuplicates);
                        if (added) {
                            // Notify
                            this.features.bindingEvent.publish(args);
                            return true;
                        }
                        // Feature not added to this set
                        return false;
                    };
                    FeatureSet.prototype._addFeatureWithoutNotification = function (feature, doNotCheckForDuplicates) {
                        if (!feature) {
                            throw new Error("Feature cannot be null.");
                        }
                        // Modify the underlying array directly to avoid firing collection change events.
                        var array = this.features.getItems();
                        // Don't add feature twice
                        if (!!doNotCheckForDuplicates || !this.containsFeature(feature)) {
                            // TODO: what if this feature already belongs to another featureSet????? Should we remove it? Most likely.... Sivlerlight doesn't so that though (as of July 3, 2012)
                            feature.featureSet = this;
                            array.push(feature);
                            if (this.esriFeatureSet && this.esriFeatureSet.features) {
                                this.esriFeatureSet.features.push(feature.esriFeature.get());
                            }
                            return true;
                        }
                        // Feature not added to this set
                        return false;
                    };
                    /**
                     * Removes a feature from this FeatureSet.
                     *
                     *     This method determines equality by using the default equality comparer for features, as defined in {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature.equals}().
                     *     This method performs a linear search; therefore, this method is an O(n) operation, where n is the number of features.
                     *
                     * @param feature The feature to remove.
                     * @return `true` if item was successfully removed; otherwise, `false`. This method also returns `false` if item is not found.
                     */
                    FeatureSet.prototype.removeFeature = function (feature) {
                        if (!feature) {
                            throw new Error("Feature cannot be null.");
                        }
                        // Short circuit - if the feature has an Id then we can check the 
                        // set of id's first to see if the feature is part of the feature set 
                        // in question
                        var featureId = feature.id.get();
                        if (!String.isNullOrEmpty(featureId) && !this._objectIds.containsKey(featureId)) {
                            return false;
                        }
                        var args = new geocortex.framework.events.CollectionChangedArgs();
                        args.type = "remove";
                        // Find the feature using structural comparison.
                        var i = this.features.length();
                        while (i--) {
                            var obj = this.features.getAt(i);
                            if (obj && obj.structurallyEquals(feature)) {
                                // Removing is an special case - the change event is broadcasted *before* actually removing. 
                                // This is because any handler of the event can know the exact state of the collection based 
                                // on the event args itself, but can still look at the collection to see what's being removed.
                                args.rangeStart = i;
                                args.rangeEnd = i;
                                args.sender = this.features;
                                this.features.bindingEvent.publish(args);
                                // Remove
                                this._removeWithoutNotificationAt(i);
                                return true;
                            }
                        }
                        // Feature not found on this set
                        return false;
                    };
                    FeatureSet.prototype._removeWithoutNotificationAt = function (index) {
                        var array = this.features.getItems();
                        if (0 <= index && index < array.length) {
                            var obj = array[index];
                            // Remove the Esri feature backing this Geocortex feature (if any)
                            var esriFeature = obj.esriFeature.get();
                            if (esriFeature && this.esriFeatureSet && this.esriFeatureSet.features) {
                                geocortex.framework.utils.ArrayUtils.removeItem(this.esriFeatureSet.features, esriFeature);
                            }
                            // Now remove the Geocortex feature itself
                            obj.featureSet = null;
                            geocortex.framework.utils.ArrayUtils.remove(array, index, index);
                            return true;
                        }
                        // Index out of bounds
                        return false;
                    };
                    /**
                     * Determines whether a feature is in this FeatureSet.
                     *
                     *     This method determines equality by using the default equality comparer for features, as defined in {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature.equals}().
                     *     This method performs a linear search; therefore, this method is an O(n) operation, where n is the number of features.
                     *
                     * @param feature The feature to locate in the FeatureSet.
                     * @return `true` if feature is found in the FeatureSet; otherwise, `false`.
                     */
                    FeatureSet.prototype.containsFeature = function (feature) {
                        if (!feature) {
                            throw new Error("Feature cannot be null.");
                        }
                        // Optimization: First check the cached lookup table to see if we can locate this feature by Id
                        var idToMatch = feature.id.get();
                        if (idToMatch && this._objectIds.containsKey(idToMatch)) {
                            return true;
                        }
                        // Not found, do a deep check
                        for (var i = 0; i < this.features.length(); i++) {
                            var obj = this.features.getAt(i);
                            if (obj.structurallyEquals(feature)) {
                                return true;
                            }
                        }
                        return false;
                    };
                    /**
                     * Removes all features from this FeatureSet.
                     */
                    FeatureSet.prototype.clearFeatures = function () {
                        if (this.features.length() == 0) {
                            // Nothing to clear
                            return;
                        }
                        // We want to publish a single "clear" event instead of multiple "remove" events.
                        // Multiple change events fired in quick succession degrade performance and cause GVH-9088
                        var args = new geocortex.framework.events.CollectionChangedArgs();
                        args.type = "clear";
                        args.rangeStart = 0;
                        args.rangeEnd = this.features.length() - 1;
                        args.sender = this.features;
                        this.features.bindingEvent.publish(args);
                        // Clear is a special case - we'll broadcast the event *before* actually clearing. This is because
                        // any handler of the event can know the exact state of the collection based on the event args itself,
                        // but can still look at the collection to see what's being cleared.
                        while (this.features.length() > 0) {
                            this._removeWithoutNotificationAt(0);
                        }
                    };
                    /**
                     * Load the geometries for the specified features (if not already loaded).
                     * If null is passed in, the geometries for all features will be fetched.
                     * @param features An array of features to load geometries for.
                     * @param successCallback Function to be called when the geometries have been loaded.
                     * @param errorCallback A function that is called if an error occurred.
                     * @return {dojo.Deferred}
                     */
                    FeatureSet.prototype.loadGeometries = function (features, successCallback, errorCallback) {
                        var _this = this;
                        var def = new dojo.Deferred();
                        // If the layer is null, we can't perform the load of geometries
                        if (!this.layer) {
                            var error = new Error("loadGeometries: Layer must be present.");
                            geocortex.deferredReject(def, error);
                            if (typeof (errorCallback) == "function") {
                                errorCallback(error);
                            }
                            return def;
                        }
                        // We need a primary key field to proceed
                        if (!this.layer.primaryKeyField) {
                            var error = new Error("loadGeometries: Layer must have a PrimaryKeyField to load geometries.");
                            geocortex.deferredReject(def, error);
                            if (typeof (errorCallback) == "function") {
                                errorCallback(error);
                            }
                            return def;
                        }
                        var keyFieldName = this.layer.primaryKeyField.name;
                        // Check if we should operate on all features
                        if (!features) {
                            // Use all the features
                            features = this.features.getItems();
                        }
                        var operatingSet = [];
                        if (features) {
                            var i;
                            // Loop through the features
                            for (i = 0; i < features.length; i++) {
                                var feature = features[i];
                                // Make sure the feature doesn't have geometry
                                if (!feature.hasGeometry.get()) {
                                    var esriFeature = feature.esriFeature.get();
                                    // If the feature contains the key field and it's not null, add feature to operating set
                                    if (esriFeature && esriFeature.attributes[keyFieldName]) {
                                        operatingSet.push(feature);
                                    }
                                }
                            }
                        }
                        // Check if there is any work to do
                        if (operatingSet.length > 0) {
                            var objectIds = [];
                            // Get all the objectIDs
                            for (i = 0; i < operatingSet.length; i++) {
                                objectIds.push(operatingSet[i].esriFeature.get().attributes[keyFieldName]);
                            }
                            var queryTask = infrastructure.taskUtils.getQueryTask(this.layer);
                            var query = new esri.tasks.Query();
                            query.objectIds = objectIds;
                            query.returnGeometry = true;
                            query.outFields = [keyFieldName];
                            // Get the spatial reference of the map
                            if (this.layer && this.layer.mapService && this.layer.mapService.essentialsMap && this.layer.mapService.essentialsMap.site) {
                                var map = this.layer.mapService.essentialsMap.site.getMap();
                                if (map) {
                                    query.outSpatialReference = this.layer.mapService.essentialsMap.site.getMap().spatialReference;
                                }
                            }
                            queryTask.execute(query).then(function (results) {
                                // Make sure we have some results
                                if (results && results.features && results.features.length > 0) {
                                    for (var j = 0; j < results.features.length; j++) {
                                        var rfeature = results.features[j];
                                        var sourceFeature = _this._findFeature(rfeature.attributes[keyFieldName], keyFieldName, operatingSet);
                                        if (sourceFeature) {
                                            sourceFeature.esriFeature.get().geometry = rfeature.geometry;
                                        }
                                    }
                                }
                                geocortex.deferredResolve(def, undefined);
                                if (typeof (successCallback) == "function") {
                                    successCallback();
                                }
                            }, function (error) {
                                var innerError = new Error("loadGeometries: Query error: " + error.message);
                                geocortex.deferredReject(def, innerError);
                                if (typeof (errorCallback) == "function") {
                                    errorCallback(innerError);
                                }
                            });
                        }
                        else {
                            geocortex.deferredResolve(def, undefined);
                            if (typeof (successCallback) == "function") {
                                successCallback();
                            }
                        }
                        return def;
                    };
                    /**
                     * Finds the Geocortex feature having the given ID (primary key value).
                     * @param id The ID to search for.
                     * @return The Geocortex feature corresponding to the given ID if it exists, or null.
                     */
                    FeatureSet.prototype.findFeatureById = function (id) {
                        return this._objectIds.get(id);
                    };
                    /**
                     * Finds the Geocortex feature corresponding to the given ESRI feature if it exists in the feature set.
                     * There is an inherent assumption here that a Geocortex feature instance will be unique in a feature set.
                     * @param esriFeature The esri graphic for which the corresponding Geocortex feature needs to be retrieved.
                     * @return The Geocortex feature corresponding to the given ESRI feature, if it exists, or null.
                     */
                    FeatureSet.prototype.findFeatureByEsriFeature = function (esriFeature) {
                        var feature = null;
                        var currFeatLayer = esriFeature.getLayer();
                        // Best effort basis. Return null only if we're sure the layer associated with this feature set doesn't match the layer
                        // for the feature we seek. If no layer is defined or we cannot ascertain this definitively, check the features for a match.
                        if (currFeatLayer && this.layer && this.layer.mapService && this.layer.mapService.serviceLayer !== currFeatLayer) {
                            return null;
                        }
                        for (var x = 0; x < this.features.length(); x++) {
                            var currFeat = this.features.getAt(x);
                            if (currFeat.esriFeature && ((currFeat.esriFeature.get() === esriFeature) || infrastructure.MapUtils.esriFeaturesEqual(currFeat.esriFeature.get(), esriFeature))) {
                                feature = currFeat;
                                break;
                            }
                        }
                        return feature;
                    };
                    /**
                     * Finds the ESRI features with given value of specified attribute in the given feature collection
                     * @param key The value against which the features are to be checked.
                     * @param keyName The name of the attribute whose value is to be compared.
                     * @param collection An array of ESRI features which needs to be checked against the given value.
                     * @return ESRI feature whose specified attribute's value is equal to the specified value
                     * @private
                     */
                    FeatureSet.prototype._findFeature = function (key, keyName, collection) {
                        var result = null;
                        var i, esriFeature;
                        if (collection && collection.length > 0) {
                            for (i = 0; i < collection.length; i++) {
                                esriFeature = collection[i].esriFeature.get();
                                if (esriFeature && esriFeature.attributes && esriFeature.attributes[keyName] == key) {
                                    result = collection[i];
                                    break;
                                }
                            }
                        }
                        return result;
                    };
                    /**
                     * Loads the features from ESRI feature set
                     */
                    FeatureSet.prototype.loadFeatures = function () {
                        this._watchFeatureSetChanges();
                        this.features.clear();
                        // We'll add all observable items in one operation for performance
                        var items = [];
                        var feature;
                        if (this.esriFeatureSet && this.esriFeatureSet.features) {
                            for (var i = 0; i < this.esriFeatureSet.features.length; ++i) {
                                var esriFeature = this.esriFeatureSet.features[i];
                                var options_1 = {
                                    "graphic": esriFeature,
                                    "layer": this.layer,
                                    "featureLayer": this.featureLayer,
                                    "resolveLayerFields": true,
                                    "allowUnsafeContent": this._allowUnsafeContent
                                };
                                feature = esriFeature && esriFeature[infrastructure.isKmlProperty] ? new infrastructure.KmlFeature(options_1) : new infrastructure.Feature(options_1);
                                feature.featureSet = this;
                                feature.defaultDateFormat = this.defaultDateFormat;
                                feature.defaultNumberFormat = this.defaultNumberFormat;
                                items.push(feature);
                            }
                        }
                        this.features.useThrottling = false; // Should not be set to true until GVH-1044 is resolved
                        this.features.addItems(items);
                    };
                    /**
                     * Loads the feature attributes.
                     */
                    FeatureSet.prototype.loadAttributes = function () {
                        this.attributes.clear();
                        var attributes = [];
                        var ignoredFields = [];
                        if (this.layer && this.layer.fields) {
                            for (var fieldIx = 0; fieldIx < this.layer.fields.length; fieldIx++) {
                                var layerField = this.layer.fields[fieldIx];
                                // GVH-2923: Ignore resolved coded domain fields added by SEP, since we do our own substitution
                                // of coded domain values in PresentableDelegateFactory.
                                if (geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureAttribute.ignoreAttribute(layerField.name)) {
                                    ignoredFields.push(layerField);
                                    continue;
                                }
                                attributes.push(new infrastructure.FeatureAttribute("", layerField.name, layerField.alias, layerField.displayName, layerField.visible, infrastructure.PresentableDelegateFactory.valuePresenterDelegate(layerField, null)));
                            }
                            for (var i = 0; i < ignoredFields.length; i++) {
                                // In many cases the SEP-generated field is configured as visible in Essentials, while the original 
                                // code field is not. Since we skipped adding these fields above, we need to make the code field visible
                                // in these cases, otherwise the field just disappears altogether (see GVH-4652).
                                var nameField = ignoredFields[i];
                                if (nameField.visible) {
                                    var matches = attributes.filter(function (attr) { return attr.name.get() === nameField.name.substr(0, nameField.name.length - ".Name()".length); });
                                    var codeAttribute = matches.length === 1 ? matches[0] : null;
                                    if (codeAttribute) {
                                        if (!codeAttribute.visible.get()) {
                                            codeAttribute.visible.set(true);
                                        }
                                        codeAttribute.alias.set(nameField.alias);
                                        codeAttribute.displayName.set(nameField.displayName);
                                    }
                                }
                            }
                        }
                        else {
                            // Describe this featureSet based on the first feature.
                            if (this.esriFeatureSet && this.esriFeatureSet.features && this.esriFeatureSet.features.length > 0) {
                                var ff = this.esriFeatureSet.features[0];
                                for (var attr in ff.attributes) {
                                    if (ff.attributes.hasOwnProperty(attr)) {
                                        attributes.push(new infrastructure.FeatureAttribute("", attr, attr, attr));
                                    }
                                }
                            }
                        }
                        this.attributes.addItems(attributes);
                    };
                    /**
                     * Updates the current collection of features.
                     * @params args Type of operation done on feature set.
                     */
                    FeatureSet.prototype.featureSetChanged = function (args) {
                        if (args.type == "append" || args.type == "insert") {
                            for (var i = args.rangeStart; i <= args.rangeEnd; i++) {
                                var feature = this.features.getAt(i);
                                feature.featureSet = this;
                                var featureId = feature.id.get();
                                if (featureId) {
                                    this._objectIds.set(featureId, feature);
                                }
                            }
                        }
                        if (args.type == "remove" || args.type == "clear") {
                            for (var i = args.rangeStart; i <= args.rangeEnd; i++) {
                                this.features.getAt(i).featureSet = null;
                                var featureId = this.features.getAt(i).id.get();
                                if (featureId) {
                                    this._objectIds.remove(featureId);
                                }
                            }
                        }
                    };
                    /**
                     * Apply the datalinks with the given featureSet, datalinks and results collection
                     * @param featureSet
                     * @param dataLinks The datalinks to be applied
                     * @param resultsCollection
                     * @param onDataLinkAddedToFeature
                     * @private
                     */
                    FeatureSet.prototype._applyDataLinks = function (featureSet, features, dataLinks, resultsCollection, onDataLinkAddedToFeature) {
                        // Remove existing data links from features before processing new data links.
                        // This ensures you can call ResolveDataLinksAsync as many times as you'd like.
                        for (var i = 0; i < featureSet.features.length(); i++) {
                            var feature = featureSet.features.getAt(i);
                            if (feature.linkedAttributes.length() > 0) {
                                // First attribute group is the attributes on the esri feature. Save it
                                var featureAttributes = feature.linkedAttributes.getAt(0);
                                // Clear the group and add it back
                                feature.linkedAttributes.clear();
                                feature.linkedAttributes.addItem(featureAttributes);
                                // Remove the raw results
                                feature.dataLinkingResults.clear();
                            }
                        }
                        // Iterate over each result set and add linked data to individual features
                        for (var j = 0; j < dataLinks.length; j++) {
                            var collection = resultsCollection[j];
                            var dataLink = dataLinks[j];
                            // process each result - one per feature. That feature is identified by result.Index
                            for (var collectionIndex = 0; collectionIndex < collection.length; collectionIndex++) {
                                var result = collection[collectionIndex];
                                // Set up a data linking result. This makes it easier for us to both
                                // 1) keep track of all of the original results in the features dataLinkingResults and
                                // 2) create the features linkedAttributes for those 1-1 links.
                                var dataLinkingResult = new geocortex.essentialsHtmlViewer.mapping.infrastructure.DataLinkingResult();
                                dataLinkingResult.table.set(result.linkedData);
                                dataLinkingResult.dataLink.set(dataLink);
                                // Get the feature associated with the result and attach the result and update 
                                // the LinkedAttributes collection if 1-1. Note: Silverlight's viewer's results view databind to the 
                                // linked attributes, to make it look like these linkedAttributes are on the feature itself.
                                // We will likely want to do the same.
                                var feature = features[result.index];
                                feature.dataLinkingResults.addItem(dataLinkingResult);
                                // Execute the callback with the feature to identify that it was updated.
                                if (onDataLinkAddedToFeature) {
                                    onDataLinkAddedToFeature(feature);
                                }
                                if (dataLink.isOneToOne) {
                                    feature.linkedAttributes.addItem(dataLinkingResult.asAttributeGroup());
                                }
                            }
                        }
                    };
                    /**
                     * Resolves the datalinks (if any) for this feature set
                     * @param onDataLinkAddedToFeature Function to be called when a datalink is resolved for a given feature
                     * @param honorVisible Boolean of whether or not we should only resolve visible datalinks. By default this is true.
                     * @param userState A User State that will be returned to the complete and fail callbacks
                     * @param onDataLinkingComplete a function that is called if the operation completes successfully
                     * @param onDataLinkingFailed a function that is called if an error occurs
                     */
                    FeatureSet.prototype.resolveDataLinks = function (onDataLinkAddedToFeature, honorVisible, userState, onDataLinkingComplete, onDataLinkingFailed) {
                        var _this = this;
                        var featureSet = this;
                        if (this.dataLinksState === DataLinksState.Resolving) {
                            if (onDataLinkingFailed) {
                                onDataLinkingFailed(this, new Error("Currently performing data linking"), userState);
                            }
                            return;
                        }
                        // Set up our defaults. So far it's just honorVisible, because we want this to default to True.  
                        // everything else will falsey not run
                        if (typeof honorVisible === "undefined") {
                            honorVisible = true;
                        }
                        if (featureSet.layer && featureSet.layer.hasDataLinks && featureSet.features.length() > 0) {
                            // Signal that datalinks are being resolved.
                            featureSet.setDataLinksState(DataLinksState.Resolving);
                            // Take a snapshot of the current features. In rare cases, the feature set may be modified while
                            // data links are resolving, causing results to be improperly applied when they come back.
                            var features_1 = this.features.get().slice();
                            // This will define all of the data links for this feature set that we need to resolve
                            var dataLinks = [];
                            if (honorVisible) {
                                // Only use Visible data links.
                                dataLinks = dojo.filter(featureSet.layer.dataLinks, function (dataLink) {
                                    return dataLink.visible;
                                });
                            }
                            else {
                                // use all data links
                                dataLinks = featureSet.layer.dataLinks;
                            }
                            // GVH-6537: Ignores any datalinks which do not have parameters defined. This is a temporary workaround for an edge case till GVH-6878 is resolved.
                            dataLinks = dojo.filter(dataLinks, function (dataLink) { return !!(dataLink && dataLink.parameters && dataLink.parameters.length); });
                            // Collect data link results so we can attach them to a feature in data-link order.
                            // This will keep things from getting complicated if out consumers happen to be data binding to them
                            var resultsCollection = [];
                            // Keep track of the number of results returned, so that once we have them all, we attach them to the features
                            var nReturned = 0;
                            // keep track of the number of results which gave error.
                            var nError = 0;
                            // Flag if something bad has happened
                            var failed = false;
                            for (var i = 0; i < dataLinks.length; i++) {
                                // No need to continue processing results if we're already in a failed state.
                                if (failed) {
                                    break;
                                }
                                // This returns a completed function that is dependant on the index, since the order of the data links is important
                                var indexDependantCompleteFunction = function (dataLinkIndex) {
                                    return function (results) {
                                        // do nothing if we're in a failed state
                                        if (failed) {
                                            return;
                                        }
                                        // Collect the results
                                        resultsCollection[dataLinkIndex] = results;
                                        nReturned++;
                                        // Wait on all the results to process
                                        if (nReturned >= dataLinks.length) {
                                            // Apply the datalinks with the given featureSet, datalinks and results collection
                                            _this._applyDataLinks(featureSet, features_1, dataLinks, resultsCollection, onDataLinkAddedToFeature);
                                            // Signal that datalinks were resolved
                                            featureSet.setDataLinksState(DataLinksState.Resolved);
                                            // Send resolved datalinks event
                                            if (typeof _this.app !== "undefined") {
                                                for (var i = 0; i < dataLinks.length; i++) {
                                                    _this.app.event("DatalinkResolutionCompletedEvent").publish(dataLinks[i].id, featureSet);
                                                }
                                            }
                                            if (onDataLinkingComplete) {
                                                onDataLinkingComplete(featureSet, userState);
                                            }
                                        }
                                    };
                                };
                                // This creates a copy of the completed function with the current index
                                var dataLinkingComplete = indexDependantCompleteFunction(i);
                                // something happened behind the scenes with part of the data linking operation
                                // Note the operation has failed and call error handler
                                var indexDependantErrorFunction = function (dataLinkingIndex) {
                                    return function (error) {
                                        // GVH - 6878 Make sure that we abort datalink processing only if all datalinks associated with a layer give error.
                                        nError++;
                                        if (nError >= dataLinks.length) {
                                            console.error("There was an error in resolving {0} datalink. Message : {1}".format(dataLinks[dataLinkingIndex].displayName, error.message));
                                            failed = true;
                                            featureSet.setDataLinksState(DataLinksState.Unresolved);
                                            if (onDataLinkingFailed) {
                                                onDataLinkingFailed(featureSet, error, userState);
                                            }
                                        }
                                        else {
                                            console.error("There was an error in resolving {0} datalink. Message : {1}".format(dataLinks[dataLinkingIndex].displayName, error.message));
                                            //     Just sending an empty DataLinkingResult.
                                            indexDependantCompleteFunction(dataLinkingIndex)(new infrastructure.DataLinkingResult());
                                        }
                                    };
                                };
                                // This creates a copy of the error function with the current index.
                                var dataLinkingFailed = indexDependantErrorFunction(i);
                                // Send datalink resolution started event
                                if (typeof this.app !== "undefined") {
                                    this.app.event("DatalinkResolutionStartedEvent").publish(dataLinks[i].id, featureSet);
                                }
                                // Perform the data linking for each data link
                                dataLinks[i].performDataLinking(featureSet.esriFeatureSet, dataLinkingComplete, dataLinkingFailed);
                            }
                        }
                        else {
                            // Signal that datalinks were resolved
                            featureSet.setDataLinksState(DataLinksState.Resolved);
                            if (onDataLinkingComplete) {
                                onDataLinkingComplete(featureSet, userState);
                            }
                        }
                    };
                    /**
                     * Executes the specified callback function when the datalinking operation is completed, or immediately if the
                     * datalinks are already resolved.
                     * @param callback The callback function to execute when the datalinks are resolved.
                     */
                    FeatureSet.prototype.doWhenDataLinkingCompleted = function (callback) {
                        var _this = this;
                        if (typeof callback === "function") {
                            if (this.dataLinksResolved.get()) {
                                callback(this);
                            }
                            else {
                                var token = this.dataLinksResolved.bind(this, function (value) {
                                    if (value) {
                                        _this.dataLinksResolved.unbind(token);
                                        callback(_this);
                                    }
                                });
                            }
                        }
                    };
                    /**
                     * Adds only those features to the feature set that are not already part of the feature set.
                     */
                    FeatureSet.prototype.append = function (featureSet) {
                        // Add all the primary keys to a lookup table
                        var featureLookUp = new Object();
                        for (var i = 0; i < this.features.length(); i++) {
                            var feature = this.features.getAt(i);
                            var primaryKeyFieldName;
                            if (this.layer && this.layer.primaryKeyField) {
                                primaryKeyFieldName = this.layer.primaryKeyField.name;
                            }
                            if (primaryKeyFieldName) {
                                var primaryKeyValue = feature.esriFeature.get().attributes[primaryKeyFieldName];
                                featureLookUp[primaryKeyValue] = feature;
                            }
                        }
                        // Add the feature if it hasn't already been added
                        for (var i = 0; i < featureSet.features.length(); i++) {
                            var feature = featureSet.features.getAt(i);
                            var primaryKeyFieldName;
                            if (featureSet.layer && featureSet.layer.primaryKeyField) {
                                primaryKeyFieldName = featureSet.layer.primaryKeyField.name;
                            }
                            if (primaryKeyFieldName) {
                                var primaryKeyValue = feature.esriFeature.get().attributes[primaryKeyFieldName];
                                if (!featureLookUp[primaryKeyValue]) {
                                    this.features.addItem(feature);
                                }
                            }
                            else {
                                // To do, at some point, fall back to another way of checking for equality?
                                this.features.addItem(feature);
                            }
                        }
                    };
                    /**
                     * Creates a new feature set that contains all elements that are present in either the current set or in the specified feature set.
                     * @param other The feature set to add elements from.
                     * @return A new feature set with the items added; or a copy of the original set if all the items were already in the set.
                     */
                    FeatureSet.prototype.union = function (other) {
                        var union = this.clone();
                        var len = other && other.features ? other.features.length() : 0;
                        for (var i = 0; i < len; i++) {
                            if (!union.containsFeature(other.features.getAt(i))) {
                                // Union already checks for duplicates. Bypass the duplicate check when calling "addFeature"
                                union.addFeature(other.features.getAt(i), true);
                            }
                        }
                        return union;
                    };
                    /**
                     * Modifies the current set to produce the set union of two sequences of {@link Feature}s by using the default equality comparer.
                     * In other words, it adds all of the elements in the second set to this set if they're not already present.
                     * @param other Set containing elements to be added to this set.
                     * @return `true` if this set changed as a result of the call; `false` otherwise.
                     */
                    FeatureSet.prototype.unionInPlace = function (other) {
                        if (!other || !other.features || other.features.length() === 0) {
                            return false;
                        }
                        var args = new geocortex.framework.events.CollectionChangedArgs();
                        args.type = "append";
                        args.rangeStart = this.features.length();
                        // A union B => add elements to this set if they haven't been added already.
                        var modified = false;
                        var itemsAdded = 0;
                        for (var i = 0; i < other.features.length(); i++) {
                            var f = other.features.getAt(i);
                            if (!this.containsFeature(f)) {
                                // Union already checks for duplicates. Bypass the duplicate check when calling "addFeature"
                                if (this._addFeatureWithoutNotification(f, true)) {
                                    modified = true;
                                    itemsAdded++;
                                }
                            }
                        }
                        // We want to publish a single change event for the whole union operation instead of multiple "append" events.
                        // Multiple change events fired in quick succession degrade performance and cause GVH-9088
                        if (modified) {
                            args.rangeEnd = args.rangeStart + itemsAdded - 1; // Inclusive range indices
                            args.sender = this.features;
                            this.features.bindingEvent.publish(args);
                        }
                        return modified;
                    };
                    /**
                     * Creates a new feature set that contains elements of the current set that do not appear in the second set.
                     * @param other The feature set whose elements that also occur in the first set will cause those elements to be removed from the returned set.
                     * @return A new feature set that contains the set difference of the elements of two sets.
                     */
                    FeatureSet.prototype.subtract = function (other) {
                        var result = this.cloneStructure();
                        for (var i = 0; other != null && i < this.features.length(); i++) {
                            if (!other.containsFeature(this.features.getAt(i))) {
                                result.addFeature(this.features.getAt(i));
                            }
                        }
                        return result;
                    };
                    /**
                     * Modifies the current set to produce the set difference of two sequences of {@link Feature}s by using the default equality comparer to compare values.
                     * The set difference of two sets is defined as the elements of the first set that do not appear in the second set.
                     * Note: This method modifies this set to only keep those elements that do not appear in the second set. It does not also include those elements in the second set that do not appear in this set.
                     * @param other Set containing elements to be removed from this set.
                     * @return `true` if this set changed as a result of the call; `false` otherwise.
                     */
                    FeatureSet.prototype.subtractInPlace = function (other) {
                        if (!other || !other.features || other.features.length() === 0) {
                            return false;
                        }
                        // A - B => remove all elements in this set that are also in the provided feature set.
                        var modified = false;
                        var i = this.features.length();
                        while (i--) {
                            var f = this.features.getAt(i);
                            if (other.containsFeature(f)) {
                                this._removeWithoutNotificationAt(i);
                                modified = true;
                            }
                        }
                        // We want to publish a single change event for the whole subtract operation instead of multiple "remove" events.
                        // Multiple change events fired in quick succession degrade performance and cause GVH-9088
                        if (modified) {
                            this.features.pulse();
                        }
                        return modified;
                    };
                    /**
                     * Creates a new feature set that contains elements that exist in both this set and the specified set.
                     * @param other The feature set to compare to the current set.
                     * @return A new feature set that contains any elements that exist in both sets.
                     */
                    FeatureSet.prototype.intersect = function (other) {
                        var result = this.cloneStructure();
                        for (var i = 0; other != null && i < this.features.length(); i++) {
                            if (other.containsFeature(this.features.getAt(i))) {
                                result.addFeature(this.features.getAt(i));
                            }
                        }
                        return result;
                    };
                    /**
                     * Modifies the current set to produce the set intersection of two sequences of {@link Feature}s by using the default equality comparer to compare values.
                     * The intersection of two sets A and B is defined as the set that contains all the elements of A that also appear in B, but no other elements.
                     * @param other Set containing elements to be retained in this set.
                     * @return `true` if this set changed as a result of the call; `false` otherwise.
                     */
                    FeatureSet.prototype.intersectInPlace = function (other) {
                        if (!other || !other.features) {
                            return false;
                        }
                        // A intersect B => remove from this set all of its elements that are not contained in the provided feature set.
                        var modified = false;
                        var i = this.features.length();
                        while (i--) {
                            var f = this.features.getAt(i);
                            if (!other.containsFeature(f)) {
                                this._removeWithoutNotificationAt(i);
                                modified = true;
                            }
                        }
                        // We want to publish a single change event for the whole intersect operation instead of multiple "remove" events.
                        // Multiple change events fired in quick succession degrade performance and cause GVH-9088
                        if (modified) {
                            this.features.pulse();
                        }
                        return modified;
                    };
                    /**
                     * Performs a shallow copy of this FeatureSet, returning the cloned value.
                     */
                    FeatureSet.prototype.clone = function () {
                        // Copy features over to the cloned FeatureSet.
                        // NOTE: Features are copied by reference; i.e they are the same (not new cloned values). Cloning features with potentially large geometries can be quite expensive.
                        // NOTE: Features have a reference to their parent FeatureSet. That reference will be updated to point to the clone.
                        var copy = this.cloneStructure();
                        // At this point the cloned feature set is empty and we need to copy all features. 
                        // Avoid checking for duplicates (which is expensive) because we know the set being populated was empty to begin with.
                        for (var i = 0; i < this.features.length(); i++) {
                            copy.addFeature(this.features.getAt(i), true);
                        }
                        return copy;
                    };
                    /**
                     * Given a FeatureSet, creates a new empty one just like the original (same layer, name etc)
                     * Note: This method will not copy the features within the original FeatureSet.
                     */
                    FeatureSet.prototype.cloneStructure = function () {
                        var copy = new FeatureSet({
                            app: this.app,
                            layer: this.layer,
                            featureLayer: this.featureLayer,
                            allowUnsafeContent: this._allowUnsafeContent,
                            defaultDateFormat: this.defaultDateFormat,
                            defaultNumberFormat: this.defaultNumberFormat
                        });
                        copy.id = this.id;
                        copy.isSelectedInCollection.set(this.isSelectedInCollection.get());
                        copy.setDataLinksState(this.dataLinksState);
                        // GVH-9542 Lazy observables should be cloned as well
                        copy.displayName.set(this.displayName.get());
                        copy.iconUri.set(this.iconUri.get());
                        // Clone the attributes collection
                        copy.attributes.set(this.attributes.get());
                        // Clone the properties collection
                        copy.extendedProperties.set(this.extendedProperties.get());
                        // Create an empty Esri feature set like the original (same name, geometry type etc). However, no features will be copied over.
                        copy.esriFeatureSet = this._cloneEsriStructure(this.esriFeatureSet);
                        return copy;
                    };
                    FeatureSet.prototype._cloneEsriStructure = function (esriFeatureSet) {
                        if (!esriFeatureSet) {
                            return null;
                        }
                        var clone = new esri.tasks.FeatureSet();
                        clone.displayFieldName = esriFeatureSet.displayFieldName;
                        clone.exceededTransferLimit = esriFeatureSet.exceededTransferLimit;
                        clone.fieldAliases = esriFeatureSet.fieldAliases;
                        clone.geometryType = esriFeatureSet.geometryType;
                        clone.spatialReference = esriFeatureSet.spatialReference;
                        // Undocumented "fields" property
                        if (esriFeatureSet.fields) {
                            clone.fields = esriFeatureSet.fields;
                        }
                        return clone;
                    };
                    FeatureSet.prototype._watchFeatureSetChanges = function () {
                        var _this = this;
                        // Destroy any previous bound handler
                        this._unwatchFeatureSetChanges();
                        // Watch for changes
                        var token = this.features.bind(this, this.featureSetChanged);
                        var handle = {
                            remove: function () { return _this.features.unbind(token); }
                        };
                        this._watchHandles.features = handle;
                        return handle;
                    };
                    FeatureSet.prototype._unwatchFeatureSetChanges = function () {
                        var handle = this._watchHandles.features;
                        if (handle) {
                            handle.remove();
                        }
                        this._watchHandles.features = null;
                    };
                    return FeatureSet;
                }());
                infrastructure.FeatureSet = FeatureSet;
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../_Definitions/framework.d.ts"/>
/// <reference path="./FeatureSet.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var FeatureSetCollection = (function () {
                    /**
                     * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} class.
                     * @class
                     * <p>Represents a Geocortex Essentials FeatureSetCollection.</p>
                     * @constructs
                     * @memberOf geocortex.essentialsHtmlViewer.mapping.infrastructure
                     */
                    function FeatureSetCollection() {
                        /**
                         * The displayName for the feature set collection.
                         * @type String
                         */
                        this.displayName = new Observable("");
                        /**
                         * Whether the feature set collection has been modified.
                         */
                        this.isModified = new Observable(false);
                        /**
                         * The collection of feature set objects constituting the collection.
                         * @type ObservableCollection<FeatureSet>
                         */
                        this.featureSets = new ObservableCollection();
                        /**
                         * The extended collection for the feature set collection.
                         * @type Array
                         */
                        this.extendedProperties = new ObservableCollection();
                        this.id = "FSC-{0}".format(geocortex.framework.utils.alphaNumericToken());
                        this.featureSets.useThrottling = false; // Should not be set to true until GVH-1044 is resolved
                    }
                    /**
                     * Finds the extended property matching the specified name.
                     * @param name The name of the property to find.
                     */
                    FeatureSetCollection.prototype.getExtendedPropertyByName = function (name) {
                        for (var i = 0; i < this.extendedProperties.getLength(); i++) {
                            var prop = this.extendedProperties.getAt(i);
                            if (prop && prop.name == name) {
                                return prop.value;
                            }
                        }
                        return null;
                    };
                    /**
                     * Sets the extended property matching the specified name.
                     * @param name The name of the property to update.
                     * @param value The property value.
                     */
                    FeatureSetCollection.prototype.setExtendedProperty = function (name, value) {
                        for (var i = 0; i < this.extendedProperties.getLength(); i++) {
                            var prop = this.extendedProperties.getAt(i);
                            if (prop && prop.name == name) {
                                prop.value = value;
                                return;
                            }
                        }
                        // Property not found - add it to the collection
                        this.extendedProperties.addItem({ name: name, value: value });
                    };
                    /**
                     * Returns the FeatureSet having the specified ID, or null if none exists.
                     * @param id The id of the FeatureSet to return.
                     * @return FeatureSet The FeatureSet with the specified ID.
                     */
                    FeatureSetCollection.prototype.getFeatureSetById = function (id) {
                        for (var featureSetIndex = 0; featureSetIndex < this.featureSets.getLength(); ++featureSetIndex) {
                            var featureSet = this.featureSets.getAt(featureSetIndex);
                            if (featureSet.id == id) {
                                return featureSet;
                            }
                        }
                        return null;
                    };
                    /**
                     * Returns the FeatureSet having the specified {@link geocortex.essentials.Layer}, or null if none exists.
                     * @param layer The Geocortex Layer of the FeatureSet to return.
                     * @return FeatureSet The FeatureSet found, if any.
                     */
                    FeatureSetCollection.prototype.getFeatureSetByLayer = function (layer) {
                        if (!layer) {
                            return null;
                        }
                        for (var featureSetIndex = 0; featureSetIndex < this.featureSets.getLength(); ++featureSetIndex) {
                            var fs = this.featureSets.getAt(featureSetIndex);
                            var fsLayer = fs.layer;
                            // Check layer id's
                            var layerIdsEqual = (layer === fsLayer) || (layer && fsLayer && layer.id == fsLayer.id);
                            // Check map service id's
                            var mapserviceIdsEqual = (layer === fsLayer)
                                || (layer && fsLayer && layer.mapService === fsLayer.mapService)
                                || (layer && fsLayer && layer.mapService && fsLayer.mapService && layer.mapService.id == fsLayer.mapService.id);
                            if (layerIdsEqual && mapserviceIdsEqual) {
                                return fs;
                            }
                        }
                        return null;
                    };
                    /**
                     * Searches all contained feature sets for a Geocortex feature corresponding to the specified ESRI feature, and returns it if found.
                     * There is an inherent assumption here that a Geocortex feature instance will be unique among all feature sets in a feature set collection.
                     * @param esriFeature The esri graphic for which the corresponding Geocortex feature needs to be retrieved.
                     * @return The Geocortex feature corresponding to the given ESRI feature, if it exists, or null.
                     */
                    FeatureSetCollection.prototype.findFeatureByEsriFeature = function (esriFeature) {
                        for (var featureSetIndex = 0; featureSetIndex < this.featureSets.getLength(); featureSetIndex++) {
                            var feature = this.featureSets.getAt(featureSetIndex).findFeatureByEsriFeature(esriFeature);
                            if (feature) {
                                return feature;
                            }
                        }
                        return null;
                    };
                    /**
                     * Returns the first Feature of the first FeatureSet, or null if none exists.
                     * @return Feature The first Feature in the collection.
                     */
                    FeatureSetCollection.prototype.firstFeature = function () {
                        for (var i = 0; i < this.featureSets.getLength(); i++) {
                            var featureSet = this.featureSets.getAt(i);
                            if (featureSet.features.getLength() > 0) {
                                return featureSet.features.getAt(0);
                            }
                        }
                        return null;
                    };
                    /**
                     * Get the number of features contained in all feature sets in this collection.
                     */
                    FeatureSetCollection.prototype.countFeatures = function () {
                        var featureCount = 0;
                        for (var fsIx = 0; fsIx < this.featureSets.length(); fsIx++) {
                            featureCount += this.featureSets.getAt(fsIx).features.length();
                        }
                        return featureCount;
                    };
                    /**
                     * Clears the feature collection within each FeatureSet, before clearing the FeatureSet collection.
                     */
                    FeatureSetCollection.prototype.clear = function () {
                        for (var i = 0; i < this.featureSets.getLength(); i++) {
                            var featureSet = this.featureSets.getAt(i);
                            featureSet.features.clear();
                        }
                        this.featureSets.clear();
                    };
                    /**
                     * Performs a shallow copy of this FeatureSetCollection, returning the cloned value.
                     * @param deepCopy Whether to clone the FeatureSets belonging to this collection. Defaults to `false`
                     */
                    FeatureSetCollection.prototype.clone = function (deepCopy) {
                        if (deepCopy === void 0) { deepCopy = false; }
                        var copy = this.cloneStructure();
                        for (var i = 0; i < this.featureSets.length(); i++) {
                            var newFs = deepCopy ? this.featureSets.getAt(i).clone() : this.featureSets.getAt(i);
                            copy.featureSets.addItem(newFs);
                        }
                        return copy;
                    };
                    /**
                     * Given a FeatureSetCollection, creates a new empty one just like the original (same layer, name etc)
                     * Note: This method will not copy the feature sets within the original collection.
                     */
                    FeatureSetCollection.prototype.cloneStructure = function () {
                        var copy = new infrastructure.FeatureSetCollection();
                        copy.sourceName = this.sourceName;
                        copy.displayName.set(this.displayName.get());
                        copy.isModified.set(this.isModified.get());
                        copy.tag = this.tag;
                        // Copy extended properties
                        this.extendedProperties.getItems().forEach(function (prop) { return copy.setExtendedProperty(prop.name, prop.value); });
                        return copy;
                    };
                    /**
                     * Produces the set union of two sequences of {@link Feature}s by using the default equality comparer.
                     * In other words, it adds all of the elements in the second set to this set if they're not already present.
                     * @param fsc Set containing elements to be added to this set.
                     * @return `true` if this set changed as a result of the call; `false` otherwise.
                     */
                    FeatureSetCollection.prototype.unionInPlace = function (other) {
                        if (!other || other.featureSets.length() === 0) {
                            return false;
                        }
                        // Optimization: Use lookup tables to find matching FeatureSets instead of looping multiple times.
                        var idLookup = this._buildFeatureSetLookup();
                        var layerLookup = this._buildLayerLookup();
                        // A union B => add elements to this set if they haven't been added already.
                        var modified = false;
                        for (var i = 0; i < other.featureSets.length(); i++) {
                            // Find matching feature set, then add the feature
                            var newFs = other.featureSets.getAt(i);
                            var idToMatch = newFs.id;
                            var layerToMatch = newFs.layer;
                            var existingSet = null;
                            if (idToMatch && idLookup.containsKey(idToMatch)) {
                                existingSet = idLookup.get(idToMatch);
                            }
                            if (!existingSet && layerToMatch && layerToMatch.mapService) {
                                var key = this._generateLayerKey(layerToMatch.mapService.id, layerToMatch.id);
                                existingSet = layerLookup.get(key);
                            }
                            if (!existingSet) {
                                this.featureSets.addItem(newFs);
                                modified = true;
                            }
                            else {
                                // A matching set was found...
                                if (existingSet.unionInPlace(newFs)) {
                                    modified = true;
                                }
                            }
                        }
                        return modified;
                    };
                    FeatureSetCollection.prototype.unionManyInPlace = function (collections) {
                        if (!collections || collections.length == 0) {
                            return false;
                        }
                        var modified = false;
                        for (var i = 0; i < collections.length; i++) {
                            if (this.unionInPlace(collections[i])) {
                                modified = true;
                            }
                        }
                        return modified;
                    };
                    /**
                     * Produces the set difference of two sequences of {@link Feature}s by using the default equality comparer to compare values.
                     * The set difference of two sets is defined as the members of the first set that do not appear in the second set.
                     * Note: This method modifies this set to only keep those elements that do not appear in the second set. It does not also include those elements in the second set that do not appear in this set.
                     * @param featureSet Set containing elements to be removed from this set.
                     * @return `true` if this set changed as a result of the call; `false` otherwise.
                     */
                    FeatureSetCollection.prototype.subtractInPlace = function (other) {
                        if (!other || other.featureSets.length() === 0) {
                            return false;
                        }
                        // Optimization: Use lookup tables to find matching FeatureSets instead of looping multiple times.
                        var idLookup = other._buildFeatureSetLookup();
                        var layerLookup = other._buildLayerLookup();
                        // A - B => remove all elements in this set that are also in the provided feature set.
                        var modified = false;
                        var i = this.featureSets.length();
                        while (i--) {
                            var fs = this.featureSets.getAt(i);
                            var idToMatch = fs.id;
                            var layerToMatch = fs.layer;
                            var existingSet = null;
                            if (idToMatch && idLookup.containsKey(idToMatch)) {
                                existingSet = idLookup.get(idToMatch);
                            }
                            if (!existingSet && layerToMatch && layerToMatch.mapService) {
                                var key = this._generateLayerKey(layerToMatch.mapService.id, layerToMatch.id);
                                existingSet = layerLookup.get(key);
                            }
                            if (existingSet) {
                                // A matching set was found...
                                if (fs.subtractInPlace(existingSet)) {
                                    modified = true;
                                }
                                // Discard empty sets
                                if (fs.features.length() == 0) {
                                    this.featureSets.removeAt(i);
                                    modified = true;
                                }
                            }
                        }
                        return modified;
                    };
                    FeatureSetCollection.prototype.subtractManyInPlace = function (collections) {
                        if (!collections || collections.length == 0) {
                            return false;
                        }
                        var modified = false;
                        for (var i = 0; i < collections.length; i++) {
                            if (this.subtractInPlace(collections[i])) {
                                modified = true;
                            }
                        }
                        return modified;
                    };
                    /**
                     * Produces the set intersection of two sequences of {@link Feature}s by using the default equality comparer to compare values.
                     * The intersection of two sets A and B is defined as the set that contains all the elements of A that also appear in B, but no other elements.
                     * @param featureSet Set containing elements to be retained in this set.
                     * @return `true` if this set changed as a result of the call; `false` otherwise.
                     */
                    FeatureSetCollection.prototype.intersectInPlace = function (other) {
                        if (!other) {
                            return false;
                        }
                        // Optimization: Use lookup tables to find matching FeatureSets instead of looping multiple times.
                        var idLookup = other._buildFeatureSetLookup();
                        var layerLookup = other._buildLayerLookup();
                        // A intersect B => remove from this set all of its elements that are not contained in the provided feature set.
                        var modified = false;
                        var i = this.featureSets.length();
                        while (i--) {
                            var fs = this.featureSets.getAt(i);
                            var idToMatch = fs.id;
                            var layerToMatch = fs.layer;
                            var existingSet = null;
                            if (idToMatch && idLookup.containsKey(idToMatch)) {
                                existingSet = idLookup.get(idToMatch);
                            }
                            if (!existingSet && layerToMatch && layerToMatch.mapService) {
                                var key = this._generateLayerKey(layerToMatch.mapService.id, layerToMatch.id);
                                existingSet = layerLookup.get(key);
                            }
                            if (!existingSet) {
                                this.featureSets.removeAt(i);
                                modified = true;
                            }
                            else {
                                // A matching set was found...
                                if (fs.intersectInPlace(existingSet)) {
                                    modified = true;
                                }
                                // Discard empty sets
                                if (fs.features.length() == 0) {
                                    this.featureSets.removeAt(i);
                                    modified = true;
                                }
                            }
                        }
                        return modified;
                    };
                    FeatureSetCollection.prototype.intersectManyInPlace = function (collections) {
                        if (!collections || collections.length == 0) {
                            return false;
                        }
                        var modified = false;
                        for (var i = 0; i < collections.length; i++) {
                            if (this.intersectInPlace(collections[i])) {
                                modified = true;
                            }
                        }
                        return modified;
                    };
                    FeatureSetCollection.prototype._generateLayerKey = function (mapServiceId, layerId) {
                        return "{0}/{1}".format(mapServiceId, layerId);
                    };
                    FeatureSetCollection.prototype._buildLayerLookup = function () {
                        var layerLookup = new infrastructure.Dictionary();
                        for (var i = 0; i < this.featureSets.length(); i++) {
                            var fs = this.featureSets.getAt(i);
                            if (fs && fs.layer && fs.layer.mapService) {
                                var key = this._generateLayerKey(fs.layer.mapService.id, fs.layer.id);
                                if (!layerLookup.containsKey(key)) {
                                    layerLookup.set(key, fs);
                                }
                            }
                        }
                        return layerLookup;
                    };
                    FeatureSetCollection.prototype._buildFeatureSetLookup = function () {
                        var idLookup = new infrastructure.Dictionary();
                        for (var i = 0; i < this.featureSets.length(); i++) {
                            var fs = this.featureSets.getAt(i);
                            if (fs && fs.id && !idLookup.containsKey(fs.id)) {
                                idLookup.set(fs.id, fs);
                            }
                        }
                        return idLookup;
                    };
                    return FeatureSetCollection;
                }());
                infrastructure.FeatureSetCollection = FeatureSetCollection;
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../FeatureSetCollection.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var eventArgs;
                (function (eventArgs) {
                    var FeatureSetManagerEventArgs = (function () {
                        /**
                         * Initializes a new instance of the {@link FeatureSetManagerEventArgs} class.
                         * @param args An object consisting of 3 members: `sender`, `featureSetCollection`, and `featureSetCollectionId`.
                         */
                        function FeatureSetManagerEventArgs(args) {
                            dojo.safeMixin(this, args);
                        }
                        return FeatureSetManagerEventArgs;
                    }());
                    eventArgs.FeatureSetManagerEventArgs = FeatureSetManagerEventArgs;
                })(eventArgs = infrastructure.eventArgs || (infrastructure.eventArgs = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/**
 * Legacy support.  No new code should use this.
 */
geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetManagerEventArgs = geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.FeatureSetManagerEventArgs;
/// <reference path="../../_Definitions/framework.d.ts"/>
/// <reference path="./FeatureSetCollection.ts"/>
/// <reference path="./eventArgs/FeatureSetManagerEventArgs.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var FeatureSetManager = (function () {
                    /**
                     * Initializes a new instance of an {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetManager} object.
                     * @class
                     * <p>The central clearing-house for all system activities that create and want to expose FeatureSet instances to other areas of the system.</p>
                     * @constructs
                     * @memberOf geocortex.essentialsHtmlViewer.mapping.infrastructure
                     * @param app The {@link geocortex.framework.application.Application} that this module belongs to.
                     */
                    function FeatureSetManager(app) {
                        /**
                         * The feature set collections being managed.
                         * @type FeatureSetCollection[]
                         */
                        this.featureSetCollections = new ObservableCollection();
                        /**
                         * Map of ID -> FSC.
                         * @private
                         */
                        this._featureSetCollectionsMap = {};
                        /**
                         * Map of FSC ID -> event token for the collection changed event.
                         * @private
                         */
                        this._collectionChangedEventMap = {};
                        /**
                         * Map of ID -> Open count.
                         * @private
                         */
                        this._collectionOpenCount = {};
                        /**
                         * Map of FSC source name -> search suggestion.
                         */
                        this._searchSuggestions = {};
                        this.app = app;
                        this._registerCommands();
                    }
                    /** @private Registers some view-related commands. */
                    FeatureSetManager.prototype._registerCommands = function () {
                        this.app.command("OpenFeatureSetCollection").register(this, this.openCollection);
                        this.app.command("CloseFeatureSetCollection").register(this, this.closeCollection);
                        // Deprecated as of 1.2. Please use RemoveFeatureSetCollection
                        this.app.command("RemoveCollection").register(this, this.removeCollection);
                        this.app.command("RemoveFeatureSetCollection").register(this, this.removeCollection);
                        // Deprecated as of 1.2. Please use RemoveFeatureSetCollection
                        this.app.command("RemoveCollectionById").register(this, this.removeCollectionById);
                        this.app.command("RemoveFeatureSetCollectionById").register(this, this.removeCollectionById);
                    };
                    /**
                     * Opens the specified collection.
                     * Opening and closing a feature set collection does not actually change the behavior of the collection.  It is
                     * used internally to keep track of multiple clients concurrently accessing a collection for the purposes of raising an event
                     * when the collection is first opened and finally closed.
                     * @param id The ID of the collection to open.
                     * @return FeatureSetCollection The opened FeatureSetCollection for the id specified, or null if the FeatureSetCollection does not exist or could not be opened.
                     */
                    FeatureSetManager.prototype.openCollection = function (id) {
                        if (!this._featureSetCollectionsMap.hasOwnProperty(id)) {
                            this.app.trace.warning("Cannot open feature set collection '{0}': No feature set collection with matching ID found.".format(id));
                            return null;
                        }
                        // If we're not already counting opens on this FSC, start.
                        if (!this._collectionOpenCount.hasOwnProperty(id)) {
                            this._collectionOpenCount[id] = 0;
                        }
                        ++this._collectionOpenCount[id];
                        // If the collection was previously closed (or never opened), raise the opened event.
                        if (this._collectionOpenCount[id] == 1) {
                            // Broadcast that this feature set was opened, and any other important info.
                            var fsc = this._featureSetCollectionsMap[id];
                            var args = new geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.FeatureSetManagerEventArgs({
                                sender: this,
                                featureSetCollection: fsc,
                                featureSetCollectionId: id
                            });
                            this.app.event("FSMCollectionOpenedEvent").publish(args);
                        }
                        return this._featureSetCollectionsMap[id];
                    };
                    /**
                     * Closes the specified collection.
                     * Opening and closing a feature set collection does not actually change the behavior of the collection.  It is
                     * used internally to keep track of multiple clients concurrently accessing a collection for the purposes of raising an event
                     * when the collection is first opened and finally closed.
                     * @param id The ID of the collection to close.
                     * @return Boolean True if the collection was successfully closed, False otherwise.
                     */
                    FeatureSetManager.prototype.closeCollection = function (id) {
                        if (!this._featureSetCollectionsMap.hasOwnProperty(id)) {
                            this.app.trace.warning("Cannot close feature set collection '{0}': No feature set collection with matching ID found.".format(id));
                            return false;
                        }
                        if (!this._collectionOpenCount.hasOwnProperty(id) || this._collectionOpenCount[id] == 0) {
                            this.app.trace.warning("Attempted to close an already-closed FeatureSetCollection.");
                            return false;
                        }
                        --this._collectionOpenCount[id];
                        // Raise a closed event if needed.
                        if (this._collectionOpenCount[id] == 0) {
                            // Broadcast that this feature set was opened, and any other important info.
                            var args = new geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.FeatureSetManagerEventArgs({
                                sender: this,
                                featureSetCollection: this._featureSetCollectionsMap[id],
                                featureSetCollectionId: id
                            });
                            this.app.event("FSMCollectionClosedEvent").publish(args);
                        }
                        return true;
                    };
                    /**
                     * Closes the specified collection if it's open.
                     * Opening and closing a feature set collection does not actually change the behavior of the collection.  It is
                     * used internally to keep track of multiple clients concurrently accessing a collection for the purposes of raising an event
                     * when the collection is first opened and finally closed.
                     * @param id The ID of the collection to close.
                     * @return Boolean True if the collection was successfully closed (or is already closed), False otherwise.
                     */
                    FeatureSetManager.prototype.tryCloseCollection = function (id) {
                        // No feature set collection with matching ID found
                        if (!this._featureSetCollectionsMap.hasOwnProperty(id)) {
                            return false;
                        }
                        if (this.isCollectionOpen(id)) {
                            return this.closeCollection(id);
                        }
                        else {
                            return true;
                        }
                    };
                    /**
                     * Determines whether the specified collection is open.
                     * @param id The ID of the collection to open.
                     * @returns Boolean True if the collection is open, False otherwise.
                     */
                    FeatureSetManager.prototype.isCollectionOpen = function (id) {
                        if (!this._featureSetCollectionsMap.hasOwnProperty(id)) {
                            this.app.trace.warning("Cannot check open state of feature set collection '{0}': No feature set collection with matching ID found.".format(id));
                            return false;
                        }
                        return (this._collectionOpenCount.hasOwnProperty(id) && this._collectionOpenCount[id] > 0);
                    };
                    /**
                     * Adds the specified collection to the feature set manager.
                     * @param fsc The FeatureSetCollection to add.
                     * @return Boolean, True if the operation was successful, false otherwise.
                     */
                    FeatureSetManager.prototype.addCollection = function (fsc) {
                        return this._addCollectionImpl(fsc);
                    };
                    /**
                     * Adds the specified collection to the feature set manager.
                     * @param fsc The FeatureSetCollection to add.
                     * @return Boolean, True if the operation was successful, false otherwise.
                     * @private
                     */
                    FeatureSetManager.prototype._addCollectionImpl = function (fsc) {
                        if (!fsc) {
                            throw new Error("FeatureSetManager.addCollection: Parameter 'fsc' required.");
                        }
                        var existingFsc = this._featureSetCollectionsMap[fsc.id];
                        if (fsc === existingFsc) {
                            return true;
                        }
                        else if (existingFsc) {
                            this.app.trace.warning("Cannot add feature set collection '{0}': A feature set collection with that ID already exists.".format(fsc.id));
                            return false;
                        }
                        this._featureSetCollectionsMap[fsc.id] = fsc;
                        this.featureSetCollections.addItem(fsc);
                        // Bind to this collection so we can broker CollectionChanged events on its behalf.
                        var token = fsc.featureSets.bind(this, dojo.hitch(this, function (arg) {
                            this.handleCollectionChanged(fsc, arg);
                        }));
                        // Keep a subscription token in the map so we can unsubscribe later.
                        this._collectionChangedEventMap[fsc.id] = token;
                        // Broadcast.
                        var args = new geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.FeatureSetManagerEventArgs({
                            sender: this,
                            featureSetCollection: this._featureSetCollectionsMap[fsc.id],
                            featureSetCollectionId: fsc.id
                        });
                        this.app.event("FSMCollectionAddedEvent").publish(args);
                        return true;
                    };
                    /**
                     * Raises an event when a feature set collection is changed in feature set manager
                     * @param args
                     */
                    FeatureSetManager.prototype.handleCollectionChanged = function (fsc, args) {
                        // TODO: Check and warn if collection is not open?
                        // Broadcast.
                        var eventPayload = new geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.FeatureSetManagerEventArgs({
                            sender: this,
                            featureSetCollection: fsc,
                            featureSetCollectionId: fsc.id,
                            collectionChangedEventArgs: args
                        });
                        this.app.event("FSMCollectionChangedEvent").publish(eventPayload);
                    };
                    /**
                     * Removes the specified collection from the feature set manager.
                     * @param fsc The FeatureSetCollection to remove.
                     * @return Boolean, True if the operation was successful, false otherwise.
                     */
                    FeatureSetManager.prototype.removeCollection = function (fsc) {
                        if (this.canRemoveCollection(fsc)) {
                            return this.removeCollectionById(fsc.id);
                        }
                        return false;
                    };
                    /**
                     * Removes the specified collection from the feature set manager.
                     * @param id The ID of the FeatureSetCollection to remove.
                     * @return Boolean, True if the operation was successful, false otherwise.
                     */
                    FeatureSetManager.prototype.removeCollectionById = function (id) {
                        // Does it even exist in the FSM?
                        if (!this._featureSetCollectionsMap.hasOwnProperty(id)) {
                            this.app.trace.warning("Cannot remove feature set collection '{0}': Collection not found.".format(id));
                            return false;
                        }
                        // If the collection is open, close it
                        if (this.isCollectionOpen(id)) {
                            this.closeCollection(id);
                        }
                        var fsc = this._featureSetCollectionsMap[id];
                        // When we bound to this collection, we stored a token in a map. Unbind.
                        var token = this._collectionChangedEventMap[id];
                        fsc.featureSets.unbind(token);
                        this.featureSetCollections.removeItem(this._featureSetCollectionsMap[id]);
                        delete this._collectionOpenCount[id];
                        // Broadcast.
                        var args = new geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.FeatureSetManagerEventArgs({
                            sender: this,
                            featureSetCollection: this._featureSetCollectionsMap[id],
                            featureSetCollectionId: id
                        });
                        this.app.event("FSMCollectionRemovedEvent").publish(args);
                        // TODO: These recycled args have a "featureSetCollection" property set to the removed FSC...confusing to the receiver maybe? shouldn't it be the new collection?
                        delete this._featureSetCollectionsMap[id];
                        return true;
                    };
                    /**
                     * Determine whether the specified FeatureSetCollection can be removed from the manager.
                     * @param fsc The FeatureSetCollection to remove.
                     * @return Boolean, True if the specified FeatureSetCollection is currently managed, false otherwise.
                     */
                    FeatureSetManager.prototype.canRemoveCollection = function (fsc) {
                        return fsc != null && this.getCollectionById(fsc.id) != null;
                    };
                    /**
                     * Gets the specified feature set collection.
                     * @param id The ID of the FeatureSetCollection to retrieve.
                     * @return FeatureSetCollection, The retrieved FeatureSetCollection.
                     */
                    FeatureSetManager.prototype.getCollectionById = function (id) {
                        return this._featureSetCollectionsMap[id];
                    };
                    /**
                     * Get all feature collection ids managed by this class.
                     */
                    FeatureSetManager.prototype.getCollectionIds = function () {
                        var ids = [];
                        for (var id in this._featureSetCollectionsMap) {
                            if (this._featureSetCollectionsMap.hasOwnProperty(id)) {
                                ids.push(id);
                            }
                        }
                        return ids;
                    };
                    /**
                     * Searches all contained feature set collections for Geocortex feature(s) corresponding to the specified ESRI feature, and returns all existing instances.
                     * @param esriFeature The esri graphic for which the corresponding Geocortex feature(s) needs to be retrieved.
                     * @return The array Geocortex features corresponding to the given ESRI feature, if they exist, or an empty array.
                     */
                    FeatureSetManager.prototype.findFeaturesByEsriFeature = function (esriFeature) {
                        var featureArr = [];
                        this.featureSetCollections.get().forEach(function (fsColl) {
                            var feature = fsColl.findFeatureByEsriFeature(esriFeature);
                            if (feature) {
                                featureArr.push(feature);
                            }
                        });
                        return featureArr;
                    };
                    /**
                     * Adds the specified search suggestions to the feature set manager.
                     * @param searchSuggestions The object containing a map of FSC source name -> search suggestion.
                     */
                    FeatureSetManager.prototype.addSearchSuggestions = function (searchSuggestions) {
                        for (var key in searchSuggestions) {
                            if (searchSuggestions.hasOwnProperty(key)) {
                                if (this._searchSuggestions.hasOwnProperty(key)) {
                                    this.app.trace.warning("Cannot add search suggestion '{0}': A search suggestion for that feature set type already exists.".format(searchSuggestions[key]));
                                    continue;
                                }
                                if (searchSuggestions[key]) {
                                    this._searchSuggestions[key] = searchSuggestions[key];
                                }
                            }
                        }
                    };
                    /**
                     * Gets the specified search suggestion.
                     * @param sourceName The source name of the FeatureSetCollection suggestion to retrieve.
                     * @return string The retrieved search suggestion.
                     */
                    FeatureSetManager.prototype.getSearchSuggestion = function (sourceName) {
                        return this._searchSuggestions[sourceName];
                    };
                    return FeatureSetManager;
                }());
                infrastructure.FeatureSetManager = FeatureSetManager;
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../_Definitions/framework.d.ts"/>
/// <reference path="../../_Definitions/dojo.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ColorUtils;
                (function (ColorUtils) {
                    /**
                     * Creates a color with the provided number array representation of the color, or null if one can not be created.
                     * @param {Number[]} colorList A 3 or 4 element list in the order RGB or RGBA.
                     * @returns {dojo.Color} color
                     */
                    function getColorFromList(colorList) {
                        if (colorList && colorList.length === 4) {
                            if (colorList[3] > 1) {
                                colorList[3] = colorList[3] / 255;
                            }
                            return new dojo.Color(colorList);
                        }
                        else {
                            return new dojo.Color(colorList);
                        }
                    }
                    ColorUtils.getColorFromList = getColorFromList;
                    /**
                     * Creates a color with the provided hex string of the color, or null if one can not be created.
                     * @param {String} color A 6 or 8 digit hex in RGB or ARGB form.
                     * @returns {dojo.Color} color
                     */
                    function getColorFromString(color) {
                        // If it looks like an ARGB String, assume that it is one (which it probably is)
                        if (typeof color === "string" && color.startsWith("#") && color.length === 9) {
                            var a = parseInt(color.slice(1, 3), 16);
                            var r = parseInt(color.slice(3, 5), 16);
                            var g = parseInt(color.slice(5, 7), 16);
                            var b = parseInt(color.slice(7, 9), 16);
                            a = a / 255;
                            return new esri.Color([r, g, b, a]);
                        }
                        else {
                            return new esri.Color(color);
                        }
                    }
                    ColorUtils.getColorFromString = getColorFromString;
                    /**
                     * Creates a CSS color string with the provided number array representation of the color.
                     * @param colorList A 3 or 4 element list in the order RGB or RGBA.
                     * @return The CSS color string or null.
                     */
                    function getStringFromList(colorList) {
                        if (!colorList) {
                            return;
                        }
                        if (colorList.length === 4) {
                            if (colorList[3] > 1) {
                                colorList[3] = colorList[3] / 255;
                            }
                            return "rgba({0}, {1}, {2}, {3})".format(colorList[0], colorList[1], colorList[2], colorList[3]);
                        }
                        else if (colorList.length === 3) {
                            return "rgb({0}, {1}, {2})".format(colorList[0], colorList[1], colorList[2]);
                        }
                        return;
                    }
                    ColorUtils.getStringFromList = getStringFromList;
                    /**
                     * Creates a CSS color string with the provided hex string of the color.
                     * @param hexColor The 6 or 8 digit hex string in RGB or ARGB form.
                     * @return The CSS color string or null.
                     */
                    function getStringFromHex(hexColor) {
                        if (typeof hexColor !== "string" || !hexColor.startsWith("#")) {
                            return;
                        }
                        if (hexColor.length === 9) {
                            var a = parseInt(hexColor.slice(1, 3), 16);
                            var r = parseInt(hexColor.slice(3, 5), 16);
                            var g = parseInt(hexColor.slice(5, 7), 16);
                            var b = parseInt(hexColor.slice(7, 9), 16);
                            a = a / 255;
                            return "rgba({0}, {1}, {2}, {3})".format(r, g, b, a);
                        }
                        else if (hexColor.length === 7) {
                            var r = parseInt(hexColor.slice(1, 3), 16);
                            var g = parseInt(hexColor.slice(3, 5), 16);
                            var b = parseInt(hexColor.slice(5, 7), 16);
                            return "rgb({0}, {1}, {2})".format(r, g, b);
                        }
                        return;
                    }
                    ColorUtils.getStringFromHex = getStringFromHex;
                    /**
                     * Generate a selection of random colors that can be used in symbolization.
                     * An attempt has been made to constrain the selection to colors that will 'look good'
                     * while providing the most diverse set of colors possible. Use for up to 12 colors is generally ok.
                     */
                    function generateRandomColors(n) {
                        if (n === void 0) { n = 6; }
                        var colors = [];
                        var startingHue = Math.random();
                        for (var i = 0; i < n; i++) {
                            // Cycle around the color wheel
                            var hue = startingHue + ((1 / n) * i);
                            hue = hue - Math.floor(hue);
                            // A fairly pure, saturated color
                            var color = new infrastructure.visualization.SymbolColor({ h: hue, s: 0.8, v: 1 });
                            // Darken or lighten colors that are adjacent on the color wheel
                            if (i % 3 === 0) {
                                color = color.darken(Math.random() / 1.8);
                            }
                            if (i % 3 === 1) {
                                color = color.lighten(Math.random() / 1.1);
                            }
                            colors.push(color);
                        }
                        // Gives the appearance of randomness, but this is *not* a good random sort to use if it actually matters
                        return colors.sort(function (c) { return 0.5 - Math.random(); });
                    }
                    ColorUtils.generateRandomColors = generateRandomColors;
                    /**
                     * Generate a random saturated color
                     */
                    function generateRandomColor() {
                        var hue = Math.random();
                        return new infrastructure.visualization.SymbolColor({ h: hue, s: 0.8, v: 1 });
                    }
                    ColorUtils.generateRandomColor = generateRandomColor;
                    /**
                     * Detect whether or not the native color input type is supported by the current browser.
                     * Returns true when color input is supported, false otherwise.
                     */
                    function isColorInputSupported() {
                        var input = document.createElement("input");
                        input.setAttribute("type", "color");
                        return input.type !== "text";
                    }
                    ColorUtils.isColorInputSupported = isColorInputSupported;
                })(ColorUtils = infrastructure.ColorUtils || (infrastructure.ColorUtils = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../_Definitions/framework.d.ts"/>
/// <reference path="../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../_Definitions/dojo.d.ts"/>
/// <reference path="../../_Definitions/modernizr.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                /**
                 * A facsimile of {@link esri.renderer.Renderer}.
                 * @private
                 */
                var SimpleRenderer = (function () {
                    /**
                     * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.SimpleRenderer} class.
                     * @constructs
                     * @memberOf geocortex.essentialsHtmlViewer.mapping.infrastructure.SimpleRenderer
                     */
                    function SimpleRenderer() {
                        /**
                         * The color scheme to fill the graphics.
                         */
                        this.fillColor = new esri.Color([236, 236, 0, 0.22745]); // #99ECEC3A
                        /**
                         * The color scheme to draw the border of the graphics.
                         */
                        this.borderColor = new esri.Color([204, 204, 51, 1]); // #FFCCCC33
                        /**
                        * The width to draw the border of the graphics.
                        */
                        this.borderWidth = 2;
                        /**
                         * Matches a member in {@link esri.renderer.Renderer}.
                         */
                        this.defaultSymbol = null;
                        this._pictureMarkerSymbolCache = {};
                    }
                    /**
                     * Returns the clone of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.SimpleRenderer} object
                     * @return {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.SimpleRenderer}
                     */
                    SimpleRenderer.prototype.clone = function () {
                        var renderer = new geocortex.essentialsHtmlViewer.mapping.infrastructure.SimpleRenderer();
                        renderer.fillColor = this.fillColor;
                        renderer.borderColor = this.borderColor;
                        renderer.borderWidth = this.borderWidth;
                        return renderer;
                    };
                    /**
                     * Returns the ESRI symbol corresponding to the geometry of given graphic.
                     * @param graphic The ESRI graphic
                     * @return The ESRI symbol
                     */
                    SimpleRenderer.prototype.getSymbol = function (graphic) {
                        if (!graphic || !graphic.geometry) {
                            return null;
                        }
                        if (graphic.geometry instanceof esri.geometry.Point || graphic.geometry instanceof esri.geometry.Multipoint) {
                            return new esri.symbol.SimpleMarkerSymbol(esri.symbol.SimpleMarkerSymbol.STYLE_CIRCLE, 10.0, null, this.borderColor);
                        }
                        if (graphic.geometry instanceof esri.geometry.Polygon) {
                            // Draw a polygon
                            return new esri.symbol.SimpleFillSymbol(esri.symbol.SimpleFillSymbol.STYLE_SOLID, new esri.symbol.SimpleLineSymbol(esri.symbol.SimpleLineSymbol.STYLE_SOLID, this.borderColor, this.borderWidth), this.fillColor);
                        }
                        if (graphic.geometry instanceof esri.geometry.Polyline) {
                            // Draw a line
                            return new esri.symbol.SimpleLineSymbol(esri.symbol.SimpleLineSymbol.STYLE_SOLID, this.borderColor, this.borderWidth);
                        }
                        return null;
                    };
                    /**
                     * Some feature layer graphics have a hidden GraphicsLayer that
                     * can be used to better inform the highlight shape.  This is pretty hacky.
                     */
                    SimpleRenderer.prototype.getSymbolWithHacks = function (graphic, layer) {
                        if (layer && layer.renderer && graphic && graphic.geometry && (graphic.geometry instanceof esri.geometry.Point || graphic.geometry instanceof esri.geometry.Multipoint)) {
                            var symbol = layer.renderer.getSymbol(graphic);
                            if (symbol instanceof esri.symbol.SimpleMarkerSymbol) {
                                return new esri.symbol.SimpleMarkerSymbol(symbol.style, symbol.size + 2, null, this.fillColor);
                            }
                            if (symbol instanceof esri.symbol.PictureMarkerSymbol) {
                                return this._getPictureMarkerSymbolHighlight(symbol);
                            }
                            if (symbol instanceof esri.symbol.MarkerSymbol) {
                                return new esri.symbol.SimpleMarkerSymbol(esri.symbol.SimpleMarkerSymbol.STYLE_CIRCLE, symbol.size, null, this.fillColor);
                            }
                        }
                        return this.getSymbol(graphic);
                    };
                    SimpleRenderer.prototype._getPictureMarkerSymbolHighlight = function (symbol) {
                        if (this._pictureMarkerSymbolCache.hasOwnProperty(symbol.url)) {
                            // Cache hit
                            return this._pictureMarkerSymbolCache[symbol.url];
                        }
                        if (Modernizr && Modernizr.canvas) {
                            try {
                                // Fill the canvas with the bg color and then use the image as a mask to apply alpha channel
                                var canvas = document.createElement("canvas");
                                canvas.width = symbol.width;
                                canvas.height = symbol.height;
                                var context = canvas.getContext("2d");
                                context.fillStyle = this.fillColor.toCss(Modernizr.rgba);
                                context.fillRect(0, 0, canvas.width, canvas.height);
                                context.globalCompositeOperation = "destination-atop";
                                var img = new Image();
                                img.src = symbol.url;
                                context.drawImage(img, 0, 0);
                                return this._pictureMarkerSymbolCache[symbol.url] = new esri.symbol.PictureMarkerSymbol(canvas.toDataURL("image/png"), canvas.width, canvas.height);
                            }
                            catch (error) {
                            }
                        }
                        // Fall back to a circle about the size of the symbol on IE 8
                        return this._pictureMarkerSymbolCache[symbol.url] = new esri.symbol.SimpleMarkerSymbol(esri.symbol.SimpleMarkerSymbol.STYLE_CIRCLE, Math.min(symbol.width, symbol.height), null, this.fillColor);
                    };
                    SimpleRenderer.prototype.toJson = function () {
                        return {
                            fillColor: this.fillColor,
                            borderColor: this.borderColor,
                            borderWidth: this.borderWidth
                        };
                    };
                    return SimpleRenderer;
                }());
                infrastructure.SimpleRenderer = SimpleRenderer;
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../_Definitions/framework.d.ts"/>
/// <reference path="../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../_Definitions/dojo.d.ts"/>
/// <reference path="./ColorUtils.ts"/>
/// <reference path="./Feature.ts"/>
/// <reference path="./SimpleRenderer.ts"/>
/// <reference path="../Viewer.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var HighlightManager = (function () {
                    /**
                     * Initializes a new instance of an {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.HighlightManager} object.
                     * @class
                     * <p>The central system for highlighting features.</p>
                     * @constructs
                     * @memberOf geocortex.essentialsHtmlViewer.mapping.infrastructure
                     * @param app The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this module belongs to.
                     */
                    function HighlightManager(app) {
                        /**
                         * ID of the currently active highlight layer
                         * @private
                         */
                        this._activeHighlightLayerName = null;
                        /**
                         * Collection of named highlight layers
                         * @private
                         */
                        this._highlightLayers = {};
                        /**
                         * The collection of object id of the original graphic to mapping objects that contain the managed (original) graphic, and the cloned graphic, and layer
                         * @private
                         */
                        this._managedGraphics = {};
                        /**
                         *   The next number to be used in the id of one of the managed or clone objects
                         * @private
                         */
                        this._nextHighlightId = 0;
                        /**
                         * The renderer that should be used to create the symbol for a graphic
                         * @private
                         */
                        this._defaultRenderer = new infrastructure.SimpleRenderer();
                        /**
                         * The name of the default highlight layer.  Only the HighlightModule has good reason to access this.
                         * @private
                         */
                        this._defaultHighlightLayerName = null;
                        this.app = app;
                    }
                    /*
                     * The section below contains all of the Command implementations
                     */
                    /**
                     * Creates a new highlighting layer with the specified name. This will throw an error if a layer with the specified name exists.
                     * @param {String} layerName The name of the layer to create.
                     * @param {String|number} fillColor The color to fill with, leave as null for default
                     * @param {String|number} borderColor The color to color the border with, leave as null for default
                     */
                    HighlightManager.prototype.createHighlightLayer = function (layerName, fillColor, borderColor) {
                        if (!layerName) {
                            throw new Error("Unable to create new highlight layer with null or empty name");
                        }
                        if (this._highlightLayers.hasOwnProperty(layerName)) {
                            // This is a warning, and not an exception, because if we try to create an already created layer, it won't necessarily mean certain doom.
                            this.app.trace.warning("Cannot create highlight layer because layer with name '{0}' already exists.".format(layerName));
                            return null;
                        }
                        var graphicsLayer = new esri.layers.GraphicsLayer();
                        // If we've specified the fill or border color during creation of the highlight layer, we will use that highlight or fill for this
                        // layer, overriding all previous values, or values coming in from the feature.
                        if ((fillColor !== null && fillColor !== undefined) || (borderColor !== null && borderColor !== undefined)) {
                            graphicsLayer.renderer = this._defaultRenderer.clone();
                            if (fillColor !== null && fillColor !== undefined) {
                                graphicsLayer.renderer.fillColor = typeof fillColor == "string" ? infrastructure.ColorUtils.getColorFromString(fillColor) : infrastructure.ColorUtils.getColorFromList(fillColor);
                            }
                            if (borderColor !== null && borderColor !== undefined) {
                                graphicsLayer.renderer.borderColor = typeof borderColor == "string" ? infrastructure.ColorUtils.getColorFromString(borderColor) : infrastructure.ColorUtils.getColorFromList(borderColor);
                            }
                        }
                        this._highlightLayers[layerName] = graphicsLayer;
                        this._addLayerToMap(graphicsLayer);
                        if (!this._activeHighlightLayerName || this._activeHighlightLayerName === "") {
                            this._activeHighlightLayerName = layerName;
                        }
                        this.app.event("HighlightLayerCreated").publish(layerName);
                        return graphicsLayer;
                    };
                    /**
                     * Sets the active highlight layer.
                     * This is the layer that new features will be added to, or cleared from.
                     * @param {String} layerName The name of the layer to set as Active.
                     */
                    HighlightManager.prototype.setActiveHighlightLayer = function (layerName) {
                        if (!layerName) {
                            throw new Error("Unable to set the active highlight layer because no layer name was given.");
                        }
                        if (!this._highlightLayers.hasOwnProperty(layerName)) {
                            throw new Error("Unable to set {0} as the active highlight layer, because a highlight layer with that name does not exist".format(layerName));
                        }
                        this._activeHighlightLayerName = layerName;
                    };
                    /**
                     * Highlights the features in the Esri Feature Set provided, and adds them to the active highlight later, or the layer specified layer.
                     * Features added will take the fill and border color that are currently set.
                     * @param {esri.tasks.FeatureSet} esriFeatureSet The Esri feature set to highlight.
                     * @param {String} [highlightLayerId] The highlight layer to add the highlights to.
                     */
                    HighlightManager.prototype.highlightEsriFeatureSet = function (esriFeatureSet, highlightLayerId) {
                        if (!esriFeatureSet) {
                            this.app.trace.warning("No FeatureSet was provided; as such, no features were highlighted");
                            return;
                        }
                        if (!esriFeatureSet.features || esriFeatureSet.features.length == 0) {
                            this.app.trace.warning("No features detected in FeatureSet; as such, no features were highlighted");
                            return;
                        }
                        // If the highlightLayerId is provided, we get that layer, otherwise, we get the active highlight layer.
                        var graphicsLayer = this.getHighlightLayerOrActive(highlightLayerId);
                        if (!graphicsLayer || !graphicsLayer.graphics) {
                            this.app.trace.warning("Unable to highlight feature because the required layer was not found, or could not accept graphics");
                        }
                        for (var i = 0; i < esriFeatureSet.features.length; i++) {
                            this._drawGraphic(esriFeatureSet.features[i], graphicsLayer);
                        }
                    };
                    /**
                    * Highlights the features in the list of features provided, and adds them to the active highlight later, or the layer specified layer.
                    * Features added will take the fill and border color that are specified in the feature, or the current highlight colors if one is not specified.
                    * @param {geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature[]} features The list of features to highlight.
                    * @param {String} [highlightLayerId] The highlight layer to add the highlights to.
                    */
                    HighlightManager.prototype.highlightFeatures = function (features, highlightLayerId) {
                        if (!features) {
                            this.app.trace.warning("No Features were provided, as such, no features were highlighted");
                            return;
                        }
                        // If the highlightLayerId is provided, we get that layer, otherwise, we get the active highlight layer.
                        var graphicsLayer = this.getHighlightLayerOrActive(highlightLayerId);
                        if (!graphicsLayer) {
                            this.app.trace.warning("Unable to highlight feature because the required layer was not found, or could not accept graphics");
                        }
                        // Features might have their own specified border and fill colors. They take precedence over those stored in the theme.
                        var savedBorderColor = this._defaultRenderer.borderColor;
                        var savedFillColor = this._defaultRenderer.fillColor;
                        var savedBorderWidth = this._defaultRenderer.borderWidth;
                        // Make sure the highlight layer is on top
                        // To be implemented
                        for (var i = 0; i < features.length; i++) {
                            var feature = features[i];
                            try {
                                var color;
                                if (feature.borderColor && feature.borderColor.get()) {
                                    color = infrastructure.ColorUtils.getColorFromList(feature.borderColor.get());
                                    if (color) {
                                        this._setBorderColor(color);
                                    }
                                }
                                if (feature.fillColor && feature.fillColor.get()) {
                                    color = infrastructure.ColorUtils.getColorFromList(feature.fillColor.get());
                                    if (color) {
                                        this._setFillColor(color);
                                    }
                                }
                                if (feature.borderWidth && feature.borderWidth.get()) {
                                    var width = feature.borderWidth.get();
                                    if (width >= 0) {
                                        this._setBorderWidth(width);
                                    }
                                }
                                this._drawGraphic(feature.esriFeature.get(), graphicsLayer);
                            }
                            finally {
                                // Reset the colors back to what they were before 
                                this._setBorderColor(savedBorderColor);
                                this._setFillColor(savedFillColor);
                                this._setBorderWidth(savedBorderWidth);
                            }
                        }
                    };
                    HighlightManager.prototype.highlightGraphics = function (graphics, highlightLayerId) {
                        if (!graphics) {
                            this.app.trace.warning("No Graphics were provided, as such, no graphics were highlighted");
                            return;
                        }
                        // If the highlightLayerId is provided, we get that layer, otherwise, we get the active highlight layer.
                        var graphicsLayer = this.getHighlightLayerOrActive(highlightLayerId);
                        if (!graphicsLayer) {
                            this.app.trace.warning("Unable to highlight feature because the required layer was not found, or could not accept graphics");
                        }
                        // Make sure the highlight layer is on top
                        // To be implemented
                        for (var i = 0; i < graphics.length; i++) {
                            this._drawGraphic(graphics[i], graphicsLayer);
                        }
                    };
                    /**
                     * Removes the layer with the specified name, and any associated highlights.
                     * @param {String} layerName The name of the layer to remove.
                     */
                    HighlightManager.prototype.removeHighlightLayer = function (layerName) {
                        if (!layerName) {
                            throw new Error("Unable to remove a highlight layer with null or empty name");
                        }
                        if (!this._highlightLayers.hasOwnProperty(layerName)) {
                            throw new Error("Cannot remove highlight layer because layer with name {0} does not exist.".format(layerName));
                        }
                        var graphicsLayer = this._highlightLayers[layerName];
                        // necessary to remove all the mappings
                        this.clearHighlights(graphicsLayer);
                        this.app.map.removeLayer(graphicsLayer);
                        delete this._highlightLayers[layerName];
                        if (this._activeHighlightLayerName === layerName) {
                            this._activeHighlightLayerName = null;
                        }
                    };
                    HighlightManager.prototype.clearHighlights = function (arg) {
                        // This method may look confusing, but essentially performs like an overloaded method where if we get no args
                        // we assume we want the active highlight layer, if we get a string, we assume we want the highlight layer with that name
                        // and if we get a graphics layer, we assume that we just want to clear the highlights from that layer.
                        // Case, no args, use activehighlight layer
                        var layerName = null;
                        if (!arg) {
                            if (this._activeHighlightLayerName) {
                                layerName = this._activeHighlightLayerName;
                            }
                        }
                        // Case, we set the layername above, or the arg should be used as it
                        var graphicsLayer = null;
                        if (layerName || typeof arg == "string") {
                            if (!layerName) {
                                layerName = arg;
                            }
                            graphicsLayer = this.getHighlightLayer(layerName);
                        }
                        // Case, we found the graphics layer above, or the arg is a suitable replacement
                        if (graphicsLayer || (typeof arg == "object" && arg instanceof esri.layers.GraphicsLayer)) {
                            if (!graphicsLayer) {
                                graphicsLayer = arg;
                            }
                            if (graphicsLayer && graphicsLayer.graphics) {
                                // We have to do a negative indexing array here, because as we remove elements, the array gets smaller.
                                // In reality, we could do this with a while look and remove index 0 just as easily. 
                                // But with a for loop, we know we won't loop infinitely, should the graphic fail to remove from the layer.
                                for (var i = graphicsLayer.graphics.length - 1; i >= 0; i--) {
                                    var graphic = graphicsLayer.graphics[i];
                                    this._removeClonedGraphic(graphic);
                                }
                            }
                            else {
                                this.app.trace.warning("An attempt was made to clear a highlight layer which contained no graphics");
                            }
                        }
                    };
                    /**
                     * Gets the current fill color.
                     * Returns the 6 or 8 digit hex color in RGB or ARGB form.
                     */
                    HighlightManager.prototype.getHighlightFillColor = function () {
                        return this._toARGBHex(this._getFillColor());
                    };
                    /**
                     * Gets the current border color.
                     * Returns the 6 or 8 digit hex color in RGB or ARGB form.
                     */
                    HighlightManager.prototype.getHighlightBorderColor = function () {
                        return this._toARGBHex(this._getBorderColor());
                    };
                    /**
                     * Gets the current border width.
                     * Returns the width of the border.
                     */
                    HighlightManager.prototype.getHighlightBorderWidth = function () {
                        return this._getBorderWidth();
                    };
                    /**
                     * Sets the fill color to the one specified.
                     * @param {String} color The 6 or 8 digit hex color in RGB or ARGB form.
                     */
                    HighlightManager.prototype.setHighlightFillColor = function (color) {
                        this._setFillColor(infrastructure.ColorUtils.getColorFromString(color));
                    };
                    /**
                     * Sets the border color to the one specified.
                     * @param {String} color The 6 or 8 digit hex color in RGB or ARGB form.
                     */
                    HighlightManager.prototype.setHighlightBorderColor = function (color) {
                        this._setBorderColor(infrastructure.ColorUtils.getColorFromString(color));
                    };
                    /**
                     * Sets the border width to the one specified.
                     * @param {number} width The number (in pixels) for the width of the hightlight.
                     */
                    HighlightManager.prototype.setHighlightBorderWidth = function (width) {
                        this._setBorderWidth(width);
                    };
                    /*
                     * The methods below do not have commands attached to them, but are general enough that they could be considered public (this does not mean that they are public though)
                     */
                    /**
                     * Gets a highlight layer with the specified name.
                     * @param {String} layerName The name of the layer to get.
                     * @returns {esri.layer.GraphicsLayer} highlight layer
                     */
                    HighlightManager.prototype.getHighlightLayer = function (layerName) {
                        if (!layerName) {
                            this.app.trace.warning("Unable to get a highlight layer with null or empty name");
                            return null;
                        }
                        return this._highlightLayers[layerName];
                    };
                    /**
                     * Gets the set of highlight layers, keyed by name.
                     */
                    HighlightManager.prototype.getHighlightLayers = function () {
                        return this._highlightLayers;
                    };
                    /**
                     * Gets a highlight layer with the specified name, or the active layer if one is not specified.
                     * @param {String} [layerName] The name of the layer to get.
                     * @returns {esri.layer.GraphicsLayer} highlight layer
                     */
                    HighlightManager.prototype.getHighlightLayerOrActive = function (layerName) {
                        var graphicsLayer;
                        if (layerName) {
                            graphicsLayer = this.getHighlightLayer(layerName);
                        }
                        else {
                            graphicsLayer = this._activeHighlightLayer();
                        }
                        return graphicsLayer;
                    };
                    /**
                     * Returns the graphics currently in the active highlight layer.
                     * @returns {esri.Graphic[]} active layer highlighted graphics.
                     */
                    HighlightManager.prototype.activeHighlightLayerGraphics = function () {
                        var activeLayer = this._activeHighlightLayer();
                        if (activeLayer && activeLayer.graphics) {
                            return activeLayer.graphics.slice(0);
                        }
                        return null;
                    };
                    /**
                     * Returns the graphics currently in the default highlight layer.
                     * @returns {esri.Graphic[]} default layer highlighted graphics.
                     */
                    HighlightManager.prototype.defaultHighlightLayerGraphics = function () {
                        var defaultLayer = this.getHighlightLayer(this._defaultHighlightLayerName);
                        if (defaultLayer) {
                            return defaultLayer.graphics.slice(0);
                        }
                        return null;
                    };
                    HighlightManager.prototype.exportState = function () {
                        var _this = this;
                        return Promise.try(function () {
                            var convert = _this.app.project.convert;
                            var state = {
                                highlightLayers: {},
                                activeHighlightLayerName: _this._activeHighlightLayerName,
                                highlights: []
                            };
                            // Add all of the highlight layers.
                            for (var name in _this._highlightLayers) {
                                state.highlightLayers[name] = convert.fromEsriLayer(_this._highlightLayers[name]);
                            }
                            // Add each graphic/layer pairing.
                            for (var highlightId in _this._managedGraphics) {
                                _this._managedGraphics[highlightId].forEach(function (managedGraphic) {
                                    state.highlights.push({
                                        feature: convert.fromEsriGraphic(managedGraphic.managedGraphic),
                                        highlightLayer: convert.fromEsriLayer(managedGraphic.layer)
                                    });
                                });
                            }
                            return state;
                        });
                    };
                    HighlightManager.prototype.applyState = function (state) {
                        var _this = this;
                        var convert = this.app.project.convert;
                        var highlightLayersPromises = {};
                        for (var name in state.highlightLayers) {
                            highlightLayersPromises[name] = convert.toEsriLayer(state.highlightLayers[name]);
                        }
                        var promises = {
                            highlightLayers: infrastructure.PromiseUtils.propsSkipRejected(highlightLayersPromises),
                            highlights: infrastructure.PromiseUtils.mapSkipRejected(state.highlights, function (hl) { return Promise.props({
                                graphic: convert.toEsriGraphic(hl.feature),
                                highlightLayer: convert.toEsriLayer(hl.highlightLayer)
                            }); })
                        };
                        return Promise.props(promises)
                            .then(function (promiseResults) {
                            // Clear all existing highlights and reset the internal state.
                            for (var layerName in _this._highlightLayers) {
                                _this.clearHighlights(layerName);
                            }
                            _this._highlightLayers = {};
                            _this._managedGraphics = {};
                            // Before we restore anything, set the next ID to be higher than any other ID we are restoring, 
                            // otherwise we could eventually generate duplicates.
                            _this._nextHighlightId = 0;
                            promiseResults.highlights.forEach(function (hl) {
                                var id = parseInt(_this._getHighlightId(hl.graphic));
                                _this._nextHighlightId = Math.max(_this._nextHighlightId, id + 1);
                            });
                            // Add highlight layers.
                            for (var name in promiseResults.highlightLayers) {
                                _this._highlightLayers[name] = promiseResults.highlightLayers[name];
                            }
                            _this._activeHighlightLayerName = state.activeHighlightLayerName;
                            // Process each highlight.
                            promiseResults.highlights.forEach(function (hl) {
                                // Prior to 2.6.1, each highlight layer was saved without any highlight graphics.
                                // To fix GVH-9783, we now save the highlight graphics in order to preserve custom 
                                // border and fill colors. We need to be able to handle both of these scenarios.
                                var highlightId = _this._getHighlightId(hl.graphic);
                                var highlightGraphic = geocortex.framework.utils.ArrayUtils.firstOrDefault(hl.highlightLayer.graphics, function (g) { return _this._getHighlightId(g) === _this._getHighlightId(hl.graphic); });
                                if (highlightGraphic) {
                                    // GVH 2.6.1 or above. We have both an original graphic and its associated highlight graphic.
                                    // Just add the appropriate metadata to _managedGraphics.
                                    _this._trackGraphic(hl.graphic, highlightGraphic, hl.highlightLayer);
                                }
                                else {
                                    // GVH 2.6.0. Re-create the highlight graphic from the original.
                                    _this._drawGraphic(hl.graphic, hl.highlightLayer);
                                }
                            });
                        });
                    };
                    /*
                     * The functions below are implementation level concerns, and should be considered to be private
                     */
                    /**
                     * Draws the graphic to the specified esri.layer.GraphicsLayer.
                     * @param The graphic to be drawn
                     * @param The specified graphic layer
                     */
                    HighlightManager.prototype._drawGraphic = function (graphic, layer) {
                        if (!graphic || !layer) {
                            this.app.trace.error("HighlightManager given null graphic or layer. Skipping...");
                            return;
                        }
                        this._showHighlightLayer(layer);
                        // If we don't have a highlightId on the graphic yet, we'll want to add one so that we can look up this graphic later.
                        var highlightId = this._getHighlightId(graphic);
                        if (!highlightId) {
                            highlightId = this._nextId();
                            this._setHighlightId(graphic, highlightId);
                        }
                        // If any of the mapping objects for this graphic already have this layer, we shouldn't add it, so we'll just return.
                        if (this._managedGraphics.hasOwnProperty(highlightId)) {
                            for (var i = 0; i < this._managedGraphics[highlightId].length; i++) {
                                if (this._managedGraphics[highlightId][i].layer === layer) {
                                    return;
                                }
                            }
                        }
                        // Create a clone of the graphic. The clone must have the same highlight ID as the original
                        // in order to work properly with projects.
                        var newGraphic = new esri.Graphic();
                        newGraphic.attributes = {};
                        for (var key in graphic.attributes) {
                            if (graphic.attributes.hasOwnProperty(key)) {
                                newGraphic.attributes[key] = graphic.attributes[key];
                            }
                        }
                        newGraphic.geometry = graphic.geometry;
                        this._setHighlightId(newGraphic, highlightId);
                        // Keep track of the fact that we're already operating for this graphic on this layer
                        this._trackGraphic(graphic, newGraphic, layer);
                        // To actually do the drawing, we need to have a graphic, and a geometry
                        if (newGraphic.geometry) {
                            if (!layer.renderer) {
                                // graphic._graphicsLayer is an undocumented member we're abusing.  The code that accesses it is defensive
                                // so worst case scenario there's no benefit here.
                                newGraphic.symbol = this._defaultRenderer.getSymbolWithHacks(newGraphic, graphic._graphicsLayer);
                            }
                            // Add the shape to be shown on the drawing layer
                            layer.add(newGraphic);
                        }
                    };
                    /**
                     * Keeps track of a pairing of original graphic + cloned graphic for a particular layer.
                     */
                    HighlightManager.prototype._trackGraphic = function (graphic, clonedGraphic, layer) {
                        // Get the existing graphicMapping object, or if we don't have one yet, create one and add it.
                        var graphicMaps;
                        var highlightId = this._getHighlightId(graphic);
                        if (this._managedGraphics.hasOwnProperty(highlightId)) {
                            graphicMaps = this._managedGraphics[highlightId];
                        }
                        else {
                            graphicMaps = [];
                            this._managedGraphics[highlightId] = graphicMaps;
                        }
                        // If any of the mapping objects for this graphic already have this layer, we shouldn't add it, so we'll just return.
                        for (var i = 0; i < graphicMaps.length; i++) {
                            if (graphicMaps[i].layer === layer) {
                                return;
                            }
                        }
                        // Keep track of the fact that we're already operating for this graphic on this layer
                        var graphicMapItem = {
                            layer: layer,
                            managedGraphic: graphic,
                            clonedGraphic: clonedGraphic
                        };
                        graphicMaps.push(graphicMapItem);
                    };
                    /** @private  Returns the dojo.Color currently set to fill */
                    HighlightManager.prototype._getFillColor = function () {
                        return this._defaultRenderer.fillColor;
                    };
                    /** @private  Sets the dojo.Color that should be used to fill graphics by default */
                    HighlightManager.prototype._setFillColor = function (color) {
                        this._defaultRenderer.fillColor = color;
                    };
                    /** @private Returns the dojo.Color currently set for borders */
                    HighlightManager.prototype._getBorderColor = function () {
                        return this._defaultRenderer.borderColor;
                    };
                    /** @private  Sets the dojo.Color that should be used for the borders of graphics */
                    HighlightManager.prototype._setBorderColor = function (color) {
                        this._defaultRenderer.borderColor = color;
                    };
                    /** @private Returns the width currently set for borders */
                    HighlightManager.prototype._getBorderWidth = function () {
                        return this._defaultRenderer.borderWidth;
                    };
                    /** @private Sets the width that should be used for the borders of graphics */
                    HighlightManager.prototype._setBorderWidth = function (width) {
                        this._defaultRenderer.borderWidth = width;
                    };
                    HighlightManager.prototype._toARGBHex = function (color) {
                        var a_hex = ("00" + (Math.floor(color.a * 255)).toString(16)).slice(-2); // a is a float between 0 and 1
                        var r_hex = ("00" + color.r.toString(16)).slice(-2); // rgb are integers between 0 and 255 
                        var g_hex = ("00" + color.g.toString(16)).slice(-2);
                        var b_hex = ("00" + color.b.toString(16)).slice(-2);
                        return "#" + a_hex + r_hex + g_hex + b_hex;
                    };
                    /** @private  Returns the next integer that should be used for keying into the layers, if a graphic doesn't already have one. */
                    HighlightManager.prototype._nextId = function () {
                        // If we find that we're actually hitting the integer max, we could always look at more intelligent ways of looping this.
                        return (this._nextHighlightId++).toString();
                    };
                    HighlightManager.prototype._getHighlightId = function (graphic) {
                        if (!graphic || !graphic.attributes) {
                            return undefined;
                        }
                        return graphic["__gcxHlId"];
                    };
                    HighlightManager.prototype._setHighlightId = function (graphic, id) {
                        // GVH-9141: Dynamic feature layers' attributes are evidently repopulated by ESRI on the fly,
                        // which makes assigning the highlight ID to these attributes impossible.
                        graphic["__gcxHlId"] = id;
                    };
                    HighlightManager.prototype._showHighlightLayer = function (layer) {
                        this.app.map.reorderLayer(layer, this.app.map.graphicsLayerIds.length - 1);
                        // keep the default highlight layer on top
                        if (layer != this._highlightLayers[this._defaultHighlightLayerName]) {
                            this.app.map.reorderLayer(this._highlightLayers[this._defaultHighlightLayerName], this.app.map.graphicsLayerIds.length - 1);
                        }
                    };
                    /** @private Adds the specified layer to the map. This is a convenience method, because it's long, and had to be done lots. */
                    HighlightManager.prototype._addLayerToMap = function (layer) {
                        // We may want to do a check that the map and layers are initialized and if not, add a delayed list, like silverlight does.
                        this.app.map.addLayer(layer);
                    };
                    /** @private  Returns the esri.layers.GraphicsLayer that is currently set as the active highlight layer. */
                    HighlightManager.prototype._activeHighlightLayer = function () {
                        if (this._activeHighlightLayerName) {
                            return this.getHighlightLayer(this._activeHighlightLayerName);
                        }
                        return null;
                    };
                    /** @private Removes the specified {esri.Graphic} clone from the system, and cleans up the managed graphic map associated with it. */
                    HighlightManager.prototype._removeClonedGraphic = function (graphic) {
                        var highlightId = this._getHighlightId(graphic);
                        if (this._managedGraphics.hasOwnProperty(highlightId)) {
                            var graphicMap = geocortex.framework.utils.ArrayUtils.firstOrDefault(this._managedGraphics[highlightId], function (x) { return x.clonedGraphic === graphic; });
                            this._removeManagedGraphic(graphicMap.managedGraphic, graphicMap.layer);
                        }
                    };
                    /**
                     * Removes the specified original graphic from the specified layer, as well as it's clone and the mapping objects associated with the clone and the layer
                     * @param graphic The specified orignal graphic to be removed from a specific layer
                     * @param graphicsLayer The specified layer from which the graphic needs to be removed
                     * @private
                     */
                    HighlightManager.prototype._removeManagedGraphic = function (graphic, graphicsLayer) {
                        var highlightId = this._getHighlightId(graphic);
                        if (this._managedGraphics.hasOwnProperty(highlightId)) {
                            var graphicMaps = this._managedGraphics[highlightId];
                            // Attempt to for this graphic that matches the graphics layer in question
                            // So that we can get the remove it from the clones and managed graphics
                            var graphicMap = null;
                            for (var i = 0; i < graphicMaps.length; i++) {
                                if (graphicMaps[i].layer === graphicsLayer) {
                                    graphicMap = graphicMaps[i];
                                    break;
                                }
                            }
                            // If we found a graphic map representing this graphic and graphicsLayer, clean up the clone
                            if (graphicMap) {
                                graphicsLayer.remove(graphicMap.clonedGraphic);
                                var graphicMapPos = graphicMaps.indexOf(graphicMap);
                                graphicMaps.splice(graphicMapPos, 1);
                                // If there are no layers left for this graphic, we might as well remove the managed graphic as well
                                if (graphicMaps.length === 0) {
                                    delete this._managedGraphics[highlightId];
                                }
                            }
                        }
                    };
                    return HighlightManager;
                }());
                infrastructure.HighlightManager = HighlightManager;
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts"/>
/// <reference path="../FeatureSetCollection.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var search;
                (function (search) {
                    var SearchProviderBase = (function () {
                        /**
                         * Create a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.search.SearchProviderBase} class.
                         * @class
                         * <p>The base class for all search provider.</p>
                         * @constructs
                         * @memberOf geocortex.essentialsHtmlViewer.mapping.infrastructure.search
                         * @param app The {@link geocortex.framework.application.Application} that this base class belongs to.
                         */
                        function SearchProviderBase(app, libraryId) {
                            this.app = app;
                            this.libraryId = libraryId;
                            this.id = "SearchProvider-" + geocortex.framework.utils.alphaNumericToken();
                            // Supporting offline searches is something a provider has to opt-in.
                            this.supportsOffline = false;
                            // Supporting search hints is something a provider has to opt-in.
                            this.supportsHints = false;
                            this.status = geocortex.essentialsHtmlViewer.mapping.infrastructure.search.Status.IDLE;
                        }
                        /**
                         * Initialize the provider.
                         * @param config The configuration object.
                         */
                        SearchProviderBase.prototype.initialize = function (config) { };
                        /**
                         * Performs the search.
                         * @param targetFsc Where search results are to go.
                         * @param searchText What to search for.
                         */
                        SearchProviderBase.prototype.search = function (targetFsc, searchText) { };
                        /**
                         * Cancel a search.
                         */
                        SearchProviderBase.prototype.cancelSearch = function () { };
                        /**
                         * Gets a language resource from the Application's resource dictionary, given a key, and optional locale.
                         * Returns null if the resource does not exist.
                         * @param key The resource key.
                         * @param locale The locale of the resource to fetch. Defaults to the current application locale.
                         */
                        SearchProviderBase.prototype.getResource = function (resourceKey, locale) {
                            return this.app.getResource(this.libraryId, resourceKey, locale);
                        };
                        return SearchProviderBase;
                    }());
                    search.SearchProviderBase = SearchProviderBase;
                })(search = infrastructure.search || (infrastructure.search = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../FeatureSetCollection.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var eventArgs;
                (function (eventArgs) {
                    var SearchProgressEventArgs = (function () {
                        /**
                         * Initializes a new instance of the {@link SearchProgressEventArgs} class.
                         */
                        function SearchProgressEventArgs() {
                            /**
                             * The status of the executing search.
                             * @type geocortex.essentialsHtmlViewer.mapping.infrastructure.search.Status
                             */
                            this.status = null;
                            /**
                             * The type of search that is being performed (eg. Instant Search, Geocode, etc.).
                             * @type String
                             */
                            this.searchType = null;
                            /**
                             * The URL to the search endpoint.
                             * @type String
                             */
                            this.endpointUrl = null;
                            /**
                             * Any error that might have been thrown.
                             * @type Error
                             */
                            this.error = null;
                            /**
                             * A message that might be displayed to the user. In the event of an error, then usually error.message
                             * @type String
                             */
                            this.message = null;
                            /**
                              * The results of the search.
                              * @type geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection
                              */
                            this.results = null;
                            /**
                             * The full search query that was used for the search. Only relevant for text-based searches.
                             * @type String
                             */
                            this.query = null;
                        }
                        return SearchProgressEventArgs;
                    }());
                    eventArgs.SearchProgressEventArgs = SearchProgressEventArgs;
                })(eventArgs = infrastructure.eventArgs || (infrastructure.eventArgs = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/**
 * Legacy support.  No new code should use this.
 */
geocortex.essentialsHtmlViewer.mapping.infrastructure.search.SearchProgressEventArgs = geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.SearchProgressEventArgs;
/// <reference path="../../../_Definitions/framework.d.ts"/>
/// <reference path="./SearchProviderBase.ts"/>
/// <reference path="../eventArgs/SearchProgressEventArgs.ts"/>
/// <reference path="../FeatureSetCollection.ts"/>
/// <reference path="../../Viewer.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var search;
                (function (search) {
                    var Status;
                    (function (Status) {
                        Status.IDLE = "Idle";
                        Status.SEARCHING = "Searching";
                        Status.ERROR = "Error";
                    })(Status = search.Status || (search.Status = {}));
                    var SearchManager = (function () {
                        /**
                         * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.search.SearchManager} class.
                         * @class
                         * <p>The search manager is the central access point for all things search within the viewer.
                         * The idea is that various search providers will be registered with the search manager
                         * and will all be used when a search takes place (if enabled).</p>
                         * @constructs
                         * @memberOf geocortex.essentialsHtmlViewer.mapping.infrastructure.search
                         * @param app The {@link geocortex.framework.application.Application} instance that this SearchManager belongs to.
                         */
                        function SearchManager(app) {
                            /** @private */
                            this._searchProviders = [];
                            /** @private */
                            this._fscRootID = "SearchResultsCollection";
                            /** @private */
                            this._count = 0;
                            /** @private */
                            this._fscSourceName = "Search";
                            this.app = app;
                            this._registerCommands();
                            this.app.event("SearchProgressEvent").subscribe(this, this._searchProgress);
                        }
                        SearchManager.prototype._resetFeatureSetCollection = function () {
                            if (!this._fsc) {
                                // See if a collection with the appropriate ID already exists in the feature set manager. 
                                // This can happen after a project is restored.
                                this._fsc = this.app.featureSetManager.getCollectionById(this._fscRootID);
                            }
                            if (!this._fsc) {
                                this._fsc = new infrastructure.FeatureSetCollection();
                                this._fsc.id = this._fscRootID;
                                this._fsc.sourceName = this._fscSourceName;
                                this.app.featureSetManager.addCollection(this._fsc);
                            }
                            else {
                                // GVH-3835 If the search collection has been removed, add it back.
                                if (!this.app.featureSetManager.getCollectionById(this._fsc.id)) {
                                    this.app.featureSetManager.addCollection(this._fsc);
                                }
                                // We want to close the manager so that new search will make the consumer of the featureset know that it needs to process new results
                                this._fsc.clear();
                                this.app.featureSetManager.tryCloseCollection(this._fsc.id);
                            }
                        };
                        /**
                         * Returns a collection of strings that match or are related to the provided search text.
                         * This is typically used for auto-complete dropdown boxes.
                         * @param hints The collection of hints. This collection should be manipulated (added) to by the implementation.
                         * @param searchText The text the user is searching on.
                         */
                        SearchManager.prototype.getSearchHints = function (hints, searchText) {
                            // This will get the list of providers currently enabled. It will also make sure that if we're offline, those provider support offline.
                            var providers = this._enabledProviders();
                            // If no enabled provider, nothing to do
                            if (providers.length == 0) {
                                this.app.trace.warning("No search providers enabled.");
                                return;
                            }
                            // Search hints using each enabled search provider. It's up to the provider to implement search hints asynchronously.
                            for (var i = 0; i < providers.length; i++) {
                                if (providers[i].supportsHints) {
                                    var hintProvider = providers[i];
                                    hintProvider.getSearchHints(hints, searchText);
                                }
                            }
                        };
                        /** @private Registers some view-related commands. */
                        SearchManager.prototype._registerCommands = function () {
                            // Command to Register a search provider
                            this.app.command("RegisterSearchProvider").register(this, this._registerProvider);
                            // Command to Performs a search on all active providers
                            this.app.command("Search").register(this, this._search);
                            // Overload to be compatible with GVS
                            this.app.command("GlobalSearch").register(this, this._search);
                            // Command to Cancel the search on all providers
                            this.app.command("CancelSearch").register(this, this._cancelSearch);
                            this.app.command("ClearSearch").register(this, this._clearSearch);
                        };
                        /** @private Registers a provider if not already registered.
                        * @param searchProvider An array of search providers
                        */
                        SearchManager.prototype._registerProvider = function (searchProvider) {
                            if (!searchProvider) {
                                throw new Error("Search Provider cannot be null.");
                            }
                            // Check if it's already registered
                            for (var i = 0; i < this._searchProviders.length; i++) {
                                var provider = this._searchProviders[i];
                                if (provider.id == searchProvider.id) {
                                    throw new Error("Search Provider '{0}' already registered.".format(searchProvider.name));
                                }
                            }
                            // Add the provider to the list
                            this._searchProviders.push(searchProvider);
                        };
                        /** @private Return an array of providers that are currently enabled and if offline, that support offline searches. */
                        SearchManager.prototype._enabledProviders = function () {
                            var providers = [];
                            for (var i = 0; i < this._searchProviders.length; i++) {
                                var provider = this._searchProviders[i];
                                if (provider.isEnabled) {
                                    if (this.app.isOffline.get() === true) {
                                        if (provider.supportsOffline) {
                                            providers.push(provider);
                                        }
                                    }
                                    else {
                                        providers.push(provider);
                                    }
                                }
                            }
                            return providers;
                        };
                        /** @private Indicates if any of the registered provider is currently searching. */
                        SearchManager.prototype._isSearching = function () {
                            // Check if any of the provider is currently searching
                            for (var i = 0; i < this._searchProviders.length; i++) {
                                var provider = this._searchProviders[i];
                                // Is it searching?
                                if (provider.status == geocortex.essentialsHtmlViewer.mapping.infrastructure.search.Status.SEARCHING) {
                                    return true;
                                }
                            }
                            return false;
                        };
                        /** @private Handler to cancel a search */
                        SearchManager.prototype._cancelSearch = function () {
                            if (!this._isSearching()) {
                                return;
                            }
                            // We need to cancel the search on all providers currently searching
                            for (var i = 0; i < this._searchProviders.length; i++) {
                                var provider = this._searchProviders[i];
                                if (provider.status == geocortex.essentialsHtmlViewer.mapping.infrastructure.search.Status.SEARCHING) {
                                    provider.cancelSearch();
                                }
                            }
                        };
                        /** @private Clear all the search results */
                        SearchManager.prototype._clearSearch = function () {
                            if (this._isSearching()) {
                                this._cancelSearch();
                            }
                            this._resetFeatureSetCollection();
                        };
                        /**
                         * @private Handler to start a search
                         * @param searchText Text to be searched
                         */
                        SearchManager.prototype._search = function (searchText) {
                            // Only one search at the time
                            if (this._isSearching()) {
                                this._cancelSearch();
                            }
                            this._resetFeatureSetCollection();
                            // Search text must be provided
                            if (!searchText || searchText.replace(/ /g, "") == "") {
                                this.app.trace.warning("Cannot perform search without search text.");
                                return;
                            }
                            // This will get the list of providers currently enabled. It will also make sure that if we're offline, those provider support offline.
                            var providers = this._enabledProviders();
                            // If no enabled provider, nothing to do
                            if (providers.length == 0) {
                                this.app.trace.warning("No search providers enabled.");
                                return;
                            }
                            // TODO: A proper resource library for infrastructure strings/resources. The explicit use of "Mapping" here is less than ideal...
                            var searchManagerFscDisplayName = this.app.getResource("Mapping", "language-search-fsc-display-name");
                            this._fsc.displayName.set(searchManagerFscDisplayName.format(searchText));
                            // If the collection is not open, open it
                            if (!this.app.featureSetManager.isCollectionOpen(this._fsc.id)) {
                                this.app.featureSetManager.openCollection(this._fsc.id);
                            }
                            for (var i = 0; i < providers.length; i++) {
                                providers[i].search(this._fsc, searchText);
                            }
                        };
                        /**
                         * @private Handles the search progress event
                         * @param searchProgress Indicates the status of search operation
                         */
                        SearchManager.prototype._searchProgress = function (searchProgress) {
                            var canClose = true;
                            // If it's not searching, check if we should close the feature set collection
                            if (searchProgress.status != geocortex.essentialsHtmlViewer.mapping.infrastructure.search.Status.SEARCHING) {
                                for (var i = 0; i < this._searchProviders.length; i++) {
                                    var provider = this._searchProviders[i];
                                    // If any of the providers is still searching, we can't close the FSC
                                    if (provider.status == geocortex.essentialsHtmlViewer.mapping.infrastructure.search.Status.SEARCHING) {
                                        canClose = false;
                                    }
                                }
                                if (canClose) {
                                    this.app.featureSetManager.tryCloseCollection(searchProgress.results.id);
                                }
                            }
                        };
                        return SearchManager;
                    }());
                    search.SearchManager = SearchManager;
                })(search = infrastructure.search || (infrastructure.search = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/Framework.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var menus;
                (function (menus) {
                    /**
                     * BatchItemModel provides a general purpose, loosely coupled model for individual batch items within a batch.
                     */
                    var BatchItemModel = (function () {
                        /**
                         * Initializes a new instance of the BatchItemModel class.
                         * @param app The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this batch item belongs to.
                         * @param config A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.BatchItemConfig} object to configure this batch item.
                         */
                        function BatchItemModel(app, config) {
                            if (!config || !config.command) {
                                app && app.trace.warning("BatchItemModel: Could not create batch item. Configuration or command not specified.");
                                return;
                            }
                            this.app = app;
                            this.command = app.command(config.command);
                            this.commandParameter = config.commandParameter || null;
                            this.abortBatchOnFailure = !!config.abortBatchOnFailure;
                        }
                        return BatchItemModel;
                    }());
                    menus.BatchItemModel = BatchItemModel;
                })(menus = infrastructure.menus || (infrastructure.menus = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/Framework.d.ts"/>
/// <reference path="../../../_Definitions/dojo.d.ts"/>
/// <reference path="./BatchItemModel.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var menus;
                (function (menus) {
                    /**
                     * MenuItemModel provides a general purpose, loosely coupled model for an individual menu item contained in a menu.
                     */
                    var MenuItemModel = (function () {
                        /**
                         * Initializes a new instance of the MenuItemModel class.
                         * @param menuModel The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuModel} that this MenuItemModel is a member of.
                         * @param config The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuItemConfig} configuration for this MenuItemModel.
                         */
                        function MenuItemModel(menuModel, config) {
                            var _this = this;
                            if (!menuModel || !config) {
                                throw new Error("MenuItemModel: Required input parameters cannot be undefined");
                            }
                            this.menuModel = menuModel;
                            this.app = menuModel.app;
                            this.text = config.text || "";
                            this.description = config.description || "";
                            this.iconUri = config.iconUri || this.menuModel.defaultIconUri;
                            this.hideOnDisable = (config.hideOnDisable != undefined) ? config.hideOnDisable : false;
                            if (config.batch) {
                                this.batchItems = [];
                                this._setBatchItems(config.batch);
                            }
                            else if (config.command) {
                                this.command = this.app.command(config.command);
                                this.commandParameter = config.commandParameter || null;
                            }
                            if (config.libraryId) {
                                geocortex.framework.ui.stringLocalizer.localizeString(this.app, config.libraryId, this.text, function (val) { return _this.text = val; });
                                geocortex.framework.ui.stringLocalizer.localizeString(this.app, config.libraryId, this.description, function (val) { return _this.description = val; });
                            }
                        }
                        /**
                         * Sets the batch items for the menu item.
                         * @param batch A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.BatchItemConfig} object to provide configuration details for
                         *              the batch commands (if any) associated with this menu item.
                         */
                        MenuItemModel.prototype._setBatchItems = function (batch) {
                            var _this = this;
                            if (batch && batch.length) {
                                batch.forEach(function (batchItem) {
                                    if (batchItem && batchItem.command) {
                                        _this.batchItems.push(new menus.BatchItemModel(_this.app, batchItem));
                                    }
                                });
                            }
                        };
                        return MenuItemModel;
                    }());
                    menus.MenuItemModel = MenuItemModel;
                })(menus = infrastructure.menus || (infrastructure.menus = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/Framework.d.ts"/>
/// <reference path="../../../_Definitions/dojo.d.ts"/>
/// <reference path="./MenuItemModel.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var menus;
                (function (menus) {
                    /**
                     * MenuModel provides a general purpose, loosely coupled model for defining menus that can be accessed by any module.
                     */
                    var MenuModel = (function () {
                        /**
                         * Initializes a new instance of the MenuModel class.
                         * @param app The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this menu belongs to.
                         * @param entry A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuEntryConfig} object to configure this menu.
                         */
                        function MenuModel(app, entry) {
                            if (!app || !entry || !entry.id) {
                                throw new Error("MenuModel: Required input parameters cannot be undefined");
                            }
                            this.app = app;
                            this.id = entry.id;
                            this.title = entry.title || "";
                            this.description = entry.description || "";
                            this.defaultIconUri = entry.defaultIconUri || "";
                            this.items = this._createMenuItems(entry.items);
                        }
                        /**
                         * Create menu items and populate the menu model based on the given configuration.
                         * @param items An array of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuItemConfig} objects to configure the menu items.
                         * @return An array of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuItemModel}  objects created based on the provided configuration.
                         */
                        MenuModel.prototype._createMenuItems = function (items) {
                            var _this = this;
                            var itemList = [];
                            if (items && items.length) {
                                items.forEach(function (item) {
                                    try {
                                        var menuItem = new geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuItemModel(_this, item);
                                        if (menuItem && (menuItem.command || menuItem.batchItems)) {
                                            itemList.push(menuItem);
                                        }
                                        else {
                                            _this.app.trace.warning("MenuModel: Could not create menu item for menu with id: {0}. Invalid configuration.".format(_this.id));
                                        }
                                    }
                                    catch (error) {
                                        _this.app.trace.warning("Unexpected configuration error: {0}".format(error.message));
                                    }
                                });
                            }
                            return itemList;
                        };
                        return MenuModel;
                    }());
                    menus.MenuModel = MenuModel;
                })(menus = infrastructure.menus || (infrastructure.menus = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts"/>
/// <reference path="./MenuModel.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var menus;
                (function (menus) {
                    /**
                     * MenuRegistry is a central management component for creating and accessing menu's from any module across the viewer.
                     */
                    var MenuRegistry = (function () {
                        /**
                         * Initializes a new instance of the MenuRegistry class.
                         * @param app The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this menu registry belongs to.
                         */
                        function MenuRegistry(app) {
                            /** An array containing references to all the menus registered in the system. */
                            this.menuList = [];
                            /** Array of viewId's mapped to their contained menu widget parameters. */
                            this._viewMenuEntries = {};
                            /** Array of configurations for each Menu. */
                            this._menuConfig = [];
                            this.app = app;
                        }
                        /**
                        * Creates and registers menu's based on the passed in configuration.
                        * @param config A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuConfig} configuration object.
                        */
                        MenuRegistry.prototype.loadMenus = function (config) {
                            var _this = this;
                            if (config && config.menus && config.menus.length) {
                                config.menus.forEach(function (menuEntry) { return _this.register(menuEntry); });
                                this._menuConfig = this._menuConfig.concat(config.menus);
                            }
                        };
                        /**
                        * Registers a menu, given from either a MenuEntryConfig or MenuModel object.
                        * @param menu The instance of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuModel} or {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuEntryConfig} to be registered.
                        */
                        MenuRegistry.prototype.register = function (menu) {
                            var menuId = menu && menu.id;
                            if (!this._validMenuId(menuId)) {
                                this.app.trace.warning("Could not register menu with id: {0}. Menu id should be defined and unique.".format(menuId));
                                return;
                            }
                            var menuToRegister = menu instanceof menus.MenuModel ? menu : new menus.MenuModel(this.app, menu);
                            if (this._validateMenuModel(menuToRegister)) {
                                this.menuList.push(menuToRegister);
                            }
                            else {
                                this.app.trace.warning("Could not register menu with id: {0}. Invalid menu configuration.".format(menuId));
                            }
                        };
                        /**
                         * Unregisters a menu.
                         * @param menuId The ID of the menu to be unregistered.
                         */
                        MenuRegistry.prototype.unregister = function (menuId) {
                            var lastIndex = this.menuList.length - 1;
                            for (var x = lastIndex; x >= 0; x--) {
                                if (this.menuList[x].id === menuId) {
                                    this.menuList.splice(x, 1);
                                }
                            }
                        };
                        /**
                         * Fetches a menu by id.
                         * @param {string} Unique id of the menu.
                         * @return The requested {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuModel} object or null if not found.
                         */
                        MenuRegistry.prototype.getMenu = function (id) {
                            var menuItems = this.menuList;
                            for (var x = 0; x < menuItems.length; x++) {
                                if (menuItems[x].id === id) {
                                    return menuItems[x];
                                }
                            }
                            return null;
                        };
                        /**
                         * Fetches the default icon URI for a given menu.
                         * @param {string} Id of the menu.
                         * @return the URI of default icon for given menu.
                         */
                        MenuRegistry.prototype.getDefaultIconUri = function (id) {
                            var menu = this.getMenu(id);
                            return (menu && menu.defaultIconUri) ? menu.defaultIconUri : "";
                        };
                        /**
                         * Given a view, returns descriptors of any menu widgets created by that view.
                         * @param view The {@link framework.ui.ViewBase} object whose associated menu widget(s) we want to retrieve.
                         * @return An array of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuWidgetParameters} objects containing the requested widget(s).
                         */
                        MenuRegistry.prototype.getMenuWidgetsForView = function (view) {
                            return this._viewMenuEntries[view.id] || [];
                        };
                        /**
                         * Generates a menu view based on dom attributes. The attributes that should be present on the DOM element being passed in are:
                         * - data-menu-id: (Required) This defines the menu to populate within the created menu view
                         * - data-menu-template: (Optional) If provided, this will be used as the template for the menu view being created. Default is Mapping/infrastructure/menus/MenuView.html
                         * - data-menu-type: (Optional) If provided, this will be used as the code behind for the menu view being created. Default is geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuView
                         * - data-menu-library-id: (Optional) If provided, this will be used as the library id for this menu View. This will override the manual libraryId input parameter if specified.
                         * - data-menu-hoist-disabled: (Optional) If present, the menu will not be hoisted.
                         * @param view The view that is requesting the menu widget.
                         * @param context The current context of the widget, if available.
                         * @param binding The binding expression passed in to the 'resolveWidget' method from which this method will typically be called.
                         * @param libraryId The library ID for the created menu widget.
                         * @return A {@link geocortex.framework.ui.ViewBase}, bound, view widget object.
                         */
                        MenuRegistry.prototype.createMenuWidget = function (view, context, binding, libraryId) {
                            var _this = this;
                            var domElement = binding.domElement;
                            var vm = binding.viewModel;
                            var menuId = domElement.getAttribute("data-menu-id");
                            if (!menuId || !this.getMenu(menuId)) {
                                console.log("Warning: Could not create menu view from DOM element attributes. Menu Id: {0} not registered with the MenuRegistry.".format(menuId));
                                return null;
                            }
                            var menuTemplate = domElement.getAttribute("data-menu-template") || "Mapping/infrastructure/menus/MenuView.html";
                            var menuTemplateType = domElement.getAttribute("data-menu-type") || "geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuView";
                            var menuLibraryId = domElement.getAttribute("data-menu-library-id") || libraryId || "Mapping"; // Default to "Mapping".
                            var hoistMenu = !domElement.hasAttribute("data-menu-hoist-disabled");
                            // While it's not necessary for the created view to be a `menus.MenuView`, it should at least have `menuContext`.
                            var widgetView = this.app.viewManager.createView({
                                typeName: menuTemplateType,
                                markupResource: menuTemplate,
                                isVisible: true
                            });
                            if (!widgetView) {
                                console.log("Warning: Could not create menu '{0}' for view '{1}': Could not construct the menu widget view.".format(menuId, view.id));
                                return null;
                            }
                            widgetView.app = this.app;
                            widgetView.configuration.menuId = menuId;
                            if (menuLibraryId) {
                                widgetView.libraryId = menuLibraryId;
                            }
                            var menuViewModel = new geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuViewModel(this.app, menuLibraryId);
                            menuViewModel.id = "MenuViewModel-{0}".format(widgetView.id);
                            menuViewModel.menuSourceView = view;
                            widgetView.attach(menuViewModel);
                            // If a specific context was passed into the widget, let's resolve it there.
                            // The context for the menu can be a regular object or a context object with multiple menu parameters. It may or may not be observable.
                            var menuContext = context;
                            if (context && context.isObservable) {
                                // If the value of the binding target, represented by the context here, is an observable itself, we'll just sync with it
                                menuViewModel.menuContext.sync(menuContext);
                            }
                            else {
                                // Note: The 'context' passed in to this function may be the value of an observable in the view model of the parent view hosting this widget.
                                // If so, we'll need to bind to the binding target observable so that if its updated, the menu context updates as well.
                                // If the binding target is not an observable, we'll just set it as the menu context.
                                if (vm && binding && vm[binding.target] && vm[binding.target].isObservable) {
                                    menuContext = vm[binding.target];
                                    menuViewModel.menuContext.sync(menuContext);
                                }
                                else {
                                    menuViewModel.menuContext.set(menuContext);
                                }
                            }
                            var menuEntry = {
                                view: view,
                                widgetView: widgetView,
                                widgetViewModel: menuViewModel,
                                context: menuContext,
                                menuId: menuId,
                                hoistMenu: hoistMenu,
                                domElement: domElement
                            };
                            if (!this._viewMenuEntries[view.id]) {
                                this._viewMenuEntries[view.id] = [];
                            }
                            // Store the reference to the view and the menu created. This allows other components to ask questions about menus for a particular view.
                            this._viewMenuEntries[view.id].push(menuEntry);
                            // Remove menu entries for views that are destroyed.
                            dojo.aspect.after(view, "onDestroy", function () { return _this._viewMenuEntries[view.id] = null; });
                            this.app.event("MenuWidgetCreatedForView").publish(menuEntry);
                            return widgetView;
                        };
                        /**
                         * Destroys the menu widget and all it's associated view model bindings and subscriptions. Automatically called when the widget view is destroyed.
                         * @param menuWidgetView The menu widget view to destroy.
                         */
                        MenuRegistry.prototype.destroyMenuWidget = function (menuWidgetView) {
                            var _this = this;
                            // Destroy the view model so all "auto" bindings are disposed off. This will also unbind all contained "MenuItemViewModel" bindings.
                            // Note: Do not destroy menuWidgetView here. This function is called when menuWidgetView is destroyed. Destroying it again will create a circular reference.
                            if (menuWidgetView.viewModel) {
                                menuWidgetView.viewModel.menuContext.removeSync();
                                menuWidgetView.viewModel.destroy();
                            }
                            // Remove the widget entry from _viewMenuEntries
                            for (var viewEntry in this._viewMenuEntries) {
                                if (!this._viewMenuEntries.hasOwnProperty(viewEntry) || this._viewMenuEntries[viewEntry] == null) {
                                    continue;
                                }
                                this._viewMenuEntries[viewEntry]
                                    .filter(function (widgetEntry) { return widgetEntry.widgetView === menuWidgetView; })
                                    .forEach(function (widgetEntry, index) {
                                    _this._viewMenuEntries[viewEntry].splice(index, 1);
                                });
                            }
                        };
                        /**
                         * Checks if a given menu id is valid or not. For a menu id to be valid, it should be unique i.e. there should be no exisiting menu's registered with the same name.
                         * @param id The menu ID to check for validity.
                         * @return A boolean which returns true if the given menu ID is valid; false otherwise.
                         */
                        MenuRegistry.prototype._validMenuId = function (id) {
                            var menuItems = id ? this.menuList.filter(function (menu) { return menu.id === id; }) : null;
                            return menuItems !== null && menuItems.length === 0;
                        };
                        /**
                         * Validates a given menu model to ensure that it meets the minimum requirements for a valid menu.
                         * @param menuModel The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuModel} object to validate.
                         * @return A boolean that returns true if the given MenuModel is valid; false otherwise.
                         */
                        MenuRegistry.prototype._validateMenuModel = function (menuModel) {
                            return !!(menuModel && menuModel.id && menuModel.items && menuModel.items.length);
                        };
                        return MenuRegistry;
                    }());
                    menus.MenuRegistry = MenuRegistry;
                })(menus = infrastructure.menus || (infrastructure.menus = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts"/>
/// <reference path="../../../_Definitions/dojo.d.ts"/>
/// <reference path="../../Viewer.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var tools;
                (function (tools) {
                    var ToolBase = (function () {
                        /**
                         * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.tools.ToolBase} class.
                         * @class
                         * <p>ToolBase provides a general purpose, loosely coupled model for creating components that have tool-like behavior.</p>
                         * @constructs
                         * @memberOf geocortex.essentialsHtmlViewer.mapping.infrastructure.tools
                         * @param app The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this tool belongs to.
                         * @param mixin An object to provide additional configuration of this tool.
                         */
                        function ToolBase(app, mixin) {
                            /**
                             * The name of this tool.
                             * @type {string}
                             */
                            this.name = "";
                            /**
                             * Whether this tool is active.
                             * @type {boolean}
                             */
                            this.isActive = false;
                            dojo.mixin(this, mixin);
                            this.app = app;
                        }
                        /**
                         * Sets the active state of the tool.
                         * @param {boolean} active The desired active state of the tool.
                         */
                        ToolBase.prototype.setActive = function (active) {
                            if (active) {
                                this.isActive = true;
                                this.onActivated();
                            }
                            else {
                                this.isActive = false;
                                this.onDeactivated();
                            }
                        };
                        /**
                         * Called when the tool is activated.
                         */
                        ToolBase.prototype.onActivated = function () { };
                        /**
                         * Called when the tool is deactivated.
                         */
                        ToolBase.prototype.onDeactivated = function () { };
                        return ToolBase;
                    }());
                    tools.ToolBase = ToolBase;
                })(tools = infrastructure.tools || (infrastructure.tools = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts"/>
/// <reference path="./ToolBase.ts"/>
/// <reference path="../../Viewer.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var tools;
                (function (tools) {
                    var ToolRegistry = (function () {
                        /**
                         * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.tools.ToolRegistry} class.
                         * @class
                         * <p>ToolRegistry provides safe, loosely-coupled access to tools.</p>
                         * <p>A ToolRegistry instance should always be used when referencing tools.</p>
                         * @constructs
                         * @memberOf geocortex.essentialsHtmlViewer.mapping.infrastructure.tools
                         * @param app The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this tool registry belongs to.
                         */
                        function ToolRegistry(app) {
                            /**
                             * An object map of all referenced tools.
                             */
                            this.tools = {};
                            /**
                             * An object map of all event subscriptions for tools.
                             * @private
                             */
                            this._subscriptions = {};
                            /**
                             * A map of commands and their associated commands.
                             * @private
                             */
                            this._toolTypes = {};
                            this.app = app;
                            this._registerCommands();
                        }
                        /**
                         * Registers the tool registry command implementations.
                         * @private
                         */
                        ToolRegistry.prototype._registerCommands = function () {
                            var _this = this;
                            // SetActiveTool
                            this.app.command("SetActiveTool").register(this, function (toolName) { return _this.setActiveTool(toolName); }, function (toolName) { return _this._setActiveToolCanExecute(toolName); });
                            // ClearActiveTool
                            this.app.command("ClearActiveTool").register(this, function () { return _this.clearActiveTool(); });
                        };
                        ToolRegistry.prototype._setActiveToolCanExecute = function (toolName) {
                            if (!this.tool(toolName)) {
                                return false;
                            }
                            return true;
                        };
                        /**
                         * Clears the active tool.
                         */
                        ToolRegistry.prototype.clearActiveTool = function () {
                            for (var ix in this.tools) {
                                if (!this.tools.hasOwnProperty(ix)) {
                                    continue;
                                }
                                var tool = this.tools[ix];
                                if (tool && tool.isActive) {
                                    tool.setActive(false);
                                }
                            }
                        };
                        /**
                         * Gets the active tool.
                         */
                        ToolRegistry.prototype.getActiveTool = function () {
                            for (var ix in this.tools) {
                                if (!this.tools.hasOwnProperty(ix)) {
                                    continue;
                                }
                                var tool = this.tools[ix];
                                if (tool && tool.isActive) {
                                    return tool;
                                }
                            }
                            return null;
                        };
                        /**
                         * Sets the active tool.
                         * @param {string} name The name of the tool to activate.
                         */
                        ToolRegistry.prototype.setActiveTool = function (name) {
                            this.clearActiveTool();
                            if (name) {
                                var tool = this.tool(name);
                                if (tool) {
                                    tool.setActive(true);
                                }
                                else {
                                    this.app.trace.warning("Could not activate tool '{0}'. The tool does not exist in the registry.".format(name));
                                }
                            }
                        };
                        /**
                         * Fetches a tool by name.
                         * @param {string} name The name of the tool to fetch.
                         */
                        ToolRegistry.prototype.tool = function (name) {
                            return this.tools[name];
                        };
                        /**
                         * Registers a tool. The tool must specify a name.
                         * @param tool The tool to register.
                         */
                        ToolRegistry.prototype.register = function (tool) {
                            var _this = this;
                            // Unregister it
                            this.unregister(tool);
                            if (tool && tool.name) {
                                this.tools[tool.name] = tool;
                                // Subscribe to the setActive method to ensure that only a single tool is active
                                this._subscriptions[tool.name] = dojo.connect(tool, "setActive", function (active) {
                                    // this will be in the scope of the tool
                                    if (active === true) {
                                        for (var ix in _this.tools) {
                                            if (!_this.hasOwnProperty(ix)) {
                                                continue;
                                            }
                                            var existingTool = _this.tools[ix];
                                            // Disable any active tools other than the one just made active
                                            if (existingTool && existingTool != tool && existingTool.isActive) {
                                                existingTool.setActive(false);
                                            }
                                        }
                                        // Raise active tool changed event
                                        // ActiveToolChanged is deprecated since version 1.1. You should now use ActiveToolChangedEvent.
                                        _this.app.event("ActiveToolChanged").publish({ "tool": tool, "previousTool": null });
                                        _this.app.event("ActiveToolChanged").publish({ "tool": tool, "previousTool": null });
                                        _this.app.event("ActiveToolChangedEvent").publish({ "tool": tool, "previousTool": null });
                                        if (tool instanceof tools.MapTool) {
                                            _this.app.event("ToolCommandActivatedEvent").publish(tool.command);
                                        }
                                    }
                                    else if (!_this.getActiveTool()) {
                                        // Raise active tool changed event
                                        _this.app.event("ActiveToolChanged").publish({ "tool": null, "previousTool": tool });
                                        _this.app.event("ActiveToolChangedEvent").publish({ "tool": null, "previousTool": tool });
                                        if (tool instanceof tools.MapTool) {
                                            _this.app.event("ToolCommandDeactivatedEvent").publish(tool.command);
                                        }
                                    }
                                });
                            }
                        };
                        /**
                         * Unregisters a tool.
                         * @param tool The tool to unregister.
                         */
                        ToolRegistry.prototype.unregister = function (tool) {
                            if (tool && tool.name && this.tools[tool.name] == tool) {
                                this.tools[tool.name] = null;
                                // Unsubscribe
                                var sub = this._subscriptions[tool.name];
                                if (sub) {
                                    dojo.disconnect(sub);
                                    this._subscriptions[tool.name] = null;
                                }
                            }
                        };
                        /**
                         * Unregisters all tools in the registry.
                         */
                        ToolRegistry.prototype.clear = function () {
                            for (var ix in this.tools) {
                                var tool = this.tools[ix];
                                if (tool) {
                                    this.unregister(tool);
                                }
                            }
                        };
                        /**
                         * Creates and optionally registers the tools specified by a configuration block. Only named tools will be registered.
                         * @param config An array of tool configuration objects.
                         * @param {boolean} registerTools A flag indicating whether to register the tool with the registry.
                         * @return An array of tool objects.
                         */
                        ToolRegistry.prototype.createTools = function (config, registerTools) {
                            var _this = this;
                            var results = [];
                            // Register configured tools
                            if (config) {
                                config.forEach(function (entry) {
                                    // Get the type. If not specified, default to MapTool.
                                    var toolTypeName = entry.typeName ? entry.typeName : "geocortex.essentialsHtmlViewer.mapping.infrastructure.tools.MapTool";
                                    // Is there a specific tool type associated with this particular tool command?
                                    if (_this._toolTypes.hasOwnProperty(entry.command)) {
                                        toolTypeName = _this._toolTypes[entry.command];
                                    }
                                    // Get the .ctor
                                    var ctor = dojo.getObject(toolTypeName);
                                    if (ctor) {
                                        // Create an instance of the tool
                                        var tool = new ctor(_this.app, entry);
                                        results.push(tool);
                                        // Register the tool
                                        if (registerTools) {
                                            _this.register(tool);
                                        }
                                    }
                                    else {
                                        _this.app.trace.warning("Could not create tool '{0}' from type name '{1}'.".format(entry.name, toolTypeName));
                                    }
                                });
                            }
                            return results;
                        };
                        /**
                         * Associates a command with a tool type, allowing tool subtypes to be created and invoked for certain tool commands.
                         * @param commandName The name of the command to associate with a tool subtype.
                         * @param toolTypeName The name of the tool type to associate with the command.
                         */
                        ToolRegistry.prototype.registerToolTypeForCommand = function (commandName, toolTypeName) {
                            this._toolTypes[commandName] = toolTypeName;
                        };
                        return ToolRegistry;
                    }());
                    tools.ToolRegistry = ToolRegistry;
                })(tools = infrastructure.tools || (infrastructure.tools = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../_Definitions/framework.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                /**
                 * Note: This is for single argument commands only. Multiple argument commands should be phased out and avoided.
                 * @docs-hide-from-nav
                 * @private
                 */
                var CommandViewModel = (function (_super) {
                    __extends(CommandViewModel, _super);
                    /**
                     * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.command.CommandViewModel} class.
                     * @class
                     * <p> CommandViewModel presents the generic commands along with its attributes such as command parameters.</p>
                     * @constructs
                     * @param app The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this command belongs to.
                     * @param libraryId The ID of the library this component belongs to.
                     * @param commandName The name of the command
                     * @param commandParameter The parameter associated with this command.
                     */
                    function CommandViewModel(app, libraryId, commandName, commandParameter) {
                        _super.call(this, app, libraryId);
                        /** Name of the command. */
                        this.commandName = "";
                        /** The command parameter, as configured. */
                        this.commandParameter = null;
                        /** Indicates whether the command can currently execute or not. */
                        this.canExecute = new Observable(true);
                        this.notExecuteHidden = new Observable(false);
                        if (commandName) {
                            this._bindToCommand(commandName, commandParameter);
                        }
                    }
                    /**
                     * Applies a new contextual parameter to this command.
                     * @param context
                     */
                    CommandViewModel.prototype.applyContext = function (context) {
                        if (this._command && context) {
                            this.canExecute.set(this._command.canExecute(context));
                        }
                    };
                    /**
                     * @private
                     * Binds to a command by name.
                     */
                    CommandViewModel.prototype._bindToCommand = function (commandName, commandParameter) {
                        if (this._canExecuteChangedBindingToken && this._command) {
                            this._command.canExecuteChanged.unsubscribe(this._canExecuteChangedBindingToken);
                        }
                        this.commandName = commandName;
                        this.commandParameter = commandParameter || null;
                        // Hold reference to the actual command itself. Note that if it doesn't exist, it will be created just by referencing it.
                        this._command = this.app.command(commandName);
                        this._canExecuteChangedBindingToken = this._command.canExecuteChanged.subscribe(this, this._handleCanExecuteChanged);
                        // Evaluate the actual canExecute state.
                        this.canExecute.set(this._command.canExecute(commandParameter));
                    };
                    /**
                     * @private
                     * Handles a "CanExecuteChanged" event for non batch commands.
                     */
                    CommandViewModel.prototype._handleCanExecuteChanged = function () {
                        this.canExecute.set(this._command.canExecute(this.commandParameter));
                    };
                    return CommandViewModel;
                }(geocortex.framework.ui.ViewModelBase));
                infrastructure.CommandViewModel = CommandViewModel;
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/**
/* Namespace for CommandViewModel changed from geocortex.essentialsHtmlViewer.mapping.modules.command.CommandViewModel
 * to geocortex.essentialsHtmlViewer.mapping.infrastructure.CommandViewModel
 * The namespace is duplicated below to be backwards compatible with third party code.
 * @private
 * @deprecated 2.4
 */
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var modules;
            (function (modules) {
                var command;
                (function (command) {
                    command.CommandViewModel = geocortex.essentialsHtmlViewer.mapping.infrastructure.CommandViewModel;
                })(command = modules.command || (modules.command = {}));
            })(modules = mapping.modules || (mapping.modules = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts"/>
/// <reference path="../CommandViewModel.ts"/>
/// <reference path="./ToolbarGroupRegistry.ts"/>
/// <reference path="../../Viewer.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var toolbarGroup;
                (function (toolbarGroup) {
                    var ToolbarGroupItemBase = (function () {
                        function ToolbarGroupItemBase(app, libraryId, entry) {
                            /**
                             * The library used for resource obtaining.
                             */
                            this.libraryId = "";
                            /**
                             * True if the item is active
                             */
                            this.isActive = new Observable(true);
                            /**
                             * True if the item has an associated transient that is currently visible.
                             */
                            this.activeTransient = new Observable(false);
                            /**
                             * True if disabled
                             */
                            this.disabled = new Observable(false);
                            /**
                              * True if disabled and hideOnDisable = true
                            */
                            this.hidden = new Observable(false);
                            /**
                             * Associated css class.
                             */
                            this.cssClass = new Observable();
                            /**
                             * Whether the tool has the ability to be displayed as small..
                             */
                            this.hasSmallLayout = new Observable(false);
                            /**
                             * Currently selected tool. (Flyout specific)
                             */
                            this.selectedTool = new Observable(null);
                            /**
                             * Whether the multitool flyout is open. (Flyout specific)
                             */
                            this.toolChangeActive = new Observable(false);
                            if (!entry) {
                                return;
                            }
                            this.id = entry.id;
                            this.app = app;
                            this.libraryId = libraryId;
                            this.type = entry.type;
                            this.name = new Observable(entry.name);
                            this.tooltip = new Observable(entry.tooltip || null);
                            this.hideOnDisable = new Observable(!!entry.hideOnDisable);
                            if (entry.libraryId) {
                                geocortex.framework.ui.stringLocalizer.localizeObservables(app, entry.libraryId, [this.name, this.tooltip]);
                            }
                        }
                        ToolbarGroupItemBase.prototype.areAllHidden = function (items) {
                            for (var i = 0; i < items.length(); i++) {
                                if ((items.getAt(i).disabled.get() === false) || (items.getAt(i).hideOnDisable.get() === false)) {
                                    return false;
                                }
                            }
                            return true;
                        };
                        ToolbarGroupItemBase.prototype.setHidden = function () {
                            if (this.disabled.get() === true && this.hideOnDisable.get() === true) {
                                this.hidden.set(true);
                            }
                            else {
                                this.hidden.set(false);
                            }
                        };
                        /*
                         * Empty abstract class for execution capability of Tools and Buttons.
                         */
                        ToolbarGroupItemBase.prototype.execute = function () {
                        };
                        ToolbarGroupItemBase.prototype.activate = function () {
                            this.isActive.set(true);
                        };
                        ToolbarGroupItemBase.prototype.deactivate = function () {
                            this.isActive.set(false);
                            this.activeTransient.set(false);
                        };
                        ToolbarGroupItemBase.prototype.onDestroy = function () {
                        };
                        return ToolbarGroupItemBase;
                    }());
                    toolbarGroup.ToolbarGroupItemBase = ToolbarGroupItemBase;
                })(toolbarGroup = infrastructure.toolbarGroup || (infrastructure.toolbarGroup = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts"/>
/// <reference path="../../Viewer.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var toolbarGroup;
                (function (toolbarGroup) {
                    var ToolbarGroupBase = (function () {
                        function ToolbarGroupBase(app, libraryId, entry) {
                            this.libraryId = "";
                            this.isActive = new Observable(false);
                            this.disabled = new Observable(false);
                            this.cssClass = new Observable();
                            this.app = app;
                            this.libraryId = libraryId;
                            if (entry) {
                                this.name = new Observable(entry.name);
                                this.id = entry.id || entry.name || geocortex.framework.utils.alphaNumericToken();
                                this.tooltip = new Observable(entry.tooltip || null);
                                this.type = entry.type || "toolbarGroup";
                                this.isDefault = !!entry.isDefault;
                                this.items = entry.items ? this.getToolbarGroupItems(entry.items) : new ObservableCollection();
                                if (entry.libraryId) {
                                    geocortex.framework.ui.stringLocalizer.localizeObservables(app, entry.libraryId, [this.name, this.tooltip]);
                                }
                            }
                        }
                        ToolbarGroupBase.prototype.getToolbarGroupItems = function (items) {
                            var itemsList = new ObservableCollection();
                            for (var i = 0; i < items.length; i++) {
                                var toolbarGroupItem = null;
                                // TODO: Make class names shorter.
                                if (items[i].type == "button") {
                                    toolbarGroupItem = new toolbarGroup.ToolbarButton(this.app, this.libraryId, items[i]);
                                }
                                else if (items[i].type == "toggleButton") {
                                    toolbarGroupItem = new toolbarGroup.ToolbarToggleButton(this.app, this.libraryId, items[i]);
                                }
                                else if (items[i].type == "region") {
                                    toolbarGroupItem = new toolbarGroup.ToolbarRegion(this.app, this.libraryId, items[i]);
                                }
                                else if (items[i].type == "tool") {
                                    toolbarGroupItem = new toolbarGroup.ToolbarTool(this.app, this.libraryId, items[i]);
                                }
                                else if (items[i].type == "toolbarGroup") {
                                    toolbarGroupItem = new toolbarGroup.ToolbarGroup(this.app, this.libraryId, items[i]);
                                }
                                else if (items[i].type == "flyout") {
                                    toolbarGroupItem = new toolbarGroup.ToolbarFlyout(this.app, this.libraryId, items[i]);
                                }
                                itemsList.addItem(toolbarGroupItem);
                            }
                            return itemsList;
                        };
                        return ToolbarGroupBase;
                    }());
                    toolbarGroup.ToolbarGroupBase = ToolbarGroupBase;
                })(toolbarGroup = infrastructure.toolbarGroup || (infrastructure.toolbarGroup = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts"/>
/// <reference path="./ToolbarGroupItemBase.ts"/>
/// <reference path="./ToolbarGroupBase.ts"/>
/// <reference path="../../Viewer.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var toolbarGroup;
                (function (toolbarGroup_1) {
                    var ToolbarGroupRegistry = (function () {
                        function ToolbarGroupRegistry(app) {
                            /**
                             * An array consisting of all referenced toolbargroups
                             * @type {geocortex.essentialsHtmlViewer.mapping.infrastructure.toolbar.toolbarGroupBase}
                             */
                            this.toolbarGroupList = new ObservableCollection();
                            /**
                             * Config object containing toolbar groups configuration
                             * @private
                             */
                            this._toolbarGroupsConfig = [];
                            this.app = app;
                        }
                        /**
                         * Fetch a new instance of toolbar group instance by id
                         * @param id Id of the toolbarGroup
                         */
                        ToolbarGroupRegistry.prototype.getToolbarGroupById = function (id) {
                            if (this.toolbarGroupList.get().length === 0 || id === null) {
                                return null;
                            }
                            for (var i = 0; i < this.toolbarGroupList.get().length; i++) {
                                if (this.toolbarGroupList.getAt(i).id == id) {
                                    return this.toolbarGroupList.getAt(i);
                                }
                            }
                            return null;
                        };
                        /**
                         * Registers a toolbar group
                         */
                        ToolbarGroupRegistry.prototype.registerToolbarGroups = function (toolbarGroups, libraryId) {
                            if (!toolbarGroups) {
                                return;
                            }
                            for (var i = 0; i < toolbarGroups.length; i++) {
                                var group = toolbarGroups[i];
                                var toolbarGroup = new geocortex.essentialsHtmlViewer.mapping.infrastructure.toolbarGroup.ToolbarGroupBase(this.app, libraryId, group);
                                this._toolbarGroupsConfig.push(group);
                                this.unregisterToolbarGroup(group.id);
                                this.toolbarGroupList.addItem(toolbarGroup);
                            }
                        };
                        /**
                         * Unregister the group with the given id if it is registered.
                         * @param id {String} Id of the toolbar group to be unregistered
                         */
                        ToolbarGroupRegistry.prototype.unregisterToolbarGroup = function (id) {
                            var index = this.getPosition(id);
                            if (index != null) {
                                this.toolbarGroupList.get().splice(index, 1);
                            }
                        };
                        /**
                         * Fetches the position of toolbar group in the list
                         * @param id {String} Id of the toolbar group whose position is to be determined
                         */
                        ToolbarGroupRegistry.prototype.getPosition = function (id) {
                            for (var i = 0; i < this.toolbarGroupList.getLength(); i++) {
                                if ((this.toolbarGroupList.getAt(i).id === id)) {
                                    return i;
                                }
                            }
                            return null;
                        };
                        return ToolbarGroupRegistry;
                    }());
                    toolbarGroup_1.ToolbarGroupRegistry = ToolbarGroupRegistry;
                })(toolbarGroup = infrastructure.toolbarGroup || (infrastructure.toolbarGroup = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts"/>
/// <reference path="../../../_Definitions/bluebird.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var undo;
                (function (undo) {
                    /** Indicates the status of the {@link UndoManager} */
                    var Status;
                    (function (Status) {
                        /** The {@link UndoManager} is idle. */
                        Status.IDLE = "Idle";
                        /** The {@link UndoManager} is undoing. */
                        Status.UNDOING = "Undoing";
                        /** The {@link UndoManager} is redoing. */
                        Status.REDOING = "Redoing";
                        /** The {@link UndoManager} is committing an open transaction. */
                        Status.COMMITTING = "Committing";
                        /** The {@link UndoManager} is rolling back an open transaction. */
                        Status.ROLLINGBACK = "RollingBack";
                    })(Status = undo.Status || (undo.Status = {}));
                    /**
                     * The UndoManager is a utility object that allows you to easily build applications with undo/redo functionality.
                     * Use the UndoManager to add actions (edits, navigation changes, graphics drawing) to the stack. The API includes
                     * a set of edit operations (add, delete, update, cut and union), created by inheriting from the {@link Undoable} class.
                     * You can inherit from the {@link Undoable} class to create custom operations that take advantage of undo/redo.
                     */
                    var UndoManager = (function () {
                        /**
                         * Initializes a new instance of the {@link UndoManager} class.
                         * @param app The {@link framework.application.Application} that this instance belongs to.
                         * @param options Optional configuration settings for this instance.
                         */
                        function UndoManager(app, options) {
                            /** The maximum number of operations the {@link UndoManager} can perform. If a number less than or equal to zero is provided the number of operations is unlimited. */
                            this.maxOperations = 0;
                            /** Whether the recording of {@link Undoable} instances in the undo history has been suspended using the Suspend method. */
                            this.isSuspended = false;
                            /** Whether the {@link UndoManager} is undoing. */
                            this.isUndoing = false;
                            /** Whether the {@link UndoManager} is redoing. */
                            this.isRedoing = false;
                            /** When true, there are redo operations available on the stack. */
                            this.canRedo = false;
                            /** When true, there are undo operations available on the stack. */
                            this.canUndo = false;
                            /** The number of operations stored in the history stack. */
                            this.length = 0;
                            /** The current operation position. */
                            this.position = 0;
                            /** Returns the outermost current open transaction or null if there is currently no transaction open. */
                            this.rootTransaction = null;
                            this._status = infrastructure.undo.Status.IDLE;
                            this._historyStack = [];
                            this.app = app;
                            options = options || {};
                            if (typeof options.maxOperations == "number") {
                                this.setMaxOperations(options.maxOperations);
                            }
                            this.registerCommands();
                        }
                        UndoManager.prototype.registerCommands = function () {
                            var _this = this;
                            this.app.command("Undo").register(this, this.undo, function (x) { return _this.canUndo; });
                            this.app.command("Redo").register(this, this.redo, function (x) { return _this.canRedo; });
                        };
                        /** Suspends the recording of {@link Undoable} instances in the undo history. */
                        UndoManager.prototype.suspend = function () {
                            this.isSuspended = true;
                        };
                        /** Resumes the recording of {@link Undoable} instances in the undo history. */
                        UndoManager.prototype.resume = function () {
                            this.isSuspended = false;
                        };
                        /**
                         * Sets the maximum number of operations the {@link UndoManager} can perform.
                         * If a number less than or equal to zero is provided the number of operations is unlimited.
                         * @param limit The operation limit
                         */
                        UndoManager.prototype.setMaxOperations = function (limit) {
                            this.maxOperations = limit;
                        };
                        /**
                         * Returns an object with the following properties that describe the current state of the {@link UndoManager}: `historyStack`, `position`.
                         */
                        UndoManager.prototype.getCurrentState = function () {
                            // Return a shallow copy of our internal state
                            return {
                                historyStack: (this._historyStack || []).slice(),
                                position: this.position,
                                rootTransaction: this.rootTransaction,
                                status: this._status
                            };
                        };
                        /**
                         * Adds an undo operation to the stack and clears the redo stack.
                         * The redo stack’s contents last as long as undo and redo are performed successively.
                         * However, because applying a new change to an object invalidates the previous changes,
                         * as soon as a new undo operation is registered, any existing redo stack is cleared.
                         * This prevents redo from returning objects to an inappropriate prior state.
                         * @param operation An operation to add to the stack.
                         */
                        UndoManager.prototype.add = function (operation) {
                            if (!operation) {
                                throw new Error("Undo operation cannot be null");
                            }
                            // If limit is set, discard items from the bottom of the stack (oldest) to make room for new operations
                            while (this.maxOperations > 0 && this._historyStack.length >= this.maxOperations) {
                                var discarded = this._historyStack.shift();
                                this.app.event("UndoOperationDiscardedEvent").publish({ sender: this, operation: discarded });
                            }
                            // Push new operation to the stack; set current position
                            this._historyStack.splice(this.position, 0, operation);
                            this.position++;
                            // If we are here after having called undo, invalidate items higher on the stack
                            this.clearRedo();
                            // Raise on-add event
                            this.app.event("UndoOperationAddedEvent").publish({ sender: this, operation: operation });
                            this._checkAvailability();
                        };
                        /**
                         * Moves the current position to the next undo operation and calls the operation's `performUndo` method.
                         */
                        UndoManager.prototype.undo = function () {
                            var _this = this;
                            if (this.position === 0) {
                                return Promise.resolve();
                            }
                            // Change internal status to Undoing then to Idle
                            var undoable = this.peekUndo();
                            this.position--;
                            if (!undoable || typeof undoable.performUndo !== "function") {
                                return Promise.resolve();
                            }
                            // Raise undo-started event
                            this._updateStatus(infrastructure.undo.Status.UNDOING);
                            this.app.event("UndoStartedEvent").publish({ sender: this, operation: undoable });
                            return undoable.performUndo(undoable.state)
                                .lastly(function () {
                                // Raise undo-completed event
                                _this._updateStatus(infrastructure.undo.Status.IDLE);
                                _this.app.event("UndoCompletedEvent").publish({ sender: _this, operation: undoable });
                                _this._checkAvailability();
                            });
                        };
                        /**
                         * Moves the current position to the next redo operation and calls the operation's `performRedo` method.
                         */
                        UndoManager.prototype.redo = function () {
                            var _this = this;
                            if (this.position === this._historyStack.length) {
                                return Promise.resolve();
                            }
                            // Change internal status to Redoing then to Idle
                            var undoable = this.peekRedo();
                            this.position++;
                            if (!undoable || typeof undoable.performRedo !== "function") {
                                return Promise.resolve();
                            }
                            // Raise redo-started event
                            this._updateStatus(infrastructure.undo.Status.REDOING);
                            this.app.event("RedoStartedEvent").publish({ sender: this, operation: undoable });
                            return undoable.performRedo(undoable.state)
                                .lastly(function () {
                                // Raise redo-completed event
                                _this._updateStatus(infrastructure.undo.Status.IDLE);
                                _this.app.event("RedoCompletedEvent").publish({ sender: _this, operation: undoable });
                                _this._checkAvailability();
                            });
                        };
                        /**
                         * Gets the next undo operation from the stack.
                         */
                        UndoManager.prototype.peekUndo = function () {
                            if (this._historyStack.length > 0 && this.position > 0) {
                                return this.getAt(this.position - 1);
                            }
                            return null;
                        };
                        /**
                         * Gets the next redo operation from the stack.
                         */
                        UndoManager.prototype.peekRedo = function () {
                            if (this._historyStack.length > 0 && this.position < this._historyStack.length) {
                                return this.getAt(this.position);
                            }
                            return null;
                        };
                        /**
                         * Clears the undo stack.
                         */
                        UndoManager.prototype.clearUndo = function () {
                            this._historyStack.splice(0, this.position);
                            this.position = 0;
                            this._checkAvailability();
                        };
                        /**
                         * Clears the redo stack.
                         */
                        UndoManager.prototype.clearRedo = function () {
                            this._historyStack.splice(this.position, this._historyStack.length - this.position);
                            this.position = this._historyStack.length;
                            this._checkAvailability();
                        };
                        /**
                         * Gets the specified operation from the stack.
                         * @param index The index of the operation to return.
                         */
                        UndoManager.prototype.getAt = function (index) {
                            return this._historyStack[index];
                        };
                        /**
                         * Removes the specified operation from the stack.
                         * If the index is not valid or out of bounds, then nothing happens.
                         * @param index The index of the operation to remove.
                         */
                        UndoManager.prototype.removeAt = function (index) {
                            if (0 <= index && index < this._historyStack.length) {
                                this._historyStack.splice(index, 1);
                                if (this.position > 0 && this.position > index) {
                                    this.position--;
                                }
                                this._checkAvailability();
                            }
                        };
                        /**
                         * Starts a transaction for recording undo operations. Undo operations recorded while a {@link UndoTransaction} is open, are added
                         * to the {@link UndoManager} only if the transaction is committed. A rollback will undo, then discard the changes which where registered
                         * while the transaction was open.
                         * @param name A short string describing the transaction.
                         * @param parent The parent transaction (for nested transactions)
                         */
                        UndoManager.prototype.beginTransaction = function (name, parent) {
                            var transaction = new undo.UndoTransaction(this, name);
                            if (!this.rootTransaction) {
                                this.rootTransaction = transaction;
                            }
                            else {
                                transaction.parentTransaction = parent || this.rootTransaction;
                            }
                            return transaction;
                        };
                        /**
                         * Commits the provided transaction. Undo operations recorded while the {@link UndoTransaction} is open,
                         * are added to the {@link UndoManager} only if the transaction is committed. Committing a transaction will
                         * commit all transactions nested below it as well.
                         * You cannot roll back a transaction once it has been committed.
                         * @param transaction The transaction to commit.
                         */
                        UndoManager.prototype.commitTransaction = function (transaction) {
                            var _this = this;
                            transaction = transaction || this.rootTransaction;
                            if (!transaction) {
                                return Promise.reject(new Error("Cannot find the transaction to commit"));
                            }
                            if (transaction.isComplete()) {
                                return Promise.reject(new Error("Transaction has been closed already"));
                            }
                            transaction.transactionStatus = undo.TransactionStatus.COMMITTING;
                            // Return right away if no changes have been recorded...
                            if (!transaction.hasChanges()) {
                                transaction.transactionStatus = undo.TransactionStatus.COMMITTED;
                                this._onTransactionCommitted(transaction);
                                return Promise.resolve();
                            }
                            var commitOrRedo = function (current) {
                                if (current instanceof undo.UndoTransaction) {
                                    return current.isComplete() ? Promise.resolve() : current.commit();
                                }
                                if (current && typeof current.performRedo == "function") {
                                    return current.performRedo(current.state, transaction);
                                }
                            };
                            var reducer = function (_, current) {
                                return current ? commitOrRedo(current) : null;
                            };
                            // Promise reduce guarantees that promises are executed sequentially and waits for the previous to settle before invoking the next one.
                            var first = transaction.changes[0];
                            return commitOrRedo(first)
                                .then(function () { return Promise.reduce(transaction.changes.slice(1), reducer, null); })
                                .then(function () {
                                if (transaction.transactionStatus == undo.TransactionStatus.COMMITTING) {
                                    transaction.transactionStatus = undo.TransactionStatus.COMMITTED;
                                    _this._onTransactionCommitted(transaction);
                                }
                            });
                        };
                        /**
                         * Rolls back (aborts) a transaction from a pending state. A rollback will undo, then discard the changes which where registered
                         * while the transaction was open. Rolling back a nested transaction will roll back its parent transaction as well.
                         * A transaction can only be rolled back from a pending state (after `beginTransaction` has been called, but before `commitTransaction` is called).
                         * @param transaction The transaction to roll back.
                         */
                        UndoManager.prototype.rollbackTransaction = function (transaction) {
                            var _this = this;
                            transaction = transaction || this.rootTransaction;
                            if (!transaction) {
                                return Promise.reject(new Error("Cannot find the transaction to rollback"));
                            }
                            if (transaction.isComplete()) {
                                return Promise.reject(new Error("Transaction has been closed already"));
                            }
                            // Undo the transaction changes, then remove it from the parent
                            transaction.transactionStatus = undo.TransactionStatus.ABORTING;
                            // Return right away if no changes have been recorded...
                            if (!transaction.hasChanges()) {
                                transaction.transactionStatus = undo.TransactionStatus.ABORTED;
                                this._onTransactionAborted(transaction);
                                return Promise.resolve();
                            }
                            var reducer = function (_, current) {
                                if (current instanceof undo.UndoTransaction) {
                                    return current.isAborted() ? Promise.resolve() : current.rollback();
                                }
                                if (current && typeof current.performUndo == "function") {
                                    return current.performUndo(current.state, transaction);
                                }
                            };
                            // Promise reduce guarantees that promises are executed sequentially and waits for the previous to settle before invoking the next one.
                            return Promise.reduce(transaction.changes.slice().reverse(), reducer, null)
                                .then(function () {
                                if (!transaction.isAborted()) {
                                    transaction.transactionStatus = undo.TransactionStatus.ABORTED;
                                    _this._onTransactionAborted(transaction);
                                }
                                // Rolling back a nested transaction will roll back its parent transaction as well.
                                if (!transaction.isTopLevel() && !transaction.parentTransaction.isAborted()) {
                                    return _this.rollbackTransaction(transaction.parentTransaction);
                                }
                            });
                        };
                        /**
                         * Destroys this instance. Sets the history stack to null and cleans up all references.
                         */
                        UndoManager.prototype.destroy = function () {
                            this._historyStack = null;
                        };
                        /** Save changes into undo redo stack for top-level transactions. */
                        UndoManager.prototype._onTransactionCommitted = function (tx) {
                            if (tx && tx.isTopLevel() && tx == this.rootTransaction) {
                                this.rootTransaction = null;
                                this.add(tx);
                            }
                        };
                        /** Undo the transaction changes, then remove it from the parent. */
                        UndoManager.prototype._onTransactionAborted = function (tx) {
                            if (!tx) {
                                return;
                            }
                            var parent = tx.parentTransaction;
                            if (parent) {
                                var i = parent.changes.indexOf(tx);
                                if (i > -1) {
                                    parent.changes.splice(i, 1);
                                }
                            }
                            if (tx.isTopLevel() && tx == this.rootTransaction) {
                                this.rootTransaction = null;
                            }
                        };
                        UndoManager.prototype._checkAvailability = function () {
                            this.length = this._historyStack.length;
                            this.isUndoing = this._status == infrastructure.undo.Status.UNDOING;
                            this.isRedoing = this._status == infrastructure.undo.Status.REDOING;
                            if (this.length === 0) {
                                this.canUndo = this.canRedo = false;
                            }
                            else {
                                if (this.position === 0) {
                                    this.canUndo = false;
                                    this.canRedo = true;
                                }
                                else if (this.position === this.length) {
                                    this.canUndo = true;
                                    this.canRedo = false;
                                }
                                else {
                                    this.canUndo = this.canRedo = true;
                                }
                            }
                            // Raise canExecuteChanged for Undo and Redo commands
                            this.app.command("Undo").raiseCanExecuteChanged();
                            this.app.command("Redo").raiseCanExecuteChanged();
                            // Raise on-change event
                            this.app.event("UndoStackChangedEvent").publish({ sender: this });
                        };
                        UndoManager.prototype._updateStatus = function (status) {
                            this._status = status || infrastructure.undo.Status.IDLE;
                            this.isUndoing = this._status == infrastructure.undo.Status.UNDOING;
                            this.isRedoing = this._status == infrastructure.undo.Status.REDOING;
                        };
                        return UndoManager;
                    }());
                    undo.UndoManager = UndoManager;
                })(undo = infrastructure.undo || (infrastructure.undo = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var webMap;
                (function (webMap) {
                    var SymbolType;
                    (function (SymbolType) {
                        SymbolType.SIMPLE_MARKER = "esriSMS";
                        SymbolType.SIMPLE_LINE = "esriSLS";
                        SymbolType.SIMPLE_FILL = "esriSFS";
                        SymbolType.PICTURE_MARKER = "esriPMS";
                        SymbolType.PICTURE_FILL = "esriPFS";
                        SymbolType.TEXT = "esriTS";
                    })(SymbolType = webMap.SymbolType || (webMap.SymbolType = {}));
                    var SimpleMarkerStyle;
                    (function (SimpleMarkerStyle) {
                        SimpleMarkerStyle.CIRCLE = "esriSMSCircle";
                        SimpleMarkerStyle.CROSS = "esriSMSCross";
                        SimpleMarkerStyle.DIAMOND = "esriSMSDiamond";
                        SimpleMarkerStyle.SQUARE = "esriSMSSquare";
                        SimpleMarkerStyle.X = "esriSMSX";
                        SimpleMarkerStyle.TRIANGLE = "esriSMSTriangle";
                        SimpleMarkerStyle.PATH = "esriSMSPath";
                    })(SimpleMarkerStyle = webMap.SimpleMarkerStyle || (webMap.SimpleMarkerStyle = {}));
                    var SimpleLineStyle;
                    (function (SimpleLineStyle) {
                        SimpleLineStyle.DASH = "esriSLSDash";
                        SimpleLineStyle.DASH_DOT = "esriSLSDashDot";
                        SimpleLineStyle.DASH_DOT_DOT = "esriSLSDashDotDot";
                        SimpleLineStyle.DOT = "esriSLSDot";
                        SimpleLineStyle.NONE = "esriSLSNull";
                        SimpleLineStyle.SOLID = "esriSLSSolid";
                    })(SimpleLineStyle = webMap.SimpleLineStyle || (webMap.SimpleLineStyle = {}));
                    var SimpleFillStyle;
                    (function (SimpleFillStyle) {
                        SimpleFillStyle.BACKWARD_DIAGONAL = "esriSFSBackwardDiagonal";
                        SimpleFillStyle.CROSS = "esriSFSCross";
                        SimpleFillStyle.DIAGONAL_CROSS = "esriSFSDiagonalCross";
                        SimpleFillStyle.FORWARD_DIAGONAL = "esriSFSForwardDiagonal";
                        SimpleFillStyle.HORIZONTAL = "esriSFSHorizontal";
                        SimpleFillStyle.NONE = "esriSFSNull";
                        SimpleFillStyle.SOLID = "esriSFSSolid";
                        SimpleFillStyle.VERTICAL = "esriSFSVertical";
                    })(SimpleFillStyle = webMap.SimpleFillStyle || (webMap.SimpleFillStyle = {}));
                    var VerticalAlignment;
                    (function (VerticalAlignment) {
                        VerticalAlignment.BASELINE = "baseline";
                        VerticalAlignment.TOP = "top";
                        VerticalAlignment.MIDDLE = "middle";
                        VerticalAlignment.BOTTOM = "bottom";
                    })(VerticalAlignment = webMap.VerticalAlignment || (webMap.VerticalAlignment = {}));
                    var HorizontalAlignment;
                    (function (HorizontalAlignment) {
                        HorizontalAlignment.LEFT = "left";
                        HorizontalAlignment.RIGHT = "right";
                        HorizontalAlignment.CENTER = "center";
                        HorizontalAlignment.JUSTIFY = "justify";
                    })(HorizontalAlignment = webMap.HorizontalAlignment || (webMap.HorizontalAlignment = {}));
                    var FontStyle;
                    (function (FontStyle) {
                        FontStyle.ITALIC = "italic";
                        FontStyle.NORMAL = "normal";
                        FontStyle.OBLIQUE = "oblique";
                    })(FontStyle = webMap.FontStyle || (webMap.FontStyle = {}));
                    var FontWeight;
                    (function (FontWeight) {
                        FontWeight.BOLD = "bold";
                        FontWeight.BOLDER = "bolder";
                        FontWeight.LIGHTER = "lighter";
                        FontWeight.NORMAL = "normal";
                    })(FontWeight = webMap.FontWeight || (webMap.FontWeight = {}));
                    var TextDecoration;
                    (function (TextDecoration) {
                        TextDecoration.LINE_THROUGH = "line-through";
                        TextDecoration.UNDERLINE = "underline";
                        TextDecoration.NONE = "none";
                    })(TextDecoration = webMap.TextDecoration || (webMap.TextDecoration = {}));
                })(webMap = infrastructure.webMap || (infrastructure.webMap = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="Symbol.ts" />
/// <reference path="../../../_Definitions/WeakMap.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var webMap;
                (function (webMap) {
                    var ArrayUtils = geocortex.framework.utils.ArrayUtils;
                    /**
                     * An indirect reference to a converted object. Used internally by WebMapConverter for dealing with cyclical object graphs.
                     * See WebMapConverter._convert() for more details.
                     */
                    var Reference = (function () {
                        function Reference() {
                        }
                        return Reference;
                    }());
                    var LIBRARY_ID = "Mapping.Infrastructure";
                    webMap.CONVERSION_TYPE_PROPERTY = "__conversionType";
                    // Special attributes that are used when converting Graphic objects to web map features.
                    var VISIBLE_ATTRIBUTE = "__visible";
                    var ID_ATTRIBUTE = "__id";
                    var SYMBOL_ATTRIBUTE = "__symbol";
                    var SYMBOL_ID_ATTRIBUTE = "__symbolId";
                    var SYMBOL_ID_PROPERTY = SYMBOL_ID_ATTRIBUTE;
                    /** A special ID prefix used when converting graphics layers to a web map feature collection. */
                    var GRAPHICS_LAYER_ID_PREFIX = "graphics-layer-";
                    /** A special symbol used for rendering invisible graphics. */
                    var INVISIBLE_SYMBOL = {
                        type: webMap.SymbolType.SIMPLE_MARKER,
                        style: webMap.SimpleMarkerStyle.CIRCLE,
                        size: 0,
                        color: [0, 0, 0, 0]
                    };
                    var INVISIBLE_SYMBOL_ID = 0;
                    /**
                     * Constants for the layerType property of service layers. This field and its possible values
                     * isn't officially documented by esri, however it's used in ArcGIS online web maps.
                     */
                    var LayerType;
                    (function (LayerType) {
                        LayerType.FeatureLayer = "ArcGISFeatureLayer";
                        LayerType.MapService = "ArcGISMapServiceLayer";
                        LayerType.TiledMapService = "ArcGISTiledMapServiceLayer";
                        LayerType.ImageService = "ArcGISImageServiceLayer";
                        LayerType.BingAerial = "BingMapsAerial";
                        LayerType.BingHybrid = "BingMapsHybrid";
                        LayerType.BingRoad = "BingMapsRoad";
                        LayerType.OpenStreetMap = "OpenStreetMap";
                        LayerType.WebTiled = "WebTiledLayer";
                        LayerType.KML = "KML";
                        LayerType.WMS = "WMS";
                    })(LayerType || (LayerType = {}));
                    /**
                     * Constants for target types that are handled by WebMapConverter.
                     */
                    var ConversionType;
                    (function (ConversionType) {
                        ConversionType.WEB_MAP_SERVICE_LAYER = "webMapServiceLayer";
                        ConversionType.WEB_MAP_LAYER = "webMapLayer";
                        ConversionType.WEB_MAP_FEATURE_SET = "webMapFeatureSet";
                        ConversionType.WEB_MAP_FEATURE = "webMapFeature";
                        ConversionType.WEB_MAP_GEOMETRY = "webMapGeometry";
                        ConversionType.WEB_MAP_SYMBOL = "webMapSymbol";
                        ConversionType.WEB_MAP_RENDERER = "webMapRenderer";
                        ConversionType.WEB_MAP_SPATIAL_REFERENCE = "webMapSpatialReference";
                        ConversionType.WEB_MAP_COLOR = "webMapColor";
                        ConversionType.WEB_MAP_DATA = "webMapData";
                        ConversionType.GCX_MAP_SERVICE = "gcxMapService";
                        ConversionType.GCX_LAYER = "gcxLayer";
                        ConversionType.GCX_FEATURE_SET = "gcxFeatureSet";
                        ConversionType.GCX_FEATURE = "gcxFeature";
                        ConversionType.ESRI_LAYER = "esriLayer";
                        ConversionType.ESRI_FEATURE_SET = "esriFeatureSet";
                        ConversionType.ESRI_GRAPHIC = "esriGraphic";
                        ConversionType.ESRI_GEOMETRY = "esriGeometry";
                        ConversionType.ESRI_SYMBOL = "esriSymbol";
                        ConversionType.ESRI_RENDERER = "esriRenderer";
                        ConversionType.ESRI_SPATIAL_REFERENCE = "esriSpatialReference";
                        ConversionType.ESRI_COLOR = "esriColor";
                        ConversionType.OBJECT = "object";
                    })(ConversionType = webMap.ConversionType || (webMap.ConversionType = {}));
                    /**
                     * Provides methods for converting between Geocortex/Esri API objects and their ArcGIS web map equivalents.
                     *
                     * Note that once an input object has been converted, any additional attempts to convert it again will always return
                     * a reference to the same result object (this is a form of the Identity Map pattern). To reset this mapping, use clearCache().
                     */
                    var WebMapConverter = (function () {
                        function WebMapConverter(app) {
                            /**
                             * Maps a result type to a cache of conversion results for that type. Each cache in turn maps input objects to result objects.
                             * Note that it's possible for the same input object to convert to different result types, which is why the cache has this structure.
                             */
                            this._resultCache = {};
                            /**
                             * The next available unique ID to assign to a symbol object.
                             */
                            this._nextSymbolId = 1;
                            // These are used by _convert().
                            this._nestingLevel = 0;
                            this._hasReferences = false;
                            this._converting = {};
                            this.app = app;
                        }
                        WebMapConverter.prototype.fromGcxMapService = function (mapService) {
                            return this._convert(mapService, ConversionType.WEB_MAP_SERVICE_LAYER, this._fromGcxMapService);
                        };
                        WebMapConverter.prototype.fromGcxLayer = function (layer) {
                            return this._convert(layer, ConversionType.WEB_MAP_LAYER, this._fromGcxlayer);
                        };
                        WebMapConverter.prototype.fromGcxFeatureSet = function (featureSet) {
                            return this._convert(featureSet, ConversionType.WEB_MAP_FEATURE_SET, this._fromGcxFeatureSet);
                        };
                        WebMapConverter.prototype.fromGcxFeature = function (feature) {
                            return this._convert(feature, ConversionType.WEB_MAP_FEATURE, this._fromGcxFeature);
                        };
                        WebMapConverter.prototype.fromEsriLayer = function (layer) {
                            return this._convert(layer, ConversionType.WEB_MAP_SERVICE_LAYER, this._fromEsriLayer);
                        };
                        WebMapConverter.prototype.fromEsriFeatureSet = function (featureSet) {
                            return this._convert(featureSet, ConversionType.WEB_MAP_FEATURE_SET, this._fromEsriFeatureSet);
                        };
                        WebMapConverter.prototype.fromEsriGraphic = function (graphic) {
                            return this._convert(graphic, ConversionType.WEB_MAP_FEATURE, this._fromEsriGraphic);
                        };
                        WebMapConverter.prototype.fromEsriGeometry = function (geometry) {
                            return this._convert(geometry, ConversionType.WEB_MAP_GEOMETRY, this._fromEsriGeometry);
                        };
                        WebMapConverter.prototype.fromEsriSymbol = function (symbol) {
                            return this._convert(symbol, ConversionType.WEB_MAP_SYMBOL, this._fromEsriSymbol);
                        };
                        WebMapConverter.prototype.fromEsriRenderer = function (renderer) {
                            return this._convert(renderer, ConversionType.WEB_MAP_RENDERER, this._fromEsriRenderer);
                        };
                        WebMapConverter.prototype.fromEsriSpatialReference = function (spatialReference) {
                            return this._convert(spatialReference, ConversionType.WEB_MAP_SPATIAL_REFERENCE, this._fromEsriSpatialReference);
                        };
                        WebMapConverter.prototype.fromEsriColor = function (color) {
                            return this._convert(color, ConversionType.WEB_MAP_COLOR, this._fromEsriColor);
                        };
                        /**
                         * Converts an arbitrary object graph to a format that can be stored in a web map.
                         */
                        WebMapConverter.prototype.fromObject = function (object) {
                            return this._convert(object, ConversionType.WEB_MAP_DATA, this._fromObject);
                        };
                        WebMapConverter.prototype.toGcxMapService = function (serviceLayer) {
                            return Promise.resolve(this._convert(serviceLayer, ConversionType.GCX_MAP_SERVICE, this._toGcxMapService));
                        };
                        WebMapConverter.prototype.toGcxLayer = function (layer, service) {
                            return Promise.resolve(this._convert(layer, ConversionType.GCX_LAYER, this._toGcxLayer, [service]));
                        };
                        WebMapConverter.prototype.toGcxFeatureSet = function (featureSet) {
                            return Promise.resolve(this._convert(featureSet, ConversionType.GCX_FEATURE_SET, this._toGcxFeatureSet));
                        };
                        WebMapConverter.prototype.toGcxFeature = function (feature) {
                            return Promise.resolve(this._convert(feature, ConversionType.GCX_FEATURE, this._toGcxFeature));
                        };
                        WebMapConverter.prototype.toEsriLayer = function (serviceLayer) {
                            return Promise.resolve(this._convert(serviceLayer, ConversionType.ESRI_LAYER, this._toEsriLayer));
                        };
                        WebMapConverter.prototype.toEsriFeatureSet = function (featureSet) {
                            return Promise.resolve(this._convert(featureSet, ConversionType.ESRI_FEATURE_SET, this._toEsriFeatureSet));
                        };
                        WebMapConverter.prototype.toEsriGraphic = function (feature) {
                            return Promise.resolve(this._convert(feature, ConversionType.ESRI_GRAPHIC, this._toEsriGraphic));
                        };
                        WebMapConverter.prototype.toEsriGeometry = function (geometry) {
                            return this._convert(geometry, ConversionType.ESRI_GEOMETRY, this._toEsriGeometry);
                        };
                        WebMapConverter.prototype.toEsriSymbol = function (symbol) {
                            return this._convert(symbol, ConversionType.ESRI_SYMBOL, this._toEsriSymbol);
                        };
                        WebMapConverter.prototype.toEsriRenderer = function (renderer) {
                            return this._convert(renderer, ConversionType.ESRI_RENDERER, this._toEsriRenderer);
                        };
                        WebMapConverter.prototype.toEsriSpatialReference = function (spatialReference) {
                            return this._convert(spatialReference, ConversionType.ESRI_SPATIAL_REFERENCE, this._toEsriSpatialReference);
                        };
                        WebMapConverter.prototype.toEsriColor = function (color) {
                            return this._convert(color, ConversionType.ESRI_COLOR, this._toEsriColor);
                        };
                        /**
                         * Converts serialized web map data back into the original API objects wherever possible. This only
                         * works if the object graph was serialized using fromObject(). Note that prototype chains for object
                         * types other than the specific Geocortex/Esri types handled by this class will NOT be preserved by
                         * toObject(fromObject(someObject)).
                         */
                        WebMapConverter.prototype.toObject = function (data) {
                            return Promise.resolve(this._convert(data, ConversionType.OBJECT, this._toObject));
                        };
                        WebMapConverter.prototype.clearCache = function () {
                            this._resultCache = {};
                        };
                        /**
                         * A wrapper for conversion methods that implements the Identity Map behaviour.
                         */
                        WebMapConverter.prototype._convert = function (source, destType, doConversion, args) {
                            if (args === void 0) { args = []; }
                            if (source === null || source === undefined || typeof source === "string" || typeof source === "number" || typeof source === "boolean" || source instanceof Date) {
                                return source;
                            }
                            var resultCache = this._resultCache[destType];
                            if (!resultCache) {
                                resultCache = this._resultCache[destType] = new WeakMap();
                            }
                            var converting = this._converting[destType];
                            if (!converting) {
                                converting = this._converting[destType] = new WeakMap();
                            }
                            if (resultCache.has(source)) {
                                // This object has already been converted to the destination type. Return the cached result.
                                return resultCache.get(source);
                            }
                            else if (converting.has(source)) {
                                // We're already in the process of converting this object, so there's a cycle in the object graph.
                                // Return a forward reference to the result, which will eventually get replaced by the actual value.
                                var reference = new Reference();
                                resultCache.set(source, reference);
                                this._hasReferences = true;
                                return reference;
                            }
                            else {
                                var result = undefined;
                                if (this._nestingLevel === 0) {
                                    this._hasReferences = false;
                                }
                                this._nestingLevel++;
                                converting.set(source, true);
                                try {
                                    // Use the callback to perform the conversion.
                                    result = doConversion.apply(this, [source].concat(args));
                                    // If there are cycles in the object graph, we may have returned a forward reference to the
                                    // result. If so, set its "result" property to the actual result. This will be used later by
                                    // _resolveReferences().
                                    var reference = resultCache.get(source);
                                    if (reference) {
                                        reference.result = result;
                                    }
                                    // Remember the real result for subsequent calls.
                                    resultCache.set(source, result);
                                }
                                catch (e) {
                                    // Remove a cached reference if the conversion failed.
                                    resultCache.delete(source);
                                    throw e;
                                }
                                finally {
                                    this._nestingLevel--;
                                    converting.delete(source);
                                }
                                if (this._nestingLevel === 0 && this._hasReferences) {
                                    // Walk the resulting object graph and swap any Reference objects out for the actual result.
                                    this._resolveReferences(result);
                                }
                                return result;
                            }
                        };
                        /**
                         * Resolves references that were added by _convert() due to cycles in the conversion input.
                         */
                        WebMapConverter.prototype._resolveReferences = function (object) {
                            if (!object) {
                                return;
                            }
                            var visited = new WeakMap();
                            var doResolve = function (object) {
                                // Optimization: Don't walk the graph for these object types, since it eventually covers everything including the site
                                // and esri map. These will not contain references.
                                if (object instanceof geocortex.essentials.MapService || object instanceof geocortex.essentials.Layer) {
                                    return;
                                }
                                // Like the source object graph, the result object graph can also contain cycles.
                                // Visited objects are tracked in order to avoid infinite recursion.
                                visited.set(object, true);
                                for (var property in object) {
                                    var value = object[property];
                                    if (typeof value !== "object") {
                                        continue;
                                    }
                                    if (value instanceof Reference) {
                                        object[property] = value.result;
                                    }
                                    else if (value && !visited.has(value)) {
                                        doResolve(value);
                                    }
                                }
                            };
                            doResolve(object);
                        };
                        WebMapConverter.prototype._getWebMapLayerDefinitionFromFeatureLayer = function (featureLayer) {
                            var result = {};
                            result.definitionExpression = featureLayer.getDefinitionExpression();
                            result.drawingInfo = {
                                renderer: this.fromEsriRenderer(featureLayer.renderer)
                            };
                            return result;
                        };
                        WebMapConverter.prototype._getWebMapLayerDefinitionFromDynamicLayer = function (dynamicServiceLayer, layerId) {
                            var result = {};
                            var hasDefinition = false;
                            if (dynamicServiceLayer.layerDefinitions && dynamicServiceLayer.layerDefinitions[layerId]) {
                                hasDefinition = true;
                                result.definitionExpression = dynamicServiceLayer.layerDefinitions[layerId];
                            }
                            if (dynamicServiceLayer.dynamicLayerInfos) {
                                var dynamicLayerInfo = ArrayUtils.firstOrDefault(dynamicServiceLayer.dynamicLayerInfos, function (info) { return info.id === layerId; });
                                if (dynamicLayerInfo) {
                                    hasDefinition = true;
                                    result.minScale = dynamicLayerInfo.minScale;
                                    result.maxScale = dynamicLayerInfo.maxScale;
                                    result.source = dynamicLayerInfo.source.toJson();
                                }
                            }
                            if (dynamicServiceLayer.layerDrawingOptions && dynamicServiceLayer.layerDrawingOptions[layerId]) {
                                hasDefinition = true;
                                result.drawingInfo = {
                                    renderer: this.fromEsriRenderer(dynamicServiceLayer.layerDrawingOptions[layerId].renderer),
                                    fixedSymbols: !dynamicServiceLayer.layerDrawingOptions[layerId].scaleSymbols
                                };
                            }
                            return hasDefinition ? result : null;
                        };
                        /**
                         * Applies a web map service layer configuration to an Essentials map service.
                         */
                        WebMapConverter.prototype._applyWebMapServiceLayerToMapService = function (serviceLayer, mapService) {
                            var _this = this;
                            return Promise.try(function () {
                                mapService.setOpacity(serviceLayer.opacity);
                                mapService.setVisibility(serviceLayer.visibility);
                                var esriServiceLayer = mapService.serviceLayer;
                                var operationalLayer = serviceLayer;
                                if (esriServiceLayer instanceof esri.layers.FeatureLayer) {
                                    // The visibility of a feature layer's sole Essentials layer needs to stay in sync with the service's visibility.
                                    mapService.layers[0].setVisibility(serviceLayer.visibility);
                                    if (operationalLayer.layerDefinition && operationalLayer.layerDefinition.definitionExpression) {
                                        esriServiceLayer.setDefinitionExpression(operationalLayer.layerDefinition.definitionExpression);
                                    }
                                }
                                // Apply drawing info.
                                if (_this._isFeatureCollection(serviceLayer) && operationalLayer.featureCollection.layers[0].layerDefinition) {
                                    return _this._applyDrawingInfo(operationalLayer.featureCollection.layers[0].layerDefinition.drawingInfo, mapService);
                                }
                                else if (operationalLayer.layerDefinition) {
                                    return _this._applyDrawingInfo(operationalLayer.layerDefinition.drawingInfo, mapService);
                                }
                            });
                        };
                        /**
                         * Applies web map layer configuration to a map service's layers. Returns a boolean indicating whether the map service
                         * will need to be refreshed as a result.
                         */
                        WebMapConverter.prototype._applyWebMapLayersToGcxLayers = function (serviceLayer, mapService) {
                            var _this = this;
                            // Apply layer configuration on each layer.
                            var layers = serviceLayer.layers || [];
                            var promises = [];
                            layers.forEach(function (layer, index) {
                                var promise = _this._findOrCreateMatchingGcxLayer(layer, mapService)
                                    .then(function (gcxLayer) { return gcxLayer ? _this._applyWebMapLayerToGcxLayer(layer, index, gcxLayer) : false; });
                                promises.push(promise);
                            });
                            return Promise.all(promises)
                                .then(function (results) { return results.some(function (needsRefresh) { return needsRefresh; }); });
                        };
                        /**
                         * Applies web map configuration to an Essentials layer. Returns a boolean indicating whether the map service
                         * will need to be refreshed as a result.
                         */
                        WebMapConverter.prototype._applyWebMapLayerToGcxLayer = function (layer, index, gcxLayer) {
                            var _this = this;
                            var esriServiceLayer = gcxLayer.mapService.serviceLayer;
                            if (!layer.layerDefinition || !(esriServiceLayer instanceof esri.layers.ArcGISDynamicMapServiceLayer)) {
                                return Promise.resolve(false);
                            }
                            var esriDynamicServiceLayer = esriServiceLayer;
                            return this.app.waitUntilServiceLayerLoaded(esriServiceLayer).then(function () {
                                // May differ from layer.id.
                                var gcxLayerId = parseInt(gcxLayer.id);
                                var needsRefresh = false;
                                if (layer.layerDefinition.definitionExpression) {
                                    // Restore the definition expression.
                                    var definitionExpressions = (esriDynamicServiceLayer.layerDefinitions || []).slice();
                                    definitionExpressions[gcxLayerId] = layer.layerDefinition.definitionExpression;
                                    esriDynamicServiceLayer.setLayerDefinitions(definitionExpressions, true);
                                    needsRefresh = true;
                                }
                                if (layer.layerDefinition.drawingInfo) {
                                    // Restore custom drawing info.
                                    gcxLayer.mapService.convertToDynamicLayers();
                                    var drawingOptions = (esriDynamicServiceLayer.layerDrawingOptions || []).slice();
                                    drawingOptions[gcxLayerId] = new esri.layers.LayerDrawingOptions();
                                    drawingOptions[gcxLayerId].renderer = _this.toEsriRenderer(layer.layerDefinition.drawingInfo.renderer);
                                    drawingOptions[gcxLayerId].scaleSymbols = !layer.layerDefinition.drawingInfo.fixedSymbols;
                                    // The "showLabels" flag is an extension used by projects. Restore this setting if detected.
                                    if (layer.layerDefinition.drawingInfo.hasOwnProperty("showLabels")) {
                                        drawingOptions[gcxLayerId].showLabels = layer.layerDefinition.drawingInfo["showLabels"];
                                    }
                                    // The "labelingInfo" property is an extension used by projects. Restore this setting if detected.
                                    if (layer.layerDefinition.drawingInfo.hasOwnProperty("labelingInfo")) {
                                        var temp = layer.layerDefinition.drawingInfo["labelingInfo"];
                                        // Ensure that labelingInfo is defined
                                        drawingOptions[gcxLayerId].labelingInfo = drawingOptions[gcxLayerId].labelingInfo || [];
                                        // labelingInfo should only have 1 item in it
                                        // If the array is empty, push it on; otherwise, set index 0
                                        if (!drawingOptions[gcxLayerId].labelingInfo.length) {
                                            drawingOptions[gcxLayerId].labelingInfo.push((new esri.layers.LabelClass(temp[0])));
                                        }
                                        else {
                                            drawingOptions[gcxLayerId].labelingInfo[0] = (new esri.layers.LabelClass(temp[0]));
                                        }
                                        // Set the colors as esri.Color's
                                        var tempObject = temp[0];
                                        var tempColor = tempObject["symbol"]["color"];
                                        var tempHaloColor = tempObject["symbol"]["haloColor"];
                                        drawingOptions[gcxLayerId].labelingInfo[0].symbol.setColor(new esri.Color([tempColor["r"], tempColor["g"], tempColor["b"], tempColor["a"]]));
                                        drawingOptions[gcxLayerId].labelingInfo[0].symbol.setHaloColor(new esri.Color([tempHaloColor["r"], tempHaloColor["g"], tempHaloColor["b"], tempHaloColor["a"]]));
                                        // Change pts back to px
                                        var symbol = drawingOptions[gcxLayerId].labelingInfo[0].symbol;
                                        drawingOptions[gcxLayerId].labelingInfo[0].symbol.font.setSize(symbol.font.size * 0.75);
                                        drawingOptions[gcxLayerId].labelingInfo[0].symbol.setHaloSize(symbol.haloSize * 0.75);
                                    }
                                    esriDynamicServiceLayer.setLayerDrawingOptions(drawingOptions, true);
                                    needsRefresh = true;
                                }
                                if (esriDynamicServiceLayer.dynamicLayerInfos) {
                                    var dynamicInfo = ArrayUtils.firstOrDefault(esriDynamicServiceLayer.dynamicLayerInfos, function (info) { return info.id === gcxLayerId; });
                                    if (dynamicInfo) {
                                        // Restore scale range if using dynamic layers.
                                        dynamicInfo.minScale = layer.layerDefinition.minScale;
                                        dynamicInfo.maxScale = layer.layerDefinition.maxScale;
                                        esriDynamicServiceLayer.setDynamicLayerInfos(esriDynamicServiceLayer.dynamicLayerInfos, true);
                                        needsRefresh = true;
                                    }
                                }
                                return needsRefresh;
                            });
                        };
                        WebMapConverter.prototype._applyDrawingInfo = function (drawingInfo, mapService) {
                            var _this = this;
                            if (!drawingInfo) {
                                return Promise.resolve();
                            }
                            var esriServiceLayer = mapService.serviceLayer;
                            return this.app.waitUntilServiceLayerLoaded(esriServiceLayer)
                                .then(function () {
                                // GVH-10156 - Do not remove heat maps for user created layers if they're enabled
                                if (mapService.heatMap && mapService.heatMap.userCanToggle && !(mapService.isUserCreated && mapService.heatMap.enabled)) {
                                    _this.app.command("RemoveHeatMap").execute({ gcxLayer: mapService.layers[0] });
                                }
                                if (drawingInfo.renderer) {
                                    if (mapService.heatMap && mapService.heatMap.userCanToggle && drawingInfo.renderer.type === webMap.RendererType.HEATMAP) {
                                        // Apply the heatmap settings via the AddHeatMap command.
                                        var renderer = drawingInfo.renderer;
                                        if (renderer) {
                                            var heatmap_1 = mapService.heatMap;
                                            heatmap_1.intensity = renderer.blurRadius;
                                            heatmap_1.field = renderer.field;
                                            heatmap_1.gradient = [];
                                            heatmap_1.offset = [];
                                            (renderer.colorStops || []).forEach(function (colorStop, i) {
                                                heatmap_1.gradient[i] = colorStop.color;
                                                heatmap_1.offset[i] = colorStop.ratio;
                                            });
                                            _this.app.command("AddHeatMap").execute({ gcxLayer: mapService.layers[0] });
                                        }
                                    }
                                    else if (esriServiceLayer instanceof esri.layers.GraphicsLayer) {
                                        _this._setGraphicsLayerRenderer(esriServiceLayer, _this.toEsriRenderer(drawingInfo.renderer));
                                    }
                                }
                            });
                        };
                        WebMapConverter.prototype._setGraphicsLayerRenderer = function (serviceLayer, renderer) {
                            serviceLayer.setRenderer(renderer);
                            serviceLayer.redraw();
                        };
                        WebMapConverter.prototype._findMatchingGcxMapService = function (serviceLayer) {
                            var result = this.app.site.essentialsMap.findMapServiceById(serviceLayer.id);
                            result = result || ArrayUtils.firstOrDefault(this.app.site.essentialsMap.mapServices, function (ms) { return ms.serviceUrl === serviceLayer.url; });
                            return result;
                        };
                        WebMapConverter.prototype._findMatchingGcxLayer = function (layer, mapService) {
                            var webMapLayer = typeof layer === "object" ? layer : null;
                            var result = null;
                            // Since layer IDs can easily change (prior to ArcGIS 10.3), always try to match by name first.
                            if (webMapLayer) {
                                result = mapService.findLayerByName(webMapLayer.name);
                            }
                            var layerId = webMapLayer ? webMapLayer.id.toString() : layer.toString();
                            result = result || mapService.findLayerById(layerId);
                            result = result || ArrayUtils.firstOrDefault(mapService.layers, function (layer) { return layer.wmsLayerName === layerId; });
                            // If the layer is dynamic, try matching via the map layer ID in the layer source.
                            var sourceLayerId = undefined;
                            if (!result && webMapLayer && webMapLayer.layerDefinition && webMapLayer.layerDefinition.source && webMapLayer.layerDefinition.source.type === "mapLayer") {
                                sourceLayerId = webMapLayer.layerDefinition.source.mapLayerId;
                            }
                            if (!result && sourceLayerId !== null && sourceLayerId !== undefined) {
                                result = mapService.findLayerById(sourceLayerId.toString());
                            }
                            if (!result) {
                                mapService.layers.forEach(function (gcxLayer) {
                                    if (gcxLayer.dynamicDefinition) {
                                        // See if the layer ID matches a map layer ID in a dynamic definition. In these cases, the ID assigned to the
                                        // Essentials Layer object doesn't correspond to a real map layer ID defined in the service.
                                        var dynamicDefinition = JSON.parse(gcxLayer.dynamicDefinition);
                                        if (dynamicDefinition && dynamicDefinition.source
                                            && dynamicDefinition.source.type === "mapLayerId"
                                            && (dynamicDefinition.source.mapLayerId || dynamicDefinition.source.mapLayerId === 0)
                                            && (dynamicDefinition.source.mapLayerId.toString() === layerId || dynamicDefinition.source.mapLayerId.toString() === sourceLayerId)) {
                                            result = gcxLayer;
                                        }
                                    }
                                });
                            }
                            return result;
                        };
                        WebMapConverter.prototype._findOrCreateMatchingGcxLayer = function (layer, mapService) {
                            var result = this._findMatchingGcxLayer(layer, mapService);
                            if (!result && this._canCreateGcxLayer(layer, mapService)) {
                                return this._createGcxLayer(layer, mapService);
                            }
                            else {
                                return Promise.resolve(result);
                            }
                        };
                        WebMapConverter.prototype._findOrCreateMatchingGcxMapService = function (serviceLayer) {
                            var result = this._findMatchingGcxMapService(serviceLayer);
                            if (!result && this._canCreateGcxMapService(serviceLayer)) {
                                return this._createGcxMapService(serviceLayer);
                            }
                            else {
                                return Promise.resolve(result);
                            }
                        };
                        /**
                         * Determines whether a new Essentials Layer object can be created for the given web map layer if
                         * no existing layer matches.
                         */
                        WebMapConverter.prototype._canCreateGcxLayer = function (layer, mapService) {
                            return mapService.serviceLayer instanceof esri.layers.ArcGISDynamicMapServiceLayer;
                        };
                        /**
                         * Invoked when a new Essentials Layer object needs to be created from the given web map layer.
                         */
                        WebMapConverter.prototype._createGcxLayer = function (layer, mapService) {
                            if (!this._canCreateGcxLayer(layer, mapService)) {
                                return Promise.reject(new Error("WebMapConverter._createGcxLayer: Unsupported layer type."));
                            }
                            // Create a dynamic layer.
                            var dynamicDefinition = {
                                source: {
                                    type: "mapLayerId",
                                    mapLayerId: layer.id
                                }
                            };
                            if (layer.layerDefinition && layer.layerDefinition.drawingInfo) {
                                dynamicDefinition["drawingInfo"] = layer.layerDefinition.drawingInfo;
                            }
                            var gcxLayerDefinition = {
                                id: layer.id.toString(),
                                name: layer.name,
                                displayName: layer.title || layer.name,
                                isDynamic: true,
                                dynamicDefinition: JSON.stringify(dynamicDefinition)
                            };
                            var result = new geocortex.essentials.Layer(mapService.url + "/layers/" + layer.id.toString());
                            result.createFromDefinition(gcxLayerDefinition);
                            mapService.add(result);
                            return Promise.resolve(result);
                        };
                        /**
                         * Determines whether a new Essentials MapService object can be created for the given web map service
                         * layer if no existing map service matches.
                         */
                        WebMapConverter.prototype._canCreateGcxMapService = function (serviceLayer) {
                            // We can only create map services types that are supported by essentials.Map.addMapService().
                            return this._isFeatureCollection(serviceLayer) || this._isKmlLayer(serviceLayer) || this._isLayerCatalogService(serviceLayer);
                        };
                        /**
                         * Invoked when a new Essentials MapService object needs to be created from the given web map service layer.
                         */
                        WebMapConverter.prototype._createGcxMapService = function (serviceLayer) {
                            var _this = this;
                            var serviceDefinition = this._getMapServiceDefinition(serviceLayer);
                            if (this._isLayerCatalogService(serviceLayer)) {
                                var lookupId = serviceLayer.gcxMapServiceDefinition.catalogId;
                                var layerIds = serviceLayer.layers.map(function (l) { return l.gcxLayerDefinition.catalogId; });
                                return new Promise(function (resolve, reject) {
                                    var callback = function (mapService) {
                                        if (mapService) {
                                            resolve(mapService);
                                        }
                                        reject(new Error("WebMapConverter._createGcxMapService: Unsupported layer catalog id."));
                                    };
                                    var args = {
                                        mapServiceId: serviceLayer.id,
                                        layerLookupIds: layerIds,
                                        lookupId: lookupId,
                                        callback: callback
                                    };
                                    _this.app.waitUntilAllLibrariesLoaded().then(function () {
                                        _this.app.command("LayerCatalogRestoreMapService").execute(args);
                                    });
                                });
                            }
                            else if (this._isFeatureCollection(serviceLayer)) {
                                var operationalLayer_1 = serviceLayer;
                                var featureCollection = operationalLayer_1.featureCollection;
                                var layer_1 = featureCollection.layers[0];
                                // Important: We need to preserve existing references to features, geometries, and attribute data 
                                // that may have already been converted using _convert(), so we can't just let the esri layer 
                                // constructor build new graphic objects for us. Instead, we'll add them manually below. The same 
                                // applies to the renderer and its symbols.
                                var featureSet = layer_1.featureSet || {};
                                var features = featureSet.features || [];
                                // The renderer will be modified by the FeatureLayer constructor, so preserve a copy 
                                var renderer_1 = layer_1.layerDefinition && layer_1.layerDefinition.drawingInfo && layer_1.layerDefinition.drawingInfo.renderer
                                    ? dojo.clone(layer_1.layerDefinition.drawingInfo.renderer)
                                    : {};
                                featureSet.features = [];
                                var promises = {
                                    mapService: infrastructure.LayerIntegrationUtils.buildLocalFeatureLayerService(layer_1, serviceDefinition),
                                    graphics: Promise.map(features, function (f) { return _this.toEsriGraphic(f); })
                                };
                                return Promise.props(promises)
                                    .then(function (promiseResults) {
                                    var mapService = promiseResults.mapService;
                                    if (renderer_1) {
                                        // Restore the unmodified renderer to the webMap objects
                                        layer_1.layerDefinition.drawingInfo.renderer = renderer_1;
                                        operationalLayer_1.layerDefinition.drawingInfo.renderer = renderer_1;
                                        // Convert the renderer.
                                        mapService.serviceLayer.setRenderer(_this._toEsriRenderer(renderer_1));
                                    }
                                    // Add features.
                                    promiseResults.graphics.forEach(function (graphic) {
                                        mapService.serviceLayer.add(graphic);
                                    });
                                    if (promiseResults.graphics.length) {
                                        mapService.serviceLayer.fullExtent = esri.graphicsExtent(promiseResults.graphics);
                                    }
                                    // Add it to the site.
                                    _this.app.site.essentialsMap.addMapService(mapService);
                                    return mapService;
                                });
                            }
                            else if (this._isKmlLayer(serviceLayer)) {
                                return infrastructure.LayerIntegrationUtils.buildKmlService(serviceLayer.url, serviceDefinition)
                                    .then(function (mapService) {
                                    // Add it to the site.
                                    _this.app.site.essentialsMap.addMapService(mapService);
                                    return mapService;
                                });
                            }
                            else {
                                return Promise.reject(new Error("WebMapConverter._createGcxMapService: Unsupported service layer type."));
                            }
                        };
                        /** Gets the Essentials map service definition from a service layer for use with _createGcxMapService(). */
                        WebMapConverter.prototype._getMapServiceDefinition = function (serviceLayer) {
                            return {
                                id: serviceLayer.id,
                                displayName: serviceLayer.title
                            };
                        };
                        WebMapConverter.prototype._isFeatureCollection = function (serviceLayer) {
                            var operationalLayer = serviceLayer;
                            return operationalLayer.featureCollection
                                && operationalLayer.featureCollection.layers
                                && operationalLayer.featureCollection.layers.length === 1
                                && !!operationalLayer.featureCollection.layers[0].featureSet;
                        };
                        WebMapConverter.prototype._isKmlLayer = function (serviceLayer) {
                            return serviceLayer.type === webMap.OperationalLayerType.KML;
                        };
                        WebMapConverter.prototype._isGraphicsLayer = function (serviceLayer) {
                            return serviceLayer.id && serviceLayer.id.startsWith(GRAPHICS_LAYER_ID_PREFIX);
                        };
                        WebMapConverter.prototype._isLayerCatalogService = function (serviceLayer) {
                            var layer = serviceLayer;
                            return layer.gcxMapServiceDefinition && layer.gcxMapServiceDefinition.catalogId;
                        };
                        /**
                         * Adds a property to a converted object that identifies the type of the original source object.
                         */
                        WebMapConverter.prototype._addSourceType = function (sourceType, object) {
                            object[webMap.CONVERSION_TYPE_PROPERTY] = sourceType;
                            return object;
                        };
                        /**
                         * Get the value to use for the "layerType" property on a service layer. This property is not part of the
                         * web map specification, but is used by AGOL.
                         */
                        WebMapConverter.prototype._getWebMapLayerType = function (layer) {
                            if (layer instanceof esri.layers.FeatureLayer) {
                                return LayerType.FeatureLayer;
                            }
                            else if (layer instanceof esri.layers.ArcGISDynamicMapServiceLayer) {
                                return LayerType.MapService;
                            }
                            else if (layer instanceof esri.layers.ArcGISTiledMapServiceLayer) {
                                return LayerType.TiledMapService;
                            }
                            else if (layer instanceof esri.layers.ArcGISImageServiceLayer) {
                                return LayerType.ImageService;
                            }
                            else if (layer instanceof esri.virtualearth.VETiledLayer) {
                                switch (layer.mapStyle.toLowerCase()) {
                                    case esri.virtualearth.VETiledLayer.MAP_STYLE_AERIAL.toLowerCase():
                                        return LayerType.BingAerial;
                                    case esri.virtualearth.VETiledLayer.MAP_STYLE_AERIAL_WITH_LABELS.toLowerCase():
                                        return LayerType.BingHybrid;
                                    case esri.virtualearth.VETiledLayer.MAP_STYLE_ROAD.toLowerCase():
                                        return LayerType.BingRoad;
                                }
                            }
                            else if (layer instanceof esri.layers.WebTiledLayer) {
                                if (layer.url && layer.url.indexOf("tile.openstreetmap.org") >= 0) {
                                    return LayerType.OpenStreetMap;
                                }
                                else {
                                    return LayerType.WebTiled;
                                }
                            }
                            else if (layer instanceof esri.layers.KMLLayer) {
                                return LayerType.KML;
                            }
                            else if (layer instanceof esri.layers.WMSLayer) {
                                return LayerType.WMS;
                            }
                            else if (layer instanceof esri.layers.WMTSLayer) {
                                return LayerType.WebTiled;
                            }
                            return undefined;
                        };
                        /**
                         * Infers the type of an attribute from a given set of Graphic objects.
                         */
                        WebMapConverter.prototype._inferAttributeType = function (graphics, attributeName) {
                            // Find the first graphic that has a value for this attribute, if possible.
                            var matchingGraphic = ArrayUtils.firstOrDefault(graphics, function (g) { return g.attributes && !geocortex.framework.utils.isNullOrUndefined(g.attributes[attributeName]); });
                            if (!matchingGraphic) {
                                return geocortex.essentials.EsriFieldTypes.esriFieldTypeString;
                            }
                            var sampleValue = matchingGraphic.attributes[attributeName];
                            if (typeof sampleValue === "number") {
                                return geocortex.essentials.EsriFieldTypes.esriFieldTypeDouble;
                            }
                            else if (sampleValue instanceof Date) {
                                return geocortex.essentials.EsriFieldTypes.esriFieldTypeDate;
                            }
                            else {
                                return geocortex.essentials.EsriFieldTypes.esriFieldTypeString;
                            }
                        };
                        /**
                         * Sets a map service's visible layers based on the settings in a web map operational layer. Returns a
                         * boolean indicating whether the service needs to be refreshed, i.e. whether any layer visibilities
                         * have changed.
                         */
                        WebMapConverter.prototype._setVisibleLayers = function (serviceLayer, mapService) {
                            var _this = this;
                            if (!mapService.supportsLayerVisibility()) {
                                return false;
                            }
                            // Determine which Essentials layers need to be visible.
                            var needsRefresh = false;
                            var visibleGcxLayers = [];
                            var visibleLayers = serviceLayer.visibleLayers || [];
                            var layers = serviceLayer.layers || [];
                            visibleLayers.forEach(function (layerId) {
                                // Find a matching Essentials layer.
                                var gcxLayer = undefined;
                                if (layers) {
                                    // For AGS services, the layerId will be numeric. For WMS layers, it will be the WMS layer name.
                                    var layer = ArrayUtils.firstOrDefault(layers, function (layer) { return layer.id === layerId; });
                                    layer = layer || ArrayUtils.firstOrDefault(layers, function (layer) { return layer.name === layerId; });
                                    if (layer) {
                                        gcxLayer = _this._findMatchingGcxLayer(layer, mapService);
                                    }
                                }
                                if (!gcxLayer) {
                                    gcxLayer = _this._findMatchingGcxLayer(layerId, mapService);
                                }
                                if (gcxLayer) {
                                    visibleGcxLayers.push(gcxLayer);
                                }
                            });
                            // Restore visibility of leaf layers (Essentials group layers must always be visible in order for the layer list to function correctly).
                            mapService.layers.forEach(function (gcxLayer) {
                                if (gcxLayer.type !== geocortex.essentials.LayerType.GROUP_LAYER) {
                                    var visible = visibleGcxLayers.indexOf(gcxLayer) >= 0;
                                    needsRefresh = needsRefresh || visible !== gcxLayer.isVisible();
                                    gcxLayer.setVisibility(visible, true /* Don't immediately refresh. */);
                                }
                            });
                            return needsRefresh;
                        };
                        // NOTE: Everything below here is only invoked by _convert, which guarantees that the input is non-null.
                        WebMapConverter.prototype._toGcxMapService = function (serviceLayer) {
                            var _this = this;
                            var result = undefined;
                            var operationalLayer = serviceLayer;
                            // Don't return references to map services or layers until the primary service layer is loaded and the
                            // map has a proper spatial reference. Otherwise, modules may begin doing things too early that end up 
                            // causing map initialization to fail.
                            return Promise.all([this.app.waitUntilSiteInitialized(), this.app.waitUntilMapLoaded()])
                                .then(function () { return _this._findOrCreateMatchingGcxMapService(serviceLayer); })
                                .then(function (mapService) {
                                result = mapService;
                                if (!result) {
                                    throw new Error("No matching Essentials map service was found for service \"{0}\".".format(serviceLayer.id));
                                }
                                return _this._applyWebMapServiceLayerToMapService(serviceLayer, result);
                            })
                                .then(function () { return _this._applyWebMapLayersToGcxLayers(operationalLayer, result); })
                                .then(function (needsRefresh) {
                                // _setVisibleLayers *must* be called at this point, regardless of whether the layer is already flagged as needsRefresh.
                                // Not doing so will result in not correctly setting the visibility of dynamic mapservice layers with custom renderers active.
                                needsRefresh = _this._setVisibleLayers(operationalLayer, result) || needsRefresh;
                                if (needsRefresh) {
                                    result.refresh();
                                }
                                return result;
                            });
                        };
                        WebMapConverter.prototype._toGcxLayer = function (layer, serviceLayer) {
                            var _this = this;
                            if (!serviceLayer) {
                                throw new Error("WebMapConverter.toGcxLayer: Parameter \"serviceLayer\" is required.");
                            }
                            return this.toGcxMapService(serviceLayer)
                                .then(function (mapService) {
                                var result = _this._findMatchingGcxLayer(layer, mapService);
                                if (!result) {
                                    throw new Error("No matching Essentials layer was found for layer \"{0}\" for service \"{1}\".".format(layer.id, serviceLayer.id));
                                }
                                return result;
                            });
                        };
                        WebMapConverter.prototype._toGcxFeatureSet = function (featureSet) {
                            var _this = this;
                            return this.toEsriFeatureSet(featureSet)
                                .then(function (esriFeatureSet) {
                                return new infrastructure.FeatureSet({
                                    app: _this.app,
                                    esriFeatureSet: esriFeatureSet
                                });
                            });
                        };
                        WebMapConverter.prototype._toEsriLayer = function (serviceLayer) {
                            if (this._isGraphicsLayer(serviceLayer)) {
                                return this._toEsriGraphicsLayer(serviceLayer);
                            }
                            else if (serviceLayer.layerType === LayerType.FeatureLayer) {
                                return this._toEsriFeatureLayer(serviceLayer);
                            }
                            else {
                                // In the future we could support other kinds of layers. This would involve actually hitting the service 
                                // URLs in some cases in order to detect the kind of service.
                                throw new Error("WebMapConverter.toEsriLayer: Unsupported layer type.");
                            }
                        };
                        WebMapConverter.prototype._toEsriGraphicsLayer = function (serviceLayer) {
                            var _this = this;
                            // Recover the original id by removing the special prefix added by _fromEsriGraphicsLayer().
                            var id = serviceLayer.id.slice(GRAPHICS_LAYER_ID_PREFIX.length);
                            var existingLayer = this.app.map.getLayer(id);
                            if (existingLayer && !(existingLayer instanceof esri.layers.GraphicsLayer)) {
                                return Promise.resolve(existingLayer);
                            }
                            return Promise.all([this.app.waitUntilSiteInitialized(), this.app.waitUntilMapLoaded()])
                                .then(function () {
                                var result = existingLayer;
                                if (!result) {
                                    result = new esri.layers.GraphicsLayer({ id: id });
                                    _this.app.map.addLayer(result);
                                }
                                result.setVisibility(serviceLayer.visibility);
                                result.setOpacity(serviceLayer.opacity);
                                result.clear();
                                // Recombine graphics into their original order before they were split by geometry type.
                                var graphicsPromises = [];
                                var featureCollection = serviceLayer.featureCollection || {};
                                var featureCollectionLayers = featureCollection.layers || [];
                                featureCollectionLayers.forEach(function (layer) {
                                    var featureSet = layer.featureSet || {};
                                    var features = featureSet.features || [];
                                    features.forEach(function (feature) {
                                        if (feature.attributes) {
                                            graphicsPromises[feature.attributes[ID_ATTRIBUTE]] = _this.toEsriGraphic(feature);
                                        }
                                    });
                                    // Restore the renderer if it's something other than the special renderer created by _fromEsriLayer().
                                    if (!result.renderer && layer.layerDefinition && layer.layerDefinition.drawingInfo && layer.layerDefinition.drawingInfo.renderer) {
                                        var renderer = layer.layerDefinition.drawingInfo.renderer;
                                        if (!renderer.uniqueValueInfos || !renderer.uniqueValueInfos[0] || JSON.stringify(renderer.uniqueValueInfos[0].symbol) !== JSON.stringify(INVISIBLE_SYMBOL)) {
                                            result.setRenderer(_this.toEsriRenderer(renderer));
                                        }
                                    }
                                });
                                return Promise.all(graphicsPromises).then(function (graphics) {
                                    graphics.forEach(function (graphic) {
                                        if (graphic) {
                                            result.add(graphic);
                                        }
                                    });
                                    return result;
                                });
                            });
                        };
                        WebMapConverter.prototype._toEsriFeatureLayer = function (serviceLayer) {
                            var _this = this;
                            if (serviceLayer.url) {
                                var result = new esri.layers.FeatureLayer(serviceLayer.url);
                                result.setVisibility(serviceLayer.visibility);
                                result.setOpacity(serviceLayer.opacity);
                                return this.app.waitUntilServiceLayerLoaded(result).return(result);
                            }
                            else if (this._isFeatureCollection(serviceLayer)) {
                                var result_1 = new esri.layers.FeatureLayer(serviceLayer.featureCollection.layers[0]);
                                result_1.setVisibility(serviceLayer.visibility);
                                result_1.setOpacity(serviceLayer.opacity);
                                result_1.clear();
                                var featureSet = serviceLayer.featureCollection.layers[0].featureSet || {};
                                var features = featureSet.features || [];
                                return Promise.map(features, function (feature) { return _this.toEsriGraphic(feature).then(function (graphic) { return result_1.add(graphic); }); }).return(result_1);
                            }
                            else {
                                throw new Error("WebMapConverter.toEsriLayer: Unsupported layer type.");
                            }
                        };
                        WebMapConverter.prototype._toEsriFeatureSet = function (featureSet) {
                            var _this = this;
                            var features = featureSet.features || [];
                            return infrastructure.PromiseUtils.mapSkipRejected(features, function (feature) { return _this.toEsriGraphic(feature); }).then(function (graphics) {
                                var result = new esri.tasks.FeatureSet();
                                result.features = graphics;
                                return result;
                            });
                        };
                        WebMapConverter.prototype._toGcxFeature = function (feature) {
                            return this.toEsriGraphic(feature).then(function (graphic) { return new infrastructure.Feature({ graphic: graphic }); });
                        };
                        WebMapConverter.prototype._toEsriGraphic = function (feature) {
                            var _this = this;
                            return this.toObject(feature.attributes).then(function (attributes) {
                                var geometry = _this.toEsriGeometry(feature.geometry);
                                var symbol;
                                var visible = true;
                                if (attributes) {
                                    // Extract and remove the special attributes added by _fromEsriGraphic if present.
                                    symbol = attributes[SYMBOL_ATTRIBUTE];
                                    delete attributes[SYMBOL_ATTRIBUTE];
                                    if (attributes.hasOwnProperty(VISIBLE_ATTRIBUTE)) {
                                        visible = attributes[VISIBLE_ATTRIBUTE];
                                        delete attributes[VISIBLE_ATTRIBUTE];
                                    }
                                    delete attributes[ID_ATTRIBUTE];
                                }
                                var result = new esri.Graphic(geometry, symbol, attributes, null);
                                result.visible = visible;
                                return result;
                            });
                        };
                        WebMapConverter.prototype._toEsriGeometry = function (geometry) {
                            if (geometry.hasOwnProperty("x") && geometry.hasOwnProperty("y")) {
                                return new esri.geometry.Point(geometry);
                            }
                            else if (geometry.hasOwnProperty("points")) {
                                return new esri.geometry.Multipoint(geometry);
                            }
                            else if (geometry.hasOwnProperty("paths")) {
                                return new esri.geometry.Polyline(geometry);
                            }
                            else if (geometry.hasOwnProperty("rings")) {
                                return new esri.geometry.Polygon(geometry);
                            }
                            else if (geometry.hasOwnProperty("xmin") && geometry.hasOwnProperty("xmax")
                                && geometry.hasOwnProperty("ymin") && geometry.hasOwnProperty("ymax")) {
                                return new esri.geometry.Extent(geometry);
                            }
                            else {
                                throw new Error("WebMapConverter.toEsriGeometry: Unrecognized type of geometry object.");
                            }
                        };
                        WebMapConverter.prototype._toEsriSymbol = function (symbol) {
                            switch (symbol.type) {
                                case webMap.SymbolType.SIMPLE_MARKER:
                                    // SimpleMarkerSymbol(json) won't set the size properly if it's a string (e.g. "12px").
                                    var result = new esri.symbol.SimpleMarkerSymbol(symbol);
                                    if (symbol.size !== result.size) {
                                        result.size = symbol["size"];
                                    }
                                    return result;
                                case webMap.SymbolType.SIMPLE_LINE:
                                    return new esri.symbol.SimpleLineSymbol(symbol);
                                case webMap.SymbolType.SIMPLE_FILL:
                                    return new esri.symbol.SimpleFillSymbol(symbol);
                                case webMap.SymbolType.PICTURE_MARKER:
                                    return new esri.symbol.PictureMarkerSymbol(symbol);
                                case webMap.SymbolType.PICTURE_FILL:
                                    return new esri.symbol.PictureFillSymbol(symbol);
                                case webMap.SymbolType.TEXT:
                                    return new esri.symbol.TextSymbol(symbol);
                                default:
                                    throw new Error("WebMapConverter.toEsriSymbol: Unsupported symbol type \"{0}\".".format(symbol.type));
                            }
                        };
                        WebMapConverter.prototype._toEsriRenderer = function (renderer) {
                            var _this = this;
                            // We need to preserve references to symbols that may have already been converted, using toEsriSymbol.
                            // Note that the esri renderer constructors modify their input. For example, a symbol object's "type"
                            // property may get switched from "esriSMS" to "simplemarkersymbol". For this reason, we use dojo.clone
                            // on the web map objects before passing to the constructor.
                            switch (renderer.type) {
                                case webMap.RendererType.SIMPLE:
                                    var simpleRenderer = new esri.renderer.SimpleRenderer(dojo.clone(renderer));
                                    simpleRenderer.symbol = this.toEsriSymbol(renderer.symbol);
                                    return simpleRenderer;
                                case webMap.RendererType.UNIQUE_VALUE:
                                    var uniqueValueRenderer = new esri.renderer.UniqueValueRenderer(dojo.clone(renderer));
                                    uniqueValueRenderer.defaultSymbol = this.toEsriSymbol(renderer.defaultSymbol);
                                    uniqueValueRenderer.infos.forEach(function (info, i) {
                                        info.symbol = _this.toEsriSymbol(renderer.uniqueValueInfos[i].symbol);
                                    });
                                    return uniqueValueRenderer;
                                case webMap.RendererType.CLASS_BREAKS:
                                    var classBreaksRenderer = new esri.renderer.ClassBreaksRenderer(dojo.clone(renderer));
                                    classBreaksRenderer.defaultSymbol = this.toEsriSymbol(renderer.defaultSymbol);
                                    classBreaksRenderer.infos.forEach(function (info, i) {
                                        info.symbol = _this.toEsriSymbol(renderer.classBreakInfos[i].symbol);
                                    });
                                    return classBreaksRenderer;
                                case webMap.RendererType.HEATMAP:
                                    var heatmapRenderer = new esri.renderer.HeatmapRenderer(dojo.clone(renderer));
                                    return heatmapRenderer;
                                default:
                                    throw new Error("WebMapConverter.toEsriRenderer: Unsupported renderer type \"{0}\".".format(renderer.type));
                            }
                        };
                        WebMapConverter.prototype._toEsriSpatialReference = function (spatialReference) {
                            return new esri.SpatialReference(spatialReference);
                        };
                        WebMapConverter.prototype._toEsriColor = function (color) {
                            return new esri.Color(color);
                        };
                        WebMapConverter.prototype._toObject = function (object) {
                            var _this = this;
                            if (typeof object === "string" || typeof object === "number" || typeof object === "boolean" || object instanceof Date || object === null || object === undefined) {
                                return Promise.resolve(object);
                            }
                            if (object.hasOwnProperty(webMap.CONVERSION_TYPE_PROPERTY)) {
                                var sourceType = object[webMap.CONVERSION_TYPE_PROPERTY];
                                switch (sourceType) {
                                    case ConversionType.GCX_MAP_SERVICE:
                                        return this.toGcxMapService(object);
                                    case ConversionType.GCX_LAYER:
                                        return this.toGcxLayer(object, null);
                                    case ConversionType.GCX_FEATURE_SET:
                                        return this.toGcxFeatureSet(object);
                                    case ConversionType.GCX_FEATURE:
                                        return this.toGcxFeature(object);
                                    case ConversionType.ESRI_LAYER:
                                        return this.toEsriLayer(object);
                                    case ConversionType.ESRI_FEATURE_SET:
                                        return this.toEsriFeatureSet(object);
                                    case ConversionType.ESRI_GRAPHIC:
                                        return this.toEsriGraphic(object);
                                    case ConversionType.ESRI_GEOMETRY:
                                        return Promise.resolve(this.toEsriGeometry(object));
                                    case ConversionType.ESRI_SYMBOL:
                                        return Promise.resolve(this.toEsriSymbol(object));
                                    case ConversionType.ESRI_RENDERER:
                                        return Promise.resolve(this.toEsriRenderer(object));
                                    case ConversionType.ESRI_SPATIAL_REFERENCE:
                                        return Promise.resolve(this.toEsriSpatialReference(object));
                                }
                            }
                            var result = {};
                            var promises = [];
                            Object.keys(object).forEach(function (property) {
                                promises.push(_this.toObject(object[property]).then(function (value) {
                                    result[property] = value;
                                }));
                            });
                            return Promise.all(promises).return(result);
                        };
                        WebMapConverter.prototype._fromGcxMapService = function (mapService) {
                            var _this = this;
                            var esriServiceLayer = mapService.serviceLayer;
                            var result = {
                                id: mapService.id,
                                url: mapService.serviceUrl,
                                opacity: mapService.opacity,
                                visibility: mapService.isVisible(),
                                layerType: this._getWebMapLayerType(esriServiceLayer)
                            };
                            if (mapService.mapServiceFunction === geocortex.essentials.MapServiceFunction.OPERATIONAL) {
                                var operationalResult = result;
                                operationalResult.title = mapService.displayName;
                                operationalResult.minScale = mapService.minScale === Infinity ? 0 : mapService.minScale;
                                operationalResult.maxScale = mapService.maxScale;
                                if (esriServiceLayer instanceof esri.layers.ArcGISDynamicMapServiceLayer) {
                                    operationalResult.capabilities = esriServiceLayer.capabilities;
                                    operationalResult.visibleLayers = esriServiceLayer.visibleLayers.map(function (id) { return parseInt(id); });
                                    var layers_1 = mapService.layers;
                                    // If dynamic layers are enabled, preserve the dynamic ordering of layers.
                                    if (esriServiceLayer.dynamicLayerInfos) {
                                        layers_1 = [];
                                        esriServiceLayer.dynamicLayerInfos.forEach(function (info, i) {
                                            var layer = mapService.findLayerById(info.id.toString());
                                            if (layer) {
                                                layers_1.push(layer);
                                            }
                                        });
                                    }
                                    operationalResult.layers = layers_1.map(function (layer) { return _this.fromGcxLayer(layer); });
                                }
                                else if (esriServiceLayer instanceof esri.layers.WMSLayer) {
                                    // This property is undocumented in the esri API, but definitely exists. It contains a list of string IDs,
                                    // which is what we need for web maps.
                                    operationalResult.visibleLayers = esriServiceLayer.visibleLayers;
                                    operationalResult.type = webMap.OperationalLayerType.WMS;
                                }
                                else if (esriServiceLayer instanceof esri.layers.KMLLayer) {
                                    operationalResult.type = webMap.OperationalLayerType.KML;
                                }
                                else if (esriServiceLayer instanceof esri.layers.FeatureLayer) {
                                    // Store feature layer symbology settings
                                    operationalResult.layerDefinition = this._getWebMapLayerDefinitionFromFeatureLayer(esriServiceLayer);
                                    operationalResult.capabilities = esriServiceLayer.capabilities;
                                    if (mapService.isUserCreated && esriServiceLayer.graphics && esriServiceLayer.graphics.length) {
                                        // This is a feature collection.
                                        operationalResult.featureCollection = this._esriFeatureLayerToFeatureCollection(esriServiceLayer);
                                        operationalResult.featureCollection.showLegend = mapService.layers[0].includeInLegend;
                                    }
                                }
                                if (esriServiceLayer instanceof esri.layers.GraphicsLayer && esriServiceLayer.renderer instanceof esri.renderer.HeatmapRenderer && !operationalResult.featureCollection) {
                                    // Preserve heatmap visualization.
                                    operationalResult.layerDefinition = operationalResult.layerDefinition || {};
                                    operationalResult.layerDefinition.drawingInfo = {
                                        renderer: this.fromEsriRenderer(esriServiceLayer.renderer)
                                    };
                                }
                            }
                            else {
                                var baseMapResult = result;
                                if (esriServiceLayer instanceof esri.virtualearth.VETiledLayer) {
                                    // Bing maps have a special type rather than a URL.
                                    baseMapResult.type = result.layerType;
                                    delete result.url;
                                }
                                else if (esriServiceLayer instanceof esri.layers.WebTiledLayer) {
                                    // Web tiled layers have a special type rather than a URL.
                                    baseMapResult.type = result.layerType;
                                    baseMapResult.templateUrl = esriServiceLayer.url;
                                    delete result.url;
                                }
                                else if (esriServiceLayer instanceof esri.layers.WMTSLayer) {
                                    // WMTS services need to be converted to web tiled layers.
                                    baseMapResult.type = webMap.BaseMapType.WEB_TILED;
                                    if (!mapService.tileRestUrl) {
                                        throw new Error("WebMapConverter.fromGcxMapService: WMTS layers are only supported if the \"tileRestUrl\" property is set.");
                                    }
                                    // HACK ALERT: This uses an internal method on esri.layers.WMTSLayer to generate a template URL from the WMTS.
                                    if (mapService.tileRestUrl && !esriServiceLayer.resourceUrls) {
                                        esriServiceLayer.resourceUrls = [{ template: mapService.tileRestUrl }];
                                    }
                                    baseMapResult.templateUrl = esriServiceLayer._getTileUrlTemplate();
                                    delete result.url;
                                }
                            }
                            return result;
                        };
                        WebMapConverter.prototype._esriFeatureLayerToFeatureCollection = function (featureLayer) {
                            var esriServiceLayerJson = featureLayer.toJson();
                            var layerDefinition = (esriServiceLayerJson.layerDefinition || {});
                            return {
                                layers: [
                                    {
                                        featureSet: {
                                            geometryType: featureLayer.geometryType,
                                            features: featureLayer.graphics.map(this.fromEsriGraphic, this)
                                        },
                                        layerDefinition: {
                                            displayField: layerDefinition.displayField,
                                            fields: layerDefinition.fields,
                                            geometryType: layerDefinition.geometryType,
                                            hasAttachments: layerDefinition.hasAttachments,
                                            minScale: layerDefinition.minScale,
                                            maxScale: layerDefinition.maxScale,
                                            name: layerDefinition.name,
                                            objectIdField: layerDefinition.objectIdField,
                                            templates: layerDefinition.templates,
                                            type: layerDefinition.type,
                                            typeIdField: layerDefinition.typeIdField,
                                            types: layerDefinition.types,
                                            drawingInfo: {
                                                renderer: this.fromEsriRenderer(featureLayer.renderer)
                                            }
                                        }
                                    }
                                ],
                                showLegend: true
                            };
                        };
                        WebMapConverter.prototype._fromGcxlayer = function (layer) {
                            var result = {
                                name: layer.wmsLayerName,
                                title: layer.displayName,
                                layerUrl: layer.getLayerUrl(),
                                legendUrl: layer.legendUrl
                            };
                            var layerId = parseInt(layer.id);
                            if (!isNaN(layerId) && layerId !== undefined) {
                                result.id = layerId;
                            }
                            var serviceLayer = layer.mapService.serviceLayer;
                            if (serviceLayer instanceof esri.layers.ArcGISDynamicMapServiceLayer) {
                                var layerDefinition = this._getWebMapLayerDefinitionFromDynamicLayer(serviceLayer, layerId);
                                if (layerDefinition) {
                                    result.layerDefinition = layerDefinition;
                                }
                            }
                            return result;
                        };
                        WebMapConverter.prototype._fromGcxFeatureSet = function (featureSet) {
                            var geometryType;
                            var esriFeatureSet = featureSet.esriFeatureSet;
                            if (esriFeatureSet) {
                                geometryType = webMap.GeometryType.fromEsriGeometryType(esriFeatureSet.geometryType);
                                if (!geometryType && esriFeatureSet.features && esriFeatureSet.features.length > 0 && esriFeatureSet.features[0].geometry) {
                                    geometryType = webMap.GeometryType.fromEsriGeometryType(esriFeatureSet.features[0].geometry.type);
                                }
                            }
                            else if (featureSet.features.length) {
                                var firstFeature = featureSet.features.getAt(0);
                                if (firstFeature.hasGeometry.get()) {
                                    geometryType = webMap.GeometryType.fromEsriGeometryType(firstFeature.esriFeature.get().geometry.type);
                                }
                            }
                            return {
                                features: featureSet.features.get().map(this.fromGcxFeature, this),
                                geometryType: geometryType || webMap.GeometryType.POINT
                            };
                        };
                        WebMapConverter.prototype._fromEsriLayer = function (layer) {
                            if (layer instanceof esri.layers.FeatureLayer) {
                                return this._fromEsriFeatureLayer(layer);
                            }
                            else if (layer instanceof esri.layers.GraphicsLayer) {
                                return this._fromEsriGraphicsLayer(layer);
                            }
                            else {
                                // NOTE: Only layer types that are used for projects or web map export are currently supported, though the intent is to 
                                // eventually support any kind of esri Layer that has a web map equivalent.
                                throw new Error("WebMapConverter.fromEsriLayer: Unsupported layer type.");
                            }
                        };
                        WebMapConverter.prototype._fromEsriGraphicsLayer = function (layer) {
                            var _this = this;
                            var result = {
                                id: GRAPHICS_LAYER_ID_PREFIX + layer.id,
                                title: layer.id,
                                visibility: layer.visible,
                                opacity: layer.opacity,
                                minScale: layer.minScale,
                                maxScale: layer.maxScale
                            };
                            // Convert the graphics layer into a feature collection. First, the graphics are split into sublayers based on geometry type.
                            // Unlike Graphic objects, web map features do not have a symbol property or a visible flag. To get around this, we convert these
                            // to special attributes (see _fromEsriGraphic). Then, each sublayer gets a unique value renderer that contains one symbol per
                            // unique symbol in use by the graphics for that sublayer, and renders the correct symbol based on these attributes.
                            var subLayers = {};
                            layer.graphics.forEach(function (graphic, i) {
                                var geometryType = graphic.geometry.type;
                                var subLayer = subLayers[geometryType];
                                if (!subLayer) {
                                    subLayer = {
                                        featureSet: {
                                            features: [],
                                            geometryType: webMap.GeometryType.fromEsriGeometryType(geometryType)
                                        },
                                        layerDefinition: {
                                            geometryType: webMap.GeometryType.fromEsriGeometryType(geometryType),
                                            objectIdField: ID_ATTRIBUTE,
                                            name: _this.app.getResource(LIBRARY_ID, "language-webmap-layer-name-" + geometryType),
                                            fields: [
                                                {
                                                    name: ID_ATTRIBUTE,
                                                    alias: "OBJECTID",
                                                    type: geocortex.essentials.EsriFieldTypes.esriFieldTypeOID,
                                                    editable: false,
                                                    nullable: false
                                                },
                                                {
                                                    name: VISIBLE_ATTRIBUTE,
                                                    alias: _this.app.getResource(LIBRARY_ID, "language-webmap-field-name-visible"),
                                                    type: geocortex.essentials.EsriFieldTypes.esriFieldTypeInteger,
                                                    editable: true,
                                                    nullable: false
                                                }
                                            ],
                                            drawingInfo: {
                                                renderer: layer.renderer ? _this.fromEsriRenderer(layer.renderer) : {
                                                    type: webMap.RendererType.UNIQUE_VALUE,
                                                    field1: SYMBOL_ID_ATTRIBUTE,
                                                    uniqueValueInfos: [
                                                        {
                                                            value: INVISIBLE_SYMBOL_ID,
                                                            symbol: INVISIBLE_SYMBOL
                                                        }
                                                    ]
                                                }
                                            }
                                        }
                                    };
                                    subLayers[graphic.geometry.type] = subLayer;
                                }
                                var feature = _this.fromEsriGraphic(graphic);
                                feature.attributes = feature.attributes || {};
                                // This serves as a unique ID, but it also records the ordinal position within the original graphics layer in case we want to convert back.
                                feature.attributes[ID_ATTRIBUTE] = i;
                                // Infer field definitions from attribute data.
                                Object.keys(feature.attributes).forEach(function (attributeName) {
                                    if (attributeName === SYMBOL_ID_ATTRIBUTE || attributeName === SYMBOL_ATTRIBUTE) {
                                        return;
                                    }
                                    var field = (function (attributeName) { return ArrayUtils.firstOrDefault(subLayer.layerDefinition.fields, function (field) { return field.name === attributeName; }); })(attributeName);
                                    if (!field) {
                                        var attributeType = _this._inferAttributeType(layer.graphics, attributeName);
                                        field = {
                                            name: attributeName,
                                            alias: attributeName,
                                            type: attributeType,
                                            nullable: true,
                                            editable: true
                                        };
                                        subLayer.layerDefinition.fields.push(field);
                                    }
                                });
                                if (!layer.renderer) {
                                    // Add an entry for the graphic's symbol to the unique value renderer if necessary.
                                    var renderer = subLayer.layerDefinition.drawingInfo.renderer;
                                    var symbolId_1 = feature.attributes[SYMBOL_ID_ATTRIBUTE];
                                    if (symbolId_1 && !ArrayUtils.firstOrDefault(renderer.uniqueValueInfos, function (info) { return info.value === symbolId_1; })) {
                                        renderer.uniqueValueInfos.push({
                                            value: symbolId_1,
                                            symbol: feature.attributes[SYMBOL_ATTRIBUTE]
                                        });
                                    }
                                }
                                subLayer.featureSet.features.push(feature);
                            });
                            // Create the feature collection and add the sublayers.
                            result.featureCollection = {
                                layers: [],
                                showLegend: false
                            };
                            for (var _i = 0, _a = Object.keys(subLayers); _i < _a.length; _i++) {
                                var key = _a[_i];
                                result.featureCollection.layers.push(subLayers[key]);
                            }
                            return result;
                        };
                        WebMapConverter.prototype._fromEsriFeatureLayer = function (layer) {
                            var result = {
                                id: layer.id,
                                title: layer.id,
                                visibility: layer.visible,
                                opacity: layer.opacity,
                                minScale: layer.minScale,
                                maxScale: layer.maxScale,
                                layerType: LayerType.FeatureLayer
                            };
                            if (layer.url) {
                                result.url = layer.url;
                            }
                            else {
                                result.featureCollection = this._esriFeatureLayerToFeatureCollection(layer);
                            }
                            return result;
                        };
                        WebMapConverter.prototype._fromEsriFeatureSet = function (featureSet) {
                            return {
                                features: featureSet.features.map(this.fromEsriGraphic, this),
                                geometryType: webMap.GeometryType.fromEsriGeometryType(featureSet.geometryType)
                            };
                        };
                        WebMapConverter.prototype._fromGcxFeature = function (feature) {
                            var _this = this;
                            var attributes = {};
                            feature.attributes.get().forEach(function (attribute) {
                                attributes[attribute.name.get()] = _this.fromObject(attribute.value.get());
                            });
                            return {
                                attributes: attributes,
                                geometry: this.fromEsriGeometry(feature.esriFeature.get().geometry)
                            };
                        };
                        WebMapConverter.prototype._fromEsriGraphic = function (graphic) {
                            var result = {
                                attributes: this.fromObject(graphic.attributes) || {},
                                geometry: this.fromEsriGeometry(graphic.geometry)
                            };
                            // Encode the graphic's symbol and visibility properties as special attributes.
                            result.attributes[VISIBLE_ATTRIBUTE] = graphic.visible ? 1 : 0;
                            if (graphic.symbol) {
                                result.attributes[SYMBOL_ATTRIBUTE] = this._addSourceType(ConversionType.ESRI_SYMBOL, this.fromEsriSymbol(graphic.symbol));
                                // Used for graphics layers. This tells the layer's unique value renderer how to draw the graphic. See _fromEsriLayer() for more details.
                                if (!graphic.symbol[SYMBOL_ID_PROPERTY]) {
                                    graphic.symbol[SYMBOL_ID_PROPERTY] = this._nextSymbolId++;
                                }
                                result.attributes[SYMBOL_ID_ATTRIBUTE] = graphic.visible ? graphic.symbol[SYMBOL_ID_PROPERTY] : INVISIBLE_SYMBOL_ID;
                            }
                            return result;
                        };
                        WebMapConverter.prototype._fromEsriGeometry = function (geometry) {
                            var result = {
                                spatialReference: this.fromEsriSpatialReference(geometry.spatialReference)
                            };
                            // For performance reasons, we perform our own conversion instead of using geometry.toJson(), which
                            // does a deep clone on all arrays (e.g. the "rings" property of polygons). For our purposes, we don't need
                            // to duplicate all of this geometry data. Note however that this introduces a small risk that the original data
                            // may change, which would be immediately reflected in the serialized data. In practice, we prevent the user
                            // from doing anything while projects and web maps are being generated, so this shouldn't be an issue. 
                            switch (geometry.type) {
                                case "point":
                                    result.x = geometry.x;
                                    result.y = geometry.y;
                                    break;
                                case "multipoint":
                                    result.points = geometry.points;
                                case "polyline":
                                    result.paths = geometry.paths;
                                    break;
                                case "polygon":
                                    result.rings = geometry.rings;
                                    break;
                                case "extent":
                                    result.xmin = geometry.xmin;
                                    result.xmax = geometry.xmax;
                                    result.ymin = geometry.ymin;
                                    result.ymax = geometry.ymax;
                                    break;
                            }
                            return result;
                        };
                        WebMapConverter.prototype._fromEsriSymbol = function (symbol) {
                            var result = symbol.toJson();
                            // SimpleMarkerSymbol.toJson() won't export the size when it's a string (e.g. "12px").
                            if (symbol.size !== result.size) {
                                result.size = symbol["size"];
                            }
                            return result;
                        };
                        WebMapConverter.prototype._fromEsriRenderer = function (renderer) {
                            var _this = this;
                            var result = renderer.toJson();
                            // We need to preserve references to symbols that may have already been converted.
                            if (renderer instanceof esri.renderer.SimpleRenderer) {
                                result.symbol = this.fromEsriSymbol(renderer.symbol);
                            }
                            else if (renderer instanceof esri.renderer.UniqueValueRenderer) {
                                result.defaultSymbol = this.fromEsriSymbol(renderer.defaultSymbol);
                                result.uniqueValueInfos.forEach(function (info, i) {
                                    info.symbol = _this.fromEsriSymbol(renderer.infos[i].symbol);
                                });
                            }
                            else if (renderer instanceof esri.renderer.ClassBreaksRenderer) {
                                result.defaultSymbol = this.fromEsriSymbol(renderer.defaultSymbol);
                                result.classBreakInfos.forEach(function (info, i) {
                                    info.symbol = _this.fromEsriSymbol(renderer.infos[i].symbol);
                                });
                            }
                            return result;
                        };
                        WebMapConverter.prototype._fromEsriSpatialReference = function (spatialReference) {
                            return spatialReference.toJson();
                        };
                        WebMapConverter.prototype._fromEsriColor = function (color) {
                            return color.toRgba();
                        };
                        WebMapConverter.prototype._fromObject = function (object) {
                            // Detect known types and convert to web map objects. In this case, we need to tag the
                            // resulting objects with the source type, so that we can perform this conversion in 
                            // reverse later.
                            if (object instanceof geocortex.essentials.MapService) {
                                return this._addSourceType(ConversionType.GCX_MAP_SERVICE, this.fromGcxMapService(object));
                            }
                            else if (object instanceof geocortex.essentials.Layer) {
                                return this._addSourceType(ConversionType.GCX_LAYER, this.fromGcxLayer(object));
                            }
                            else if (object instanceof infrastructure.FeatureSet) {
                                return this._addSourceType(ConversionType.GCX_FEATURE_SET, this.fromGcxFeatureSet(object));
                            }
                            else if (object instanceof infrastructure.Feature) {
                                return this._addSourceType(ConversionType.GCX_FEATURE, this.fromGcxFeature(object));
                            }
                            else if (object instanceof esri.layers.Layer) {
                                return this._addSourceType(ConversionType.ESRI_LAYER, this.fromEsriLayer(object));
                            }
                            else if (object instanceof esri.tasks.FeatureSet) {
                                return this._addSourceType(ConversionType.ESRI_FEATURE_SET, this.fromEsriFeatureSet(object));
                            }
                            else if (object instanceof esri.Graphic) {
                                return this._addSourceType(ConversionType.ESRI_GRAPHIC, this.fromEsriGraphic(object));
                            }
                            else if (object instanceof esri.geometry.Geometry) {
                                return this._addSourceType(ConversionType.ESRI_GEOMETRY, this.fromEsriGeometry(object));
                            }
                            else if (object instanceof esri.symbol.Symbol) {
                                return this._addSourceType(ConversionType.ESRI_SYMBOL, this.fromEsriSymbol(object));
                            }
                            else if (object instanceof esri.renderer.Renderer) {
                                return this._addSourceType(ConversionType.ESRI_RENDERER, this.fromEsriRenderer(object));
                            }
                            else if (object instanceof esri.SpatialReference) {
                                return this._addSourceType(ConversionType.ESRI_SPATIAL_REFERENCE, this.fromEsriSpatialReference(object));
                            }
                            // Perform a deep clone of the object's properties to a JSON-compatible object, recursively applying this function.
                            var result = {};
                            for (var property in object) {
                                if (!object.hasOwnProperty(property) || typeof object[property] === "function" || property === SYMBOL_ID_PROPERTY) {
                                    continue;
                                }
                                result[property] = this.fromObject(object[property]);
                            }
                            return result;
                        };
                        return WebMapConverter;
                    }());
                    webMap.WebMapConverter = WebMapConverter;
                })(webMap = infrastructure.webMap || (infrastructure.webMap = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../webMap/WebMapConverter.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var project;
                (function (project) {
                    var ArrayUtils = geocortex.framework.utils.ArrayUtils;
                    // These properties are added to graphic objects by certain modules and need to be preserved.
                    project.PROPERTY_MEASUREMENT_ID = "measurementId";
                    project.PROPERTY_HIGHLIGHT_ID = "__gcxHlId";
                    /**
                     * Provides methods for converting between Geocortex/Esri API objects and their project equivalents.
                     *
                     * Note that once an input object has been converted, any additional attempts to convert it again will always return
                     * a reference to the same result object (this is a form of the Identity Map pattern). To reset this mapping, use clearCache().
                     */
                    var ProjectConverter = (function (_super) {
                        __extends(ProjectConverter, _super);
                        function ProjectConverter() {
                            _super.apply(this, arguments);
                        }
                        ProjectConverter.prototype.fromGcxMapService = function (mapService) {
                            return _super.prototype.fromGcxMapService.call(this, mapService);
                        };
                        ProjectConverter.prototype.fromGcxLayer = function (layer) {
                            return _super.prototype.fromGcxLayer.call(this, layer);
                        };
                        ProjectConverter.prototype.fromGcxFeatureSetCollection = function (fsc) {
                            return this._convert(fsc, "projectFeatureSetCollection", this._fromGcxFeatureSetCollection);
                        };
                        ProjectConverter.prototype.fromGcxFeatureSet = function (featureSet) {
                            return _super.prototype.fromGcxFeatureSet.call(this, featureSet);
                        };
                        ProjectConverter.prototype.fromEsriFeatureSet = function (featureSet) {
                            return _super.prototype.fromEsriFeatureSet.call(this, featureSet);
                        };
                        ProjectConverter.prototype.fromEsriLayer = function (layer) {
                            return _super.prototype.fromEsriLayer.call(this, layer);
                        };
                        ProjectConverter.prototype.fromGcxFeature = function (feature) {
                            return _super.prototype.fromGcxFeature.call(this, feature);
                        };
                        ProjectConverter.prototype.fromEsriGraphic = function (graphic) {
                            return _super.prototype.fromEsriGraphic.call(this, graphic);
                        };
                        ProjectConverter.prototype.toGcxFeatureSetCollection = function (fsc) {
                            return Promise.resolve(this._convert(fsc, "gcxFeatureSetCollection", this._toGcxFeatureSetCollection));
                        };
                        // Override
                        ProjectConverter.prototype._canCreateGcxLayer = function (layer, mapService) {
                            // For projects, only restore a layer if it was user-added. If it was defined in the site
                            // and subsequently removed, we don't want to restore it from the project.
                            return !!layer.gcxLayerDefinition;
                        };
                        // Override
                        ProjectConverter.prototype._canCreateGcxMapService = function (serviceLayer) {
                            // For projects, only restore a map service if it was user-added. If it was defined in the site
                            // and subsequently removed, we don't want to restore it from the project.
                            return !!serviceLayer.gcxMapServiceDefinition;
                        };
                        ProjectConverter.prototype._createGcxMapService = function (serviceLayer) {
                            return _super.prototype._createGcxMapService.call(this, serviceLayer)
                                .then(function (mapService) {
                                if (mapService instanceof infrastructure.LayerIntegrationUtils.LocalFeatureLayerService) {
                                    var operationalLayer = serviceLayer;
                                    // Apply stored gcx layer settings to the layer that gets automatically created by LayerIntegrationUtils.
                                    if (operationalLayer.layers && operationalLayer.layers[0] && operationalLayer.layers[0].gcxLayerDefinition) {
                                        mapService.layers[0].createFromDefinition(operationalLayer.layers[0].gcxLayerDefinition);
                                    }
                                }
                                return mapService;
                            });
                        };
                        ProjectConverter.prototype._createGcxLayer = function (layer, mapService) {
                            var gcxLayerDefinition = layer.gcxLayerDefinition;
                            var result = new geocortex.essentials.Layer(gcxLayerDefinition.url);
                            result.createFromDefinition(gcxLayerDefinition);
                            mapService.add(result);
                            result.isUserCreated = true;
                            return Promise.resolve(result);
                        };
                        // Override
                        ProjectConverter.prototype._getMapServiceDefinition = function (serviceLayer) {
                            return serviceLayer.gcxMapServiceDefinition;
                        };
                        ProjectConverter.prototype._getWebMapLayerDefinitionFromDynamicLayer = function (dynamicServiceLayer, layerId) {
                            var result = _super.prototype._getWebMapLayerDefinitionFromDynamicLayer.call(this, dynamicServiceLayer, layerId);
                            if (dynamicServiceLayer.layerDrawingOptions && dynamicServiceLayer.layerDrawingOptions[layerId]) {
                                // Add a custom flag for label visibility.
                                result.drawingInfo.showLabels = dynamicServiceLayer.layerDrawingOptions[layerId].showLabels;
                                // Add the labelingInfo property to save customized labels.
                                result.drawingInfo.labelingInfo = dynamicServiceLayer.layerDrawingOptions[layerId].labelingInfo;
                            }
                            return result;
                        };
                        ProjectConverter.prototype._applyDynamicLayerInfo = function (layer, index, gcxLayer) {
                            var esriDynamicServiceLayer = gcxLayer.mapService.serviceLayer;
                            var gcxLayerId = parseInt(gcxLayer.id);
                            gcxLayer.mapService.convertToDynamicLayers();
                            var dynamicLayerInfos = esriDynamicServiceLayer.dynamicLayerInfos || [];
                            var dynamicLayerInfo = dynamicLayerInfos.filter(function (info) { return info.id === gcxLayerId; })[0];
                            if (!dynamicLayerInfo) {
                                // Create a dynamicLayerInfo at the correct position.
                                dynamicLayerInfo = new esri.layers.DynamicLayerInfo();
                                dynamicLayerInfo.id = gcxLayerId;
                                dynamicLayerInfo.name = layer.name;
                                if (layer.layerDefinition) {
                                    dynamicLayerInfo.minScale = layer.layerDefinition.minScale;
                                    dynamicLayerInfo.maxScale = layer.layerDefinition.maxScale;
                                }
                                dynamicLayerInfos.splice(index, 0, dynamicLayerInfo);
                            }
                            else {
                                var currentIndex = dynamicLayerInfos.indexOf(dynamicLayerInfo);
                                if (currentIndex != index) {
                                    // Move the existng dynamicLayerInfo to the correct position.
                                    dynamicLayerInfos.splice(index, 0, dynamicLayerInfos.splice(currentIndex, 1)[0]);
                                }
                            }
                            esriDynamicServiceLayer.setDynamicLayerInfos(dynamicLayerInfos);
                        };
                        ProjectConverter.prototype._applyDrawingInfo = function (drawingInfo, mapService) {
                            var _this = this;
                            if (!drawingInfo) {
                                return Promise.resolve();
                            }
                            return _super.prototype._applyDrawingInfo.call(this, drawingInfo, mapService).then(function () {
                                // Clustering is currently enabled if there is saved clustering info ( <2.7 ) or if there is saved info and the enabled flag is set to true ( >=2.7 )
                                // Prior to 2.7 clustering info was not saved if clustering was not currently enabled.
                                var clusteringEnabled = drawingInfo.clustering && (drawingInfo.clustering.enabled || typeof drawingInfo.clustering.enabled === "undefined");
                                // Remove any existing cluster layer
                                _this.app.command("RemoveClusterLayer").execute({ gcxLayer: mapService.layers[0] });
                                // Apply saved cluster settings
                                if (mapService.featureClustering && mapService.featureClustering.userCanToggle && drawingInfo.clustering) {
                                    mapService.featureClustering.radius = drawingInfo.clustering.radius;
                                    mapService.featureClustering.backgroundColor = drawingInfo.clustering.backgroundColor;
                                    mapService.featureClustering.labelColor = drawingInfo.clustering.labelColor;
                                    mapService.featureClustering.maximumFeatures = drawingInfo.clustering.maximumFeatures;
                                }
                                // Add the cluster layer to the map if it is enabled
                                if (clusteringEnabled) {
                                    _this.app.command("AddClusterLayer").execute({ gcxLayer: mapService.layers[0] });
                                }
                                else {
                                    var serviceLayer = mapService.serviceLayer;
                                    serviceLayer.setRenderer(_this.toEsriRenderer(drawingInfo.renderer));
                                    serviceLayer.redraw();
                                }
                            });
                        };
                        // This method is overridden with no content in order that the renderer may be applied 
                        // *after* creating the cluster layer in instances of ProjectConverter.
                        // Not doing so will result in the cluster layer replacing custom symbology with the default.
                        ProjectConverter.prototype._setGraphicsLayerRenderer = function (serviceLayer, renderer) {
                            // Do nothing, renderer is set in _applyDrawingInfo if it needs to be
                        };
                        ProjectConverter.prototype._applyWebMapLayerToGcxLayer = function (layer, index, gcxLayer) {
                            var _this = this;
                            return _super.prototype._applyWebMapLayerToGcxLayer.call(this, layer, index, gcxLayer)
                                .then(function (needsRefresh) {
                                var esriServiceLayer = gcxLayer.mapService.serviceLayer;
                                var projectLayer = layer;
                                // Turn all layer styles off
                                for (var _i = 0, _a = gcxLayer.styles; _i < _a.length; _i++) {
                                    var style = _a[_i];
                                    style.enabled = false;
                                }
                                // If a layer style was active it needs to be flagged as enabled
                                if (projectLayer.layerStyleId) {
                                    var style = gcxLayer.styles.filter(function (s) { return s.id === projectLayer.layerStyleId; })[0];
                                    // Get the renderer for the custom style from the layer. Custom styles are only saved if they are currently active.
                                    var jsonRenderer = void 0;
                                    if (esriServiceLayer instanceof esri.layers.ArcGISDynamicMapServiceLayer) {
                                        jsonRenderer = JSON.stringify(_this.toEsriRenderer(projectLayer.layerDefinition.drawingInfo.renderer).toJson());
                                    }
                                    else if (esriServiceLayer instanceof esri.layers.FeatureLayer) {
                                        var operationalLayer = projectLayer.serviceLayer;
                                        jsonRenderer = JSON.stringify(_this.toEsriRenderer(operationalLayer.layerDefinition.drawingInfo.renderer).toJson());
                                    }
                                    // Update the renderer of the custom style and set it to enabled
                                    if (style) {
                                        if (jsonRenderer) {
                                            style.setRenderer(jsonRenderer);
                                        }
                                        style.enabled = true;
                                    }
                                    else {
                                        if (jsonRenderer) {
                                            gcxLayer.styles.push(new geocortex.essentials.LayerStyle(jsonRenderer, projectLayer.layerStyleId, projectLayer.layerStyleId, true));
                                        }
                                    }
                                }
                                // If the layer was flagged as a dynamic layer when it was saved, then convert the service to use 
                                // dynamic layers (if it isn't already) and override the min/max scale and drawing order based on
                                // the saved data. If the layer was not flagged this way, then we don't want to override anything.
                                if (projectLayer.isDynamic && esriServiceLayer instanceof esri.layers.ArcGISDynamicMapServiceLayer) {
                                    return _this.app.waitUntilServiceLayerLoaded(esriServiceLayer)
                                        .then(function () {
                                        _this._applyDynamicLayerInfo(projectLayer, index, gcxLayer);
                                        return needsRefresh;
                                    });
                                }
                                else {
                                    return needsRefresh;
                                }
                            });
                        };
                        ProjectConverter.prototype._toGcxLayer = function (layer, serviceLayer) {
                            var projectLayer = layer;
                            if (!serviceLayer) {
                                serviceLayer = projectLayer.serviceLayer;
                            }
                            return _super.prototype._toGcxLayer.call(this, layer, serviceLayer);
                        };
                        ProjectConverter.prototype._toGcxFeatureSetCollection = function (fsc) {
                            var _this = this;
                            var result = this.app.featureSetManager.featureSetCollections.get().filter(function (x) { return x.id === fsc.id; })[0];
                            if (!result) {
                                result = new infrastructure.FeatureSetCollection();
                                result.id = fsc.id;
                                this.app.featureSetManager.addCollection(result);
                            }
                            result.displayName.set(fsc.displayName);
                            result.sourceName = fsc.sourceName;
                            var fscName = "feature set collection \"{0}\"".format(fsc.id);
                            var toGcxFeatureSet = function (fs) { return infrastructure.PromiseUtils.warnOnReject(_this.toGcxFeatureSet(fs), _this.app, "Unable to restore feature set \"{0}\" for {1}: {{0}}".format(fs.id, fscName)); };
                            return infrastructure.PromiseUtils.mapSkipRejected(fsc.featureSets, toGcxFeatureSet)
                                .then(function (featureSets) {
                                result.clear();
                                result.featureSets.addItems(featureSets);
                            })
                                .then(function () { return infrastructure.PromiseUtils.warnOnReject(_this.toObject(fsc.tag), _this.app, "Unable to restore tag for {0}: {{0}}".format(fscName)); })
                                .then(function (tag) { result.tag = tag; })
                                .then(function () { return _this._toGcxExtendedProperties(fsc.extendedProperties, fscName); })
                                .then(function (extendedProperties) { result.extendedProperties.addItems(extendedProperties); })
                                .then(function () { return result; });
                        };
                        ProjectConverter.prototype._toGcxFeatureSet = function (featureSet) {
                            var _this = this;
                            var result;
                            var layer = featureSet.layer;
                            var serviceLayer = layer ? layer.serviceLayer : null;
                            var features = featureSet.features || [];
                            var promises = {
                                gcxLayer: this.toGcxLayer(layer, serviceLayer),
                                esriFeatureSet: this.toEsriFeatureSet(featureSet),
                                extendedProperties: this._toGcxExtendedProperties(featureSet.extendedProperties, "feature set")
                            };
                            return Promise.props(promises)
                                .then(function (promiseResults) {
                                result = new infrastructure.FeatureSet({
                                    app: _this.app,
                                    layer: promiseResults.gcxLayer,
                                    esriFeatureSet: promiseResults.esriFeatureSet,
                                    // SECURITY: FeatureSets are only tagged with `allowUnsafeContent` if the application is configured to allow it.
                                    allowUnsafeContent: _this.app.configuration && _this.app.configuration.allowUnsafeContent && featureSet.allowUnsafeContent
                                });
                                if (!layer) {
                                    // Infer attributes from first feature.
                                    result.loadAttributes();
                                    result.displayName.set(featureSet.displayName);
                                    result.iconUri.set(featureSet.iconUri);
                                }
                                result.id = featureSet.id;
                                result.extendedProperties.addItems(promiseResults.extendedProperties);
                            })
                                .then(function () { return infrastructure.PromiseUtils.mapSkipRejected(features, function (feature) {
                                return _this._findMatchingGcxFeature(feature, result)
                                    .then(function (gcxFeature) { return _this._applyFeatureToGcxFeature(feature, gcxFeature); });
                            }); })
                                .then(function () {
                                _this.app.waitUntilAllLibrariesLoaded()
                                    .then(function () {
                                    if (result.dataLinksState === infrastructure.DataLinksState.Unresolved) {
                                        result.resolveDataLinks(function (feature) {
                                            _this.app.event("FeatureChangedEvent").publish(feature);
                                        });
                                    }
                                });
                            })
                                .then(function () { return result; });
                        };
                        ProjectConverter.prototype._toGcxFeature = function (feature) {
                            var _this = this;
                            if (feature.featureSet) {
                                return this.toGcxFeatureSet(feature.featureSet)
                                    .then(function (gcxFeatureSet) { return _this._findMatchingGcxFeature(feature, gcxFeatureSet); })
                                    .then(function (gcxFeature) {
                                    if (!gcxFeature) {
                                        // This only happens if the feature was serialized as just an ID and we couldn't re-query it.
                                        throw new Error("Unable to restore feature with ID \"{0}\": feature no longer exists.".format(feature.id));
                                    }
                                    return gcxFeature;
                                });
                            }
                            else {
                                return this._createGcxFeature(feature);
                            }
                        };
                        ProjectConverter.prototype._createGcxFeature = function (feature) {
                            var _this = this;
                            var layer = feature.layer;
                            var serviceLayer = layer ? layer.serviceLayer : null;
                            var promises = {
                                gcxLayer: this.toGcxLayer(layer, serviceLayer),
                                featureLayer: layer ? null : this.toEsriLayer(feature.featureLayer),
                                graphic: this.toEsriGraphic(feature),
                                extendedProperties: this._toGcxExtendedProperties(feature.extendedProperties, "feature")
                            };
                            return Promise.props(promises)
                                .then(function (promiseResults) {
                                var options = {
                                    layer: promiseResults.gcxLayer,
                                    featureLayer: promiseResults.featureLayer,
                                    graphic: promiseResults.graphic,
                                    allowUnsafeContent: _this.app.configuration && _this.app.configuration.allowUnsafeContent && feature.allowUnsafeContent
                                };
                                var result = feature[infrastructure.isKmlProperty] ? new infrastructure.KmlFeature(options) : new infrastructure.Feature(options);
                                result.defaultDateFormat = feature.defaultDateFormat || infrastructure.DateFormat.DEFAULT;
                                result.defaultNumberFormat = feature.defaultNumberFormat || infrastructure.NumberFormat.DEFAULT;
                                result.timeZoneId = feature.timeZoneId;
                                result.displayTimeZoneId = feature.displayTimeZoneId;
                                result.borderColor.set(feature.borderColor);
                                result.fillColor.set(feature.fillColor);
                                result.borderWidth.set(feature.borderWidth);
                                result.extendedProperties.addItems(promiseResults.extendedProperties);
                                return result;
                            });
                        };
                        ProjectConverter.prototype._applyFeatureToGcxFeature = function (feature, gcxFeature) {
                            if (!feature || !gcxFeature) {
                                return Promise.resolve();
                            }
                            gcxFeature.defaultDateFormat = feature.defaultDateFormat || infrastructure.DateFormat.DEFAULT;
                            gcxFeature.defaultNumberFormat = feature.defaultNumberFormat || infrastructure.NumberFormat.DEFAULT;
                            gcxFeature.timeZoneId = feature.timeZoneId;
                            return this._toGcxExtendedProperties(feature.extendedProperties, "feature")
                                .then(function (extendedProperties) { return gcxFeature.extendedProperties.addItems(extendedProperties); });
                        };
                        ProjectConverter.prototype._findMatchingGcxFeature = function (feature, gcxFeatureSet) {
                            if (feature.id) {
                                return Promise.resolve(gcxFeatureSet.findFeatureById(feature.id));
                            }
                            else {
                                return this.toEsriGraphic(feature)
                                    .then(function (graphic) { return ArrayUtils.firstOrDefault(gcxFeatureSet.features.get(), function (f) { return f.esriFeature.get() === graphic; }); });
                            }
                        };
                        ProjectConverter.prototype._queryFeatures = function (features, featureSet) {
                            var _this = this;
                            if (!features || !features.length || !featureSet || !featureSet.layer) {
                                return Promise.resolve([]);
                            }
                            return Promise.try(function () {
                                // Break up the IDs into batches and issue seperate queries. Some databases cannot handle more than 
                                // a certain number of items in a SQL IN clause (e.g. Oracle).
                                var maxIdsPerQuery = 1000;
                                var ids = features.map(function (f) { return f.id; });
                                var idBatches = [];
                                while (ids.length > maxIdsPerQuery) {
                                    idBatches.push(ids.splice(0, maxIdsPerQuery));
                                }
                                idBatches.push(ids);
                                var layer = featureSet.layer;
                                var serviceLayer = layer ? layer.serviceLayer : null;
                                return _this.toGcxLayer(layer, serviceLayer).then(function (gcxLayer) {
                                    if (!gcxLayer || !gcxLayer.getObjectIdFieldName()) {
                                        throw new Error("Cannot restore features for layer \"{0}\": no primary key field defined.".format(gcxLayer ? gcxLayer.name : ""));
                                    }
                                    var primaryKeyField = gcxLayer.getObjectIdFieldName();
                                    var queryTask = infrastructure.taskUtils.getQueryTask(gcxLayer);
                                    return infrastructure.PromiseUtils.mapSkipRejected(idBatches, function (idBatch) {
                                        var query = new esri.tasks.Query();
                                        query.objectIds = idBatch.map(function (id) { return infrastructure.FormatUtils.parseNumber(id); });
                                        query.returnGeometry = true;
                                        query.outFields = ["*"];
                                        return queryTask.execute(query).then(function (fs) { return fs.features; });
                                    }, { concurrency: 2 })
                                        .then(function (graphics) { return ArrayUtils.flatten(graphics); });
                                });
                            });
                        };
                        ProjectConverter.prototype._toEsriGraphic = function (feature) {
                            return _super.prototype._toEsriGraphic.call(this, feature)
                                .then(function (result) {
                                // Preserve special properties added by measurements and coordinates.
                                if (feature.hasOwnProperty(project.PROPERTY_MEASUREMENT_ID)) {
                                    result[project.PROPERTY_MEASUREMENT_ID] = feature[project.PROPERTY_MEASUREMENT_ID];
                                }
                                if (feature.hasOwnProperty(infrastructure.coordinates.coordinateIdentifierProperty)) {
                                    result[infrastructure.coordinates.coordinateIdentifierProperty] = feature[infrastructure.coordinates.coordinateIdentifierProperty];
                                }
                                if (feature.hasOwnProperty(infrastructure.isKmlProperty)) {
                                    result[infrastructure.isKmlProperty] = feature[infrastructure.isKmlProperty];
                                }
                                // GVH-9141: Dynamic feature layers' attributes are evidently repopulated by ESRI on the fly,
                                // which makes assigning the highlight ID to these attributes impossible.
                                if (feature.hasOwnProperty(project.PROPERTY_HIGHLIGHT_ID)) {
                                    result[project.PROPERTY_HIGHLIGHT_ID] = feature[project.PROPERTY_HIGHLIGHT_ID];
                                }
                                return result;
                            });
                        };
                        ProjectConverter.prototype._toEsriFeatureSet = function (featureSet) {
                            var _this = this;
                            var layer = featureSet.layer;
                            var serviceLayer = layer ? layer.serviceLayer : null;
                            var features = featureSet.features || [];
                            // Partition the features into two sets: one that will be re-queried from the source, and another
                            // that will be rehydrated from embedded data.
                            var featuresToRequery = features.filter(function (f) { return !geocortex.framework.utils.isNullOrUndefined(f.id); });
                            var featuresToRehydrate = features.filter(function (f) { return geocortex.framework.utils.isNullOrUndefined(f.id); });
                            var promises = {
                                gcxLayer: this.toGcxLayer(layer, serviceLayer),
                                queryResults: this._queryFeatures(featuresToRequery, featureSet),
                                rehydratedGraphics: infrastructure.PromiseUtils.mapSkipRejected(featuresToRehydrate, function (f) { return _this.toEsriGraphic(f); })
                            };
                            return Promise.props(promises)
                                .then(function (promiseResults) {
                                var graphics = promiseResults.queryResults.concat(promiseResults.rehydratedGraphics);
                                var result = new esri.tasks.FeatureSet();
                                result.features = graphics;
                                return result;
                            });
                        };
                        ProjectConverter.prototype._fromGcxMapService = function (mapService) {
                            var _this = this;
                            var serviceLayer = mapService.serviceLayer;
                            var result;
                            if (mapService && mapService.serviceLayer instanceof esri.layers.WMTSLayer && !mapService.tileRestUrl) {
                                // AGOL requires WMTS to be converted to web tiled services, which is only possible if the WMTS
                                // supports RESTful encoding (WebMapConverter will throw an error if these conditions aren't met).
                                // For our purposes in projects, we don't care about this restriction.
                                result = {
                                    id: mapService.id,
                                    url: mapService.serviceUrl,
                                    type: infrastructure.webMap.BaseMapType.WEB_TILED,
                                    opacity: mapService.opacity,
                                    visibility: mapService.isVisible(),
                                    layers: []
                                };
                            }
                            else {
                                result = _super.prototype._fromGcxMapService.call(this, mapService);
                            }
                            if (mapService.isUserCreated) {
                                result.gcxMapServiceDefinition = mapService.toJson();
                            }
                            if (!result.layers) {
                                // For projects, we always populate the layers array.
                                result.layers = infrastructure.ArrayUtils.mapWithErrorCallback(mapService.layers, function (layer) { return _this.fromGcxLayer(layer); }, function (layer, error) { console.warn("Unable to convert layer \"{0}\": {1}".format(layer.id, error)); });
                            }
                            if (mapService.featureClustering) {
                                // Save clustering settings in the drawing info.
                                var operationalResult = result;
                                var layerDefinition = void 0;
                                if (this._isFeatureCollection(result)) {
                                    operationalResult.featureCollection.layers[0].layerDefinition = operationalResult.featureCollection.layers[0].layerDefinition || { drawingInfo: {} };
                                    layerDefinition = operationalResult.featureCollection.layers[0].layerDefinition;
                                }
                                else {
                                    operationalResult.layerDefinition = operationalResult.layerDefinition || { drawingInfo: {} };
                                    layerDefinition = operationalResult.layerDefinition;
                                }
                                layerDefinition.drawingInfo = layerDefinition.drawingInfo || {};
                                layerDefinition.drawingInfo.clustering = {
                                    radius: mapService.featureClustering.radius,
                                    backgroundColor: mapService.featureClustering.backgroundColor,
                                    labelColor: mapService.featureClustering.labelColor,
                                    maximumFeatures: mapService.featureClustering.maximumFeatures,
                                    enabled: mapService.featureClustering.enabled
                                };
                                // Save the original renderer, if there is one.
                                var clusterLayer = this.app.map.getLayer(mapService.id + "-cluster");
                                if (clusterLayer) {
                                    layerDefinition.drawingInfo.renderer = this.fromEsriRenderer(clusterLayer.featureLayerRenderer);
                                }
                            }
                            return result;
                        };
                        ProjectConverter.prototype._fromGcxlayer = function (layer) {
                            var result = _super.prototype._fromGcxlayer.call(this, layer);
                            result.serviceLayer = this.fromGcxMapService(layer.mapService);
                            var esriServiceLayer = layer.mapService.serviceLayer;
                            result.isDynamic = layer.isDynamic;
                            // If the service was converted to use dynamic layers, make note of this for later so that
                            // overridden layer order and scale range are re-applied.
                            if (esriServiceLayer instanceof esri.layers.ArcGISDynamicMapServiceLayer && esriServiceLayer.supportsDynamicLayers) {
                                result.isDynamic = result.isDynamic || (esriServiceLayer.dynamicLayerInfos && !!esriServiceLayer.dynamicLayerInfos[parseInt(layer.id)]);
                            }
                            if (layer.isUserCreated) {
                                result.gcxLayerDefinition = layer.toJson();
                            }
                            // If a layer style is enabled, record the id
                            var enabledLayerStyle = layer.styles.filter(function (s) { return s.enabled; })[0];
                            if (enabledLayerStyle) {
                                result.layerStyleId = enabledLayerStyle.id;
                            }
                            return result;
                        };
                        ProjectConverter.prototype._fromGcxFeatureSetCollection = function (fsc) {
                            var result = {
                                id: fsc.id,
                                displayName: fsc.displayName.get(),
                                featureSets: fsc.featureSets.get().map(this.fromGcxFeatureSet, this),
                                sourceName: fsc.sourceName,
                                tag: this.fromObject(fsc.tag)
                            };
                            if (fsc.extendedProperties.getLength()) {
                                result.extendedProperties = this._fromGcxExtendedProperties(fsc.extendedProperties);
                            }
                            return result;
                        };
                        ProjectConverter.prototype._fromGcxFeatureSet = function (featureSet) {
                            var result = _super.prototype._fromGcxFeatureSet.call(this, featureSet);
                            result.id = featureSet.id;
                            result.layer = this.fromGcxLayer(featureSet.layer);
                            // TODO: Hack. Maybe add a public getter to infrastructure.FeatureSet.
                            result.allowUnsafeContent = featureSet["_allowUnsafeContent"];
                            if (!featureSet.layer) {
                                result.displayName = featureSet.displayName.get();
                                result.iconUri = featureSet.iconUri.get();
                            }
                            return result;
                        };
                        ProjectConverter.prototype._fromGcxFeature = function (feature) {
                            var result = {};
                            if (this._canRequeryFeatureData(feature)) {
                                // Store only the ID. We will re-query the layer for the feature's attribute and geometry data 
                                // if we ever perform the inverse conversion.
                                result = {
                                    id: feature.id.get(),
                                    featureSet: this.fromGcxFeatureSet(feature.featureSet)
                                };
                            }
                            else {
                                // Create a normal feature with embedded attribute data and geometry.
                                result = _super.prototype._fromGcxFeature.call(this, feature);
                                result.featureSet = this.fromGcxFeatureSet(feature.featureSet);
                            }
                            // Only serialize the layer if there is no feature set.
                            if (!result.featureSet) {
                                result.layer = this.fromGcxLayer(feature.layer);
                            }
                            // Only serialize the feature layer if the feature is not associated with an Essentials layer
                            // (otherwise the feature layer can just be recreated).
                            if (feature.featureLayer && !feature.layer) {
                                result.featureLayer = this.fromEsriLayer(feature.featureLayer);
                            }
                            // TODO: Hack. Maybe add a public getter to infrastructure.Feature.
                            result.allowUnsafeContent = feature["_allowUnsafeContent"];
                            if (feature.borderColor.get()) {
                                result.borderColor = feature.borderColor.get();
                            }
                            if (feature.fillColor.get()) {
                                result.fillColor = feature.fillColor.get();
                            }
                            if (feature.borderWidth.get() >= 0) {
                                result.borderWidth = feature.borderWidth.get();
                            }
                            if (feature.extendedProperties.getLength()) {
                                result.extendedProperties = this._fromGcxExtendedProperties(feature.extendedProperties);
                            }
                            if (feature.defaultDateFormat !== infrastructure.DateFormat.DEFAULT) {
                                result.defaultDateFormat = feature.defaultDateFormat;
                            }
                            if (feature.defaultNumberFormat !== infrastructure.NumberFormat.DEFAULT) {
                                result.defaultNumberFormat = feature.defaultNumberFormat;
                            }
                            // Preserve special tag for KML features.
                            var esriFeature = feature.esriFeature.get();
                            if (esriFeature && esriFeature.hasOwnProperty(infrastructure.isKmlProperty)) {
                                result[infrastructure.isKmlProperty] = esriFeature[infrastructure.isKmlProperty];
                            }
                            if (feature.timeZoneId) {
                                result.timeZoneId = feature.timeZoneId;
                            }
                            if (feature.displayTimeZoneId) {
                                result.displayTimeZoneId;
                            }
                            return result;
                        };
                        ProjectConverter.prototype._fromEsriGraphic = function (graphic) {
                            var result = _super.prototype._fromEsriGraphic.call(this, graphic);
                            // Preserve special properties added by measurements and coordinates.
                            if (graphic.hasOwnProperty(project.PROPERTY_MEASUREMENT_ID)) {
                                result[project.PROPERTY_MEASUREMENT_ID] = graphic[project.PROPERTY_MEASUREMENT_ID];
                            }
                            if (graphic.hasOwnProperty(infrastructure.coordinates.coordinateIdentifierProperty)) {
                                result[infrastructure.coordinates.coordinateIdentifierProperty] = graphic[infrastructure.coordinates.coordinateIdentifierProperty];
                            }
                            // Preserve special tag for KML features.
                            if (graphic.hasOwnProperty(infrastructure.isKmlProperty)) {
                                result[infrastructure.isKmlProperty] = graphic[infrastructure.isKmlProperty];
                            }
                            // GVH-9141: Dynamic feature layers' attributes are evidently repopulated by ESRI on the fly,
                            // which makes assigning the highlight ID to these attributes impossible.
                            if (graphic.hasOwnProperty(project.PROPERTY_HIGHLIGHT_ID)) {
                                result[project.PROPERTY_HIGHLIGHT_ID] = graphic[project.PROPERTY_HIGHLIGHT_ID];
                            }
                            return result;
                        };
                        ProjectConverter.prototype._toGcxExtendedProperties = function (extendedProperties, owner) {
                            var _this = this;
                            extendedProperties = extendedProperties || {};
                            return infrastructure.PromiseUtils.mapSkipRejected(Object.keys(extendedProperties), function (property) {
                                var promise = _this.toObject(extendedProperties[property])
                                    .then(function (value) { return { name: property, value: value }; });
                                return infrastructure.PromiseUtils.warnOnReject(promise, _this.app, "Unable to restore extended property '{0}' for {1}: {{0}}".format(property, owner));
                            });
                        };
                        ProjectConverter.prototype._fromGcxExtendedProperties = function (extendedProperties) {
                            var _this = this;
                            var result = {};
                            extendedProperties.get().forEach(function (property) {
                                result[property.name] = _this.fromObject(property.value);
                            });
                            return result;
                        };
                        /**
                         * Determines whether a feature can be serialized using only its ID, rather than storing all of
                         * its attribute and geometry data. In this case, the original layer will be re-queried during
                         * deserialization to restore the data.
                         */
                        ProjectConverter.prototype._canRequeryFeatureData = function (feature) {
                            // Note that we do not want to check layer.queryable here (directly, or indirectly via TaskUtils.canQueryLayer()).
                            // That flag is a preference set by the admin as to whether users can query the layer. Instead, we check
                            // layer.supportsQuery which indicates whether the query operation is supported by the layer.
                            return feature
                                && !feature.isModified
                                && !geocortex.framework.utils.isNullOrUndefined(feature.id.get())
                                && feature.id.get() !== ""
                                && feature.featureSet
                                && feature.featureSet.layer
                                && feature.featureSet.layer.getLayerUrl()
                                && feature.featureSet.layer.supportsQuery
                                || String.isNullOrEmpty(feature.featureSet.layer.catalogId);
                        };
                        return ProjectConverter;
                    }(infrastructure.webMap.WebMapConverter));
                    project.ProjectConverter = ProjectConverter;
                })(project = infrastructure.project || (infrastructure.project = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../_Definitions/framework.d.ts"/>
/// <reference path="../_Definitions/essentials.d.ts"/>
/// <reference path="../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../_Definitions/globalize.d.ts"/>
/// <reference path="./infrastructure/accessibility/AccessibilityManager.ts"/>
/// <reference path="./infrastructure/FeatureSetManager.ts"/>
/// <reference path="./infrastructure/HighlightManager.ts"/>
/// <reference path="./infrastructure/search/SearchManager.ts"/>
/// <reference path="./infrastructure/menus/MenuRegistry.ts"/>
/// <reference path="./infrastructure/tools/ToolRegistry.ts"/>
/// <reference path="./infrastructure/toolbarGroup/ToolbarGroupRegistry.ts"/>
/// <reference path="./infrastructure/undo/UndoManager.ts"/>
/// <reference path="./infrastructure/webMap/WebMapConverter.ts"/>
/// <reference path="./infrastructure/project/ProjectConverter.ts"/>
/**
 * Contains infrastructural components used for authoring and extending the Geocortex Viewer for HTML5.
 */
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var FormatUtils = essentialsHtmlViewer.mapping.infrastructure.FormatUtils;
        var ViewerApplication = (function (_super) {
            __extends(ViewerApplication, _super);
            function ViewerApplication(configObject, hostElement, id, configTokens) {
                _super.call(this, configObject, hostElement, id, configTokens);
                this.version = geocortex.essentialsHtmlViewer.version;
                this.markupLayer = new Observable();
                this.isArcGisWebApp = false;
                this._workflowActivityDispatcher = null;
                this._activityTypeHandlerQueue = [];
                this._activityIdHandlerQueue = [];
                this._localeResourcesLoaded = false;
                this._initialProjectPromise = null;
                /**
                 * A list of locales that are supported by Moment.js.
                 */
                this._momentLocales = ["af", "ar", "ar-MA", "ar-SA", "ar-TN", "az", "be", "bg", "bn", "bo", "br", "bs", "ca", "cs", "cv", "cy", "da", "de", "de-AT", "el", "en-AU", "en-CA", "en-GB", "eo", "es", "et", "eu", "fa", "fi", "fo", "fr", "fr-CA", "fy", "gl", "he", "hi", "hr", "hu", "hy-AM", "id", "is", "it", "ja", "jv", "ka", "km", "ko", "lb", "lt", "lv", "me", "mk", "ml", "mr", "ms", "ms-MY", "my", "nb", "ne", "nl", "nn", "pl", "pt", "pt-BR", "ro", "ru", "si", "sk", "sl", "sq", "sr", "sr-Cyrl", "sv", "ta", "th", "tl-PH", "tr", "tzl", "tzm", "tzm-Latn", "uk", "uz", "vi", "zh-CN", "zh-TW"];
                /**
                 * A list of locales that are supported by Globalize.js.
                 */
                this._globalizeLocales = ["af", "ar", "ar-MA", "ar-SA", "ar-TN", "az", "be", "bg", "bn", "bo", "br", "bs", "ca", "cs", "cy", "da", "de", "de-AT", "el", "en", "en-AU", "en-CA", "en-GB", "eo", "es", "et", "eu", "fa", "fi", "fo", "fr", "fr-CA", "fy", "gl", "he", "hi", "hr", "hu", "hy", "id", "is", "it", "ja", "ka", "km", "ko", "lb", "lt", "lv", "mk", "ml", "mr", "ms", "my", "nb", "ne", "nl", "nn", "pl", "pt", "ro", "ru", "si", "sk", "sl", "sq", "sr", "sr-Cyrl", "sv", "ta", "th", "tr", "tzm", "tzm-Latn", "uk", "uz", "vi", "zh"];
                this["___uaIsiPad"] = !!navigator.userAgent.match(/iPad/i);
                this.accessibilityManager = new geocortex.essentialsHtmlViewer.mapping.infrastructure.accessibility.AccessibilityManager(this);
                this.coordinatesManager = new geocortex.essentialsHtmlViewer.mapping.infrastructure.coordinates.CoordinatesManager(this);
                this.featureSetManager = new geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetManager(this);
                this.searchManager = new geocortex.essentialsHtmlViewer.mapping.infrastructure.search.SearchManager(this);
                this.highlightManager = new geocortex.essentialsHtmlViewer.mapping.infrastructure.HighlightManager(this);
                this.nativeManager = new essentialsHtmlViewer.mapping.infrastructure.nativeIntegration.NativeManager(this);
                this.offlineManager = new essentialsHtmlViewer.mapping.infrastructure.offline.OfflineManager(this, "Mapping.Infrastructure");
                this.toolRegistry = new geocortex.essentialsHtmlViewer.mapping.infrastructure.tools.ToolRegistry(this);
                this.menuRegistry = new geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuRegistry(this);
                this.toolbarGroupRegistry = new geocortex.essentialsHtmlViewer.mapping.infrastructure.toolbarGroup.ToolbarGroupRegistry(this);
                this.stateManager = new geocortex.essentialsHtmlViewer.mapping.infrastructure.applicationState.StateManager(this, "Mapping.Infrastructure");
                this.undoManager = new geocortex.essentialsHtmlViewer.mapping.infrastructure.undo.UndoManager(this);
                this.project = new essentialsHtmlViewer.mapping.infrastructure.project.ProjectManager(this);
                this.webMap = new essentialsHtmlViewer.mapping.infrastructure.webMap.WebMapManager(this);
                this.bookmarks = new essentialsHtmlViewer.mapping.infrastructure.BookmarkManager(this);
                this._applicationContentPolicy = new essentialsHtmlViewer.mapping.infrastructure.ContentPolicy(this);
                this._registerApplicationLevelCommands();
            }
            Object.defineProperty(ViewerApplication.prototype, "defaultContentPolicy", {
                get: function () {
                    return this._applicationContentPolicy;
                },
                enumerable: true,
                configurable: true
            });
            ViewerApplication.prototype.followNavigationLink = function (args) {
                var url = args.url, element = args.element;
                var uriDetails = {
                    uri: args.url,
                    attribute: "href",
                    tag: "a",
                    type: essentialsHtmlViewer.mapping.infrastructure.FilterUtils.UriType.NavigableLink,
                    linkChallengeCallback: function (accepted, uri) {
                        if (accepted) {
                            var target = "_blank";
                            if (element && element.hasAttribute("target")) {
                                target = element.getAttribute("target");
                            }
                            window.open(uri.uri, target);
                        }
                        return false;
                    }
                };
                // If can resolve trust for this link synchronously, simply return true. Callers can use the return directly in their onclick handlers
                // in order to let the link through or not.
                var trusted = this._applicationContentPolicy.tryScreenNavLinkSynchronously(uriDetails);
                if (trusted) {
                    return true;
                }
                else {
                    this._executeOpenWebPage(args);
                    return false;
                }
            };
            ViewerApplication.prototype._registerApplicationLevelCommands = function () {
                this.command("OpenWebPage").register(this, this._executeOpenWebPage);
            };
            ViewerApplication.prototype._executeOpenWebPage = function (argument) {
                var url = typeof argument === "string" ? argument : argument["url"];
                var element = typeof argument === "string" ? null : argument["element"] ? argument["element"] : null;
                // GVH-10937 added property isLink to sidestep url = decodeURIComponent(url) for opening links that must not be modified/encoded
                var isLink = typeof argument === "string" ? null : argument["isLink"] ? argument["isLink"] : null;
                var acceptableSchemes = ["http", "https", "ftp", "ftps", "gopher", "mailto"];
                // GVH-10937 if opening a web page, the address is not modified/encoded
                if (!isLink) {
                    url = decodeURIComponent(url);
                }
                // TODO: This is deprecated/url! Remove!
                var dUrl = new dojo._Url(url);
                if (acceptableSchemes.indexOf(dUrl.scheme) < 0) {
                    this.trace.warning("Could not open '" + url + "': Invalid URI scheme.");
                    return;
                }
                var open = function (uri, element) {
                    var target = "_blank";
                    if (element && element.hasAttribute("target")) {
                        target = element.getAttribute("target");
                    }
                    window.open(uri, target);
                };
                // SECURITY: Attempt to screen URIs synchronously.
                // If this can't be done, schedule a dialog that will prompt the user for trust.
                var uriDetails = {
                    uri: url,
                    attribute: "href",
                    tag: "a",
                    type: essentialsHtmlViewer.mapping.infrastructure.FilterUtils.UriType.NavigableLink,
                    linkChallengeCallback: function (accepted, uri) {
                        if (accepted) {
                            open(uri.uri, element);
                        }
                        return false;
                    }
                };
                // If we trust this URL, we can just open it synchronously.
                // If we don't, we'll need to screen the URI asynchronously.
                var promptDisabled = this._applicationContentPolicy.hasFlag(1 /* DisableSecurityPrompt */);
                if (promptDisabled || this._applicationContentPolicy.tryScreenNavLinkSynchronously(uriDetails)) {
                    open(uriDetails.uri, element);
                    return false;
                }
                else {
                    uriDetails.forcePrompt = true;
                    this._applicationContentPolicy.screenUris([uriDetails]);
                }
            };
            ViewerApplication.prototype.initialize = function () {
                var _this = this;
                // IE7 users get debug mode all the time. When not in debug mode, "data-binding" DOM attributes are removed. This causes binding problems in IE7
                // which are likely due to dojo.removeAttr and its effect on cloned elements (e.g. templates).
                // Note: document.all is an IE only thing and document.querySelector is 8+.
                if (document.all && !document.querySelector) {
                    this.debugMode = true;
                }
                // Populate the "ViewerConfigUri" token.
                var configUriPieces = this.configUri ? this.configUri.split("/") : window.location.href.split("/");
                var viewerConfigUri = configUriPieces.slice(0, configUriPieces.length - 1).join("/") + "/";
                this.configTokens["ViewerConfigUri"] = viewerConfigUri;
                if (this.getUrlParameter("gcxLocalServer")) {
                    this.localServerAddress = this.getUrlParameter("gcxLocalServer");
                }
                if (this.getUrlParameter("gcxLocalServerNamespace")) {
                    this.localServerNamespace = this.getUrlParameter("gcxLocalServerNamespace");
                }
                if (this.getUrlParameter("gcxLocalServerToken")) {
                    this.localServerToken = this.getUrlParameter("gcxLocalServerToken");
                }
                this.offlineManager.load();
                _super.prototype.initialize.call(this);
                // Begin loading project data if a project ID was specified via URL parameter.
                var projectId = this.getUrlParameter(essentialsHtmlViewer.mapping.infrastructure.project.PROJECT_QUERY_STRING_KEY);
                if (projectId) {
                    // If a guest link was also specified via URL parameter, set it on the document store.
                    var guestLink_1 = this.getUrlParameter(geocortex.essentials.documents.LINK_QUERY_STRING_KEY);
                    if (guestLink_1) {
                        this.waitUntilSiteInitialized()
                            .then(function () { return _this.site.documentStore.setGuestLink(guestLink_1); });
                    }
                    this.waitUntilAllLibrariesLoaded()
                        .then(function () { return _this.event("ProjectLoadingEvent").publish(projectId); });
                    this._initialProjectPromise = this.project.read(projectId)
                        .then(function (project) { return _this.project._beginLoad(project); })
                        .catch(function (error) {
                        _this.trace.error("Error loading project: {0}".format(error.message), error);
                    });
                    var originalInitialStateAppliedCallback = this.initialStateAppliedCallback;
                    this.initialStateAppliedCallback = function (app) {
                        if (_this.project.isLoading) {
                            _this.project._finishLoad();
                        }
                        if (originalInitialStateAppliedCallback) {
                            originalInitialStateAppliedCallback(app);
                        }
                    };
                }
            };
            /**
             * Returns a promise that is fulfilled when the Essentials site is initialized.
             */
            ViewerApplication.prototype.waitUntilSiteInitialized = function () {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    if (_this.site && _this.site.isInitialized) {
                        resolve();
                    }
                    else {
                        _this.event("SiteInitializedEvent").once(_this, function (site) { resolve(); });
                        _this.event("SiteInitializationFailedEvent").once(_this, function (error) { reject(error); });
                        _this.event("SiteAuthorizationFailedEvent").once(_this, function (error) { reject(error); });
                    }
                });
            };
            /**
             * Returns a promise that is fulfilled when the Document Store is initialized.
             */
            ViewerApplication.prototype.waitUntilDocumentStoreInitialized = function () {
                var _this = this;
                return this.waitUntilSiteInitialized()
                    .then(function () { return _this.site.documentStore.onInitialized(); });
            };
            /**
             * Returns a promise that is fulfilled when the esri map is loaded (i.e., the first service layer has been
             * added to the map and its spatial reference set).
             */
            ViewerApplication.prototype.waitUntilMapLoaded = function () {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    if (_this.map && _this.map.loaded) {
                        resolve();
                    }
                    else {
                        if (_this.map) {
                            var loadHandle = _this.map.on("load", function (e) {
                                loadHandle.remove();
                                resolve();
                            });
                        }
                        else {
                            // This is the very first event that is fired after the map is set.
                            _this.event("SiteInitializingEvent").once(_this, function () {
                                var loadHandle = _this.map.on("load", function (e) {
                                    loadHandle.remove();
                                    resolve();
                                });
                            });
                        }
                    }
                });
            };
            /**
             * Returns a promise that is fulfilled when the given service layer has finished loading.
             */
            ViewerApplication.prototype.waitUntilServiceLayerLoaded = function (serviceLayer) {
                return new Promise(function (resolve, reject) {
                    if (serviceLayer.loadError) {
                        reject(serviceLayer.loadError);
                    }
                    else if (serviceLayer.loaded) {
                        resolve();
                    }
                    else {
                        var loadHandle = serviceLayer.on("load", function (e) {
                            loadHandle.remove();
                            errorHandle.remove();
                            resolve();
                        });
                        var errorHandle = serviceLayer.on("error", function (e) {
                            loadHandle.remove();
                            errorHandle.remove();
                            reject(e.error);
                        });
                    }
                });
            };
            /**
             * Returns a promise that is fulfilled when all service layers in the site have finished loading.
             */
            ViewerApplication.prototype.waitUntilSiteServiceLayersLoaded = function () {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    if (_this.site && _this.site.serviceLayersLoaded) {
                        resolve();
                    }
                    else {
                        _this.event("SiteServiceLayersLoadedEvent").once(_this, function (site) { resolve(); });
                        _this.event("SiteInitializationFailedEvent").once(_this, function (error) { reject(error); });
                        _this.event("SiteAuthorizationFailedEvent").once(_this, function (error) { reject(error); });
                    }
                });
            };
            /**
             * Returns a promise that is fulfilled when the all libraries are loaded.
             */
            ViewerApplication.prototype.waitUntilAllLibrariesLoaded = function () {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    if (_this.allLibrariesLoaded) {
                        resolve();
                    }
                    else {
                        _this.event("ViewerLibrariesDownloadedEvent").once(_this, function (args) { resolve(); });
                    }
                });
            };
            /**
             * Returns a promise that is fulfilled when the view with the given ID is initialized.
             */
            ViewerApplication.prototype.waitUntilViewInitialized = function (viewId) {
                var _this = this;
                return new Promise(function (resolve, reject) {
                    var view = _this.viewManager.getViewById(viewId);
                    if (view && view.initiallyBound) {
                        resolve(view);
                    }
                    else {
                        var token = _this.event("ViewInitializedEvent").subscribe(_this, function (view) {
                            if (view.id === viewId) {
                                resolve(view);
                                _this.event("ViewInitializedEvent").unsubscribe(token);
                            }
                        });
                    }
                });
            };
            ViewerApplication.prototype.registerActivityTypeHandler = function (typeName, handler) {
                if (!this._workflowActivityDispatcher) {
                    this._activityTypeHandlerQueue.push({ typeName: typeName, handler: handler });
                }
                else {
                    this._workflowActivityDispatcher.registerActivityHandler(typeName, handler);
                }
            };
            ViewerApplication.prototype.registerActivityIdHandler = function (id, handler) {
                if (!this._workflowActivityDispatcher) {
                    this._activityIdHandlerQueue.push({ id: id, handler: handler });
                }
                else {
                    this._workflowActivityDispatcher.registerExternalIdHandler(id, handler);
                }
            };
            ViewerApplication.prototype.getWorkflowActivityDispatcher = function () {
                return this._workflowActivityDispatcher;
            };
            ViewerApplication.prototype.setWorkflowActivityDispatcher = function (dispatcher) {
                this._workflowActivityDispatcher = dispatcher;
                // Register any queued up activity type handlers.
                for (var i = 0; i < this._activityTypeHandlerQueue.length; ++i) {
                    var typeHandlerEntry = this._activityTypeHandlerQueue[i];
                    this._workflowActivityDispatcher.registerActivityHandler(typeHandlerEntry.typeName, typeHandlerEntry.handler);
                }
                this._activityTypeHandlerQueue.length = 0;
                // Register any queued up activity type handlers.
                for (var i = 0; i < this._activityIdHandlerQueue.length; ++i) {
                    var idHandlerEntry = this._activityIdHandlerQueue[i];
                    this._workflowActivityDispatcher.registerExternalIdHandler(idHandlerEntry.id, idHandlerEntry.handler);
                }
                this._activityIdHandlerQueue.length = 0;
            };
            /**
             * Shuts down the application, releasing all modules, views, bindings, view models, regions, commands, and events.
             */
            ViewerApplication.prototype.shutdown = function (state) {
                this.toolRegistry.clear();
                this.undoManager.destroy();
                _super.prototype.shutdown.call(this, state);
            };
            /**
             * Called immediately after the configuration object has been loaded from JSON, and before any libraries are downloaded.
             * have been downloaded.
             * @protected
             */
            ViewerApplication.prototype.onConfigurationLoaded = function (configObject) {
                var _this = this;
                var config = configObject["configuration"];
                // GVH-10205: Allowing image sources through by default.
                var disablePromptOnImages = true;
                // Check configuration for `ContentPolicy` flags.
                if (config.hasOwnProperty("application") && config["application"].hasOwnProperty("contentPolicy")) {
                    var policyConfig = config.application.contentPolicy;
                    if (policyConfig["disableSecurityPrompt"]) {
                        this._applicationContentPolicy.setFlag(1 /* DisableSecurityPrompt */);
                    }
                    // GVH-10205: Allowing image sources through by default.
                    if (policyConfig["disablePromptOnImages"] === false) {
                        disablePromptOnImages = false;
                    }
                    // When user clicks "Yes" on "Potentially Untrusted Content Encountered", trust only exact url.
                    // Hence, if Url is ..../images/kittens.gif, we will have popup for ..../images/dogs.gif.
                    // By default, we start trusting everything in ..../images/ which can be potentially dangerous especially if
                    // someone is using a url shortner.
                    if (policyConfig["trustExactUrl"] === true) {
                        this._applicationContentPolicy.setFlag(4 /* TrustExactUrl */);
                    }
                }
                if (disablePromptOnImages) {
                    this._applicationContentPolicy.setFlag(2 /* DisablePromptOnImages */);
                }
                // Calling `screenUris` here has the effect of initializing the app's content policy as soon as
                // the site becomes available, which makes handling hyperlinks easier.
                this._applicationContentPolicy.screenUris([]);
                // Check configuration for locale.
                if (config && config.hasOwnProperty("application") && config.application.locale) {
                    this.locale = config.application.locale;
                }
                // Check URL parameter for locale.
                if (this.urlParameters && this.getUrlParameter("locale")) {
                    this.locale = this.getUrlParameter("locale");
                }
                // Set default language tag for document using locale
                var defaultLanguage = this.locale || "en-US";
                document.documentElement.setAttribute("lang", defaultLanguage);
                this._loadThirdPartyLocaleResources().then(function () {
                    if ($ && $["timepicker"]) {
                        // HACK ALERT: Hook jQuery UI time formatting with our own formatting when "gcxTimeFormat" or "gcxTimeStyle" are present in the options.
                        var Timepicker = Object.getPrototypeOf($["timepicker"]);
                        if (Timepicker._onTimeChange) {
                            Timepicker._base_onTimeChange = Timepicker._onTimeChange;
                            Timepicker._onTimeChange = function () {
                                this._base_onTimeChange();
                                if (this._defaults && this._defaults.gcxTimeFormat && this.$timeObj) {
                                    var formattedTime = FormatUtils.formatDate($(this.$input).datepicker("getDate"), this._defaults.gcxTimeFormat);
                                    this.$timeObj.text(formattedTime);
                                }
                                if (this._defaults && this._defaults.gcxTimeStyle === true) {
                                    var rootObj = this.$timeObj ? this.$timeObj.prevObject : null;
                                    if (rootObj && $(".info-message", rootObj).length !== 1) {
                                        rootObj.append("<div class='info-message'></div>");
                                    }
                                    var infoMsg = rootObj ? $(".info-message", rootObj) : null;
                                    if (infoMsg) {
                                        infoMsg.text(this._defaults.timeText + ": " + this.$timeObj.text());
                                        this.$timeObj.css("display", "none");
                                        $(this.$timeObj.selector + "_label").css("display", "none");
                                    }
                                }
                            };
                        }
                    }
                    if ($ && $["datepicker"] && $["datepicker"]["_showDatepicker"]) {
                        // HACK ALERT: If we are showing our own input with "gcxDatepicker" class, set the focus to that input
                        // instead whenever the date picker is shown. This is needed for keyboard navigation to work properly
                        // with date pickers (see GVH-7540).
                        $["datepicker"]["__base_showDatepicker"] = $["datepicker"]["_showDatepicker"];
                        $["datepicker"]["_showDatepicker"] = function (input) {
                            this.__base_showDatepicker(input);
                            var gcxDatepickerInput = $(input).siblings(".gcxDatepicker");
                            if (gcxDatepickerInput.length) {
                                gcxDatepickerInput.focus();
                            }
                        };
                    }
                    if (config.hasOwnProperty("application") && config["application"].hasOwnProperty("geometryServiceUrl")) {
                        esri.config.defaults.geometryService = new esri.tasks.GeometryService(config["application"]["geometryServiceUrl"]);
                    }
                    // Check if datum transforms have been specified, otherwise add defaults.
                    if (config.hasOwnProperty("application") && config["application"].hasOwnProperty("datumTransforms")) {
                        essentialsHtmlViewer.mapping.infrastructure.GeometryUtils.registerDatumTransforms(config["application"]["datumTransforms"]);
                    }
                    else {
                        essentialsHtmlViewer.mapping.infrastructure.GeometryUtils.registerDefaultDatumTransforms();
                    }
                    // Early check if we need to perform an OAuth2 logon (faster than waiting for the check in the Site)
                    if (configObject.configuration.application && configObject.configuration.application.oAuth2ClientId) {
                        var uri = window.location.href;
                        // Do the redirect to the logon page if we don't have a grant yet (token in the fragment), and we also do not have an error (such as user cancelled the sign in)
                        // If the user did cancel the sign in, we'll let the application start up so that the SiteModule can notify the user of the error
                        if (!geocortex.essentials.OAuth2Client.applicationHasImplicitGrant() && !geocortex.essentials.OAuth2Client.applicationHasImplicitGrantError()) {
                            var logonUri = configObject.configuration.application.oAuth2AuthorizeUri || "http://www.arcgisonline.com/sharing/oauth2/authorize";
                            geocortex.essentials.OAuth2Client.redirectToLogOnPage(logonUri, configObject.configuration.application.oAuth2ClientId);
                            _this.abortInitialization = true;
                            return;
                        }
                    }
                    _super.prototype.onConfigurationLoaded.call(_this, configObject);
                });
            };
            ViewerApplication.prototype.getInitialState = function (moduleName, libraryId) {
                var _this = this;
                if (!this._initialProjectPromise || this._initialProjectPromise.isRejected()) {
                    return Promise.resolve(null);
                }
                return this._initialProjectPromise.then(function () {
                    var project = _this.project.current;
                    if (project && project.content && project.content.moduleState) {
                        return project.content.moduleState[moduleName];
                    }
                    else {
                        return null;
                    }
                });
            };
            Object.defineProperty(ViewerApplication.prototype, "locale", {
                get: function () {
                    return this._locale;
                },
                set: function (val) {
                    this._locale = this._canonicalizeLocale(val);
                    if (this._localeResourcesLoaded) {
                        moment.locale(this._getMomentLocaleForLocale(this._locale));
                        _globalize.locale(this._getGlobalizeLocaleForLocale(this._locale));
                    }
                },
                enumerable: true,
                configurable: true
            });
            ViewerApplication.prototype.doWhenMapInitialized = function (action) {
                var _this = this;
                if (this.isArcGisWebApp) {
                    action();
                }
                else if (this.site && this.site.isInitialized) {
                    action();
                }
                else {
                    var token = this.eventRegistry.event("SiteServiceLayersLoadedEvent").subscribe(this, function () {
                        _this.eventRegistry.event("SiteServiceLayersLoadedEvent").unsubscribe(token);
                        action();
                    });
                }
            };
            /**
             * Loads necessary locale resources for 3rd party libraries once the application locale is known.
             */
            ViewerApplication.prototype._loadThirdPartyLocaleResources = function () {
                var _this = this;
                // The dojo loader breaks loading of AMD-enabled modules, causing "multipleDefine" errors. 
                // Temporarily disable it and re-enable it later.
                var amd;
                if (typeof define === "function") {
                    amd = define.amd;
                    delete define.amd;
                }
                return Promise.all([this._loadMomentLocaleData(), this._loadGlobalizeLocaleData()]).then(function () {
                    typeof define === "function" && (define.amd = amd);
                    _this._localeResourcesLoaded = true;
                }, function (error) {
                    typeof define === "function" && (define.amd = amd);
                });
            };
            ViewerApplication.prototype._loadMomentLocaleData = function () {
                var _this = this;
                var locale = this._getMomentLocaleForLocale(this.locale);
                if (moment.localeData(locale)) {
                    // We already have this locale loaded. Esri's JavaScript API will automatically load the locale
                    // matching the browser's settings, so we only need to load a different one when it's specified
                    // by our software, e.g. via the locale= URL parameter.
                    return Promise.resolve();
                }
                return new Promise(function (resolve, reject) {
                    if (locale === "en") {
                        // This locale is built in to Moment.js and doesn't require a separate download.
                        resolve();
                    }
                    else {
                        var url = "./Resources/Scripts/moment/locale/" + locale + ".js";
                        _this.includeScript(url, function (script) {
                            moment.locale(locale);
                            resolve();
                        }, reject);
                    }
                });
            };
            ViewerApplication.prototype._loadGlobalizeLocaleData = function () {
                var locale = this._getGlobalizeLocaleForLocale(this.locale);
                var url = "./Resources/Scripts/globalize/locale/" + locale + ".json";
                return this.fetchConfigResource({ url: url }).then(function (json) {
                    var localeData = JSON.parse(json);
                    _globalize.load(localeData);
                    _globalize.locale(locale);
                });
            };
            /**
             * Maps a locale code to one of the available locales for Moment.js.
             */
            ViewerApplication.prototype._getMomentLocaleForLocale = function (locale) {
                return this._getBestMatchLocale(locale, this._momentLocales);
            };
            /**
             * Maps a locale code to one of the available locales for Globalize.js.
             */
            ViewerApplication.prototype._getGlobalizeLocaleForLocale = function (locale) {
                return this._getBestMatchLocale(locale, this._globalizeLocales);
            };
            /**
             * Given a list of available locales, chooses the most appropriate match for a target locale.
             */
            ViewerApplication.prototype._getBestMatchLocale = function (locale, availableLocales) {
                locale = this._canonicalizeLocale(locale);
                var localeParts = this._parseLocale(locale);
                if (availableLocales.indexOf(locale) >= 0) {
                    return locale;
                }
                else if (localeParts.script) {
                    // Try language+script, e.g. if there is no "zh-Hans-CN", try just "zh-Hans".
                    locale = localeParts.language + "-" + localeParts.script;
                    if (availableLocales.indexOf(locale) >= 0) {
                        return locale;
                    }
                    // Try language+territory, e.g. if there is no "zh-Hans-CN", try just "zh-CN".
                    locale = localeParts.language + "-" + localeParts.territory;
                    if (availableLocales.indexOf(locale) >= 0) {
                        return locale;
                    }
                }
                else if (localeParts.territory) {
                    // Try language alone, e.g. if there is no "de-CH", try just "de".
                    locale = localeParts.language;
                    if (availableLocales.indexOf(locale) >= 0) {
                        return locale;
                    }
                }
                return "en";
            };
            /**
             * Parses a locale code into its component parts.
             */
            ViewerApplication.prototype._parseLocale = function (locale) {
                if (!locale) {
                    throw new Error("Invalid locale: {0}".format(locale));
                }
                var parts = locale.split("-");
                if (parts.length < 1 || parts.length > 3 || parts.some(function (x) { return x.length === 0; })) {
                    throw new Error("Invalid locale: {0}".format(locale));
                }
                var result = { language: parts[0].toLowerCase() };
                if (parts.length == 2) {
                    if (parts[1].length == 2) {
                        result.territory = parts[1].toUpperCase();
                    }
                    else {
                        result.script = parts[1][0].toUpperCase() + parts[1].slice(1).toLowerCase();
                    }
                }
                else if (parts.length === 3) {
                    result.script = parts[1][0].toUpperCase() + parts[1].slice(1).toLowerCase();
                    result.territory = parts[2].toUpperCase();
                }
                return result;
            };
            /**
             * Converts a locale code to its canonicalized form, e.g. "de-ch" becomes "de-CH", "ZH-HANS-CN" becomes "zh-Hans-CN").
             */
            ViewerApplication.prototype._canonicalizeLocale = function (locale) {
                var localeParts = this._parseLocale(locale);
                var result = localeParts.language;
                if (localeParts.script) {
                    result += "-" + localeParts.script;
                }
                if (localeParts.territory) {
                    result += "-" + localeParts.territory;
                }
                return result;
            };
            return ViewerApplication;
        }(geocortex.framework.application.Application));
        essentialsHtmlViewer.ViewerApplication = ViewerApplication;
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../_Definitions/framework.d.ts"/>
/// <reference path="../../_Definitions/essentials.d.ts"/>
/// <reference path="../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../Viewer.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var GeometryUtils;
                (function (GeometryUtils) {
                    GeometryUtils.DEFAULT_GEOMETRY_SERVICE_URI = "http://sampleserver6.arcgisonline.com/arcgis/rest/services/Utilities/Geometry/GeometryServer";
                    /**@private */
                    var _datumTransformRegistry = [];
                    var _geometryService = null;
                    /**
                     *
                     */
                    function isValidGeometry(geometry) {
                        var nullOrUndefined = geocortex.framework.utils.isNullOrUndefined;
                        if (nullOrUndefined(geometry)) {
                            return false;
                        }
                        switch (geometry.type) {
                            case "point":
                                var castPoint = geometry;
                                return !nullOrUndefined(castPoint.x) && !nullOrUndefined(castPoint.y);
                            case "multipoint":
                                var points = geometry.points;
                                return points && points.length > 0;
                            case "polyline":
                                var paths = geometry.paths;
                                return paths && paths.length > 0;
                            case "polygon":
                                var rings = geometry.rings;
                                return rings && rings.length > 0;
                            case "extent":
                                var castExtent = geometry;
                                return !nullOrUndefined(castExtent.xmin) && !nullOrUndefined(castExtent.xmax) && !nullOrUndefined(castExtent.ymin) && !nullOrUndefined(castExtent.ymax);
                            default:
                                return false;
                        }
                    }
                    GeometryUtils.isValidGeometry = isValidGeometry;
                    /**
                     * Returns an approximation of the center point of the given geometry, as measured in Cartesian space.
                     * @param geometry The geometry whose center needs to be returned
                     */
                    function getMiddle(geometry) {
                        if (!geometry || !geometry.type || !isValidGeometry(geometry)) {
                            return null;
                        }
                        var extent;
                        if (geometry.type == "point") {
                            return geometry;
                        }
                        else if (geometry.type == "multipoint") {
                            extent = geometry.getExtent();
                            return extent ? extent.getCenter() : null;
                        }
                        else if (geometry.type == "polyline") {
                            // The middle point of the polyline is calculated by first measuring the total length of the polyline, and then finding the segment in
                            // which the midpoint of length is reached.
                            var line = geometry;
                            // Measure the total distance of the line
                            var totalDistance = 0;
                            for (var j = 0; j < line.paths.length; j++) {
                                for (var i = 0; i < line.paths[j].length - 1; i++) {
                                    var pointA = new esri.geometry.Point(line.paths[j][i]);
                                    var pointB = new esri.geometry.Point(line.paths[j][i + 1]);
                                    totalDistance += _distance(pointA, pointB);
                                }
                            }
                            // Find the middle segment and return the middle point of the whole polyline interpolated along the middle segment
                            var travelled = 0;
                            for (j = 0; j < line.paths.length; j++) {
                                for (i = 0; i < line.paths[j].length - 1; i++) {
                                    var pointA = new esri.geometry.Point(line.paths[j][i]);
                                    var pointB = new esri.geometry.Point(line.paths[j][i + 1]);
                                    var distance = _distance(pointA, pointB);
                                    if (travelled + distance > totalDistance / 2) {
                                        var distanceToMid = totalDistance / 2 - travelled;
                                        var dx = pointB.x - pointA.x;
                                        var dy = pointB.y - pointA.y;
                                        var steps = distance / distanceToMid;
                                        var xStep = dx / steps;
                                        var yStep = dy / steps;
                                        return new esri.geometry.Point(pointA.x + xStep, pointA.y + yStep, geometry.spatialReference);
                                    }
                                    travelled += distance;
                                }
                            }
                        }
                        else if (geometry.type == "polygon") {
                            extent = geometry.getExtent();
                            return extent ? extent.getCenter() : null;
                        }
                        else if (geometry.type == "extent") {
                            return geometry.getCenter();
                        }
                        return null;
                    }
                    GeometryUtils.getMiddle = getMiddle;
                    /**
                     * Returns the midpoint of the line segment defined by two endpoints.
                     * @param pointA The beginning point of the line segment.
                     * @param pointB The ending point of the line segment.
                     */
                    function getMidpoint(pointA, pointB) {
                        if (!pointA || !pointB) {
                            throw new Error("The beginning and ending points are required.");
                        }
                        var midPoint = new esri.geometry.Point({
                            x: (pointA.x + pointB.x) / 2,
                            y: (pointA.y + pointB.y) / 2,
                            spatialReference: pointA.spatialReference.toJson()
                        });
                        return midPoint;
                    }
                    GeometryUtils.getMidpoint = getMidpoint;
                    /**
                     * Returns the distance between two given points.
                     * @param pointA The beginning point in the distance calculation.
                     * @param pointB The ending point in the distance calculation.
                     */
                    function _distance(pointA, pointB) {
                        var dx = pointB.x - pointA.x;
                        var dy = pointB.y - pointA.y;
                        return Math.sqrt(dx * dx + dy * dy);
                    }
                    /**
                     * Returns the type of ESRI geometry
                     * @param typeName
                     * @param defaultType
                     */
                    function getEsriGeometryType(typeName, defaultType) {
                        if (!typeName) {
                            return null;
                        }
                        var drawType = null;
                        switch (typeName.toLowerCase()) {
                            case "rectangle":
                                drawType = esri.toolbars.Draw.EXTENT;
                                break;
                            case "freehandpolygon":
                                drawType = esri.toolbars.Draw.FREEHAND_POLYGON;
                                break;
                            case "freehandpolyline":
                                drawType = esri.toolbars.Draw.FREEHAND_POLYLINE;
                                break;
                            case "mappoint":
                                drawType = esri.toolbars.Draw.POINT;
                                break;
                            case "multipoint":
                                drawType = esri.toolbars.Draw.MULTI_POINT;
                                break;
                            case "polygon":
                                drawType = esri.toolbars.Draw.POLYGON;
                                break;
                            case "polyline":
                                drawType = esri.toolbars.Draw.POLYLINE;
                                break;
                            default:
                                drawType = defaultType || esri.toolbars.Draw.EXTENT;
                                break;
                        }
                        return drawType;
                    }
                    GeometryUtils.getEsriGeometryType = getEsriGeometryType;
                    /**
                     * This "protected" method is deprecated. Use the public "getGeometryService" instead. This is being retained in order to avoid breaking external/services
                     *  code that may be using it.
                     */
                    function _getGeometryService(app) {
                        return getGeometryService(app);
                    }
                    GeometryUtils._getGeometryService = _getGeometryService;
                    /**
                     * Returns the ESRI geometry service
                     * @param app The {@link geocortex.framework.application.Application}
                     */
                    function getGeometryService(app) {
                        if (!app || !app.configuration) {
                            return null;
                        }
                        else if (_geometryService && _geometryService.url && _geometryService.url.startsWith(app.configuration.geometryServiceUrl)) {
                            return _geometryService;
                        }
                        var url = app.configuration.geometryServiceUrl;
                        var token = app.configuration.geometryServiceToken;
                        if (token) {
                            url += ((url.indexOf("?") > -1) ? "&token=" : "?token=") + encodeURIComponent(token);
                            // Subscribe to token refresh notifications.
                            var serviceTokenRefreshedHandle = dojo.subscribe("ServiceTokenRefreshed", function (eventArgs) {
                                if (eventArgs.serviceUrl === app.configuration.geometryServiceUrl) {
                                    app.configuration.geometryServiceToken = eventArgs.token;
                                    // Clear the cached geometry service object so that it gets recreated with the new token the next time that it's needed.
                                    _geometryService = null;
                                    dojo.unsubscribe(serviceTokenRefreshedHandle);
                                }
                            });
                        }
                        //GVH-9394: Log a warning if the geometry service protocol is http when the viewer is https.
                        if (window.location.protocol == "https:" && !(/^(https|\/\/)/.test(url))) {
                            app.trace.warning("Mixed Content Warning: This Viewer was loaded over HTTPS but the geometry service was loaded over HTTP. This may limit functionality. Please configure the geometry service to be served securely.");
                        }
                        _geometryService = new esri.tasks.GeometryService(url);
                        return _geometryService;
                    }
                    GeometryUtils.getGeometryService = getGeometryService;
                    /**
                     * Determines if there requires a projection to go between a given Spatial Reference and the current application instance.
                     * @param geometry The geometry we would like to determine if it needs to be projected
                     * @param app An instance of the application (used to get the current map spatial reference).
                     */
                    function needsProjection(geometry, app) {
                        if (geocortex.essentials.GeometryUtilities.spatialRefsAreEqual(geometry.spatialReference, app.map.spatialReference, false)) {
                            return false;
                        }
                        return true;
                    }
                    GeometryUtils.needsProjection = needsProjection;
                    /**
                    * Projects a geometry from one coordinate system to another (well-known) coordinate system, firing a failure callback on error.
                    * @param geometry The geometry to project.
                    * @param outSR The spatial reference of the target coordinate system.
                    * @param callback The callback function for success (http://help.arcgis.com/en/webapi/javascript/arcgis/help/jsapi/geometryservice.htm#onProjectComplete).
                    * @param errback The error callback function.
                    * @param app An instance of the application (used to get the url to the geometry service).
                    */
                    function projectGeometry(geometry, outSR, callback, errback, app) {
                        if (!geometry || !geometry.spatialReference) {
                            if (errback) {
                                errback(new Error("Invalid geometry or spatial reference."));
                            }
                            return;
                        }
                        // Only project if the spatial reference is actually different
                        if (geometry.spatialReference.equals(outSR)) {
                            if (callback) {
                                callback(geometry);
                            }
                        }
                        else {
                            // Project map extent to geographic. Geocortex search always takes values in geographic
                            var projectParams = new esri.tasks.ProjectParameters();
                            projectParams.outSR = outSR;
                            projectParams.geometries = [geometry];
                            // Fire our success callback on success
                            var onComplete = function (geometries) {
                                if (geometries && geometries.length > 0 && callback) {
                                    callback(geometries[0]);
                                }
                            };
                            this.project(projectParams, onComplete, errback, app);
                        }
                    }
                    GeometryUtils.projectGeometry = projectGeometry;
                    /**
                    * Projects a geometry from one coordinate system to another (well-known) coordinate system with a transformation, firing a failure callback on error.
                    * @param geometry The geometry to project.
                    * @param outSR The spatial reference of the target coordinate system.
                    * @param transformationWkid The WKID for the transformation to be applied.
                    * @param callback The callback function for success (http://help.arcgis.com/en/webapi/javascript/arcgis/help/jsapi/geometryservice.htm#onProjectComplete).
                    * @param errback The error callback function.
                    * @param app An instance of the application (used to get the url to the geometry service).
                    */
                    function projectGeometryWithTransform(geometry, outSR, transformationWkid, callback, errback, app) {
                        if (!transformationWkid) {
                            // No transformation wkid provided, so let's use the standard function.
                            this.projectGeometry(geometry, outSR, callback, errback);
                            return;
                        }
                        if (!geometry || !geometry.spatialReference) {
                            if (errback) {
                                errback(new Error("Invalid geometry or spatial reference."));
                            }
                            return;
                        }
                        // Only project if the spatial reference is actually different
                        if (geometry.spatialReference.equals(outSR)) {
                            if (callback) {
                                callback(geometry);
                            }
                        }
                        else {
                            var projectParams = new esri.tasks.ProjectParameters();
                            projectParams.outSR = outSR;
                            projectParams.geometries = [geometry];
                            projectParams.transformation = { "wkid": transformationWkid };
                            // Fire our success callback on success
                            var onComplete = function (geometries) {
                                if (geometries && geometries.length > 0 && callback) {
                                    callback(geometries[0]);
                                }
                            };
                            this.project(projectParams, onComplete, errback, app);
                        }
                    }
                    GeometryUtils.projectGeometryWithTransform = projectGeometryWithTransform;
                    /**
                    * Projects the geometries provided in the projectParameters.
                    * @param projectParameters The project parameters (see http://help.arcgis.com/en/webapi/javascript/arcgis/help/jsapi/projectparameters.htm).
                    * @param callback The callback function for success (http://help.arcgis.com/en/webapi/javascript/arcgis/help/jsapi/geometryservice.htm#onProjectComplete).
                    * @param errback The error callback function.
                    * @param app An instance of the application (used to get the url to the geometry service).
                    */
                    function project(projectParameters, callback, errback, app) {
                        // projectParameters or equivalent is required
                        if (!projectParameters || (esri.tasks.hasOwnProperty("ProjectParameters") && !(projectParameters instanceof esri.tasks.ProjectParameters)) || !projectParameters.hasOwnProperty("outSR") || !projectParameters.hasOwnProperty("geometries")) {
                            if (errback && dojo.isFunction(errback)) {
                                var errorMsg = "projectParameters required.";
                                errback(new Error(errorMsg));
                            }
                            return;
                        }
                        // callback function required
                        if (!callback || !dojo.isFunction(callback)) {
                            if (errback && dojo.isFunction(errback)) {
                                var errorMsg = "callback required.";
                                errback(new Error(errorMsg));
                            }
                            return;
                        }
                        // callback function required
                        if (!projectParameters.outSR) {
                            if (errback && dojo.isFunction(errback)) {
                                var errorMsg = "output spatial reference is required.";
                                errback(new Error(errorMsg));
                            }
                            return;
                        }
                        var geometries = projectParameters.geometries;
                        var performProject = false;
                        // Check if there are any geometry
                        if (geometries && geometries.length > 0) {
                            // Check if the spatial reference are different (this means we need to project)
                            if (!geocortex.essentials.GeometryUtilities.spatialRefsAreEqual(geometries[0].spatialReference, projectParameters.outSR, false)) {
                                performProject = true;
                            }
                        }
                        // Check if we need to project the geometries
                        if (performProject) {
                            // Get the geometry service
                            var service = this._getGeometryService(app);
                            // Since we've already ensure the geometries need projection, if the following holds, they're different and we can project them locally.
                            if ((projectParameters.outSR.isWebMercator() && geometries[0].spatialReference.wkid === 4326) || (projectParameters.outSR.wkid === 4326 && geometries[0].spatialReference.isWebMercator())) {
                                this._projectLocally(projectParameters.geometries, projectParameters.outSR, callback, errback);
                                return;
                            }
                            // If we can't get the geometry service, raise an error
                            if (!service) {
                                if (errback && dojo.isFunction(errback)) {
                                    var errorMsg = "Unable to get the geometry service. Make sure a geometry service url is configured in the application.";
                                    errback(new Error(errorMsg));
                                }
                                return;
                            }
                            // Check if we need to apply a datum transformation for the projection
                            // If a transform has already been set, don't override it, as it may be applying some specific transform
                            var datumTransformParameters = getDatumTransformParameters(geometries[0].spatialReference, projectParameters.outSR);
                            if (datumTransformParameters && !projectParameters.transformation) {
                                projectParameters.transformation = datumTransformParameters.transformation;
                                projectParameters.transformForward = datumTransformParameters.transformForward;
                            }
                            // Perform the project
                            if (esri.tasks.hasOwnProperty("ProjectParameters")) {
                                // At the beginning of this method, we ensured that if ProjectParameters existed, that projectParameters was of that type. So we don't have to check that this is of the type here.
                                // Otherwise we would have to check that ProjectParameters exists, and if projectParameter is of that type.
                                service.project(projectParameters, callback, errback);
                            }
                            else {
                                service.project(projectParameters.geometries, projectParameters.outSR, callback, errback);
                            }
                        }
                        else {
                            callback(geometries);
                        }
                    }
                    GeometryUtils.project = project;
                    /**
                     * Simplify the polygons.
                     * @param polygons An array of esri.geometry.Polygons.
                     * @param callback A function to be called with the set of simplified polygons once completed.
                     * @param errback The error callback function.
                     * @param app An instance of the application (used to get the url to the geometry service).
                     */
                    function simplifyPolygons(polygons, callback, errback, app) {
                        // NOTE: The purpose of this method is that one day we may decide to do this client side, as such, this will give an api that we can change the internal workings of
                        // without breaking its use.
                        // Get the geometry service for this app
                        var service = this._getGeometryService(app);
                        // Call the esri geometry service simplify operation
                        service.simplify(polygons, callback, errback);
                    }
                    GeometryUtils.simplifyPolygons = simplifyPolygons;
                    /**
                     * Simplify a polygon.
                     * @param polygon A single esri.geometry.Polygon.
                     * @param callback A function to be called with a simplified polygon once completed.
                     * @param errback The error callback function.
                     * @param app An instance of the application (used to get the url to the geometry service).
                     */
                    function simplifyPolygon(polygon, callback, errback, app) {
                        // NOTE: The purpose of this method is that one day we may decide to do this client side, as such, this will give an api that we can change the internal workings of
                        // without breaking its use.
                        // We have to define our own simplify method, because we want a single polygon, but the polygons method takes and returns a list.
                        function simplifySuccess(polygons) {
                            if (polygons && polygons.length > 0) {
                                callback(polygons[0]);
                            }
                            else {
                                errback();
                            }
                        }
                        ;
                        this.simplifyPolygons([polygon], simplifySuccess, errback, app);
                    }
                    GeometryUtils.simplifyPolygon = simplifyPolygon;
                    /**
                     * Projects the geometries locally.
                     * @param geometries An array of geometries which needs to be projected.
                     * @param outSR {esri.SpatialReference} outSR The spatial reference to which the geometries should be converted
                     * @param callback A function to be called after the geometries have been projected.
                     * @param errback The error callback function.
                     * @private
                     */
                    function _projectLocally(geometries, outSR, callback, errback) {
                        var outGeometries = [];
                        for (var i = 0; i < geometries.length; i++) {
                            if (geometries[i].spatialReference.isWebMercator() && outSR.wkid === 4326) {
                                outGeometries[i] = esri.geometry.webMercatorToGeographic(geometries[i]);
                            }
                            else if (geometries[i].spatialReference.wkid === 4326 && outSR.isWebMercator()) {
                                outGeometries[i] = esri.geometry.geographicToWebMercator(geometries[i]);
                            }
                            else {
                                if (errback && dojo.isFunction(errback)) {
                                    var errorMsg = "Unable to get the geometry service. Make sure a geometry service url is configured in the application.";
                                    errback(new Error(errorMsg));
                                }
                                this.app.trace.error("An operation requiring projection attempted to project while offline, but was not between WebMercator and WGS84");
                            }
                        }
                        callback(outGeometries);
                    }
                    GeometryUtils._projectLocally = _projectLocally;
                    /**
                     * Creates and returns a circle with given specifications
                     * @params
                     * spatialReference Spatial Reference of the map
                     * centerPoint Center point of the circle
                     * radius Radius of the circle in meters
                     * ringSize Number of points in the ring that proximate the circle
                     */
                    function createCircle(spatialReference, centerPoint, radius, ringSize) {
                        // Array of points that make up the circle
                        var ring = [];
                        var angle = null;
                        // Number of points on the circle
                        var pts = ringSize || 40;
                        var circle = new esri.geometry.Polygon(spatialReference);
                        // Used to compute points on the circle
                        angle = 360 / pts;
                        for (var i = 1; i <= pts; i++) {
                            // Convert angle to radians
                            var radians = i * angle * Math.PI / 180;
                            // Add point to the circle
                            ring.push([centerPoint.x + radius * Math.cos(radians), centerPoint.y + radius * Math.sin(radians)]);
                        }
                        // To close the ring Start Point needs to be equal to End Point
                        ring.push(ring[0]);
                        circle.addRing(ring);
                        return circle;
                    }
                    GeometryUtils.createCircle = createCircle;
                    /**
                     * Fixes the aspect ratio, such that the width or height of the envelope is expanded
                     * so that the aspect ratio of the envelope matches that of the reference envelope.
                     * @param envelope The envelope, whose aspect ratio should be fixed.
                     * @param reference The reference envelope, to match the aspect ratio to.
                     * @returns A new envelope with the width or height adjusted to match the aspect ratio of the reference envelope.
                     */
                    function fixAspectRatio(newExtent, referenceExtent) {
                        var referenceAspect = referenceExtent.getWidth() / referenceExtent.getHeight();
                        var currentAspect = newExtent.getWidth() / newExtent.getHeight();
                        var newWidth = newExtent.getWidth();
                        var newHeight = newExtent.getHeight();
                        if (currentAspect < referenceAspect) {
                            // Expand the width
                            newWidth = referenceAspect * newHeight;
                        }
                        else {
                            // Expand the height
                            newHeight = (1 / referenceAspect) * newWidth;
                        }
                        var center = newExtent.getCenter();
                        return new esri.geometry.Extent(center.x - (newWidth / 2.0), center.y - (newHeight / 2.0), center.x + (newWidth / 2.0), center.y + (newHeight / 2.0), newExtent.spatialReference);
                    }
                    GeometryUtils.fixAspectRatio = fixAspectRatio;
                    /**
                     * Converts an extent to a polygon.
                     */
                    function extentToPolygon(envelope) {
                        var polygon = new esri.geometry.Polygon(envelope.spatialReference);
                        var points = new Array();
                        points.push(new esri.geometry.Point(envelope.getCenter().x - (envelope.getWidth() / 2), envelope.getCenter().y - (envelope.getHeight() / 2)));
                        points.push(new esri.geometry.Point(envelope.getCenter().x - (envelope.getWidth() / 2), envelope.getCenter().y + (envelope.getHeight() / 2)));
                        points.push(new esri.geometry.Point(envelope.getCenter().x + (envelope.getWidth() / 2), envelope.getCenter().y + (envelope.getHeight() / 2)));
                        points.push(new esri.geometry.Point(envelope.getCenter().x + (envelope.getWidth() / 2), envelope.getCenter().y - (envelope.getHeight() / 2)));
                        points.push(new esri.geometry.Point(envelope.getCenter().x - (envelope.getWidth() / 2), envelope.getCenter().y - (envelope.getHeight() / 2))); // Close the polygon
                        polygon.addRing(points);
                        return polygon;
                    }
                    GeometryUtils.extentToPolygon = extentToPolygon;
                    /**
                     * Compares two point geometries for equality. Returns true if both Point structures contain the same X, Y values and spatial reference; otherwise, false.
                     */
                    function pointsAreEqual(a, b) {
                        // Check they are both null or not null
                        if ((a && !b) || (!a && b)) {
                            return false;
                        }
                        if (!a) {
                            return true;
                        }
                        // Check X,Y
                        if (a.x !== b.x || a.y !== b.y) {
                            return false;
                        }
                        // Check the spatial reference
                        if ((!a.spatialReference && b.spatialReference) || (a.spatialReference && !b.spatialReference)) {
                            return false;
                        }
                        if (!a.spatialReference.equals(b.spatialReference)) {
                            return false;
                        }
                        return true;
                    }
                    GeometryUtils.pointsAreEqual = pointsAreEqual;
                    /**
                     * Registers default datum transforms. This includes RD New (28992), British National Grid (27700), and Czech S-JTSK(102067).
                     */
                    function registerDefaultDatumTransforms() {
                        var datumTransforms = [];
                        // Add RD New datum transform (Amersfoort_To_WGS_1984_2008_MB)
                        datumTransforms.push({
                            transformWkid: 108457,
                            fromWkid: 28992,
                            toWkid: 4326
                        });
                        // Add British National Grid datum transform (OSGB_1936_To_WGS_1984_1)
                        datumTransforms.push({
                            transformWkid: 1195,
                            fromWkid: 27700,
                            toWkid: 4326
                        });
                        // Add Czech S-JTSK datum transform (S_JTSK_To_WGS_1984_1)
                        datumTransforms.push({
                            transformWkid: 1623,
                            fromWkid: 102067,
                            toWkid: 4326
                        });
                        registerDatumTransforms(datumTransforms);
                    }
                    GeometryUtils.registerDefaultDatumTransforms = registerDefaultDatumTransforms;
                    /**
                     * Registers the datum transform to be used when projecting geometries between the specified spatial references.
                     * @param datumTransforms An array of datum transforms to add to the registry
                     */
                    function registerDatumTransforms(datumTransforms) {
                        datumTransforms.forEach(function (element) {
                            var fromSR = null;
                            if (element.fromWkid && element.fromWkid > 0) {
                                fromSR = new esri.SpatialReference(element.fromWkid);
                            }
                            else if (element.fromWkt) {
                                fromSR = new esri.SpatialReference(element.fromWkt);
                            }
                            var toSR = null;
                            if (element.toWkid && element.toWkid > 0) {
                                toSR = new esri.SpatialReference(element.toWkid);
                            }
                            else if (element.toWkt) {
                                toSR = new esri.SpatialReference(element.toWkt);
                            }
                            var transformation = null;
                            if (element.transformWkid && element.transformWkid > 0) {
                                transformation = new esri.SpatialReference(element.transformWkid);
                            }
                            else if (element.transformWkt) {
                                transformation = new esri.SpatialReference(element.transformWkt);
                            }
                            if (!fromSR || !toSR || !transformation) {
                                throw new Error("Invalid or missing spatial reference. Cannot register datum transform.");
                            }
                            _datumTransformRegistry.push({
                                fromSR: fromSR,
                                toSR: toSR,
                                transformation: transformation
                            });
                        });
                    }
                    GeometryUtils.registerDatumTransforms = registerDatumTransforms;
                    /**
                     * Retrieves the datum transform to be used when projecting geometries between the specified spatial references, and whether to transform forward.
                     * @param from The spatial reference you are projecting from.
                     * @param to The spatial reference you are projecting to.
                     * @returns An object with the properties `transformation` and `transformForward`, relating to the datum transform for the given spatial reference parameters.
                     */
                    function getDatumTransformParameters(from, to) {
                        if (!from || !to || _datumTransformRegistry.length == 0) {
                            return null;
                        }
                        var spatialRefsAreEqual = geocortex.essentials.GeometryUtilities.spatialRefsAreEqual;
                        for (var i = 0; i < _datumTransformRegistry.length; i++) {
                            var item = _datumTransformRegistry[i];
                            if (spatialRefsAreEqual(from, item.fromSR) && spatialRefsAreEqual(to, item.toSR)) {
                                return {
                                    transformation: item.transformation,
                                    transformForward: true
                                };
                            }
                            if (spatialRefsAreEqual(from, item.toSR) && spatialRefsAreEqual(to, item.fromSR)) {
                                return {
                                    transformation: item.transformation,
                                    transformForward: false
                                };
                            }
                        }
                        return null;
                    }
                    GeometryUtils.getDatumTransformParameters = getDatumTransformParameters;
                    /**
                     * Determines whether or not the geometries intersect.
                     * @param geometry1 The geometry that is tested for the intersects relationship to the other geometry.
                     * @param geometry2 The geometry being intersected.
                     * @return A promise for whether or not the geometries intersect.
                     */
                    function intersects(geometry1, geometry2) {
                        // Using a promise here in case we need to switch this method to use the asynchronous geometry engine in the future.
                        var executeDirective = function (resolve, reject) {
                            try {
                                require(["esri/geometry/geometryEngine"], function (geometryEngine) {
                                    resolve(geometryEngine.intersects(geometry1, geometry2));
                                });
                            }
                            catch (e) {
                                reject(e);
                            }
                        };
                        return new Promise(executeDirective);
                    }
                    GeometryUtils.intersects = intersects;
                    // All inputs must be of the same type of geometries and share one spatial reference
                    function unionGeometries(geometries) {
                        // Using a promise here in case we need to switch this method to use the asynchronous geometry engine in the future.
                        var executeDirective = function (resolve, reject) {
                            try {
                                require(["esri/geometry/geometryEngine"], function (geometryEngine) {
                                    resolve(geometryEngine.union(geometries));
                                });
                            }
                            catch (e) {
                                reject(e);
                            }
                        };
                        return new Promise(executeDirective);
                    }
                    GeometryUtils.unionGeometries = unionGeometries;
                    /**
                     * Separate a multi-part geometry into a list of individual geometries.
                     * @param geometry The geometry to separate.
                     */
                    function explodeGeometry(geometry) {
                        switch (geometry.type) {
                            case "polygon":
                                return geometry.rings.map(function (ring) { return new esri.geometry.Polygon(ring).setSpatialReference(geometry.spatialReference); });
                            case "polyline":
                                return geometry.paths.map(function (path) { return new esri.geometry.Polyline(path).setSpatialReference(geometry.spatialReference); });
                            case "multipoint":
                                return geometry.points.map(function (point) { return new esri.geometry.Point(point, geometry.spatialReference); });
                        }
                        // Just return the geometry if it is not supported
                        return [geometry];
                    }
                    GeometryUtils.explodeGeometry = explodeGeometry;
                    /**
                     * Split polyline or polygon geometries where they cross the cutter polyline.
                     * @param geometries The polyline or polygon geometries to cut.
                     * @param cutter The polyline used to cut the geometries.
                     * @param app The {@link geocortex.framework.application.Application}.
                     */
                    function cutGeometries(geometries, cutter, app) {
                        var _this = this;
                        var executeDirective = function (resolve, reject) {
                            var service = _this.getGeometryService(app);
                            if (!service) {
                                return Promise.reject(new Error("Unable to get the geometry service. Make sure a geometry service url is configured in the application."));
                            }
                            try {
                                service.cut(geometries, cutter).then(function (results) {
                                    // Create a list of each cut operation which contains the resulting geometries
                                    var cutGeometries = [];
                                    for (var i = 0; i < results.geometries.length; i++) {
                                        var cutIndex = results.cutIndexes[i];
                                        if (!cutGeometries[cutIndex]) {
                                            cutGeometries[cutIndex] = [];
                                        }
                                        cutGeometries[cutIndex].push(results.geometries[i]);
                                    }
                                    resolve(cutGeometries);
                                });
                            }
                            catch (e) {
                                reject(e);
                            }
                        };
                        return new Promise(executeDirective);
                    }
                    GeometryUtils.cutGeometries = cutGeometries;
                    /**
                     * Converts an envelope to a ring.
                     */
                    function toRing(env) {
                        return [
                            [env.xmin, env.ymin],
                            [env.xmin, env.ymax],
                            [env.xmax, env.ymax],
                            [env.xmax, env.ymin],
                            [env.xmin, env.ymin]
                        ];
                    }
                    GeometryUtils.toRing = toRing;
                })(GeometryUtils = infrastructure.GeometryUtils || (infrastructure.GeometryUtils = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../GeometryUtils.ts"/>
/**
 * Static utility class for the buffer module.
 */
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var buffer;
                (function (buffer_1) {
                    var BufferUtils;
                    (function (BufferUtils) {
                        /**
                         * The buffer units that the Buffer Module supports along with their descriptions. This static object will
                         * be populated with the configured language resources when the buffer module initializes.
                         */
                        BufferUtils.SUPPORTED_BUFFER_UNITS = {
                            feet: null,
                            yard: null,
                            meter: null,
                            kilometer: null,
                            mile: null,
                            nauticalmile: null
                        };
                        /**
                         * Individual WKID's (which are not part of any geographicWkidRanges below) that represent a geographic coordinate system.
                         */
                        var geographicWkids = [
                            3819, 3821, 3824, 3889, 3906, 5013, 5233, 5246, 5252, 5264,
                            5324, 5340, 5354, 5360, 5365, 5371, 5373, 5381, 5393, 5451,
                            5464, 5467, 5489, 5524, 5527, 5546, 5561, 37257, 104000, 104020,
                            104023, 104199, 104223, 104896];
                        /**
                         * The range of WKID's that represent a geographic coordinate system.
                         */
                        var geographicWkidRanges = [
                            [4001, 4999],
                            [5228, 5229],
                            [2044, 2045], [2081, 2083], [2085, 2086], [2093, 2093],
                            [2096, 2098], [2105, 2132], [2169, 2170], [2176, 2180],
                            [2193, 2193], [2200, 2200], [2206, 2212], [2319, 2319],
                            [2320, 2462], [2523, 2549], [2551, 2735], [2738, 2758],
                            [2935, 2941], [2953, 2953], [3006, 3030], [3034, 3035],
                            [3058, 3059], [3068, 3068], [3114, 3118], [3126, 3138],
                            [3300, 3301], [3328, 3335], [3346, 3346], [3350, 3352],
                            [3366, 3366], [3416, 3416], [20004, 20032], [20064, 20092],
                            [21413, 21423], [21473, 21483], [21896, 21899], [22171, 22177],
                            [22181, 22187], [22191, 22197], [25884, 25884], [27205, 27232],
                            [27391, 27398], [27492, 27492], [28402, 28432], [28462, 28492],
                            [30161, 30179], [30800, 30800], [31251, 31259], [31275, 31279],
                            [31281, 31290], [31466, 31700],
                            [37001, 37008], [37201, 37208], [37211, 37235], [37237, 37243],
                            [37245, 37247], [37249, 37255], [37259, 37260],
                            [104100, 104145], [104256, 104259], [104260, 104261], [104286, 104287],
                            [104304, 104305], [104700, 104786], [104800, 104871], [104900, 104970],
                            [104990, 104992]];
                        /**
                         * The geometry service has no inherent support for yards. Defining our own constant here so we can support it.
                         */
                        BufferUtils.GCX_UNIT_YARDS = 12345;
                        /**
                         * Buffers a given geometry and returns a promise containing the Buffer Results.
                         * @param app The application that's requesting the buffer operation.
                         * @param bufferGeometryArgs The {@link infrastructure.buffer.BufferGeometryArgs} object containing the buffer configuration.
                         * @returns A Promise returning a {@link infrastructure.buffer.BufferOperationResult} object on success and a {@link infrastructure.buffer.BufferOperationError} object on failure.
                         */
                        function bufferGeometry(app, bufferGeometryArgs) {
                            var bufferGeometriesArgs = {
                                "bufferId": bufferGeometryArgs.bufferId,
                                "geometries": [bufferGeometryArgs.geometry],
                                "callback": bufferGeometryArgs.callback,
                                "geodesic": bufferGeometryArgs.geodesic,
                                "bufferSpatialReference": bufferGeometryArgs.bufferSpatialReference,
                                "outSpatialReference": bufferGeometryArgs.outSpatialReference,
                                "bufferDistance": bufferGeometryArgs.bufferDistance,
                                "bufferUnit": bufferGeometryArgs.bufferUnit,
                                "unionResults": bufferGeometryArgs.unionResults,
                                "sourceCommand": bufferGeometryArgs.sourceCommand
                            };
                            var executeOperation = function (resolve, reject) {
                                bufferGeometries(app, bufferGeometriesArgs).then(function (results) {
                                    results.geometry = results.geometries[0] || null;
                                    resolve(results);
                                }, function (errorObj) {
                                    reject(errorObj);
                                });
                            };
                            return new Promise(executeOperation);
                        }
                        BufferUtils.bufferGeometry = bufferGeometry;
                        /**
                         * Buffers an array of given geometries and returns a promise containing the Buffer Results. The input geometries need not be of the same type. However, multiple buffer requests may
                         * be issued if geometries are of different types.
                         * @param app The application that's requesting the buffer operation.
                         * @param bufferGeometriesArgs The {@link infrastructure.buffer.BufferGeometriesArgs} object containing the buffer configuration.
                         * @returns A Promise returning a {@link infrastructure.buffer.BufferOperationResult} object on success and a {@link infrastructure.buffer.BufferOperationError} object on failure.
                         */
                        function bufferGeometries(app, bufferGeometriesArgs) {
                            var bufferGeometriesOfSimilarType = function (geometries) {
                                var bufferParams = null;
                                require(["esri/tasks/BufferParameters"], function (BufferParameters) {
                                    bufferParams = new esri.tasks.BufferParameters();
                                    bufferParams.geometries = geometries;
                                    bufferParams.unit = getGeometryServiceUnitConstant(bufferGeometriesArgs.bufferUnit);
                                    bufferParams.bufferSpatialReference = bufferGeometriesArgs.bufferSpatialReference || bufferGeometriesArgs.outSpatialReference || bufferGeometriesArgs.geometries[0].spatialReference || app.map.spatialReference;
                                    bufferParams.outSpatialReference = bufferGeometriesArgs.outSpatialReference || app.map.spatialReference || bufferGeometriesArgs.geometries[0].spatialReference || bufferGeometriesArgs.bufferSpatialReference;
                                    bufferParams.distances = [bufferGeometriesArgs.bufferDistance];
                                    bufferParams.unionResults = bufferGeometriesArgs.unionResults != undefined ? !!bufferGeometriesArgs.unionResults : true;
                                    bufferParams.geodesic = !!bufferGeometriesArgs.geodesic;
                                    // Workaround for the fact that ESRI's geometry service does not have a YARDS constant.
                                    if (bufferParams.unit == BufferUtils.GCX_UNIT_YARDS) {
                                        bufferParams.unit = esri.tasks.GeometryService.UNIT_FOOT;
                                        bufferParams.distances = [convertLength(bufferGeometriesArgs.bufferDistance, BufferUtils.GCX_UNIT_YARDS, esri.tasks.GeometryService.UNIT_FOOT)];
                                    }
                                });
                                var performBuffer = function (resolve, reject) {
                                    buffer(app, bufferParams).then(resolve, reject);
                                };
                                return new Promise(performBuffer);
                            };
                            var executeOperation = function (resolve, reject) {
                                var geometriesSeparatedByType = _separateGeometriesByType(bufferGeometriesArgs.geometries);
                                var bufferOperationPromises = [];
                                geometriesSeparatedByType.forEach(function (geometries) {
                                    bufferOperationPromises.push(bufferGeometriesOfSimilarType(geometries));
                                });
                                Promise.all(bufferOperationPromises).then(function (results) {
                                    var baseResults = results[0];
                                    baseResults.bufferId = bufferGeometriesArgs.bufferId;
                                    baseResults.sourceCommand = bufferGeometriesArgs.sourceCommand;
                                    if (results.length === 1) {
                                        resolve(baseResults);
                                    }
                                    else {
                                        for (var x = 1; x < results.length; x++) {
                                            var geom = results[x].geometries;
                                            if (geom.length) {
                                                baseResults.geometries = baseResults.geometries.concat(geom);
                                            }
                                        }
                                        if (bufferGeometriesArgs.unionResults) {
                                            infrastructure.GeometryUtils.unionGeometries(baseResults.geometries).then(function (unionedGeometry) {
                                                if (infrastructure.GeometryUtils.isValidGeometry(unionedGeometry)) {
                                                    baseResults.geometries = [unionedGeometry];
                                                    baseResults.geometry = unionedGeometry;
                                                    resolve(baseResults);
                                                }
                                            }, function (error) {
                                                var errorObj = {};
                                                errorObj.error = error;
                                                errorObj.bufferId = bufferGeometriesArgs.bufferId;
                                                errorObj.sourceCommand = bufferGeometriesArgs.sourceCommand;
                                                reject(errorObj);
                                            });
                                        }
                                        else {
                                            resolve(baseResults);
                                        }
                                    }
                                }, function (errorObj) {
                                    errorObj.bufferId = bufferGeometriesArgs.bufferId;
                                    errorObj.sourceCommand = bufferGeometriesArgs.sourceCommand;
                                    reject(errorObj);
                                });
                            };
                            return new Promise(executeOperation);
                        }
                        BufferUtils.bufferGeometries = bufferGeometries;
                        /**
                        * Buffers an array of given geometries and returns a promise containing the Buffer Results. Note that all input geometries must be of the same type.
                        * @param app The application that's requesting the buffer operation.
                        * @param bufferParameters The {@link esri.tasks.BufferParameters} object containing the buffer configuration.
                        * @returns A Promise returning a {@link infrastructure.buffer.BufferOperationResult} object on success and a {@link infrastructure.buffer.BufferOperationError} object on failure.
                        */
                        function buffer(app, bufferParameters) {
                            var generateBufferOperationResultsObj = function (geometries, error) {
                                var result = {};
                                if (geometries) {
                                    result.geometries = geometries;
                                }
                                if (error) {
                                    result.error = error;
                                }
                                return result;
                            };
                            var executeOperation = function (resolve, reject) {
                                var geomServ = infrastructure.GeometryUtils.getGeometryService(app);
                                if (!geomServ) {
                                    var errMsg = "BufferUtils: Buffer operation failed. Could not retrieve geometry service.";
                                    app.trace.error(errMsg);
                                    reject(generateBufferOperationResultsObj(null, new Error(errMsg)));
                                    return;
                                }
                                var executeBufferOperation = function () {
                                    geomServ.buffer(bufferParameters, function (bufferedGeometries) { return resolve(generateBufferOperationResultsObj(bufferedGeometries, null)); }, function (error) { return reject(generateBufferOperationResultsObj(null, error)); });
                                };
                                esri.geometry.normalizeCentralMeridian(bufferParameters.geometries).then(function (normalizedGeometries) {
                                    if (normalizedGeometries[0].type === "polygon") {
                                        // If first geometry is a polygon then simplify polygon.  This will make the user drawn polygon topologically correct. 
                                        // We assume here that all input geometries are the same type.
                                        geomServ.simplify(bufferParameters.geometries, function (geometries) {
                                            bufferParameters.geometries = geometries;
                                            executeBufferOperation();
                                        }, function (error) {
                                            reject(generateBufferOperationResultsObj(null, error));
                                        });
                                    }
                                    else {
                                        bufferParameters.geometries = normalizedGeometries;
                                        executeBufferOperation();
                                    }
                                });
                            };
                            return new Promise(executeOperation);
                        }
                        BufferUtils.buffer = buffer;
                        /**
                         * Checks to see if a given WKID is geographic or not.
                         */
                        function isGeographicWkid(wkid) {
                            var wkidToTest = parseInt(wkid, 10);
                            if (isNaN(wkidToTest)) {
                                return false;
                            }
                            if (geographicWkids.indexOf(wkidToTest) > -1) {
                                return true;
                            }
                            for (var count = 0; count < geographicWkidRanges.length; count++) {
                                if (wkidToTest >= geographicWkidRanges[count][0] && wkidToTest <= geographicWkidRanges[count][1]) {
                                    return true;
                                }
                            }
                            return false;
                        }
                        BufferUtils.isGeographicWkid = isGeographicWkid;
                        /**
                        * Retrieves the unit description from the configuration string used by the Buffer Module.
                        * @param config A string containing the configuration value for which the unit description is required. Can be any SUPPORTED_BUFFER_UNITS property value.
                        * @return A {@link infrastructure.buffer.BufferUnitDesc} object with details about the configured language resources for the config string.
                        */
                        function getUnitDescFromConfig(config) {
                            for (var prop in infrastructure.buffer.BufferUtils.SUPPORTED_BUFFER_UNITS) {
                                if (!infrastructure.buffer.BufferUtils.SUPPORTED_BUFFER_UNITS.hasOwnProperty(prop)) {
                                    continue;
                                }
                                if (BufferUtils.SUPPORTED_BUFFER_UNITS[prop] && BufferUtils.SUPPORTED_BUFFER_UNITS[prop].config === config) {
                                    return infrastructure.buffer.BufferUtils.SUPPORTED_BUFFER_UNITS[prop];
                                }
                            }
                            return null;
                        }
                        BufferUtils.getUnitDescFromConfig = getUnitDescFromConfig;
                        /**
                        * Returns the type of ESRI Geometry Service unit constant. Works for standard abbreviations, display text and esri.Unit constants. Will also work to convert between
                        * string representations of esri's geometry service unit constants and the constants themselves.
                        * @param typeName
                        * @param defaultType
                        * @return esri.tasks.GeometryService unit constant
                        */
                        function getGeometryServiceUnitConstant(typeName, defaultUnit) {
                            if (!typeName) {
                                return null;
                            }
                            var unitType = null;
                            switch (typeName) {
                                case "feet":
                                case geocortex.essentials.DistanceUnitType.FEET:
                                case esri.tasks.GeometryService.UNIT_FOOT.toString():
                                case esri.Units.FEET:
                                    unitType = esri.tasks.GeometryService.UNIT_FOOT;
                                    break;
                                case "kilometer":
                                case geocortex.essentials.DistanceUnitType.KILOMETERS:
                                case esri.tasks.GeometryService.UNIT_KILOMETER.toString():
                                case esri.Units.KILOMETERS:
                                    unitType = esri.tasks.GeometryService.UNIT_KILOMETER;
                                    break;
                                case "meter":
                                case geocortex.essentials.DistanceUnitType.METERS:
                                case esri.tasks.GeometryService.UNIT_METER.toString():
                                case esri.Units.METERS:
                                    unitType = esri.tasks.GeometryService.UNIT_METER;
                                    break;
                                case "mile":
                                case geocortex.essentials.DistanceUnitType.MILES:
                                case esri.tasks.GeometryService.UNIT_STATUTE_MILE.toString():
                                case esri.Units.MILES:
                                    unitType = esri.tasks.GeometryService.UNIT_STATUTE_MILE;
                                    break;
                                case "nauticalmile":
                                case geocortex.essentials.DistanceUnitType.NAUTICAL_MILES:
                                case esri.tasks.GeometryService.UNIT_NAUTICAL_MILE.toString():
                                case esri.Units.NAUTICAL_MILES:
                                    unitType = esri.tasks.GeometryService.UNIT_NAUTICAL_MILE;
                                    break;
                                case "yard":
                                case geocortex.essentials.DistanceUnitType.YARDS:
                                case esri.Units.YARDS:
                                    // Yards does not have an equivalent in esri.tasks.GeometryService. Hence returning our own defined constant
                                    unitType = BufferUtils.GCX_UNIT_YARDS; // TODO: Add Yard Support. Geometry service does not natively support it.
                                    break;
                                default:
                                    unitType = defaultUnit || typeName;
                            }
                            return unitType;
                        }
                        BufferUtils.getGeometryServiceUnitConstant = getGeometryServiceUnitConstant;
                        /*
                        * Convert Length from one Geometry Service Unit to another
                        * Note: Esri's Geometry Service does not support UNIT_YARD as of v3.7. Using an internat constant GCX_UNIT_YARDS to signify yards
                        * @param length The length to convert
                        * @param fromUnit The unit to convert from
                        * @param toUnit The unit to convert to
                        * @return The converted length
                        */
                        function convertLength(length, fromUnit, toUnit) {
                            var baseLength = 0;
                            // First switch to the base unit - in our case feet
                            switch (fromUnit) {
                                case esri.tasks.GeometryService.UNIT_METER:
                                    baseLength = length * 3.280839895013;
                                    break;
                                case esri.tasks.GeometryService.UNIT_KILOMETER:
                                    baseLength = length * 3280.839895013123;
                                    break;
                                case esri.tasks.GeometryService.UNIT_STATUTE_MILE:
                                    baseLength = length * 5280;
                                    break;
                                case esri.tasks.GeometryService.UNIT_NAUTICAL_MILE:
                                    baseLength = length * 6076.12;
                                    break;
                                case BufferUtils.GCX_UNIT_YARDS:
                                    baseLength = length * 3;
                                    break;
                                default:
                                    baseLength = length;
                            }
                            // Now switch from the baselength to the required unit
                            switch (toUnit) {
                                case esri.tasks.GeometryService.UNIT_METER:
                                    return (baseLength / 3.280839895013);
                                case esri.tasks.GeometryService.UNIT_KILOMETER:
                                    return (baseLength / 3280.839895013123);
                                case esri.tasks.GeometryService.UNIT_STATUTE_MILE:
                                    return (baseLength / 5280);
                                case esri.tasks.GeometryService.UNIT_NAUTICAL_MILE:
                                    return (baseLength / 6076.12);
                                case BufferUtils.GCX_UNIT_YARDS:
                                    return (baseLength / 3);
                                default:
                                    return baseLength;
                            }
                        }
                        BufferUtils.convertLength = convertLength;
                        // This is an internal helper function and hence is not exported.
                        function _separateGeometriesByType(geometries) {
                            var geometriesBasedOnType = [];
                            var insertGeometryBasedOnType = function (geometry) {
                                var geometryInserted = false;
                                for (var x = 0; x < geometriesBasedOnType.length; x++) {
                                    if (geometriesBasedOnType[x].length && geometriesBasedOnType[x][0].type === geometry.type) {
                                        geometriesBasedOnType[x].push(geometry);
                                        geometryInserted = true;
                                        break;
                                    }
                                }
                                if (!geometryInserted) {
                                    var insertionIndex = geometriesBasedOnType.length;
                                    geometriesBasedOnType[insertionIndex] = [];
                                    geometriesBasedOnType[insertionIndex].push(geometry);
                                }
                            };
                            geometries.forEach(insertGeometryBasedOnType);
                            return geometriesBasedOnType;
                        }
                    })(BufferUtils = buffer_1.BufferUtils || (buffer_1.BufferUtils = {}));
                })(buffer = infrastructure.buffer || (infrastructure.buffer = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                /**
                 * Representation of a ClusterLayer.
                 */
                var ClusterLayer = (function (_super) {
                    __extends(ClusterLayer, _super);
                    function ClusterLayer(gcxLayer, app) {
                        var _this = this;
                        _super.call(this);
                        /** The Geocortex Layer that is used as the basis for the cluster layer. */
                        this.gcxLayer = null;
                        /** The Feature Layer that is used as the basis for the cluster layer. */
                        this.featureLayer = null;
                        /** Layer to represent the individual graphics within an expanded cluster. */
                        this.singleFeatureLayer = null;
                        /** The radius of each cluster. */
                        this.clusterRadius = new Observable(null);
                        /** The maximum number of features to include in a cluster. */
                        this.maxFeaturesInCluster = new Observable(null);
                        /** Retyping of the renderer to show that we're using a ClassBreaksRenderer */
                        this.renderer = null;
                        /** Observale information about the renderer currently in use. Used by the legend. */
                        this.rendererInformation = [];
                        /** The renderer for the Feature Layer that is passed in on object construction. */
                        this.featureLayerRenderer = null;
                        /** All of the graphics from the feature layer. */
                        this._featureLayerGraphics = [];
                        /** Collection of information for all clusters. */
                        this._clusters = [];
                        /** The clusters that are currently being hidden when a cluster is focused upon/exploded. */
                        this._hiddenClusters = [];
                        /** Color of the label on clusters. */
                        this._clusterLabelColor = null;
                        /** Background color of clusters. */
                        this._clusterBackgroundColor = null;
                        /** The name of the FeatureSet that the features inside of exploded clusters will be placed into. */
                        this._featureSetName = null;
                        /** Event handlers that are handled by esri/dojo. */
                        this._esriEventHandlers = [];
                        /** Event handlers that are handled by geocortex/Framework*/
                        this._gcxEventHandlers = [];
                        /** The font size */
                        this._fontSize = "10pt";
                        /** The font family */
                        this._fontFamily = "Segoe UI, sans-serif";
                        /** Event handler for map clicks after a cluster has been exploded. */
                        this._mapClickHandler = null;
                        if (!(gcxLayer.mapService.serviceLayer instanceof esri.layers.FeatureLayer)) {
                            throw new Error("ClusterLayers require an Esri FeatureLayer to be passed in as a parameter.");
                        }
                        this.app = app;
                        this.id = gcxLayer.mapService.id + "-cluster";
                        this._featureSetName = this.id + "FeatureSet";
                        this.gcxLayer = gcxLayer;
                        this.featureLayer = gcxLayer.mapService.serviceLayer;
                        this.singleFeatureLayer = new esri.layers.GraphicsLayer();
                        this.url = this.featureLayer.url;
                        this.setVisibility(this.featureLayer.visible && this.featureLayer.visibleAtMapScale);
                        this.setOpacity(this.featureLayer.opacity);
                        // Save the renderer for the feature layer and then set it to null so that we can still make use of the featureLayer's graphics
                        // but don't have them getting in the way.
                        this.featureLayerRenderer = this.featureLayer.renderer;
                        this.featureLayer.setRenderer(null);
                        this.featureLayer.redraw();
                        // Prepare the layer that will be used to represent exploded clusters.
                        this.singleFeatureLayer.id = gcxLayer.mapService.id + "-explodedClusterLayer";
                        this.singleFeatureLayer.setRenderer(this.featureLayerRenderer);
                        this.singleFeatureLayer.setOpacity(this.featureLayer.opacity);
                        this.singleFeatureLayer.url = this.url;
                        // Load the options specified in Essentials.
                        this.clusterRadius.set(gcxLayer.mapService.featureClustering.radius || 50);
                        this.maxFeaturesInCluster.set(gcxLayer.mapService.featureClustering.maximumFeatures || 0);
                        this._clusterLabelColor = new esri.Color(gcxLayer.mapService.featureClustering.labelColor);
                        this._clusterBackgroundColor = new esri.Color(gcxLayer.mapService.featureClustering.backgroundColor);
                        // There are 4 renderer breaks - there would be a variable w/ the number of breaks, but it's not a configurable
                        // property - so a developer could change that and expect the breaks to dynamically change. So, magic number
                        // feels OK here.
                        for (var i = 0; i < 4; i++) {
                            this.rendererInformation.push({
                                isVisible: new Observable(false),
                                rangeString: new Observable("")
                            });
                        }
                        // Make it so that whenever the maximum features in the cluster change that we reload the renderer so that the legend 
                        // updates properly.
                        this.maxFeaturesInCluster.bind(this, function (newValue) {
                            _this.gcxLayer.mapService.featureClustering.maximumFeatures = newValue;
                            _this._loadRenderer();
                        });
                        this.clusterRadius.bind(this, function (newValue) {
                            _this.gcxLayer.mapService.featureClustering.radius = newValue;
                        });
                        // Load the renderer in case the ClusterLayer is enabled with a maximum cluster size already specified.
                        // If this doesn't happen then the legend will crash when the layer is enabled.
                        if (this.maxFeaturesInCluster.get() > 0) {
                            this._loadRenderer();
                        }
                        // Since most of the event listeners revolve around the map, we need to ensure that it is loaded before
                        // setting them up.
                        if (this.app.map && this.app.map.loaded) {
                            this._setupEventListeners(this.app.map);
                        }
                        else {
                            this.app.event("MapLoadedEvent").once(this, function (map) {
                                _this._setupEventListeners(map);
                            });
                        }
                        // Do an initial cluster to get the ball rolling.
                        this.recluster();
                    }
                    /**
                     * Called whenever clusters need to be recalculated.
                     */
                    ClusterLayer.prototype.recluster = function () {
                        // Don't want any reclustering to happen when we are viewing an exploded cluster.
                        if (this.singleFeatureLayer.graphics.length > 0) {
                            return;
                        }
                        // Copy over what's in the featureLayer.
                        this._featureLayerGraphics = this.featureLayer.graphics.slice(0, this.featureLayer.graphics.length);
                        // Generate the clusters and then redraw the layer.
                        this._generateClusters();
                        this.redraw();
                    };
                    /**
                     * Clears all of the event handlers, layers, and other persistent things that are associated with this cluster.
                     */
                    ClusterLayer.prototype.destroy = function () {
                        if (this.app.map.getLayer(this.singleFeatureLayer.id) === this.singleFeatureLayer) {
                            this.app.map.removeLayer(this.singleFeatureLayer);
                        }
                        if (this.app.featureSetManager.getCollectionById(this._featureSetName)) {
                            this.app.featureSetManager.closeCollection(this._featureSetName);
                            this.app.featureSetManager.removeCollectionById(this._featureSetName);
                        }
                        // Restore the feature layer to its former glory.
                        this.app.map.removeLayer(this);
                        this.featureLayer.setRenderer(this.featureLayerRenderer);
                        this.featureLayer.redraw();
                        // Kill the event handlers.
                        for (var i = 0; i < this._esriEventHandlers.length; i++) {
                            this._esriEventHandlers[i].remove();
                        }
                        for (var i = 0; i < this._gcxEventHandlers.length; i++) {
                            this.app.event(this._gcxEventHandlers[i].eventName).unsubscribe(this._gcxEventHandlers[i].token);
                        }
                    };
                    /**
                     * Used to detect when a cluster is clicked by the user.
                     * If a valid click is detected, then all other clusters are hidden and the selected cluster has its graphics displayed.
                     * @param event The ArcGIS MouseEvent that triggered the cluster's click action.
                     */
                    ClusterLayer.prototype.onFeatureClicked = function (event) {
                        var _this = this;
                        if (!(event.graphic instanceof esri.Graphic)) {
                            return;
                        }
                        // Can't explode clusters when a tool is active.
                        if (this.app.toolRegistry.getActiveTool()) {
                            return;
                        }
                        var eventGraphic = event.graphic;
                        this.singleFeatureLayer.clear();
                        this._hiddenClusters = [];
                        // Get the features from the cluster and send them to a map tip.
                        var gcxFeatures = [];
                        var esriFeatures = [];
                        // Add the individual graphics that are contained within the cluster to the map.
                        for (var i = 0; i < this._featureLayerGraphics.length; i++) {
                            if (this._featureLayerGraphics[i].attributes.clusterId === eventGraphic.attributes.clusterId) {
                                var featureOpts = {
                                    graphic: this._featureLayerGraphics[i],
                                    layer: this.gcxLayer,
                                    resolveLayerFields: true
                                };
                                featureOpts.symbol = this._getRenderedSymbol(this._featureLayerGraphics[i]);
                                gcxFeatures.push(new infrastructure.Feature(featureOpts));
                                esriFeatures.push(this._featureLayerGraphics[i]);
                                this.singleFeatureLayer.add(this._featureLayerGraphics[i]);
                            }
                        }
                        // Hide all of the clusters.
                        this._hiddenClusters = this.graphics.slice(0, this.graphics.length);
                        this.clear();
                        this.redraw();
                        // Add and redraw the layer for the exploded features.
                        if (!this.app.map.getLayer(this.singleFeatureLayer.id)) {
                            this.app.map.addLayer(this.singleFeatureLayer);
                        }
                        this.singleFeatureLayer.redraw();
                        var featureSet = new infrastructure.FeatureSet();
                        featureSet.features.set(gcxFeatures);
                        // GVH-7095: Resolve any datalinks the feature set might have, and notify when a feature has any datalinks resolved.
                        featureSet.layer = this.gcxLayer;
                        featureSet.esriFeatureSet = new esri.tasks.FeatureSet();
                        featureSet.esriFeatureSet.features = esriFeatures;
                        featureSet.resolveDataLinks(function (feature) {
                            _this.app.event("FeatureChangedEvent").publish(feature);
                        });
                        var featureSetCollection = new infrastructure.FeatureSetCollection();
                        featureSetCollection.featureSets.addItem(featureSet);
                        featureSetCollection.id = this._featureSetName;
                        featureSetCollection.sourceName = "ClusterFeatures";
                        if (this.app.featureSetManager.getCollectionById(this._featureSetName)) {
                            this.app.featureSetManager.removeCollectionById(this._featureSetName);
                        }
                        this.app.featureSetManager.addCollection(featureSetCollection);
                        this.app.featureSetManager.openCollection(this._featureSetName);
                        this.app.featureSetManager.closeCollection(this._featureSetName);
                        // Disable map clicks so that when the user clicks to collapse the cluster they don't have a new maptip open.
                        this.app.command("DisableMapClick").execute();
                        this._mapClickHandler = this.app.map.on("click", function (event) {
                            // Do not allow the click handler to dismiss itself if the editor is active.
                            if (_this.app.stateManager.getActiveStates().filter(function (activeState) { return activeState.stateDefinition.name === "EditorActiveState"; }).length > 0) {
                                _this.singleFeatureLayer.redraw();
                                return;
                            }
                            _this._mapClickHandler.remove();
                            _this._mapClickHandler = null;
                            _this.app.command("EnableMapClick").execute();
                            _this.singleFeatureLayer.clear();
                            _this.recluster();
                            return false;
                        });
                    };
                    /**
                     * Assigns values and event listeners concerned with the map.
                     * @param map The esri map that is associated with this layer.
                     */
                    ClusterLayer.prototype._setupEventListeners = function (map) {
                        var _this = this;
                        this._gcxEventHandlers.push({
                            eventName: "MapClickedEvent",
                            token: this.app.event("MapClickedEvent").subscribe(this, function (event) { return _this._mapClickedEvent(event); })
                        });
                        this._gcxEventHandlers.push({
                            eventName: "MapExtentChangedEvent",
                            token: this.app.event("MapExtentChangedEvent").subscribe(this, function (extent, args) { return _this._mapExtentChangedEvent(extent, args); })
                        });
                        this._gcxEventHandlers.push({
                            eventName: "MapTipClosedEvent",
                            token: this.app.event("MapTipClosedEvent").subscribe(this, function () { return _this._mapTipClosedEvent(); })
                        });
                        this._gcxEventHandlers.push({
                            eventName: "ClusterLayerRemovedEvent",
                            token: this.app.event("ClusterLayerRemovedEvent").subscribe(this, function (clusterLayer) { return _this._clusterLayerRemovedEvent(clusterLayer); })
                        });
                        this._gcxEventHandlers.push({
                            eventName: "LayerVisibilityChangedEvent",
                            token: this.app.event("LayerVisibilityChangedEvent").subscribe(this, function (results) { return _this._layerVisibilityChangedEvent(results); })
                        });
                        this._gcxEventHandlers.push({
                            eventName: "GeometryEditInvokedEvent",
                            token: this.app.event("GeometryEditInvokedEvent").subscribe(this, function (graphic) { return _this.recluster(); })
                        });
                        this._gcxEventHandlers.push({
                            eventName: "GeometryEditCompletedEvent",
                            token: this.app.event("GeometryEditCompletedEvent").subscribe(this, function (graphic) { return _this._handleGeometryChange(); })
                        });
                        this._gcxEventHandlers.push({
                            eventName: "EditorClosedEvent",
                            token: this.app.event("EditorClosedEvent").subscribe(this, function () { return _this._handleEditorClosedEvent(); })
                        });
                        // Recluster whenever the parent feature layer completes an update.
                        this._esriEventHandlers.push(this.featureLayer.on("update-end", function (featureSet) { _this.recluster(); }));
                    };
                    /**
                     * Runs after a geometry edit/feature editor is closed to ensure what is represented is proper.
                     */
                    ClusterLayer.prototype._handleGeometryChange = function () {
                        this.recluster();
                        if (this.singleFeatureLayer.graphics.length > 0) {
                            this.singleFeatureLayer.redraw();
                        }
                    };
                    /**
                     * Runs after the Feature Editor is closed.
                     */
                    ClusterLayer.prototype._handleEditorClosedEvent = function () {
                        this.recluster();
                        if (this.singleFeatureLayer.graphics.length > 0) {
                            this.singleFeatureLayer.redraw();
                        }
                    };
                    /**
                     * Run whenever the map is clicked and the cluster layer is active.
                     * @param event The MouseEvent/TouchEvent that triggered this.
                     */
                    ClusterLayer.prototype._mapClickedEvent = function (event) {
                        if (!this.visible) {
                            return;
                        }
                        // For some reason trying to instanceof 'esri.AGSMouseEvent' fails, so we can't check. We check for the graphic though,
                        // so this is OK. (I swear.)
                        var currGraphic = event && event.graphic ? event.graphic : null;
                        // Map tips/cluster exploding should not be invoked when a tool is active.
                        if (this.app.toolRegistry.getActiveTool() !== null) {
                            return;
                        }
                        // Handle when a cluster or a feature within an exploded cluster is clicked.
                        if (currGraphic && currGraphic.getLayer() === this && currGraphic.attributes && currGraphic.geometry instanceof esri.geometry.Point) {
                            // Handle when an actual cluster has been clicked.
                            if (currGraphic.attributes.clusterId && currGraphic.attributes.clusterCount) {
                                this.onFeatureClicked(event);
                                return;
                            }
                            // A feature within an exploded cluster has been clicked.
                            this.app.command("ShowMapTip").execute(new infrastructure.Feature({ "graphic": currGraphic, "layer": this.gcxLayer }));
                            return;
                        }
                        if (this.singleFeatureLayer.graphics.length > 0) {
                            this.singleFeatureLayer.clear();
                            this.app.command("RemovePushpins").execute();
                        }
                        this.recluster();
                    };
                    /**
                     * Run whenever the map's extent is changed and clustering is active.
                     * @param extent The new extent of the map.
                     * @param args Arguments involving the map's new extent.
                     */
                    ClusterLayer.prototype._mapExtentChangedEvent = function (extent, args) {
                        // If we get outside of the visibility range for the FeatureLayer, we need to hide clusters.
                        if (!this.featureLayer.visibleAtMapScale || !this.featureLayer.visible) {
                            this.setVisibility(false);
                        }
                        else {
                            this.setVisibility(true);
                        }
                        if (this.singleFeatureLayer.graphics.length === 0 && this.visible && this.featureLayer.visibleAtMapScale) {
                            this.recluster();
                        }
                        // Reload the renderer so the cluster counts are accurately reflected.
                        this._loadRenderer();
                    };
                    /**
                     * Clears the data from the cluster that has been exploded when a maptip is closed.
                     */
                    ClusterLayer.prototype._mapTipClosedEvent = function () {
                        // Clear the event handler for the map click - we're doing what it would do in here.
                        if (this._mapClickHandler) {
                            this._mapClickHandler.remove();
                            this._mapClickHandler = null;
                        }
                        // Remove the "clusterFeatures" from the FeatureSetCollection and hide any of the shown single symbology.
                        this.app.command("EnableMapClick").execute();
                        this.singleFeatureLayer.clear();
                        this.recluster();
                    };
                    /**
                     * Cleans up the cluster layer that has been removed.
                     * @param clusterLayer The ClusterLayer that is being disabled/removed.
                     */
                    ClusterLayer.prototype._clusterLayerRemovedEvent = function (clusterLayer) {
                        if (clusterLayer === this) {
                            this.destroy();
                        }
                    };
                    /**
                     * Raised whenever a layer's visibility changes. Used to make it so clusters are invisible when a layer is disabled at
                     * the layer list level.
                     * @param result An object with an Essentials Layer, MapService, and visibility boolean.
                     */
                    ClusterLayer.prototype._layerVisibilityChangedEvent = function (result) {
                        var _this = this;
                        result.forEach(function (currentResult) {
                            if (currentResult.layer !== _this.gcxLayer) {
                                return;
                            }
                            _this.setVisibility(currentResult.visibility && _this.featureLayer.visibleAtMapScale);
                            // Reload the renderer so the clusters are not shown in the legend.
                            _this._loadRenderer();
                        });
                    };
                    /**
                     * Sets up the renderer and the various breaks that are used to represent clusters at different sizes.
                     * This can be called dynamically as the size of the clusters change depending on the number of features in the largest cluster.
                     */
                    ClusterLayer.prototype._loadRenderer = function () {
                        var renderer = new esri.renderer.ClassBreaksRenderer(null, "clusterCount");
                        var largestClusterSize = null;
                        if (this.maxFeaturesInCluster.get() > 0) {
                            // We have a hard limit to the # of features in a cluster. Just use that for the maximum cluster size.
                            largestClusterSize = this.maxFeaturesInCluster.get();
                        }
                        else {
                            // Otherwise, the largest cluster is our maximum.
                            var largestCluster = 0;
                            for (var i = 0; i < this._clusters.length; i++) {
                                if (this._clusters[i].attributes.clusterCount > largestCluster) {
                                    largestCluster = this._clusters[i].attributes.clusterCount;
                                }
                            }
                            largestClusterSize = largestCluster;
                        }
                        // We need to break down the amount that is rendered within each size category.
                        // This is dependent on the maximum number of features to include inside of a cluster.
                        // Small = 1-30%, medium = 31-60%, large = 61-90%, x-Large: 91%-100%+
                        var smallEnd = Math.ceil(largestClusterSize * 0.309999999999);
                        if (smallEnd === 1) {
                            smallEnd++;
                        }
                        var mediumStart = Math.ceil(largestClusterSize * 0.31);
                        if (mediumStart <= smallEnd) {
                            mediumStart = smallEnd + 1;
                        }
                        var mediumEnd = Math.ceil(largestClusterSize * 0.609999999999);
                        if (mediumEnd < mediumStart) {
                            mediumEnd = mediumStart;
                        }
                        var largeStart = Math.ceil(largestClusterSize * 0.61);
                        if (largeStart <= mediumEnd) {
                            largeStart = mediumEnd + 1;
                        }
                        var largeEnd = Math.ceil(largestClusterSize * 0.909999999999);
                        if (largeEnd < largeStart) {
                            largeEnd = largeStart;
                        }
                        var xLargeStart = Math.ceil(largestClusterSize * 0.91);
                        if (xLargeStart <= largeEnd) {
                            xLargeStart = largeEnd + 1;
                        }
                        // Add all of the breaks to the renderer.
                        // _addBreak has logic to see if the break actually needs to be added to the renderer - in cases where having 4
                        // different sizes makes no sense (say there are only clusters of 2 visible) the break is not added.
                        this._addBreak(renderer, 21, 2, smallEnd, largestClusterSize, 0);
                        this._addBreak(renderer, 28, mediumStart, mediumEnd, largestClusterSize, 1);
                        this._addBreak(renderer, 35, largeStart, largeEnd, largestClusterSize, 2);
                        this._addBreak(renderer, 42, xLargeStart, Infinity, largestClusterSize, 3);
                        this.setRenderer(renderer);
                    };
                    /**
                     * Checks to see if a valid break can be generated from the passed in information. If so, then generates a break on the passed renderer.
                     * @param renderer The ClassBreaksRenderer that will have a new break added to it.
                     * @param symbolSize The size in pixels of the circle to be generated.
                     * @param rangeStart The start of the range.
                     * @param rangeEnd The end of the range.
                     * @param largestClusterSize The number of features in the largest cluster on screen.
                     * @param rendererInformationPosition RendererInformation tracks visibility/values on a 0-3 scale to communicate to the legend.
                     */
                    ClusterLayer.prototype._addBreak = function (renderer, symbolSize, rangeStart, rangeEnd, largestClusterSize, rendererInformationPosition) {
                        // Update the observables so the legend has something to work with.
                        if (largestClusterSize >= rangeStart && this.visible && this.featureLayer.visibleAtMapScale) {
                            if (rangeStart !== rangeEnd) {
                                if (rangeEnd !== Infinity) {
                                    this.rendererInformation[rendererInformationPosition].rangeString.set(rangeStart + " - " + rangeEnd);
                                }
                                else {
                                    // The rangeEnd is infinity, so this is the largest cluster.
                                    this.rendererInformation[rendererInformationPosition].rangeString.set(rangeStart + "+");
                                }
                            }
                            else {
                                this.rendererInformation[rendererInformationPosition].rangeString.set(rangeStart.toString());
                            }
                            this.rendererInformation[rendererInformationPosition].isVisible.set(true);
                        }
                        else {
                            this.rendererInformation[rendererInformationPosition].isVisible.set(false);
                        }
                        // Create the actual symbol and add it.
                        var symbol = null;
                        if (dojo.isIE === 8) {
                            // For some reason IE8 requires symbols to be initialized through a JSON object.
                            // I don't get it either.
                            symbol = new esri.symbol.SimpleMarkerSymbol({
                                "color": this._clusterBackgroundColor.toRgba(),
                                "size": symbolSize,
                                type: "esriSMS",
                                style: "esriSMSCircle",
                                outline: {
                                    color: this._makeTransparent(this._clusterBackgroundColor.toRgba()),
                                    width: 8,
                                    type: "esriSLS",
                                    style: "esriSLSSolid"
                                }
                            });
                        }
                        else {
                            symbol = new esri.symbol.SimpleMarkerSymbol(esri.symbol.SimpleMarkerSymbol.STYLE_CIRCLE, symbolSize, new esri.symbol.SimpleLineSymbol(esri.symbol.SimpleLineSymbol.STYLE_SOLID, new esri.Color(this._makeTransparent(this._clusterBackgroundColor.toRgba())), 8), this._clusterBackgroundColor);
                        }
                        renderer.addBreak(rangeStart, rangeEnd, symbol);
                    };
                    /**
                     * Used to make the passed color arrray slightly transparent.
                     * @param color An array of RGBA color values.
                     */
                    ClusterLayer.prototype._makeTransparent = function (color) {
                        if (color.length === 4) {
                            color[3] = 0.25;
                        }
                        return color;
                    };
                    /**
                     * Checks to see if the passed point is within the tolerance (pixels) of the current cluster.
                     * @param point The point to compare to the cluster.
                     * @param cluster The cluster to compare to the point.
                     */
                    ClusterLayer.prototype._isValidCluster = function (point, cluster, resolution) {
                        var distance = (Math.sqrt(Math.pow((cluster.x - point.x), 2) + Math.pow((cluster.y - point.y), 2)) / resolution);
                        return (distance <= this.clusterRadius.get() && this._isClusterFull(cluster));
                    };
                    /**
                     * Checks to see if the current cluster has exceeded the configured maximum cluster size.
                     * Returns false if no maximum cluster size is configured.
                     * @param cluster The cluster to evaluate.
                     */
                    ClusterLayer.prototype._isClusterFull = function (cluster) {
                        // If the cluster's maximum values are 0 or "" then we don't enforce cluster sizes.
                        return (cluster.attributes.clusterCount < this.maxFeaturesInCluster.get() || this.maxFeaturesInCluster.get() == 0 || this.maxFeaturesInCluster.get().toString() == "");
                    };
                    /**
                     * Generates the clusters by going through the graphics stored in _featureLayerGraphics.
                     */
                    ClusterLayer.prototype._generateClusters = function () {
                        // Remove all existing graphics from layer
                        this.clear();
                        // Clear all of the existing clusters.
                        this._clusters = [];
                        // Run through all graphics and make clusters from them so we have a rough idea of where the cluster centers should lay.
                        // As this is the first run through, we don't want to preserve the clusters' location.
                        // TODO: Possibly replace the double-pass calculation w/ quadtree solution?
                        this._addGraphicsToClusters(false);
                        // Create a copy of the clusters, now that we know where they should be located and run through the features again.
                        // This will give us a more accurate rendering of where features should be, as features added early in the calculation
                        // could be far off from where they should be due to the cluster's centre shifting as new features are added to it.
                        var newClusters = [];
                        for (var i = 0; i < this._clusters.length; i++) {
                            newClusters[i] = {
                                x: this._clusters[i].x,
                                y: this._clusters[i].y,
                                attributes: {
                                    clusterCount: 0,
                                    clusterId: this._clusters[i].attributes.clusterId,
                                    extent: this._clusters[i].attributes.extent
                                }
                            };
                        }
                        // Now that we have a set of reference clusters, perform the clustering operation again so that we can get better accuracy.
                        // Since this is the second run and we have a general idea of where the clusters should lay, preserve their current locations.
                        this._clusters = newClusters;
                        this._addGraphicsToClusters(true);
                        this._showAllClusters();
                    };
                    /**
                     * Matches up graphics with clusters and associates them.
                     * @param preserveClusterLocation Whether the addition of a point to a cluster should adjust where the cluster is located.
                     */
                    ClusterLayer.prototype._addGraphicsToClusters = function (preserveClusterLocation) {
                        var length = this._featureLayerGraphics.length;
                        var resolution = this.app.map.extent.getWidth() / this.app.map.width;
                        for (var j = 0; j < length; j++) {
                            var currentPoint = null;
                            // Don't add graphics that aren't visible as the editor may disable them on the featureLayer level and we want to have this
                            // represented in clusters as well.
                            if (this._featureLayerGraphics[j].geometry instanceof esri.geometry.Point && this._featureLayerGraphics[j].visible) {
                                currentPoint = this._featureLayerGraphics[j].geometry;
                            }
                            else {
                                continue;
                            }
                            // We only want to cluster that which is in the current extent, otherwise snapshot layers could take a long time on any
                            // clustering operation if there are a lot of features visible outside of the extent.
                            if (!this.app.map.extent.contains(currentPoint)) {
                                // Reset all other clusters and make sure their id is changed
                                this._featureLayerGraphics[j].attributes.clusterId = -1;
                                continue;
                            }
                            var graphic = this._featureLayerGraphics[j];
                            var clustersWithinRange = [];
                            // See which clusters are within range of the point.
                            for (var i = 0; i < this._clusters.length; i++) {
                                var currentCluster = this._clusters[i];
                                if (this._isValidCluster(currentPoint, currentCluster, resolution)) {
                                    clustersWithinRange.push(currentCluster);
                                }
                            }
                            if (clustersWithinRange.length === 1) {
                                // Only one cluster within range of the point, that makes it easy - add the point to the cluster.
                                this._clusterAddPoint(graphic, currentPoint, clustersWithinRange[0], preserveClusterLocation);
                            }
                            else if (clustersWithinRange.length > 1) {
                                // Find the closest cluster.
                                var distances = [];
                                for (var i = 0; i < clustersWithinRange.length; i++) {
                                    distances[i] = Math.sqrt(Math.pow(clustersWithinRange[i].x - currentPoint.x, 2) + Math.pow(clustersWithinRange[i].y - currentPoint.y, 2));
                                }
                                var closestCluster = null;
                                var closestDistance = null;
                                // Distances and clustersWithinRange share the same array values. Cluster 1 = distance 1, cluster 2 = distance 2, etc.
                                for (var i = 0; i < distances.length; i++) {
                                    if (closestDistance === null || closestDistance > distances[i]) {
                                        closestDistance = distances[i];
                                        closestCluster = clustersWithinRange[i];
                                    }
                                }
                                this._clusterAddPoint(graphic, currentPoint, closestCluster, preserveClusterLocation);
                            }
                            else {
                                // There were no clusters found within range. Make a new one.
                                this._createCluster(graphic, currentPoint);
                            }
                        }
                    };
                    /**
                     * Adds all generated clusters to the layer.
                     * Before doing so, it checks to see what the breaks should be for graphically representing cluster size.
                     */
                    ClusterLayer.prototype._showAllClusters = function () {
                        // Reload the renderer if a maximum cluster size is not set.
                        if (this.maxFeaturesInCluster.get() == 0 || this.maxFeaturesInCluster.get().toString() == "") {
                            this._loadRenderer();
                        }
                        for (var i = 0, il = this._clusters.length; i < il; i++) {
                            this._showCluster(this._clusters[i]);
                        }
                    };
                    /**
                     * Adds an individual cluster to the layer.
                     * @param cluster The cluster to add to the layer.
                     */
                    ClusterLayer.prototype._showCluster = function (cluster) {
                        var point = new esri.geometry.Point(cluster.x, cluster.y, this.app.map.spatialReference);
                        var newGraphic = new esri.Graphic(point, null, cluster.attributes);
                        newGraphic.setSymbol(this._getRenderedSymbol(newGraphic));
                        this.add(newGraphic);
                        // code below is used to not label clusters with a single point
                        if (cluster.attributes.clusterCount < 2) {
                            return;
                        }
                        // show number of points in the cluster
                        var labelXOffset = 0;
                        var labelYOffset = -5;
                        var textSymbol = null;
                        if (dojo.isIE === 8) {
                            // IE 8 requires the TextSymbol to be constructed via JSON for some reason.
                            // Same as the SimpleMarkerSymbol.
                            // I hate so you much IE 8.
                            textSymbol = new esri.symbol.TextSymbol({
                                type: "esriTS",
                                color: this._clusterLabelColor.toRgba(),
                                xoffset: labelXOffset,
                                yoffset: labelYOffset,
                                font: {
                                    family: this._fontFamily,
                                    size: this._fontSize,
                                    weight: "bold"
                                }
                            });
                            textSymbol.setText(cluster.attributes.clusterCount.toString());
                        }
                        else {
                            // For browsers that aren't completely awful... (Ex. not IE8)
                            textSymbol = new esri.symbol.TextSymbol(cluster.attributes.clusterCount);
                            textSymbol.setColor(this._clusterLabelColor);
                            textSymbol.setOffset(labelXOffset, labelYOffset);
                            textSymbol.setFont(new esri.symbol.Font(this._fontSize)
                                .setFamily(this._fontFamily)
                                .setWeight(esri.symbol.Font.WEIGHT_BOLD));
                        }
                        var labelGraphic = new esri.Graphic(point, textSymbol, cluster.attributes);
                        this.add(labelGraphic);
                    };
                    /**
                     * Retrieves the symbology associated with the passed esri graphic.
                     * @param graphic The Esri graphic to retrieve the feature symbology for.
                     */
                    ClusterLayer.prototype._getRenderedSymbol = function (graphic) {
                        var attr = graphic.attributes;
                        if (attr.clusterCount !== 1) {
                            return null;
                        }
                        var renderer = this.featureLayerRenderer;
                        if (!renderer) {
                            // For some reason the feature layer renderer isn't there. 
                            return null;
                        }
                        if (renderer instanceof esri.renderer.SimpleRenderer) {
                            return renderer.getSymbol(graphic);
                        }
                        else {
                            // We need to find the actual feature to pass in for a UniqueValueRenderer and other renderer types.
                            for (var i = 0; i < this._featureLayerGraphics.length; i++) {
                                var currentFeature = this._featureLayerGraphics[i];
                                if (currentFeature.attributes.clusterId === graphic.attributes.clusterId) {
                                    return renderer.getSymbol(currentFeature);
                                }
                            }
                        }
                    };
                    /**
                     * Adds a point to an existing cluster.
                     * @param graphic The graphic to be associated with the cluster.
                     * @param p The point/graphic that will readjust the cluster location.
                     * @param cluster The cluster to be associated with.
                     * @param preserveClusterLocation Whether the cluster's location should be adjusted when the point is added.
                     */
                    ClusterLayer.prototype._clusterAddPoint = function (graphic, p, cluster, preserveClusterLocation) {
                        // Average in the new point to the cluster geometry
                        var count, x, y;
                        if (!preserveClusterLocation) {
                            count = cluster.attributes.clusterCount;
                            x = (p.x + (cluster.x * count)) / (count + 1);
                            y = (p.y + (cluster.y * count)) / (count + 1);
                            cluster.x = x;
                            cluster.y = y;
                        }
                        // Build an extent that includes all points in a cluster
                        if (p.x < cluster.attributes.extent[0]) {
                            cluster.attributes.extent[0] = p.x;
                        }
                        else if (p.x > cluster.attributes.extent[2]) {
                            cluster.attributes.extent[2] = p.x;
                        }
                        if (p.y < cluster.attributes.extent[1]) {
                            cluster.attributes.extent[1] = p.y;
                        }
                        else if (p.y > cluster.attributes.extent[3]) {
                            cluster.attributes.extent[3] = p.y;
                        }
                        // Increment the count
                        cluster.attributes.clusterCount++;
                        // attributes might not exist
                        if (!p.hasOwnProperty("attributes")) {
                            p.attributes = {};
                        }
                        // give the graphic a cluster id
                        graphic.attributes.clusterId = p.attributes.clusterId = cluster.attributes.clusterId;
                    };
                    /**
                     * Called when there is no cluster within range of the point. Creates a new cluster in that location.
                     * @param graphic The graphic to use as a reference for the beginning of the cluster.
                     * @param graphic p The point specifying where the cluster is to be created.
                     */
                    ClusterLayer.prototype._createCluster = function (graphic, point) {
                        var clusterId = this._clusters.length + 1;
                        graphic.attributes.clusterId = clusterId;
                        // create the cluster
                        var cluster = {
                            "x": point.x,
                            "y": point.y,
                            "attributes": {
                                "clusterCount": 1,
                                "clusterId": clusterId,
                                "extent": [point.x, point.y, point.x, point.y]
                            }
                        };
                        this._clusters.push(cluster);
                    };
                    return ClusterLayer;
                }(esri.layers.GraphicsLayer));
                infrastructure.ClusterLayer = ClusterLayer;
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/Documents.Rest.d.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var documents;
                (function (documents) {
                    var GrantKind = geocortex.essentials.documents.GrantKind;
                    /**
                     * Model for a Moniker which has grants on a document.
                     */
                    var MonikerModel = (function () {
                        function MonikerModel(config) {
                            /**
                             * The grants that this moniker has on the document.
                             */
                            this.grants = [];
                            /**
                             * Whether or not this moniker represents a global grant.
                             */
                            this.isGlobal = false;
                            /**
                             * Whether or not this moniker represents a public grant.
                             */
                            this.isPublic = false;
                            /**
                             * Whether or not this moniker has its grants revoked.
                             */
                            this.isRevoked = new Observable(false);
                            /**
                             * Whether or not this moniker has a reader grant.
                             */
                            this.canRead = false;
                            /**
                             * Whether or not this moniker has a writer grant.
                             */
                            this.canWrite = false;
                            /**
                             * Whether this widget is enabled.  All contained controls will take this value.
                             */
                            this.enabled = new Observable(true);
                            if (!config.id && !config.grant) {
                                throw new Error("MonikerModel: parameter \"id\" or \"grant\" is required.");
                            }
                            if (config.id) {
                                this.id = config.id;
                            }
                            if (config.name) {
                                this.name = config.name;
                            }
                            if (config.iconUri) {
                                this.iconUri = config.iconUri;
                            }
                            if (!!config.isGlobal) {
                                this.isGlobal = config.isGlobal;
                            }
                            if (!!config.isPublic) {
                                this.isPublic = config.isPublic;
                            }
                            if (config.grant) {
                                // If given a grant, then update the ID and name
                                this.id = config.grant.globalId;
                                if (config.grant.subject) {
                                    this.name = config.grant.subject.title;
                                }
                                this.addGrant(config.grant);
                            }
                        }
                        MonikerModel.prototype.addGrant = function (grant) {
                            this.grants.push(grant);
                            switch (grant.kind) {
                                case GrantKind.READER:
                                    this.canRead = true;
                                    break;
                                case GrantKind.WRITER:
                                    this.canWrite = true;
                                    break;
                            }
                        };
                        return MonikerModel;
                    }());
                    documents.MonikerModel = MonikerModel;
                })(documents = infrastructure.documents || (infrastructure.documents = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/Documents.Rest.d.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var coordinates;
                (function (coordinates) {
                    var AngleDirectionSystem;
                    (function (AngleDirectionSystem) {
                        /**
                        * Polar coordinates. 0 degrees points East, angles are measured counter-clockwise.
                        */
                        AngleDirectionSystem.POLAR = "polar";
                        /**
                        * North azimuth. 0 degrees points North, angles are measured clockwise.
                        */
                        AngleDirectionSystem.NORTH_AZIMUTH = "north_azimuth";
                        /**
                        * South azimuth. 0 degrees points South, angles are measured clockwise.
                        */
                        AngleDirectionSystem.SOUTH_AZIMUTH = "south_azimuth";
                    })(AngleDirectionSystem = coordinates.AngleDirectionSystem || (coordinates.AngleDirectionSystem = {}));
                })(coordinates = infrastructure.coordinates || (infrastructure.coordinates = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var coordinates;
                (function (coordinates) {
                    var AngleFormat;
                    (function (AngleFormat) {
                        /**
                        * Decimal degrees.
                        */
                        AngleFormat.DD = "dd";
                        /**
                        * Whole degrees with decimal minutes.
                        */
                        AngleFormat.DDM = "ddm";
                        /**
                        * Degrees, minutes, seconds.
                        */
                        AngleFormat.DMS = "dms";
                    })(AngleFormat = coordinates.AngleFormat || (coordinates.AngleFormat = {}));
                })(coordinates = infrastructure.coordinates || (infrastructure.coordinates = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var coordinates;
                (function (coordinates) {
                    coordinates.featureSetExtendedProperty = "containsCoordinates";
                    coordinates.coordinateIdentifierProperty = "coordinateId";
                    /**
                     * The Coordinates Manager manages all the coordinate models registered in the system.
                     * Not only does it act as the central repository for coordinate systems, it is also responsible for mapping between the input source
                     * coordinate stream and the output coordinate stream when needed - i.e. when there are subscribers to the output coordinate stream.
                     */
                    var CoordinatesManager = (function () {
                        /**
                        * Initializes a new instance of the {@link CoordinatesManager} class.
                        * @param app The {@link framework.application.Application} that this instance belongs to.
                        */
                        function CoordinatesManager(app) {
                            this._registeredCoordinateModels = [];
                            this.app = app;
                        }
                        /**
                         * Registers a new {@link CoordinatesModel}
                         * @param setDefault If this is true then the currently registered model will be set as default. Please note that if there is only one model registered in hte system, it will automatically
                         * be set as default, regardless of this setting.
                         * @return The newly created {@link CoordinatesModel} or null on error.
                         */
                        CoordinatesManager.prototype.registerModel = function (model, setDefault) {
                            if (setDefault === void 0) { setDefault = false; }
                            if (!this._validateModelRegistration(model)) {
                                return false;
                            }
                            this._processCoordinatesModel(model);
                            if (this._registeredCoordinateModels.length === 0 || setDefault) {
                                this._defaultCoordinatesModel = model;
                            }
                            this._registeredCoordinateModels.push(model.id);
                            return true;
                        };
                        /**
                         Retrieves the coordinates for the provided mapPoint or the current mouse pointer location one time in either the specified Coordinate System or in the currently active one
                         @return Promise<CoordinateInfo> Returns a promise for the coordinate information.
                         */
                        CoordinatesManager.prototype.getCoordinate = function (inputCoordinate, targetCoordinateSystem, coordinateModelId) {
                            var _this = this;
                            if (!this.hasRegisteredCoordinatesModel(coordinateModelId)) {
                                var msg = "Coordinates Manager: Could not resolve coordinates. Target coordinates model incorrectly configured or not registered.";
                                return Promise.reject(new Error(msg));
                            }
                            var mapPoint = inputCoordinate instanceof esri.geometry.Point ? inputCoordinate : new esri.geometry.Point(inputCoordinate.x, inputCoordinate.y, inputCoordinate.spatialReference);
                            var coordModel = this._defaultCoordinatesModel;
                            if (coordinateModelId && coordModel.id !== coordinateModelId) {
                                this.getCoordinatesModel(coordinateModelId).then(function (model) {
                                    return coordinates.CoordinateUtils.getCoordinate(_this.app, mapPoint, targetCoordinateSystem || model.currentCoordinateSystem.get(), model.fractionalDigits, model.defaultGcsWkid);
                                }, function (err) {
                                    return Promise.reject(err);
                                });
                            }
                            else {
                                return coordinates.CoordinateUtils.getCoordinate(this.app, mapPoint, targetCoordinateSystem || coordModel.currentCoordinateSystem.get(), coordModel.fractionalDigits, coordModel.defaultGcsWkid);
                            }
                        };
                        /**
                        * Get the specified coordinate model by id. This function will return valid coordinate model instances, whether or not they have been registered with the coordinates manager.
                        * @param modelId The unique identifier for the coordinate model.
                        * @return Promise<CoordinateModel> A promise for the requested coordinate model, whenever it is registered as a framework object.
                        */
                        CoordinatesManager.prototype.getCoordinatesModel = function (modelId) {
                            var _this = this;
                            var executeOperation = function (resolve, reject) {
                                _this.app.getFrameworkObjectByIdAsync(modelId, function (coordModel) {
                                    if (coordModel instanceof geocortex.essentialsHtmlViewer.mapping.infrastructure.coordinates.CoordinatesModel) {
                                        resolve(coordModel);
                                    }
                                    else {
                                        reject(new Error("CoordinatesManager: getCoordinatesModel - {0} is not an instance of a Coordinates Model.".format(modelId)));
                                    }
                                }, function (err) { return reject(err); });
                            };
                            return new Promise(executeOperation);
                        };
                        /**
                         * Tests to see if a coordinates model is registered with the coordinates manager. If no model id is provided, will check if there is a default model registeed else will check to see if the specified
                         * model has been registered or not.
                         * @param modelId Optional. If provided, will check to see if the specified model is registered, else will check if a default model is registered or not.
                         */
                        CoordinatesManager.prototype.hasRegisteredCoordinatesModel = function (modelId) {
                            if (!modelId && this._defaultCoordinatesModel && this._defaultCoordinatesModel.isRegistered) {
                                return true;
                            }
                            if (modelId) {
                                return this._registeredCoordinateModels.indexOf(modelId) > -1;
                            }
                            return false;
                        };
                        CoordinatesManager.prototype._validateModelRegistration = function (coordinatesModel) {
                            if (!coordinatesModel || !coordinatesModel.id || !coordinatesModel.coordinateSystems.length() || !coordinatesModel.currentCoordinateSystem.get()) {
                                return false;
                            }
                            var duplicateModelIds = this._registeredCoordinateModels.filter(function (modelId) { return coordinatesModel.id === modelId; });
                            if (duplicateModelIds.length) {
                                return false;
                            }
                            for (var x = 0; x < coordinatesModel.coordinateSystems.length(); x++) {
                                var coordModel = coordinatesModel.coordinateSystems.getAt(x);
                                if (!this._validateCoordinateSystem(coordModel)) {
                                    return false;
                                }
                            }
                            return true;
                        };
                        CoordinatesManager.prototype._validateCoordinateSystem = function (coordSystem) {
                            return coordSystem.displayName != null && coordSystem.output != null && (coordSystem.wkid != null || coordSystem.wkt != null);
                        };
                        CoordinatesManager.prototype._processCoordinatesModel = function (coordsModel) {
                            var _this = this;
                            this._addModelSubscriptionHooks(coordsModel);
                            // Wire up the input to output stream mappings. We won't allow a mapping to get processed till the previous mapping (if any) has finished processing (or errored out).
                            // We also will not allow multiple consecutive identical inputs to pass through.
                            var inProgress = false;
                            coordsModel.inputStream.bind(this, function (coords) {
                                if (inProgress
                                    || !coordsModel.isActive.get()
                                    || (_this._prevCoord
                                        && _this._prevCoord.x == coords.x
                                        && _this._prevCoord.y == coords.y
                                        && (_this._prevCoord.spatialReference
                                            && coords.spatialReference
                                            && (_this._prevCoord.spatialReference.wkid === coords.spatialReference.wkid
                                                || _this._prevCoord.spatialReference.wkt == coords.spatialReference.wkt)))) {
                                    _this._prevCoord = coords;
                                    return;
                                }
                                _this._prevCoord = coords;
                                var mapPoint = coords instanceof esri.geometry.Point ? coords : new esri.geometry.Point(coords.x, coords.y, coords.spatialReference);
                                inProgress = true;
                                infrastructure.coordinates.CoordinateUtils.getCoordinate(_this.app, mapPoint, coordsModel.currentCoordinateSystem.get(), coordsModel.fractionalDigits, coordsModel.defaultGcsWkid).then(function (coordinate) {
                                    coordsModel.outputStream.set(coordinate);
                                    inProgress = false;
                                }, function (error) {
                                    _this.app.trace.error("CoordinatesManager: An error occurred while attempting to map from input to output coordinate streams for model: {0}".format(coordsModel.id));
                                    inProgress = false;
                                });
                            });
                            coordsModel.isRegistered = true;
                        };
                        /**
                         * We'll need to monitor when subscribers subscribe/unsubscribe to the outputStream observable so we can stop unnecessary coordinate tracking when it's no longer needed. This could be done with a
                         * modification to Events.ts but that will involve an increased memory footprint for functionality that's currently not used anywhere else in the system. After a discussion with <jscharf>, we've
                         * decided to hook into the outputStream bindingEvent subscribe and unsubscribe functions for the time being rather than modify Events.ts to support this. - <sabubaker>
                         */
                        CoordinatesManager.prototype._addModelSubscriptionHooks = function (coordsModel) {
                            var _this = this;
                            var tgtEvt = coordsModel.outputStream.bindingEvent;
                            dojo.aspect.after(tgtEvt, "subscribe", function (token) {
                                _this._handleModelSubscriptionsChanged(coordsModel, tgtEvt["subscriptions"]);
                                return token;
                            });
                            dojo.aspect.after(tgtEvt, "unsubscribe", function (status) {
                                _this._handleModelSubscriptionsChanged(coordsModel, tgtEvt["subscriptions"]);
                                return status;
                            });
                            dojo.aspect.after(tgtEvt, "clear", function () { return _this._handleModelSubscriptionsChanged(coordsModel, tgtEvt["subscriptions"]); });
                            // GVH-9708: Components may have subscribed to the output stream even before the coordinates model is registered. 
                            this._handleModelSubscriptionsChanged(coordsModel, tgtEvt["subscriptions"]);
                        };
                        CoordinatesManager.prototype._handleModelSubscriptionsChanged = function (coordsModel, subscriptions) {
                            var hasSubscribers = false;
                            for (var token in subscriptions) {
                                if (subscriptions.hasOwnProperty(token)) {
                                    hasSubscribers = true;
                                    break;
                                }
                            }
                            if (hasSubscribers !== coordsModel.isActive.get()) {
                                coordsModel.isActive.set(hasSubscribers);
                            }
                        };
                        return CoordinatesManager;
                    }());
                    coordinates.CoordinatesManager = CoordinatesManager;
                })(coordinates = infrastructure.coordinates || (infrastructure.coordinates = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var coordinates;
                (function (coordinates) {
                    /**
                     * Represents a coordinate model. A system can contain multiple coordinate models, each with its own coordinate systems. This model must be processed and registered with the {@link CoordinatesManager}.
                     */
                    var CoordinatesModel = (function (_super) {
                        __extends(CoordinatesModel, _super);
                        function CoordinatesModel() {
                            _super.apply(this, arguments);
                            /**
                             * An observable boolean indicating whether or not this coordinates model is currently active. Automatically activated when there are subscribers to the output stream.
                             */
                            this.isActive = new Observable(false);
                            /**
                             * The coordinate systems supported by this coordinate model.
                             */
                            this.coordinateSystems = new ObservableCollection([]);
                            /**
                             * The currently selected coordinate system.
                             */
                            this.currentCoordinateSystem = new Observable(null);
                            /**
                             * The number of fractional digits the output coordinates should be rounded off to.
                             */
                            this.fractionalDigits = 5;
                            /**
                             * The default geographic coordinate system to use.
                             */
                            this.defaultGcsWkid = 4326;
                            /**
                             * A stream of input base (read raw) coordinates. These can be mapPoints.
                             */
                            this.inputStream = new Observable(null);
                            /**
                             * Processed output coordinate stream. The coordinateManager will automatically convert the input stream to output when this model is active.
                             */
                            this.outputStream = new Observable(null);
                            /**
                            * A boolean indicating whether or not this coordinates model has been initialized and registered with the Coordinates Manager.
                            */
                            this.isRegistered = false;
                        }
                        /**
                         * Application of configuration settings will be handled by the (@link mapping.modules.Map.MapCoordinatesController} once the map is initialized. This function is simply provided to enable a CoordinatesModel object to be
                         * specified as a view model in the configuration files. In such cases, the initialize function will automatically be invoked with the configuration settings.
                         */
                        CoordinatesModel.prototype.initialize = function (config) {
                            this.configuration = config;
                        };
                        return CoordinatesModel;
                    }(geocortex.framework.ui.ViewModelBase));
                    coordinates.CoordinatesModel = CoordinatesModel;
                })(coordinates = infrastructure.coordinates || (infrastructure.coordinates = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts"/>
/// <reference path="../FormatUtils.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var coordinates;
                (function (coordinates) {
                    var CoordinateUtils;
                    (function (CoordinateUtils) {
                        /**
                        * Retrieves the coordinates for the provided mapPoint in the target coordinate system.
                        * fracDigits Optional Parameter lets you specify the number of digits the resulting formatted coordinate values should be rounded to.
                        * geographicCoordSys Optional Parameter lets your specify the default geographic coordinate system to use. Defaults to GCS_WGS_1984 (4326)
                        * @return Promise<Coordinate> Returns a promise for the requested Coordinate.
                        */
                        function getCoordinate(app, mapPoint, targetCoordSys, fracDigits, geographicCoordSys) {
                            if (fracDigits === void 0) { fracDigits = 5; }
                            if (geographicCoordSys === void 0) { geographicCoordSys = 4326; }
                            var processDirective = function (resolve, reject) {
                                var webMercatorUtils = esri.geometry;
                                var sourceSpatialRef = mapPoint.spatialReference;
                                var customCoords = app.map.spatialReference.wkt
                                    ? targetCoordSys.wkt !== app.map.spatialReference.wkt
                                    : targetCoordSys.wkid !== app.map.spatialReference.wkid;
                                var targetSpatialRef = (customCoords || targetCoordSys.output === "xy")
                                    ? new esri.SpatialReference(targetCoordSys.wkid || targetCoordSys.wkt)
                                    : new esri.SpatialReference(geographicCoordSys);
                                var formatAndResolve = function (result) {
                                    var coord = _getFormattedCoordinates(app, result, targetCoordSys, fracDigits);
                                    resolve(coord);
                                };
                                var projectCoordinates = function () {
                                    infrastructure.GeometryUtils.projectGeometry(mapPoint, targetSpatialRef, function (projectedPoint) {
                                        formatAndResolve(projectedPoint);
                                    }, function (error) {
                                        reject(new Error("Unable to project geometry for coordinate tracking: {0}".format(error.message)));
                                    }, app);
                                };
                                var projectCoordinatesIfNativelySupported = function () {
                                    app.command("NativeHasCapability").execute("project", function (canProjectOffline) {
                                        if (!canProjectOffline) {
                                            reject(new Error("Offline Mode. Unable to project geometry for coordinate tracking."));
                                            return;
                                        }
                                        projectCoordinates();
                                    });
                                };
                                if (webMercatorUtils.canProject(sourceSpatialRef, targetSpatialRef)) {
                                    var result = webMercatorUtils.project(mapPoint, targetSpatialRef);
                                    formatAndResolve(result);
                                }
                                else if (!app.isOffline.get()) {
                                    projectCoordinates();
                                }
                                else {
                                    projectCoordinatesIfNativelySupported();
                                }
                            };
                            return new Promise(processDirective);
                        }
                        CoordinateUtils.getCoordinate = getCoordinate;
                        /**
                         * Convert DMS to Decimal Degrees for deciphering manual user input.
                         */
                        function convertDmsToDecimalDegrees(app, deg, min, sec, bearing) {
                            // TODO: Shift to CoordinateUtils.
                            var westAbbr = getResource(app, "west-abbrev").toUpperCase();
                            var eastAbbr = getResource(app, "east-abbrev").toUpperCase();
                            var northAbbr = getResource(app, "north-abbrev").toUpperCase();
                            var southAbbr = getResource(app, "south-abbrev").toUpperCase();
                            bearing = bearing.toUpperCase();
                            var degree = parseFloat(deg);
                            var minute = parseFloat(min);
                            var second = parseFloat(sec);
                            if ((isNaN(degree) || isNaN(minute) || isNaN(second)) || (degree < 0 || degree > 180) || (minute < 0 || minute > 60) || (second < 0 || second > 60) ||
                                (bearing != westAbbr && bearing != eastAbbr && bearing != northAbbr && bearing != southAbbr)) {
                                return null;
                            }
                            var dd = degree + minute / 60 + second / 3600;
                            if (bearing === southAbbr || bearing === westAbbr) {
                                dd = -dd;
                            }
                            return dd;
                        }
                        CoordinateUtils.convertDmsToDecimalDegrees = convertDmsToDecimalDegrees;
                        /**
                        * Formats an angle for display.
                        * @param angle The angle to format, in decimal degrees.
                        * @param format The format to use. One of the AngleFormat constants.
                        * @param app The Geocortex application.
                        * @param fractionalDigits The number of digits to display after the decimal point, for formats that display
                        *     fractional values.
                        */
                        function formatAngle(angle, format, app, fractionalDigits) {
                            if (fractionalDigits == null || typeof fractionalDigits === "undefined") {
                                fractionalDigits = 4;
                            }
                            if (!format) {
                                format = coordinates.AngleFormat.DD;
                            }
                            format = format.toLowerCase();
                            switch (format) {
                                case coordinates.AngleFormat.DDM: return _formatAngleAsDdm(angle, app, fractionalDigits);
                                case coordinates.AngleFormat.DMS: return _formatAngleAsDms(angle, app, fractionalDigits);
                                default: return _formatAngleAsDd(angle, app, fractionalDigits);
                            }
                        }
                        CoordinateUtils.formatAngle = formatAngle;
                        /**
                        * Formats latitude and longitude numbers for display.
                        * @param latitude The degrees of latitude.
                        * @param longitude The degrees of longitude.
                        * @param format The format to use. One of the AngleFormat constants.
                        * @param app The Geocortex application.
                        * @param fractionalDigits The number of digits to display after the decimal point, for formats that display
                        *     fractional values.
                        */
                        function formatLatLon(latitude, longitude, format, app, fractionalDigits) {
                            var latDescriptor = null;
                            var longDescriptor = null;
                            if (latitude > 0) {
                                latDescriptor = CoordinateUtils.getResource(app, "north-abbrev");
                            }
                            else {
                                latDescriptor = CoordinateUtils.getResource(app, "south-abbrev");
                            }
                            if (longitude > 0) {
                                longDescriptor = CoordinateUtils.getResource(app, "east-abbrev");
                            }
                            else {
                                longDescriptor = CoordinateUtils.getResource(app, "west-abbrev");
                            }
                            return {
                                latitude: "{0} {1}".format(CoordinateUtils.formatAngle(Math.abs(latitude), format, app, fractionalDigits), latDescriptor),
                                longitude: "{0} {1}".format(CoordinateUtils.formatAngle(Math.abs(longitude), format, app, fractionalDigits), longDescriptor)
                            };
                        }
                        CoordinateUtils.formatLatLon = formatLatLon;
                        /**
                        * Formats a projected coordinate (X/Y value) for display.
                        * @param coordinate The coordinate to format.
                        * @param app The Geocortex application.
                        * @param fractionalDigits The number of digits to display after the decimal point.
                        */
                        function formatXYCoordinate(coordinate, app, fractionalDigits) {
                            if (fractionalDigits == null || typeof fractionalDigits === "undefined") {
                                fractionalDigits = 4;
                            }
                            return infrastructure.FormatUtils.formatNumber(coordinate, infrastructure.NumberFormat.NUMBER, { fractionalDigits: fractionalDigits });
                        }
                        CoordinateUtils.formatXYCoordinate = formatXYCoordinate;
                        /**
                        * Formats an angle in quadrant bearing notation, e.g. "N 48.5° E".
                        * @param angle The angle to format, specified in decimal degrees using the North azimuth direction system.
                        * @param format The format to use. One of the AngleFormat constants.
                        * @param app The Geocortex application.
                        * @param fractionalDigits The number of digits to display after the decimal point, for formats that display
                        *     fractional values.
                        */
                        function formatBearing(angle, format, app, fractionalDigits) {
                            // Cover a few special cases for due North, due East, etc.
                            // NB: As per the API documentation, everything below assumes the input is in
                            // North azimuth coordinates, not polar!
                            if (angle === 0) {
                                return CoordinateUtils.getResource(app, "north-abbrev");
                            }
                            else if (angle === 90) {
                                return CoordinateUtils.getResource(app, "east-abbrev");
                            }
                            else if (angle === 180) {
                                return CoordinateUtils.getResource(app, "south-abbrev");
                            }
                            else if (angle === 270) {
                                return CoordinateUtils.getResource(app, "west-abbrev");
                            }
                            var prefix = CoordinateUtils.getResource(app, "north-abbrev");
                            var suffix = CoordinateUtils.getResource(app, "east-abbrev");
                            if (angle >= 90 && angle < 180) {
                                prefix = CoordinateUtils.getResource(app, "south-abbrev");
                                angle = 180 - angle;
                            }
                            else if (angle >= 180 && angle < 270) {
                                prefix = CoordinateUtils.getResource(app, "south-abbrev");
                                suffix = CoordinateUtils.getResource(app, "west-abbrev");
                                angle = angle - 180;
                            }
                            else if (angle >= 270 && angle < 360) {
                                suffix = CoordinateUtils.getResource(app, "west-abbrev");
                                angle = 360 - angle;
                            }
                            return "{0} {1} {2}".format(prefix, CoordinateUtils.formatAngle(angle, format, app, fractionalDigits), suffix);
                        }
                        CoordinateUtils.formatBearing = formatBearing;
                        /**
                         * Retrieves coordinate string resources from the infrastructure library.
                         * @param app The application that this utilities class belongs to.
                         * @param resource Input resource name. Can be of the form "language-coordinates-xxx" or simply "xxx".
                         */
                        function getResource(app, resource) {
                            resource = !resource.startsWith("language-coordinates-") ? "language-coordinates-" + resource : resource;
                            return app.getResource("Mapping.Infrastructure", resource);
                        }
                        CoordinateUtils.getResource = getResource;
                        /**
                        * fracDigits Optional Parameter lets you specify the number of digits the resulting formatted coordinate values should be rounded to.
                        * result An Esri generated object w/ 'x' and 'y' values. Current position on the map.
                        */
                        function _getFormattedCoordinates(app, projectedMapPoint, targetCoordinateSystem, fracDigits) {
                            if (fracDigits === void 0) { fracDigits = 5; }
                            var coord = {};
                            coord.targetCoordinateSystem = targetCoordinateSystem;
                            coord.x = projectedMapPoint.x;
                            coord.y = projectedMapPoint.y;
                            coord.spatialReference = projectedMapPoint.spatialReference;
                            /* The lat/long based systems have the x/y values switched. This is intentional, as they're the inverse of the standard x/y numbers */
                            if (targetCoordinateSystem.output == "xy") {
                                coord.formattedLatitudeOrX = infrastructure.FormatUtils.formatNumber(projectedMapPoint.x, infrastructure.NumberFormat.DEFAULT, { fractionalDigits: fracDigits });
                                coord.formattedLongitudeOrY = infrastructure.FormatUtils.formatNumber(projectedMapPoint.y, infrastructure.NumberFormat.DEFAULT, { fractionalDigits: fracDigits });
                            }
                            else {
                                var latLon = infrastructure.coordinates.CoordinateUtils.formatLatLon(projectedMapPoint.y, projectedMapPoint.x, targetCoordinateSystem.output, app, fracDigits);
                                coord.formattedLatitudeOrX = latLon.latitude;
                                coord.formattedLongitudeOrY = latLon.longitude;
                            }
                            return coord;
                        }
                        /**
                        * Formats an angle as decimal degrees.
                        * @param angle The angle to format, in decimal degrees.
                        * @param app The Geocortex application.
                        * @param fractionalDigits The number of digits to display after the decimal point, for formats that display
                        *     fractional values.
                        * @private
                        */
                        function _formatAngleAsDd(angle, app, fractionalDigits) {
                            // TODO: Change this to a custom format string with degrees once the API supports it.
                            return "{0}{1}".format(infrastructure.FormatUtils.formatNumber(angle, infrastructure.NumberFormat.NUMBER, { fractionalDigits: fractionalDigits }), CoordinateUtils.getResource(app, "degrees"));
                        }
                        /**
                        * Formats an angle as degrees, minutes, and seconds.
                        * @param angle The angle to format, in decimal degrees.
                        * @param app The Geocortex application.
                        * @private
                        */
                        function _formatAngleAsDms(angle, app, fractionalDigits) {
                            var degrees = Math.floor(Math.abs(angle));
                            var minutes = Math.floor((Math.abs(angle) - degrees) * 60);
                            var seconds = (Math.abs(angle) - degrees - (minutes / 60)) * 60 * 60;
                            return "{0}{1} {2}{3} {4}{5}".format(degrees * _sign(angle), CoordinateUtils.getResource(app, "degrees"), minutes, CoordinateUtils.getResource(app, "minutes"), infrastructure.FormatUtils.formatNumber(seconds, infrastructure.NumberFormat.NUMBER, { fractionalDigits: fractionalDigits }), CoordinateUtils.getResource(app, "seconds"));
                        }
                        /**
                        * Formats an angle as whole degrees and decimal minutes.
                        * @param angle The angle to format, in decimal degrees.
                        * @param app The Geocortex application.
                        * @param fractionalDigits The number of digits to display after the decimal point, for formats that display
                        *     fractional values.
                        */
                        function _formatAngleAsDdm(angle, app, fractionalDigits) {
                            var degrees = Math.floor(Math.abs(angle));
                            var minutes = (Math.abs(angle) - degrees) * 60;
                            return "{0}{1} {2}{3}".format(degrees * _sign(angle), CoordinateUtils.getResource(app, "degrees"), infrastructure.FormatUtils.formatNumber(minutes, infrastructure.NumberFormat.NUMBER, { fractionalDigits: fractionalDigits }), CoordinateUtils.getResource(app, "minutes"));
                        }
                        /**
                        * Same as Math.sign(x). Not all browsers support it.
                        */
                        function _sign(x) {
                            if (typeof x !== "number") {
                                return NaN;
                            }
                            // NaN, +/- infinity, and -0 pass through as themselves.
                            return x > 0 ? 1 : x < 0 ? -1 : x;
                        }
                    })(CoordinateUtils = coordinates.CoordinateUtils || (coordinates.CoordinateUtils = {}));
                })(coordinates = infrastructure.coordinates || (infrastructure.coordinates = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/Documents.Rest.d.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var documents;
                (function (documents) {
                    var DocumentField = geocortex.essentials.documents.DocumentField;
                    var FilterMethod = geocortex.essentials.documents.FilterMethod;
                    var FilterType = geocortex.essentials.documents.FilterType;
                    var FrameworkObject = geocortex.framework.FrameworkObject;
                    var DocumentCollection = (function (_super) {
                        __extends(DocumentCollection, _super);
                        function DocumentCollection(app, libraryId, mapCallback) {
                            _super.call(this, app, libraryId);
                            this._pageSize = 10;
                            this._queryParams = {};
                            /**
                             * Whether or not the document collection is successfully initialized.
                             */
                            this.isInitialized = false;
                            /**
                             * Whether or not this collection should stop fetching items from the server.
                             */
                            this.stopFetching = false;
                            /**
                             * The items of the current page.
                             */
                            this.items = new ObservableCollection();
                            /**
                             * The total number of items in the collection.
                             */
                            this.numberOfItems = new Observable(0);
                            this.currIndexStart = new Observable(0);
                            this.currIndexStartFromOne = new Observable(1); // 1-indexed, for presentation to user
                            this.currIndexEnd = new Observable(0);
                            this.currPageNumber = new Observable(1);
                            this.firstPageNumber = new Observable(1);
                            this.lastPageNumber = new Observable(1);
                            this.statusFetching = new Observable(false);
                            this.statusOffline = new Observable(false);
                            this._mapCallback = mapCallback;
                        }
                        DocumentCollection.prototype.initialize = function (config) {
                            var _this = this;
                            if (config === void 0) { config = {}; }
                            if (config.pageSize) {
                                this._pageSize = config.pageSize;
                            }
                            if (config.queryParams) {
                                this._queryParams = dojo.mixin(this._queryParams, config.queryParams);
                            }
                            if (config.fileType) {
                                // Convenience shortcut for filtering by filter type
                                this.addFilter({
                                    field: DocumentField.FILE_TYPE,
                                    method: FilterMethod.VALUES,
                                    range: [
                                        {
                                            string: config.fileType
                                        }
                                    ]
                                });
                            }
                            this.isInitialized = true;
                            this.currIndexStartFromOne.syncTransform(this.currIndexStart, function (value) { return value + 1; });
                            this.currPageNumber.bind(this, function () { return _this._handlePageChanged(); });
                            this._populateFromDocStore();
                        };
                        /**
                         * Get the total length of the collection.
                         */
                        DocumentCollection.prototype.getLength = function () {
                            return this.numberOfItems.get();
                        };
                        /**
                         * Increments the page number.
                         */
                        DocumentCollection.prototype.nextPage = function () {
                            this.currPageNumber.set(this.currPageNumber.get() + 1);
                        };
                        /**
                         * Decrements the page number.
                         */
                        DocumentCollection.prototype.prevPage = function () {
                            this.currPageNumber.set(this.currPageNumber.get() - 1);
                        };
                        /**
                         * Refreshes the collection.
                         */
                        DocumentCollection.prototype.refresh = function () {
                            this._populateFromDocStore();
                        };
                        /**
                         * Disposes any bindings tracked by this object.
                         */
                        DocumentCollection.prototype.destroy = function () {
                            _super.prototype.destroy.call(this);
                            // Clear the current page of results.
                            if (this.items) {
                                this.items.clear();
                            }
                        };
                        /**
                         * Set the query parameters used to populate the items.
                         * @param queryParams The query parameters.
                         */
                        DocumentCollection.prototype.setQueryParameters = function (queryParams) {
                            this._queryParams = queryParams;
                            // Refresh the list and return to the first page
                            this.currPageNumber.set(1);
                        };
                        /**
                         * Get the query parameters being used to populate the items.
                         */
                        DocumentCollection.prototype.getQueryParameters = function () {
                            return this._queryParams;
                        };
                        /**
                         * Adds a filter to the query. Removes any previous filters with the same filter.
                         * @param filter The filter to add.
                         * @param filterType The type of filter.
                         */
                        DocumentCollection.prototype.addFilter = function (filter, filterType) {
                            if (filterType === void 0) { filterType = FilterType.REQUIRE; }
                            // Setup the query filters if needed
                            if (!this._queryParams.filters) {
                                this._queryParams.filters = {};
                            }
                            if (!this._queryParams.filters[filterType]) {
                                this._queryParams.filters[filterType] = [];
                            }
                            // Remove any previous filters with the given filter field
                            this._queryParams.filters[filterType] = this._queryParams.
                                filters[filterType].filter(function (f) { return f.field !== filter.field; });
                            // Add the new filter
                            this._queryParams.filters[filterType].push(filter);
                            // Refresh the list and return to the first page
                            this.currPageNumber.set(1);
                        };
                        /**
                         * Remove filters using a given field.
                         * @param field The field of the filters to remove.
                         * @param filterType The type of filter.
                         */
                        DocumentCollection.prototype.removeFilter = function (field, filterType) {
                            if (filterType === void 0) { filterType = FilterType.REQUIRE; }
                            if (!this._queryParams.filters || !this._queryParams.filters[filterType]) {
                                return;
                            }
                            // Remove any filters with the given field
                            this._queryParams.filters[filterType] = this._queryParams.
                                filters[filterType].filter(function (f) { return f.field !== field; });
                            // Cleanup the query if we don't have any filters
                            if (this._queryParams.filters[filterType].length === 0) {
                                delete this._queryParams.filters[filterType];
                            }
                            // Refresh the list and return to the first page
                            this.currPageNumber.set(1);
                        };
                        /**
                         * Sort the documents.
                         * @param sorter The sorter that describes how to sort the documents.
                         */
                        DocumentCollection.prototype.sortBy = function (sorter) {
                            if (!sorter.fields || sorter.fields.length === 0) {
                                return;
                            }
                            // Remove any previous sort fields and add the new one
                            if (sorter.descending) {
                                delete this._queryParams.sort;
                                this._queryParams.sortDescending = sorter.fields;
                            }
                            else {
                                delete this._queryParams.sortDescending;
                                this._queryParams.sort = sorter.fields;
                            }
                            // Refresh the list and return to the first page
                            this.currPageNumber.set(1);
                        };
                        DocumentCollection.prototype._handlePageChanged = function () {
                            // Silently fix up the actual value of pageNumber so the binding event doesnt fire.
                            this.currPageNumber.value = Math.max(1, Number(this.currPageNumber.get()));
                            // Make sure we are in range.
                            if (this.currPageNumber.get() > this.lastPageNumber.get() && this.lastPageNumber.get() > 0) {
                                this.currPageNumber.set(this.lastPageNumber.get());
                            }
                            else {
                                // For page changes, just update the indexes and update the docs
                                this.currIndexStart.set((this.currPageNumber.get() - 1) * this._pageSize);
                                this.currIndexEnd.set(Math.min(this.numberOfItems.get(), this.currIndexStart.get() + this._pageSize));
                                this._populateFromDocStore();
                            }
                        };
                        DocumentCollection.prototype._populateFromDocStore = function () {
                            var _this = this;
                            if (!this.app.site.documentStore.supported || !this.isInitialized || this.stopFetching) {
                                return;
                            }
                            this.statusFetching.set(true);
                            var queryParams = this._buildQueryParams();
                            this.app.waitUntilSiteInitialized()
                                .then(function () { return _this.statusOffline.set(false); })
                                .then(function () { return _this.app.site.documentStore.query(queryParams); })
                                .then(function (result) { return _this._handleQueryResult(result); })
                                .catch(function (error) {
                                // If there was an error, clear the current items
                                _this.items.clear();
                                _this.numberOfItems.set(0);
                                _this.statusOffline.set(true);
                                _this.app.trace.error("Error fetching documents: {0}".format(error), error);
                            })
                                .finally(function () { return _this.statusFetching.set(false); });
                        };
                        /**
                         * Build the query parameters with paging related properties.
                         */
                        DocumentCollection.prototype._buildQueryParams = function () {
                            var queryParams = dojo.mixin({}, this._queryParams);
                            queryParams.start = this.currIndexStart.get();
                            queryParams.limit = this._pageSize;
                            return queryParams;
                        };
                        DocumentCollection.prototype._handleQueryResult = function (queryResult) {
                            this.items.set(queryResult.results.map(this._mapCallback));
                            // Update the total number of items
                            var total = queryResult.total ? queryResult.total : 0;
                            this.numberOfItems.set(total);
                            // Update the last page number
                            var numPages = Math.ceil(total / this._pageSize);
                            this.lastPageNumber.set(numPages);
                            // Kind of redundant but let's just make sure it is 1.
                            this.firstPageNumber.set(1);
                            // For page changes, just update the indexes and update the docs
                            this.currIndexStart.set((this.currPageNumber.get() - 1) * this._pageSize);
                            this.currIndexEnd.set(Math.min(this.numberOfItems.get(), this.currIndexStart.get() + this._pageSize));
                        };
                        return DocumentCollection;
                    }(FrameworkObject));
                    documents.DocumentCollection = DocumentCollection;
                })(documents = infrastructure.documents || (infrastructure.documents = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/jquery.d.ts" />
/// <reference path="../../../_Definitions/jqueryui.d.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var documents;
                (function (documents) {
                    var GrantEditorView = (function (_super) {
                        __extends(GrantEditorView, _super);
                        function GrantEditorView() {
                            _super.apply(this, arguments);
                            this.autoCompleteMinLength = 0;
                            this.autoCompleteMaxEntries = 10;
                        }
                        GrantEditorView.prototype.added = function (widgetViewHost) {
                            _super.prototype.added.call(this, widgetViewHost);
                            this._setupJQueryAutocomplete();
                        };
                        /**
                         * Called on search input.
                         */
                        GrantEditorView.prototype.handleInputChanged = function (evt, el, ctx) {
                            this.viewModel.validateSearchInput();
                        };
                        GrantEditorView.prototype.handleAddMonikerButtonClick = function (evt, el, ctx) {
                            this.viewModel.addMoniker();
                            this.viewModel.resetOptions();
                        };
                        GrantEditorView.prototype.handleUpdateMoniker = function (evt, el, ctx) {
                            this.viewModel.updateMoniker(ctx, el.value);
                            return true;
                        };
                        GrantEditorView.prototype.handleAutoCompleteBlur = function (evt, el, ctx) {
                            $(el).autocomplete("widget").hide();
                        };
                        GrantEditorView.prototype.getSuggestions = function (request, response) {
                            var _this = this;
                            this.viewModel.searchMonikers(request.term)
                                .then(function (monikers) { return _this._processMonikers(monikers); })
                                .then(function (results) { return response(results); })
                                .catch(function (error) { return response([]); });
                        };
                        GrantEditorView.prototype._processMonikers = function (monikers) {
                            var results = [];
                            if (monikers.length > 0) {
                                // Limit the monikers and convert to jquery autocomplete source format
                                results = monikers.slice(0, this.autoCompleteMaxEntries).map(function (moniker) {
                                    return {
                                        label: moniker.title,
                                        moniker: moniker
                                    };
                                });
                            }
                            return Promise.resolve(results);
                        };
                        GrantEditorView.prototype._setupJQueryAutocomplete = function () {
                            var _this = this;
                            // Setup the jQuery UI Autocomplete options - http://api.jqueryui.com/autocomplete/
                            var options = {
                                minLength: this.autoCompleteMinLength,
                                source: function (request, response) {
                                    _this.getSuggestions(request, response);
                                },
                                select: function (e, ui) {
                                    _this._handleAutoCompleteSelect(e, ui);
                                    return false;
                                }
                            };
                            $(this.autoCompleteInput).autocomplete(options);
                        };
                        GrantEditorView.prototype._handleAutoCompleteSelect = function (event, ui) {
                            // Binding isn't being trigger - trigger it manually
                            this.viewModel.searchText.set(ui.item.label);
                            this.viewModel.selectedMoniker.set(ui.item.moniker);
                        };
                        return GrantEditorView;
                    }(geocortex.framework.ui.ViewBase));
                    documents.GrantEditorView = GrantEditorView;
                })(documents = infrastructure.documents || (infrastructure.documents = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var documents;
                (function (documents) {
                    var ArrayUtils = geocortex.framework.utils.ArrayUtils;
                    var BatchRequestBuilder = geocortex.essentials.documents.BatchRequestBuilder;
                    var GrantID = geocortex.essentials.documents.GrantID;
                    var GrantKind = geocortex.essentials.documents.GrantKind;
                    var MonikerKind = geocortex.essentials.documents.MonikerKind;
                    var GrantEditorViewModel = (function (_super) {
                        __extends(GrantEditorViewModel, _super);
                        function GrantEditorViewModel(app, libraryId) {
                            var _this = this;
                            _super.call(this, app, libraryId);
                            // The ordering of these supported grant kinds need to match the order of the table
                            this._supportedGrantKinds = [GrantKind.READER, GrantKind.WRITER];
                            this._globalGrantIds = [GrantID.PUBLIC, GrantID.USER];
                            this._allowPublicAccess = false;
                            this._lastSearchResults = [];
                            this.defaultGrantKind = GrantKind.READER;
                            this.userIconUri = "Resources/Images/Icons/user-24.png";
                            this.roleIconUri = "Resources/Images/Icons/team-24.png";
                            /**
                             * The underlying document whose grants are being edited.
                             */
                            this.document = null;
                            /**
                             * The configured grants.
                             */
                            this.grants = [];
                            /**
                             * The monikers that have grants on the current document.
                             */
                            this.monikers = new ObservableCollection();
                            /**
                             * Whether or not the current search text maps to a valid moniker.
                             */
                            this.isValidMoniker = new Observable(false);
                            // Options
                            this.monikerKinds = new ObservableCollection();
                            this.selectedMonikerKind = new Observable();
                            this.selectedMoniker = new Observable();
                            this.searchText = new Observable();
                            this.enabled = new Observable(true);
                            // Reset the search text when the kind of moniker changes
                            this.searchText.syncTransform(this.selectedMonikerKind, function () { return ""; });
                            // If a moniker was selected, we know its valid
                            this.isValidMoniker.syncTransform(this.selectedMoniker, function (moniker) { return !!moniker; });
                            this.enabled.bind(this, function () { return _this._setMonikerEnableds(); });
                            this._setMonikerKinds();
                            if (this.app.site && this.app.site.isInitialized) {
                                this.onSiteInitialized();
                            }
                            else {
                                this.app.event("SiteInitializedEvent").once(this, this.onSiteInitialized);
                            }
                        }
                        GrantEditorViewModel.prototype.onSiteInitialized = function () {
                            var _this = this;
                            this.app.site.documentStore.onInitialized()
                                .then(function () {
                                // Update whether or not we have a policy to allow public access
                                _this._allowPublicAccess = _this.app.site.documentStore
                                    .hasPolicyGrant(function (grant) { return grant.globalId === GrantID.PUBLIC && grant.kind === GrantKind.GLOBAL_READER; });
                            });
                        };
                        /**
                         * Load a document's grants from the document store and updates the view model state.
                         * @param id The ID of the document to load.
                         */
                        GrantEditorViewModel.prototype.loadById = function (id) {
                            var _this = this;
                            return this.app.waitUntilSiteInitialized()
                                .then(function () { return _this.app.site.documentStore.getById(id); })
                                .then(function (doc) { return _this._updateModel(doc); })
                                .catch(function (error) {
                                // Given that this is a widget, it is expected that the parent view properly handles this error
                                _this.app.trace.error("Error loading document: {0}".format(error), error);
                                _this.reset();
                            });
                        };
                        /**
                         * Add a moniker, updating the document with a grant for the moniker.
                         */
                        GrantEditorViewModel.prototype.addMoniker = function () {
                            var selectedMoniker = this._getSelectedMoniker();
                            if (!selectedMoniker) {
                                this.app.trace.error("GrantEditorViewModel: Could not find moniker with title {0}.".format(this.searchText.get()));
                                return;
                            }
                            // If we already have the moniker, do not add it
                            if (this._monikerExists(selectedMoniker)) {
                                this.app.trace.warning("GrantEditorViewModel: Could not add the grant as it already exists.");
                                return;
                            }
                            // Add the grant to the document
                            var grant = this.addGrant(selectedMoniker.globalId, this.defaultGrantKind);
                            // Add the moniker to our list with the grant
                            this.monikers.addItem(new documents.MonikerModel({
                                grant: grant,
                                name: selectedMoniker.title,
                                iconUri: this._isUserKind(this.selectedMonikerKind.get()) ? this.userIconUri : this.roleIconUri
                            }));
                            this._setMonikerEnableds();
                        };
                        /**
                         * Add a grant to the document.
                         * @param id The global ID of the grant
                         * @param kind The kind of grant.
                         * @return The grant that was added
                         */
                        GrantEditorViewModel.prototype.addGrant = function (id, kind) {
                            var grant = {
                                globalId: id,
                                kind: kind,
                                assert: true
                            };
                            this.grants.push(grant);
                            return grant;
                        };
                        /**
                         * Update the moniker by updating the document grants.
                         * @param moniker The model of the moniker being updated.
                         * @param grantKind The kind of grant to add to the document for the given moniker.
                         */
                        GrantEditorViewModel.prototype.updateMoniker = function (moniker, grantKind) {
                            // Revoke any grants for the moniker
                            moniker.grants.forEach(function (grant) {
                                grant.assert = false;
                                grant.revoke = true;
                            });
                            switch (grantKind) {
                                case GrantKind.READER:
                                case GrantKind.WRITER:
                                    // Get the grant or add one of the document
                                    var grant = ArrayUtils.firstOrDefault(moniker.grants, function (grant) { return grant.kind === grantKind; });
                                    if (!grant) {
                                        grant = this.addGrant(moniker.id, grantKind);
                                        moniker.addGrant(grant);
                                    }
                                    // Make sure the grant has been asserted
                                    grant.assert = true;
                                    grant.revoke = false;
                                    // Update the revoked state of the grant if it is not a global grant
                                    if (!this._globalGrantIds.some(function (grantId) { return grantId === moniker.id; })) {
                                        moniker.isRevoked.set(false);
                                    }
                                    break;
                                default:
                                    // Set the grant as revoked if it is not a global grant
                                    if (!this._globalGrantIds.some(function (grantId) { return grantId === moniker.id; })) {
                                        moniker.isRevoked.set(true);
                                    }
                            }
                        };
                        /**
                         * Search for monikers using a given search term. These results will
                         * be limited by the currently selected moniker kind (users or roles).
                         * @param searchTerm The search term to search monikers with.
                         * @return A promise containing a list of monikers.
                         */
                        GrantEditorViewModel.prototype.searchMonikers = function (searchTerm) {
                            var _this = this;
                            var request;
                            if (this._isUserKind(this.selectedMonikerKind.get())) {
                                request = BatchRequestBuilder.searchUsers(searchTerm);
                            }
                            else {
                                request = BatchRequestBuilder.searchRoles(searchTerm);
                            }
                            return this.app.waitUntilSiteInitialized()
                                .then(function () { return _this.app.site.documentStore.perform(request); })
                                .then(function (result) { return _this._lastSearchResults = result.monikers; });
                        };
                        /**
                         * Validates the search input.
                         */
                        GrantEditorViewModel.prototype.validateSearchInput = function () {
                            var _this = this;
                            // Only validate once we have a selected moniker and search text
                            if (!this.selectedMoniker.get() || !this.searchText.get()) {
                                return;
                            }
                            this.isValidMoniker.set(this._lastSearchResults.some(function (moniker) { return moniker.title === _this.searchText.get(); }));
                        };
                        /**
                         * Reset the search options.
                         */
                        GrantEditorViewModel.prototype.resetOptions = function () {
                            this.searchText.set(null);
                            this.selectedMoniker.set(null);
                        };
                        /**
                         * Set the view model state to defaults.
                         */
                        GrantEditorViewModel.prototype.reset = function () {
                            this._updateModel(null);
                        };
                        /**
                         * Gets the selected moniker based off the current search text.
                         * If the text does not match the selected moniker, it will search
                         * through the last search results for monikers.
                         */
                        GrantEditorViewModel.prototype._getSelectedMoniker = function () {
                            var _this = this;
                            // If the search matches the last selected moniker use that
                            if (this.selectedMoniker.get().title === this.searchText.get()) {
                                return this.selectedMoniker.get();
                            }
                            // Fallback to checking the last search results for a moniker
                            return this._lastSearchResults.filter(function (x) { return x.title === _this.searchText.get(); })[0];
                        };
                        /**
                         * Whether a given moniker kind is a user kind.
                         * @param monikerKind The moniker kind.
                         * @return Whether or not the kind is a user kind.
                         */
                        GrantEditorViewModel.prototype._isUserKind = function (monikerKind) {
                            return monikerKind === MonikerKind.USER;
                        };
                        /**
                         * Update the view model with the document of the given ID.
                         * @param id The ID of the document to update this model with.
                         */
                        GrantEditorViewModel.prototype._updateModel = function (document) {
                            this.document = document;
                            this.grants = document && document.grants ? document.grants : [];
                            this.resetOptions();
                            this._updateMonikers(this.grants);
                        };
                        /**
                         * Updates the monikers list based off the given grants.
                         * @param grants The grants to build the monikers from.
                         */
                        GrantEditorViewModel.prototype._updateMonikers = function (grants) {
                            // Rebuild the monikers list
                            this.monikers.clear();
                            var monikerModels = [];
                            // Add monikers for the global grants now so they're at the top of the list
                            for (var i = 0; i < this._globalGrantIds.length; i++) {
                                var grantId = this._globalGrantIds[i];
                                monikerModels.push(new documents.MonikerModel({
                                    id: grantId,
                                    name: this.app.getResource(this.libraryId, "language-grant-editor-global-grant-name-{0}".format(grantId)),
                                    iconUri: this.roleIconUri,
                                    isGlobal: true,
                                    isPublic: grantId === GrantID.PUBLIC
                                }));
                            }
                            // Loop through the grants twice, first looking for reader grants, then writer grants
                            for (var i = 0; i < this._supportedGrantKinds.length; i++) {
                                for (var j = 0; j < grants.length; j++) {
                                    var grant = grants[j];
                                    // If the grant is not of the current kind, just skip
                                    if (grant.kind !== this._supportedGrantKinds[i]) {
                                        continue;
                                    }
                                    // If we have a model for the moniker, add the grant
                                    // Otherwise, create a new moniker for the grant
                                    var monikerModel = ArrayUtils.firstOrDefault(monikerModels, function (model) { return model.id === grant.globalId; });
                                    if (monikerModel) {
                                        monikerModel.addGrant(grant);
                                    }
                                    else {
                                        monikerModels.push(new documents.MonikerModel({
                                            grant: grant,
                                            iconUri: this._isUserKind(grant.subject.kind) ? this.userIconUri : this.roleIconUri
                                        }));
                                    }
                                }
                            }
                            // If we do not allow public access, filter out any public monikers
                            if (!this._allowPublicAccess) {
                                monikerModels = monikerModels.filter(function (monikerModel) { return !monikerModel.isPublic; });
                            }
                            this.monikers.addItems(monikerModels);
                            this._setMonikerEnableds();
                        };
                        /**
                         * Checks whether or not the moniker already exists based off its ID and aliases.
                         * @param moniker The moniker to check whether it exists.
                         * @return Whether or not the moniker exists.
                         */
                        GrantEditorViewModel.prototype._monikerExists = function (moniker) {
                            if (!moniker) {
                                return false;
                            }
                            var monikers = this.monikers.getItems();
                            // Check if the moniker ID has a match
                            if (monikers.some(function (x) { return x.id === moniker.globalId; })) {
                                return true;
                            }
                            // If the moniker has alias IDs, check for a match
                            if (moniker.aliases) {
                                for (var i = 0; i < moniker.aliases.length; i++) {
                                    var alias = moniker.aliases[i];
                                    if (monikers.some(function (x) { return x.id === alias; })) {
                                        return true;
                                    }
                                }
                            }
                            return false;
                        };
                        GrantEditorViewModel.prototype._setMonikerKinds = function () {
                            this.monikerKinds.addItems([
                                {
                                    kind: MonikerKind.USER,
                                    displayName: this.app.getResource(this.libraryId, "language-grant-editor-moniker-type-user")
                                },
                                {
                                    kind: MonikerKind.ROLE,
                                    displayName: this.app.getResource(this.libraryId, "language-grant-editor-moniker-type-role")
                                }
                            ]);
                            this.selectedMonikerKind.set(this.monikerKinds.getAt(0).kind);
                        };
                        GrantEditorViewModel.prototype._setMonikerEnableds = function () {
                            var enabled = this.enabled.get();
                            for (var monikerIx = 0, length_1 = this.monikers.length(); monikerIx < length_1; monikerIx++) {
                                this.monikers.getAt(monikerIx).enabled.set(enabled);
                            }
                        };
                        return GrantEditorViewModel;
                    }(geocortex.framework.ui.ViewModelBase));
                    documents.GrantEditorViewModel = GrantEditorViewModel;
                })(documents = infrastructure.documents || (infrastructure.documents = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var documents;
                (function (documents) {
                    /**
                     * Model for a single guest link of a document.
                     */
                    var GuestLinkModel = (function () {
                        function GuestLinkModel(config) {
                            /**
                             * The name of the guest link.
                             */
                            this.name = new Observable();
                            /**
                             * The URL for this guest link.
                             */
                            this.linkUrl = new Observable();
                            if (config.kind) {
                                this.kind = config.kind;
                            }
                            if (config.name) {
                                this.name.set(config.name);
                            }
                        }
                        GuestLinkModel.prototype.reset = function () {
                            this.grant = null;
                            this.link = null;
                            this.linkUrl.set(null);
                        };
                        return GuestLinkModel;
                    }());
                    documents.GuestLinkModel = GuestLinkModel;
                })(documents = infrastructure.documents || (infrastructure.documents = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ExportTilesUtils;
                (function (ExportTilesUtils) {
                    var tenTwoOneServices = {};
                    /**
                     * Submit a job to the ArcGIS server.  The result is a JobInfo structure.
                     * @param serviceUrl The map service URL.
                     * @param jobName The name of the job, eg: exportTiles, estimateExportTilesSize.
                     * @param params Parameters to the job.
                     * @returns A promise of the job info for the new job.
                     */
                    function submitJob(serviceUrl, jobName, params) {
                        var url = serviceUrl + "/" + jobName;
                        if (tenTwoOneServices.hasOwnProperty(serviceUrl)) {
                            url += "/submitjob";
                        }
                        return esri.request({
                            callbackParamName: "callback",
                            content: dojo.mixin({ f: "json" }, params),
                            handleAs: "json",
                            url: url
                        })
                            .then(function (jobInfo) {
                            if (!jobInfo.jobStatus && jobInfo.executionType && jobInfo.parameters) {
                                // ArcGIS 10.2.1 exactly returns info about this service at this endpoint, and we must use '/submitJob' instead.
                                tenTwoOneServices[serviceUrl] = true;
                                return submitJob(serviceUrl, jobName, params);
                            }
                            return jobInfo;
                        });
                    }
                    /**
                     * Follow the executing job to success or failure.  If the passed in JobInfo is already completed
                     * then the function exits quickly, otherwise the job is polled over the network.
                     * @param serviceUrl The map service URL.
                     * @param jobName The name of the job, eg: exportTiles, estimateExportTilesSize.
                     * @param jobInfo The info of the job to follow to completion.
                     * @param retryDelay A delay before polling on the network.
                     * @returns A promise of the job info for the finished job.
                     */
                    function finishJob(serviceUrl, jobName, jobInfo, retryDelay) {
                        if (retryDelay === void 0) { retryDelay = 1000; }
                        switch (jobInfo.jobStatus) {
                            case esri.tasks.JobInfo.STATUS_CANCELLED:
                            case esri.tasks.JobInfo.STATUS_DELETED:
                            case esri.tasks.JobInfo.STATUS_FAILED:
                            case esri.tasks.JobInfo.STATUS_TIMED_OUT:
                                return Promise.reject(getMostInterestingFailureMessage(jobInfo));
                            case esri.tasks.JobInfo.STATUS_SUCCEEDED:
                                return Promise.resolve(jobInfo);
                            default:
                                return Promise
                                    .delay(retryDelay)
                                    .then(function () { return esri.request({
                                    callbackParamName: "callback",
                                    content: { f: "json" },
                                    handleAs: "json",
                                    url: serviceUrl + "/" + jobName + "/jobs/" + jobInfo.jobId
                                }); })
                                    .then(function (jobInfo) { return finishJob(serviceUrl, jobName, jobInfo, Math.min(retryDelay * 2, 60000)); });
                        }
                    }
                    /**
                     * Get the result or input parameter of a completed job.
                     * @param serviceUrl The map service URL.
                     * @param jobName The name of the job, eg: exportTiles, estimateExportTilesSize.
                     * @param jobId The ID of the job, returned from submitJob.
                     * @param paramUrl The relative path of the parameter URL, eg: results/out_service_url, inputs/service_url.
                     * @returns A promise of the job parameter's value.
                     */
                    function getJobParam(serviceUrl, jobName, jobId, paramUrl) {
                        return esri.request({
                            callbackParamName: "callback",
                            content: { f: "json" },
                            handleAs: "json",
                            url: serviceUrl + "/" + jobName + "/jobs/" + jobId + "/" + paramUrl
                        });
                    }
                    /**
                     * Get folder content from the ArcGIS Server.
                     * @param folderUrl The URL of the folder.
                     * @returns A promise of the folder's content.
                     */
                    function getJobOutputFolder(folderUrl) {
                        return esri.request({
                            callbackParamName: "callback",
                            content: { f: "json" },
                            handleAs: "json",
                            url: folderUrl
                        });
                    }
                    /**
                     * From the messages in the JobInfo get the most interesting error message.
                     * @param jobInfo The job status object.
                     * @returns The most interesting error message.
                     */
                    function getMostInterestingFailureMessage(jobInfo) {
                        if (!jobInfo || !jobInfo.messages) {
                            return "";
                        }
                        var failureMessages = jobInfo.messages.filter(function (message) { return message.type === esri.tasks.GPMessage.TYPE_ERROR; });
                        // Messages with error codes are more useful.
                        var errorCodedMessages = failureMessages.filter(function (message) { return /^ERROR \d+:/.test(message.description); });
                        if (errorCodedMessages.length > 0) {
                            failureMessages = errorCodedMessages;
                        }
                        // Return the longest error message.
                        return failureMessages.reduce(function (previous, next) { return next.description.length > previous.length ? next.description : previous; }, "");
                    }
                    /**
                     * Export tiles from a map service supporting the operation.
                     * @param service The map service to export tiles from.
                     * @param params Operation parameters.
                     * @returns A promise of the URL(s) the newly exported tiles can be downloaded from.
                     */
                    function exportTiles(service, params) {
                        var serviceUrl = typeof service === "string" ? service : service.url;
                        while (serviceUrl[serviceUrl.length - 1] === "/") {
                            serviceUrl = serviceUrl.substring(0, serviceUrl.length - 1);
                        }
                        return submitJob(serviceUrl, "exportTiles", params)
                            .then(function (jobInfo) { return finishJob(serviceUrl, "exportTiles", jobInfo); })
                            .then(function (jobInfo) { return getJobParam(serviceUrl, "exportTiles", jobInfo.jobId, jobInfo.results.out_service_url.paramUrl); })
                            .then(function (jobParam) { return getJobOutputFolder(jobParam.value); })
                            .then(function (folderContent) { return folderContent.files; });
                    }
                    ExportTilesUtils.exportTiles = exportTiles;
                    /**
                     * Extimate the size of exported tiles from a map service supporting the operation.
                     * @param service The map service to export tiles from.
                     * @param params Operation parameters.
                     * @returns A promise of an estimate of the size of the exported tiles.
                     */
                    function estimateExportTilesSize(service, params) {
                        var serviceUrl = typeof service === "string" ? service : service.url;
                        while (serviceUrl[serviceUrl.length - 1] === "/") {
                            serviceUrl = serviceUrl.substring(0, serviceUrl.length - 1);
                        }
                        return submitJob(serviceUrl, "estimateExportTilesSize", params)
                            .then(function (jobInfo) { return finishJob(serviceUrl, "estimateExportTilesSize", jobInfo); })
                            .then(function (jobInfo) { return getJobParam(serviceUrl, "estimateExportTilesSize", jobInfo.jobId, jobInfo.results.out_service_url.paramUrl); })
                            .then(function (result) {
                            if (typeof result.value === "string") {
                                // 10.2.1
                                return {
                                    totalSize: +result.value,
                                    totalTilesToExport: null
                                };
                            }
                            else {
                                // 10.2.2
                                return result.value;
                            }
                        });
                    }
                    ExportTilesUtils.estimateExportTilesSize = estimateExportTilesSize;
                })(ExportTilesUtils = infrastructure.ExportTilesUtils || (infrastructure.ExportTilesUtils = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../_Definitions/caja-html-sanitizer.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var FilterUtils;
                (function (FilterUtils) {
                    /**
                     * Sanitize a string of unsafe HTML to eliminate XSS (cross-site scripting) security risks.
                     * This method allows tags and standard attributes, however `data-` attributes are not allowed.
                     * Script tags are not allowed either.
                     * Note that you must pass a {@link SanitizeOptions.uriTransformer} function in the options
                     * if you wish to allow URIs in your content.
                     * @param unsafeHtml String of HTML to be scrubbed clean.
                     * @param options {@link SanitizeOptions}.
                     * @return Safe HTML that has been sanitized.
                     */
                    function sanitize(unsafeHtml, options) {
                        if (options === void 0) { options = {}; }
                        // Allowing [aria-label] attribute on all tags.
                        html4.ATTRIBS["*::aria-label"] = 0;
                        // GVH-10345
                        // Caja doesn't support wildcards like data-*. We have opted to provide one specific attribute 
                        // that is intended to be used in feature descriptions with replacement tokens.
                        html4.ATTRIBS["*::data-replacement-token"] = 0;
                        // Allowing [target] attribute on <a> tags.
                        html4.ATTRIBS["a::target"] = 0;
                        // Allowing [src] attribute on <iframe> tags.
                        // Integer 1 indicates that the attribute is a URI to be passed through the URI transformer.
                        if (options.allowFrames) {
                            html4.ATTRIBS["iframe::src"] = 1;
                        }
                        // Performing sanitization via Google Caja.
                        //  - Caja GitHub repo: https://github.com/google/caja
                        //  - Caja html-sanitizer.js source code: https://github.com/google/caja/blob/master/src/com/google/caja/plugin/html-sanitizer.js
                        //  - Some documentation that helped inform our usage: https://github.com/google/caja/wiki/JsHtmlSanitizer
                        return html.sanitize(unsafeHtml, function (uri, ueffect, ltype, hints) {
                            if (!options.uriTransformer) {
                                // If URI transformer is not specified, we simply eliminate all URIs.
                                return "";
                            }
                            else {
                                // Ensure the URI is simply a string (instead of Caja's fancy location object).
                                uri = uri.toString();
                                // Details object that is provided to the URI transformer.
                                var details = void 0;
                                // Details for a markup URI.
                                if (hints.TYPE === "MARKUP") {
                                    var xmlHints = hints;
                                    details = {
                                        uri: uri,
                                        type: (xmlHints.XML_TAG === "a" && xmlHints.XML_ATTR === "href") ? UriType.NavigableLink : UriType.Markup,
                                        tag: xmlHints.XML_TAG,
                                        attribute: xmlHints.XML_ATTR
                                    };
                                }
                                else if (hints.TYPE === "CSS") {
                                    var cssHints = hints;
                                    details = {
                                        uri: uri,
                                        type: UriType.Css,
                                        property: cssHints.CSS_PROP
                                    };
                                }
                                else {
                                    throw new Error("Unknown URI hint type: '" + hints.TYPE + "'");
                                }
                                // Run the URI transformer with the URI and the details object, and return the result.
                                return options.uriTransformer(uri, details);
                            }
                        });
                    }
                    FilterUtils.sanitize = sanitize;
                    /**
                     * Strip all HTML out of a string.
                     * @param unsafe String of text which will have its HTML stripped away.
                     * @return A plain text string without any HTML markup.
                     */
                    function stripHtml(unsafe) {
                        // Initially unescaping content to destroy encoded XSS attacks.
                        unsafe = String.unescapeHtml(unsafe);
                        // Sanitize any HTML that is present, to make it safe (from XSS risks).
                        var safe = sanitize(unsafe);
                        // Create a temporary div (using the browser to strip away HTML content).
                        var div = document.createElement("div");
                        // Insert the safe content as innerHTML.
                        div.innerHTML = safe;
                        // Return the temporary div's textContent to receive plain text.
                        return div.innerText || div.textContent;
                    }
                    FilterUtils.stripHtml = stripHtml;
                    /**
                     * Interfaces and implementation details specific to sanitization.
                     */
                    (function (UriType) {
                        UriType[UriType["Markup"] = 0] = "Markup";
                        UriType[UriType["Css"] = 1] = "Css";
                        UriType[UriType["NavigableLink"] = 2] = "NavigableLink";
                    })(FilterUtils.UriType || (FilterUtils.UriType = {}));
                    var UriType = FilterUtils.UriType;
                    /**
                     * A container for HTML content that is not trusted to be safe.
                     * Has getters for accessing either the originally-provided unsafe HTML string, or a safely sanitized version.
                     * Simplifies XSS security matters by making the handling of unsafe HTML obvious and clear.
                     */
                    var UnsafeHtml = (function () {
                        /**
                         * Create a new container for unsafe HTML.
                         */
                        function UnsafeHtml(unsafeHtml, sanitizeOptions) {
                            if (sanitizeOptions === void 0) { sanitizeOptions = {}; }
                            this.sanitize(unsafeHtml, sanitizeOptions);
                        }
                        /**
                         * Update the HTML.
                         */
                        UnsafeHtml.prototype.sanitize = function (unsafeHtml, sanitizeOptions) {
                            if (sanitizeOptions === void 0) { sanitizeOptions = {}; }
                            this._unsafeHtml = unsafeHtml;
                            this._safeHtml = sanitize(this._unsafeHtml, sanitizeOptions);
                        };
                        Object.defineProperty(UnsafeHtml.prototype, "unsafeHtml", {
                            /**
                             * Get the original unsafe HTML.
                             */
                            get: function () {
                                return this._unsafeHtml;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(UnsafeHtml.prototype, "safeHtml", {
                            /**
                             * Get the safely sanitized version of the HTML.
                             */
                            get: function () {
                                return this._safeHtml;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        return UnsafeHtml;
                    }());
                    FilterUtils.UnsafeHtml = UnsafeHtml;
                    /**
                     * Utilities for parsing and assessing data URIs.
                     */
                    var DataUri;
                    (function (DataUri) {
                        /** Whitelist for media types (MIME types without parameters like charset) which are allowed in safe data URI's. */
                        DataUri.dataUriMediaTypeWhitelist = [
                            "image/jpeg",
                            "image/png",
                            "image/gif",
                            "image/svg+xml"
                        ];
                        /**
                         * Break a data URI string down into its sub-components.
                         * @param uri Data URI to parse.
                         * @return {@link DataUriComponents} as seen in the URI (no defaults are provided, omitted optionals will be undefined).
                         */
                        function parseDataUri(uri) {
                            // Regular expression for matching data URIs.
                            //                      1  2    3    4
                            //                      |  |    |    |
                            var matches = uri.match(/^\s*data:(.*?),.+/i);
                            //                                    |
                            //                                    5
                            // 1: Optional leading whitespace.
                            // 2: Required 'data:' scheme.
                            // 3: Optional (captured) meta data preamble, potentially containing: media type, character set, and base64 extension.
                            // 4: Required comma that separates the meta preamble from the data payload.
                            // 5: Required data payload.
                            // If the provided data URI is invalid, return null.
                            if (!matches) {
                                return null;
                            }
                            // Break the meta preamble down into its optional parts: media type, character set, and base64 extension.
                            var meta = matches[1], metaParts = meta.split(";"), mediaType, charset, extension;
                            for (var _i = 0, metaParts_1 = metaParts; _i < metaParts_1.length; _i++) {
                                var metaPart = metaParts_1[_i];
                                // Parse meta parts for character set.
                                if (/^charset=(.+)$/i.test(metaPart)) {
                                    // Only allow this part to be defined one time (duplicates cause parsing failure).
                                    if (charset) {
                                        return null;
                                    }
                                    charset = metaPart;
                                }
                                else if (/^base64$/i.test(metaPart)) {
                                    // Only allow this part to be defined one time (duplicates cause parsing failure).
                                    if (extension) {
                                        return null;
                                    }
                                    extension = metaPart;
                                }
                                else if (/^.+$/i.test(metaPart)) {
                                    // Only allow this part to be defined one time (duplicates cause parsing failure).
                                    if (mediaType) {
                                        return null;
                                    }
                                    mediaType = metaPart;
                                }
                            }
                            // Return the data payload's starting index, instead of allocating and returning a new substring (performance).
                            var payloadIndex = uri.indexOf(",") + 1;
                            // Return parsed details.
                            return { uri: uri, meta: meta, mediaType: mediaType, charset: charset, extension: extension, payloadIndex: payloadIndex };
                        }
                        DataUri.parseDataUri = parseDataUri;
                        /**
                         * Check if a data URI is safe, in that it cannot be used as an XSS attack vector.
                         * The data URI is considered safe when its detected media type (MIME type) is present in the data URI media type whitelist.
                         * @param uri Data URI to scrutinize for XSS safety.
                         * @return True when the data URI is safe, false when the data URI is unsafe or invalid.
                         */
                        function isDataUriSafe(uri) {
                            // Parse the data URI.
                            var parse = parseDataUri(uri);
                            // If the data URI failed parsing then it's not safe.
                            if (!parse) {
                                return false;
                            }
                            // If media type is not present, it's standard to assume "text/plain".
                            var mediaType = parse.mediaType;
                            if (!mediaType) {
                                mediaType = "text/plain";
                            }
                            // If the media type is whitelisted, this data URI is safe.
                            if (DataUri.dataUriMediaTypeWhitelist.some(function (white) { return mediaType.toLowerCase() === white.toLowerCase(); })) {
                                return true;
                            }
                            // If the data URI is unsafe (or invalid), false is returned.
                            return false;
                        }
                        DataUri.isDataUriSafe = isDataUriSafe;
                    })(DataUri = FilterUtils.DataUri || (FilterUtils.DataUri = {}));
                })(FilterUtils = infrastructure.FilterUtils || (infrastructure.FilterUtils = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var highlightedLabel;
                (function (highlightedLabel) {
                    /**
                     * The highlight label anchor modes. The label can be anchored at the bottom left, the center or as a callout.
                     */
                    (function (HighlightedLabelAnchor) {
                        HighlightedLabelAnchor[HighlightedLabelAnchor["BOTTOM_LEFT"] = 0] = "BOTTOM_LEFT";
                        HighlightedLabelAnchor[HighlightedLabelAnchor["MIDDLE"] = 1] = "MIDDLE";
                        HighlightedLabelAnchor[HighlightedLabelAnchor["CALLOUT"] = 2] = "CALLOUT";
                    })(highlightedLabel.HighlightedLabelAnchor || (highlightedLabel.HighlightedLabelAnchor = {}));
                    var HighlightedLabelAnchor = highlightedLabel.HighlightedLabelAnchor;
                    /**
                     * Creates a highlighted label and adds it to a specified graphics layer on the map. The label could be a simple rectangle or a callout with an id text tag and a pointer pointing to the map point associated with this label.
                     */
                    var HighlightedLabelGraphic = (function () {
                        function HighlightedLabelGraphic(config, app) {
                            this.textGraphics = [];
                            this.textSymbols = [];
                            // Dimensions
                            this._height = 0;
                            this._width = 0;
                            this._padding = 0;
                            // Const
                            this._calloutSizeWidthFraction = 5;
                            this._tagHeightPercentage = 0.6;
                            if (!app || !this._processConfig(config)) {
                                throw new Error("HighlightedLabelGraphic: Initialization failed.");
                            }
                            this.app = app;
                            this.graphicsLayer = infrastructure.GraphicUtils.getGraphicsLayer(this._config.layerId, true, this.app);
                            // Initialize graphics and symbols if we aren't restoring from saved state (see fromExportedState()).
                            if (!config["_isRestoringState"]) {
                                this._executeSetupRoutine();
                            }
                        }
                        HighlightedLabelGraphic.prototype.getTextFontFamily = function () {
                            return this.textSymbols && this.textSymbols.length > 0 ? this.textSymbols[0].font.family : this._config.fontFamily;
                        };
                        HighlightedLabelGraphic.prototype.getTextFontSize = function () {
                            return this.textSymbols && this.textSymbols.length > 0 ? this.textSymbols[0].font.size + "px" : this._config.fontSize;
                        };
                        HighlightedLabelGraphic.prototype.getWidth = function () {
                            return this._width;
                        };
                        HighlightedLabelGraphic.prototype.getTotalWidth = function () {
                            return this._width + this._padding;
                        };
                        HighlightedLabelGraphic.prototype.getHeight = function () {
                            return this._height;
                        };
                        HighlightedLabelGraphic.prototype.getTotalHeight = function () {
                            return this._height + this._padding;
                        };
                        HighlightedLabelGraphic.prototype.getMapPoint = function () {
                            return this._config.mapPoint;
                        };
                        HighlightedLabelGraphic.prototype.getConfig = function () {
                            return this._config;
                        };
                        HighlightedLabelGraphic.prototype.addToLayer = function (show) {
                            var _this = this;
                            if (show === void 0) { show = true; }
                            infrastructure.GraphicUtils.addGraphicToLayer(this.highlightGraphic, this._config.layerId, this.app);
                            infrastructure.GraphicUtils.addGraphicToLayer(this.highlightIdTagGraphic, this._config.layerId, this.app);
                            this.textGraphics.forEach(function (textGraphic) {
                                infrastructure.GraphicUtils.addGraphicToLayer(textGraphic, _this._config.layerId, _this.app);
                            });
                            if (show) {
                                this.show();
                            }
                            else {
                                this.hide();
                            }
                        };
                        HighlightedLabelGraphic.prototype.removeFromLayer = function (destroy) {
                            this.hide();
                            var removeGraphic = function (graphic) {
                                var lyr = graphic.getLayer();
                                if (lyr) {
                                    lyr.remove(graphic);
                                }
                            };
                            if (this.textGraphics && this.textGraphics.length > 0) {
                                this.textGraphics.forEach(function (graphic) { return removeGraphic(graphic); });
                                if (destroy) {
                                    this.textGraphics.length = 0;
                                    this.textSymbols.length = 0;
                                }
                            }
                            if (this.highlightIdTagGraphic) {
                                removeGraphic(this.highlightIdTagGraphic);
                                if (destroy) {
                                    this.highlightIdTagGraphic = null;
                                    this.highlightIdTagSymbol = null;
                                }
                            }
                            if (this.highlightGraphic) {
                                removeGraphic(this.highlightGraphic);
                                if (destroy) {
                                    this.highlightGraphic = null;
                                    this.highlightIdTagSymbol = null;
                                }
                            }
                        };
                        HighlightedLabelGraphic.prototype.isVisible = function () {
                            if (!this.highlightGraphic) {
                                return false;
                            }
                            return this.highlightGraphic.visible
                                && (!this._config.calloutWithIdTag || this.highlightIdTagGraphic.visible)
                                && this.textGraphics.filter(function (tg) { return tg.visible; }).length > 0;
                        };
                        HighlightedLabelGraphic.prototype.show = function () {
                            if (this.highlightGraphic) {
                                this.highlightGraphic.show();
                            }
                            if (this.highlightIdTagGraphic) {
                                this.highlightIdTagGraphic.show();
                            }
                            if (this.textGraphics && this.textGraphics.length > 0) {
                                this.textGraphics.forEach(function (textGraphic) {
                                    textGraphic.show();
                                });
                            }
                            return this;
                        };
                        HighlightedLabelGraphic.prototype.hide = function () {
                            if (this.textGraphics && this.textGraphics.length > 0) {
                                this.textGraphics.forEach(function (textGraphic) {
                                    textGraphic.hide();
                                });
                            }
                            if (this.highlightIdTagGraphic) {
                                this.highlightIdTagGraphic.hide();
                            }
                            if (this.highlightGraphic) {
                                this.highlightGraphic.hide();
                            }
                            return this;
                        };
                        HighlightedLabelGraphic.prototype.update = function (mapPoint, text) {
                            if (!this.highlightGraphic || !this.textGraphics.length) {
                                return;
                            }
                            var show = this.isVisible();
                            var keyval = this._key ? this.highlightGraphic[this._key] : null;
                            this._config.text = text || "";
                            this._config.mapPoint = mapPoint && mapPoint instanceof esri.geometry.Point ? mapPoint : this._config.mapPoint;
                            this.removeFromLayer(true);
                            this._executeSetupRoutine();
                            this.addToLayer(show);
                            if (keyval) {
                                this.assignGraphicIdentifierKey(this._key, keyval);
                            }
                        };
                        HighlightedLabelGraphic.prototype.refresh = function (newLabelText) {
                            if (!this.highlightGraphic || !this.textGraphics.length) {
                                return;
                            }
                            var show = this.isVisible();
                            var keyval = this._key ? this.highlightGraphic[this._key] : null;
                            this._config.text = newLabelText || "";
                            this.removeFromLayer(true);
                            this._executeSetupRoutine();
                            this.addToLayer(show);
                            if (keyval) {
                                this.assignGraphicIdentifierKey(this._key, keyval);
                            }
                        };
                        HighlightedLabelGraphic.prototype.moveToTop = function () {
                            var highlightGraphicDojoShape = this.highlightGraphic.getDojoShape();
                            if (highlightGraphicDojoShape) {
                                highlightGraphicDojoShape.moveToFront();
                            }
                            if (this.highlightIdTagGraphic) {
                                var highlightIdTagGraphicDojoShape = this.highlightIdTagGraphic.getDojoShape();
                                if (highlightIdTagGraphicDojoShape) {
                                    highlightIdTagGraphicDojoShape.moveToFront();
                                }
                            }
                            var textGraphicDojoShape;
                            for (var textGraphicIndex = 0; textGraphicIndex < this.textGraphics.length; textGraphicIndex++) {
                                textGraphicDojoShape = this.textGraphics[textGraphicIndex].getDojoShape();
                                if (textGraphicDojoShape) {
                                    textGraphicDojoShape.moveToFront();
                                }
                            }
                        };
                        HighlightedLabelGraphic.prototype.assignGraphicIdentifierKey = function (key, value) {
                            this._key = key;
                            this.highlightGraphic[key] = value;
                            if (this.highlightIdTagGraphic) {
                                this.highlightIdTagGraphic[key] = value;
                            }
                            this.textGraphics.forEach(function (textGraphic) {
                                textGraphic[key] = value;
                            });
                        };
                        HighlightedLabelGraphic.prototype.updateIdTagText = function (newId) {
                            if (!newId) {
                                return;
                            }
                            if (this._config.calloutWithIdTag) {
                                this._config.idTagText = newId;
                                var idTextGraphic = this.textGraphics[this.textGraphics.length - 1];
                                if (idTextGraphic && idTextGraphic.symbol) {
                                    idTextGraphic.symbol.setText(newId);
                                    idTextGraphic.setSymbol(idTextGraphic.symbol);
                                }
                            }
                        };
                        HighlightedLabelGraphic.prototype.setHighlightColor = function (color) {
                            if (color && (color instanceof esri.Color) && this.highlightSymbol) {
                                this._config.highlightColor = color;
                                if (this.highlightSymbol && this.highlightGraphic) {
                                    this.highlightSymbol.setColor(color);
                                    this.highlightGraphic.setSymbol(this.highlightSymbol);
                                }
                            }
                            // The id tag text and the tag outline are the same color as the highlight color. We need to change that as well
                            if (this._config.calloutWithIdTag) {
                                var idTextGraphic = this.textGraphics[this.textGraphics.length - 1];
                                if (this.highlightIdTagSymbol && this.highlightIdTagGraphic) {
                                    this.highlightIdTagSymbol.outline.setColor(color);
                                    this.highlightIdTagGraphic.setSymbol(this.highlightIdTagSymbol);
                                }
                                if (idTextGraphic) {
                                    idTextGraphic.symbol.setColor(color);
                                    idTextGraphic.setSymbol(idTextGraphic.symbol);
                                }
                            }
                        };
                        HighlightedLabelGraphic.prototype.setTextColor = function (color) {
                            if (color && (color instanceof esri.Color)) {
                                this._config.textColor = color;
                                var len = this.textGraphics.length;
                                if (this._config.calloutWithIdTag) {
                                    if (this.highlightIdTagSymbol && this.highlightIdTagGraphic) {
                                        this.highlightIdTagSymbol.setColor(color);
                                        this.highlightIdTagGraphic.setSymbol(this.highlightIdTagSymbol);
                                    }
                                    // The last text graphic is the id tag. We dont want to change it's color.
                                    len--;
                                }
                                for (var x = 0; x < len; x++) {
                                    var textGraphic = this.textGraphics[x];
                                    if (textGraphic) {
                                        textGraphic.symbol.setColor(color);
                                        textGraphic.setSymbol(textGraphic.symbol);
                                    }
                                }
                            }
                        };
                        /**
                         * Exports the state of the label graphic, which can be used to recreate it later.
                         */
                        HighlightedLabelGraphic.prototype.exportState = function (app) {
                            var convert = app.project.convert;
                            var config = this.getConfig();
                            return {
                                highlightGraphic: convert.fromEsriGraphic(this.highlightGraphic),
                                highlightSymbol: convert.fromEsriSymbol(this.highlightSymbol),
                                textGraphics: this.textGraphics.map(function (g) { return convert.fromEsriGraphic(g); }),
                                textSymbols: this.textSymbols.map(function (s) { return convert.fromEsriSymbol(s); }),
                                layerId: config.layerId,
                                mapPoint: convert.fromEsriGeometry(this.getMapPoint()),
                                labelXoffset: config.labelXoffset,
                                labelYoffset: config.labelYoffset,
                                text: config.text,
                                fontFamily: config.fontFamily,
                                fontSize: config.fontSize,
                                cornerRadius: config.cornerRadius,
                                angle: config.angle,
                                anchor: config.anchor,
                                textColor: convert.fromEsriColor(config.textColor),
                                highlightColor: convert.fromEsriColor(config.highlightColor),
                                highlightOutlineSymbol: convert.fromEsriSymbol(config.highlightOutlineSymbol)
                            };
                        };
                        /**
                         * Creates a HighlightedLabelGraphic from exported state (see exportState()).
                         */
                        HighlightedLabelGraphic.fromExportedState = function (state, app, prototype) {
                            return Promise.try(function () {
                                if (!state || !state.highlightGraphic) {
                                    throw new Error("HighlightedLabelGraphic.fromExportedState: Invalid state.");
                                }
                                else if (!app) {
                                    throw new Error("HighlightedLabelGraphic.fromExportedState: Parameter \"app\" is required.");
                                }
                                var convert = app.project.convert;
                                var promises = {
                                    highlightGraphic: convert.toEsriGraphic(state.highlightGraphic),
                                    textGraphics: Promise.map(state.textGraphics, function (g) { return convert.toEsriGraphic(g); })
                                };
                                return Promise.props(promises).then(function (promiseResults) {
                                    var config = {
                                        layerId: state.layerId,
                                        mapPoint: convert.toEsriGeometry(state.mapPoint),
                                        text: state.text,
                                        labelXoffset: state.labelXoffset,
                                        labelYoffset: state.labelYoffset,
                                        fontFamily: state.fontFamily,
                                        fontSize: state.fontSize,
                                        cornerRadius: state.cornerRadius,
                                        angle: state.angle,
                                        anchor: state.anchor,
                                        textColor: convert.toEsriColor(state.textColor),
                                        highlightColor: convert.toEsriColor(state.highlightColor),
                                        highlightOutlineSymbol: convert.toEsriSymbol(state.highlightOutlineSymbol)
                                    };
                                    // This tells the constructor not to create new graphics and symbols, since we will be restoring existing ones shortly.
                                    config._isRestoringState = true;
                                    prototype = prototype || HighlightedLabelGraphic.prototype;
                                    var result = Object.create(prototype);
                                    result.constructor.call(result, config, app);
                                    result.initializeHighlightDimensions();
                                    result.highlightGraphic = promiseResults.highlightGraphic;
                                    result.highlightSymbol = convert.toEsriSymbol(state.highlightSymbol);
                                    result.textGraphics = promiseResults.textGraphics;
                                    result.textSymbols = state.textSymbols.map(function (s) { return convert.toEsriSymbol(s); });
                                    return result;
                                });
                            });
                        };
                        HighlightedLabelGraphic.prototype._executeSetupRoutine = function () {
                            this.initializeHighlightDimensions();
                            this.initializeHighlightGraphic();
                            this.initializeHighlighteIdTagGraphic();
                            this.initializeTextGraphicsAndSymbols();
                        };
                        HighlightedLabelGraphic.prototype.setHighlightAnchor = function () {
                            switch (this._config.anchor) {
                                case HighlightedLabelAnchor.BOTTOM_LEFT:
                                    this.highlightSymbol.setOffset(this.getTotalWidth() / 2, this.getTotalHeight() / 2);
                                    break;
                                case HighlightedLabelAnchor.CALLOUT:
                                    this.highlightSymbol.setOffset(0, (this.getTotalHeight() / 2) + (this._config.calloutPixelSize / 4));
                                    break;
                                default:
                                    this.highlightSymbol.setOffset(0, 0);
                                    break;
                            }
                            this.highlightSymbol.setOffset(this.highlightSymbol.xoffset + this._config.labelXoffset, this.highlightSymbol.yoffset + this._config.labelYoffset);
                        };
                        HighlightedLabelGraphic.prototype.setTextAnchor = function (textLineIndex, verticalOffset) {
                            switch (this._config.anchor) {
                                case HighlightedLabelAnchor.MIDDLE:
                                    this.textSymbols[textLineIndex].setOffset(0, verticalOffset);
                                    break;
                                case HighlightedLabelAnchor.BOTTOM_LEFT:
                                    this.textSymbols[textLineIndex].setOffset(this.getTotalWidth() / 2, verticalOffset + this.getTotalHeight() / 2);
                                    break;
                                case HighlightedLabelAnchor.CALLOUT:
                                    this.textSymbols[textLineIndex].setOffset(0, verticalOffset + (this.getTotalHeight() / 2) + (this._config.calloutPixelSize / 2));
                                    break;
                                default:
                                    break;
                            }
                        };
                        HighlightedLabelGraphic.prototype.initializeHighlightDimensions = function () {
                            var label = infrastructure.highlightedLabel.HighlightedLabelUtils.getLabelSize(this._config.text, this._config.fontFamily, this._config.fontSize, this._config.layerId);
                            var padding = label.height * 0.5;
                            var extraLeftSpace = this._config.calloutWithIdTag ? label.height + padding : 0;
                            this._height = label.height;
                            this._width = label.width + extraLeftSpace;
                            this._padding = padding;
                            this._config.calloutPixelSize = this._config.calloutPixelSize || Math.floor(this._width / this._calloutSizeWidthFraction);
                        };
                        HighlightedLabelGraphic.prototype.initializeHighlightGraphic = function () {
                            this.highlightGraphic = new esri.Graphic();
                            // Set a flag indicating that the text graphic is highlighted. This is needed for printing measurement markup (GVH-3346)
                            this.highlightGraphic["highlightedTextLabel"] = true;
                            this.highlightSymbol = new esri.symbol.SimpleMarkerSymbol();
                            this.highlightGraphic.setGeometry(this._config.mapPoint);
                            this.configureHighlightSymbol(this._config.highlightColor, this._config.highlightOutlineSymbol, this._config.fontSize);
                        };
                        HighlightedLabelGraphic.prototype.initializeHighlighteIdTagGraphic = function () {
                            if (this._config.calloutWithIdTag) {
                                this.highlightIdTagGraphic = new esri.Graphic();
                                this.highlightIdTagSymbol = new esri.symbol.SimpleMarkerSymbol();
                                this.highlightIdTagGraphic.setGeometry(this._config.mapPoint);
                                this.configureHighlightIdTagSymbol(this._config.textColor, this._config.fontSize);
                            }
                        };
                        HighlightedLabelGraphic.prototype.configureHighlightSymbol = function (highlightColor, highlightOutlineSymbol, fontSize) {
                            this.setHighlightAnchor();
                            this.highlightSymbol.setStyle("STYLE_PATH");
                            var svgPath = infrastructure.highlightedLabel.HighlightedLabelUtils.generateSvgHighlightLabelPath(this.getTotalWidth(), this.getTotalHeight(), this._config.cornerRadius, this._config.calloutWithIdTag, this._config.calloutPixelSize);
                            this.highlightSymbol.setPath(svgPath);
                            this.highlightSymbol.setColor(highlightColor);
                            this.highlightSymbol.setOutline(highlightOutlineSymbol);
                            this.highlightSymbol.setAngle(this._config.angle);
                            // Despite the definition file specifying number as type of the input parameter even the sample online uses a string instead
                            this.highlightSymbol.setSize(fontSize);
                            this.highlightGraphic.setSymbol(this.highlightSymbol);
                        };
                        HighlightedLabelGraphic.prototype.configureHighlightIdTagSymbol = function (highlightColor, fontSize) {
                            /*
                             * GVH-8876
                             * It is critical that this type of callout symbol has 2 SVG symbols under 3 text symbols.
                             */
                            var xOffset = -((this.getTotalWidth() / 2) - (this.getTotalHeight() / 2));
                            var yOffset = (this.getTotalHeight() / 2) + (this._config.calloutPixelSize / 2);
                            this.highlightIdTagSymbol.setStyle("STYLE_PATH");
                            this.highlightIdTagSymbol.setPath(highlightedLabel.HighlightedLabelUtils.generateSvgCirclePath((this.getTotalHeight() * this._tagHeightPercentage) / 2));
                            this.highlightIdTagSymbol.setColor(highlightColor);
                            this.highlightIdTagSymbol.outline && this.highlightIdTagSymbol.outline.setColor(highlightColor);
                            this.highlightIdTagSymbol.setOffset(xOffset + this._config.labelXoffset, yOffset + this._config.labelYoffset);
                            // Despite the definition file specifying number as type of the input parameter even the sample online uses a string instead
                            this.highlightIdTagSymbol.setSize(this.getTotalHeight() * this._tagHeightPercentage);
                            this.highlightIdTagGraphic.setSymbol(this.highlightIdTagSymbol);
                        };
                        HighlightedLabelGraphic.prototype.initializeTextGraphicsAndSymbols = function () {
                            if (!this._config.text) {
                                return;
                            }
                            var textLines = infrastructure.highlightedLabel.HighlightedLabelUtils.getTextLines(this._config.text);
                            if (!textLines || !textLines.length || textLines.length === 0) {
                                return;
                            }
                            var numberOfLines = textLines.length;
                            var font = new esri.symbol.Font();
                            font.setSize(this._config.fontSize);
                            font.setFamily(this._config.fontFamily);
                            var labelSingleLineHeight = this.getHeight() / numberOfLines;
                            var computedHeightDifference = Math.abs(font.size - labelSingleLineHeight);
                            var offsetMultiplier = (this.getHeight() / 2) / labelSingleLineHeight;
                            this.textGraphics = []; //!this.textGraphics ? [] : this.textGraphics;
                            this.textSymbols = []; //!this.textSymbols ? [] : this.textSymbols;
                            for (var textLineIndex = 0; textLines && textLines.length > 0 && textLineIndex < textLines.length; textLineIndex++) {
                                if (!this.textGraphics[textLineIndex]) {
                                    this.textGraphics[textLineIndex] = new esri.Graphic();
                                }
                                if (!this.textSymbols[textLineIndex]) {
                                    this.textSymbols[textLineIndex] = new esri.symbol.TextSymbol("");
                                }
                                //this.textSymbols[textLineIndex] = new esri.symbol.TextSymbol(""); // Is this required? Check.
                                if (this.textGraphics[textLineIndex].geometry !== this._config.mapPoint) {
                                    this.textGraphics[textLineIndex].setGeometry(this._config.mapPoint);
                                }
                                var verticalOffset = ((offsetMultiplier - (textLineIndex + 1)) * labelSingleLineHeight) + computedHeightDifference;
                                this.configureTextSymbol(textLineIndex, textLines[textLineIndex], this._config.textColor, font, this._config.angle, verticalOffset);
                                if (numberOfLines === 1) {
                                    this.textSymbols[textLineIndex].setHorizontalAlignment(esri.symbol.TextSymbol.ALIGN_MIDDLE);
                                    // this.textSymbols[textLineIndex].setVerticalAlignment(esri.symbol.TextSymbol.ALIGN_MIDDLE);
                                    // GVH-8127 Since vertical alignment is ignored by IE we have to reinvent the wheel and implement the vertical offset ourselves with some good old trigonometry:
                                    // since the text can be at an angle the offset has to be applied taking it into account -> x = h*sin(alpha) and y = h*cos(alpha) 
                                    var radiantsAngle = this._config.angle * (Math.PI / 180);
                                    this.textSymbols[textLineIndex].setOffset(-((labelSingleLineHeight / 2 / 2) * Math.sin(radiantsAngle)), -Math.abs((labelSingleLineHeight / 2 / 2) * Math.cos(radiantsAngle)));
                                    var customAttributes = {
                                        "customVerticalAlignment": "middle",
                                        "numberOfLines": 1
                                    };
                                    this.textGraphics[textLineIndex].setAttributes(customAttributes);
                                }
                                else {
                                    this.textSymbols[textLineIndex].setHorizontalAlignment(esri.symbol.TextSymbol.ALIGN_START);
                                    this.textSymbols[textLineIndex].setVerticalAlignment(esri.symbol.TextSymbol.ALIGN_START);
                                    var customAttributes = {
                                        "customVerticalAlignment": "middle",
                                        "numberOfLines": numberOfLines
                                    };
                                    this.textGraphics[textLineIndex].setAttributes(customAttributes);
                                }
                                var _addlXOffset = this._config.calloutWithIdTag ? this.getTotalHeight() / 2 : 0;
                                this.textSymbols[textLineIndex].setOffset(this.textSymbols[textLineIndex].xoffset + this._config.labelXoffset + _addlXOffset, this.textSymbols[textLineIndex].yoffset + this._config.labelYoffset);
                                this.textGraphics[textLineIndex].setSymbol(this.textSymbols[textLineIndex]);
                            }
                            if (this._config.calloutWithIdTag) {
                                var tagFont = new esri.symbol.Font();
                                tagFont.setSize(this._config.fontSize);
                                tagFont.setSize(Math.floor(tagFont.size * 1.25));
                                tagFont.setFamily(this._config.fontFamily);
                                tagFont.setWeight(esri.symbol.Font.WEIGHT_BOLD);
                                var idGraphic = new esri.Graphic();
                                idGraphic.setGeometry(this._config.mapPoint);
                                this.textGraphics.push(idGraphic);
                                var idTextSymbol = new esri.symbol.TextSymbol(this._config.idTagText);
                                this.textSymbols.push(idTextSymbol);
                                this.configureTextSymbol(numberOfLines, this._config.idTagText, this._config.highlightColor, tagFont, 0, 0);
                                var xOffset = -((this.getTotalWidth() / 2) - (this.getTotalHeight() / 2));
                                var yOffset = -(tagFont.size / 3);
                                idTextSymbol.setOffset(idTextSymbol.xoffset + xOffset, idTextSymbol.yoffset + yOffset);
                                idGraphic.setSymbol(idTextSymbol);
                            }
                        };
                        HighlightedLabelGraphic.prototype.configureTextSymbol = function (textLineIndex, lineText, textColor, font, angle, verticalOffset) {
                            if (this.textSymbols && textLineIndex < this.textSymbols.length) {
                                this.textSymbols[textLineIndex].setText(lineText);
                                this.textSymbols[textLineIndex].setFont(font);
                                this.textSymbols[textLineIndex].setColor(textColor);
                                this.textSymbols[textLineIndex].setAngle(angle);
                                this.setTextAnchor(textLineIndex, verticalOffset);
                            }
                        };
                        HighlightedLabelGraphic.prototype._processConfig = function (config) {
                            if (!config || !config.layerId || !config.mapPoint) {
                                return false;
                            }
                            config.calloutWithIdTag = config.calloutWithIdTag == undefined ? false : !!config.calloutWithIdTag;
                            config.idTagText = config.idTagText || "";
                            config.calloutPixelSize = config.calloutPixelSize || 0;
                            config.labelXoffset = config.calloutWithIdTag ? 0 : config.labelXoffset || 0;
                            config.labelYoffset = config.calloutWithIdTag ? 0 : config.labelYoffset || 0;
                            config.layerId = config.layerId;
                            config.mapPoint = config.mapPoint;
                            config.text = config.text || "";
                            config.fontFamily = config.fontFamily || "Arial";
                            config.fontSize = config.fontSize || "12px";
                            config.cornerRadius = config.cornerRadius == undefined ? 5 : config.cornerRadius;
                            config.angle = config.calloutWithIdTag ? 0 : config.angle || 0;
                            config.anchor = config.calloutWithIdTag ? HighlightedLabelAnchor.CALLOUT
                                : config.anchor != undefined ? config.anchor : HighlightedLabelAnchor.MIDDLE;
                            config.textColor = config.textColor && config.textColor instanceof esri.Color ? config.textColor : new esri.Color("white");
                            config.highlightColor = config.highlightColor && config.highlightColor instanceof esri.Color ? config.highlightColor : new esri.Color("black");
                            config.highlightOutlineSymbol = config.highlightOutlineSymbol && config.highlightOutlineSymbol instanceof esri.symbol.SimpleLineSymbol ? config.highlightOutlineSymbol : new esri.symbol.SimpleLineSymbol();
                            this._config = config;
                            return true;
                        };
                        return HighlightedLabelGraphic;
                    }());
                    highlightedLabel.HighlightedLabelGraphic = HighlightedLabelGraphic;
                })(highlightedLabel = infrastructure.highlightedLabel || (infrastructure.highlightedLabel = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var layerCatalog;
                (function (layerCatalog) {
                    /** A base class for providing custom filtering logic for a layer catalog. */
                    var LayerCatalogFilterProviderBase = (function () {
                        function LayerCatalogFilterProviderBase(app, libraryId) {
                            this.app = app;
                            this.libraryId = libraryId;
                        }
                        /**
                         * Initialize the provider.
                         * @param config The configuration object.
                         */
                        LayerCatalogFilterProviderBase.prototype.initialize = function (config) { };
                        /**
                         * Performs the search.
                         * @param text The text to filter the catalog entries on.
                         * @param entries The catalog entries to filter.
                         */
                        LayerCatalogFilterProviderBase.prototype.filter = function (text, entries) {
                            return Promise.resolve();
                        };
                        return LayerCatalogFilterProviderBase;
                    }());
                    layerCatalog.LayerCatalogFilterProviderBase = LayerCatalogFilterProviderBase;
                })(layerCatalog = infrastructure.layerCatalog || (infrastructure.layerCatalog = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var LayerIntegrationUtils;
                (function (LayerIntegrationUtils) {
                    /**
                     * Queries the provided map service URL, and returns an array of feature service URLs that were found.
                     * @param url Map service URL to interrogate for feature services.
                     * @returns The promise of an array of feature service URLs.
                     */
                    function discoverFeatureServices(url) {
                        return new Promise(function (resolve, reject) {
                            // Making a request to the provided endpoint URL.
                            esri.request({
                                url: url,
                                content: { f: "json" },
                                handleAs: "json"
                            }).then(function (response) {
                                // Handling a map service (which may contain feature services).
                                if ("layers" in response) {
                                    // Returning a whole URL for each feature layer.
                                    var featureServiceUrls = [];
                                    for (var _i = 0, _a = response.layers; _i < _a.length; _i++) {
                                        var layer = _a[_i];
                                        if (!layer.subLayerIds) {
                                            featureServiceUrls.push(url + "/" + layer.id);
                                        }
                                    }
                                    resolve(featureServiceUrls);
                                }
                                else if ("fields" in response) {
                                    resolve([url]);
                                }
                                else {
                                    reject(new Error("Unknown response type from url (" + url + ")."));
                                }
                            }, reject);
                        });
                    }
                    LayerIntegrationUtils.discoverFeatureServices = discoverFeatureServices;
                    /**
                     * Build and initialize a populated Geocortex feature layer map service based on the provided feature service URL.
                     * The returned feature layer service will come with a service layer and a single Geocortex layer.
                     * @param url The URL to the feature service endpoint.
                     * @returns The promise of a Geocortex feature layer map service.
                     */
                    function buildFeatureLayerService(serviceUrl) {
                        // Creating the Geocortex feature layer map service.
                        var mapService = new geocortex.essentials.FeatureLayerService();
                        // Configuring the map service.
                        mapService._createFrom({
                            id: geocortex.framework.utils.alphaNumericToken(),
                            displayName: geocortex.framework.utils.alphaNumericToken(),
                            serviceType: geocortex.essentials.MapServiceType.FEATURE,
                            serviceFunction: geocortex.essentials.MapServiceFunction.OPERATIONAL,
                            connectionString: serviceUrl
                        });
                        mapService.serviceUrl = serviceUrl;
                        mapService.outFields = "*";
                        // Creating the associated esri service layer.
                        mapService._createServiceLayer();
                        return new Promise(function (resolve, reject) {
                            // Waiting for the esri service layer to load.
                            mapService.serviceLayer.on("load", function (loaded) {
                                // Finish initializing the Geocortex map service.
                                mapService.displayName = mapService.serviceLayer.name;
                                // Create and initialize the Geocortex layer.
                                var gcxLayer = new geocortex.essentials.Layer();
                                gcxLayer._createFrom(mapService.serviceLayer);
                                gcxLayer.id = mapService.serviceLayer.layerId.toString();
                                gcxLayer.type = geocortex.essentials.LayerType.FEATURE_LAYER;
                                // Set the feature type of the layer (needed for resymbolization)
                                var featureLayer = mapService.serviceLayer;
                                if (featureLayer.geometryType === "esriGeometryPoint") {
                                    gcxLayer.featureType = "Point";
                                }
                                if (featureLayer.geometryType === "esriGeometryPolyline") {
                                    gcxLayer.featureType = "Line";
                                }
                                if (featureLayer.geometryType === "esriGeometryPolygon") {
                                    gcxLayer.featureType = "Polygon";
                                }
                                // Associating the Geocortex layer with its map service.
                                gcxLayer.mapService = mapService;
                                mapService.layers.push(gcxLayer);
                                // Finally returning the map service.
                                resolve(mapService);
                            });
                        });
                    }
                    LayerIntegrationUtils.buildFeatureLayerService = buildFeatureLayerService;
                    /**
                     * Build and initialize a KML map service based on the provided KML service URL.
                     * @param serviceUrl The URL to the esri KML service layer.
                     * @param serviceDefinition A map service definition object containing the properties for the new map service (optional).
                     * @returns The promise of a Geocortex KmlService.
                     */
                    function buildKmlService(serviceUrl, serviceDefinition) {
                        if (serviceDefinition === void 0) { serviceDefinition = {}; }
                        // Creating the Geocortex KML map service.
                        var mapService = new geocortex.essentials.KmlService();
                        // Configuring the map service. Allow settings in the supplied service definition to override these defaults.
                        serviceDefinition = $.extend({
                            id: geocortex.framework.utils.alphaNumericToken(),
                            serviceType: geocortex.essentials.MapServiceType.KML,
                            serviceFunction: geocortex.essentials.MapServiceFunction.OPERATIONAL,
                            serviceUrl: serviceUrl,
                            drawingBehavior: geocortex.essentials.DrawingBehavior.KML_SERVICE,
                            connectionString: serviceUrl
                        }, serviceDefinition);
                        mapService._createFrom(serviceDefinition);
                        // Creating the associated esri service layer.
                        mapService._createServiceLayer();
                        return new Promise(function (resolve, reject) {
                            // Returning the map service once the associated service layer has loaded.
                            mapService.serviceLayer.on("load", function (load) {
                                // Returning the map service.
                                resolve(mapService);
                            });
                        });
                    }
                    LayerIntegrationUtils.buildKmlService = buildKmlService;
                    /**
                     * Create a local map service from a serialized feature layer (JSON data called a 'Feature Collection').
                     * @param featureCollection An esri `FeatureCollection`, which is a serialized representation of a feature layer.
                     * @param serviceDefinition A map service definition object containing the properties for the new map service (optional).
                     * @returns A Promise of a local feature layer service that exists in a disconnected state (does not have a valid URL).
                     */
                    function buildLocalFeatureLayerService(featureCollectionObject, serviceDefinition) {
                        if (serviceDefinition === void 0) { serviceDefinition = {}; }
                        // Creating the local Geocortex feature layer map service. 
                        // Settings in the supplied service definition will override these defaults.
                        var mapService = new LocalFeatureLayerService();
                        serviceDefinition = $.extend({
                            id: geocortex.framework.utils.alphaNumericToken() + ":Local",
                            displayName: featureCollectionObject.layerDefinition.name,
                            serviceType: geocortex.essentials.MapServiceType.FEATURE,
                            serviceFunction: geocortex.essentials.MapServiceFunction.OPERATIONAL,
                            connectionString: mapService.url
                        }, serviceDefinition);
                        mapService._createFrom(serviceDefinition);
                        // Creating the local esri service layer (and attaching it to the map service).
                        var serviceLayer = mapService.serviceLayer = new LocalFeatureLayer(featureCollectionObject);
                        serviceLayer.id = mapService.id;
                        serviceLayer.layerId = 0; // Hardcoded to always be the first and only service layer.
                        serviceLayer.name = featureCollectionObject.layerDefinition.name;
                        if (serviceLayer.graphics.length) {
                            serviceLayer.fullExtent = esri.graphicsExtent(serviceLayer.graphics);
                        }
                        serviceLayer.setEditable(false);
                        // Creating the local Geocortex layer (and attaching it to the map service).
                        var gcxLayer = new LocalLayer();
                        gcxLayer._createFrom(serviceLayer);
                        gcxLayer.id = serviceLayer.layerId.toString();
                        gcxLayer.primaryKeyField = gcxLayer.getFieldByName(serviceLayer.objectIdField);
                        gcxLayer.mapService = mapService;
                        gcxLayer.searchable = true;
                        gcxLayer.type = geocortex.essentials.LayerType.FEATURE_LAYER;
                        // Set the feature type of the layer (needed for resymbolization)
                        if (featureCollectionObject.layerDefinition && featureCollectionObject.layerDefinition.geometryType) {
                            var geometryType = featureCollectionObject.layerDefinition.geometryType.toLowerCase();
                            if (geometryType.indexOf("point") > -1) {
                                gcxLayer.featureType = "Point";
                            }
                            else if (geometryType.indexOf("line") > -1) {
                                gcxLayer.featureType = "Line";
                            }
                            else if (geometryType.indexOf("polygon") > -1) {
                                gcxLayer.featureType = "Polygon";
                            }
                        }
                        // Querying is not supported at this time.
                        gcxLayer.queryable = false;
                        gcxLayer.supportsQuery = false;
                        mapService.layers.push(gcxLayer);
                        // Returning the local feature layer map service.
                        return Promise.resolve(mapService);
                    }
                    LayerIntegrationUtils.buildLocalFeatureLayerService = buildLocalFeatureLayerService;
                    /**
                     * Specialized esri feature layer that exists in a disconnected state (no URL).
                     */
                    var LocalFeatureLayer = (function (_super) {
                        __extends(LocalFeatureLayer, _super);
                        /**
                         * Create a LocalFeatureLayer from a feature layer that is serialized as a FeatureCollection.
                         * @param options: `LocalFeatureLayerConstructorOptions`.
                         */
                        function LocalFeatureLayer(featureCollectionObject) {
                            _super.call(this, featureCollectionObject, { mode: esri.layers.FeatureLayer.MODE_SNAPSHOT });
                            // We deliberately avoid setting `this.url` at all, so that the esri API knows not to query the server (it then uses local techniques instead).
                        }
                        /**
                         * Special query handling for local feature layers, overriding `queryFeatures` of the Esri API.
                         * The Esri API allows only simple extent-based queries to be performed clientside. For more complex queries (involving polygons, for example), the Esri API will query the server.
                         * Local feature layers, which exist in a disconnected state (no URL), have no associated server endpoint available to query.
                         * In order to perform queries with complex geometry on local feature layers, this method performs the query with a simplified version of the geometry (an extent) which yields false positives, which we then manually filter out by using the Esri geometry engine.
                         */
                        LocalFeatureLayer.prototype.queryFeatures = function (originalQuery, callback, errback) {
                            var query = new esri.tasks.Query();
                            if (originalQuery.hasOwnProperty("geometry")) {
                                query.geometry = (originalQuery.geometry.type !== "extent")
                                    ? originalQuery.geometry.getExtent()
                                    : originalQuery.geometry;
                            }
                            var allowedQueryProperties = ["num", "objectIds", "returnGeometry", "spatialRelationship"];
                            for (var _i = 0, allowedQueryProperties_1 = allowedQueryProperties; _i < allowedQueryProperties_1.length; _i++) {
                                var propertyName = allowedQueryProperties_1[_i];
                                query[propertyName] = originalQuery[propertyName];
                            }
                            // Performing the query with simplified geometry.
                            return _super.prototype.queryFeatures.call(this, query, callback, errback).then(function (featureSet) {
                                // Filtering false positives out of the feature set.
                                return Promise.all(featureSet.features.map(function (feature) { return infrastructure.GeometryUtils.intersects(originalQuery.geometry, feature.geometry); }))
                                    .then(function (positives) { return featureSet.features.filter(function (feature, index) { return !!positives[index]; }); })
                                    .then(function (filteredFeatures) {
                                    featureSet.features = filteredFeatures;
                                    return featureSet;
                                });
                            });
                        };
                        return LocalFeatureLayer;
                    }(esri.layers.FeatureLayer));
                    LayerIntegrationUtils.LocalFeatureLayer = LocalFeatureLayer;
                    /**
                     * Specialized Geocortex feature layer map service that exists in a disconnected state (no URL).
                     */
                    var LocalFeatureLayerService = (function (_super) {
                        __extends(LocalFeatureLayerService, _super);
                        function LocalFeatureLayerService() {
                            _super.apply(this, arguments);
                        }
                        return LocalFeatureLayerService;
                    }(geocortex.essentials.FeatureLayerService));
                    LayerIntegrationUtils.LocalFeatureLayerService = LocalFeatureLayerService;
                    /**
                     * Specialized Geocortex layer that exists in a disconnected state (no URL).
                     */
                    var LocalLayer = (function (_super) {
                        __extends(LocalLayer, _super);
                        function LocalLayer() {
                            _super.apply(this, arguments);
                        }
                        return LocalLayer;
                    }(geocortex.essentials.Layer));
                    LayerIntegrationUtils.LocalLayer = LocalLayer;
                })(LayerIntegrationUtils = infrastructure.LayerIntegrationUtils || (infrastructure.LayerIntegrationUtils = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var layerSelector;
                (function (layerSelector) {
                    var LayerSelectorViewBase = (function (_super) {
                        __extends(LayerSelectorViewBase, _super);
                        function LayerSelectorViewBase() {
                            _super.apply(this, arguments);
                        }
                        /*
                         * Activated when the user chooses to make all layers identifiable again.
                         * @param evt The MouseEvent that triggered this.
                         * @param el The HTML element that the user clicked to make this happen.
                         * @param context The LayerSelectorItem that is associated with this event.
                         */
                        LayerSelectorViewBase.prototype.selectAllLayers = function (evt, el, context) {
                            this.viewModel.layerSelector.enableAllLayers();
                        };
                        /*
                         * Activated when the user chooses to make no layers identifiable.
                         * @param evt The MouseEvent that triggered this.
                         * @param el The HTML element that the user clicked to make this happen.
                         * @param context The LayerSelectorItem that is associated with this event.
                         */
                        LayerSelectorViewBase.prototype.clearAllLayers = function (evt, el, context) {
                            this.viewModel.layerSelector.disableAllLayers();
                        };
                        LayerSelectorViewBase.prototype.handleExpanderClick = function (evt, el, context) {
                            context.isExpanded.set(!context.isExpanded.get());
                        };
                        return LayerSelectorViewBase;
                    }(geocortex.framework.ui.ViewBase));
                    layerSelector.LayerSelectorViewBase = LayerSelectorViewBase;
                })(layerSelector = infrastructure.layerSelector || (infrastructure.layerSelector = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var layerSelector;
                (function (layerSelector_1) {
                    var LayerSelectorViewModelBase = (function (_super) {
                        __extends(LayerSelectorViewModelBase, _super);
                        function LayerSelectorViewModelBase(app, libraryId) {
                            _super.call(this, app, libraryId);
                            this.selectAllButtonText = new Observable(this.app.getResource(libraryId, "language-layer-selector-default-select-all-text"));
                            this.clearAllButtonText = new Observable(this.app.getResource(libraryId, "language-layer-selector-default-clear-all-text"));
                            this.selectAllButtonTitle = new Observable(this.app.getResource(libraryId, "language-layer-selector-default-select-all-tooltip"));
                            this.clearAllButtonTitle = new Observable(this.app.getResource(libraryId, "language-layer-selector-default-clear-all-tooltip"));
                            this.items = new ObservableCollection([]);
                        }
                        LayerSelectorViewModelBase.prototype.initialize = function (config) {
                            _super.prototype.initialize.call(this, config);
                            if (this.app.map && this.app.site.isInitialized) {
                                this._setupLayerSelector();
                            }
                            else {
                                this.app.event("SiteInitializedEvent").once(this, this._setupLayerSelector);
                            }
                        };
                        /**
                         * This handler fires exactly once when the layer selector is initialized. Override this method in a sub class to define the handler.
                         */
                        LayerSelectorViewModelBase.prototype.onInitialized = function (layerSelector) {
                        };
                        /**
                         * Called when a new LayerSelectorFolderItem is created.
                         * Override this method in a sub class to define the handler.
                         * @param folderItem The item created.
                         */
                        LayerSelectorViewModelBase.prototype.onLayerSelectorFolderItemCreated = function (folderItem) {
                        };
                        /**
                         * Called when a new LayerSelectorLayerItem is created.
                         * Override this method in a sub class to define the handler.
                         * @param layerItem The item created.
                         */
                        LayerSelectorViewModelBase.prototype.onLayerSelectorLayerItemCreated = function (layerItem) {
                        };
                        /**
                         * Called when a new LayerSelectorServiceLayerItem is created.
                         * Override this method in a sub class to define the handler.
                         * @param layerItem The item created.
                         */
                        LayerSelectorViewModelBase.prototype.onLayerSelectorServiceLayerItemCreated = function (layerItem) {
                        };
                        /**
                         * The filter based on which the layers are included in the 'items' collection. Can be modified at runtime. Override this
                         * method in a sub class to define the filter.
                         */
                        LayerSelectorViewModelBase.prototype.filter = function (layerSelectorLayerItem) {
                            return true;
                        };
                        /**
                         * The handler for a layer state change event. Override this method in a sub class to define the handler.
                         */
                        LayerSelectorViewModelBase.prototype.handleLayerStateChange = function (layerSelectorLayerItem) {
                        };
                        /**
                         * The handler that is invoked when all layers are set to enabled. Override this method in a sub class to define the handler.
                         */
                        LayerSelectorViewModelBase.prototype.handleAllLayersEnabled = function () {
                        };
                        /**
                         * The handler that is invoked when all layers are disabled. Override this method in a sub class to define the handler.
                         */
                        LayerSelectorViewModelBase.prototype.handleAllLayersDisabled = function () {
                        };
                        /**
                         * Recursively walks the tree of items and returns a flat array of all items.
                         * @returns all LayerSelectorItems of any depth.
                         */
                        LayerSelectorViewModelBase.prototype.getAllItems = function () {
                            return LayerSelectorViewModelBase._expandItems(this.items.get());
                        };
                        /**
                         * Recursively walks the tree of the given items and returns a flat array of all items.
                         * @returns all LayerSelectorItems of any depth.
                         */
                        LayerSelectorViewModelBase._expandItems = function (items) {
                            return items.concat.apply(items, items.map(function (item) { return LayerSelectorViewModelBase._expandItems(item.items.get()); }));
                        };
                        LayerSelectorViewModelBase.prototype._setupLayerSelector = function () {
                            var _this = this;
                            this.appInfo = infrastructure.gis.AppInfo.fromGeocortexApp(this.app);
                            var layerSelectorOptions = {
                                onInitializedHandler: function (layerSelector) { return _this.onInitialized(layerSelector); },
                                layerFilter: function (layerSelectorItem) { return _this.filter(layerSelectorItem); },
                                layerStateChangeHandler: function (layerSelectorItem) { return _this.handleLayerStateChange(layerSelectorItem); },
                                enableAllLayersHandler: function () { return _this.handleAllLayersEnabled(); },
                                disableAllLayersHandler: function () { return _this.handleAllLayersDisabled(); },
                                onLayerSelectorFolderItemCreated: function (item) { return _this.onLayerSelectorFolderItemCreated(item); },
                                onLayerSelectorLayerItemCreated: function (item) { return _this.onLayerSelectorLayerItemCreated(item); },
                                onLayerSelectorServiceLayerItemCreated: function (item) { return _this.onLayerSelectorServiceLayerItemCreated(item); }
                            };
                            this.layerSelector = new layerSelector.LayerSelector(this.appInfo, layerSelectorOptions);
                            this._subscribeEvents();
                            this.items.sync(this.layerSelector.items);
                            this.items.pulse();
                        };
                        LayerSelectorViewModelBase.prototype._subscribeEvents = function () {
                            this.app.event("MapServiceAddedEvent").subscribe(this, this._handleMapServicesAdded);
                            this.app.event("MapServiceRemovedEvent").subscribe(this, this._handleMapServiceRemoved);
                            // GVH-7336 Handle layers that are dynamically added or removed from the map
                            this.app.event("MapServiceLayersChangedWithResultEvent").subscribe(this, this._handleMapServiceLayersChanged);
                        };
                        LayerSelectorViewModelBase.prototype._handleMapServicesAdded = function (ms) {
                            this.layerSelector.addUserAddedServiceLayer(ms);
                        };
                        LayerSelectorViewModelBase.prototype._handleMapServiceRemoved = function (ms) {
                            this.layerSelector.removeServiceLayer(ms);
                        };
                        LayerSelectorViewModelBase.prototype._handleMapServiceLayersChanged = function (args) {
                            if (args) {
                                this.layerSelector.updateServiceLayer(args.mapService, args.newItems, args.oldItems);
                            }
                        };
                        return LayerSelectorViewModelBase;
                    }(geocortex.framework.ui.ViewModelBase));
                    layerSelector_1.LayerSelectorViewModelBase = LayerSelectorViewModelBase;
                })(layerSelector = infrastructure.layerSelector || (infrastructure.layerSelector = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var nativeIntegration;
                (function (nativeIntegration) {
                    /**
                     * Communication channel for sending messages to GMAF. Includes handling of long running jobs, progress reporting, and cancellation.
                     * @private
                     */
                    var MessageClient = (function () {
                        function MessageClient(app) {
                            this.app = app;
                        }
                        /**
                         * Sends a message to GMAF and returns a Promise that will be resolved when the operation is complete.
                         * Operations can be short running (if there is no cancellation token) or long running (if there is a cancellation token).
                         */
                        MessageClient.prototype.message = function (messageType, payload, cancellationToken, progress) {
                            var _this = this;
                            return new Promise(function (resolve, reject) {
                                if (!_this.app.nativeManager.isNative()) {
                                    reject(new Error("Method not supported in browser."));
                                    return;
                                }
                                var jobId;
                                // Cancellation may be requested in the future
                                if (cancellationToken) {
                                    cancellationToken.register(function () {
                                        _this.cancel(jobId);
                                    });
                                }
                                // Progress handler
                                var nativeEventSubscription;
                                if (progress) {
                                    nativeEventSubscription = _this.app.event("NativeMessageEvent").subscribe(_this, function (message) {
                                        if (message.type === "JobProgress" && message.parameters.jobId === jobId) {
                                            if (message.parameters.status === "inProgress") {
                                                // Progress
                                                progress(message.parameters);
                                            }
                                            else if (message.parameters.status === "complete") {
                                                // Done
                                                resolve(message.parameters.details);
                                                _this.app.event("NativeMessageEvent").unsubscribe(nativeEventSubscription);
                                            }
                                            else if (message.parameters.status === "canceled") {
                                                // Error
                                                var error = new Error(message.parameters.details.message);
                                                error.name = "OperationCanceled";
                                                reject(error);
                                                _this.app.event("NativeMessageEvent").unsubscribe(nativeEventSubscription);
                                            }
                                            else if (message.parameters.status === "error") {
                                                // Error
                                                reject(new Error(message.parameters.details.message));
                                                _this.app.event("NativeMessageEvent").unsubscribe(nativeEventSubscription);
                                            }
                                        }
                                    });
                                }
                                // Send message
                                _this.app.nativeManager.onNativeInitialized().then(function () {
                                    return _this.app.nativeManager.xhrPost({
                                        url: _this.app.localServerAddress + "/message/" + messageType,
                                        postData: JSON.stringify(payload),
                                        method: "POST"
                                    });
                                }).then(function (responseData) {
                                    var jsonObj = JSON.parse(responseData);
                                    jobId = jsonObj.jobId;
                                    // Cancellation may have been requested already
                                    if (cancellationToken && cancellationToken.isCancellationRequested) {
                                        _this.cancel(jobId);
                                    }
                                    else if (jobId) {
                                        // Complete client handshake - let the server know that we're listening to progress messages.
                                        // The server will not procede with handling the message until this handshake is completed.
                                        _this.app.nativeManager.xhrPost({
                                            url: _this.app.localServerAddress + "/message/JobHandshake",
                                            postData: JSON.stringify({
                                                jobId: jobId
                                            }),
                                            method: "POST"
                                        });
                                    }
                                    else {
                                        resolve(jsonObj.result);
                                    }
                                }).catch(function (error) {
                                    try {
                                        var json = JSON.parse(error.response.data);
                                        reject(new Error(json.error.message));
                                    }
                                    catch (exception) {
                                        reject(error);
                                    }
                                });
                            });
                        };
                        MessageClient.prototype.cancel = function (jobId) {
                            if (jobId) {
                                return this.app.nativeManager.xhrPost({
                                    url: this.app.localServerAddress + "/message/CancelJob",
                                    postData: JSON.stringify({
                                        jobId: jobId
                                    }),
                                    method: "POST"
                                });
                            }
                        };
                        return MessageClient;
                    }());
                    nativeIntegration.MessageClient = MessageClient;
                })(nativeIntegration = infrastructure.nativeIntegration || (infrastructure.nativeIntegration = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var offline;
                (function (offline) {
                    /**
                     * @private
                     */
                    function formatByteTransferRateString(app, bSec) {
                        var kbSec = bSec / 1024;
                        if (kbSec < 1) {
                            return app.getResource("Mapping.Infrastructure", "language-offline-progress-bytes-per-second").format(Math.round(bSec));
                        }
                        var mbSec = bSec / 1048576; // 1024 * 1024
                        if (mbSec < 1) {
                            return app.getResource("Mapping.Infrastructure", "language-offline-progress-kilobytes-per-second").format(Math.round(kbSec));
                        }
                        return app.getResource("Mapping.Infrastructure", "language-offline-progress-megabytes-per-second").format(Math.round(mbSec * 10) / 10);
                    }
                    offline.formatByteTransferRateString = formatByteTransferRateString;
                    /**
                     * @private
                     */
                    function formatBytesString(app, bytes) {
                        var kb = bytes / 1024;
                        if (kb < 1) {
                            return app.getResource("Mapping.Infrastructure", "language-offline-progress-bytes").format(bytes);
                        }
                        var mb = bytes / 1048576; // 1024 * 1024
                        if (mb < 1) {
                            return app.getResource("Mapping.Infrastructure", "language-offline-progress-kilobytes").format(Math.round(kb));
                        }
                        var gb = bytes / 1073741824; // 1024 * 1024 * 1024
                        if (gb < 1) {
                            return app.getResource("Mapping.Infrastructure", "language-offline-progress-megabytes").format(Math.round(mb));
                        }
                        return app.getResource("Mapping.Infrastructure", "language-offline-progress-gigabytes").format(Math.round(gb * 100) / 100);
                    }
                    offline.formatBytesString = formatBytesString;
                })(offline = infrastructure.offline || (infrastructure.offline = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var project;
                (function (project) {
                    /**
                     * Provides a set of filters for use with {@link: ObjectFilter.filter} corresponding to common project interfaces.
                     */
                    var ProjectFilter = (function () {
                        function ProjectFilter(app) {
                            var _this = this;
                            this._numberValidator = new infrastructure.validation.NumberValidator();
                            this._xssHtmlValidator = new infrastructure.validation.XssHtmlValidator();
                            /**
                             * A generic filter for objects whose schema is unknown.
                             */
                            this.object = function (object) {
                                // TODO: if (typeof object === "string") { XSS Filter }
                                if (!object || typeof object !== "object") {
                                    return true;
                                }
                                // Look for well-known project types that have been tagged with a conversion type.
                                switch (object[infrastructure.webMap.CONVERSION_TYPE_PROPERTY]) {
                                    case infrastructure.webMap.ConversionType.GCX_MAP_SERVICE:
                                    case infrastructure.webMap.ConversionType.ESRI_LAYER:
                                        return function () { return _this.serviceLayer; };
                                    case infrastructure.webMap.ConversionType.GCX_LAYER:
                                        return function () { return _this.layer; };
                                    case infrastructure.webMap.ConversionType.GCX_FEATURE_SET:
                                    case infrastructure.webMap.ConversionType.ESRI_FEATURE_SET:
                                        return function () { return _this.featureSet; };
                                    case infrastructure.webMap.ConversionType.GCX_FEATURE:
                                    case infrastructure.webMap.ConversionType.ESRI_GRAPHIC:
                                        return function () { return _this.feature; };
                                    case infrastructure.webMap.ConversionType.ESRI_GEOMETRY:
                                        return _this.geometry;
                                    case infrastructure.webMap.ConversionType.ESRI_SYMBOL:
                                        return _this.symbol;
                                    case infrastructure.webMap.ConversionType.ESRI_RENDERER:
                                        return _this.renderer;
                                    case infrastructure.webMap.ConversionType.ESRI_SPATIAL_REFERENCE:
                                        return _this.spatialReference;
                                }
                                // Recursively filter each property.
                                var filter = {};
                                for (var _i = 0, _a = Object.keys(object); _i < _a.length; _i++) {
                                    var key = _a[_i];
                                    filter[key] = _this.object;
                                }
                                return filter;
                            };
                            this.app = app;
                            this._urlValidator = new infrastructure.validation.SiteUrlValidator(app);
                            this._webMapFilter = new infrastructure.webMap.WebMapFilter(app);
                            this._xssHtmlValidator = new infrastructure.validation.XssHtmlValidator(app.defaultContentPolicy);
                        }
                        Object.defineProperty(ProjectFilter.prototype, "baseMap", {
                            get: function () {
                                return this._webMapFilter.baseMap;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "baseMapLayer", {
                            get: function () {
                                if (!this._baseMapLayer) {
                                    this._baseMapLayer = $.extend({}, this._webMapFilter.baseMapLayer, this._serviceLayerCommon);
                                }
                                return this._baseMapLayer;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "bookmark", {
                            get: function () {
                                return this._webMapFilter.bookmark;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "color", {
                            get: function () {
                                return this._webMapFilter.color;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "coordinateSystem", {
                            get: function () {
                                if (!this._coordinateSystem) {
                                    this._coordinateSystem = {
                                        wkid: this._numberValidator,
                                        wkt: true,
                                        output: true
                                    };
                                }
                                return this._coordinateSystem;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "domain", {
                            get: function () {
                                return this._webMapFilter.domain;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "inheritedDomain", {
                            get: function () {
                                return this._webMapFilter.inheritedDomain;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "rangeDomain", {
                            get: function () {
                                return this._webMapFilter.rangeDomain;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "codedValueDomain", {
                            get: function () {
                                return this._webMapFilter.codedValueDomain;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "drawingInfo", {
                            get: function () {
                                if (!this._drawingInfo) {
                                    this._drawingInfo = $.extend({}, this._webMapFilter.drawingInfo, {
                                        showLabels: true,
                                        clustering: {
                                            radius: this._numberValidator,
                                            backgroundColor: this.color,
                                            labelColor: this.color,
                                            maximumFeatures: this._numberValidator,
                                            enabled: true
                                        },
                                        labelingInfo: {
                                            item: {
                                                fieldInfos: {
                                                    item: this.object
                                                },
                                                labelExpression: true,
                                                labelExpressionInfo: this.object,
                                                labelPlacement: true,
                                                maxScale: this._numberValidator,
                                                minScale: this._numberValidator,
                                                sizeInfo: this.object,
                                                symbol: {
                                                    align: true,
                                                    angle: this._numberValidator,
                                                    color: {
                                                        a: this._numberValidator,
                                                        b: this._numberValidator,
                                                        g: this._numberValidator,
                                                        r: this._numberValidator
                                                    },
                                                    decoration: true,
                                                    font: {
                                                        decoration: true,
                                                        family: true,
                                                        size: this._numberValidator,
                                                        style: true,
                                                        variant: true,
                                                        weight: true
                                                    },
                                                    haloColor: {
                                                        a: this._numberValidator,
                                                        b: this._numberValidator,
                                                        g: this._numberValidator,
                                                        r: this._numberValidator
                                                    },
                                                    haloSize: true,
                                                    horizontalAlignment: true,
                                                    kerning: true,
                                                    rotated: true,
                                                    text: true,
                                                    type: true,
                                                    verticalAlignment: true,
                                                    xoffset: this._numberValidator,
                                                    yoffset: this._numberValidator
                                                },
                                                useCodedValues: true,
                                                where: true
                                            }
                                        }
                                    });
                                }
                                return this._drawingInfo;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "feature", {
                            get: function () {
                                var _this = this;
                                if (!this._feature) {
                                    this._feature = $.extend({}, this._webMapFilter.feature, {
                                        id: true,
                                        layer: function () { return _this.layer; },
                                        featureLayer: function () { return _this.serviceLayer; },
                                        featureSet: function () { return _this.featureSet; },
                                        allowUnsafeContent: true,
                                        extendedProperties: this.object,
                                        defaultNumberFormat: this._xssHtmlValidator,
                                        defaultDateFormat: this._xssHtmlValidator,
                                        timeZoneId: true,
                                        displayTimeZoneId: true,
                                        borderColor: this.color,
                                        fillColor: this.color,
                                        borderWidth: true,
                                        attributes: this.object
                                    });
                                    // These aren't declared in the interface, but they need to be preserved if found.
                                    this._feature[project.PROPERTY_MEASUREMENT_ID] = true;
                                    this._feature[project.PROPERTY_HIGHLIGHT_ID] = true;
                                    this._feature[mapping.infrastructure.isKmlProperty] = true;
                                }
                                return this._feature;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "featureCollection", {
                            get: function () {
                                if (!this._featureCollection) {
                                    this._featureCollection = $.extend({}, this._webMapFilter.featureCollection, {
                                        layers: {
                                            item: this.layer
                                        }
                                    });
                                }
                                return this._featureCollection;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "featureSet", {
                            get: function () {
                                var _this = this;
                                if (!this._featureSet) {
                                    this._featureSet = $.extend({}, this._webMapFilter.featureSet, {
                                        id: true,
                                        features: {
                                            item: function () { return _this.feature; }
                                        },
                                        allowUnsafeContent: true,
                                        extendedProperties: this.object,
                                        layer: function () { return _this.layer; },
                                        displayName: this._xssHtmlValidator,
                                        iconUri: this._urlValidator
                                    });
                                }
                                return this._featureSet;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "featureSetCollection", {
                            get: function () {
                                var _this = this;
                                if (!this._featureSetCollection) {
                                    this._featureSetCollection = {
                                        id: true,
                                        displayName: this._xssHtmlValidator,
                                        featureSets: {
                                            item: function () { return _this.featureSet; }
                                        },
                                        sourceName: true,
                                        tag: this.object,
                                        extendedProperties: this.object
                                    };
                                }
                                return this._featureSetCollection;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "field", {
                            get: function () {
                                return this._webMapFilter.field;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "geometry", {
                            get: function () {
                                return this._webMapFilter.geometry;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "graphic", {
                            get: function () {
                                if (!this._graphic) {
                                    this._graphic = $.extend({}, this._webMapFilter.feature);
                                    // These aren't declared in the interface, but they need to be preserved if found.
                                    this._graphic[project.PROPERTY_MEASUREMENT_ID] = true;
                                    this._graphic[project.PROPERTY_HIGHLIGHT_ID] = true;
                                    this._graphic[mapping.infrastructure.isKmlProperty] = true;
                                }
                                return this._graphic;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "point", {
                            get: function () {
                                return this._webMapFilter.point;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "multiPoint", {
                            get: function () {
                                return this._webMapFilter.multiPoint;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "polyline", {
                            get: function () {
                                return this._webMapFilter.polyline;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "polygon", {
                            get: function () {
                                return this._webMapFilter.polygon;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "extent", {
                            get: function () {
                                return this._webMapFilter.extent;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "layer", {
                            get: function () {
                                var _this = this;
                                if (!this._layer) {
                                    this._layer = $.extend({}, this._webMapFilter.layer, {
                                        serviceLayer: function () { return _this.serviceLayer; },
                                        layerDefinition: this.layerDefinition,
                                        featureSet: function () { return _this.featureSet; },
                                        isDynamic: true,
                                        layerStyleId: true,
                                        gcxLayerDefinition: {
                                            id: true,
                                            name: this._xssHtmlValidator,
                                            url: this._urlValidator,
                                            defaultVisibility: true,
                                            visible: true,
                                            displayName: this._xssHtmlValidator,
                                            description: true,
                                            featureType: true,
                                            featureZoomScale: true,
                                            featureZoomFactor: true,
                                            hasAttachments: true,
                                            nativeID: true,
                                            parentLayerId: true,
                                            subLayerIds: true,
                                            styleName: true,
                                            legendUrl: this._urlValidator,
                                            isDynamic: true,
                                            dynamicDefinition: true,
                                            defaultDateFormat: true,
                                            defaultNumberFormat: true,
                                            fullExtent: true,
                                            drawIndex: true,
                                            identifiable: true,
                                            includeInLayerList: true,
                                            includeInLegend: true,
                                            featureBorderColor: true,
                                            featureBorderWidth: true,
                                            featureFillColor: true,
                                            minScale: this._numberValidator,
                                            maxScale: this._numberValidator,
                                            queryable: true,
                                            searchable: true,
                                            snappable: true,
                                            snappingEnabled: true,
                                            showFeatureHyperlinks: true,
                                            canToggleLabels: true,
                                            showLabels: true,
                                            showMapTips: true,
                                            supportsIdentify: true,
                                            supportsQuery: true,
                                            type: true,
                                            fields: true,
                                            primaryKeyField: true,
                                            displayField: true,
                                            catalogId: this.object,
                                            // These either pose a known security risk, or are simply irrelevant for projects. Note that anything 
                                            // not appearing in this filter is implicitly disallowed anyway; these are just added here for clarity.
                                            featureDescription: false,
                                            featureLongDescription: false,
                                            featureLabel: false,
                                            featureHyperlinks: false,
                                            layerHyperlinks: false,
                                            relationships: false,
                                            dataLinks: false,
                                            reports: false,
                                            charts: false
                                        }
                                    });
                                }
                                return this._layer;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "layerDefinition", {
                            get: function () {
                                if (!this._layerDefinition) {
                                    this._layerDefinition = $.extend({}, this._webMapFilter.layerDefinition, {
                                        drawingInfo: this.drawingInfo
                                    });
                                }
                                return this._layerDefinition;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "operationalLayer", {
                            get: function () {
                                var _this = this;
                                if (!this._operationalLayer) {
                                    this._operationalLayer = $.extend({}, this._webMapFilter.operationalLayer, this._serviceLayerCommon, {
                                        layers: {
                                            item: function () { return _this.layer; }
                                        },
                                        featureCollection: this.featureCollection,
                                        layerDefinition: this.layerDefinition
                                    });
                                }
                                return this._operationalLayer;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "renderer", {
                            get: function () {
                                return this._webMapFilter.renderer;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "serviceLayer", {
                            get: function () {
                                if (!this._serviceLayer) {
                                    this._serviceLayer = $.extend({}, this.operationalLayer, this.baseMapLayer);
                                }
                                return this._serviceLayer;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "simpleRenderer", {
                            get: function () {
                                return this._webMapFilter.simpleRenderer;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "uniqueValueRenderer", {
                            get: function () {
                                return this._webMapFilter.uniqueValueRenderer;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "classBreaksRenderer", {
                            get: function () {
                                return this._webMapFilter.classBreaksRenderer;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "heatmapRenderer", {
                            get: function () {
                                return this._webMapFilter.heatmapRenderer;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "spatialReference", {
                            get: function () {
                                return this._webMapFilter.spatialReference;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "symbol", {
                            get: function () {
                                return this._webMapFilter.symbol;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "simpleMarkerSymbol", {
                            get: function () {
                                return this._webMapFilter.simpleMarkerSymbol;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "simpleLineSymbol", {
                            get: function () {
                                return this._webMapFilter.simpleLineSymbol;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "simpleFillSymbol", {
                            get: function () {
                                return this._webMapFilter.simpleFillSymbol;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "pictureMarkerSymbol", {
                            get: function () {
                                return this._webMapFilter.pictureMarkerSymbol;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "pictureFillSymbol", {
                            get: function () {
                                return this._webMapFilter.pictureFillSymbol;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "textSymbol", {
                            get: function () {
                                return this._webMapFilter.textSymbol;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "template", {
                            get: function () {
                                return this._webMapFilter.template;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "type", {
                            get: function () {
                                return this._webMapFilter.type;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(ProjectFilter.prototype, "_serviceLayerCommon", {
                            get: function () {
                                var _this = this;
                                return {
                                    layers: {
                                        item: function () { return _this.layer; }
                                    },
                                    gcxMapServiceDefinition: {
                                        id: true,
                                        url: this._urlValidator,
                                        serviceUrl: this._urlValidator,
                                        serviceType: true,
                                        serviceFunction: true,
                                        displayName: this._xssHtmlValidator,
                                        shortDisplayName: true,
                                        baseMapGroup: true,
                                        baseMapGroupIndex: true,
                                        baseMapGroupIsMutuallyExclusive: true,
                                        description: true,
                                        copyright: true,
                                        hasAttributionData: true,
                                        visible: true,
                                        disableClientCaching: true,
                                        opacity: this._numberValidator,
                                        instantSearch: true,
                                        format: true,
                                        isExpanded: true,
                                        serverVersion: true,
                                        failureAction: true,
                                        tileMatrixSet: true,
                                        requestEncoding: true,
                                        operationalSpatialReference: true,
                                        minScale: this._numberValidator,
                                        maxScale: this._numberValidator,
                                        identifiable: true,
                                        includeCatalogItems: true,
                                        includeMosaicDatasetValues: true,
                                        defaultDateFormat: true,
                                        defaultNumberFormat: true,
                                        tileInfo: true,
                                        includeInLayerList: true,
                                        drawingBehavior: true,
                                        featureClustering: {
                                            enabled: true,
                                            userCanToggle: true,
                                            radius: this._numberValidator,
                                            maximumFeatures: this._numberValidator,
                                            backgroundColor: this.color,
                                            labelColor: this.color
                                        },
                                        featureHeatMap: {
                                            enabled: true,
                                            userCanToggle: true,
                                            respectScaleRange: true,
                                            gradient: true,
                                            offset: {
                                                item: this._numberValidator
                                            },
                                            intensity: this._numberValidator,
                                            field: true,
                                            defaultRenderer: this.renderer,
                                            defaultMinScale: this._numberValidator,
                                            defaultMaxScale: this._numberValidator,
                                            includeInLegend: true
                                        },
                                        catalogId: this.object,
                                        // These either pose a known security risk, or are simply irrelevant for projects. Note that anything 
                                        // not appearing in this filter is implicitly disallowed anyway; these are just added here for clarity.
                                        layerOptions: false,
                                        layerHyperlinks: false,
                                        attributionDataUrl: false
                                    }
                                };
                            },
                            enumerable: true,
                            configurable: true
                        });
                        return ProjectFilter;
                    }());
                    project.ProjectFilter = ProjectFilter;
                })(project = infrastructure.project || (infrastructure.project = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../_Definitions/framework.d.ts"/>
/// <reference path="../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../_Definitions/dojo.d.ts"/>
/**
 * Viewer Shell (Desktop, Tablet, Handheld) Utilities.
 */
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ShellUtils;
                (function (ShellUtils) {
                    /**
                     * Debounces a given function and runs it once all view related events have settled for a specified timeout (defaults to 400ms). This function cannot guarantee deterministic results and we don't recommend
                     * you use it unless absolutely necessary. There may be points of failure introduced if, for instance, a large number of modules use it and activate views of their own. This may lead to unintended
                     * behavior.
                     * @param app The {@link ViewerApplication} invoking this function.
                     * @param delegate The function to execute after debouncing.
                     * @param settleThreshold Optional parameter that can be used to set the settle threshold. Defaults to 400ms.
                     */
                    function debounceViewEvents(app, delegate, settleThresholdMs) {
                        if (settleThresholdMs === void 0) { settleThresholdMs = 400; }
                        var targetEvents = ["ViewInitializedEvent", "ViewActivatedEvent", "ViewDeactivatedEvent", "ViewDimensionsChangedEvent", "ViewHostedEvent", "ViewUnhostedEvent", "ApplicationResizeEvent"];
                        debounceEvents(app, delegate, targetEvents, settleThresholdMs);
                    }
                    ShellUtils.debounceViewEvents = debounceViewEvents;
                    /**
                     * Debounces a given function and runs it once all target events have settled for a specified timeout (defaults to 200ms). This function cannot guarantee deterministic results and we don't recommend
                     * you use it unless absolutely necessary.
                     * @param app The {@link ViewerApplication} invoking this function.
                     * @param delegate The function to execute after debouncing.
                     * @param targetEvents The list of events that will cause the given delegate to get debounced.
                     * @param settleThreshold Optional parameter that can be used to set the settle threshold. Defaults to 400ms.
                     */
                    function debounceEvents(app, delegate, targetEvents, settleThresholdMs) {
                        var _this = this;
                        if (settleThresholdMs === void 0) { settleThresholdMs = 200; }
                        var setTimeoutToken = -1;
                        var eventSubscriptionInfo = [];
                        var cancelEventSubscriptions = function () {
                            for (var x = eventSubscriptionInfo.length - 1; x >= 0; x--) {
                                var subInfo = eventSubscriptionInfo[x];
                                app.event(subInfo.eventName).unsubscribe(subInfo.subscriptionToken);
                                eventSubscriptionInfo.pop();
                            }
                        };
                        var executeDelegateAfterThreshold = function () {
                            setTimeoutToken = setTimeout(function () {
                                setTimeoutToken = null;
                                cancelEventSubscriptions();
                                delegate();
                            }, settleThresholdMs);
                        };
                        targetEvents.forEach(function (eventName) {
                            var tok = app.event(eventName).subscribe(_this, function () {
                                if (setTimeoutToken === null) {
                                    return;
                                }
                                clearTimeout(setTimeoutToken);
                                executeDelegateAfterThreshold();
                            });
                            eventSubscriptionInfo.push({
                                "eventName": eventName,
                                "subscriptionToken": tok
                            });
                        });
                        executeDelegateAfterThreshold();
                    }
                    ShellUtils.debounceEvents = debounceEvents;
                })(ShellUtils = infrastructure.ShellUtils || (infrastructure.ShellUtils = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/rx.lite.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var nativeIntegration;
                (function (nativeIntegration) {
                    var NativeManager = (function () {
                        function NativeManager(app) {
                            this.app = app;
                            /**
                             * Indicates whether native is initialized.  For a check with an asynchronous
                             * callback use onNativeInitialized().
                             */
                            this.nativeInitialized = false;
                            this._messageClient = new nativeIntegration.MessageClient(app);
                        }
                        NativeManager.prototype.isNative = function () {
                            return /\bGeocortexApp\b/.test(navigator.userAgent);
                        };
                        NativeManager.prototype.xhrGet = function (dojoArgs) {
                            var _this = this;
                            return this.onNativeInitialized().then(function () {
                                _this.appendAuthorizationHeader(dojoArgs);
                                return dojo.xhrGet(dojoArgs);
                            });
                        };
                        NativeManager.prototype.xhrPost = function (dojoArgs) {
                            var _this = this;
                            return this.onNativeInitialized().then(function () {
                                _this.appendAuthorizationHeader(dojoArgs);
                                return dojo.xhrPost(dojoArgs);
                            });
                        };
                        NativeManager.prototype.appendAuthorizationHeader = function (dojoArgs) {
                            if (!dojoArgs) {
                                dojoArgs = {};
                            }
                            if (!dojoArgs.headers) {
                                dojoArgs.headers = {};
                            }
                            if (!dojoArgs.headers.Authorization) {
                                dojoArgs.headers.Authorization = "Token " + this.app.localServerToken;
                            }
                        };
                        /**
                         * Sends a message to GMAF and returns a Promise that will be resolved when the operation is complete.
                         * Operations can be short running (if there is no cancellation token) or long running (if there is a cancellation token).
                         */
                        NativeManager.prototype.message = function (messageType, body, cancellationToken, progress) {
                            return this._messageClient.message(messageType, body, cancellationToken, progress);
                        };
                        /**
                         * Gets a promise that will be resolved when the "native ready" message has been received from the native
                         * layer, which indicates that the native infrastructure has been initialized.
                         */
                        NativeManager.prototype.onNativeInitialized = function () {
                            var _this = this;
                            if (this._nativeInitializedPromise) {
                                return this._nativeInitializedPromise;
                            }
                            this._nativeInitializedPromise = new Promise(function (resolve, reject) {
                                _this._nativeInitializedResolve = resolve;
                            });
                            return this._nativeInitializedPromise;
                        };
                        /**
                         * To be called once by the module that handles the native initialize to indicate that native initialization
                         * is complete. Causes the promise returned by onNativeInitialized() to be resolved.
                         */
                        NativeManager.prototype.signalNativeInitialized = function () {
                            this.onNativeInitialized(); // Make sure promise is created
                            this.nativeInitialized = true;
                            this._nativeInitializedResolve();
                        };
                        /**
                         * Gets the resource info for a viewer resource.
                         * @param fileName The name of the file on the server to get the resource info for.
                         */
                        NativeManager.prototype.getViewerResourceInfo = function (fileName) {
                            var url = this.app.localServerAddress + "/resource/" + this.app.localServerNamespace + "/" + fileName + "/info";
                            return this.xhrGet({ url: url }).then(function (responseTxt) {
                                var response = JSON.parse(responseTxt);
                                return {
                                    name: response.name,
                                    exists: response.exists,
                                    length: response.length,
                                    lastAccessTime: response.lastAccessTime ? new Date(response.lastAccessTime) : null,
                                    lastWriteTime: response.lastWriteTime ? new Date(response.lastWriteTime) : null
                                };
                            });
                        };
                        /**
                         * Tests to see if the app has a certain native capability. Example "editing".
                         */
                        NativeManager.prototype.hasNativeCapability = function (capability) {
                            var _this = this;
                            return new Promise(function (resolve, reject) {
                                // We haven't grabbed the capabilities yet, so we will want to grab them, and store them for future use
                                if (!_this._capabilities) {
                                    // If we're native, we can check our devices capabilities
                                    if (/\bGeocortexApp\b/.test(navigator.userAgent)) {
                                        // Ask the native app for it's current capabilities (in json form)
                                        geocortex.GeocortexNativeApp.capabilities(function (nativeCaps) {
                                            // Store them for future use
                                            _this._capabilities = nativeCaps;
                                            // And let the caller know if we have that capability.
                                            resolve(_this._capabilities.indexOf(capability) > -1);
                                        }, function (error) {
                                            resolve(false);
                                        });
                                    }
                                    else {
                                        resolve(false);
                                    }
                                }
                                else {
                                    // We already have the capabilities stored, so we can just reuse them
                                    resolve(_this._capabilities.indexOf(capability) > -1);
                                }
                            });
                        };
                        return NativeManager;
                    }());
                    nativeIntegration.NativeManager = NativeManager;
                })(nativeIntegration = infrastructure.nativeIntegration || (infrastructure.nativeIntegration = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var offline;
                (function (offline) {
                    /**
                     * Delete basemaps from the device.  Takes an OfflineMapBasemap array instead of an OfflineMap because
                     * the geometry isn't needed and it makes sense to delete a subset of the basemaps.
                     * @param app
                     * @param basemaps
                     * @param cancellationToken
                     * @param progress
                     */
                    function deleteBasemaps(app, basemaps) {
                        // Delete all basemaps at once.
                        return Promise.all(basemaps.map(function (basemap) { return deleteBasemap(app, basemap); }))
                            .then(function () { return null; });
                    }
                    offline.deleteBasemaps = deleteBasemaps;
                    function deleteBasemap(app, basemap) {
                        if (!basemap) {
                            return Promise.reject("basemap cannot be null.");
                        }
                        if (!basemap.filename) {
                            return Promise.reject("basemap.filename cannot be null.");
                        }
                        switch (basemap.sourceType) {
                            case offline.OfflineMapBasemap.Type.PREGENERATED:
                                return app.nativeManager.message("RemoveResource", { fileName: basemap.filename });
                            case offline.OfflineMapBasemap.Type.EXPORT_TILES:
                                return app.nativeManager.message("RemoveExportedTiles", { fileName: basemap.filename });
                        }
                        return null;
                    }
                })(offline = infrastructure.offline || (infrastructure.offline = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var offline;
                (function (offline) {
                    /**
                     * Downloads all OfflineBasemaps in the OfflineMap as necessary.
                     * @param offlineMap
                     * @param progress
                     * @private
                     */
                    function downloadBasemaps(app, offlineMap, cancellationToken, progress) {
                        // Download basemaps in series.
                        var completedBasemaps = 0;
                        return Promise.reduce(offlineMap.content.basemaps, function (_, basemap) {
                            if (cancellationToken.isCancellationRequested) {
                                throw new Error("Operation cancelled.");
                            }
                            return downloadBasemap(app, offlineMap, basemap, cancellationToken, function (args) {
                                var overallPercentage = (args.percentage + completedBasemaps * 100) / offlineMap.content.basemaps.length;
                                if (progress) {
                                    progress({
                                        message: args.message,
                                        percentage: overallPercentage
                                    });
                                }
                            }).catch(function (error) {
                                if (progress) {
                                    progress({
                                        isWarning: true,
                                        message: app.getResource("Mapping.Infrastructure", "language-offline-progress-basemapdownload-failed").format(basemap.filename, error.message || error),
                                        percentage: 100
                                    });
                                }
                            }).finally(function () {
                                completedBasemaps++;
                            });
                        }, null);
                    }
                    offline.downloadBasemaps = downloadBasemaps;
                    function downloadBasemap(app, offlineMap, basemap, cancellationToken, progress) {
                        if (!basemap) {
                            throw new Error("basemap cannot be null.");
                        }
                        if (!basemap.filename) {
                            throw new Error("basemap.filename cannot be null.");
                        }
                        if (!basemap.url) {
                            throw new Error("basemap.url cannot be null.");
                        }
                        switch (basemap.sourceType) {
                            case offline.OfflineMapBasemap.Type.PREGENERATED:
                                return downloadPregeneratedBasemap(app, basemap, cancellationToken, progress);
                            case offline.OfflineMapBasemap.Type.EXPORT_TILES:
                                return downloadExportTilesBasemap(app, offlineMap, basemap, cancellationToken, progress);
                        }
                        return null;
                    }
                    var resourceDownloadEventStatus = {
                        connecting: "Connecting",
                        processing: "Processing",
                        downloading: "Downloading"
                    };
                    function downloadPregeneratedBasemap(app, basemap, cancellationToken, progress) {
                        // The URL might be Essentials-relative, but GMAF doesn't have that base URL and can only use absolute URLs.
                        var url = app.makeAbsolute(basemap.url, app.site.url);
                        var token = app.site.getTokenFromPrincipal(url, geocortex.essentials.Site) || app.site.getTokenFromPrincipal(url, esri.IdentityManagerBase);
                        if (token != null) {
                            url += (url.indexOf("?") === -1 ? "?" : "&") + "token=" + token;
                        }
                        var downloadParams = {
                            url: url,
                            fileName: basemap.filename,
                            overwrite: "OnNewer"
                        };
                        return app.nativeManager.message("DownloadResource", downloadParams, cancellationToken, function (jobMessage) {
                            var eventArgs = jobMessage.details;
                            switch (eventArgs.status) {
                                case resourceDownloadEventStatus.connecting:
                                    if (progress) {
                                        progress({
                                            message: app.getResource("Mapping.Infrastructure", "language-offline-progress-basemapdownload-connecting").format(basemap.filename),
                                            percentage: 0
                                        });
                                    }
                                    break;
                                case resourceDownloadEventStatus.downloading:
                                    if (progress) {
                                        var downloadedPercent = Math.round(eventArgs.bytesDownloaded / eventArgs.bytesTotal * 100);
                                        var bytesDownloadedString = offline.formatBytesString(app, eventArgs.bytesDownloaded);
                                        var bytesTotalString = offline.formatBytesString(app, eventArgs.bytesTotal);
                                        var downloadRate = offline.formatByteTransferRateString(app, eventArgs.bytesPerSecond);
                                        progress({
                                            message: app.getResource("Mapping.Infrastructure", "language-offline-progress-basemapdownload-downloading")
                                                .format(basemap.filename, bytesDownloadedString, bytesTotalString, downloadedPercent, downloadRate),
                                            percentage: downloadedPercent
                                        });
                                    }
                                    break;
                                default:
                                    app.trace.error("Unknown ResourceDownloadEvent status " + eventArgs.status);
                            }
                        });
                    }
                    function downloadExportTilesBasemap(app, offlineMap, basemap, cancellationToken, progress) {
                        var url = basemap.url;
                        var token = app.site.getTokenFromPrincipal(url, esri.IdentityManagerBase);
                        if (token != null) {
                            url += (url.indexOf("?") === -1 ? "?" : "&") + "token=" + token;
                        }
                        var exportTilesParams = {
                            url: url,
                            fileName: basemap.filename,
                            minLevel: basemap.minLevel,
                            maxLevel: basemap.maxLevel,
                            areaOfInterest: JSON.stringify({
                                features: [
                                    {
                                        geometry: offlineMap.content.geometry
                                    }
                                ]
                            }),
                            refreshInterval: basemap.refreshInterval
                        };
                        return app.nativeManager.message("ExportTiles", exportTilesParams, cancellationToken, function (jobMessage) {
                            var eventArgs = jobMessage.details;
                            switch (eventArgs.status) {
                                case resourceDownloadEventStatus.connecting:
                                    if (progress) {
                                        progress({
                                            message: app.getResource("Mapping.Infrastructure", "language-offline-progress-basemapexport-connecting").format(basemap.filename),
                                            percentage: 0
                                        });
                                    }
                                    break;
                                case resourceDownloadEventStatus.processing:
                                    if (progress) {
                                        progress({
                                            message: eventArgs.message || app.getResource("Mapping.Infrastructure", "language-offline-progress-basemapexport-processing").format(basemap.filename),
                                            percentage: 0
                                        });
                                    }
                                    break;
                                case resourceDownloadEventStatus.downloading:
                                    if (progress) {
                                        var downloadedPercent = Math.round(eventArgs.bytesDownloaded / eventArgs.bytesTotal * 100);
                                        var bytesDownloadedString = offline.formatBytesString(app, eventArgs.bytesDownloaded);
                                        var bytesTotalString = offline.formatBytesString(app, eventArgs.bytesTotal);
                                        var downloadRate = offline.formatByteTransferRateString(app, eventArgs.bytesPerSecond);
                                        progress({
                                            message: app.getResource("Mapping.Infrastructure", "language-offline-progress-basemapexport-downloading")
                                                .format(basemap.filename, bytesDownloadedString, bytesTotalString, downloadedPercent, downloadRate),
                                            percentage: downloadedPercent
                                        });
                                    }
                                    break;
                                default:
                                    app.trace.error("Unknown ResourceDownloadEvent status " + eventArgs.status);
                            }
                        });
                    }
                })(offline = infrastructure.offline || (infrastructure.offline = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure_1) {
                var offline;
                (function (offline) {
                    var bundle;
                    (function (bundle_1) {
                        /**
                         * Builds an offline Bundle.
                         * @return a promise of the Bundle.
                         * @private
                         */
                        function buildBundle(context) {
                            var bundle = {
                                id: context.bundleId,
                                timestamp: new Date().getTime(),
                                routingRules: bundle_1.buildRoutingRules(context),
                                resources: []
                            };
                            var promises = [
                                addInvariantEntries(context, bundle),
                                addSiteEntry(context, bundle),
                                addLayerListEntry(context, bundle),
                                addMapServiceEnties(context, bundle)
                            ];
                            return Promise.all(promises).then(function () { return bundle; });
                        }
                        bundle_1.buildBundle = buildBundle;
                        /**
                         * Add entries that are the same in every bundle.
                         */
                        function addInvariantEntries(context, bundle) {
                            bundle.resources.push(buildJsonEntry("__error_offline_no_endpoint", {
                                error: {
                                    code: 400,
                                    message: "This resource is not available offline.",
                                    details: []
                                }
                            }));
                            bundle.resources.push(buildJsonEntry("__no_features", {
                                objectIdFieldName: "OBJECTID",
                                globalIdFieldName: "GlobalID",
                                features: []
                            }));
                            bundle.resources.push(buildJsonEntry("__no_search_results", {
                                count: 0,
                                features: [],
                                ResponseStatus: {}
                            }));
                            bundle.resources.push(buildJsonEntry("__no_data_links", {
                                results: []
                            }));
                            bundle.resources.push(buildJsonEntry("__empty_attribution_response", ""));
                            return null;
                        }
                        function addLayerListEntry(context, bundle) {
                            return new Promise(function (resolve, reject) {
                                var layerListUrl = cleanUpRestUrl(context, context.app.site.url + "/map/layerlist");
                                geocortex.request({
                                    url: layerListUrl,
                                    content: {
                                        "f": "json"
                                    },
                                    load: function (layerListJson) {
                                        bundle.resources.push(buildJsonEntry("__layerlist_", layerListJson));
                                        resolve(null);
                                    },
                                    error: function (error) {
                                        context.app.trace.error("Error fetching '" + layerListUrl + "': " + error.message);
                                        reject(error);
                                    },
                                    callbackParamName: "Callback"
                                });
                            });
                        }
                        function addSiteEntry(context, bundle) {
                            return new Promise(function (resolve, reject) {
                                var siteUrl = cleanUpRestUrl(context, context.app.site.url);
                                geocortex.request({
                                    url: siteUrl,
                                    content: {
                                        "f": "json",
                                        "deep": context.app.site.deepInitialize
                                    },
                                    load: function (siteJson) {
                                        // Remove the auth from the principal so the user isn't stuck with it and unable to log out.
                                        if (siteJson && siteJson.principal) {
                                            siteJson.principal.isAuthenticated = false;
                                            siteJson.principal.label = "Guest";
                                            siteJson.principal.expiry = null;
                                            siteJson.principal.identities = [];
                                            siteJson.principal.tokens = {
                                                arcgis: {},
                                                geocortex: {},
                                                site: null
                                            };
                                        }
                                        bundle.resources.push(buildJsonEntry("__site_", siteJson));
                                        resolve(null);
                                    },
                                    error: function (error) {
                                        context.app.trace.error("Error fetching '" + siteUrl + "'. " + error.message);
                                        reject(error);
                                    },
                                    callbackParamName: "Callback"
                                });
                            });
                        }
                        function addMapServiceEnties(context, bundle) {
                            var processedMapServiceUrls = [];
                            var mapServices = context.app.site.essentialsMap.mapServices;
                            if (context.app.site.overviewMap) {
                                mapServices = mapServices.concat(context.app.site.overviewMap.mapServices);
                            }
                            var promises = mapServices.map(function (mapService) {
                                // Don't add duplicates.  Overview map and regular map may or may not share map services.
                                if (processedMapServiceUrls.indexOf(mapService.url) != -1) {
                                    return null;
                                }
                                processedMapServiceUrls.push(mapService.url);
                                if ((mapService.mapServiceType === geocortex.essentials.MapServiceType.BING) || (mapService.mapServiceType === geocortex.essentials.MapServiceType.WMS) || (mapService.mapServiceType === geocortex.essentials.MapServiceType.WEBTILED)) {
                                    // Unhandled.
                                    return null;
                                }
                                else if ((mapService.mapServiceType === geocortex.essentials.MapServiceType.GEORSS) || (mapService.mapServiceType === geocortex.essentials.MapServiceType.KML)) {
                                    return addXmlMapServiceEntry(context, bundle, mapService);
                                }
                                else if (mapService instanceof geocortex.essentials.FeatureLayerService) {
                                    return addFeatureServiceEntries(context, bundle, mapService);
                                }
                                else {
                                    return addJsonMapServiceEntry(context, bundle, mapService);
                                }
                            });
                            return Promise.all(promises);
                        }
                        function addFeatureServiceEntries(context, bundle, mapService) {
                            var promises = [];
                            var featureServiceUrl = /^(.*)(\/[0-9]+\/?)$/.exec(mapService.serviceUrl)[1];
                            // Related tables...
                            // Get the relationships - prefer the relationships from the Essentials layer, because they can have security applied
                            // Fall back to using the relationships from the ESRI layer
                            var relationships = null;
                            if (mapService.layers[0]) {
                                relationships = mapService.layers[0].relationships;
                            }
                            else if (mapService.serviceLayer) {
                                relationships = mapService.serviceLayer.relationships;
                            }
                            if (relationships) {
                                promises = promises.concat(relationships.map(function (relationship) {
                                    return new Promise(function (resolve, reject) {
                                        var relatedTableUrl = featureServiceUrl + "/" + relationship.relatedTableId;
                                        var content = {
                                            f: "json"
                                        };
                                        var token = mapService.findServiceToken();
                                        if (token) {
                                            content.token = token;
                                        }
                                        esri.request({
                                            url: relatedTableUrl,
                                            handleAs: "json",
                                            content: content,
                                            callbackParamName: "Callback"
                                        }).then(function (response) {
                                            bundle.resources.push(buildJsonEntry(urlToPattern(relatedTableUrl), response));
                                            resolve(null);
                                        }, function (error) {
                                            context.app.trace.error("Error fetching '" + relatedTableUrl + "'. " + error.message);
                                            reject(error);
                                        });
                                    });
                                }));
                            }
                            promises.push(addJsonMapServiceEntry(context, bundle, mapService));
                            return Promise.all(promises);
                        }
                        function addJsonMapServiceEntry(context, bundle, mapService) {
                            return new Promise(function (resolve, reject) {
                                var mapServiceUrl = cleanUpMapServiceUrl(context, mapService);
                                var content = {
                                    f: "json"
                                };
                                var token = mapService.findServiceToken();
                                if (token) {
                                    content.token = token;
                                }
                                esri.request({
                                    url: mapServiceUrl,
                                    handleAs: "json",
                                    content: content,
                                    callbackParamName: "Callback"
                                }).then(function (response) {
                                    bundle.resources.push(buildJsonEntry(urlToPattern(mapServiceUrl), response));
                                    resolve(null);
                                }, function (error) {
                                    context.app.trace.error("Error fetching '" + mapServiceUrl + "'. " + error.message);
                                    reject(error);
                                });
                            });
                        }
                        function addXmlMapServiceEntry(context, bundle, mapService) {
                            return new Promise(function (resolve, reject) {
                                var mapServiceUrl = cleanUpMapServiceUrl(context, mapService);
                                esri.request({
                                    url: mapServiceUrl,
                                    handleAs: "xml",
                                    content: {},
                                    callbackParamName: "Callback"
                                }).then(function (response) {
                                    bundle.resources.push(buildEntry(urlToPattern(mapServiceUrl), new XMLSerializer().serializeToString(response)));
                                    resolve(null);
                                }, function (error) {
                                    context.app.trace.error("Error fetching '" + mapServiceUrl + "'. " + error.message);
                                    reject(error);
                                });
                            });
                        }
                        /**
                         * Builds an OfflineResourceEntry for an object.
                         */
                        function buildJsonEntry(key, value, encode) {
                            if (encode === void 0) { encode = false; }
                            return buildEntry(key, JSON.stringify(value), encode);
                        }
                        /**
                         * Builds an OfflineResourceEntry for a raw string value.
                         */
                        function buildEntry(key, value, encode) {
                            if (encode === void 0) { encode = false; }
                            return {
                                isEncoded: encode,
                                isJson: true,
                                key: key,
                                value: encode ? geocortex.framework.utils.base64Encode(value) : value
                            };
                        }
                        function cleanUpMapServiceUrl(context, mapService) {
                            var url = mapService.serviceUrl;
                            if (!url && mapService.serviceLayer) {
                                url = mapService.serviceLayer.url;
                            }
                            if (url) {
                                url = cleanUpRestUrl(context, url);
                            }
                            return url;
                        }
                        bundle_1.cleanUpMapServiceUrl = cleanUpMapServiceUrl;
                        function cleanUpRestUrl(context, url) {
                            url = context.app.makeAbsolute(url);
                            // Let the browser do the cleanup for us.
                            var link = document.createElement("a");
                            link.href = url;
                            var reformattedUrl = link.href;
                            var lastChar = reformattedUrl.charAt(reformattedUrl.length - 1);
                            if (lastChar === "/" || lastChar === "\\") {
                                reformattedUrl = reformattedUrl.substr(0, reformattedUrl.length - 1);
                            }
                            return reformattedUrl;
                        }
                        bundle_1.cleanUpRestUrl = cleanUpRestUrl;
                        /**
                         * Turns a well-formed URL into a regex pattern, which could also be a key for a resource.
                         */
                        function urlToPattern(url) {
                            var pattern = url;
                            // Strip out protocol.
                            var hasProtocolTest = /^[a-z]+:\/\/(.*)/.exec(pattern);
                            if (hasProtocolTest) {
                                pattern = hasProtocolTest[1];
                            }
                            // Due to a very unusual load balancing, ESRI relays tile request for odd numbers through
                            // "services.arcgisonline" and even numbers via "server.arcgisonline".
                            var isArcGisOnlineTest = /^(services|server)\.arcgisonline\.(.*)/.exec(pattern);
                            if (isArcGisOnlineTest) {
                                pattern = "(services|server).arcgisonline." + isArcGisOnlineTest[2];
                            }
                            // The Bing URL is dev.virtualearth.net, but the tiles are requested from tiles.virtualearth.net.
                            // Match on anything that where the host ends with virtualearth.net
                            var bingTest = /^[^/]*virtualearth.net\//.exec(pattern);
                            if (bingTest) {
                                pattern = "[^/]*virtualearth.net/";
                            }
                            // Strip out default ports.
                            var hasDefaultPortTest = /^([a-zA-Z.]+):(80|443)(.*)/.exec(pattern);
                            if (hasDefaultPortTest) {
                                pattern = hasDefaultPortTest[1] + hasDefaultPortTest[3];
                            }
                            pattern = pattern.replace(/\//g, "/+").replace(/\./g, "\\.");
                            return pattern;
                        }
                        bundle_1.urlToPattern = urlToPattern;
                    })(bundle = offline.bundle || (offline.bundle = {}));
                })(offline = infrastructure_1.offline || (infrastructure_1.offline = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var offline;
                (function (offline) {
                    var bundle;
                    (function (bundle_2) {
                        /**
                         * Builds a bundle of rules on what to do while an offline map is active and applies
                         * them to outgoing network traffic.
                         */
                        var BundleManager = (function () {
                            function BundleManager(app, libraryId) {
                                var _this = this;
                                this.app = app;
                                this.libraryId = libraryId;
                                this._router = new bundle_2.OfflineRouter(this.app);
                                this._esriRequestHacker = new bundle_2.EsriRequestHacker(app, function (request, options) { return _this._router.handle(request, options); });
                                this._esriLayerHacker = new bundle_2.EsriLayerHacker(app, function (url) { return _this._router.rewriteUrl(url); });
                                this._esriLayerHacker.errorReporter = function (error) { return _this.app.trace.warning(error); };
                                this._serveResourceHandler = new bundle_2.offlineHandlers.ServeResourceHandler(this.app, function (key) { return _this._appStoreGetPromise(key); }, function (key, value) { return _this._appStoreSetPromise(key, value); }, function (key) { return _this._appStoreRemovePromise(key); });
                                var passthroughHandler = new bundle_2.offlineHandlers.PassthroughHandler(this.app, function (request, options) { return _this._esriRequestHacker.unhackedRequest(request, options); });
                                this._router.setDefaultHandler(passthroughHandler);
                                this._router.addHandler(passthroughHandler);
                                this._router.addHandler(this._serveResourceHandler);
                                this._router.addHandler(new bundle_2.offlineHandlers.FailHandler());
                                this._router.addHandler(new bundle_2.offlineHandlers.RewriteHandler(this.app, function (request, options) { return _this._esriRequestHacker.unhackedRequest(request, options); }));
                                this._router.addHandler(new bundle_2.offlineHandlers.SiteHandler(this.app, function (key) { return _this._serveResourceHandler.getResourceValue(key); }, function (request, options) { return _this._esriRequestHacker.unhackedRequest(request, options); }));
                                this.app.event("ApplicationStorageClearedEvent").subscribe(this, function () {
                                    _this._serveResourceHandler.clear();
                                    _this._router.clearRoutingRules();
                                });
                            }
                            /**
                             * Download Offline Resources.
                             * @param bundleId the ID that will be given to this bundle.
                             * @param basemaps information on how to direct basemap requests.
                             */
                            BundleManager.prototype.createBundle = function (bundleId, basemaps) {
                                var _this = this;
                                // Wrap the _createBundle implementation and trash the return value so that we don't expose the bundle.
                                return this._buildBundle(bundleId, basemaps)
                                    .then(function (bundle) { return _this._storeBundle(bundle); })
                                    .then(function (bundle) { return undefined; });
                            };
                            /**
                             * Delete all resources stored for the given bundle.
                             * @param bundleId The ID of the existing bundle.
                             */
                            BundleManager.prototype.deleteBundle = function (bundleId) {
                                var _this = this;
                                return this._getBundle(bundleId)
                                    .then(function (bundle) { return bundle ? _this._serveResourceHandler.unstoreBundle(bundle) : null; })
                                    .then(function (bundle) { return bundle ? _this._appStoreRemovePromise(_this._getBundleKey(bundle)) : null; })
                                    .then(function () { return; });
                            };
                            /**
                             * Update all resources stored for the given bundle.
                             * @param bundleId The ID of the existing bundle.
                             * @param basemaps information on how to direct basemap requests.
                             */
                            BundleManager.prototype.updateBundle = function (bundleId, basemaps) {
                                var _this = this;
                                return this._buildBundle(bundleId, basemaps)
                                    .then(function (bundle) {
                                    return _this.deleteBundle(bundleId)
                                        .catch(function (error) {
                                        _this.app.trace.warning("Unable to delete old bundle before replacing it. " + (error.message || error) + " Attempting to continue.");
                                        return null;
                                    })
                                        .then(function () { return bundle; });
                                })
                                    .then(function (bundle) { return _this._storeBundle(bundle); })
                                    .then(function (bundle) { return _this._router.setRoutingRules(bundle.routingRules); })
                                    .then(function () { return; });
                            };
                            /**
                             * Make the bundle with the given ID the active bundle.  After the returned promise
                             * resolves future offline routing and resources will come from the bundle.
                             * @param bundleId
                             */
                            BundleManager.prototype.loadBundle = function (bundleId) {
                                var _this = this;
                                if (!bundleId) {
                                    return Promise.reject(new Error("Bundle ID cannot be null."));
                                }
                                return this._getBundle(bundleId)
                                    .then(function (bundle) {
                                    if (!bundle) {
                                        throw new Error(_this.getResource("language-offline-errors-bundlenotfound"));
                                    }
                                    _this._serveResourceHandler.loadBundle(bundle);
                                    _this._router.setRoutingRules(bundle.routingRules);
                                });
                            };
                            /**
                             * Return to a default state with no active bundle available.
                             * This should always be safe.
                             */
                            BundleManager.prototype.unloadBundle = function () {
                                this._serveResourceHandler.clear();
                                this._router.clearRoutingRules();
                                // Act like an async function in case we need async functionality in the future.
                                return Promise.resolve();
                            };
                            /**
                             * Generate the bundle for this viewer.
                             * @param bundleId the ID that will be given to this bundle.
                             * @param basemaps information on how to direct basemap requests.
                             */
                            BundleManager.prototype._buildBundle = function (bundleId, basemaps) {
                                var _this = this;
                                // Need to update profile key to reference the currently active profile
                                return offline.SyncEngine.getSyncInfo(this.app, bundleId)
                                    .then(function (featureLayerSyncInfo) {
                                    var bundleContext = {
                                        app: _this.app,
                                        bundleId: bundleId,
                                        basemaps: basemaps,
                                        featureLayerSyncInfo: featureLayerSyncInfo
                                    };
                                    // We need to make sure that we're targetting online resources while building the bundle, so disable the OfflineRouter temporarily
                                    _this._esriRequestHacker.disable();
                                    return bundle_2.buildBundle(bundleContext).finally(function () {
                                        _this._esriRequestHacker.enable();
                                    });
                                });
                            };
                            /**
                             * Adds bundle resources to the offline store.  Does not activate it.
                             * @param bundle The bundle to store.
                             */
                            BundleManager.prototype._storeBundle = function (bundle) {
                                var _this = this;
                                if (bundle == null) {
                                    return Promise.reject(new Error("Bundle is null."));
                                }
                                if (bundle.id == null) {
                                    return Promise.reject(new Error("Bundle ID is null."));
                                }
                                return this._serveResourceHandler.stripAndStoreBundle(bundle)
                                    .then(function () {
                                    _this._appStoreSetPromise(_this._getBundleKey(bundle), JSON.stringify(bundle));
                                    return bundle;
                                }, function (error) {
                                    _this.app.trace.warning("Failed to save offline bundle '" + bundle.id + "'. " + (error.message || error));
                                    // IE-only.
                                    if (error.code == 22 && window.localStorage && window.localStorage.remainingSpace) {
                                        _this.app.trace.warning("Local storage has " + window.localStorage.remainingSpace + " bytes remaining.");
                                    }
                                    throw error;
                                });
                            };
                            /**
                             * Get the bundle with the given ID from storage.  Does not make it active.
                             * @param bundleId The ID of the bundle to retrieve.
                             */
                            BundleManager.prototype._getBundle = function (bundleId) {
                                if (!bundleId) {
                                    return Promise.reject(new Error("Bundle ID is null."));
                                }
                                return this._appStoreGetPromise(this._getBundleKey(bundleId))
                                    .then(function (bundleJsonString) {
                                    if (!bundleJsonString) {
                                        return null;
                                    }
                                    return JSON.parse(bundleJsonString);
                                });
                            };
                            /**
                             * Get the storage key for the given bundle or bundle ID.
                             * @param bundle
                             */
                            BundleManager.prototype._getBundleKey = function (bundle) {
                                return "__bundle-" + (typeof bundle === "string" ? bundle : bundle.id);
                            };
                            /**
                             * Get from the store in promise form.  This will hopefully be moved into Store in 3.0.
                             * @param key
                             */
                            BundleManager.prototype._appStoreGetPromise = function (key) {
                                var _this = this;
                                return new Promise(function (resolve, reject) { return _this.app.store.get(key, resolve, reject); });
                            };
                            /**
                             * Set to the store in promise form.  This will hopefully move into Store in 3.0.
                             * @param key
                             * @param value
                             */
                            BundleManager.prototype._appStoreSetPromise = function (key, value) {
                                var _this = this;
                                return new Promise(function (resolve, reject) { return _this.app.store.set(key, value, function () { return resolve(); }, reject); });
                            };
                            /**
                             * Remove from the store in promise form.  This will hopefully move into Store in 3.0.
                             * @param key
                             */
                            BundleManager.prototype._appStoreRemovePromise = function (key) {
                                var _this = this;
                                return new Promise(function (resolve, reject) { return _this.app.store.remove(key, function () { return resolve(); }, reject); });
                            };
                            BundleManager.prototype.getResource = function (key) {
                                return this.app.getResource(this.libraryId, key);
                            };
                            return BundleManager;
                        }());
                        bundle_2.BundleManager = BundleManager;
                    })(bundle = offline.bundle || (offline.bundle = {}));
                })(offline = infrastructure.offline || (infrastructure.offline = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var offline;
                (function (offline) {
                    var bundle;
                    (function (bundle) {
                        /**
                         * A resource that is stored and can be served while offline.  Typically these
                         * are responses from REST endpoints served by the "ServeResource" routing rule.
                         */
                        var BundleResourceEntry = (function () {
                            function BundleResourceEntry(mixin) {
                                if (mixin) {
                                    dojo.safeMixin(this, mixin);
                                }
                                else {
                                    this.key = "";
                                }
                            }
                            return BundleResourceEntry;
                        }());
                        bundle.BundleResourceEntry = BundleResourceEntry;
                    })(bundle = offline.bundle || (offline.bundle = {}));
                })(offline = infrastructure.offline || (infrastructure.offline = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var offline;
                (function (offline) {
                    var bundle;
                    (function (bundle) {
                        /**
                         * Applies dirty hacks to the Esri layers to make requests work offline.
                         * This relies upon undocumented functionality and may break between releases.
                         * (But rarely has!  Whew.)
                         */
                        var EsriLayerHacker = (function () {
                            /**
                             * Constructor.
                             * @param urlRewriter The function that rewrites tile requests, or returns null to not rewrite it.
                             *                    Can be set on the fly.
                             */
                            function EsriLayerHacker(app, urlRewriter) {
                                this.app = app;
                                this.urlRewriter = urlRewriter;
                                /**
                                 * Callback for errors produced by invalid requests.
                                 */
                                this.errorReporter = function (error) { };
                                this._captureHooks();
                                this._extendEsriLayers();
                            }
                            EsriLayerHacker.prototype._captureHooks = function () {
                                this._hooked_esri_getTileUrl = esri.layers.ArcGISTiledMapServiceLayer._meta.hidden.getTileUrl;
                                this._hooked_ogc_getWMTSTileUrl = esri.layers.WMTSLayer._meta.hidden.getTileUrl;
                                this._ogc__tileLoadHandler = esri.layers.WMTSLayer.superclass._tileLoadHandler;
                                this._hooked_BingMaps_getTileUrl = esri.virtualearth.VETiledLayer._meta.hidden.getTileUrl;
                                this._bingMaps__tileLoadHandler = esri.virtualearth.VETiledLayer.superclass._tileLoadHandler;
                                this._hooked_WebTiledLayer_getTileUrl = esri.layers.WebTiledLayer._meta.hidden.getTileUrl;
                                this._webTiledLayer__tileLoadHandler = esri.layers.WebTiledLayer.superclass._tileLoadHandler;
                                this._hooked_esri_getImageUrl = esri.layers.ArcGISDynamicMapServiceLayer._meta.hidden.getImageUrl;
                                this._hooked_ogc_getImageUrl = esri.layers.WMSLayer._meta.hidden.getImageUrl;
                            };
                            /**
                             * @private Extend ESRI layers for offline functionality
                             */
                            EsriLayerHacker.prototype._extendEsriLayers = function () {
                                // None of the below should use arrow functions.  We need to pass through the context.
                                var layerHacker = this;
                                esri.virtualearth.VETiledLayer.extend({
                                    getTileUrl: function (svc, col, row) {
                                        var originalTileUrl = layerHacker._hooked_BingMaps_getTileUrl.apply(this, [svc, col, row]);
                                        if (!layerHacker.app.offlineManager.isOfflineMapActive.get()) {
                                            return originalTileUrl;
                                        }
                                        return layerHacker.urlRewriter(originalTileUrl) || originalTileUrl;
                                    },
                                    // We can also muck around with tiles here, if need be.
                                    _tileLoadHandler: function (evt) {
                                        layerHacker._bingMaps__tileLoadHandler.apply(this, [evt]);
                                    }
                                });
                                esri.layers.WMTSLayer.extend({
                                    getTileUrl: function (svc, col, row) {
                                        var originalTileUrl = layerHacker._hooked_ogc_getWMTSTileUrl.apply(this, [svc, col, row]);
                                        if (!layerHacker.app.offlineManager.isOfflineMapActive.get()) {
                                            return originalTileUrl;
                                        }
                                        return layerHacker.urlRewriter(originalTileUrl) || originalTileUrl;
                                    },
                                    // We can also muck around with tiles here, if need be.
                                    _tileLoadHandler: function (evt) {
                                        layerHacker._ogc__tileLoadHandler.apply(this, [evt]);
                                    }
                                });
                                esri.layers.WebTiledLayer.extend({
                                    getTileUrl: function (svc, col, row) {
                                        var originalTileUrl = layerHacker._hooked_WebTiledLayer_getTileUrl.apply(this, [svc, col, row]);
                                        if (!layerHacker.app.offlineManager.isOfflineMapActive.get()) {
                                            return originalTileUrl;
                                        }
                                        return layerHacker.urlRewriter(originalTileUrl) || originalTileUrl;
                                    },
                                    // We can also muck around with tiles here, if need be.
                                    _tileLoadHandler: function (evt) {
                                        layerHacker._webTiledLayer__tileLoadHandler.apply(this, [evt]);
                                    }
                                });
                                esri.layers.ArcGISTiledMapServiceLayer.extend({
                                    getTileUrl: function (svc, col, row) {
                                        var originalTileUrl = layerHacker._hooked_esri_getTileUrl.apply(this, [svc, col, row]);
                                        if (!layerHacker.app.offlineManager.isOfflineMapActive.get()) {
                                            return originalTileUrl;
                                        }
                                        return layerHacker.urlRewriter(originalTileUrl) || originalTileUrl;
                                    }
                                });
                                esri.layers.WMSLayer.extend({
                                    getImageUrl: function (param, width, height, callback) {
                                        if (!layerHacker.app.offlineManager.isOfflineMapActive.get()) {
                                            if (!width || !height) {
                                                layerHacker.errorReporter("Invalid dimensions on requested map image. This is usually due to an invalid map resize event.");
                                            }
                                            layerHacker._hooked_ogc_getImageUrl.apply(this, arguments);
                                            return;
                                        }
                                        else {
                                            // We need to remap the original URL. To do so, we need to call the original method and
                                            // get it to call our dummy callback.
                                            function surrogateCallback(originalTileUrl) {
                                                var newTileUrl = layerHacker.urlRewriter(originalTileUrl) || originalTileUrl;
                                                if (callback) {
                                                    callback(newTileUrl);
                                                }
                                            }
                                            ;
                                            layerHacker._hooked_ogc_getImageUrl.apply(this, [param, width, height, surrogateCallback]);
                                        }
                                    }
                                });
                                esri.layers.ArcGISDynamicMapServiceLayer.extend({
                                    getImageUrl: function (param, width, height, callback) {
                                        if (!layerHacker.app.offlineManager.isOfflineMapActive.get()) {
                                            if (!width || !height) {
                                                layerHacker.errorReporter("Invalid dimensions on requested map image. This is usually due to an invalid map resize event.");
                                            }
                                            layerHacker._hooked_esri_getImageUrl.apply(this, arguments);
                                            return;
                                        }
                                        else {
                                            // We need to remap the original URL. To do so, we need to call the original method and
                                            // get it to call our dummy callback.
                                            function surrogateCallback(originalTileUrl) {
                                                var newTileUrl = layerHacker.urlRewriter(originalTileUrl) || originalTileUrl;
                                                if (callback) {
                                                    callback(newTileUrl);
                                                }
                                            }
                                            ;
                                            layerHacker._hooked_esri_getImageUrl.apply(this, [param, width, height, surrogateCallback]);
                                        }
                                    }
                                });
                            };
                            return EsriLayerHacker;
                        }());
                        bundle.EsriLayerHacker = EsriLayerHacker;
                    })(bundle = offline.bundle || (offline.bundle = {}));
                })(offline = infrastructure.offline || (infrastructure.offline = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var offline;
                (function (offline) {
                    var bundle;
                    (function (bundle) {
                        /**
                         * Applies dirty hacks to esri.request to make requests work offline.
                         * This may break between Esri API releases.
                         */
                        var EsriRequestHacker = (function () {
                            /**
                             * Calls to esri.request will be redirected to the given requestHandler while enabled.
                             * @param app
                             * @param requestHandler
                             */
                            function EsriRequestHacker(app, requestHandler) {
                                this.app = app;
                                this.requestHandler = requestHandler;
                                // Whether to apply the hack.
                                this._isEnabled = true;
                                this._setupEsriRequestHooks();
                            }
                            EsriRequestHacker.prototype.unhackedRequest = function (request, options) {
                                return this._hooked_esri_request.call(esri, request, options);
                            };
                            /**
                             * Bypass the hack and allow traffic to flow through normally.
                             */
                            EsriRequestHacker.prototype.disable = function () {
                                this._isEnabled = false;
                            };
                            /**
                             * Re-engage the hack.
                             */
                            EsriRequestHacker.prototype.enable = function () {
                                this._isEnabled = true;
                            };
                            /**
                             * @private Hook into esri.request. This is for REST requests.
                             */
                            EsriRequestHacker.prototype._setupEsriRequestHooks = function () {
                                var _this = this;
                                if (!esri.request) {
                                    this.app.trace.error("Offline module could not hook into ESRI API.");
                                    return;
                                }
                                this._hooked_esri_request = esri.request;
                                esri.request = (function (request, options) {
                                    if (_this.app.offlineManager.getActiveOfflineMap() && _this._isEnabled) {
                                        // Custom offline handling.
                                        return _this.requestHandler(request, options);
                                    }
                                    else {
                                        // No offline map, or not enabled? Request online resources
                                        return _this._hooked_esri_request.call(esri, request, options);
                                    }
                                });
                                // RequestPreCallback is supported for online requests only.  This is probably the least confusing
                                // thing for downstream developers.  Offline request management is done through the offline bundle.
                                var additionalRequestPreCallback = null;
                                esri.request.setRequestPreCallback = function (callback) {
                                    additionalRequestPreCallback = callback;
                                };
                                this._hooked_esri_request.setRequestPreCallback(function (ioArgs) {
                                    // In GMAF *only*, send all requests to the localhost over HTTP.  GMAF's server will never
                                    // support HTTPS, but it's on the same device so that's ok.  If this behaviour ever happens
                                    // outside GMAF that's *super* bad.
                                    if (/GeocortexApp/.test(navigator.userAgent) && /^https:\/\/(localhost|127\.0\.0\.1)(:\d+)?\//.test(ioArgs.url)) {
                                        ioArgs.url = "http" + ioArgs.url.substring(5);
                                    }
                                    if (additionalRequestPreCallback) {
                                        ioArgs = additionalRequestPreCallback(ioArgs);
                                    }
                                    return ioArgs;
                                });
                            };
                            return EsriRequestHacker;
                        }());
                        bundle.EsriRequestHacker = EsriRequestHacker;
                    })(bundle = offline.bundle || (offline.bundle = {}));
                })(offline = infrastructure.offline || (infrastructure.offline = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var offline;
                (function (offline) {
                    var bundle;
                    (function (bundle) {
                        var offlineHandlers;
                        (function (offlineHandlers) {
                            /**
                             * Doesn't actually handle anything and just pushes it through to online.
                             */
                            var PassthroughHandler = (function () {
                                function PassthroughHandler(app, unhackedRequesthandler) {
                                    this.app = app;
                                    this.unhackedRequesthandler = unhackedRequesthandler;
                                    this.name = "Passthrough";
                                }
                                PassthroughHandler.prototype.handle = function (request, rule, matches) {
                                    this.unhackedRequesthandler(request, request.options)
                                        .then(function (data) { return request.dfd.resolve(data); }, function (error) { return request.dfd.errback(error); });
                                    return true;
                                };
                                return PassthroughHandler;
                            }());
                            offlineHandlers.PassthroughHandler = PassthroughHandler;
                        })(offlineHandlers = bundle.offlineHandlers || (bundle.offlineHandlers = {}));
                    })(bundle = offline.bundle || (offline.bundle = {}));
                })(offline = infrastructure.offline || (infrastructure.offline = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var offline;
                (function (offline) {
                    var bundle;
                    (function (bundle) {
                        var offlineHandlers;
                        (function (offlineHandlers) {
                            /**
                             * Rejects all matching requests.
                             */
                            var FailHandler = (function () {
                                function FailHandler() {
                                    this.name = "Fail";
                                }
                                FailHandler.prototype.handle = function (request, rule, matches) {
                                    // The OfflineModule has traditionally been excellent at serving fail.
                                    request.dfd.reject();
                                    offlineHandlers.hookDeferredCallbacks(request);
                                    return true;
                                };
                                return FailHandler;
                            }());
                            offlineHandlers.FailHandler = FailHandler;
                        })(offlineHandlers = bundle.offlineHandlers || (bundle.offlineHandlers = {}));
                    })(bundle = offline.bundle || (offline.bundle = {}));
                })(offline = infrastructure.offline || (infrastructure.offline = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var offline;
                (function (offline) {
                    var bundle;
                    (function (bundle) {
                        var offlineHandlers;
                        (function (offlineHandlers) {
                            /**
                             * A useful util function.  Sets the load and error callbacks onto the deferred
                             * object used by request. This is due to the change from _request
                             * to request. _serveResourceImpl does not hook load and errors itself.
                             */
                            function hookDeferredCallbacks(request) {
                                var dfd = request.dfd;
                                var load = request.load; // <jeffg> I don't know where this comes from.
                                if (load) {
                                    dfd.addCallback(function (data) {
                                        var pending = dfd._pendingDfd, // <jeffg> undocumented, sketchy
                                        ioArgs = pending && pending.ioArgs, args = ioArgs && ioArgs.args;
                                        return load.call(args, data, ioArgs);
                                    });
                                }
                                var error = request.error; // <jeffg> I don't know where this comes from.
                                if (error) {
                                    dfd.addErrback(function (data) {
                                        var pending = dfd._pendingDfd, // <jeffg> undocumented, sketchy
                                        ioArgs = pending && pending.ioArgs, args = ioArgs && ioArgs.args;
                                        return error.call(args, data, ioArgs);
                                    });
                                }
                            }
                            offlineHandlers.hookDeferredCallbacks = hookDeferredCallbacks;
                        })(offlineHandlers = bundle.offlineHandlers || (bundle.offlineHandlers = {}));
                    })(bundle = offline.bundle || (offline.bundle = {}));
                })(offline = infrastructure.offline || (infrastructure.offline = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var offline;
                (function (offline) {
                    var bundle;
                    (function (bundle) {
                        var offlineHandlers;
                        (function (offlineHandlers) {
                            /**
                             * Rewrites requests and then passes them through the unhackedRequesthandler.
                             */
                            var RewriteHandler = (function () {
                                function RewriteHandler(app, unhackedRequesthandler) {
                                    this.app = app;
                                    this.unhackedRequesthandler = unhackedRequesthandler;
                                    this.name = "Rewrite";
                                }
                                RewriteHandler.prototype.handle = function (request, rule, matches) {
                                    request.url = this.rewriteRequest(request, rule, matches);
                                    // If Esri doesn't think we have cors, but modernizr thinks we do, trust modernizr
                                    if (!require.has("esri-cors") && Modernizr.cors) {
                                        // In Esri 3.4, they switched to has.js support for their 'feature detection'. 
                                        // Esri uses User Agent sniffing for their feature detection, which is regularly wrong, 
                                        // Especially with the Geocortex App, as it doesn't have 'Safari', or 'Chrome' in it.
                                        // To be able to support the App, we have to replace Esri's has function, but we only do this
                                        // If we know that we support cors, and the browser doesn't think we already have it.
                                        delete require.has.cache["esri-cors"];
                                        require.has.add("esri-cors", function () { return true; });
                                    }
                                    // Once we've rewritten the request, pass it down the esri chain, and hook the responses into our
                                    // Deferred we already returned.
                                    this.unhackedRequesthandler(request, request.options)
                                        .then(function (data) { return request.dfd.resolve(data); }, function (error) { return request.dfd.errback(error); });
                                    return true;
                                };
                                /**
                                 * Rewrites a request's URL.
                                 */
                                RewriteHandler.prototype.rewriteRequest = function (ctx, rule, matches) {
                                    if (!rule || !rule.parameters || !rule.parameters["newUrl"]) {
                                        throw new Error("Not a rewrite rule.");
                                    }
                                    var newUrl = rule.parameters["newUrl"];
                                    newUrl = newUrl.format.apply(newUrl, matches);
                                    newUrl = newUrl.replace("{localserver}", this.app.localServerAddress); // As seen in buildRoutingRules().
                                    // Append access-token for GMAF local server
                                    if (this.app.localServerAddress && this.app.localServerAddress.length > 0 && newUrl.startsWith(this.app.localServerAddress)) {
                                        newUrl = this._appendLocalServerToken(newUrl);
                                    }
                                    return newUrl;
                                };
                                /**
                                 * Takes a url, and appends the local server token as a URL parameter to create a new URL.
                                 */
                                RewriteHandler.prototype._appendLocalServerToken = function (url) {
                                    if (this.app.localServerToken) {
                                        if (!url.endsWith("?")) {
                                            url += url.indexOf("?") > 0 ? "&" : "?";
                                        }
                                        url += "localServerToken=" + this.app.localServerToken;
                                    }
                                    return url;
                                };
                                return RewriteHandler;
                            }());
                            offlineHandlers.RewriteHandler = RewriteHandler;
                        })(offlineHandlers = bundle.offlineHandlers || (bundle.offlineHandlers = {}));
                    })(bundle = offline.bundle || (offline.bundle = {}));
                })(offline = infrastructure.offline || (infrastructure.offline = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var offline;
                (function (offline) {
                    var bundle;
                    (function (bundle_3) {
                        var offlineHandlers;
                        (function (offlineHandlers) {
                            /**
                             * Serves resources stored in the bundle.  Some resources are removed from the bundle
                             * and stored separately to shrink what needs to be kept in memory.
                             */
                            var ServeResourceHandler = (function () {
                                function ServeResourceHandler(app, resourceGetter, resourceSetter, resourceRemover) {
                                    this.app = app;
                                    this.resourceGetter = resourceGetter;
                                    this.resourceSetter = resourceSetter;
                                    this.resourceRemover = resourceRemover;
                                    this.name = "ServeResource";
                                    this.isReady = new Observable(false);
                                }
                                /**
                                 * Serve the request using the given rule from the bundle.
                                 * @param request The request to serve.
                                 * @param rule The rule from the bundle that matches the request.
                                 * @param matches Regex capturing groups.
                                 * @return Whether the request was successfully handled.
                                 */
                                ServeResourceHandler.prototype.handle = function (request, rule, matches) {
                                    var _this = this;
                                    if (!this._bundle || !rule.parameters || !rule.parameters["key"]) {
                                        return false;
                                    }
                                    var key = rule.parameters["key"];
                                    key = key.format.apply(key, matches);
                                    // Don't use getResourceValue() because we need to know synchonously if we're going to handle.
                                    for (var i = 0, length = this._bundle.resources.length; i < length; i++) {
                                        if (this._bundle.resources[i].key === key) {
                                            offlineHandlers.hookDeferredCallbacks(request);
                                            this._getResourceValue(this._bundle.resources[i])
                                                .then(function (value) {
                                                request.dfd.resolve(value);
                                            })
                                                .catch(function (error) {
                                                _this.app.trace.error(error.message);
                                                request.dfd.reject(error.message);
                                            });
                                            return true;
                                        }
                                    }
                                    return false;
                                };
                                /**
                                 * Serve all future requests with resources from the given bundle.
                                 * @param bundle The bundle to serve from.
                                 */
                                ServeResourceHandler.prototype.loadBundle = function (bundle) {
                                    this.isReady.set(true);
                                    this._bundle = bundle;
                                };
                                /**
                                 * Clear all known resources.
                                 */
                                ServeResourceHandler.prototype.clear = function () {
                                    this.isReady.set(false);
                                    this._bundle = null;
                                };
                                /**
                                 * Strip large values out of the bundle and store them separately.  This does not make the
                                 * bundle active.  That is done with loadBundle.
                                 * @param bundle The bundle to process.
                                 * @return a promise of the bundle that was passed in, after it is processed.
                                 */
                                ServeResourceHandler.prototype.stripAndStoreBundle = function (bundle) {
                                    var _this = this;
                                    if (!bundle) {
                                        return Promise.reject(new Error("Bundle cannot be null."));
                                    }
                                    // For all resource entries with large values, store the value separately.
                                    var setPromises = bundle.resources.map(function (entry) {
                                        if (entry.value == null) {
                                            return Promise.reject(new Error("Bundle resoure entry value is already null: " + entry.key));
                                        }
                                        if (entry.value && entry.value.length > ServeResourceHandler._resourceCachingLength) {
                                            return _this.resourceSetter(ServeResourceHandler._getResourceStorageKey(bundle, entry), entry.value)
                                                .then(function () {
                                                entry.value = null;
                                            }, function (error) {
                                                _this.app.trace.error("Unable to strip '" + entry.key + "' out of the bundle and store it separately. " + error);
                                                // We're going to swallow the error and keep going.  Technically the value is still in the
                                                // bundle so nothing is lost at this point, but the odds of being able to save the bundle
                                                // itself is basically nil so you're probably screwed anyways.
                                            });
                                        }
                                        return null;
                                    });
                                    return Promise.all(setPromises).then(function () { return bundle; });
                                };
                                /**
                                 * Unstore all entries stored by stripAndStoreBundle.  The values are not returned to
                                 * the bundle.  It's assumed we're just going to throw it away.
                                 * @param bundle The bundle to process.
                                 * @return a promise of the bundle that was passed in, after it is processed.
                                 */
                                ServeResourceHandler.prototype.unstoreBundle = function (bundle) {
                                    var _this = this;
                                    if (!bundle) {
                                        return Promise.reject(new Error("Bundle cannot be null."));
                                    }
                                    var removePromises = bundle.resources.map(function (entry) {
                                        if (entry.value == null) {
                                            return _this.resourceRemover(ServeResourceHandler._getResourceStorageKey(bundle, entry));
                                        }
                                        return null;
                                    });
                                    return Promise.all(removePromises)
                                        .then(function () { return bundle; });
                                };
                                /**
                                 * Get the resouce for the given key.
                                 * @param key
                                 */
                                ServeResourceHandler.prototype.getResourceValue = function (key) {
                                    for (var i = 0, length = this._bundle.resources.length; i < length; i++) {
                                        if (this._bundle.resources[i].key === key) {
                                            return this._getResourceValue(this._bundle.resources[i]);
                                        }
                                    }
                                    return Promise.reject(new Error("No such entry found."));
                                };
                                /**
                                 * Get the resource from the given entry.
                                 * @param entry
                                 */
                                ServeResourceHandler.prototype._getResourceValue = function (entry) {
                                    var _this = this;
                                    return Promise.resolve(entry.value)
                                        .then(function (value) {
                                        if (value == null) {
                                            // Null values indicate it was removed and put in storage as per stripAndStoreBundle().
                                            return _this.resourceGetter(ServeResourceHandler._getResourceStorageKey(_this._bundle, entry));
                                        }
                                        return value;
                                    })
                                        .then(function (value) {
                                        if (!value) {
                                            throw new Error("Resource entry missing for: " + entry.key);
                                        }
                                        return value;
                                    })
                                        .then(function (value) {
                                        // Does the resource need decoding?
                                        if (entry.isEncoded === true) {
                                            value = geocortex.framework.utils.base64Decode(value);
                                        }
                                        // Is it a JSON string?
                                        if (entry.isJson === true) {
                                            value = JSON.parse(value);
                                        }
                                        return value;
                                    });
                                };
                                ServeResourceHandler._getResourceStorageKey = function (bundle, entry) {
                                    return bundle.id + "-" + entry.key;
                                };
                                /** The resource length at which it will be put in storage rather than kept in memory. */
                                ServeResourceHandler._resourceCachingLength = 200;
                                return ServeResourceHandler;
                            }());
                            offlineHandlers.ServeResourceHandler = ServeResourceHandler;
                        })(offlineHandlers = bundle_3.offlineHandlers || (bundle_3.offlineHandlers = {}));
                    })(bundle = offline.bundle || (offline.bundle = {}));
                })(offline = infrastructure.offline || (infrastructure.offline = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var offline;
                (function (offline) {
                    var bundle;
                    (function (bundle) {
                        var offlineHandlers;
                        (function (offlineHandlers) {
                            /**
                             * Handles requests for the site specially to inject the true principal if the user is authed.
                             */
                            var SiteHandler = (function () {
                                /**
                                 * @param siteJsonGetter Gets the stored site JSON.  The key passed in comes from the rule parameter.
                                 * @param unhackedRequesthandler Unhacked esri.request.
                                 */
                                function SiteHandler(app, siteJsonGetter, unhackedRequesthandler) {
                                    this.app = app;
                                    this.siteJsonGetter = siteJsonGetter;
                                    this.unhackedRequesthandler = unhackedRequesthandler;
                                    this.name = "Site";
                                }
                                SiteHandler.prototype.handle = function (request, rule, matches) {
                                    var _this = this;
                                    offlineHandlers.hookDeferredCallbacks(request);
                                    this.siteJsonGetter(rule.parameters["key"])
                                        .then(function (storedSiteJson) {
                                        // If there's no token, return the stored result.
                                        if (!_this._hasToken(request)) {
                                            return storedSiteJson;
                                        }
                                        // There's a token, try to get a principal for it.
                                        return _this._getOnlineSitePrincipal(request)
                                            .then(function (liveSitePrincipal) {
                                            // We got the principal from the online site.
                                            storedSiteJson.principal = liveSitePrincipal;
                                            return storedSiteJson;
                                        }, function (error) {
                                            // Well the live request didn't work, use the stored.
                                            return _this._getGmafPrincipal(storedSiteJson.principal)
                                                .then(function (gmafPrincipal) {
                                                storedSiteJson.principal = gmafPrincipal;
                                                return storedSiteJson;
                                            }, function (error) {
                                                // Fails everywhere.  Go with what we have.
                                                return storedSiteJson;
                                            });
                                        });
                                    })
                                        .then(function (siteJson) {
                                        request.dfd.resolve(siteJson);
                                    }, function (error) {
                                        request.dfd.errback(error);
                                    });
                                    return true;
                                };
                                SiteHandler.prototype._hasToken = function (request) {
                                    return /[?&]token=/.test(request.url) || (request.content && request.content.token);
                                };
                                SiteHandler.prototype._getOnlineSitePrincipal = function (request) {
                                    var _this = this;
                                    var unhackedRequest = new bundle.RequestContext({
                                        callbackParamName: request.callbackParamName,
                                        content: request.content,
                                        form: request.form,
                                        handleAs: request.handleAs,
                                        timeOut: 10000,
                                        url: request.url
                                    }, null, request.options);
                                    return new Promise(function (resolve, reject) { return _this.unhackedRequesthandler(unhackedRequest, unhackedRequest.options).then(resolve, reject); })
                                        .then(function (liveSiteJson) {
                                        if (!liveSiteJson || liveSiteJson.error || !liveSiteJson.principal) {
                                            // Well the live request didn't work, use the stored.
                                            throw new Error("Site JSON looks malformed.");
                                        }
                                        return liveSiteJson.principal;
                                    });
                                };
                                /**
                                 * Get a faked up principal object from GMAF using the security information it has.
                                 * This only works to present a security context while offline in GMAF, that can be
                                 * refreshed automatically when going online.
                                 * @param request
                                 */
                                SiteHandler.prototype._getGmafPrincipal = function (storedPrincipal) {
                                    if (!this.app.nativeManager.nativeInitialized) {
                                        return Promise.reject(new Error("Not a native app."));
                                    }
                                    return this.app.nativeManager
                                        .xhrGet({
                                        url: this.app.localServerAddress + "/account/userinfo",
                                        handleAs: "json"
                                    })
                                        .then(function (userinfo) {
                                        if (!userinfo || !userinfo.token) {
                                            throw new Error("GMAF has no login info.");
                                        }
                                        return dojo.mixin(storedPrincipal, {
                                            isAuthenticated: true,
                                            label: userinfo.userName,
                                            expiry: new Date().toISOString(),
                                            tokens: {
                                                site: userinfo.token
                                            }
                                        });
                                    });
                                };
                                return SiteHandler;
                            }());
                            offlineHandlers.SiteHandler = SiteHandler;
                        })(offlineHandlers = bundle.offlineHandlers || (bundle.offlineHandlers = {}));
                    })(bundle = offline.bundle || (offline.bundle = {}));
                })(offline = infrastructure.offline || (infrastructure.offline = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var offline;
                (function (offline) {
                    var bundle;
                    (function (bundle) {
                        /**
                         * Routes offline requests through request handlers.  This is done by hacking esri.request.
                         * The "Rewrite" request handler is the only handler installed by default.
                         */
                        var OfflineRouter = (function () {
                            function OfflineRouter(app) {
                                var _this = this;
                                this.app = app;
                                this.isReady = new Observable(false);
                                this._handlers = {};
                                this._rules = [];
                                this.app.command("RewriteUrlForOffline").register(this, function (url, callback) {
                                    callback(_this.rewriteUrl(url));
                                });
                            }
                            /**
                             * Add a request handler.  The handler function will be called to handle requests
                             * when a rule matching the given name has a pattern matching the request.
                             * @param handlerName The name of the handler.  This matches the RoutingRule handlerName.
                             * @param handler The handling function for the rule.
                             */
                            OfflineRouter.prototype.addHandler = function (handler) {
                                this._handlers[handler.name] = handler;
                            };
                            /**
                             * Remove a request handler.
                             * @param handlerName The name of the handler.
                             * @return Whether a handler was found and removed.
                             */
                            OfflineRouter.prototype.removeHandler = function (handlerName) {
                                if (this._handlers.hasOwnProperty(handlerName)) {
                                    delete this._handlers[handlerName];
                                    return true;
                                }
                                return false;
                            };
                            /**
                             * Set the handler to use when no other handlers match.  The handler will be called with
                             * rule and matches as null, as there is no rule that matched.
                             * @param handler
                             */
                            OfflineRouter.prototype.setDefaultHandler = function (handler) {
                                this._defaultHandler = handler;
                            };
                            /**
                             * Set the rules that determine how (offline) requests are routed.
                             * @param rules
                             */
                            OfflineRouter.prototype.setRoutingRules = function (rules) {
                                this._rules = rules.concat();
                                this.isReady.set(true);
                            };
                            /**
                             * Set the rules that determine how (offline) requests are routed from a promise.
                             * @param routingRulesJsonStringPromise
                             */
                            OfflineRouter.prototype.setRoutingRulesFromPromise = function (routingRulesJsonStringPromise) {
                                var _this = this;
                                this._rules.length = 0;
                                this.isReady.set(false);
                                routingRulesJsonStringPromise.then(function (routingRulesJsonString) {
                                    if (!routingRulesJsonString) {
                                        _this.app.trace.debug("No offline request routing table was found.");
                                        return;
                                    }
                                    try {
                                        _this.setRoutingRules(JSON.parse(routingRulesJsonString));
                                    }
                                    catch (error) {
                                        _this.app.trace.error("Unable to parse routing rules: {0}".format(error));
                                    }
                                }, function (error) {
                                    _this.app.trace.warning("An error occurred while attempting to fetch offline request routing rules: {0}".format(error));
                                });
                            };
                            /**
                             * Remove all routing rules.
                             */
                            OfflineRouter.prototype.clearRoutingRules = function () {
                                this._rules.length = 0;
                                this.isReady.set(false);
                            };
                            /**
                             * Check the tile URL against any "Rewrite" rules in the offline manifest and return
                             * the rewritten URL if there is a match.  Return null otherwise.
                             * @param url The URL to rewrite.
                             * @return The rewritten URL or null.
                             */
                            OfflineRouter.prototype.rewriteUrl = function (url) {
                                var rewriteHandler = this._handlers["Rewrite"];
                                if (!rewriteHandler) {
                                    // No Rewrite handler installed.
                                    return url;
                                }
                                url = this._stripOutProxy(url);
                                for (var i = 0; i < this._rules.length; ++i) {
                                    var rule = this._rules[i];
                                    if (rule.handlerName !== "Rewrite") {
                                        continue;
                                    }
                                    var exp = new RegExp(rule.pattern);
                                    var matches = exp.exec(url);
                                    // Did we find at least one match? Look for the handler associated with the rule and execute it.
                                    if (matches && matches.length && matches.length > 0) {
                                        return rewriteHandler.rewriteRequest(null, rule, matches);
                                    }
                                }
                                return null;
                            };
                            /**
                             * Handles (routes) an offline request.
                             */
                            OfflineRouter.prototype.handle = function (request, options) {
                                var _this = this;
                                var dfd = new dojo.Deferred();
                                this._whenReady(function () {
                                    var requestContext = new bundle.RequestContext(request, dfd, options);
                                    var requestUrl = _this._stripOutProxy(requestContext.url);
                                    // Give each handler a chance to process the request.
                                    var handled = false;
                                    // Sequentially evaluate the known rules. If we match a rule, we will execute the appropriate handler.
                                    // The handler may or may not handle the request.
                                    for (var i = 0; i < _this._rules.length; ++i) {
                                        var rule = _this._rules[i];
                                        // Match on the URL.
                                        var exp = new RegExp(rule.pattern);
                                        var matches = exp.exec(requestUrl);
                                        // Match on the content parameters
                                        var contentMatches = true;
                                        if (matches && rule.queryParameterPatterns) {
                                            for (var name in rule.queryParameterPatterns) {
                                                var valuePattern = rule.queryParameterPatterns[name];
                                                var parameterValue = request.content ? request.content[name] : null;
                                                var parameterMatcher = new RegExp(valuePattern.pattern);
                                                var parameterMatch = parameterMatcher.exec(parameterValue);
                                                contentMatches = contentMatches && !!parameterMatch;
                                            }
                                        }
                                        // Did we find at least one match? Look for the handler associated with the rule and execute it.
                                        if (matches && matches.length && matches.length > 0 && contentMatches) {
                                            var handler = _this._handlers[rule.handlerName];
                                            if (!handler) {
                                                _this.app.trace.warning("Offline request failed for resource '" + request.url + "'. Matching rule found without handler.");
                                            }
                                            else {
                                                handled = true;
                                                try {
                                                    // Run the handler against the request, passing it the matching rule and regex matches for context.
                                                    // Note: If the handler returns false, other rules will be allowed to be triggered.
                                                    if (handler.handle(requestContext, rule, matches) === false) {
                                                        handled = false;
                                                        continue;
                                                    }
                                                    else {
                                                        break;
                                                    }
                                                }
                                                catch (error) {
                                                    _this.app.trace.warning("Offline request failed for resource '" + request.url + "'. " + error);
                                                    dfd.errback(new Error("Offline request failed"));
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    // If we couldn't handle the response, use the default handler.
                                    if (!handled) {
                                        _this._defaultHandler.handle(requestContext, null, null);
                                    }
                                });
                                return dfd;
                            };
                            OfflineRouter.prototype._whenReady = function (callback) {
                                if (this.isReady.get()) {
                                    callback();
                                }
                                else {
                                    this.isReady.once(this, callback);
                                }
                            };
                            /**
                             * Strips out possible proxy prefix from an offline request.
                             */
                            OfflineRouter.prototype._stripOutProxy = function (url) {
                                if (!url) {
                                    return null;
                                }
                                var proxyUri = this.app.configuration.proxyUri;
                                if (url.indexOf(proxyUri) >= 0) {
                                    if (url.replace) {
                                        return url.replace(proxyUri, "");
                                    }
                                }
                                else {
                                    return url;
                                }
                                return null;
                            };
                            return OfflineRouter;
                        }());
                        bundle.OfflineRouter = OfflineRouter;
                    })(bundle = offline.bundle || (offline.bundle = {}));
                })(offline = infrastructure.offline || (infrastructure.offline = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var offline;
                (function (offline) {
                    var bundle;
                    (function (bundle) {
                        var RequestContext = (function () {
                            function RequestContext(mixin, dfd, options) {
                                this.options = null;
                                this.content = null;
                                this.handleAs = null;
                                this.timeOut = null;
                                this.url = null;
                                if (mixin) {
                                    dojo.mixin(this, mixin);
                                }
                                this.dfd = dfd || new dojo.Deferred();
                                this.options = options || null;
                            }
                            return RequestContext;
                        }());
                        bundle.RequestContext = RequestContext;
                    })(bundle = offline.bundle || (offline.bundle = {}));
                })(offline = infrastructure.offline || (infrastructure.offline = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var offline;
                (function (offline) {
                    var bundle;
                    (function (bundle) {
                        /**
                         * Builds an array of routing rules in the bundle.
                         * @return a dojo.Deferred<RoutingRule[]>
                         */
                        function buildRoutingRules(context) {
                            var routingRules = [
                                {
                                    handlerName: "Rewrite",
                                    pattern: "/arcgis/+rest/+services/+Utilities/+Geometry/+GeometryServer/+(.*)",
                                    parameters: { newUrl: "{localserver}/GeometryServer/{1}" }
                                },
                                {
                                    handlerName: "ServeResource",
                                    pattern: "/map/+layerlist$",
                                    parameters: { key: "__layerlist_" }
                                },
                                {
                                    handlerName: "ServeResource",
                                    pattern: "/search$",
                                    parameters: { key: "__no_search_results" }
                                },
                                {
                                    handlerName: "Site",
                                    pattern: bundle.urlToPattern(context.app.site.originalUrl) + "/*$",
                                    parameters: { key: "__site_" }
                                }
                            ];
                            var processedMapServiceUrls = [];
                            var mapServices = context.app.site.essentialsMap.mapServices;
                            if (context.app.site.overviewMap) {
                                mapServices = mapServices.concat(context.app.site.overviewMap.mapServices);
                            }
                            mapServices.forEach(function (mapService) {
                                // Don't add duplicates.  Overview map and regular map may or may not share map services.
                                if (processedMapServiceUrls.indexOf(mapService.url) !== -1) {
                                    return;
                                }
                                processedMapServiceUrls.push(mapService.url);
                                var attributionUrl = (mapService.serviceLayer && mapService.serviceLayer.attributionDataUrl) || mapService.attributionDataUrl;
                                if (attributionUrl) {
                                    routingRules.push({
                                        handlerName: "ServeResource",
                                        pattern: bundle.urlToPattern(attributionUrl),
                                        parameters: { key: "__empty_attribution_response" }
                                    });
                                }
                                var mapServiceUrlPattern = bundle.urlToPattern(bundle.cleanUpMapServiceUrl(context, mapService));
                                if (mapService.mapServiceType === geocortex.essentials.MapServiceType.BING || mapService.mapServiceType === geocortex.essentials.MapServiceType.WMS) {
                                    routingRules = routingRules.concat(getRewriteToBlankTileRoutingRules(mapServiceUrlPattern));
                                    return;
                                }
                                if (mapService.mapServiceType === geocortex.essentials.MapServiceType.WMTS || mapService.mapServiceType === geocortex.essentials.MapServiceType.WEBTILED) {
                                    routingRules = routingRules.concat(getWebTileSericeRoutingRules(mapServiceUrlPattern));
                                    return;
                                }
                                if (mapService instanceof geocortex.essentials.FeatureLayerService) {
                                    routingRules = routingRules.concat(getFeatureServiceRoutingRules(mapServiceUrlPattern, mapService, context));
                                }
                                else {
                                    // Add new patterns for map services.
                                    routingRules = routingRules.concat(getMapServiceRoutingRules(mapServiceUrlPattern, mapService, context));
                                }
                                if (mapService.mapServiceType === geocortex.essentials.MapServiceType.TILED) {
                                    routingRules = routingRules.concat(getTileServiceRoutingRules(mapServiceUrlPattern, mapService, context));
                                }
                                if (mapService.mapServiceFunction !== geocortex.essentials.MapServiceFunction.BASE && !(mapService instanceof geocortex.essentials.FeatureLayerService)) {
                                    routingRules = routingRules.concat(getMapServiceOperationRejectedRoutingRules(mapServiceUrlPattern));
                                }
                                routingRules.push({
                                    handlerName: "ServeResource",
                                    pattern: mapServiceUrlPattern + "/*$",
                                    parameters: { key: mapServiceUrlPattern }
                                });
                            });
                            // Data links are not supported offline
                            routingRules.push({
                                handlerName: "ServeResource",
                                pattern: "/+map/+mapservices/+[0-9]+/+layers/+[0-9]+/+datalinks/+[^/]+/+link$",
                                parameters: {
                                    key: "__no_data_links"
                                }
                            });
                            return routingRules;
                        }
                        bundle.buildRoutingRules = buildRoutingRules;
                        function getRewriteToBlankTileRoutingRules(pattern) {
                            return [
                                {
                                    handlerName: "Rewrite",
                                    pattern: pattern,
                                    parameters: { newUrl: "Resources/Images/blank-tile.png" }
                                }
                            ];
                        }
                        function getMapServiceRoutingRules(mapServiceUrlPattern, mapService, context) {
                            var routingRules = [];
                            var serviceLayerUrl = mapService.serviceLayer.url.indexOf("?") !== -1 ?
                                mapService.serviceLayer.url.substr(0, mapService.serviceLayer.url.indexOf("?")) : mapService.serviceLayer.url;
                            serviceLayerUrl = serviceLayerUrl.toLowerCase();
                            var serverSyncInfo = context.featureLayerSyncInfo.servers.filter(function (s) { return !!s.layers.filter(function (x) { return s.featureServiceUrl.toLowerCase() === serviceLayerUrl; })[0]; })[0];
                            if (serverSyncInfo) {
                                // Route *all* map service operations through to the local server when offline
                                // Includes: query, queryRelatedRecords, identify, find, applyEdits, addAttachment, deleteAttachments, updateAttachment, and maybe more!
                                routingRules.push({
                                    handlerName: "Rewrite",
                                    pattern: mapServiceUrlPattern + "/+(.+)",
                                    parameters: { newUrl: serverSyncInfo.localServerUrl.replace("FeatureServer", "MapServer") + "/{1}" }
                                });
                            }
                            else {
                                routingRules = routingRules.concat(getMapServiceOperationRejectedRoutingRules(mapServiceUrlPattern));
                            }
                            return routingRules;
                        }
                        function getWebTileSericeRoutingRules(mapServiceUrlPattern) {
                            mapServiceUrlPattern = decodeURI(mapServiceUrlPattern).replace(/%24/g, "$"); // decodeURI() doesn't decode the dollar sign ($)
                            return [
                                {
                                    handlerName: "Rewrite",
                                    pattern: mapServiceUrlPattern
                                        .replace(/\$?{subDomain}/ig, "(?:.*)")
                                        .replace(/\$?{level}/ig, "[0-9]*")
                                        .replace(/\$?{row}/ig, "[0-9]*")
                                        .replace(/\$?{col}/ig, "[0-9]*"),
                                    parameters: { newUrl: "Resources/Images/blank-tile.png" }
                                }
                            ];
                        }
                        function getFeatureServiceRoutingRules(mapServiceUrlPattern, mapService, context) {
                            var routingRules = [];
                            // Strip out the last /0 or whatever.
                            var featureServiceUrlPattern = /^(.*)(\/\+?[0-9]+\/?\+?)$/.exec(mapServiceUrlPattern)[1];
                            var featureServiceRegexMatch = /^(.*)\/([0-9]+\/?)$/.exec(mapService.serviceUrl);
                            var featureServiceUrl = featureServiceRegexMatch[1];
                            var layerId = parseInt(featureServiceRegexMatch[2]);
                            // This can cause duplicate entries, live with it.
                            routingRules.push({
                                handlerName: "ServeResource",
                                pattern: featureServiceUrlPattern + "/*$",
                                parameters: { key: featureServiceUrlPattern }
                            });
                            // Feature layer operations / endpoints
                            // Find a match entry in the feature layer sync info
                            var serviceLayerUrl = mapService.serviceLayer.url.indexOf("?") !== -1 ?
                                mapService.serviceLayer.url.substr(0, mapService.serviceLayer.url.indexOf("?")) : mapService.serviceLayer.url;
                            serviceLayerUrl = serviceLayerUrl.toLowerCase();
                            var serverSyncInfo = context.featureLayerSyncInfo.servers.filter(function (s) { return !!s.layers.filter(function (x) { return (s.featureServiceUrl + "/" + x.id).toLowerCase() === serviceLayerUrl; })[0]; })[0];
                            if (serverSyncInfo) {
                                // Route *all* feature layer operations through to the local server when offline
                                // Includes: query, queryRelatedRecords, identify, find, applyEdits, addAttachment, deleteAttachments, updateAttachment, and maybe more!
                                routingRules.push({
                                    handlerName: "Rewrite",
                                    pattern: mapServiceUrlPattern + "/+(.+)",
                                    parameters: { newUrl: serverSyncInfo.localServerUrl + "/" + layerId + "/{1}" }
                                });
                            }
                            else {
                                routingRules = routingRules.concat(getLayerOperationRejectedRoutingRules(featureServiceUrlPattern, layerId));
                            }
                            // Related tables... Add a handler for serving up the table JSON.
                            var relatedTableRoutingRules2D = mapService.serviceLayer.relationships.map(function (relationship) { return getRelatedTableRoutingRules(featureServiceUrlPattern, featureServiceUrl, serverSyncInfo ? serverSyncInfo.localServerUrl : null, relationship, context); });
                            routingRules = routingRules.concat.apply(routingRules, relatedTableRoutingRules2D);
                            return routingRules;
                        }
                        function getRelatedTableRoutingRules(featureServiceUrlPattern, featureServiceUrl, localServerUrl, relationship, context) {
                            var routingRules = [{
                                    handlerName: "ServeResource",
                                    pattern: featureServiceUrlPattern + "/+" + relationship.relatedTableId + "/*$",
                                    parameters: { key: featureServiceUrlPattern + "/+" + relationship.relatedTableId }
                                }];
                            var tableIsSynced = localServerUrl && context.featureLayerSyncInfo.servers
                                .filter(function (syncInfo) { return syncInfo.featureServiceUrl === featureServiceUrl; })
                                .some(function (syncInfo) { return syncInfo.layers && syncInfo.layers.some(function (layerInfo) { return layerInfo.id === relationship.relatedTableId; }); });
                            if (tableIsSynced) {
                                // Add handlers for the server operations / endpoints
                                routingRules.push({
                                    handlerName: "Rewrite",
                                    pattern: featureServiceUrlPattern + "/+" + relationship.relatedTableId + "/+(.+)",
                                    parameters: { newUrl: localServerUrl + "/" + relationship.relatedTableId + "/{1}" }
                                });
                            }
                            else {
                                routingRules = routingRules.concat(getLayerOperationRejectedRoutingRules(featureServiceUrlPattern, relationship.relatedTableId));
                            }
                            return routingRules;
                        }
                        function getTileServiceRoutingRules(mapServiceUrlPattern, mapService, context) {
                            var basemapConfiguration = context.basemaps.filter(function (basemap) { return basemap.url === mapService.url || basemap.url === mapService.serviceUrl; })[0];
                            if (basemapConfiguration) {
                                var n = numCapturingGroups(mapServiceUrlPattern);
                                return [
                                    {
                                        handlerName: "Rewrite",
                                        pattern: mapServiceUrlPattern + "/+tile/+([0-9]*)/+([0-9]*)/+([0-9]*)",
                                        parameters: { newUrl: "{localserver}/" + basemapConfiguration.localServicePath + "/{{{0}}}/{{{1}}}/{{{2}}}".format(n + 1, n + 2, n + 3) }
                                    }
                                ].concat(getMapServiceOperationRejectedRoutingRules(mapServiceUrlPattern));
                            }
                            else {
                                return getRewriteToBlankTileRoutingRules(mapServiceUrlPattern + "/+(tile|tilemap)").concat(getMapServiceOperationRejectedRoutingRules(mapServiceUrlPattern));
                            }
                        }
                        function getMapServiceOperationRejectedRoutingRules(mapServiceUrlPattern) {
                            // Operations are listed in the service rest endpoint, but Essentials doesn't expose it. Just do every operation.
                            return [
                                {
                                    handlerName: "ServeResource",
                                    pattern: mapServiceUrlPattern + "/+([^/]*/+)?(query|queryRelatedRecords|identify|find)",
                                    parameters: { key: "__no_features" }
                                }
                            ];
                        }
                        function getLayerOperationRejectedRoutingRules(featureServiceUrlPattern, layerId) {
                            // Operations are listed in the service rest endpoint, but Essentials doesn't expose it. Just do every operation.
                            return [
                                {
                                    handlerName: "ServeResource",
                                    pattern: featureServiceUrlPattern + "/+" + layerId + "/+(query|queryRelatedRecords|applyEdits)",
                                    parameters: { key: "__no_features" }
                                }
                            ];
                        }
                        /**
                         * Get the number of capturing groups in the given regular expression.
                         * eg /foo(bar|baz)/ has 1, /(?:http|ftp):/ has 0 because of the non-capturing group.
                         */
                        function numCapturingGroups(pattern) {
                            var regex;
                            if (pattern instanceof RegExp) {
                                var patternAsString = pattern.toString();
                                // At this point patternAsString has a leading and trailing /.
                                patternAsString = patternAsString.substring(1, patternAsString.length - 2);
                                regex = new RegExp(patternAsString + "|");
                            }
                            else {
                                regex = new RegExp(pattern.toString() + "|");
                            }
                            return regex.exec("").length - 1;
                        }
                    })(bundle = offline.bundle || (offline.bundle = {}));
                })(offline = infrastructure.offline || (infrastructure.offline = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                /**
                 * Masks everything outside of a certain area of interest (AOI).
                 */
                var AreaOfInterestMask = (function () {
                    function AreaOfInterestMask(app, config) {
                        this.app = app;
                        this._enabled = true;
                        /**
                          * Whether to set the map background color to be the same as the fill color. This can be be useful because the
                          * mask may not reach all the way to the outer edges of the map. Setting this to true will ensure full coverage.
                          */
                        this.matchMapBackground = false;
                        /**
                          * The color of the mask.
                          */
                        this.fillColor = null;
                        /**
                          * The color of the AOI outline.
                          */
                        this.boundaryColor = new esri.Color("red");
                        /**
                          * The thickness of the AOI otuline.
                          */
                        this.boundaryWidth = 2;
                        /**
                          * The style of the AOI otuline.
                          */
                        this.boundaryStyle = esri.symbol.SimpleLineSymbol.STYLE_SOLID;
                        /**
                          * The layer id to use for map graphics.
                          */
                        this.layerId = "AreaOfInterestMask";
                    }
                    /**
                     * Shows the mask. Will not be shown if the mask is disabled.
                     * @param areaOfInterest The area of interest to to be visible. Everything outside of this will be hidden.
                     */
                    AreaOfInterestMask.prototype.show = function (areaOfInterest) {
                        var _this = this;
                        this._aoi = areaOfInterest;
                        this.app.waitUntilSiteServiceLayersLoaded().then(function () {
                            if (!_this._enabled) {
                                return;
                            }
                            // Layer
                            var maskLayer = _this._getLayer();
                            maskLayer.clear();
                            if (_this.fillColor || _this.boundaryStyle !== esri.symbol.SimpleFillSymbol.STYLE_NULL) {
                                maskLayer.show();
                            }
                            // Mask
                            if (_this.fillColor) {
                                var maskGeom = new esri.geometry.Polygon(areaOfInterest.spatialReference);
                                var bottomService = _this.app.map.getLayer(_this.app.map.layerIds[0]);
                                var outer = infrastructure.GeometryUtils.toRing(bottomService.fullExtent.expand(1.5));
                                for (var i = 0; i < areaOfInterest.rings.length; i++) {
                                    var ring = areaOfInterest.rings[i];
                                    maskGeom.rings.push(dojo.clone(ring).reverse());
                                }
                                maskGeom.rings.push(outer);
                                var maskSymbol = new esri.symbol.SimpleFillSymbol(esri.symbol.SimpleFillSymbol.STYLE_SOLID, new esri.symbol.SimpleLineSymbol(esri.symbol.SimpleLineSymbol.STYLE_NULL), _this.fillColor);
                                var maskGraphic = new esri.Graphic({ geometry: maskGeom });
                                maskGraphic.setSymbol(maskSymbol);
                                _this.app.map.graphics.add(maskGraphic);
                            }
                            // Boundary
                            if (_this.boundaryStyle !== esri.symbol.SimpleFillSymbol.STYLE_NULL) {
                                var boundarySymbol = new esri.symbol.SimpleFillSymbol(esri.symbol.SimpleFillSymbol.STYLE_NULL, new esri.symbol.SimpleLineSymbol(_this.boundaryStyle, _this.boundaryColor, _this.boundaryWidth), new esri.Color("white"));
                                var boundaryGraphic = new esri.Graphic({ geometry: areaOfInterest });
                                boundaryGraphic.setSymbol(boundarySymbol);
                                maskLayer.add(boundaryGraphic);
                            }
                            // Also set the background colour of the map to match the mask, in case the mask doesn't completely cover the map
                            if (_this.matchMapBackground && _this.fillColor) {
                                var mapNode = _this._getMapNode();
                                _this._originalMapBackground = mapNode.css("background-color");
                                mapNode.css("background-color", "rgba(" + _this.fillColor.r + "," + _this.fillColor.g + "," + _this.fillColor.b + "," + _this.fillColor.a + ")");
                            }
                        });
                    };
                    /**
                     * Eliminates the mask.
                     */
                    AreaOfInterestMask.prototype.hide = function () {
                        this._aoi = null;
                        var layer = this.app.map.getLayer(this.layerId);
                        if (layer) {
                            this.app.map.removeLayer(layer);
                        }
                        if (this.matchMapBackground) {
                            this._getMapNode().css("background-color", this._originalMapBackground);
                        }
                    };
                    /**
                     * Enables the mask. If it was not enabled while show() was called, this method will actually show the mask.
                     */
                    AreaOfInterestMask.prototype.enable = function () {
                        this._enabled = true;
                        if (this._aoi) {
                            this.show(this._aoi);
                        }
                    };
                    /**
                     * Disables the mask. If show() is called while disabled, it will not actually be shown.
                     */
                    AreaOfInterestMask.prototype.disable = function () {
                        this._enabled = false;
                    };
                    /**
                     * Configures this AreaOfInterestMask to match the properties specified in the config. Any properties that are null
                     * or undefined will retain their existing values.
                     */
                    AreaOfInterestMask.prototype.configure = function (config) {
                        if (config) {
                            if (!geocortex.framework.utils.isNullOrUndefined(config.boundaryColor)) {
                                this.boundaryColor = new esri.Color(config.boundaryColor);
                            }
                            if (!geocortex.framework.utils.isNullOrUndefined(config.boundaryWidth)) {
                                this.boundaryWidth = config.boundaryWidth;
                            }
                            if (!geocortex.framework.utils.isNullOrUndefined(config.boundaryStyle)) {
                                if (config.boundaryStyle == "null") {
                                    this.boundaryStyle = esri.symbol.SimpleLineSymbol.STYLE_NULL;
                                }
                                else if (config.boundaryStyle == "solid") {
                                    this.boundaryStyle = esri.symbol.SimpleLineSymbol.STYLE_SOLID;
                                }
                                else if (config.boundaryStyle == "dash") {
                                    this.boundaryStyle = esri.symbol.SimpleLineSymbol.STYLE_DASH;
                                }
                                else if (config.boundaryStyle == "dot") {
                                    this.boundaryStyle = esri.symbol.SimpleLineSymbol.STYLE_DOT;
                                }
                            }
                            if (!geocortex.framework.utils.isNullOrUndefined(config.enabled)) {
                                if (config.enabled) {
                                    this.enable();
                                }
                                else {
                                    this.disable();
                                }
                            }
                            if (!geocortex.framework.utils.isNullOrUndefined(config.fillColor)) {
                                this.fillColor = new esri.Color(config.fillColor);
                            }
                            if (!geocortex.framework.utils.isNullOrUndefined(config.layerId)) {
                                this.layerId = config.layerId;
                            }
                            if (!geocortex.framework.utils.isNullOrUndefined(config.matchMapBackground)) {
                                this.matchMapBackground = config.matchMapBackground;
                            }
                        }
                    };
                    AreaOfInterestMask.prototype._getLayer = function () {
                        var layer = this.app.map.getLayer(this.layerId);
                        if (!layer) {
                            layer = new esri.layers.GraphicsLayer({ id: this.layerId });
                            this.app.map.addLayer(layer);
                        }
                        return layer;
                    };
                    AreaOfInterestMask.prototype._getMapNode = function () {
                        return $(".esriMapContainer").first().parent();
                    };
                    return AreaOfInterestMask;
                }());
                infrastructure.AreaOfInterestMask = AreaOfInterestMask;
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var offline;
                (function (offline) {
                    /**
                     * Manages offline state.  Chief among the offline state is the offline map
                     * which defines what data will be available offline and how offline requests
                     * are handled.  Offline profiles that are added may be activated when offline.
                     */
                    var OfflineManager = (function () {
                        function OfflineManager(app, libraryId) {
                            this.app = app;
                            this.libraryId = libraryId;
                            this._activeOfflineMapId = null;
                            // Need to track the previous active offline map so that if the user attempts to launch the application without internet 
                            // connectivity, but the previous state of the application did not have an active offline map, then we should restore 
                            // the previous active offline map.
                            this._previousActiveOfflineMapId = null;
                            this._offlineMaps = [];
                            /** Whether or not the current job can be canceled */
                            this.canCancel = new Observable(false);
                            /**
                             * An indiciator of whether or not there is an active offline map.
                             * This property is preferable to app.isOffline (which is deprecated) because it more accurately describes
                             * the state of the application. There is no binary online/offline switch, so app.isOffline is misleading.
                             * Even though an offline map is active, the device may still have internet connectivity.
                             */
                            this.isOfflineMapActive = new Observable(false);
                            this._bundleManager = new offline.bundle.BundleManager(app, libraryId);
                            this.aoiMask = new infrastructure.AreaOfInterestMask(app, { enabled: false });
                        }
                        /**
                         * Add an offline map.  The site information and features are downloaded.
                         * @param offlineMap The offline map to add.
                         * @param progress An optional callback for a stream of progress messages.
                         */
                        OfflineManager.prototype.addOfflineMap = function (offlineMap, progress) {
                            var _this = this;
                            return this._lastOperation = this._waitForLast().finally(function () {
                                offline.OfflineMap.verify(offlineMap);
                                _this._throwIfNotNativeInitialized();
                                // Start by being not cancelled
                                _this.canCancel.set(true);
                                _this._cancellationTokenSource = new infrastructure.CancellationTokenSource();
                                // If no handler, create a do-nothing handler so we don't need to check this variable all the time
                                if (!progress) {
                                    progress = function () { };
                                }
                                // Calculate the amount of work that needs to be done using a heuristic
                                var workDescription = offline.WorkCalculator.calculateFirstDownloadWork(offlineMap);
                                var completedWork = offline.WorkCalculator.noWork();
                                var percentage = function () { return offline.WorkCalculator.calculatePercentageComplete(completedWork, workDescription); };
                                // Update map service tokens
                                return Promise.resolve(_this.app.site.updateServiceTokensIfStale())
                                    .then(function () { return _this._appStoreSetPromise(_this._getOfflineMapKey(offlineMap), JSON.stringify(offlineMap)); })
                                    .then(function () {
                                    progress({ message: _this.getResource("language-offline-progress-savingofflinemap"), percentage: percentage() });
                                    _this._offlineMaps.push(offlineMap);
                                    return _this._save();
                                })
                                    .then(function () {
                                    // Download feature layers
                                    _this._throwIfCanceled();
                                    completedWork.saveProfileWork = workDescription.saveProfileWork; // Save profile work is complete
                                    progress({ message: _this.getResource("language-offline-progress-starting-sync"), percentage: percentage() });
                                    var syncParams = offline.SyncParameters.buildSyncParameters(_this.app, offlineMap);
                                    return offline.SyncEngine.sync(_this.app, syncParams, _this._cancellationTokenSource.token(), function (syncProgress) {
                                        completedWork.featureLayerWork = (syncProgress.overallProgress / 100) * workDescription.featureLayerWork;
                                        progress({ message: syncProgress.text, percentage: percentage() });
                                    });
                                })
                                    .then(function () {
                                    // Download basemaps
                                    _this._throwIfCanceled();
                                    completedWork.featureLayerWork = workDescription.featureLayerWork; // Feature layer work is complete
                                    progress({ message: _this.getResource("language-offline-progress-starting-basemap-download"), percentage: percentage() });
                                    return offline.downloadBasemaps(_this.app, offlineMap, _this._cancellationTokenSource.token(), function (basemapProgress) {
                                        completedWork.basemapWork = (basemapProgress.percentage / 100) * workDescription.basemapWork;
                                        progress({ message: basemapProgress.message, percentage: percentage(), isWarning: basemapProgress.isWarning });
                                    });
                                })
                                    .then(function () {
                                    // Create bundle
                                    _this._throwIfCanceled();
                                    completedWork.basemapWork = workDescription.basemapWork; // Basemap work is complete
                                    progress({ message: _this.getResource("language-offline-progress-downloadingsite"), percentage: percentage() });
                                    return _this._bundleManager.createBundle(offlineMap.id, _this._getOfflineMapBasemapMapping(offlineMap));
                                })
                                    .then(function () {
                                    // Done / raise-event
                                    _this._throwIfCanceled();
                                    completedWork.bundleWork = workDescription.bundleWork; // Bundle work is complete
                                    progress({ message: _this.getResource("language-offline-progress-complete"), percentage: percentage() });
                                    // Raise event
                                    _this.app.event("OfflineMapAddedEvent").publish({
                                        offlineMap: offlineMap
                                    });
                                })
                                    .catch(function (error) {
                                    // We need to revert all changes that have been committed thus far.
                                    // We can do this by simply removing the offline map. We don't actually want the user to see
                                    // any progress about this happening - it should just happen in the background without the user
                                    // being aware. So that's why this promise is explicitly not returned.
                                    _this._removeOfflineMapNow(offlineMap, function () { });
                                    throw new Error(error);
                                })
                                    .finally(function () {
                                    _this._cancellationTokenSource.dispose();
                                    _this._cancellationTokenSource = null;
                                    _this.canCancel.set(false);
                                });
                            });
                        };
                        /**
                         * Remove an offline map.  The site information and feature data is deleted.
                         * @param offlineMap The offline map to remove, or its ID.
                         * @param progress An optional callback for a stream of progress messages.
                         */
                        OfflineManager.prototype.removeOfflineMap = function (offlineMap, progress) {
                            var _this = this;
                            return this._lastOperation = this._waitForLast().finally(function () { return _this._removeOfflineMapNow(offlineMap, progress); });
                        };
                        /**
                         * Remove an offline map right now, without waiting for the previous operation to complete.
                         */
                        OfflineManager.prototype._removeOfflineMapNow = function (offlineMap, progress) {
                            var _this = this;
                            if (!offlineMap) {
                                throw new Error(this.getResource("language-offline-errors-offlinemapnull"));
                            }
                            this._throwIfNotNativeInitialized();
                            var offlineMapIx = this._getOfflineMapIx(offlineMap);
                            if (offlineMapIx === -1) {
                                throw new Error(this.getResource("language-offline-errors-notfound"));
                            }
                            if (this._offlineMaps[offlineMapIx].id === this._activeOfflineMapId) {
                                throw new Error(this.getResource("language-offline-errors-isactive"));
                            }
                            return offline.SyncEngine.deleteData(this.app, this._offlineMaps[offlineMapIx].id)
                                .catch(function (error) {
                                _this.app.trace.error("Error deleting feature data: " + error);
                            })
                                .then(function () {
                                if (progress) {
                                    progress(_this.getResource("language-offline-progress-unregisteringreplica"));
                                }
                                return _this._bundleManager.deleteBundle(_this._offlineMaps[offlineMapIx].id);
                            })
                                .catch(function (error) {
                                _this.app.trace.error("Error deleting bundle: " + error);
                            })
                                .then(function () {
                                if (progress) {
                                    progress(_this.getResource("language-offline-progress-removingofflinemap"));
                                }
                                var basemapsToDelete = _this._offlineMaps[offlineMapIx].content.basemaps
                                    .filter(function (basemap) { return basemap.sourceType === offline.OfflineMapBasemap.Type.EXPORT_TILES; });
                                offline.deleteBasemaps(_this.app, basemapsToDelete)
                                    .then(null, function (error) {
                                    _this.app.trace.error("Error deleting offline map. " + error);
                                });
                                return _this._appStoreRemovePromise(_this._getOfflineMapKey(offlineMap));
                            })
                                .catch(function (error) {
                                _this.app.trace.error("Error deleting offline map. " + error);
                            })
                                .then(function () {
                                if (_this._offlineMaps[offlineMapIx].id === _this._previousActiveOfflineMapId) {
                                    _this._previousActiveOfflineMapId = null;
                                }
                                _this._offlineMaps.splice(offlineMapIx, 1);
                                return _this._save();
                            })
                                .finally(function () {
                                _this.app.event("OfflineMapRemovedEvent").publish({
                                    offlineMap: offlineMap
                                });
                            });
                        };
                        /**
                         * Sync an offline map.  Edits are sent to the server, then feature data redownloaded,
                         * then the site data is redownloaded.
                         * @param offlineMap The offline map to sync, or its ID.
                         * @param progress An optional callback for a stream of progress messages.
                         */
                        OfflineManager.prototype.syncOfflineMap = function (offlineMap, progress) {
                            var _this = this;
                            return this._lastOperation = this._waitForLast().finally(function () {
                                if (!offlineMap) {
                                    throw new Error(_this.getResource("language-offline-errors-offlinemapnull"));
                                }
                                var offlineMapIx = _this._getOfflineMapIx(offlineMap);
                                if (offlineMapIx === -1) {
                                    throw new Error(_this.getResource("language-offline-errors-notfound"));
                                }
                                _this._throwIfNotNativeInitialized();
                                // Make sure we've got a reference to an actual OfflineMap and not just its id
                                if (typeof offlineMap === "string" || offlineMap instanceof String) {
                                    offlineMap = _this._offlineMaps[offlineMapIx];
                                }
                                // If the offline map changes significantly those parts will have to be regenerated.
                                var offlineMapChanges = null;
                                if (offlineMap !== _this._offlineMaps[offlineMapIx]) {
                                    offlineMapChanges = offline.OfflineMap.diff(_this._offlineMaps[offlineMapIx], offlineMap);
                                }
                                // Start by being not cancelled
                                _this.canCancel.set(true);
                                _this._cancellationTokenSource = new infrastructure.CancellationTokenSource();
                                // Calculate the amount of work that needs to be done using a heuristic
                                var workDescription = offline.WorkCalculator.calculateSyncWork(offlineMap);
                                var completedWork = offline.WorkCalculator.noWork();
                                var percentage = function () { return offline.WorkCalculator.calculatePercentageComplete(completedWork, workDescription); };
                                // Update map service tokens
                                return Promise.resolve(_this.app.site.updateServiceTokensIfStale())
                                    .then(function () {
                                    // Sync feature layers
                                    var syncParams = offline.SyncParameters.buildSyncParameters(_this.app, offlineMap);
                                    return offline.SyncEngine.sync(_this.app, syncParams, _this._cancellationTokenSource.token(), function (syncProgress) {
                                        completedWork.featureLayerWork = (syncProgress.overallProgress / 100) * workDescription.featureLayerWork;
                                        progress({ message: syncProgress.text, percentage: percentage() });
                                    });
                                })
                                    .then(function () {
                                    // Delete out-dated basemaps
                                    _this._throwIfCanceled();
                                    completedWork.featureLayerWork = workDescription.featureLayerWork; // Feature layer work is complete
                                    var basemapsToDelete = [];
                                    if (offlineMapChanges && offlineMapChanges.content && offlineMapChanges.content.geometry) {
                                        // If the geometry changed then all our custom offline basemaps are trash.
                                        basemapsToDelete = _this._offlineMaps[offlineMapIx].content.basemaps
                                            .filter(function (basemap) { return basemap.sourceType === offline.OfflineMapBasemap.Type.EXPORT_TILES; });
                                    }
                                    else if (offlineMapChanges && offlineMapChanges.content && offlineMapChanges.content.basemaps) {
                                        // Any entry that isn't exactly the same must be trashed.
                                        basemapsToDelete = _this._offlineMaps[offlineMapIx].content.basemaps
                                            .filter(function (basemap) { return basemap.sourceType === offline.OfflineMapBasemap.Type.EXPORT_TILES; })
                                            .filter(function (basemap) { return !offlineMapChanges.content.basemaps.some(function (newBasemap) {
                                            return newBasemap.baseMapId === basemap.baseMapId
                                                && newBasemap.sourceType === basemap.sourceType
                                                && newBasemap.url === basemap.url
                                                && newBasemap.minLevel === basemap.minLevel
                                                && newBasemap.maxLevel === basemap.maxLevel;
                                        }); });
                                    }
                                    return basemapsToDelete.length > 0 ? offline.deleteBasemaps(_this.app, basemapsToDelete) : null;
                                })
                                    .then(function () {
                                    // Download basemaps
                                    _this._throwIfCanceled();
                                    progress({ message: _this.getResource("language-offline-progress-starting-basemap-download"), percentage: percentage() });
                                    return offline.downloadBasemaps(_this.app, offlineMap, _this._cancellationTokenSource.token(), function (basemapProgress) {
                                        completedWork.basemapWork = (basemapProgress.percentage / 100) * workDescription.basemapWork;
                                        progress({ message: basemapProgress.message, percentage: percentage(), isWarning: basemapProgress.isWarning });
                                    });
                                })
                                    .then(function () {
                                    // Update bundle
                                    _this._throwIfCanceled();
                                    _this.canCancel.set(false); // We've passed the point of no return - the user can longer cancel
                                    completedWork.basemapWork = workDescription.basemapWork; // Basemap work is complete
                                    progress({ message: _this.getResource("language-offline-progress-downloadingsite"), percentage: percentage() });
                                    return _this._bundleManager.updateBundle(offlineMap.id, _this._getOfflineMapBasemapMapping(offlineMap));
                                })
                                    .then(function () {
                                    // Save the offline map if it changed
                                    if (!offlineMapChanges) {
                                        return null;
                                    }
                                    progress({ message: _this.getResource("language-offline-progress-savingofflinemap"), percentage: percentage() });
                                    return _this._appStoreSetPromise(_this._getOfflineMapKey(offlineMap), JSON.stringify(offlineMap));
                                })
                                    .then(function () {
                                    if (!offlineMapChanges) {
                                        return null;
                                    }
                                    _this._offlineMaps.splice(offlineMapIx, 1, offlineMap);
                                    return _this._save();
                                })
                                    .then(function () {
                                    // Done / raise-event
                                    completedWork.bundleWork = workDescription.bundleWork; // Bundle work is complete
                                    progress({ message: _this.getResource("language-offline-progress-complete"), percentage: percentage() });
                                    _this._offlineMaps[offlineMapIx] = offlineMap; // Update the reference to the offline map that is now synced
                                    // Refresh AOI mask with latest geometry
                                    _this.aoiMask.show(new esri.geometry.Polygon(_this._offlineMaps[offlineMapIx].content.geometry));
                                    // Refresh layers
                                    _this.app.site.essentialsMap.mapServices.forEach(function (x) { return x.refresh(); });
                                    // Raise event
                                    _this.app.event("OfflineMapSyncedEvent").publish({
                                        offlineMap: offlineMap
                                    });
                                })
                                    .finally(function () {
                                    // 7. Clean up
                                    _this._cancellationTokenSource.dispose();
                                    _this._cancellationTokenSource = null;
                                    _this.canCancel.set(false);
                                });
                            });
                        };
                        /**
                         * Updates the bundle for an offline map without syncing.
                         * @param offlineMap The offline map to sync, or its ID.
                         */
                        OfflineManager.prototype.updateBundle = function (offlineMap) {
                            var _this = this;
                            return this._lastOperation = this._waitForLast().finally(function () {
                                if (!offlineMap) {
                                    throw new Error(_this.getResource("language-offline-errors-offlinemapnull"));
                                }
                                var offlineMapIx = _this._getOfflineMapIx(offlineMap);
                                if (offlineMapIx === -1) {
                                    throw new Error(_this.getResource("language-offline-errors-notfound"));
                                }
                                _this._throwIfNotNativeInitialized();
                                return _this._bundleManager.updateBundle(_this._offlineMaps[offlineMapIx].id, _this._getOfflineMapBasemapMapping(_this._offlineMaps[offlineMapIx]));
                            });
                        };
                        /**
                         * Make an offline map active.  When offline this is the data from which offline
                         * data is served.
                         * @param offlineMap The offline map to make active, or its ID.
                         * @param userAction Set to true if the activation is happening as a result of the user
                         * explicitly clicking a button to activate the offline map. Set to false if the activation
                         * is happening automatically without the user explicitly activating the offline map.
                         */
                        OfflineManager.prototype.activateOfflineMap = function (offlineMap, userAction) {
                            var _this = this;
                            return this._lastOperation = this._waitForLast().finally(function () {
                                if (!offlineMap) {
                                    throw new Error(_this.getResource("language-offline-errors-offlinemapnull"));
                                }
                                var offlineMapIx = _this._getOfflineMapIx(offlineMap);
                                if (offlineMapIx === -1) {
                                    throw new Error(_this.getResource("language-offline-errors-notfound"));
                                }
                                _this._throwIfNotNativeInitialized();
                                var lastActiveOfflineMapId = _this._activeOfflineMapId;
                                _this._activeOfflineMapId = _this._offlineMaps[offlineMapIx].id;
                                return _this._bundleManager.loadBundle(_this._activeOfflineMapId)
                                    .then(function () { return _this.refreshSyncInfo(); })
                                    .then(function () { return _this._save(); })
                                    .catch(function (error) {
                                    // If there was an error before this point then go back to the previous offline map.
                                    _this._activeOfflineMapId = lastActiveOfflineMapId;
                                    return Promise.resolve()
                                        .then(function () {
                                        if (lastActiveOfflineMapId) {
                                            return _this._bundleManager.loadBundle(_this._activeOfflineMapId);
                                        }
                                        else {
                                            return _this._bundleManager.unloadBundle();
                                        }
                                    })
                                        .then(function () { return _this.refreshSyncInfo(); })
                                        .catch(function (restoreError) {
                                        _this.app.trace.error("Error undoing attempt to activate offline map. " + (restoreError.message || restoreError));
                                    })
                                        .then(function () { throw error; });
                                })
                                    .then(function () {
                                    // Tell the app that we're "offline" - this isn't entirely true, but it's the best value we can set for isOffline
                                    _this.app.isOffline.set(true);
                                    _this.isOfflineMapActive.set(true);
                                    // AOI mask
                                    var realGeometry = new esri.geometry.Polygon(_this._offlineMaps[offlineMapIx].content.geometry);
                                    _this.aoiMask.show(realGeometry);
                                    var offlineMap = _this._offlineMaps[offlineMapIx];
                                    _this._restoreOfflineUserAddedLayers(offlineMap);
                                    // Refresh layers
                                    _this.app.site.essentialsMap.mapServices.forEach(function (x) {
                                        if (x instanceof geocortex.essentials.FeatureLayerService) {
                                            // HACK: GMAF-869 - Layer may have been suspended when going online. It should always be safe to *try* to load layers offline, so resume it.
                                            var fl = x.serviceLayer;
                                            if (fl.suspended) {
                                                fl.resume();
                                            }
                                        }
                                        x.refresh();
                                    });
                                    // Raise event
                                    _this.app.event("OfflineMapActivatedEvent").publish({
                                        offlineMap: _this._offlineMaps[offlineMapIx],
                                        userAction: !!userAction
                                    });
                                });
                            });
                        };
                        /**
                         * Make no offline map active.  This will succeed even if there is no
                         * active profile.
                         * @param userAction Set to true if the activation is happening as a result of the user
                         * explicitly clicking a button to activate the offline map. Set to false if the activation
                         * is happening automatically without the user explicitly activating the offline map.
                         */
                        OfflineManager.prototype.deactivateOfflineMap = function (userAction) {
                            var _this = this;
                            return this._lastOperation = this._waitForLast().finally(function () {
                                _this._throwIfNotNativeInitialized();
                                if (_this._activeOfflineMapId == null) {
                                    return Promise.resolve();
                                }
                                _this._previousActiveOfflineMapId = _this._activeOfflineMapId;
                                _this._activeOfflineMapId = null;
                                return _this._bundleManager.unloadBundle()
                                    .then(function () { return _this.refreshSyncInfo(); })
                                    .then(function () { return _this._save(); })
                                    .then(function () {
                                    // Tell the app that we're online
                                    _this.app.isOffline.set(false);
                                    _this.isOfflineMapActive.set(false);
                                    // AOI mask
                                    _this.aoiMask.hide();
                                    // Refresh layers
                                    _this.app.site.updateServiceTokensIfStale().then(function () {
                                        _this.app.site.essentialsMap.mapServices.forEach(function (x) {
                                            if (x instanceof geocortex.essentials.FeatureLayerService) {
                                                // It's a feature layer
                                                // HACK: GMAF-869 - Do a test query first to make sure the layer is available online.
                                                // If it is, we can safely refresh it. If it's not, disable (suspend) the layer.
                                                var fl = x.serviceLayer;
                                                var query = new esri.tasks.Query();
                                                query.objectIds = [0];
                                                fl.queryIds(query, function () {
                                                    x.refresh();
                                                }, function () {
                                                    fl.suspend();
                                                });
                                            }
                                            else {
                                                // Not a feature layer - just refresh it
                                                x.refresh();
                                            }
                                        });
                                    });
                                    // Raise event
                                    _this.app.event("OfflineMapActivatedEvent").publish({
                                        offlineMap: null,
                                        userAction: !!userAction
                                    });
                                });
                            });
                        };
                        /**
                         * Cancels the current sync or download.
                         */
                        OfflineManager.prototype.cancel = function () {
                            if (this.canCancel.get()) {
                                this._cancellationTokenSource.cancel(); // This will trigger an actual server side cancellation due to registered listeners
                                this.canCancel.set(false);
                                // Because of the cancellation, the last operation should eventually complete with an error (cancelled)
                                return this._lastOperation;
                            }
                            else {
                                return Promise.reject(this.getResource("language-offline-errors-cancelrejected"));
                            }
                        };
                        /**
                         * Clears out the last operation, so that the next operation can just go ahead without waiting for the last operation to complete.
                         * This should be used with caution, only called in extreme circumstances - for example if the last operation is hung.
                         */
                        OfflineManager.prototype.forgetLast = function () {
                            this._lastOperation = Promise.resolve();
                        };
                        /**
                         * Get the offline map with the given ID or null if not found.
                         * @param offlineMapId
                         */
                        OfflineManager.prototype.getOfflineMapById = function (offlineMapId) {
                            return this._offlineMaps.filter(function (op) { return op.id === offlineMapId; })[0];
                        };
                        /**
                         * Get all offline maps.
                         */
                        OfflineManager.prototype.getOfflineMaps = function () {
                            return this._offlineMaps.concat();
                        };
                        /**
                         * Get the currently active offline map or null if none.
                         */
                        OfflineManager.prototype.getActiveOfflineMap = function () {
                            return this._activeOfflineMapId ? this.getOfflineMapById(this._activeOfflineMapId) : null;
                        };
                        /**
                         * Refresh the sync info object.  This is automatically done when the active
                         * offline map changes.
                         */
                        OfflineManager.prototype.refreshSyncInfo = function () {
                            var _this = this;
                            if (!this._activeOfflineMapId) {
                                this.syncInfo = null;
                                return Promise.resolve();
                            }
                            return offline.SyncEngine.getSyncInfo(this.app, this._activeOfflineMapId)
                                .then(function (syncInfo) {
                                _this.syncInfo = syncInfo;
                            });
                        };
                        /**
                         * Save the state of the OfflineManager to storage.  This goes in the promise chain of anything that
                         * changes the state.
                         */
                        OfflineManager.prototype._save = function () {
                            var _this = this;
                            var valueJson = {
                                offlineMapIds: this._offlineMaps.map(function (op) { return op.id; }),
                                activeOfflineMapId: this._activeOfflineMapId,
                                previousActiveOfflineMapId: this._previousActiveOfflineMapId
                            };
                            return this._appStoreSetPromise("__offlineManager", JSON.stringify(valueJson))
                                .catch(function (error) {
                                _this.app.trace.error("Error saving offline manager state. " + (error.message || error));
                                error.message = _this.getResource("language-offline-errors-savefailed");
                                throw error;
                            });
                        };
                        /**
                         * Load the state of the OfflineManager from storage.  This should only be called on start up.
                         */
                        OfflineManager.prototype.load = function () {
                            var _this = this;
                            if (this._lastOperation) {
                                return;
                            }
                            this._lastOperation = this._appStoreGetPromise("__offlineManager")
                                .then(function (stateJsonString) {
                                if (!stateJsonString) {
                                    return null;
                                }
                                var state = JSON.parse(stateJsonString);
                                // Load all the offline maps.
                                var offlineMapLoadPromises = state.offlineMapIds
                                    .map(function (offlineMapId) {
                                    return _this._loadOfflineMapFromStorage(offlineMapId)
                                        .catch(function (error) {
                                        // Forget that profile existed and keep going.
                                        _this.app.trace.warning("Unable to restore offline map '" + offlineMapId + "'. " + (error.message || error));
                                        return null;
                                    });
                                });
                                return Promise.filter(offlineMapLoadPromises, function (op) { return op != null; })
                                    .then(function (offlineMaps) {
                                    // Intelligently load or don't load an offline map depending on a number of criteria
                                    // such as: the active offline map id, the previous active offline map id, and device connectivity
                                    _this._offlineMaps = offlineMaps;
                                    var prioritizedMaps = _this._prioritizeOfflineMaps(state, _this._offlineMaps);
                                    return _this._initializeMap(prioritizedMaps);
                                })
                                    .then(function () {
                                    _this.app.event("OfflineMapsLoadedEvent").publish({
                                        offlineMaps: _this._offlineMaps,
                                        activeOfflineMap: _this.getActiveOfflineMap()
                                    });
                                });
                            })
                                .catch(function (error) {
                                _this.app.trace.error("Error loading offline manager state. " + (error.message || error));
                                error.message = _this.getResource("language-offline-errors-loadfailed");
                                throw error;
                            });
                        };
                        /**
                         * Creates a priority sequence of offline map ids whereby we should use the first one that is workable.
                         */
                        OfflineManager.prototype._prioritizeOfflineMaps = function (state, offlineMaps) {
                            var sequence = [state.activeOfflineMapId, state.previousActiveOfflineMapId];
                            for (var _i = 0, _a = offlineMaps.map(function (x) { return x.id; }); _i < _a.length; _i++) {
                                var offlineMapId = _a[_i];
                                if (offlineMapId !== state.activeOfflineMapId && offlineMapId !== state.previousActiveOfflineMapId) {
                                    sequence.push(offlineMapId);
                                }
                            }
                            return sequence;
                        };
                        /**
                         * Employs some intelligence to determine which offline map should be loaded, if any.
                         * This method is recursive and will keep trying to initialize with the offline map ids
                         * in the sequence provided until it finds one that is workable.
                         */
                        OfflineManager.prototype._initializeMap = function (offlineMapIds) {
                            var _this = this;
                            if (offlineMapIds.length === 0 && this.app.isOffline.get()) {
                                return Promise.resolve();
                            }
                            // If we don't have connectivity, we must load an offline map or all hope is lost
                            var offlineMapId = offlineMapIds[0];
                            if (this.app.isOffline.get() && !offlineMapId) {
                                // Try the next preferred offline map - recursive call
                                return this._initializeMap(offlineMapIds.slice(1));
                            }
                            // Attempt to load either the offline map or the online map
                            if (offlineMapId) {
                                return this._bundleManager.loadBundle(offlineMapId)
                                    .then(function () {
                                    _this._activeOfflineMapId = offlineMapId;
                                    _this.app.isOffline.set(!!offlineMapId);
                                    _this.isOfflineMapActive.set(!!offlineMapId);
                                    var offlineMapIx = _this._getOfflineMapIx(offlineMapId);
                                    var offlineMap = _this._offlineMaps[offlineMapIx];
                                    var realGeometry = new esri.geometry.Polygon(_this._offlineMaps[offlineMapIx].content.geometry);
                                    _this.aoiMask.show(realGeometry);
                                    _this._restoreOfflineUserAddedLayers(offlineMap);
                                    return _this.refreshSyncInfo();
                                })
                                    .catch(function (error) {
                                    // Try the next preferred offline map - recursive call
                                    return _this._initializeMap(offlineMapIds.slice(1));
                                });
                            }
                            else {
                                // Online map is preferred, and we're online so we'll use it
                                return Promise.resolve();
                            }
                        };
                        /**
                         * Waits for the last operation to complete, absorbing any errors in the process, because we don't care
                         * about errors from the last operation when starting a new operation.
                         */
                        OfflineManager.prototype._waitForLast = function () {
                            return this._lastOperation.catch(function (error) { });
                        };
                        /**
                         * Throws an error if cancellation has been requested.
                         */
                        OfflineManager.prototype._throwIfCanceled = function () {
                            if (this._cancellationTokenSource.token().isCancellationRequested) {
                                throw new Error(this.getResource("language-offline-errors-canceled"));
                            }
                        };
                        OfflineManager.prototype._throwIfNotNativeInitialized = function () {
                            if (!this.app.nativeManager.nativeInitialized) {
                                throw new Error(this.getResource("language-offline-errors-notnativeinitialized"));
                            }
                        };
                        /**
                         * Load an OfflineMap from storage.  Offline profiles are kept in memory so this
                         * is only necessary on start up.
                         * @param offlineMapId
                         */
                        OfflineManager.prototype._loadOfflineMapFromStorage = function (offlineMapId) {
                            var _this = this;
                            return this._appStoreGetPromise(this._getOfflineMapKey(offlineMapId))
                                .then(function (offlineMapJsonString) {
                                if (!offlineMapJsonString) {
                                    // We should always know what offline maps are in the store.
                                    _this.app.trace.error("Offline profile '{offlineMapId}' not found.");
                                    throw new Error(_this.getResource("language-offline-errors-notfound"));
                                }
                                return JSON.parse(offlineMapJsonString);
                            }, function (error) {
                                _this.app.trace.error("Error loading offline map. " + (error.message || error));
                                error.message = _this.getResource("language-offline-errors-loadfailed");
                                throw error;
                            });
                        };
                        /**
                         * There could be user added layers that were stored in the offline map that aren't in the map at startup
                         * We are going to add those layers.
                         * Currently those layers are not removed from the map when the offline map is deactivated. This could be added later.
                         * @param offlineMapId
                         */
                        OfflineManager.prototype._restoreOfflineUserAddedLayers = function (offlineMap) {
                            var _this = this;
                            this.app.waitUntilSiteServiceLayersLoaded().then(function () {
                                var offlineAddedServiecs = [];
                                var appInfo = infrastructure.gis.AppInfo.fromGeocortexApp(_this.app);
                                // We will loop through all of the layers to see if they are user added layers, if they are user added, we might need to add them to the viewer.
                                offlineMap.content.layers.forEach(function (offlineLayer) {
                                    // If the layer wasn't added by a user, or we don't have any service info for the layer, ignore it.
                                    if (!offlineLayer.isUserCreated || !offlineLayer.serviceInfo) {
                                        return;
                                    }
                                    var serviceUrl = offlineLayer.serviceInfo.url;
                                    if (!serviceUrl) {
                                        return;
                                    }
                                    var existingLayer = appInfo.mapInfo.getLayerInfos().filter(function (layerInfo) { return layerInfo.uniqueId === offlineLayer.layerInfoUniqueId; })[0];
                                    // Layer exists, we're good.
                                    if (existingLayer) {
                                        if (existingLayer.gcxLayer && existingLayer.gcxLayer.properties.offlineMapId) {
                                            existingLayer.gcxLayer.properties.offlineMapId = offlineMap.id;
                                        }
                                        return;
                                    }
                                    // Layer hasn't been added to the map yet. We need to add it.
                                    var existingService = appInfo.mapInfo.serviceLayers.filter(function (serviceLayerInfo) { return serviceLayerInfo.serviceLayer.url === serviceUrl; })[0];
                                    if (existingService && existingService.gcxMapService) {
                                        var essLayer = new geocortex.essentials.Layer(offlineLayer.layerJson.url);
                                        essLayer.createFromDefinition(offlineLayer.layerJson);
                                        essLayer.isUserCreated = true;
                                        essLayer.includeInLayerList = true;
                                        essLayer.setInActiveTheme(true);
                                        essLayer.properties.offlineMapId = offlineMap.id;
                                        essLayer.parentLayerId = null; // Need to set the parent layer id to null to ensure visible layers are calculated properly.
                                        existingService.gcxMapService.add(essLayer);
                                        var addedService = offlineAddedServiecs.filter(function (os) { return os.service === existingService.gcxMapService; })[0];
                                        if (!addedService) {
                                            offlineAddedServiecs.push({
                                                service: existingService.gcxMapService,
                                                layers: [essLayer]
                                            });
                                        }
                                        else {
                                            addedService.layers.push(essLayer);
                                        }
                                    }
                                });
                                offlineAddedServiecs.forEach(function (addedService) {
                                    // Throw this event so that the layer list and others will update with the new layers.
                                    _this.app.event("MapServiceLayersChangedWithResultEvent").publish({
                                        mapService: addedService.service,
                                        newItems: addedService.layers,
                                        oldItems: []
                                    });
                                    _this.app.event("MapServiceLayersChangedEvent").publish(addedService.service);
                                });
                            });
                        };
                        /**
                         * Get the index of the OfflineMap.  The index of an OfflineMap is never
                         * exposed outside this class.
                         * @param offlineMap The offline map or its ID.
                         */
                        OfflineManager.prototype._getOfflineMapIx = function (offlineMap) {
                            var offlineMapId = typeof offlineMap === "string" ? offlineMap : offlineMap.id;
                            for (var offlineMapIx = 0; offlineMapIx < this._offlineMaps.length; offlineMapIx++) {
                                if (this._offlineMaps[offlineMapIx].id === offlineMapId) {
                                    return offlineMapIx;
                                }
                            }
                            return -1;
                        };
                        /**
                         * Get the array with information mapping map service URLs to downloaded tpk filename.
                         * @param offlineMap
                         */
                        OfflineManager.prototype._getOfflineMapBasemapMapping = function (offlineMap) {
                            var basemaps = this.app.site.essentialsMap.baseMaps;
                            return offlineMap.content.basemaps
                                .map(function (offlineBasemap) {
                                var basemap = basemaps.filter(function (basemap) { return offlineBasemap.baseMapId === basemap.id; })[0];
                                if (!basemap) {
                                    return null;
                                }
                                // Take the last map service.  The bottom-most layer is most likely to be always visible.
                                var basemapService = basemap.services.filter(function (mapService) { return mapService.mapService.mapServiceType === geocortex.essentials.MapServiceType.TILED; }).pop();
                                if (!basemapService) {
                                    return null;
                                }
                                return {
                                    url: geocortex.essentials.utilities.DecomposedUri.removeQueryParameters(basemapService.mapService.serviceLayer.url, "token"),
                                    localServicePath: (offlineBasemap.sourceType === offline.OfflineMapBasemap.Type.PREGENERATED ? "tile" : "viewertile") + "/" + offlineBasemap.filename.replace(" ", "_")
                                };
                            })
                                .filter(function (e) { return !!e; });
                        };
                        /**
                         * Get the key to retrieve the offline map content from the store.
                         * @param offlineMap The offline map ID or the offline map itself.
                         */
                        OfflineManager.prototype._getOfflineMapKey = function (offlineMap) {
                            if (typeof offlineMap === "string") {
                                return "__offlineMap-" + offlineMap;
                            }
                            else {
                                return "__offlineMap-" + offlineMap.id;
                            }
                        };
                        /**
                         * Get from the store in promise form.  This will hopefully be moved into Store in 3.0.
                         * @param key
                         */
                        OfflineManager.prototype._appStoreGetPromise = function (key) {
                            var _this = this;
                            return new Promise(function (resolve, reject) { return _this.app.store.get(key, resolve, reject); });
                        };
                        /**
                         * Set to the store in promise form.  This will hopefully move into Store in 3.0.
                         * @param key
                         * @param value
                         */
                        OfflineManager.prototype._appStoreSetPromise = function (key, value) {
                            var _this = this;
                            return new Promise(function (resolve, reject) { return _this.app.store.set(key, value, function () { return resolve(); }, reject); });
                        };
                        /**
                         * Remove from the store in promise form.  This will hopefully move into Store in 3.0.
                         * @param key
                         */
                        OfflineManager.prototype._appStoreRemovePromise = function (key) {
                            var _this = this;
                            return new Promise(function (resolve, reject) { return _this.app.store.remove(key, function () { return resolve(); }, reject); });
                        };
                        OfflineManager.prototype.getResource = function (key) {
                            return this.app.getResource(this.libraryId, key);
                        };
                        return OfflineManager;
                    }());
                    offline.OfflineManager = OfflineManager;
                })(offline = infrastructure.offline || (infrastructure.offline = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var offline;
                (function (offline) {
                    var OfflineMap;
                    (function (OfflineMap) {
                        /**
                         * Perform basic verification on the OfflineMap.  Throws errors if the OfflineMap
                         * is malformed.
                         * @param offlineMap The OfflineMap to verify.
                         */
                        function verify(offlineMap) {
                            if (!offlineMap) {
                                throw new Error("offlineMap is null or undefined.");
                            }
                            if (!offlineMap.id) {
                                throw new Error("offlineMap.id is null or undefined.");
                            }
                            if (!offlineMap.content) {
                                throw new Error("offlineMap.content is null or undefined.");
                            }
                            if (!offlineMap.content.geometry) {
                                throw new Error("offlineMap.content.geometry is null or undefined.");
                            }
                            if (!offlineMap.content.basemaps) {
                                throw new Error("offlineMap.content.basemaps is null or undefined.");
                            }
                            else {
                                for (var basemapIx = 0; basemapIx < offlineMap.content.basemaps.length; basemapIx++) {
                                    if (!offlineMap.content.basemaps[basemapIx].url) {
                                        throw new Error("offlineMap.content.basemaps[" + basemapIx + "].url is null or undefined.");
                                    }
                                    if (!offlineMap.content.basemaps[basemapIx].baseMapId) {
                                        throw new Error("offlineMap.content.basemaps[" + basemapIx + "].baseMapId is null or undefined.");
                                    }
                                    if (!offlineMap.content.basemaps[basemapIx].filename) {
                                        throw new Error("offlineMap.content.basemaps[" + basemapIx + "].filename is null or undefined.");
                                    }
                                    if (!offlineMap.content.basemaps[basemapIx].sourceType) {
                                        throw new Error("offlineMap.content.basemaps[" + basemapIx + "].sourceType is null or undefined.");
                                    }
                                }
                            }
                            if (!offlineMap.content.layers) {
                                throw new Error("offlineMap.content.layers is null or undefined.");
                            }
                            else {
                                for (var layerIx = 0; layerIx < offlineMap.content.layers.length; layerIx++) {
                                    if (!offlineMap.content.layers[layerIx].layerInfoUniqueId) {
                                        throw new Error("offlineMap.content.layers[" + layerIx + "].layerInfoUniqueId is null or undefined.");
                                    }
                                }
                            }
                            if (!offlineMap.properties["siteId"]) {
                                throw new Error("offlineMap.properties.siteId is null or undefined.");
                            }
                            if (!offlineMap.properties["viewerId"]) {
                                throw new Error("offlineMap.properties.viewerId is null or undefined.");
                            }
                        }
                        OfflineMap.verify = verify;
                        /**
                         * Compare the two offline maps and return an object containing only the values
                         * that are different in offlineMapB.
                         * @param offlineMapA The offline map to compare from.
                         * @param offlineMapB The offline map to compare to, where differing values will come from.
                         * @return An offline map-like object containing only the differences.
                         */
                        function diff(offlineMapA, offlineMapB) {
                            var differences = {};
                            if (offlineMapA.description !== offlineMapB.description) {
                                differences.description = offlineMapB.description;
                            }
                            if (!jsonEq(offlineMapA.grants, offlineMapB.grants)) {
                                differences.grants = offlineMapB.grants;
                            }
                            if (!jsonEq(offlineMapA.properties, offlineMapB.properties)) {
                                differences.properties = offlineMapB.properties;
                            }
                            if (!jsonEq(offlineMapA.shape, offlineMapB.shape)) {
                                differences.shape = offlineMapB.shape;
                            }
                            if (!jsonEq(offlineMapA.tags || [], offlineMapB.tags || [])) {
                                differences.tags = offlineMapB.tags;
                            }
                            if (offlineMapA.title !== offlineMapB.title) {
                                differences.title = offlineMapB.title;
                            }
                            if (!jsonEq(offlineMapA.thumbnail, offlineMapB.thumbnail)) {
                                differences.thumbnail = offlineMapB.thumbnail;
                            }
                            if (offlineMapA.version !== offlineMapB.version) {
                                differences.version = offlineMapB.version;
                            }
                            // Compare map content in more depth.
                            if ((offlineMapA.content == null) !== (offlineMapB.content == null)) {
                                differences.content = offlineMapB.content;
                            }
                            else if (offlineMapB.content == null) {
                                differences.content = null;
                            }
                            else if (!jsonEq(offlineMapA.content, offlineMapB.content)) {
                                differences.content = {};
                                if (!jsonEq(offlineMapA.content.geometry, offlineMapB.content.geometry)) {
                                    differences.content.geometry = offlineMapB.content.geometry;
                                }
                                if (!jsonEq(offlineMapA.content.layers, offlineMapB.content.layers)) {
                                    differences.content.layers = offlineMapB.content.layers;
                                }
                                if (!jsonEq(offlineMapA.content.basemaps, offlineMapB.content.basemaps)) {
                                    differences.content.basemaps = offlineMapB.content.basemaps;
                                }
                                if (offlineMapA.content.includeAttachments !== offlineMapB.content.includeAttachments) {
                                    differences.content.includeAttachments = offlineMapB.content.includeAttachments;
                                }
                            }
                            // Only return differences if it has any.
                            for (var prop in differences) {
                                if (differences.hasOwnProperty(prop)) {
                                    return differences;
                                }
                            }
                            return null;
                        }
                        OfflineMap.diff = diff;
                        function jsonEq(a, b) {
                            return a === b || JSON.stringify(a) === JSON.stringify(b);
                        }
                    })(OfflineMap = offline.OfflineMap || (offline.OfflineMap = {}));
                    var OfflineMapBasemap;
                    (function (OfflineMapBasemap) {
                        OfflineMapBasemap.Type = {
                            EXPORT_TILES: "exportTiles",
                            PREGENERATED: "pregenerated"
                        };
                    })(OfflineMapBasemap = offline.OfflineMapBasemap || (offline.OfflineMapBasemap = {}));
                })(offline = infrastructure.offline || (infrastructure.offline = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var offline;
                (function (offline) {
                    var SyncInfo = (function () {
                        function SyncInfo(syncInfo) {
                            this.servers = [];
                            for (var i = 0; i < syncInfo.servers.length; i++) {
                                if (typeof syncInfo.servers[i].lastSyncTime == "string") {
                                    syncInfo.servers[i].lastSyncTime = new Date(syncInfo.servers[i].lastSyncTime);
                                }
                                this.servers.push(syncInfo.servers[i]);
                            }
                        }
                        SyncInfo.prototype.isSynced = function (url) {
                            return !!this.findLayerOrTable(url);
                        };
                        SyncInfo.prototype.findLayerOrTable = function (url) {
                            var layerUrlParts = geocortex.essentials.utilities.LayerUtilities.decomposeFeatureLayerUrl(url);
                            var matchingServers = this.servers.filter(function (x) { return x.featureServiceUrl == layerUrlParts.serviceUrl; });
                            for (var i = 0; i < matchingServers.length; i++) {
                                var server = matchingServers[i];
                                var layer = server.layers.filter(function (x) { return x.id == layerUrlParts.layerId; })[0];
                                if (layer) {
                                    return layer;
                                }
                                var table = server.layers.filter(function (x) { return x.id == layerUrlParts.layerId; })[0];
                                if (table) {
                                    return table;
                                }
                            }
                            return null;
                        };
                        return SyncInfo;
                    }());
                    offline.SyncInfo = SyncInfo;
                })(offline = infrastructure.offline || (infrastructure.offline = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var offline;
                (function (offline) {
                    var SyncEngine = (function () {
                        function SyncEngine() {
                        }
                        SyncEngine.getSyncInfo = function (app, profileName) {
                            // Get the sync info from the server asynchronously
                            var url = app.localServerAddress + "/sync/" + app.localServerNamespace + "/info?profile=" + profileName;
                            return app.nativeManager.xhrGet({
                                url: url
                            }).then(function (response) {
                                var json = JSON.parse(response);
                                return new offline.SyncInfo(json);
                            });
                        };
                        SyncEngine.sync = function (app, parameters, cancellationToken, progress) {
                            var _this = this;
                            app.event("FeatureDataSyncStartedEvent").publish(parameters);
                            return this
                                ._unregisterOfflineDeletedReplicas(app)
                                .then(function (response) { return _this._sync(app, parameters, cancellationToken, progress); })
                                .then(function (progress) {
                                app.event("FeatureDataSyncCompletedEvent").publish();
                                return progress;
                            });
                        };
                        SyncEngine._sync = function (app, options, cancellationToken, progress) {
                            var _this = this;
                            cancellationToken.register(function () { return _this._cancel(app); });
                            return new Promise(function (resolve, reject) {
                                // Listen for native messages while we're syncing
                                var eventToken = app.event("NativeMessageEvent").subscribe(_this, function (msg) {
                                    if (msg.type !== "syncStatus") {
                                        return;
                                    }
                                    if (msg.parameters.state === _this.STATUS_SUCCESS) {
                                        app.event("NativeMessageEvent").unsubscribe(eventToken);
                                        progress(msg.parameters);
                                        resolve(msg.parameters);
                                    }
                                    else if (msg.parameters.state === _this.STATUS_ERROR) {
                                        app.event("NativeMessageEvent").unsubscribe(eventToken);
                                        reject(msg.parameters.text);
                                    }
                                    else if (msg.parameters.state === _this.STATUS_IN_PROGRESS) {
                                        progress(msg.parameters);
                                    }
                                });
                                var requestParams = {
                                    options: JSON.stringify(options)
                                };
                                // Do the sync!
                                var url = app.localServerAddress + "/sync/" + app.localServerNamespace + "/execute";
                                app.nativeManager.xhrPost({
                                    url: url,
                                    content: requestParams,
                                    error: function (error) {
                                        app.event("NativeMessageEvent").unsubscribe(eventToken);
                                        reject(error.responseText);
                                    }
                                });
                            });
                        };
                        SyncEngine._cancel = function (app) {
                            var url = app.localServerAddress + "/sync/" + app.localServerNamespace + "/cancel";
                            return app.nativeManager.xhrPost({
                                url: url,
                                method: "POST"
                            });
                        };
                        SyncEngine.deleteData = function (app, profile) {
                            // Create an object for each service uri and token
                            var serviceInfo = this._getFeatureServiceTokenInfo(app);
                            var url = app.localServerAddress + "/sync/" + app.localServerNamespace + "/delete";
                            var data = {
                                parameters: JSON.stringify({
                                    profile: profile,
                                    serviceInfo: serviceInfo
                                })
                            };
                            return app.nativeManager.xhrPost({
                                url: url,
                                content: data,
                                method: "POST"
                            });
                        };
                        SyncEngine._unregisterOfflineDeletedReplicas = function (app) {
                            // Replicas cannot be unregistered when offline
                            // Attempt to complete unregistering replicas in the hopes that we'll eventually start up when online
                            // Doing it this way since we don't have any good means of determining when we've gone online
                            var serviceInfo = this._getFeatureServiceTokenInfo(app);
                            var url = app.localServerAddress + "/sync/" + app.localServerNamespace + "/unregisterDeletedReplicas";
                            var data = {
                                parameters: JSON.stringify({
                                    serviceInfo: serviceInfo
                                })
                            };
                            return app.nativeManager.xhrPost({
                                url: url,
                                content: data
                            });
                        };
                        SyncEngine._getFeatureServiceTokenInfo = function (app) {
                            return app.site.essentialsMap.mapServices
                                .filter(function (mapService) { return mapService instanceof geocortex.essentials.FeatureLayerService; })
                                .map(function (mapService) { return ({
                                serviceUrl: geocortex.essentials.utilities.LayerUtilities.decomposeFeatureLayerUrl(mapService.serviceUrl).serviceUrl,
                                token: mapService.serviceToken
                            }); });
                        };
                        /* Status states */
                        SyncEngine.STATUS_IN_PROGRESS = "inProgress";
                        SyncEngine.STATUS_SUCCESS = "success";
                        SyncEngine.STATUS_ERROR = "error";
                        return SyncEngine;
                    }());
                    offline.SyncEngine = SyncEngine;
                })(offline = infrastructure.offline || (infrastructure.offline = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var offline;
                (function (offline) {
                    var SyncParameters;
                    (function (SyncParameters) {
                        /**
                         * Builds a SyncParameters object from an OfflineMap.
                         * @param app The app from which the map and appInfo are derived.
                         * @param offlineMap The OfflineMap to build SyncParameters from.
                         */
                        function buildSyncParameters(app, offlineMap) {
                            var appInfo = infrastructure.gis.AppInfo.fromGeocortexApp(app);
                            var layerInfos = appInfo.mapInfo.getLayerInfos();
                            var featureServiceParameters = [];
                            offlineMap.content.layers
                                .forEach(function (opLayer) {
                                var layerSyncParam;
                                var serviceUrl;
                                var layerId;
                                var capabilities;
                                var token;
                                var layerInfo = layerInfos.filter(function (layerInfo) { return layerInfo.uniqueId == opLayer.layerInfoUniqueId; })[0];
                                if (!layerInfo && !opLayer.isUserCreated) {
                                    return;
                                }
                                if (layerInfo) {
                                    serviceUrl = layerInfo.url.substring(0, layerInfo.url.lastIndexOf("/"));
                                    // Get the layer id from the url. 
                                    layerId = parseInt(layerInfo.id);
                                    //var layerId = parseInt(layerInfo.url.substring(layerInfo.url.lastIndexOf("/") + 1));
                                    layerSyncParam = {
                                        id: layerId,
                                        where: opLayer.definitionExpression
                                    };
                                    if (layerInfo.gcxLayer.isDynamic) {
                                        var mapService = layerInfo.serviceLayerInfo.serviceLayer;
                                        var dynamicInfo = mapService.dynamicLayerInfos.filter(function (dynLayerInfo) {
                                            return dynLayerInfo.id === layerId;
                                        })[0];
                                        if (dynamicInfo) {
                                            layerSyncParam.dynamicLayerInfo = dynamicInfo.toJson();
                                        }
                                        var drawingOptions = mapService.layerDrawingOptions[layerId];
                                        if (drawingOptions) {
                                            layerSyncParam.layerDrawingOptions = drawingOptions.toJson();
                                        }
                                    }
                                    token = layerInfo.serviceLayerInfo.gcxMapService.serviceToken;
                                    capabilities = layerInfo.serviceLayerInfo.capabilities;
                                }
                                else if (opLayer.isUserCreated && opLayer.serviceInfo && opLayer.layerJson) {
                                    serviceUrl = opLayer.serviceInfo.url;
                                    capabilities = opLayer.serviceInfo.capabilities;
                                    layerId = parseInt(opLayer.layerJson.id);
                                    var dynamicDefinition = JSON.parse(opLayer.layerJson.dynamicDefinition);
                                    layerSyncParam = {
                                        id: layerId,
                                        where: opLayer.definitionExpression,
                                        dynamicLayerInfo: dynamicDefinition,
                                        layerDrawingOptions: dynamicDefinition ? dynamicDefinition.drawingInfo : null
                                    };
                                }
                                else {
                                    return;
                                }
                                var fsParams = featureServiceParameters.filter(function (fsProp) { return fsProp.url === serviceUrl; })[0];
                                if (!fsParams) {
                                    fsParams = {
                                        url: serviceUrl,
                                        layers: [layerSyncParam],
                                        capabilities: capabilities,
                                        token: token
                                    };
                                    featureServiceParameters.push(fsParams);
                                }
                                else {
                                    fsParams.layers.push(layerSyncParam);
                                }
                                if (layerInfo) {
                                    // There are no relationships specified in the offline map for now.  Take all relationships.
                                    layerInfo.relationships.forEach(function (relationship) {
                                        if (!fsParams.layers.some(function (x) { return x.id == relationship.relatedTableId; })) {
                                            fsParams.layers.push({ id: relationship.relatedTableId });
                                        }
                                    });
                                }
                            });
                            return {
                                profile: offlineMap.id,
                                featureServices: featureServiceParameters,
                                geometry: offlineMap.content.geometry,
                                includeAttachments: offlineMap.content.includeAttachments,
                                mapSpatialReference: app.map.spatialReference.toJson()
                            };
                        }
                        SyncParameters.buildSyncParameters = buildSyncParameters;
                    })(SyncParameters = offline.SyncParameters || (offline.SyncParameters = {}));
                })(offline = infrastructure.offline || (infrastructure.offline = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var offline;
                (function (offline) {
                    /**
                     * Utility class to calculate work being done for sync.
                     * @private
                     */
                    var WorkCalculator = (function () {
                        function WorkCalculator() {
                        }
                        WorkCalculator.calculateFirstDownloadWork = function (profile) {
                            // Rough heuristic for determining the total amount of work that needs to be done
                            var workDescription = {
                                saveProfileWork: 0.25,
                                featureLayerWork: profile.content.layers.length + 2,
                                basemapWork: profile.content.basemaps.length * 4,
                                bundleWork: 0.5
                            };
                            return workDescription;
                        };
                        WorkCalculator.calculateSyncWork = function (profile) {
                            // Rough heuristic for determining the total amount of work that needs to be done
                            var workDescription = {
                                saveProfileWork: 0,
                                featureLayerWork: profile.content.layers.length + 2,
                                basemapWork: profile.content.basemaps.length * 2,
                                bundleWork: 0.5
                            };
                            return workDescription;
                        };
                        WorkCalculator.noWork = function () {
                            var workDescription = {
                                saveProfileWork: 0,
                                bundleWork: 0,
                                featureLayerWork: 0,
                                basemapWork: 0
                            };
                            return workDescription;
                        };
                        WorkCalculator.calculatePercentageComplete = function (completedWork, totalWork) {
                            var percentage = (this._calculateTotalWork(completedWork) / this._calculateTotalWork(totalWork)) * 100;
                            return percentage;
                        };
                        WorkCalculator._calculateTotalWork = function (work) {
                            var total = work.saveProfileWork + work.bundleWork + work.featureLayerWork + work.basemapWork;
                            return total;
                        };
                        return WorkCalculator;
                    }());
                    offline.WorkCalculator = WorkCalculator;
                })(offline = infrastructure.offline || (infrastructure.offline = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../_Definitions/framework.d.ts"/>
/// <reference path="../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../_Definitions/dojo.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var PortalUtils;
                (function (PortalUtils) {
                    /**
                     * Get a arcgis.com or Portal identity if it exists.
                     * @param app The current application instance
                     */
                    function getPortalIdentity(app) {
                        return infrastructure.SecurityUtils.getIdentity("ags-oauth2", app);
                    }
                    PortalUtils.getPortalIdentity = getPortalIdentity;
                    /**
                     * Check if the authenticated user has access to Portal.
                     * @param app The current application instance
                     */
                    function hasAccessToPortal(app) {
                        // TODO: Check for internet connectivity
                        // From Jeff G.: There's an observable app.offline that only indicates if the user has forced offline, which is going away and not dependable anyways.
                        return !!getPortalIdentity(app);
                    }
                    PortalUtils.hasAccessToPortal = hasAccessToPortal;
                    /**
                     * Check if the authenticated user has create content privilege in Portal.
                     * @param app The current application instance
                     */
                    function hasCreateContentPrivilege(app) {
                        var identity = getPortalIdentity(app);
                        if (!identity) {
                            return false;
                        }
                        return infrastructure.SecurityUtils.hasPrivilegeClaim(identity, "portal:user:createItem");
                    }
                    PortalUtils.hasCreateContentPrivilege = hasCreateContentPrivilege;
                    /**
                     * Check if the authenticated user has publishFeature privilege in Portal.
                     * @param app The current application instance
                     */
                    function hasPublishFeaturePrivilege(app) {
                        var identity = getPortalIdentity(app);
                        if (!identity) {
                            return false;
                        }
                        return infrastructure.SecurityUtils.hasPrivilegeClaim(identity, "portal:publisher:publishFeatures");
                    }
                    PortalUtils.hasPublishFeaturePrivilege = hasPublishFeaturePrivilege;
                    /**
                     * Gets the Portal base URL.
                     * @param app The current application instance
                     */
                    function getPortalBaseUrl(app) {
                        var identity = getPortalIdentity(app);
                        if (!identity) {
                            return null;
                        }
                        // This claim represents the base URL for the user's arcgis.com/Portal
                        var claims = infrastructure.SecurityUtils.getClaimsByType(identity, "http://www.geocortex.com/security/ags/portal");
                        var claim = claims[0];
                        if (!claim) {
                            return null;
                        }
                        return claim.value;
                    }
                    PortalUtils.getPortalBaseUrl = getPortalBaseUrl;
                    /**
                     * Gets the Portal My Content page URL.
                     * @param app The current application instance
                     */
                    function getPortalMyContentUrl(app) {
                        var portalBaseUrl = getPortalBaseUrl(app);
                        if (!portalBaseUrl) {
                            return null;
                        }
                        // Can configure the URL in the configuration file. This handles the case of if/when Esri decides to change their URL structure.
                        var relContentPageUrl = app.configuration.portalContentRelUrl || "home/content.html";
                        return String.format("{0}{1}", portalBaseUrl, relContentPageUrl);
                    }
                    PortalUtils.getPortalMyContentUrl = getPortalMyContentUrl;
                    /**
                     * Gets the Portal item page URL for the given item id.
                     * @param itemId The item id
                     * @param app The current application instance
                     */
                    function getPortalItemUrl(itemId, app) {
                        var portalBaseUrl = getPortalBaseUrl(app);
                        if (!portalBaseUrl) {
                            return null;
                        }
                        // Can configure the url in the configuration file. This handles the case of if/when Esri decides to change their URL structure.
                        var relItemPageUrl = app.configuration.portalItemRelUrl || "home/item.html?id=";
                        return String.format("{0}{1}{2}", portalBaseUrl, relItemPageUrl, itemId);
                    }
                    PortalUtils.getPortalItemUrl = getPortalItemUrl;
                })(PortalUtils = infrastructure.PortalUtils || (infrastructure.PortalUtils = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/Documents.Rest.d.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var project;
                (function (project_1) {
                    // These are used by encodeReferences() and decodeReferences(). These constants were chosen so that the output is 
                    // compatible with the CircularJSON library (https://github.com/WebReflection/circular-json), which is what we 
                    // initially used to perform the tasks carried out by these functions. Unfortunately, that library's implementation 
                    // is too slow when dealing with large object graphs.
                    var pathMarker = "~";
                    var escapedPathMarker = "\\x7e";
                    var DEFAULT_VIEWER_ID = "unknown";
                    project_1.PROJECT_TYPE = "gvh-project";
                    project_1.SITE_ID_PROPERTY_NAME = "siteID";
                    project_1.VIEWER_ID_PROPERTY_NAME = "viewerID";
                    project_1.PROJECT_QUERY_STRING_KEY = "project";
                    project_1.VIEWER_QUERY_STRING_KEY = "viewer";
                    var ProjectManager = (function () {
                        function ProjectManager(app) {
                            if (!app) {
                                throw new Error("ProjectManager: Parameter 'app' is required.");
                            }
                            this.app = app;
                            this.convert = new project_1.ProjectConverter(app);
                            this.filter = new project_1.ProjectFilter(app);
                        }
                        /**
                         * Creates a new, empty project.
                         */
                        ProjectManager.prototype.createEmpty = function (name) {
                            var properties = {};
                            properties[project_1.SITE_ID_PROPERTY_NAME] = {
                                "string": this.app.site.id
                            };
                            properties[project_1.VIEWER_ID_PROPERTY_NAME] = {
                                "string": this.app.configModel.viewerId
                            };
                            return {
                                title: name,
                                fileType: project_1.PROJECT_TYPE,
                                contentType: "application/json",
                                content: {
                                    moduleState: {}
                                },
                                properties: properties
                            };
                        };
                        /**
                         * Creates a new project containing the current state of the application.
                         */
                        ProjectManager.prototype.create = function (name) {
                            var project = this.createEmpty(name);
                            return this.update(project).return(project);
                        };
                        /**
                         * Updates an existing project with the current state of the application.
                         */
                        ProjectManager.prototype.update = function (project) {
                            return this._exportState().then(function (applicationState) { project.content = applicationState; });
                        };
                        /**
                         * Removes a project.
                         * @param project Either the project ID, or the actual project to remove.
                         */
                        ProjectManager.prototype.remove = function (project) {
                            var _this = this;
                            if (!project) {
                                throw new Error("RemoveProject: parameter \"project\" is required.");
                            }
                            var projectId = this.getProjectID(project);
                            return this.app.waitUntilSiteInitialized()
                                .then(function () { return _this.app.event("ProjectDeletingEvent").publish(projectId); })
                                .then(function () { return _this.app.site.documentStore.deleteById(projectId); })
                                .then(function () {
                                if (_this.current && _this.current.id === projectId) {
                                    _this.current = null;
                                }
                            })
                                .then(function () {
                                _this.app.event("ProjectDeletedEvent").publish(projectId);
                            })
                                .catch(function (error) {
                                _this.app.event("ProjectErrorEvent").publish(null, error);
                                var title = _this._getResource("language-project-error-title");
                                var message = _this._getResource("language-project-error-delete");
                                if (error && error.formalCode === "writer denied") {
                                    message = _this._getResource("language-project-error-delete-denied");
                                }
                                _this.app.command("Alert").execute(message, title);
                                throw error;
                            });
                        };
                        /**
                         * Saves a project by updating the application state then writing to storage.
                         * @param project The project to save.
                         */
                        ProjectManager.prototype.save = function (project, updateApplicationState) {
                            var _this = this;
                            if (updateApplicationState === void 0) { updateApplicationState = true; }
                            if (!project) {
                                throw new Error("SaveProject: parameter \"project\" is required.");
                            }
                            return this.app.waitUntilSiteInitialized()
                                .then(function () { return _this.app.event("ProjectSavingEvent").publish(project); })
                                .then(function () {
                                if (updateApplicationState) {
                                    // Wait for the views to settle before updating state
                                    return new Promise(function (resolve, reject) { return infrastructure.ShellUtils.debounceViewEvents(_this.app, function () { return resolve(); }); })
                                        .then(function () { return _this.update(project); })
                                        .then(function () { return infrastructure.MapUtils.getThumbnailUri(_this.app); })
                                        .then(function (thumbnail) { return project.thumbnail = { location: thumbnail }; })
                                        .catch(function (error) {
                                        _this.app.event("ProjectErrorEvent").publish(project, error);
                                        var title = _this._getResource("language-project-error-title");
                                        var message = _this._getResource("language-project-error-write");
                                        _this.app.command("Alert").execute(message, title);
                                        throw error;
                                    });
                                }
                                else {
                                    return Promise.resolve();
                                }
                            })
                                .then(function () { return _this.write(project); })
                                .then(function (savedProject) { return dojo.mixin(project, savedProject); })
                                .then(function () { return _this.app.event("ProjectSavedEvent").publish(project); });
                        };
                        /**
                         * Loads a project.
                         * @param project Either the project ID, or the actual project to load.
                         */
                        ProjectManager.prototype.load = function (project) {
                            var _this = this;
                            if (!project) {
                                throw new Error("LoadProject: parameter \"project\" is required.");
                            }
                            var projectId = this.getProjectID(project);
                            this.app.event("ProjectLoadingEvent").publish(projectId);
                            // If we do not have project content, we'll just get the project based
                            // on the ID, so that we retrieve the project with its content
                            if (typeof project === "object" && project.content === undefined) {
                                project = projectId;
                            }
                            return this.getProject(project)
                                .then(function (project) { return _this._beginLoad(project); })
                                .then(function () {
                                if (!_this.current || !_this.current.content) {
                                    return;
                                }
                                return _this._applyState(_this.current.content);
                            })
                                .then(function () { return _this._finishLoad(); })
                                .catch(function (error) { _this.isLoading = false; });
                        };
                        /**
                         * Writes a project file to storage.
                         */
                        ProjectManager.prototype.write = function (project) {
                            var _this = this;
                            if (!project) {
                                throw new Error("ProjectManager.write: Parameter \"project\" is required.");
                            }
                            if (project.content && project.content.isDecoded) {
                                this.encodeReferences(project.content);
                            }
                            return this.app.waitUntilSiteInitialized()
                                .then(function () {
                                if (geocortex.framework.utils.isNullOrUndefined(project.id)) {
                                    return _this.app.site.documentStore.add(project)
                                        .then(function (newProject) {
                                        project.id = newProject.id;
                                        return newProject;
                                    });
                                }
                                else {
                                    return _this.app.site.documentStore.updateById(project.id, project);
                                }
                            })
                                .catch(function (error) {
                                _this.app.event("ProjectErrorEvent").publish(project, error);
                                var title = _this._getResource("language-project-error-title");
                                var message = _this._getResource("language-project-error-write");
                                if (error && (error.formalCode === "writer denied" || error.formalCode === "create denied")) {
                                    message = _this._getResource("language-project-error-write-denied");
                                }
                                _this.app.command("Alert").execute(message, title);
                                throw error;
                            });
                        };
                        /**
                         * Reads a project from storage.
                         * @param id The project ID.
                         * @param Whether or not to include the project content if retrieving it from the document store.
                         */
                        ProjectManager.prototype.read = function (id, includeContent) {
                            var _this = this;
                            if (includeContent === void 0) { includeContent = true; }
                            if (!id) {
                                throw new Error("ProjectManager.read: parameter \"id\" is required.");
                            }
                            // The <any> is required because the final .catch(...) confuses the compiler into thinking
                            // that the chain returns Promise<void>, when in fact it's a legit Promise<Project> chain.
                            return this.app.waitUntilSiteInitialized()
                                .then(function () { return _this.app.site.documentStore.getById(id, includeContent); })
                                .then(function (project) {
                                if (project) {
                                    _this.decodeReferences(project.content);
                                    // SECURITY: Filter all incoming data before returning it to the caller.
                                    return _this._filterApplicationState(project.content)
                                        .then(function (filteredContent) {
                                        project.content = filteredContent;
                                        return project;
                                    });
                                }
                                return project;
                            })
                                .catch(function (error) {
                                _this.app.event("ProjectErrorEvent").publish(null, error);
                                var title = _this._getResource("language-project-error-title");
                                var message = _this._getResource("language-project-error-read");
                                if (error && error.formalCode === "item missing") {
                                    message = _this._getResource("language-project-error-read-not-found").format(id);
                                }
                                else if (error && error.formalCode === "reader denied") {
                                    message = _this._getResource("language-project-error-read-denied");
                                    if (_this.app.command("SignIn").canExecute(null)) {
                                        // Present the user with the option to sign in.
                                        message = _this._getResource("language-project-error-sign-in-required");
                                        var callback = function (signInClicked) {
                                            if (signInClicked) {
                                                _this.app.command("SignIn").execute(null);
                                            }
                                            else {
                                                // If the user cancels opening the project, then reload the viewer normally without the project parameter in the URL.
                                                window.location.assign(infrastructure.UrlUtils.removeQueryParameter(window.location.href, "project"));
                                            }
                                            // Note: Unreachable. Both branches above will immediately terminate the script by navigating away from the current page.
                                        };
                                        _this.app.command("Confirm").execute(message, title, callback, {
                                            okLabel: _this._getResource("language-project-sign-in")
                                        });
                                        // Unreachable, but just to be safe (we don't want to fall through and show an alert as well).
                                        throw error;
                                    }
                                    else {
                                        message = _this._getResource("language-project-error-read-denied");
                                    }
                                }
                                _this.app.command("Alert").execute(message, title);
                                throw error;
                            });
                        };
                        /**
                         * Gets the given project.
                         * @param project Either the project ID, or the actual project.
                         * @param Whether or not to include the project content if retrieving it from the document store.
                         * @return A promise containing the project.
                         */
                        ProjectManager.prototype.getProject = function (project, includeContent) {
                            if (includeContent === void 0) { includeContent = true; }
                            if (!project) {
                                throw new Error("ProjectManager.getProject: parameter \"project\" is required.");
                            }
                            if (typeof project === "string") {
                                // Treat it as a project ID.
                                return this.app.project.read(project, includeContent);
                            }
                            else {
                                // It's already a project.
                                return Promise.resolve(project);
                            }
                        };
                        /**
                         * Gets the ID of the given project.
                         * @param project Either the project ID, or the actual project.
                         * @return The project ID.
                         */
                        ProjectManager.prototype.getProjectID = function (project) {
                            if (!project) {
                                throw new Error("ProjectManager.getProjectID: parameter \"project\" is required.");
                            }
                            if (typeof project === "string") {
                                // It's already the project ID.
                                return project;
                            }
                            else {
                                // Get the project ID.
                                return project.id;
                            }
                        };
                        /**
                         * Gets the URL for the given project, or null if the project does not have an ID.
                         * @param project The project to get the URL for.
                         * @return The project URL or null.
                         */
                        ProjectManager.prototype.getProjectUrl = function (project) {
                            if (!project || !project.id) {
                                return null;
                            }
                            var siteId = this.getSiteID(project);
                            if (!siteId) {
                                throw new Error("ProjectManager.getProjectUrl: project siteId is null or undefined.");
                            }
                            var viewerId = this.getViewerID(project);
                            if (!viewerId) {
                                throw new Error("ProjectManager.getProjectUrl: project viewerId is null or undefined.");
                            }
                            var url = window.location.href;
                            // Strip url parameters
                            if (url.indexOf("?") > -1) {
                                url = url.substring(0, url.indexOf("?"));
                            }
                            else if (url.indexOf("#") > -1) {
                                url = url.substring(0, url.indexOf("#"));
                            }
                            var queryParams = new infrastructure.Dictionary();
                            // Add the viewer ID if it has been set
                            if (viewerId !== DEFAULT_VIEWER_ID) {
                                var viewerQueryStringValue = encodeURIComponent("{0}.{1}".format(siteId, viewerId));
                                queryParams.set(project_1.VIEWER_QUERY_STRING_KEY, viewerQueryStringValue);
                            }
                            // Add the project ID
                            queryParams.set(project_1.PROJECT_QUERY_STRING_KEY, encodeURIComponent(project.id));
                            return "{0}{1}".format(url, infrastructure.UrlUtils.queryStringDictionaryToString(queryParams));
                        };
                        /**
                         * Gets the Essentials site ID that the given project is associated with.
                         */
                        ProjectManager.prototype.getSiteID = function (project) {
                            if (!project) {
                                throw new Error("ProjectManager.getSiteID: parameter \"project\" is required.");
                            }
                            if (!project.properties) {
                                return null;
                            }
                            var siteIDProperty = project.properties[project_1.SITE_ID_PROPERTY_NAME];
                            return siteIDProperty ? siteIDProperty.string : null;
                        };
                        /**
                         * Gets the Essentials viewer ID that the given project is associated with.
                         */
                        ProjectManager.prototype.getViewerID = function (project) {
                            if (!project) {
                                throw new Error("ProjectManager.getViewerID: parameter \"project\" is required.");
                            }
                            if (!project.properties) {
                                return null;
                            }
                            var viewerIDProperty = project.properties[project_1.VIEWER_ID_PROPERTY_NAME];
                            return viewerIDProperty ? viewerIDProperty.string : null;
                        };
                        /**
                         * Validates whether or not the given project is owned by the current user.
                         * @param The project to verify ownership of.
                         * @return A promise containing the project being validated.
                         */
                        ProjectManager.prototype.validateProjectOwnership = function (project) {
                            if (this.app.site.documentStore.isOwner(project)) {
                                return Promise.resolve(project);
                            }
                            else {
                                return Promise.reject(this._getResource("language-project-error-owner"));
                            }
                        };
                        /**
                         * Gets the current state of the application.
                         */
                        ProjectManager.prototype._exportState = function () {
                            var _this = this;
                            // Important: prior to exporting state, we need to clear the project converter's cache.
                            // Otherwise, it will potentially return stale values from previous calls to this
                            // function, rather than the current state.
                            this.convert.clearCache();
                            var modules = this._getModules();
                            var moduleData = {};
                            Object.keys(modules).forEach(function (moduleName) {
                                moduleData[moduleName] = Promise.try(function () { return modules[moduleName].exportState(); });
                            });
                            return infrastructure.PromiseUtils.propsSkipRejected(moduleData)
                                .then(function (moduleData) {
                                // Modules that have nothing to save will return null from exportState(). Skip these.
                                for (var moduleName in moduleData) {
                                    if (!moduleData[moduleName]) {
                                        delete moduleData[moduleName];
                                    }
                                }
                                var state = {
                                    mapScale: _this.app.map.getScale(),
                                    mapCenter: _this.convert.fromEsriGeometry(_this.app.map.extent.getCenter()),
                                    moduleState: moduleData
                                };
                                return _this._filterApplicationState(state);
                            })
                                .then(function (state) {
                                _this.encodeReferences(state);
                                return state;
                            });
                        };
                        /**
                         * Applies the given state to the viewer.
                         */
                        ProjectManager.prototype._applyState = function (state) {
                            var _this = this;
                            if (!state) {
                                return Promise.resolve();
                            }
                            this.decodeReferences(state);
                            var modulesState = state.moduleState || [];
                            // Restore project state for each module.
                            return Promise.map(Object.keys(modulesState), function (moduleName) {
                                var module = _this._getModules()[moduleName];
                                if (!module) {
                                    return;
                                }
                                var moduleState = modulesState[moduleName];
                                if (!moduleState.serialVersion) {
                                    moduleState.serialVersion = 1;
                                }
                                return Promise.try(function () { return module.applyState(moduleState); })
                                    .catch(function (e) { return _this.app.trace.warning("Unable to restore project state for module \"{0}\": {1}".format(moduleName, e)); });
                            })
                                .return();
                        };
                        /**
                         * Applies the project's extent to the application's map.
                         */
                        ProjectManager.prototype._applyMapExtent = function (project) {
                            this.app.site.essentialsMap.extentManager.setScaleWithPriority(project.content.mapScale, Number.MAX_VALUE);
                            var center = this.convert.toEsriGeometry(project.content.mapCenter);
                            this.app.site.essentialsMap.extentManager.centerAtWithPriority(center, Number.MAX_VALUE);
                        };
                        ProjectManager.prototype._getResource = function (resource) {
                            return this.app.getResource("Mapping.Infrastructure", resource);
                        };
                        /**
                         * Gets all loaded the modules, keyed by name.
                         */
                        ProjectManager.prototype._getModules = function () {
                            // NOTE: For architectural reasons, we don't want to give out direct access to module instances via the
                            // module manager, so we need to access these in a somewhat dirty way.
                            return this.app.moduleManager._modules;
                        };
                        // Internal hooks that are also used by ViewerApplication.
                        ProjectManager.prototype._beginLoad = function (project) {
                            var _this = this;
                            return this.app.waitUntilSiteInitialized().then(function () {
                                if (_this.isLoading) {
                                    throw new Error("Cannot load a new project until the current project has finished loading.");
                                }
                                var projectSiteID = _this.getSiteID(project);
                                if (_this.app.site.id !== projectSiteID) {
                                    throw new Error("The project \"{0}\" was created for the Essentials site ID \"{1}\" and is not compatible with this site.".format(project.title, projectSiteID));
                                }
                                // Important: prior to loading state, we need to clear the project converter's cache.
                                // Otherwise, it could potentially return stale values from loading the previous project.
                                _this.convert.clearCache();
                                _this.isLoading = true;
                                _this.current = project;
                                _this._applyMapExtent(project);
                            });
                        };
                        ProjectManager.prototype._finishLoad = function () {
                            var _this = this;
                            // Reapply the map extent after all other modules have finished loading, in case a module
                            // has adjusted it during reload (this can sometimes happen when e.g. the dataframe is opened).
                            setTimeout(function () { return _this._applyMapExtent(_this.current); }, 150);
                            this.app.event("ProjectLoadedEvent").publish(this.current);
                            this.isLoading = false;
                        };
                        /**
                         * Filters application state according to the filter defined by each module.
                         * @param state The application state to filter.
                         */
                        ProjectManager.prototype._filterApplicationState = function (state) {
                            var _this = this;
                            var filter = {
                                mapCenter: this.filter.point,
                                mapScale: true,
                                moduleState: {},
                                isDecoded: true
                            };
                            var modules = this._getModules();
                            return Promise.map(Object.keys(modules), function (moduleName) {
                                var module = modules[moduleName];
                                if (!module) {
                                    return;
                                }
                                var moduleFilter = module.getStateFilter();
                                if (state.moduleState[moduleName] && !moduleFilter) {
                                    _this.app.trace.warning("Module \"{0}\" has project state, but has no defined state filter. A module that participate in projects must implement ModuleBase.getStateFilter().".format(moduleName));
                                    return;
                                }
                                // The base properties of ModuleState are always implicitly allowed, even if not defined by the module.
                                moduleFilter = $.extend({}, moduleFilter, { serialVersion: true });
                                filter.moduleState[moduleName] = moduleFilter;
                            })
                                .then(function () {
                                return infrastructure.ObjectFilter.filter(state, filter, { XssHtmlValidator: { defaultContentPolicy: _this.app.defaultContentPolicy } });
                            });
                        };
                        /**
                         * Replaces shared references within the object graph with special strings that act as "pointers" to
                         * the shared object. When the object graph is serialized as JSON, this reduces the serialized footprint
                         * and also allows cycles within the object graph, which would normally cause an error.
                         * @param state The application state to encode.
                         */
                        ProjectManager.prototype.encodeReferences = function (state) {
                            if (!state) {
                                return;
                            }
                            var allPathMarkersRegExp = new RegExp(pathMarker, "g");
                            var visited = new WeakMap();
                            var path = [];
                            var _doEncode = function (object) {
                                if (!Array.isArray(object)) {
                                    // Associate a pointer with this object for later use.
                                    visited.set(object, pathMarker + path.join(pathMarker));
                                }
                                for (var _i = 0, _a = Object.keys(object); _i < _a.length; _i++) {
                                    var key = _a[_i];
                                    var value = object[key];
                                    if (value && typeof value === "object") {
                                        var pointer = visited.get(value);
                                        if (pointer) {
                                            // We've already encountered this object, so replace it with a pointer.
                                            object[key] = pointer;
                                        }
                                        else {
                                            path.push((key + "").replace(allPathMarkersRegExp, escapedPathMarker));
                                            _doEncode(value);
                                            path.pop();
                                        }
                                    }
                                    else if (value && typeof value === "string" && value.startsWith(pathMarker)) {
                                        // Escape the path marker if it occurs at the beginning of a normal string.
                                        object[key] = value.replace(pathMarker, escapedPathMarker);
                                    }
                                }
                            };
                            _doEncode(state);
                            delete state.isDecoded;
                        };
                        /**
                         * Performs the inverse of encodeReferences(), i.e. turns "pointers" back into shared object references.
                         * @param state The application state to decode.
                         */
                        ProjectManager.prototype.decodeReferences = function (state) {
                            if (!state || state.isDecoded) {
                                return;
                            }
                            var allEscapedPathMarkersRegExp = new RegExp(escapedPathMarker.replace("\\", "\\\\"), "g");
                            var visited = new WeakMap();
                            var _doDecode = function (object) {
                                if (visited.has(object)) {
                                    return;
                                }
                                visited.set(object, true);
                                for (var _i = 0, _a = Object.keys(object); _i < _a.length; _i++) {
                                    var key = _a[_i];
                                    var value = object[key];
                                    if (value && typeof value === "string") {
                                        if (value.startsWith(pathMarker)) {
                                            // Resolve the reference.
                                            var pathParts = value.split(pathMarker).map(function (part) { return part.replace(allEscapedPathMarkersRegExp, pathMarker); });
                                            var reference = state;
                                            for (var i = 1; i < pathParts.length; i++) {
                                                var pathPart = pathParts[i];
                                                if (pathPart && reference) {
                                                    reference = reference[pathPart];
                                                }
                                            }
                                            object[key] = reference;
                                        }
                                        else if (value.startsWith(escapedPathMarker)) {
                                            object[key] = value.replace(escapedPathMarker, pathMarker);
                                        }
                                    }
                                    else if (value && typeof value === "object") {
                                        _doDecode(value);
                                    }
                                }
                            };
                            _doDecode(state);
                            state.isDecoded = true;
                        };
                        return ProjectManager;
                    }());
                    project_1.ProjectManager = ProjectManager;
                })(project = infrastructure.project || (infrastructure.project = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var PromiseUtils;
                (function (PromiseUtils) {
                    function allSkipRejected(values) {
                        var failure = {};
                        return Promise.resolve(values).then(function (array) {
                            var promises = (array || []).map(function (x) { return Promise.resolve(x).catch(function (e) { return failure; }); });
                            return Promise.all(promises).then(function (results) { return results.filter(function (x) { return x !== failure; }); });
                        });
                    }
                    PromiseUtils.allSkipRejected = allSkipRejected;
                    function mapSkipRejected(values, mapper, option) {
                        var failure = {};
                        return Promise.resolve(values).then(function (array) {
                            var promises = (array || []).map(function (x) { return Promise.resolve(x).catch(function (e) { return failure; }); });
                            var mapperWrapper = function (item, index, arrayLength) {
                                return Promise.try(function () { return mapper(item, index, arrayLength); }).catch(function (e) { return failure; });
                            };
                            return Promise.map(promises, mapperWrapper, option).then(function (results) { return results.filter(function (x) { return x !== failure; }); });
                        });
                    }
                    PromiseUtils.mapSkipRejected = mapSkipRejected;
                    function propsSkipRejected(object) {
                        return Promise.resolve(object).then(function (object) {
                            var result = {};
                            return Promise.map(Object.keys(object), function (key) {
                                return Promise.resolve(object[key]).then(function (value) { result[key] = value; }, function (error) { });
                            }).return(result);
                        });
                    }
                    PromiseUtils.propsSkipRejected = propsSkipRejected;
                    /**
                     * Logs a warning if the given promise is rejected.
                     * @param promise The promise that might be rejected.
                     * @param app The application
                     * @param warning The warning text to log. May contain a "{0}" placeholder that will be substituted with the actual error.
                     */
                    function warnOnReject(promise, app, warning) {
                        return Promise.resolve(promise).catch(function (e) {
                            app.trace.warning(warning.format(e));
                            return Promise.reject(e);
                        });
                    }
                    PromiseUtils.warnOnReject = warnOnReject;
                })(PromiseUtils = infrastructure.PromiseUtils || (infrastructure.PromiseUtils = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var reporting;
                (function (reporting) {
                    /**
                     * Returns an array of all Features within a given Reportable input (group of features).
                     */
                    function getAllFeaturesFromReportable(reportable) {
                        var features = [];
                        if (reportable instanceof infrastructure.FeatureSetCollection) {
                            var featureSetCollection = reportable;
                            featureSetCollection.featureSets.get().forEach(function (featureSet) {
                                featureSet.features.get().forEach(function (feature) {
                                    features.push(feature);
                                });
                            });
                        }
                        else if (reportable instanceof infrastructure.FeatureSet) {
                            var featureSet = reportable;
                            featureSet.features.get().forEach(function (feature) {
                                features.push(feature);
                            });
                        }
                        else if (reportable instanceof infrastructure.Feature) {
                            var feature = reportable;
                            features.push(feature);
                        }
                        else if (reportable && reportable.constructor === Array) {
                            features = reportable;
                        }
                        return features;
                    }
                    reporting.getAllFeaturesFromReportable = getAllFeaturesFromReportable;
                })(reporting = infrastructure.reporting || (infrastructure.reporting = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var commandArgs;
                (function (commandArgs) {
                    var ClusterLayerArgs = (function () {
                        function ClusterLayerArgs() {
                        }
                        return ClusterLayerArgs;
                    }());
                    commandArgs.ClusterLayerArgs = ClusterLayerArgs;
                })(commandArgs = infrastructure.commandArgs || (infrastructure.commandArgs = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var eventArgs;
                (function (eventArgs) {
                    /**
                     * Describes the arguments for a Snapping event.
                     */
                    var SnappingFeedbackEventArgs = (function () {
                        function SnappingFeedbackEventArgs() {
                        }
                        return SnappingFeedbackEventArgs;
                    }());
                    eventArgs.SnappingFeedbackEventArgs = SnappingFeedbackEventArgs;
                })(eventArgs = infrastructure.eventArgs || (infrastructure.eventArgs = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var layerList;
                (function (layerList) {
                    /** The visibility type of a layer list item's sub-items. */
                    var LayerVisibilityType = (function () {
                        function LayerVisibilityType() {
                        }
                        /** Any number of items can be visible at a time. */
                        LayerVisibilityType.Default = "default";
                        /** Only one item can be visible at a time. */
                        LayerVisibilityType.MutuallyExclusive = "mutuallyExclusive";
                        return LayerVisibilityType;
                    }());
                    layerList.LayerVisibilityType = LayerVisibilityType;
                })(layerList = infrastructure.layerList || (infrastructure.layerList = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/LayerList.Rest.d.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var layerSelector;
                (function (layerSelector_2) {
                    var LayerSelector = (function () {
                        /**
                         * Creates a new instance of the (@link LayerSelector} class.
                         * @param appInfo The {@link gis.AppInfo} that the layer selector belongs to
                         * @param options Optional. An object containing options to configure the layer selector
                         */
                        function LayerSelector(appInfo, options) {
                            /**
                             * A flat list of the filtered LayerSelectorServiceLayer and LayerSelectorLayer items.
                             */
                            this.filteredLayerSelectorLayerItems = [];
                            /**
                            * A flat list of the unfiltered LayerSelectorServiceLayer and LayerSelectorLayer items.
                            */
                            this.unfilteredLayerSelectorLayerItems = [];
                            this.itemTypes = {
                                FOLDER: "folder",
                                LAYER: "layer",
                                SERVICELAYER: "serviceLayer"
                            };
                            /*
                             * The library id to use for retrieving language resources from the mapping.infrastructure project
                             */
                            this._infrastructureLibraryId = "Mapping.Infrastructure";
                            this._unfilteredItems = [];
                            /** Placeholder folder for user-added layers */
                            this._userAddedLayersFolder = null;
                            this.appInfo = appInfo;
                            if (options) {
                                if (options.layerFilter && dojo.isFunction(options.layerFilter)) {
                                    this.layerFilter = options.layerFilter;
                                }
                                if (options.layerStateChangeHandler && dojo.isFunction(options.layerStateChangeHandler)) {
                                    this.layerStateChangeHandler = options.layerStateChangeHandler;
                                }
                                if (options.enableAllLayersHandler && dojo.isFunction(options.enableAllLayersHandler)) {
                                    this.enableAllLayersHandler = options.enableAllLayersHandler;
                                }
                                if (options.disableAllLayersHandler && dojo.isFunction(options.disableAllLayersHandler)) {
                                    this.disableAllLayersHandler = options.disableAllLayersHandler;
                                }
                                if (options.onInitializedHandler && dojo.isFunction(options.onInitializedHandler)) {
                                    this.onInitializedHandler = options.onInitializedHandler;
                                }
                                if (options.onLayerSelectorFolderItemCreated && dojo.isFunction(options.onLayerSelectorFolderItemCreated)) {
                                    this.onLayerSelectorFolderItemCreated = options.onLayerSelectorFolderItemCreated;
                                }
                                if (options.onLayerSelectorLayerItemCreated && dojo.isFunction(options.onLayerSelectorLayerItemCreated)) {
                                    this.onLayerSelectorLayerItemCreated = options.onLayerSelectorLayerItemCreated;
                                }
                                if (options.onLayerSelectorServiceLayerItemCreated && dojo.isFunction(options.onLayerSelectorServiceLayerItemCreated)) {
                                    this.onLayerSelectorServiceLayerItemCreated = options.onLayerSelectorServiceLayerItemCreated;
                                }
                            }
                            this.items = new ObservableCollection();
                            this.initialized = false;
                            this._suspendLayerStateChangeHandler = false;
                            this.initialize();
                        }
                        LayerSelector.prototype.initialize = function () {
                            this._loadLayerSelectorItems();
                            this.applyFilter(this.layerFilter);
                            this.setLayerStateChangeHandler(this.layerStateChangeHandler);
                            this.setEnableAllLayersHandler(this.enableAllLayersHandler);
                            this.setDisableAllLayersHandler(this.disableAllLayersHandler);
                            if (this.onInitializedHandler && !this.initialized) {
                                this.onInitializedHandler(this);
                            }
                            this.initialized = true;
                        };
                        LayerSelector.prototype.applyFilter = function (itemFilter) {
                            var _this = this;
                            this.layerFilter = (itemFilter && dojo.isFunction(itemFilter)) ? itemFilter : null;
                            this.items.clear();
                            this.filteredLayerSelectorLayerItems = [];
                            if (!this.layerFilter) {
                                this.items.set(this._unfilteredItems);
                                this.filteredLayerSelectorLayerItems = this.unfilteredLayerSelectorLayerItems.slice(0);
                                return;
                            }
                            var processItem = function (item) {
                                var processedItem = null;
                                if (item.itemType === _this.itemTypes.FOLDER) {
                                    processedItem = _this._generateItemCloneForFilter(item);
                                    item.items.get().forEach(function (childItem) {
                                        var processedChildItem = processItem(childItem);
                                        if (processedChildItem && (!processedChildItem.isFolder || (processedChildItem.isFolder && processedChildItem.items.length()))) {
                                            processedItem.items.addItem(processedChildItem);
                                        }
                                    });
                                    return processedItem;
                                }
                                else if (item.itemType === _this.itemTypes.SERVICELAYER && item.items.getLength() > 0) {
                                    // ServiceLayers like image services which have no children will not be handled here. They will be handled just like regular Layers.             
                                    if (_this.layerFilter(item)) {
                                        processedItem = _this._generateItemCloneForFilter(item);
                                        _this.filteredLayerSelectorLayerItems.push(processedItem);
                                    }
                                    else {
                                        // We'll still need a folder that contains the layers (if any) from this map service that satisfy the filter.
                                        processedItem = _this._creatFolderItemFromServiceLayer(item, true, true);
                                    }
                                    item.items.get().forEach(function (childItem) {
                                        var processedChildItem = processItem(childItem);
                                        if (processedChildItem && (!processedChildItem.isFolder || (processedChildItem.isFolder && processedChildItem.items.length()))) {
                                            processedItem.items.addItem(processedChildItem);
                                        }
                                    });
                                }
                                else {
                                    if (_this.layerFilter(item)) {
                                        processedItem = item;
                                        _this.filteredLayerSelectorLayerItems.push(processedItem);
                                    }
                                }
                                return processedItem;
                            };
                            this._unfilteredItems.forEach(function (item) {
                                var filteredItem = processItem(item);
                                if (filteredItem && (!filteredItem.isFolder || (filteredItem.isFolder && filteredItem.items.length()))) {
                                    _this.items.addItem(filteredItem);
                                }
                            });
                        };
                        /**
                         * Reapply the last used layer filter.
                         */
                        LayerSelector.prototype.reapplyFilter = function () {
                            this.applyFilter(this.layerFilter);
                        };
                        LayerSelector.prototype.setLayerStateChangeHandler = function (layerStateChangeHandler) {
                            var _this = this;
                            var unbindCurrentBindings = function () {
                                _this.unfilteredLayerSelectorLayerItems.forEach(function (layerSelectorLayerItem) {
                                    if (layerSelectorLayerItem["_isEnabledBindingToken"]) {
                                        layerSelectorLayerItem.isEnabled.unbind(layerSelectorLayerItem["_isEnabledBindingToken"]);
                                        delete (layerSelectorLayerItem["_isEnabledBindingToken"]);
                                    }
                                });
                            };
                            unbindCurrentBindings();
                            this.layerStateChangeHandler = (layerStateChangeHandler && dojo.isFunction(layerStateChangeHandler)) ? layerStateChangeHandler : null;
                            if (!this.layerStateChangeHandler) {
                                return;
                            }
                            this.unfilteredLayerSelectorLayerItems.forEach(function (layerSelectorLayerItem) {
                                layerSelectorLayerItem["_isEnabledBindingToken"] = layerSelectorLayerItem.isEnabled.bind(_this, function () {
                                    if (!_this._suspendLayerStateChangeHandler) {
                                        _this.layerStateChangeHandler(layerSelectorLayerItem);
                                    }
                                });
                            });
                        };
                        LayerSelector.prototype.setEnableAllLayersHandler = function (enableAllLayersHandler) {
                            this.enableAllLayersHandler = (enableAllLayersHandler && dojo.isFunction(enableAllLayersHandler)) ? enableAllLayersHandler : null;
                        };
                        LayerSelector.prototype.setDisableAllLayersHandler = function (disableAllLayersHandler) {
                            this.disableAllLayersHandler = (disableAllLayersHandler && dojo.isFunction(disableAllLayersHandler)) ? disableAllLayersHandler : null;
                        };
                        LayerSelector.prototype.enableAllLayers = function () {
                            this._suspendLayerStateChangeHandler = true;
                            this.filteredLayerSelectorLayerItems.forEach(function (item) { return item.isEnabled.set(true); });
                            this._suspendLayerStateChangeHandler = false;
                            if (this.enableAllLayersHandler) {
                                this.enableAllLayersHandler();
                            }
                        };
                        LayerSelector.prototype.disableAllLayers = function () {
                            this._suspendLayerStateChangeHandler = true;
                            this.filteredLayerSelectorLayerItems.forEach(function (item) { return item.isEnabled.set(false); });
                            this._suspendLayerStateChangeHandler = false;
                            if (this.disableAllLayersHandler) {
                                this.disableAllLayersHandler();
                            }
                        };
                        LayerSelector.prototype.addUserAddedServiceLayer = function (mapService) {
                            var _this = this;
                            if (mapService instanceof infrastructure.gis.ServiceLayerInfo) {
                                mapService = mapService.gcxMapService;
                            }
                            if (!mapService) {
                                return false;
                            }
                            // Do not add duplicate service layers
                            var matchingServicelayers = this.unfilteredLayerSelectorLayerItems.filter(function (layerItem) {
                                return layerItem.serviceLayer && layerItem.serviceLayer.gcxMapService === mapService;
                            });
                            if (matchingServicelayers.length) {
                                return false;
                            }
                            var serviceLayer = infrastructure.gis.ServiceLayerInfo.fromGcxMapService(mapService);
                            var layerSelectorServiceLayerItem = this._createServiceLayerItemFromServiceLayer(serviceLayer, true, true);
                            this.unfilteredLayerSelectorLayerItems.push(layerSelectorServiceLayerItem);
                            // <asanchez> As per the original logic below, when a map service is dynamically added client-side only top-level layers are processed and added to the layer selector. 
                            // This means that any sub-layers belonging to a group layer will be ignored since we are not recursively walking the layer tree in the logic below.
                            // I checked with <dplotsky> and this is ok because typical layer catalog implementations (e.g. BC Gov't) will have a flat list of layers to add/remove from the viewer. 
                            // However, since this method can be triggered by programmatically adding map services to the viewer, an enhancement should be filed to support the use case where group
                            // layers can be present in a map service that has been added to the viewer programmatically.
                            mapService.layers.forEach(function (layer) {
                                // Do not add duplicate layers.
                                var matchingLayers = _this.unfilteredLayerSelectorLayerItems.filter(function (layerItem) {
                                    return layerItem.layer && layerItem.layer.gcxLayer === layer;
                                });
                                if (matchingLayers.length) {
                                    return false;
                                }
                                // Find the layer info object corresponding to the Geocortex layer. If not found, create it.
                                var lyrInfo = serviceLayer.findLayerById(layer.id);
                                if (!lyrInfo) {
                                    lyrInfo = infrastructure.gis.LayerInfo.fromGcxLayer(layer);
                                    lyrInfo.serviceLayerInfo = serviceLayer;
                                    serviceLayer.layers.push(lyrInfo);
                                }
                                var layerSelectorLayerItem = _this._createLayerItemFromLayer(lyrInfo, true, true);
                                if (layerSelectorLayerItem) {
                                    layerSelectorServiceLayerItem.items.addItem(layerSelectorLayerItem);
                                    _this.unfilteredLayerSelectorLayerItems.push(layerSelectorLayerItem);
                                }
                            });
                            this._unfilteredItems.push(layerSelectorServiceLayerItem);
                            // Reset the filter so all filtered items are recomputed 
                            this.applyFilter(this.layerFilter);
                            this.setLayerStateChangeHandler(this.layerStateChangeHandler);
                            return true;
                        };
                        LayerSelector.prototype.removeServiceLayer = function (mapService) {
                            var _this = this;
                            if (mapService instanceof infrastructure.gis.ServiceLayerInfo) {
                                mapService = mapService.gcxMapService;
                            }
                            if (!mapService) {
                                return false;
                            }
                            var matchingServiceLayers = this.unfilteredLayerSelectorLayerItems.filter(function (serviceLayerItem) {
                                return serviceLayerItem.serviceLayer && serviceLayerItem.serviceLayer.gcxMapService === mapService;
                            });
                            if (matchingServiceLayers.length) {
                                matchingServiceLayers.forEach(function (srvLyr) { return _this._removeItemFromUnfilteredCollections(srvLyr); });
                            }
                            mapService.layers.forEach(function (lyr) {
                                var matchingLayers = _this.unfilteredLayerSelectorLayerItems.filter(function (layerItem) {
                                    return layerItem.layer && layerItem.layer.gcxLayer === lyr;
                                });
                                if (!matchingLayers.length) {
                                    return false;
                                }
                                matchingLayers.forEach(function (selectorItem) { return _this._removeItemFromUnfilteredCollections(selectorItem); });
                            });
                            // Reset the filter so all filtered items are recomputed 
                            this.applyFilter(this.layerFilter);
                            this.setLayerStateChangeHandler(this.layerStateChangeHandler);
                            return true;
                        };
                        LayerSelector.prototype.updateServiceLayer = function (mapService, newItems, oldItems) {
                            var _this = this;
                            newItems = newItems || [];
                            oldItems = oldItems || [];
                            if (mapService instanceof infrastructure.gis.ServiceLayerInfo) {
                                mapService = mapService.gcxMapService;
                            }
                            if (!mapService) {
                                return false;
                            }
                            var serviceLayer = infrastructure.gis.ServiceLayerInfo.fromGcxMapService(mapService);
                            // Remove `oldItems` from layer selector state
                            for (var i = 0; oldItems && i < oldItems.length; i++) {
                                var layer = oldItems[i];
                                // Need to find it first before removing it from the layer selector state
                                var matchingLayers = this.unfilteredLayerSelectorLayerItems.filter(function (x) { return x.layer && x.layer.gcxLayer === layer; });
                                if (!matchingLayers.length) {
                                    continue;
                                }
                                matchingLayers.forEach(function (selectorItem) { return _this._removeItemFromUnfilteredCollections(selectorItem); });
                            }
                            if (!this._userAddedLayersFolder) {
                                var json = {
                                    id: geocortex.framework.utils.alphaNumericToken() + ":UserAdded",
                                    name: this.appInfo.gcxApp.getResource(this._infrastructureLibraryId, "language-layerlist-user-added-layers-folder-title"),
                                    isExpanded: true,
                                    isVisible: true,
                                    items: [],
                                    canToggleVisibility: null,
                                    iconUri: null,
                                    isVisibleInLayerList: null,
                                    layerID: null,
                                    mapServiceID: null,
                                    layerVisibilityType: null,
                                    themeSettings: null,
                                    type: null
                                };
                                this._userAddedLayersFolder = this._createFolderItemFromRestItem(json, true, true);
                            }
                            // Add `newItems` to layer selector state
                            for (var j = 0; newItems && j < newItems.length; j++) {
                                var layer = newItems[j];
                                // Do not add duplicate layers.
                                var matchingLayers = this.unfilteredLayerSelectorLayerItems.filter(function (x) { return x.layer && x.layer.gcxLayer === layer; });
                                if (matchingLayers.length) {
                                    continue;
                                }
                                // Find the layer info object corresponding to the Geocortex layer. If not found, create it.
                                var lyrInfo = serviceLayer.findLayerById(layer.id);
                                if (!lyrInfo) {
                                    lyrInfo = infrastructure.gis.LayerInfo.fromGcxLayer(layer);
                                    lyrInfo.serviceLayerInfo = serviceLayer;
                                    serviceLayer.layers.push(lyrInfo);
                                }
                                var layerSelectorLayerItem = this._createLayerItemFromLayer(lyrInfo, true, true);
                                if (layerSelectorLayerItem) {
                                    this._userAddedLayersFolder.items.addItem(layerSelectorLayerItem);
                                    this.unfilteredLayerSelectorLayerItems.push(layerSelectorLayerItem);
                                }
                            }
                            // Add the placeholder folder to the top of the layer selector, if not already there
                            if (this._userAddedLayersFolder && this._userAddedLayersFolder.items.length() > 0 && this._unfilteredItems.indexOf(this._userAddedLayersFolder) < 0) {
                                this._unfilteredItems.unshift(this._userAddedLayersFolder);
                            }
                            // Reset the filter so all filtered items are recomputed 
                            this.applyFilter(this.layerFilter);
                            this.setLayerStateChangeHandler(this.layerStateChangeHandler);
                            return true;
                        };
                        LayerSelector.prototype._removeItemFromUnfilteredCollections = function (item) {
                            var _this = this;
                            if (!item) {
                                return;
                            }
                            var emptyFolders = [];
                            var removeItemFromArray = function (array, selectorItemToRemove) {
                                var targetIndex = array.indexOf(selectorItemToRemove);
                                if (targetIndex > -1) {
                                    array.splice(targetIndex, 1);
                                }
                            };
                            var recursivelyRemoveItemFromArray = function (array, itemToRemove) {
                                for (var x = array.length - 1; x >= 0; x--) {
                                    var currItem = array[x];
                                    if (currItem === itemToRemove) {
                                        array.splice(x, 1);
                                    }
                                    else {
                                        if (currItem.isFolder && currItem.items.length()) {
                                            removeItemFromArray(currItem.items.get(), itemToRemove);
                                            currItem.items.pulse();
                                            recursivelyRemoveItemFromArray(currItem.items.get(), itemToRemove);
                                            if (currItem.items.length() === 0) {
                                                emptyFolders.push(currItem);
                                            }
                                        }
                                    }
                                }
                            };
                            if (!item.isFolder) {
                                removeItemFromArray(this.unfilteredLayerSelectorLayerItems, item);
                            }
                            recursivelyRemoveItemFromArray(this._unfilteredItems, item);
                            if (emptyFolders.length) {
                                emptyFolders.forEach(function (folder) { return _this._removeItemFromUnfilteredCollections(folder); });
                            }
                        };
                        /*
                        * Loads the layer list that is used with this Layer Selector.
                        */
                        LayerSelector.prototype._loadLayerSelectorItems = function () {
                            var _this = this;
                            var restLayerList = this.appInfo.gcxApp.site.layerListRestEndpoint;
                            var mapInfo = this.appInfo.mapInfo;
                            this._unfilteredItems = [];
                            this.unfilteredLayerSelectorLayerItems = [];
                            var getLayerSelectorItems = function (item) {
                                var layerSelectorItem;
                                var itemExpanded = item.isExpanded != undefined ? item.isExpanded : true;
                                switch (item.type) {
                                    case "folder":
                                        layerSelectorItem = _this._createFolderItemFromRestItem(item, true, itemExpanded);
                                        break;
                                    case "mapService":
                                        var mapService = mapInfo.findMapServiceById(item.mapServiceID);
                                        layerSelectorItem = _this._createServiceLayerItemFromServiceLayer(mapService, true, itemExpanded);
                                        _this.unfilteredLayerSelectorLayerItems.push(layerSelectorItem);
                                        break;
                                    case "layer":
                                        var mapService = mapInfo.findMapServiceById(item.mapServiceID);
                                        var layer = mapService && mapService.findLayerById(item.layerID);
                                        layerSelectorItem = _this._createLayerItemFromLayer(layer, true, itemExpanded);
                                        _this.unfilteredLayerSelectorLayerItems.push(layerSelectorItem);
                                        break;
                                }
                                if (layerSelectorItem && item.items) {
                                    for (var i = 0; i < item.items.length; i++) {
                                        var childItem = getLayerSelectorItems(item.items[i]);
                                        if (childItem) {
                                            layerSelectorItem.items.addItem(childItem);
                                        }
                                    }
                                }
                                if (item.type === "folder" && layerSelectorItem && layerSelectorItem.items.getLength() === 0) {
                                    return null;
                                }
                                return layerSelectorItem;
                            };
                            if (restLayerList.items && restLayerList.items.length) {
                                restLayerList.items.forEach(function (item) {
                                    var selectorItem = getLayerSelectorItems(item);
                                    if (selectorItem) {
                                        _this._unfilteredItems.push(selectorItem);
                                    }
                                });
                            }
                            this._loadSelectorItemsNotInLayerList();
                        };
                        /*
                         * Adds item to the layer list collections for display.
                         * Includes a perusal through the site's mapservices to catch layers that are not included in the layerlist.
                         */
                        LayerSelector.prototype._loadSelectorItemsNotInLayerList = function () {
                            for (var i = 0; i < this.appInfo.mapInfo.serviceLayers.length; i++) {
                                var layerSelectorServiceLayerItem = null;
                                var currentMapService = this.appInfo.mapInfo.serviceLayers[i];
                                if (currentMapService && !currentMapService.includeInLayerList) {
                                    layerSelectorServiceLayerItem = this._createServiceLayerItemFromServiceLayer(currentMapService, true, true);
                                    this._unfilteredItems.push(layerSelectorServiceLayerItem);
                                    this.unfilteredLayerSelectorLayerItems.push(layerSelectorServiceLayerItem);
                                }
                                for (var j = 0; j < currentMapService.layers.length; j++) {
                                    var currentLayer = currentMapService.layers[j];
                                    if (!currentLayer || (currentLayer && currentLayer.includeInLayerList)) {
                                        continue;
                                    }
                                    var layerItem = this._createLayerItemFromLayer(currentLayer, true, true);
                                    if (layerSelectorServiceLayerItem && layerItem) {
                                        layerSelectorServiceLayerItem.items.addItem(layerItem);
                                        this.unfilteredLayerSelectorLayerItems.push(layerItem);
                                    }
                                    else if (layerSelectorServiceLayerItem == null && layerItem) {
                                        this._unfilteredItems.push(layerItem);
                                        this.unfilteredLayerSelectorLayerItems.push(layerItem);
                                    }
                                }
                            }
                        };
                        LayerSelector.prototype._createFolderItemFromRestItem = function (item, isEnabled, isExpanded) {
                            if (!item) {
                                return null;
                            }
                            var folderItem = {};
                            folderItem.itemType = this.itemTypes.FOLDER;
                            folderItem.name = new Observable(item.name || "Layers");
                            folderItem.isFolder = true;
                            folderItem.isEnabled = new Observable(!!isEnabled);
                            folderItem.isExpanded = new Observable(!!isExpanded);
                            folderItem.iconUri = new Observable("");
                            folderItem.items = new ObservableCollection();
                            this._setTooltips(folderItem);
                            if (this.onLayerSelectorFolderItemCreated) {
                                this.onLayerSelectorFolderItemCreated(folderItem);
                            }
                            return folderItem;
                        };
                        LayerSelector.prototype._creatFolderItemFromServiceLayer = function (srcItem, isEnabled, isExpanded) {
                            var folderItem = {};
                            folderItem.itemType = this.itemTypes.FOLDER;
                            folderItem.name = new Observable(srcItem.name.get() || "Layers");
                            folderItem.isFolder = true;
                            folderItem.isEnabled = new Observable(!!isEnabled);
                            folderItem.isExpanded = new Observable(!!isExpanded);
                            folderItem.iconUri = new Observable(srcItem.iconUri.get() || "");
                            folderItem.items = new ObservableCollection();
                            this._setTooltips(folderItem);
                            if (this.onLayerSelectorFolderItemCreated) {
                                this.onLayerSelectorFolderItemCreated(folderItem);
                            }
                            return folderItem;
                        };
                        LayerSelector.prototype._createLayerItemFromLayer = function (layer, isEnabled, isExpanded) {
                            if (!layer) {
                                return null;
                            }
                            var layerItem = {};
                            layerItem.itemType = this.itemTypes.LAYER;
                            layerItem.isEnabled = new Observable(!!isEnabled);
                            layerItem.isExpanded = new Observable(!!isExpanded);
                            layerItem.name = new Observable(layer.gcxLayer.displayName);
                            layerItem.isFolder = false;
                            layerItem.iconUri = new Observable(layer.gcxLayer.iconUri);
                            layerItem.layer = layer;
                            layerItem.items = new ObservableCollection([]);
                            this._setTooltips(layerItem);
                            if (this.onLayerSelectorLayerItemCreated) {
                                this.onLayerSelectorLayerItemCreated(layerItem);
                            }
                            return layerItem;
                        };
                        LayerSelector.prototype._createServiceLayerItemFromServiceLayer = function (serviceLayer, isEnabled, isExpanded) {
                            if (!serviceLayer) {
                                return null;
                            }
                            var layerItem = {};
                            layerItem.itemType = this.itemTypes.SERVICELAYER;
                            layerItem.isEnabled = new Observable(!!isEnabled);
                            layerItem.isExpanded = new Observable(!!isExpanded);
                            layerItem.name = new Observable(serviceLayer.gcxMapService.displayName);
                            layerItem.isFolder = false;
                            layerItem.iconUri = new Observable(serviceLayer.gcxMapService.iconUri);
                            layerItem.serviceLayer = serviceLayer;
                            layerItem.items = new ObservableCollection([]);
                            this._setTooltips(layerItem);
                            if (this.onLayerSelectorServiceLayerItemCreated) {
                                this.onLayerSelectorServiceLayerItemCreated(layerItem);
                            }
                            return layerItem;
                        };
                        /**
                         * Generates a clone of a folder or service layer item, set to enabled and minus its items. This is so we can filter items with children based on any filter that's applied
                         * without actually modifying the original layer/folder item.
                         */
                        LayerSelector.prototype._generateItemCloneForFilter = function (srcItem) {
                            var itemClone = dojo.mixin({}, srcItem);
                            itemClone.isEnabled = new Observable(true);
                            itemClone.items = new ObservableCollection();
                            if (srcItem.serviceLayer != undefined) {
                                itemClone.serviceLayer = srcItem.serviceLayer;
                            }
                            return itemClone;
                        };
                        /*
                         * Set up the descriptive tooltips to include the name of the layer. This is done for WCAG purposes.
                         */
                        LayerSelector.prototype._setTooltips = function (item) {
                            var expanderTooltip = this.appInfo.gcxApp.getResource(this._infrastructureLibraryId, "language-layerselector-item-expand").format(item.name.get());
                            var stateToggleTooltip = this.appInfo.gcxApp.getResource(this._infrastructureLibraryId, "language-layerselector-state-toggle").format(item.name.get());
                            var iconTooltip = this.appInfo.gcxApp.getResource(this._infrastructureLibraryId, "language-layerselector-icon-tooltip").format(item.name.get());
                            item.expanderTooltip = new Observable(expanderTooltip);
                            item.stateToggleTooltip = new Observable(stateToggleTooltip);
                            item.iconTooltip = new Observable(iconTooltip);
                        };
                        return LayerSelector;
                    }());
                    layerSelector_2.LayerSelector = LayerSelector;
                })(layerSelector = infrastructure.layerSelector || (infrastructure.layerSelector = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/LayerList.Rest.d.ts" />
/// <reference path="../../../_Definitions/LayerList.Rest.d.ts" />
/// <reference path="../../../_Definitions/LayerList.Rest.d.ts" />
/// <reference path="../../../_Definitions/LayerList.Rest.d.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var commandArgs;
                (function (commandArgs) {
                    var AddStatusArgs = (function () {
                        /**
                         * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.AddStatusArgs} class.
                
                         * @param text The message text to display.
                         * @param imageUri The URI of the image icon to show beside the text.
                         * @param userClosedCallback A callback function to invoke when the status message is dismissed by the user.
                         * @param imageClass The css class name to apply so that an image can be shown using css.
                         * @param id The ID of the status message. You can use this ID later on for the "PulseStatus" command and the "RemoveStatus" command.
                         *        If you do not supply a value, an ID will be created and assigned to id property so that you can use it later on.
                         * @param timeoutMS The timeout in milliseconds after which time the status message will go away.  A value of 0 or less than 0 means never time out.
                         * @param showBusyIcon If set to true, then a busy icon will be used - likely an animation to shown activity.
                         */
                        function AddStatusArgs(text, imageUri, userClosedCallback, imageClass, id, timeoutMS, showBusyIcon) {
                            this.text = text;
                            this.imageUri = imageUri;
                            this.userClosedCallback = userClosedCallback;
                            this.imageClass = imageClass;
                            this.id = id;
                            this.timeoutMS = timeoutMS || 30000; // 30 seconds is the default
                            this.showBusyIcon = !!showBusyIcon;
                        }
                        return AddStatusArgs;
                    }());
                    commandArgs.AddStatusArgs = AddStatusArgs;
                })(commandArgs = infrastructure.commandArgs || (infrastructure.commandArgs = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts"/>
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../../_Definitions/jquery.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var commandArgs;
                (function (commandArgs) {
                    var ShowMapElementArgs = (function () {
                        /**
                         * Initializes a new instance of the {@link ShowMapElementArgs} class.
                         * `ShowMapElementArgs` defines the arguments passed to a command relating to a showing an HTML view or element on the map.
                         * This class can be used for showing content in a map tip, or for attaching arbitrary HTML content to the map.
                         * The content property may be any of the following types:
                         * - An HTML DOM Element.
                         * - A framework view, inheriting from {@link framework.ui.ViewBase}.
                         * - An HTML content string.
                         * @param elementId The ID to use when referring to the newly created element, e.g. when updating or removing it.
                         * @param mapPoint The point (in map space) to anchor the element to.
                         * @param content Arbitrary content to display in the map element.
                         * @param title Title of the element.
                         */
                        function ShowMapElementArgs(elementId, mapPoint, content, title) {
                            /**
                             * Whether to destroy the child content view when this view is destroyed.  Leave this false if the view is going
                             * to be reused (for instance as part of a module).  Set this to true if the view was created manually
                             * with ViewManeger.createView() and then forgotten about.
                             */
                            this.destroyContentView = false;
                            /** @private */
                            this.delay = 0;
                            this.elementID = elementId || null;
                            this.mapPoint = mapPoint || null;
                            this.content = content || null;
                            this.title = title || null;
                        }
                        /**
                         * Gets the HTML element node, based on the content property.
                         */
                        ShowMapElementArgs.prototype.getNode = function () {
                            if (this.content) {
                                if (this.contentIsView()) {
                                    return this.content.root;
                                }
                                // To check if the content is an Html element
                                if (this.content.nodeName) {
                                    return this.content;
                                }
                                if (typeof this.content === "string") {
                                    // Create a new node using the content (can be html)
                                    var div = document.createElement("div");
                                    // GVH-10085
                                    div.innerHTML = new infrastructure.FilterUtils.UnsafeHtml(this.content).safeHtml;
                                    return div;
                                }
                            }
                            return null;
                        };
                        /**
                         * Gets the HTML element node, based on the title property.
                         */
                        ShowMapElementArgs.prototype.getTitleNode = function () {
                            if (this.title) {
                                if (this.titleIsView()) {
                                    return this.title.root;
                                }
                                // To check if the content is an Html element
                                if (this.title.nodeName) {
                                    return this.title;
                                }
                                if (typeof this.title === "string") {
                                    // Create a new node using the content (can be html)
                                    var div = document.createElement("div");
                                    // GVH-10085
                                    div.innerHTML = new infrastructure.FilterUtils.UnsafeHtml(this.content).safeHtml;
                                    return div;
                                }
                            }
                            return null;
                        };
                        /**
                         * Determines if the content property is a {@link geocortex.framework.ui.ViewBase}.
                         */
                        ShowMapElementArgs.prototype.contentIsView = function () {
                            return this.content && this.content instanceof geocortex.framework.ui.ViewBase;
                        };
                        /**
                         * Determines if the title property is a {@link geocortex.framework.ui.ViewBase}.
                         */
                        ShowMapElementArgs.prototype.titleIsView = function () {
                            return this.title && this.title instanceof geocortex.framework.ui.ViewBase;
                        };
                        return ShowMapElementArgs;
                    }());
                    commandArgs.ShowMapElementArgs = ShowMapElementArgs;
                })(commandArgs = infrastructure.commandArgs || (infrastructure.commandArgs = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/**
 * Legacy support. No new code should use this.
 * @private
 */
geocortex.essentialsHtmlViewer.mapping.infrastructure.ShowMapElementArgs = geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.ShowMapElementArgs;
/**
* This utility class has moved to geocortex.essentialsHtmlViewer.mapping.infrastructure.coordinates.CoordinateUtils
* The namespace is duplicated below to be backwards compatible with third party code.
*/
/**
 * @deprecated Please use geocortex.essentialsHtmlViewer.mapping.infrastructure.coordinates.AngleFormat instead.
 */
geocortex.essentialsHtmlViewer.mapping.infrastructure.AngleFormat = geocortex.essentialsHtmlViewer.mapping.infrastructure.coordinates.AngleFormat;
/**
 * @deprecated Please use geocortex.essentialsHtmlViewer.mapping.infrastructure.coordinates.AngleDirectionSystem instead.
 */
geocortex.essentialsHtmlViewer.mapping.infrastructure.AngleDirectionSystem = geocortex.essentialsHtmlViewer.mapping.infrastructure.coordinates.AngleDirectionSystem;
/**
 * @deprecated Please use geocortex.essentialsHtmlViewer.mapping.infrastructure.coordinates.CoordinateUtils instead.
 */
geocortex.essentialsHtmlViewer.mapping.infrastructure.CoordinateUtils = geocortex.essentialsHtmlViewer.mapping.infrastructure.coordinates.CoordinateUtils;
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var eventArgs;
                (function (eventArgs) {
                    var AuthenticationEventArgs = (function () {
                        function AuthenticationEventArgs() {
                            this.result = null;
                            this.username = null;
                            this.token = null;
                        }
                        return AuthenticationEventArgs;
                    }());
                    eventArgs.AuthenticationEventArgs = AuthenticationEventArgs;
                })(eventArgs = infrastructure.eventArgs || (infrastructure.eventArgs = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/**
 * Legacy support.  No new code should use this.
 */
geocortex.essentialsHtmlViewer.mapping.infrastructure.AuthenticationEventArgs = geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.AuthenticationEventArgs;
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var eventArgs;
                (function (eventArgs) {
                    var GeolocationEventArgs = (function () {
                        /**
                         * Initializes a new instance of the {@link GeolocationEventArgs} class.
                         */
                        function GeolocationEventArgs() {
                            /** A point in Web Mercator. */
                            this.mapPoint = null;
                            /** A point in the map's spatial reference. */
                            this.projectedMapPoint = null;
                            /** A location returned directly from the HTML5 geolocation event. */
                            this.location = null;
                            /** Whether the current geolocation result was from a single geolocate, track, or a follow. */
                            this.typeOfGeolocation = null;
                            /** The accuracyThreshold goal that was initially specified for a single point geolocate command. */
                            this.accuracyThreshold = null;
                            /** Whether or not the single point geolocation process reached its time limit. */
                            this.timedOut = false;
                        }
                        return GeolocationEventArgs;
                    }());
                    eventArgs.GeolocationEventArgs = GeolocationEventArgs;
                })(eventArgs = infrastructure.eventArgs || (infrastructure.eventArgs = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var eventArgs;
                (function (eventArgs) {
                    var MapExtentEventArgs = (function () {
                        /**
                         * Initializes a new instance of the {@link MapExtentEventArgs} class.
                         */
                        function MapExtentEventArgs() {
                            /** Supplementary information for when we are able to project */
                            /** to 4326 on the client-side (i.e. from Web Mercator) */
                            this.centerLatLon = null;
                            this.currentScale = null;
                            this.currentResolution = null;
                        }
                        return MapExtentEventArgs;
                    }());
                    eventArgs.MapExtentEventArgs = MapExtentEventArgs;
                })(eventArgs = infrastructure.eventArgs || (infrastructure.eventArgs = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var eventArgs;
                (function (eventArgs) {
                    var UserEventArgs = (function () {
                        /**
                         * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.UserEventArgs} class.
                         */
                        function UserEventArgs() {
                            /**
                             * Gets or sets whether the user sign-in/sign-out should be cancelled, or allowed to proceed.
                             */
                            this.isCancelled = false;
                        }
                        return UserEventArgs;
                    }());
                    eventArgs.UserEventArgs = UserEventArgs;
                })(eventArgs = infrastructure.eventArgs || (infrastructure.eventArgs = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../_Definitions/framework.d.ts"/>
/// <reference path="./Feature.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var FeatureDescriptionPresenterView = (function (_super) {
                    __extends(FeatureDescriptionPresenterView, _super);
                    /**
                     * Construct a feature description presenter view.
                     */
                    function FeatureDescriptionPresenterView(app, libraryId) {
                        _super.call(this, app, libraryId);
                        // Validator for sanitizing HTML for safe injection into the document.
                        this._xssHtmlValidator = new infrastructure.validation.XssHtmlValidator({
                            contentPolicy: app.defaultContentPolicy
                        });
                    }
                    /** @inherited */
                    FeatureDescriptionPresenterView.prototype.attach = function (viewModel) {
                        var _this = this;
                        if (viewModel && viewModel instanceof infrastructure.Feature) {
                            return this.descriptionApply(viewModel, this.root)
                                .then(function () { return _super.prototype.attach.call(_this, viewModel); });
                        }
                        else {
                            _super.prototype.attach.call(this, viewModel);
                            return Promise.resolve();
                        }
                    };
                    /**
                     * Returns a description for the given feature capable of performing commands in hyperlinks.
                     * To be used with features that do not have relationships.
                     * @deprecated 2.6 Use {@link getDescriptionContent} instead.
                     * @param feature The feature what we would like to get the description for
                     */
                    FeatureDescriptionPresenterView.prototype.descriptionGet = function (feature) {
                        return this.getDescriptionContent(feature);
                    };
                    FeatureDescriptionPresenterView.prototype.getContentFieldFormat = function (feature) {
                        switch (this.contentField) {
                            case "label": return feature.labelFormat.get();
                            case "description": return feature.descriptionFormat.get();
                            case "longDescription": return feature.longDescriptionFormat.get();
                            default: return feature.longDescriptionFormat.get();
                        }
                    };
                    /**
                     * Returns a description for the given feature.
                     * The description is populated with unbound command hyperlinks and image load handlers for handling layout changes.
                     * Consumers must bind this content themselves.
                     * Note that all anchor tags are converted to command hyperlinks that open the URLs only after verification via a {@link ContentPolicy}.
                     * @param feature The feature what we would like to generate the descriptive content for.
                     * @param descriptionFormat Optional parameter. If provided, will override the descriptionFormat for the feature - to be used for eg. when relationship replacement tokens resolve asynchronously.
                     */
                    FeatureDescriptionPresenterView.prototype.getDescriptionContent = function (feature, descriptionFormat) {
                        var _this = this;
                        var format = descriptionFormat;
                        if (!format) {
                            format = this.getContentFieldFormat(feature);
                        }
                        var commandHyperlinkPlaceholderState = this._extractCommandHyperlinks(format);
                        format = commandHyperlinkPlaceholderState.html;
                        // Sanitizing the formatted template string.
                        return this._sanitizeHtml(feature.formatTemplateString(format))
                            .then(function (html) {
                            // SECURITY: Note that we inject command hyperlinks and image tags back *after* sanitizing the HTML. These functions must
                            // be careful to return only safe content.
                            // Injecting command hyperlinks back into the sanitized HTML.
                            commandHyperlinkPlaceholderState.html = html;
                            html = _this._injectCommandHyperlinks(commandHyperlinkPlaceholderState);
                            // Applying data-bindings based on command hyperlinks.
                            html = _this.insertLinkAndImageBindings(html);
                            // Return the safe HTML so that it may be injected into the document.
                            return html;
                        });
                    };
                    /**
                     * Renders a feature description into the provided HTML element, injecting command hyperlinks and image loading handlers.
                     * @deprecated 2.6 Use {@link applyDescriptiveTemplate} instead.
                     * @param feature The feature what we would like to get the description for
                     * @param viewRoot The HTML element to assign the description to.
                     */
                    FeatureDescriptionPresenterView.prototype.descriptionApply = function (feature, viewRoot) {
                        return this.applyDescriptiveTemplate(feature, viewRoot);
                    };
                    /**
                     * Renders a feature description into the provided HTML element, injecting command hyperlinks and image loading handlers.
                     * @param feature The feature what we would like to get the description for
                     * @param viewRoot The HTML element to assign the description to.
                     */
                    FeatureDescriptionPresenterView.prototype.applyDescriptiveTemplate = function (feature, viewRoot) {
                        var _this = this;
                        // Several asynchronous things might be happening concurrently within this function.
                        // We compile them into this promises array, and wait for them all to finish before resolving this function's returned promise.
                        // The value of the returned promise is not important; it exists so that the consumer may take action after this function's duties are completed.
                        var promises = [];
                        var format = this.getContentFieldFormat(feature);
                        // Since we don't have access to the commandRegistry in Feature, let's parse
                        // the format for related features before we send it off for further processing.
                        if (format && feature.hasRelationships) {
                            // Extract the tokens from the description.
                            var matches = format.match(/{{.[^}]+?\..+?}}|{.[^}]+?\..+?}/g);
                            var separatedValues = [];
                            for (var current in matches) {
                                if (!matches.hasOwnProperty(current)) {
                                    continue;
                                }
                                var currentMatch = matches[current];
                                currentMatch = currentMatch.substr(1, currentMatch.length - 2); // Get rid of the { } around the token values.
                                // The tokens are in a name.value format - let's break them up into two separate array values.
                                // [0] = Relationship Name, [1] = Attribute Value
                                separatedValues.push(currentMatch.match(/[^.].[^.]*/g));
                            }
                            // Scan relationships to see if we have a match.
                            if (separatedValues.length && feature.layer && feature.layer.relationships) {
                                for (var current in feature.layer.relationships) {
                                    if (!feature.layer.relationships.hasOwnProperty(current)) {
                                        continue;
                                    }
                                    var currentRelationship = feature.layer.relationships[current];
                                    // Check to see if the name of the relationship exists within our values.
                                    // Sometimes the relationship's name variable differs (name & displayName must be checked)
                                    if (separatedValues.toString().indexOf(currentRelationship.name) != -1 ||
                                        separatedValues.toString().indexOf(currentRelationship.displayName) != -1) {
                                        promises.push(new Promise(function (resolve, reject) {
                                            var getSuccessCallback = function (relIdentifier) {
                                                return function (graphics) {
                                                    if (graphics.length > 0) {
                                                        // The two below for loops are used to make it so we can make sure the {name.value} is replaced
                                                        // with the appropriate token value.
                                                        for (var current in separatedValues) {
                                                            if (!separatedValues.hasOwnProperty(current)) {
                                                                continue;
                                                            }
                                                            // Looks like the SL viewer just grabs the first returned graphic, so let's do the same.
                                                            var targetGraphic = graphics[0];
                                                            var currentPair = separatedValues[current];
                                                            var currName = currentPair[0].trim();
                                                            var currVal = currentPair[1].trim();
                                                            if (relIdentifier.indexOf(currName) === -1 || targetGraphic.attributes[currVal] === undefined) {
                                                                continue;
                                                            }
                                                            for (var current in matches) {
                                                                if (!matches.hasOwnProperty(current)) {
                                                                    continue;
                                                                }
                                                                var currentMatch = matches[current];
                                                                if (format.indexOf(currentMatch) !== -1 && currentMatch.indexOf(currName) !== -1 && currentMatch.indexOf(currVal) !== -1) {
                                                                    format = format.replace(currentMatch, targetGraphic.attributes[currVal]);
                                                                    _this.getDescriptionContent(feature, format)
                                                                        .then(function (content) { return viewRoot.innerHTML = content; })
                                                                        .then(function () { return resolve(); });
                                                                }
                                                            }
                                                        }
                                                    }
                                                    else {
                                                        resolve();
                                                    }
                                                };
                                            };
                                            // We have a match for our tokens - let's get the related feature info.
                                            _this.app.command("GetRelatedFeatures").execute({
                                                mapService: feature.layer.mapService,
                                                currentFeature: feature,
                                                relationshipId: currentRelationship.id,
                                                objectId: feature.id.get(),
                                                successCallback: getSuccessCallback("{0}-{1}".format(currentRelationship.name, currentRelationship.displayName)),
                                                errorCallback: function (error) {
                                                    error.message = "There was an error retrieving related features: " + error.message;
                                                    _this.app.trace.warning(error.message);
                                                    // GVH-10136: We dont want to reject the promise in case of error. Rejection will immediately cause Promises.all (below) to reject without waiting
                                                    // for all promises to resolve.
                                                    resolve(error);
                                                }
                                            });
                                        }));
                                    }
                                }
                            }
                        }
                        // Initial update - if more information comes in from related features it will be updated again.
                        promises.push(this.getDescriptionContent(feature)
                            .then(function (content) { return viewRoot.innerHTML = content; }));
                        return Promise.all(promises).then(function () { return null; });
                    };
                    /**
                     * Extract command hyperlinks and replace them with placeholders.
                     */
                    FeatureDescriptionPresenterView.prototype._extractCommandHyperlinks = function (html) {
                        var commandHyperlinkPlaceholders = [];
                        if (!html) {
                            return { html: html, commandHyperlinkPlaceholders: commandHyperlinkPlaceholders };
                        }
                        html = html.replace(/\bhref="#?command:.*?"/ig, function (commandHyperlink) {
                            var placeholder = "href=\"mailto:" + geocortex.framework.utils.alphaNumericToken() + "\"";
                            commandHyperlinkPlaceholders.push({ commandHyperlink: commandHyperlink, placeholder: placeholder });
                            return placeholder;
                        });
                        return { html: html, commandHyperlinkPlaceholders: commandHyperlinkPlaceholders };
                    };
                    /**
                     * Inject command hyperlinks back into the subject of a previous extraction.
                     */
                    FeatureDescriptionPresenterView.prototype._injectCommandHyperlinks = function (state) {
                        var html = state.html, commandHyperlinkPlaceholders = state.commandHyperlinkPlaceholders;
                        if (!html) {
                            return "";
                        }
                        var getCommandHyperlinkForPlaceholder = function (placeholder) {
                            for (var _i = 0, commandHyperlinkPlaceholders_1 = commandHyperlinkPlaceholders; _i < commandHyperlinkPlaceholders_1.length; _i++) {
                                var details = commandHyperlinkPlaceholders_1[_i];
                                if (placeholder === details.placeholder) {
                                    return details.commandHyperlink;
                                }
                            }
                        };
                        return html.replace(/\bhref="mailto:.*?"/ig, getCommandHyperlinkForPlaceholder);
                    };
                    /**
                     * Sanitize a string of HTML.
                     */
                    FeatureDescriptionPresenterView.prototype._sanitizeHtml = function (html) {
                        // SECURITY: HTML is sanitized. GVH-9760.
                        // Frames ALLOWED.
                        // Anchor tags converted to command hyperlinks.
                        // All URIs are run through a `ContentPolicy` by way of the XSS validator.
                        var sanitizeOptions = {
                            allowFrames: true,
                            allowArbitraryHyperlinks: true,
                            // SECURITY: These are pushed through the XSS validator immediately below, so they are subject to a `ContentPolicy`.
                            uriTransformer: function (uri, details) {
                                if (details.type !== infrastructure.FilterUtils.UriType.NavigableLink) {
                                    return uri;
                                }
                                else {
                                    // GVH-10285: Preventing double command hyperlinking.
                                    return /^mailto\:/.test(uri) ? uri : "command:OpenWebPage?" + uri;
                                }
                            }
                        };
                        return this._xssHtmlValidator.validate(html, { sanitizeOptions: sanitizeOptions })
                            .then(function (result) { return result.validatedValue; });
                    };
                    /**
                     * Creates a cleansed copy of a format with any command hyperlinks replaced with click handlers
                     * @deprecated 2.6 Use {@link insertLinkAndImageBindings} instead.
                     * @param Format the format template for this feature
                     */
                    FeatureDescriptionPresenterView.prototype.cleansedFormatForFormat = function (descFormat) {
                        return this.insertLinkAndImageBindings(descFormat);
                    };
                    /**
                     * Inserts command hyperlinks and image load handlers, the latter for the purpose of handling layout changes.
                     * @param Format the format template for this feature
                     */
                    FeatureDescriptionPresenterView.prototype.insertLinkAndImageBindings = function (descFormat) {
                        var _this = this;
                        if (descFormat === null) {
                            return null;
                        }
                        // If we've already seen it, just return the copy.
                        if (descFormat in this._descFormats) {
                            return this._descFormats[descFormat];
                        }
                        else {
                            var anchorPattern = /<a[^>]*(\/?>)/g;
                            // In the regex below, the command: will only match urls that are of the command scheme. To match any urls, remove 'command:'
                            var hrefAnchorPattern = /(<a.*?href\s*?=\s*?")(command:.+?)(".*?)(\/?>)/;
                            var newFormat = descFormat.replace(anchorPattern, function (match, contents, offset, s) {
                                var matches = match.match(hrefAnchorPattern);
                                if (matches) {
                                    // GVH-5525, GVH-10497
                                    // Preserve a few safe attributes that we need
                                    var safeAttrs = "";
                                    var safeAttrsMatch = match.match(/(title|aria-label)\s*?=\s*?"[^"]*?"/g);
                                    if (safeAttrsMatch) {
                                        safeAttrs = " " + safeAttrsMatch.join(" ");
                                    }
                                    return "<a _key=\"" + _this.keyForUri(matches[2]) + "\" href=\"javascript:void(0)\" data-binding=\"{@event-onclick: handleHyperlinkClick}{@event-mouseup: ignoreEvent}{@event-mousedown: ignoreEvent}\"" + safeAttrs + matches[4];
                                }
                                else {
                                    // This will currently return the original string if the anchor is not of a command type. to replace this with an empty anchor use "<a " + contents;
                                    return match;
                                }
                            });
                            // GVH-9466: Attach an event handler to img tags so we can take action when an image loads.
                            newFormat = newFormat.replace(/<img/g, "<img data-binding=\"{@event-load: handleImgLoad}\"");
                            this._descFormats[descFormat] = newFormat;
                            return newFormat;
                        }
                    };
                    /**
                     * Override this method to add custom behavior on image load.
                     */
                    FeatureDescriptionPresenterView.prototype.handleImgLoad = function (evt) {
                    };
                    /**
                     * Finds the id for the given command hyperlink. If one is not found, creates one and returns that.
                     * @param Uri the uri you would like the key for
                     * @return Number
                     */
                    FeatureDescriptionPresenterView.prototype.keyForUri = function (uri) {
                        var index = dojo.indexOf(this._uris, uri);
                        if (index >= 0) {
                            index;
                        }
                        else {
                            index = this._uris.length;
                            this._uris.push(uri);
                        }
                        return index;
                    };
                    /**
                     * Attempts to parse the parameter string given into one with the given type. Also performs Token replacements
                     * @param parameter the parameter string you are attempting to parse
                     * @param paramType the type that you would like to get the parameter in.
                     * @param context the context to use for any token replacements
                     * @return Object an array of the command parameters given the given format.
                     */
                    FeatureDescriptionPresenterView.prototype.parseArguments = function (parameter, paramType, context) {
                        var result = {};
                        if (paramType === "none") {
                            return null;
                        }
                        else if (paramType === "string") {
                            if (this.tryPerformTokenSubstitution(parameter, context, result)) {
                                return [result.value];
                            }
                            else {
                                return [parameter];
                            }
                        }
                        else if (paramType === "list") {
                            // Attempt Json list
                            var paramsList;
                            try {
                                // Use JSON2. dojo.fromJson ==== evil
                                paramsList = JSON.parse(parameter);
                            }
                            // Fall back on query string
                            catch (err) {
                                paramsList = parameter.split("&");
                            }
                            // Token substitution doesn't work on json lists, due to syntax.
                            for (var i = 0; i < paramsList.length; i++) {
                                if (this.tryPerformTokenSubstitution(paramsList[i], context, result)) {
                                    paramsList[i] = result.value;
                                }
                            }
                            return paramsList;
                        }
                        else {
                            // Try to parse from json. If that fails, try to parse the query string
                            var param;
                            try {
                                param = JSON.parse(parameter);
                            }
                            catch (err) {
                                // It wasn't in JSON, so lets see if it's just a single token
                                if (parameter.indexOf("=") < 0) {
                                    if (this.tryPerformTokenSubstitution(parameter, context, result)) {
                                        return [result.value];
                                    }
                                    // I know of no objects that are not of the form {$Feature}, {$Geometry} etc that we can make using a single non-key value argument that isn't in JSON.
                                    this.app.trace.warning("The specified parameter could not be parsed to a valid Object in JSON or Query String format.");
                                    return [null];
                                }
                                param = dojo.queryToObject(parameter);
                            }
                            // Perform token replacement on the resulting object
                            for (var key in param) {
                                if (param.hasOwnProperty(key) && typeof param[key] !== "function") {
                                    if (this.tryPerformTokenSubstitution(param[key], context, result)) {
                                        param[key] = result.value;
                                    }
                                }
                            }
                            var originalParam = null;
                            // This is one of our class types, so lets make the arguments of the right type
                            if (paramType !== "object") {
                                var argumentType = dojo.getObject(paramType)();
                                // Incase we need to do some adjustment, store the original
                                originalParam = param;
                                param = dojo.safeMixin(argumentType, param);
                            }
                            // If the originalParam is different then the current one, make sure that we haven't inadvertently added a spatial reference
                            if (originalParam) {
                                // If the new param object has a spatialReference and the original didn't, delete it, because it comes from Esri's default. Grr.
                                if (param.spatialReference && !originalParam.spatialReference) {
                                    param.spatialReference = null;
                                }
                            }
                            return [param];
                        }
                    };
                    /**
                     * Replaces any instances of the given token string with the attributes of a given feature, and returns if we any such substitutions occurred.
                     * @param token The token string you would like to replace
                     * @param feature The feature that should be used as a context for the token replacements
                     * @param output An object whose value parameter will contain the substituted output if the token substitution succeeds
                     * @return Boolean
                     */
                    FeatureDescriptionPresenterView.prototype.tryPerformTokenSubstitution = function (token, feature, output) {
                        var _this = this;
                        // GVH-10065: The fix for GVH-8355 introduced excessive guards regarding 'feature' having a valid esriFeature and a valid geometry associated with the feature.
                        // It's perfectly valid for features to not have geometry here if they are derived from a table. Adding checks when needed in order to avoid regressing GVH-8355.
                        // The replaced code is as below.
                        // /* 
                        //  * if (token === null || feature === null || !(feature instanceof Feature) || feature.esriFeature.get() === null || (feature.esriFeature.get().geometry === null && token === "{$Geometry}")) { 
                        //  */
                        // GVH-9164: We type guard here because, while we expect a feature, the caller technically passes an 'any'-type, which in the case of workflows run with command parameters is a string.
                        if (token === null || token === undefined || !feature || !(feature instanceof infrastructure.Feature)) {
                            output.value = null;
                            return false;
                        }
                        var esriFeature = (feature.esriFeature && feature.esriFeature.get && feature.esriFeature.get()) || null;
                        if (token === "{$Feature}") {
                            output.value = feature;
                            return true;
                        }
                        else if (token === "{$Graphic}") {
                            output.value = esriFeature || null;
                            return output.value === null ? false : true;
                        }
                        else if (token === "{$Geometry}") {
                            output.value = (esriFeature && esriFeature.geometry) || null;
                            return output.value === null ? false : true;
                        }
                        else if (typeof token === "string") {
                            // If there are any other tokens we should be substituting, do it.
                            var matched = false;
                            var result = token.replace(/{.+?}/g, function (match) {
                                matched = true;
                                var attributeName = match.substring(1, match.length - 1);
                                var replacement = esriFeature && esriFeature.attributes[attributeName];
                                if (replacement) {
                                    return replacement;
                                }
                                else {
                                    if (!replacement && feature.layer) {
                                        replacement = geocortex.essentials.utilities.StringUtilities.replaceLayerTokens(attributeName, feature.layer);
                                    }
                                    if (!replacement && feature.layer && feature.layer.mapService) {
                                        replacement = geocortex.essentials.utilities.StringUtilities.replaceMapServicetokens(attributeName, feature.layer.mapService);
                                    }
                                    if (replacement.length > 0) {
                                        return replacement;
                                    }
                                    else {
                                        _this.app.trace.warning("The token syntax {" + attributeName + "} was detected, but could not be matched to a valid replacement value.");
                                        // GVH-10457
                                        // Return the original token (including curly braces).
                                        // If the source string only contained a single token that could not be matched it would be better to have the whole 
                                        // function return false and allow the caller to decide what to do with an unmodified value, however since were are 
                                        // in a global regex replace we could be dealing with multiple tokens and some of them might match. We need to assume 
                                        // that we are modifying the original string in some way, even if we are just replacing with the exact same content.
                                        return match;
                                    }
                                }
                            });
                            output.value = result;
                            return matched;
                        }
                        return false;
                    };
                    /**
                     * Returns Html encoded quotes to their non-html forms
                     * @param input the string to replace the quotes to non html quotes
                     * @return String
                     */
                    FeatureDescriptionPresenterView.prototype.decodeHtmlQuotes = function (input) {
                        input = input.replace(/&quot;/g, "\"");
                        input = input.replace(/&39;/g, "'");
                        return input;
                    };
                    /**
                     * Returns Html encoded ampersands to their non-html forms
                     * @param input the string to replace the ampersands to non html ampersands
                     * @return String
                     */
                    FeatureDescriptionPresenterView.prototype.decodeHtmlAmpersands = function (input) {
                        input = input.replace(/&amp;/g, "&");
                        return input;
                    };
                    /**
                     * A click handler for hyperlinks embedded in the descriptions returned from descriptionGet/descriptionApply
                     * @param event The event object that was fired with the click
                     * @param el The element where the click occurred
                     * @param context The feature that is related to the description the click occurred in
                     * @return Boolean if the event should propogate up
                     */
                    FeatureDescriptionPresenterView.prototype.handleHyperlinkClick = function (event, element, context) {
                        var key = element.getAttribute("_key");
                        var uri = this._uris[key];
                        if (uri) {
                            var url = new dojo._Url(uri);
                            // We will let the browser take care of any other links, we're just going to take care of commands
                            if (url.scheme === "command") {
                                var command = url.path;
                                var query = url.query;
                                this.runCommand(command, query, context);
                                return false;
                            }
                        }
                        return false;
                    };
                    /**
                     * An event handler handler designed to stop events from propagating to overzealous parent views.
                     * @param event The event object that was fired with the click
                     * @param el The element where the click occurred
                     * @param context The feature that is related to the description the click occurred in
                     * @return False. If this was embedded, we never want our parents notified
                     */
                    FeatureDescriptionPresenterView.prototype.ignoreEvent = function (event, el, context) {
                        return false;
                    };
                    /**
                     * Runs the command named with the given parameters and context
                     * @param commandName The name of the command we would like executed
                     * @param parameter The parameter to be fed to the command. Encoded in either JSON or Query String format.
                     * @param context The feature context that should be used for token replacements
                     */
                    FeatureDescriptionPresenterView.prototype.runCommand = function (commandName, parameter, context) {
                        var command = this.app.command(commandName);
                        // Verify that we know this command
                        var commandMetadata = geocortex.essentialsHtmlViewer.Commands.metadataForCommandName(commandName);
                        if (commandMetadata === null) {
                            this.app.trace.warning("The specified command \"{0}\" has no associated metadata.".format(commandName));
                            return;
                        }
                        // Verify that we know how to hyperlink this command
                        if (!commandMetadata.isHyperlinkable) {
                            this.app.trace.warning("The specified command \"{0}\" is not able to be hyperlinked.".format(commandName));
                            return;
                        }
                        // It is possible that a command could validly have no parameters at all.
                        var commandArguments = [];
                        if (parameter) {
                            // We now need to decode some HTML encoded characters, as we might need them unescaped to process
                            parameter = this.decodeHtmlQuotes(parameter);
                            parameter = this.decodeHtmlAmpersands(parameter);
                            // Here we will parse the arguments to the expected type, and return the result as an array of arguments
                            var commandArguments = this.parseArguments(parameter, commandMetadata.arguments, context);
                        }
                        // GVH-10937 creating a flag for the case where a link is included in feature description and must not be encoded/altered
                        if (commandName == "OpenWebPage") {
                            var commandArgsOWP = { url: commandArguments[0], isLink: true };
                            var commandArgsOWPArray = [];
                            commandArgsOWPArray.push(commandArgsOWP);
                            command.execute.apply(command, commandArgsOWPArray);
                        }
                        else {
                            command.execute.apply(command, commandArguments);
                        }
                    };
                    return FeatureDescriptionPresenterView;
                }(geocortex.framework.ui.ViewBase));
                infrastructure.FeatureDescriptionPresenterView = FeatureDescriptionPresenterView;
                FeatureDescriptionPresenterView.prototype._uris = [];
                FeatureDescriptionPresenterView.prototype._descFormats = {};
                FeatureDescriptionPresenterView.prototype.contentField = null;
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../_Definitions/framework.d.ts"/>
/// <reference path="../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../_Definitions/dojo.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var FocusUtils;
                (function (FocusUtils) {
                    /**
                     * Sets the focus on the first input control in a view (e.g. a textbox, drop-down, checkbox)
                     * @param view The target view.
                     */
                    function focusOnFirstInput(view) {
                        if (!view || !view.root) {
                            return;
                        }
                        // Don't refocus if a modal is active and the view isn't the modal view.
                        if (view.app && view.app.modalRegionSingleton && view.app.modalRegionSingleton.isActive && view.id !== "ModalViewContainerView") {
                            return;
                        }
                        // Focus on the first visible input, link, or button that isn't disabled.
                        try {
                            var unfilteredControls = $(view.root).find("input, a, button, select, textarea, [tabindex]").not(".inactive, .bound-invisible, .disabled, .close-16, .back-16, [tabindex=-1], [readonly]:not(.control-readonly)");
                            var filteredControls = [];
                            // Need to check parents to make sure they're not disabled, as if they are then we can't see the children.
                            for (var i = 0; i < unfilteredControls.length; i++) {
                                var currentControl = unfilteredControls[i];
                                if ($(currentControl).parentsUntil(view.root, ".inactive, .bound-invisible, .disabled, .invisible, .hidden-hoisted-menu").length >= 1) {
                                    continue;
                                }
                                // In order to prevent the soft keyboard from popping up on touch devices we need to make it so that the active control is
                                // set to readonly until the user interacts with it in a meaningful fashion. This means keyboard input, touch, or a mouse click.
                                // Once that happens, then we can make the field editable and this will activate the keyboard on touch.
                                var inputElements = ["select", "input", "textarea"];
                                if ($.inArray(currentControl.tagName.toLowerCase(), inputElements) !== -1) {
                                    if (currentControl === document.activeElement) {
                                        // We don't want to focus on the same element numerous times - this causes oddities on iOS.
                                        return;
                                    }
                                    $(currentControl).addClass("control-readonly");
                                    currentControl.setAttribute("readonly", "true");
                                    focus(currentControl);
                                    // Ensure that when this control loses focus that the readonly flag is removed.
                                    $(currentControl).one("blur", function (event) {
                                        currentControl.removeAttribute("readonly");
                                        $(currentControl).removeClass("control-readonly");
                                    });
                                    $(document).off("keypress.focus-control mousedown.focus-control touchstart.focus-control");
                                    $(document).off("keydown.focus-control");
                                    // This function is exposing a bug. 'focusOnFirstInput' is called when all animations stop causing a potential race condition. 
                                    // If user presses a key before focus has been moved to first input then other functions will be fired as well
                                    // (e.g. pressing '+' will zoom the map instead of adding character "+". Zoom appears to be fired by esri.js and not from AccessibilityModule).
                                    // For clarifications ask Gioele.
                                    // Key down will fire before keypress. Keydown fires for every key pressed while keypress will fire only for
                                    // "printable characters". 
                                    // We are only catching the backspace but we may catch other not printable characters.
                                    $(document).on("keydown.focus-control", function (event) { return (function (event, currentControl) {
                                        if (currentControl.getAttribute("readonly")) {
                                            //If backspace
                                            if (event.keyCode === 8) {
                                                event.preventDefault();
                                            }
                                        }
                                        else {
                                            $(document).off("keydown.focus-control");
                                        }
                                    })(event, currentControl); });
                                    $(document).one("keypress.focus-control mousedown.focus-control touchstart.focus-control", function (event) { return (function (event, currentControl) {
                                        // We need to use a closure to save the keydown event and the current control inside the loop
                                        currentControl.removeAttribute("readonly");
                                        $(currentControl).removeClass("control-readonly");
                                        var targetElement = event.target || event.srcElement;
                                        if (targetElement !== currentControl) {
                                            // Event element isn't the focused one, let's ditch the focus.
                                            currentControl.blur();
                                        }
                                        else {
                                            // IE requires that we lose focus on the element and then focus again in order for keyboard entry to work.
                                            // Thanks again, IE. You're a pal.
                                            currentControl.blur();
                                            focus(currentControl);
                                            var typeAttribute = currentControl.getAttribute("type");
                                            if (typeAttribute && typeAttribute.toLowerCase) {
                                                typeAttribute = typeAttribute.toLowerCase();
                                            }
                                            var currentControlIsWritable = function (currentControl) {
                                                if (currentControl.tagName.toLowerCase() === "textarea") {
                                                    return true;
                                                }
                                                else if (currentControl.contentEditable === "true") {
                                                    return true;
                                                }
                                                else if (typeAttribute) {
                                                    var allowedTypes = [
                                                        "date",
                                                        "datetime",
                                                        "datetime-local",
                                                        "email",
                                                        "month",
                                                        "number",
                                                        "password",
                                                        "search",
                                                        "text",
                                                        "tel",
                                                        "time",
                                                        "week"];
                                                    return allowedTypes.indexOf(typeAttribute) >= 0;
                                                }
                                                else {
                                                    return false;
                                                }
                                            };
                                            if (currentControlIsWritable(currentControl) && event.type === "keypress") {
                                                // The first keydown is lost to a text input if we don't add it keydown itself (ugh).
                                                // However - Firefox adds the character and registers the keycode here as 0. This causes
                                                // Firefox to add a garbage unicode character. Let's check the keycode before adding it.
                                                if (event.keyCode != 0) {
                                                    // http://stackoverflow.com/a/5829387
                                                    $(currentControl).val($(currentControl).val() + String.fromCharCode(event.keyCode));
                                                }
                                                // Edge doesn't move the cursor after the first entered letter but it won't doesn't add it
                                                // immediately either, so we must set a small timeout just for Edge. Sigh.
                                                if (/Edge\/12./i.test(navigator.userAgent)) {
                                                    setTimeout(function () {
                                                        currentControl.setSelectionRange(1, 1);
                                                    }, 10);
                                                }
                                            }
                                        }
                                        // Need to remove the binding - even though it's one time it will still fire a mousedown or touchstart after a keydown happens.
                                        // Each event seems to have its own one-time binding.
                                        $(document).off("keypress.focus-control mousedown.focus-control touchstart.focus-control");
                                        $(document).off("keydown.focus-control");
                                    })(event, currentControl); });
                                }
                                else {
                                    focus(currentControl);
                                }
                                // Need to escape, we've done our work here - it's focused.
                                break;
                            }
                        }
                        catch (exception) {
                            if (view.app) {
                                view.app.trace.debug("Could not focus: " + exception);
                            }
                        }
                    }
                    FocusUtils.focusOnFirstInput = focusOnFirstInput;
                    /**
                     * Sets the focus on the map control (if available)
                     * @param map The map control to focus on.
                     */
                    function focusOnMap(map) {
                        if (!map) {
                            return;
                        }
                        var action = function (esriMap) {
                            var mapRoot = esriMap.root;
                            // IE makes SVGs focusable. Let's put a stop to that to make things work for screen readers.
                            // Otherwise we end up with two tabbable elements and everything is absolutely awful.
                            $(mapRoot).find("svg").attr("focusable", "false");
                            mapRoot.tabIndex = 0;
                            focus(mapRoot);
                        };
                        if (map.loaded) {
                            action(map);
                        }
                        else {
                            // Map hasn't loaded yet. Wait for it to load before setting the focus.
                            var handle = map.on("load", function (event) {
                                handle.remove();
                                action(event.map);
                            });
                        }
                    }
                    FocusUtils.focusOnMap = focusOnMap;
                    /**
                     * Sets the focus on the specified DOM element.
                     * The focus is used to determine which element is the first to receive keyboard-related events.
                     */
                    function focus(domElement) {
                        if (!domElement) {
                            return;
                        }
                        // Focusing elements that are currently under a CSS transition causes big issues in most or all
                        // browsers(!). See GVH-5305.
                        geocortex.framework.ui.animation.runWhenIdle(function () {
                            try {
                                if (domElement === document.activeElement) {
                                    // We don't want to focus on the same element numerous times - this causes oddities on iOS.
                                    // This is done here as well as in focusOnElement since this occurs asynchronously. 
                                    return;
                                }
                                domElement.focus();
                            }
                            catch (e) {
                            }
                        });
                    }
                    FocusUtils.focus = focus;
                })(FocusUtils = infrastructure.FocusUtils || (infrastructure.FocusUtils = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../_Definitions/framework.d.ts"/>
/// <reference path="../../_Definitions/essentials.d.ts"/>
/// <reference path="../../_Definitions/arcgis-js-api.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var GraphicUtils;
                (function (GraphicUtils) {
                    var _layerIDMap = {};
                    /**
                     * Modifies the attributes array of the graphic so that it the keys are attribute
                     * names instead of aliases (as defined in ArcGIS Server).  Those attributes
                     * that are defined using attribute names will not be modified.
                     * @param graphic The ESRI graphic
                     * @param layer The Geocortex Essentials layer
                     */
                    function sanitizeAttributeNames(graphic, layer) {
                        // GVH-5394: The unique id is of the form <mapserviceid.layerid>
                        var uniqueLayerId = layer.mapService ? "{0}.{1}".format(layer.mapService.id, layer.id) : null;
                        // Get the map that converts from a field alias to a field name
                        var fieldAliasToNameMap;
                        if (uniqueLayerId && _layerIDMap[uniqueLayerId]) {
                            fieldAliasToNameMap = _layerIDMap[uniqueLayerId];
                        }
                        else {
                            fieldAliasToNameMap = {};
                            for (var i = 0; i < layer.fields.length; i++) {
                                var field = layer.fields[i];
                                // GVH-3473 Skip attribute names generated by SEP
                                if (_isSEPCodedDomainField(field, layer)) {
                                    continue;
                                }
                                fieldAliasToNameMap[field.alias] = field.name;
                            }
                            if (uniqueLayerId) {
                                _layerIDMap[uniqueLayerId] = fieldAliasToNameMap;
                            }
                        }
                        // Build up a collection of values to replace
                        var replacementValues = [];
                        for (var alias in fieldAliasToNameMap) {
                            if (!fieldAliasToNameMap.hasOwnProperty(alias) || !graphic.attributes.hasOwnProperty(alias)) {
                                continue;
                            }
                            // Note that if the word "Null" is found, it's replaced with a true null. Find task return nulls as text 
                            // (this is caused by Ersi on the server side, we can't control this). GVH-1127
                            if (graphic.attributes[alias] === "Null") {
                                graphic.attributes[alias] = null;
                            }
                            var value = graphic.attributes[alias];
                            if (value === undefined) {
                                continue;
                            }
                            var replacementValue = {
                                alias: alias,
                                name: fieldAliasToNameMap[alias],
                                value: value
                            };
                            if (replacementValue.alias != replacementValue.name) {
                                replacementValues.push(replacementValue);
                            }
                        }
                        // Do the replacement
                        for (var j = 0; j < replacementValues.length; j++) {
                            var replacement = replacementValues[j];
                            //GVH-3192
                            delete graphic.attributes[replacement.alias];
                            graphic.attributes[replacement.name] = replacement.value;
                        }
                    }
                    GraphicUtils.sanitizeAttributeNames = sanitizeAttributeNames;
                    /** @private GVH-3473 Skip attribute names generated by SEP */
                    function _isSEPCodedDomainField(field, layer) {
                        if (layer && field && field.name) {
                            // Field name ends with .Name()
                            if (field.name.indexOf(".Name()", field.name.length - ".Name()".length) !== -1) {
                                return true;
                            }
                            else if (layer.getFieldByName(field.name + ".Name()")) {
                                return true;
                            }
                        }
                        return false;
                    }
                    GraphicUtils._isSEPCodedDomainField = _isSEPCodedDomainField;
                    /**
                     * Utility method to execute the deleteMarkup function silently without any prompts even if multiple markup are being deleted
                     * @param geometry The geometry defining the area within which to delete markup. Typically passed in by the MapTool
                     * @param layerIds A string array of id's of layers to delete markup from
                     * @param app The current application instance
                     * @param callback An optional callback function which, if defined, will be passed the array of deleted graphics.
                     * @param onlyMeasurementMarkup: An optional parameter which if true will only delete measurement markup and labels from the specified layers. Defaults to false.
                     */
                    function deleteMarkupSilently(geometry, layerIds, app, callback, onlyMeasurementMarkup) {
                        if (onlyMeasurementMarkup === void 0) { onlyMeasurementMarkup = false; }
                        deleteMarkup(geometry, layerIds, app, callback, onlyMeasurementMarkup);
                    }
                    GraphicUtils.deleteMarkupSilently = deleteMarkupSilently;
                    /**
                     * Utility method for the "DeleteMarkup" and "DeleteMeasurement" commands, common to the Markup and Measurement modules. Placing it here ensures that there's no dependency between the two modules and no
                     * duplication of code. This method will delete all graphics from the given layer(s) and will display a warning if multiple items are being deleted (if configured). It can be run in two modes - if
                     * onlyMeasurementMarkup is true, it will delete only markup which is tagged by the measurement module - otherwise it will delete all markup.
                     * @param geometry The geometry defining the area within which to delete markup. Typically passed in by the MapTool
                     * @param layerIds A string array of id's of layers to delete markup from
                     * @param app The current application instance
                     * @param callback An optional callback function which, if defined, will be passed the array of deleted graphics.
                     * @param onlyMeasurementMarkup: An optional parameter which if true will only delete measurement markup and labels from the specified layers. Defaults to false.
                     * @param multipleMarkupWarnMsg An optional string defining the language resource for the warning to be displayed if more than one markup is being deleted. If not provided, will disable this warning.
                     * @param multipleMarkupWarnTitle An optional string defining the language resource for the title for the aforementioned warning.
                     * @param libraryId An optional string defining the library id to retrieve the aforementioned language resources from. Defaults to "Mapping"
                     */
                    function deleteMarkup(geometry, layerIds, app, callback, onlyMeasurementMarkup, multipleMarkupWarnMsg, multipleMarkupWarnTitle, libraryId) {
                        if (onlyMeasurementMarkup === void 0) { onlyMeasurementMarkup = false; }
                        if (libraryId === void 0) { libraryId = "Mapping"; }
                        var deleted = [];
                        var graphicsLayers = [];
                        var nettGraphicsToDelete = 0;
                        var measurementIdBucket = {};
                        var tryFireCallback = function (deletedGraphicArray) {
                            if (callback) {
                                callback(deletedGraphicArray);
                            }
                        };
                        var deleteGraphics = function () {
                            for (var i = 0; i < deleted.length; i++) {
                                if (deleted[i].visible) {
                                    if (onlyMeasurementMarkup && !deleted[i].hasOwnProperty("measurementId")) {
                                        deleted.splice(i, 1);
                                        continue;
                                    }
                                    var layer = deleted[i].getLayer();
                                    if (layer) {
                                        layer.remove(deleted[i]);
                                    }
                                }
                                else {
                                    deleted.splice(i, 1);
                                }
                            }
                        };
                        if (!geometry || !layerIds || !layerIds.length || !app) {
                            var errMsg = "Error deleting markup. Required parameters missing.";
                            if (app) {
                                app.trace.error(errMsg);
                            }
                            else {
                                console.log(errMsg);
                            }
                            tryFireCallback(deleted);
                            return;
                        }
                        for (var x = 0; x < layerIds.length; x++) {
                            var layer = app.map.getLayer(layerIds[x]);
                            if (!layer) {
                                continue;
                            }
                            graphicsLayers.push(layer);
                        }
                        if (!graphicsLayers.length) {
                            app.trace.error("Error deleting markup. No graphics layer(s) found.");
                            tryFireCallback(deleted);
                            return;
                        }
                        for (var y = 0; y < graphicsLayers.length; y++) {
                            var markup = getMarkupFromGeometry(geometry, graphicsLayers[y], app);
                            if (markup && markup.length) {
                                deleted = deleted.concat(markup);
                            }
                        }
                        // Ensure that all measurement labels corresponding to a particular graphic are treated as one graphic. Otherwise deleting a single 
                        // measurement graphic and its labels will trigger the "multiple" graphics warning.
                        for (var p = 0; p < deleted.length; p++) {
                            var currGraphic = deleted[p];
                            if (currGraphic.visible) {
                                if (currGraphic.hasOwnProperty("measurementId")) {
                                    if (!measurementIdBucket.hasOwnProperty(currGraphic["measurementId"])) {
                                        measurementIdBucket[currGraphic["measurementId"]] = true;
                                        nettGraphicsToDelete++;
                                    }
                                }
                                else if (!onlyMeasurementMarkup) {
                                    nettGraphicsToDelete++;
                                }
                            }
                            if (nettGraphicsToDelete > 1) {
                                break;
                            }
                        }
                        if (nettGraphicsToDelete === 0) {
                            tryFireCallback(deleted);
                        }
                        else if ((nettGraphicsToDelete === 1) || !multipleMarkupWarnMsg) {
                            deleteGraphics();
                            tryFireCallback(deleted);
                        }
                        else {
                            var content = app.getResource(libraryId, multipleMarkupWarnMsg);
                            var title = (multipleMarkupWarnTitle) ? app.getResource(libraryId, multipleMarkupWarnTitle) : null;
                            app.command("Confirm").execute(content, title, function (ok) {
                                if (ok) {
                                    deleteGraphics();
                                }
                                else {
                                    deleted = [];
                                }
                                tryFireCallback(deleted);
                            });
                        }
                    }
                    GraphicUtils.deleteMarkup = deleteMarkup;
                    /**
                     * Retrieves graphics contained within an extent specified by the given geometry from a given layer on the map.
                     * @param geometry The geometry defining the area on the specified layer from which to extract markup
                     * @param graphicsLayer The esri layer from which to extract markup
                     * @param app The current application instance
                     * @param simpleMarkerSymbolBufferDiameter Optional. Represents the diameter of the circle to buffer for a graphic with a simple marker symbol. Defautls to the size of the symbol in pixels.
                     * @param pointBufferDiameter Optional. Represents the diameter of a circle to buffer with the given point geometry as it's center. Defaults to 6.
                     * @return An array of esri.Graphic objects contained within the specified geometry on the specified layer.
                     */
                    function getMarkupFromGeometry(geometry, graphicsLayer, app, simpleMarkerSymbolBufferDiameter, pointBufferDiameter) {
                        if (pointBufferDiameter === void 0) { pointBufferDiameter = 6; }
                        var extent = null;
                        var markup = [];
                        if (!geometry || !graphicsLayer || !app) {
                            var errMsg = "Error retrieving markup. Required parameters missing.";
                            if (app) {
                                app.trace.error(errMsg);
                            }
                            else {
                                console.log(errMsg);
                            }
                            return markup;
                        }
                        if (!graphicsLayer.graphics.length) {
                            return markup;
                        }
                        // Get the extent represented by the geometry
                        if (geometry.type == "point") {
                            extent = getPolygonFromPoint(geometry, pointBufferDiameter, app).getExtent();
                        }
                        else if (geometry.type == "polyline") {
                            extent = geometry.getExtent();
                        }
                        else if (geometry.type == "polygon") {
                            extent = geometry.getExtent();
                        }
                        if (extent == null) {
                            app.trace.error("Error retrieving markup. Could not compute extent.");
                            return markup;
                        }
                        // Now retrieve the graphics contained in the extent.
                        for (var i = 0; i < graphicsLayer.graphics.length; i++) {
                            if (extent.intersects(graphicsLayer.graphics[i].geometry)) {
                                markup.push(graphicsLayer.graphics[i]);
                            }
                            else if (graphicsLayer.graphics[i].symbol instanceof esri.symbol.SimpleMarkerSymbol) {
                                if (graphicsLayer.graphics[i].geometry instanceof esri.geometry.Point) {
                                    var polygon = getPolygonFromPoint(graphicsLayer.graphics[i].geometry, simpleMarkerSymbolBufferDiameter || graphicsLayer.graphics[i].symbol.size, app);
                                    if (extent.intersects(polygon)) {
                                        markup.push(graphicsLayer.graphics[i]);
                                    }
                                }
                                else if (graphicsLayer.graphics[i].geometry instanceof esri.geometry.Multipoint) {
                                    var multipointSymbol = graphicsLayer.graphics[i].symbol;
                                    var multipointGeometry = graphicsLayer.graphics[i].geometry;
                                    for (var j = 0; j < multipointGeometry.points.length; j++) {
                                        var point = new esri.geometry.Point(multipointGeometry.points[j], multipointGeometry.spatialReference);
                                        if (extent.intersects(getPolygonFromPoint(point, simpleMarkerSymbolBufferDiameter || multipointSymbol.size, app))) {
                                            markup.push(graphicsLayer.graphics[i]);
                                            break;
                                        }
                                    }
                                }
                            }
                            else if (graphicsLayer.graphics[i].symbol instanceof esri.symbol.TextSymbol) {
                                var symbol = graphicsLayer.graphics[i].symbol;
                                var textSymbol = symbol;
                                var screenPoint = app.map.toScreen(graphicsLayer.graphics[i].geometry);
                                var dimentions = getRenderedTextMarkupSize(textSymbol.text, textSymbol.font.family, textSymbol.font.size, textSymbol.font.weight);
                                var height = dimentions.height;
                                var width = dimentions.width;
                                screenPoint.x += textSymbol.xoffset;
                                screenPoint.y -= textSymbol.yoffset;
                                switch (textSymbol.align) {
                                    case esri.symbol.TextSymbol.ALIGN_START:
                                        var topLeft = new esri.geometry.Point(screenPoint.x, screenPoint.y - height, null);
                                        var topRight = new esri.geometry.Point(screenPoint.x + width, screenPoint.y - height, null);
                                        var bottomLeft = new esri.geometry.Point(screenPoint.x, screenPoint.y, null);
                                        var bottomRight = new esri.geometry.Point(screenPoint.x + width, screenPoint.y, null);
                                        break;
                                    case esri.symbol.TextSymbol.ALIGN_MIDDLE:
                                        var topLeft = new esri.geometry.Point(screenPoint.x - width / 2, screenPoint.y - height, null);
                                        var topRight = new esri.geometry.Point(screenPoint.x + width / 2, screenPoint.y - height, null);
                                        var bottomLeft = new esri.geometry.Point(screenPoint.x - width / 2, screenPoint.y, null);
                                        var bottomRight = new esri.geometry.Point(screenPoint.x + width / 2, screenPoint.y, null);
                                        break;
                                    case esri.symbol.TextSymbol.ALIGN_END:
                                        var topLeft = new esri.geometry.Point(screenPoint.x - width, screenPoint.y - height, null);
                                        var topRight = new esri.geometry.Point(screenPoint.x, screenPoint.y - height, null);
                                        var bottomLeft = new esri.geometry.Point(screenPoint.x - width, screenPoint.y, null);
                                        var bottomRight = new esri.geometry.Point(screenPoint.x, screenPoint.y, null);
                                        break;
                                }
                                topLeft = app.map.toMap(topLeft);
                                topRight = app.map.toMap(topRight);
                                bottomLeft = app.map.toMap(bottomLeft);
                                bottomRight = app.map.toMap(bottomRight);
                                var textPolygon = new esri.geometry.Polygon({
                                    "rings": [[[topLeft.x, topLeft.y], [topRight.x, topRight.y], [bottomRight.x, bottomRight.y], [bottomLeft.x, bottomLeft.y]]],
                                    "spatialReference": topLeft.spatialReference
                                });
                                // GVH-3579: Rotate the "Hit Box" to match the angle of the text
                                textPolygon = rotatePolygon(symbol.angle, graphicsLayer.graphics[i].geometry, textPolygon);
                                if (extent.intersects(textPolygon)) {
                                    markup.push(graphicsLayer.graphics[i]);
                                }
                            }
                        }
                        return markup;
                    }
                    GraphicUtils.getMarkupFromGeometry = getMarkupFromGeometry;
                    /**
                     * Function to rotate any given polygon by a specified angle. Returns a rotated copy of the original polygon.
                     * @param degreesClockwise The angle to rotate the polygon in, specified in degrees, in a clockwise direction (as is standard for esri)
                     * @param pivotMapPoint The "pivot" around which to rotate the polygon. Is not required to lie on or within the polygon
                     * @param polygon The polygon to rotate.
                     * @return A rotated copy of the original polygon
                     */
                    function rotatePolygon(degreesClockwise, pivotMapPoint, polygon) {
                        var rotatedPolygon = new esri.geometry.Polygon(polygon.toJson());
                        var degs = ((degreesClockwise < 0) ? (360 + degreesClockwise) : degreesClockwise) % 360;
                        var radiansAntiClockwise = (360 - degs) * (Math.PI / 180);
                        for (var ringIndex = 0; ringIndex < rotatedPolygon.rings.length; ringIndex++) {
                            for (var pointIndex = 0; pointIndex < rotatedPolygon.rings[ringIndex].length; pointIndex++) {
                                var currPoint = rotatedPolygon.getPoint(ringIndex, pointIndex);
                                var rotatedXCoord = (((currPoint.x - pivotMapPoint.x) * Math.cos(radiansAntiClockwise)) - ((currPoint.y - pivotMapPoint.y) * Math.sin(radiansAntiClockwise)) + pivotMapPoint.x);
                                var rotatedYCoord = (((currPoint.x - pivotMapPoint.x) * Math.sin(radiansAntiClockwise)) + ((currPoint.y - pivotMapPoint.y) * Math.cos(radiansAntiClockwise)) + pivotMapPoint.y);
                                currPoint.setX(rotatedXCoord);
                                currPoint.setY(rotatedYCoord);
                                rotatedPolygon.setPoint(ringIndex, pointIndex, currPoint);
                            }
                        }
                        return rotatedPolygon;
                    }
                    GraphicUtils.rotatePolygon = rotatePolygon;
                    /** Function to generate a polygon containing a specified incircle with a given point as it's center.
                     *  @param point The center of the specified incircle
                     *  @param diameter The diameter of the specified incircle
                     *  @param app The current application instance
                     *  @return A polygon containing an incircle of the specified diameter, with the specified point as its center
                     */
                    function getPolygonFromPoint(point, diameter, app) {
                        // GVH-9180: Ensure that diameter is not a string like "12px". If it is, then convert it into a number.
                        diameter = parseFloat(diameter);
                        var screenPoint = app.map.toScreen(point);
                        var rootedDiameter = (diameter / Math.sqrt(2)) / 2;
                        var topLeft = new esri.geometry.Point(screenPoint.x - rootedDiameter, screenPoint.y - rootedDiameter, null);
                        var topRight = new esri.geometry.Point(screenPoint.x + rootedDiameter, screenPoint.y - rootedDiameter, null);
                        var bottomLeft = new esri.geometry.Point(screenPoint.x - rootedDiameter, screenPoint.y + rootedDiameter, null);
                        var bottomRight = new esri.geometry.Point(screenPoint.x + rootedDiameter, screenPoint.y + rootedDiameter, null);
                        topLeft = app.map.toMap(topLeft);
                        topRight = app.map.toMap(topRight);
                        bottomLeft = app.map.toMap(bottomLeft);
                        bottomRight = app.map.toMap(bottomRight);
                        var polygon = new esri.geometry.Polygon({
                            "rings": [[[topLeft.x, topLeft.y], [topRight.x, topRight.y], [bottomRight.x, bottomRight.y], [bottomLeft.x, bottomLeft.y], [topLeft.x, topLeft.y]]],
                            "spatialReference": topLeft.spatialReference
                        });
                        return polygon;
                    }
                    GraphicUtils.getPolygonFromPoint = getPolygonFromPoint;
                    function getRenderedTextMarkupSize(labelStr, fontFamily, fontSizeNumberOrString, fontWeight) {
                        if (fontWeight === void 0) { fontWeight = "normal"; }
                        var page = document.body;
                        var container = document.createElement("div");
                        var size = ((fontSizeNumberOrString != undefined) && (typeof fontSizeNumberOrString === "number")) ? fontSizeNumberOrString + "px" : fontSizeNumberOrString; // Esri's js api 3.8 reports size as a number - in pixels. Safeguard.
                        var attr = { fontFamily: fontFamily, fontSize: size, fontWeight: fontWeight, padding: "0", position: "absolute", lineHeight: "1", visibility: "hidden" };
                        for (var p in attr) {
                            container.style[p] = attr[p];
                        }
                        container.appendChild(document.createTextNode(labelStr));
                        page.appendChild(container);
                        var result = {
                            width: container.clientWidth,
                            height: container.clientHeight
                        };
                        page.removeChild(container);
                        return result;
                    }
                    GraphicUtils.getRenderedTextMarkupSize = getRenderedTextMarkupSize;
                    /**
                     * Add a graphic to the specified layer
                     * @param graphic The graphic to be added
                     * @param layerId The layer ID to add the graphic to
                     * @app The app that this module belongs to
                     * @return A boolean returning true on success and false otherwise
                     */
                    function addGraphicToLayer(graphic, layerId, app) {
                        if (graphic) {
                            var layer = getGraphicsLayer(layerId, true, app);
                            layer.add(graphic);
                            // Make sure the layer is visible.
                            if (!layer.visible) {
                                layer.setVisibility(true);
                            }
                            return true;
                        }
                        return false;
                    }
                    GraphicUtils.addGraphicToLayer = addGraphicToLayer;
                    /**
                     * Retrieve the graphic layer with the specified id if it exists. If 'create' is true, create it if it doesn't
                     * @param id The layer ID to retrieve or to create
                     * @param create Create the layer if it doesn't exist if this is true
                     * @param app The application that this module belongs to
                     * @return The retrieved or created Graphics layer
                     */
                    function getGraphicsLayer(id, create, app) {
                        // Get the Graphics layer
                        var layer = app.map.getLayer(id);
                        // Create the graphics layer if it doesn't exist, and we're supposed to create
                        if (!layer && create) {
                            layer = new esri.layers.GraphicsLayer();
                            layer.id = id;
                            app.map.addLayer(layer);
                        }
                        return layer;
                    }
                    GraphicUtils.getGraphicsLayer = getGraphicsLayer;
                    /**
                     * Gets the map's graphics layers that are neither associated with the Essentials site nor used internally by GVH.
                     */
                    function getUserGraphicsLayers(app) {
                        var isEssentialsLayer = function (layer) { return app.site.essentialsMap.mapServices.some(function (ms) {
                            return ms.serviceLayer === layer || (ms.serviceLayer instanceof esri.layers.KMLLayer && ms.serviceLayer.getLayers().indexOf(layer) >= 0);
                        }); };
                        var results = [];
                        // Exclude special layers used by GVH, such as those used for snapping, pushpins, and highlighting.
                        var layersToExclude = ["snapping_graphics", "snapping_helper_graphics", "DefaultPushpinsLayer"];
                        var highlightLayers = app.highlightManager.getHighlightLayers();
                        for (var name in highlightLayers) {
                            layersToExclude.push(highlightLayers[name].id);
                        }
                        app.map.graphicsLayerIds.forEach(function (id) {
                            var graphicsLayer = app.map.getLayer(id);
                            if (isEssentialsLayer(graphicsLayer) || graphicsLayer instanceof infrastructure.ClusterLayer || graphicsLayer.id.endsWith("-explodedClusterLayer") || layersToExclude.indexOf(id) >= 0) {
                                // Skip.
                                return;
                            }
                            results.push(graphicsLayer);
                        });
                        return results;
                    }
                    GraphicUtils.getUserGraphicsLayers = getUserGraphicsLayers;
                })(GraphicUtils = infrastructure.GraphicUtils || (infrastructure.GraphicUtils = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../_Definitions/framework.d.ts"/>
/// <reference path="../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../_Definitions/dojo.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var SecurityUtils;
                (function (SecurityUtils) {
                    // Claim type values for Geocortex business level
                    // Refer to CustomClaimTypes in Essentials for more claim types
                    var CLAIM_TYPE_PRIVILEGE = "http://www.geocortex.net/security/claims/privilege";
                    /**
                     * Get an identity based on the authentication type.
                     * @param authenticationType The authentication type of the identity to find
                     * @param app The current application instance
                     */
                    function getIdentity(authenticationType, app) {
                        var site = app.site;
                        if (!site || !site.principal || !site.principal.identities) {
                            return null;
                        }
                        return geocortex.framework.utils.ArrayUtils.firstOrDefault(site.principal.identities, function (identity) { return identity.authenticationType === authenticationType; });
                    }
                    SecurityUtils.getIdentity = getIdentity;
                    /**
                     * Get a claim based on the claim type.
                     * @param identity The identity in which to search for claims
                     * @param type The claim type to find
                     */
                    function getClaimsByType(identity, type) {
                        return identity.claims.filter(function (claim) { return claim.type === type; });
                    }
                    SecurityUtils.getClaimsByType = getClaimsByType;
                    /**
                     * Get a claim based on the claim value.
                     * @param identity The identity in which to search for claims
                     * @param value The claim value to find
                     */
                    function getClaimsByValue(identity, value) {
                        return identity.claims.filter(function (claim) { return claim.value === value; });
                    }
                    SecurityUtils.getClaimsByValue = getClaimsByValue;
                    /**
                     * Get a claim based on the claim type and value.
                     * @param identity The identity in which to search for claims
                     * @param type The claim type to find
                     * @param value The claim value to find
                     */
                    function getClaimByTypeAndValue(identity, type, value) {
                        return geocortex.framework.utils.ArrayUtils.firstOrDefault(identity.claims, function (claim) { return claim.type === type && claim.value === value; });
                    }
                    SecurityUtils.getClaimByTypeAndValue = getClaimByTypeAndValue;
                    /**
                     * Check if the identity has a given privilege.
                     * @param identity The identity in which to search the claims for a specific privilege
                     * @param value The privilege value to find
                     */
                    function hasPrivilegeClaim(identity, value) {
                        return !!getClaimByTypeAndValue(identity, CLAIM_TYPE_PRIVILEGE, value);
                    }
                    SecurityUtils.hasPrivilegeClaim = hasPrivilegeClaim;
                })(SecurityUtils = infrastructure.SecurityUtils || (infrastructure.SecurityUtils = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var selection;
                (function (selection) {
                    /** Describes how features from one collection should be combined with existing features in another collection. */
                    var CombineMode;
                    (function (CombineMode) {
                        /** Replaces the values in one collection with the values from another. */
                        CombineMode.REPLACE = "replace";
                        /** Produces the set union, which means unique elements that appear in either of two collections. */
                        CombineMode.UNION = "union";
                        /** Produces the set difference, which means the elements of one collection that do not appear in a second collection. */
                        CombineMode.SUBTRACT = "subtract";
                        /** Produces the set intersection, which means elements that appear in each of two collections. */
                        CombineMode.INTERSECT = "intersect";
                    })(CombineMode = selection.CombineMode || (selection.CombineMode = {}));
                })(selection = infrastructure.selection || (infrastructure.selection = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/Framework.d.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var selection;
                (function (selection) {
                    /**
                     * Helper class that models a storage facility for selection metadata.
                     */
                    var SelectionMetadataStore = (function () {
                        function SelectionMetadataStore(app) {
                            /** Internal state holding metadata about saved selections */
                            this._store = new infrastructure.Dictionary();
                            this.app = app;
                        }
                        SelectionMetadataStore.prototype.findByName = function (name) {
                            var query = { name: name };
                            var results = this.find(query);
                            return geocortex.framework.utils.ArrayUtils.firstOrDefault(results);
                        };
                        SelectionMetadataStore.prototype.findByCollectionId = function (fscId) {
                            var query = { featureSetCollectionIds: [fscId] };
                            var results = this.find(query);
                            return geocortex.framework.utils.ArrayUtils.firstOrDefault(results);
                        };
                        SelectionMetadataStore.prototype.findById = function (id) {
                            var query = { ids: [id] };
                            var results = this.find(query);
                            return geocortex.framework.utils.ArrayUtils.firstOrDefault(results);
                        };
                        SelectionMetadataStore.prototype.findAll = function () {
                            // Query parameters are optional. If not supplied we enumerate all metadata.
                            return this.find();
                        };
                        SelectionMetadataStore.prototype.find = function (queryParameters) {
                            // Query parameters are optional. If not supplied we enumerate all metadata.
                            queryParameters = queryParameters || {};
                            var results = this._store.values();
                            if (queryParameters.ids && queryParameters.ids.length > 0) {
                                results = results.filter(function (x) { return queryParameters.ids.indexOf(x.id) > -1; });
                            }
                            if (queryParameters.featureSetCollectionIds && queryParameters.featureSetCollectionIds.length > 0) {
                                results = results.filter(function (x) { return queryParameters.featureSetCollectionIds.indexOf(x.featureSetCollectionId) > -1; });
                            }
                            if (queryParameters.name) {
                                results = results.filter(function (x) { return x.name && x.name == queryParameters.name; });
                            }
                            if (queryParameters.dateCreatedMin && queryParameters.dateCreatedMin instanceof Date) {
                                var timeCreatedMin = queryParameters.dateCreatedMin.getTime();
                                results = results.filter(function (x) { return typeof x.timeCreated != "undefined" && x.timeCreated >= timeCreatedMin; });
                            }
                            if (queryParameters.dateCreatedMax && queryParameters.dateCreatedMax instanceof Date) {
                                var timeCreatedMax = queryParameters.dateCreatedMax.getTime();
                                results = results.filter(function (x) { return typeof x.timeCreated != "undefined" && x.timeCreated <= timeCreatedMax; });
                            }
                            if (queryParameters.dateModifiedMin && queryParameters.dateModifiedMin instanceof Date) {
                                var timeModifiedMin = queryParameters.dateModifiedMin.getTime();
                                results = results.filter(function (x) { return typeof x.timeModified != "undefined" && x.timeModified >= timeModifiedMin; });
                            }
                            if (queryParameters.dateModifiedMax && queryParameters.dateModifiedMax instanceof Date) {
                                var timeModifiedMax = queryParameters.dateModifiedMax.getTime();
                                results = results.filter(function (x) { return typeof x.timeModified != "undefined" && x.timeModified <= timeModifiedMax; });
                            }
                            if (queryParameters.dateExpirationMin && queryParameters.dateExpirationMin instanceof Date) {
                                var timeExpirationMin = queryParameters.dateExpirationMin.getTime();
                                results = results.filter(function (x) { return typeof x.timeExpiration != "undefined" && x.timeExpiration >= timeExpirationMin; });
                            }
                            if (queryParameters.dateExpirationMax && queryParameters.dateExpirationMax instanceof Date) {
                                var timeExpirationMax = queryParameters.dateExpirationMax.getTime();
                                results = results.filter(function (x) { return typeof x.timeExpiration != "undefined" && x.timeExpiration <= timeExpirationMax; });
                            }
                            // Return a copy of the stored metadata. We don't want external consumers to be able to change the metadata directly.
                            return results.map(function (x) { return dojo.mixin({}, x); });
                        };
                        SelectionMetadataStore.prototype.add = function (metadata) {
                            if (!metadata) {
                                throw new Error("The selection metadata cannot be null.");
                            }
                            // Store a copy of the provided object. That way the internal state cannot be manipulated from outside of this class.
                            var copy = dojo.mixin({}, metadata);
                            var newId = copy.id = this._generateId();
                            this._store.set(newId, copy);
                            return newId;
                        };
                        SelectionMetadataStore.prototype.updateById = function (id, values) {
                            if (!id) {
                                throw new Error("The metadata ID must be set.");
                            }
                            if (!values) {
                                throw new Error("The selection metadata cannot be null.");
                            }
                            if (!this._store.containsKey(id)) {
                                throw new Error("Selection metadata with ID '{0}' not found.".format(id));
                            }
                            var meta = this._store.get(id);
                            this._update(meta, values);
                        };
                        SelectionMetadataStore.prototype.removeById = function (id) {
                            if (!id) {
                                throw new Error("The metadata ID must be set.");
                            }
                            this._store.remove(id);
                        };
                        SelectionMetadataStore.prototype.clear = function () {
                            this._store.clear();
                        };
                        SelectionMetadataStore.prototype._update = function (metadata, values) {
                            metadata.name = values.name;
                            metadata.count = values.count;
                            metadata.timeCreated = values.timeCreated;
                            metadata.timeModified = values.timeModified;
                            metadata.timeExpiration = metadata.timeExpiration;
                            metadata.featureSetCollectionId = values.featureSetCollectionId;
                            metadata.modified = values.modified;
                        };
                        SelectionMetadataStore.prototype._generateId = function () {
                            return geocortex.framework.utils.alphaNumericToken();
                        };
                        return SelectionMetadataStore;
                    }());
                    selection.SelectionMetadataStore = SelectionMetadataStore;
                })(selection = infrastructure.selection || (infrastructure.selection = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../_Definitions/moment.d.ts" />
/// <reference path="../../_Definitions/moment-timezone.d.ts" />
/**
 * Time is a tricky business, made more tricky by local implementation of time zones. The two major concepts when dealing with time are that of an
 * "instant" and that of a "clock"; in general, an "instant" is the moment in the history of the Universe when an event precisely occurs (setting aside
 * concerns of relativity and the impossibility of simultinaety), and clocks around the world will say different things to describe this instant. By
 * convention, the "standard" clock is one which is set in Universal Coordinated Time (UTC). All local times (i.e., all other clock times) are offset by
 * some number of minutes from UTC, generally (though not always) in hour or half-hour increments. A "time zone", by definition, is an area of the world
 * in which all clocks agree with one another. Thus the same instant will have the same "clock time" inside a given time zone, but the "clock time" for
 * that same instant will generally differ across different time zones.
 *
 * Computers have tried to make this process as seamless as possible by communicating time via UTC timestamps, and then converting those timestamps to
 * the clock time of their local time zone. So in the viewer, when a user sees a date, that date has been consumed by JavaScript as a timestamp in UTC, and the
 * Date object converts itself to the system time of the client machine when it is presented to the user.
 *
 * TimeZoneUtils solves two problems associated with this behaviour. The first is ArcGIS Server generally communicates dates as UTC timestamps, while
 * administrators do not always store their times in UTC. This can lead to the wrong time showing up when JavaScript automatically converts the timestamp
 * from UTC time to local time, since the timestamp might not actually describe an instant in UTC time. The second problem is that administrators may
 * wish their dates to look the same for all of their users, regardless of the users' time zones; that is, they do not want the dates converted to the
 * users' clock times, but instead to the clock time of a preselected time zone, and they want this time to look the same no matter where the user is
 * located in the world. The various constants and methods in this module are designed with these problems in mind.
 */
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var TimeZoneUtils;
                (function (TimeZoneUtils) {
                    // The constant denoting the UTC time zone, which in general results in no offset being applied.
                    TimeZoneUtils.UTC_ZONE_ID = "Etc/UTC";
                    /**
                     * Retrieves the time zone from a layer (or the layer's map service, or the site).
                     * @param holder The layer whose time zone we are interrogating.
                     */
                    function getTimeZoneFromLayer(holder) {
                        if (!holder) {
                            return null;
                        }
                        var layerZoneId = null;
                        var mapServiceZoneId = null;
                        layerZoneId = holder.timeZoneId;
                        if (holder.mapService) {
                            mapServiceZoneId = getTimeZoneFromMapService(holder.mapService);
                        }
                        return geocortex.framework.utils.ArrayUtils.firstOrDefault([layerZoneId, mapServiceZoneId], function (id) { return !!id; });
                    }
                    TimeZoneUtils.getTimeZoneFromLayer = getTimeZoneFromLayer;
                    /**
                     * Retrieves the time zone from a map service (or the site).
                     * @param holder The map service whose time zone we are interrogating.
                     */
                    function getTimeZoneFromMapService(holder) {
                        if (!holder) {
                            return null;
                        }
                        var mapServiceZoneId = null;
                        var siteZoneId = null;
                        mapServiceZoneId = holder.timeZoneId;
                        if (holder.essentialsMap && holder.essentialsMap.site) {
                            siteZoneId = holder.essentialsMap.site.timeZoneId;
                        }
                        return geocortex.framework.utils.ArrayUtils.firstOrDefault([mapServiceZoneId, siteZoneId], function (id) { return !!id; });
                    }
                    TimeZoneUtils.getTimeZoneFromMapService = getTimeZoneFromMapService;
                    /**
                     * Retrieves the display time zone from a map service's site.
                     * @param holder The map service whose display time zone we are interrogating.
                     */
                    function getDisplayTimeZoneFromMapService(holder) {
                        if (!holder) {
                            return null;
                        }
                        if (holder.essentialsMap && holder.essentialsMap.site) {
                            return holder.essentialsMap.site.displayTimeZoneId;
                        }
                        return null;
                    }
                    TimeZoneUtils.getDisplayTimeZoneFromMapService = getDisplayTimeZoneFromMapService;
                    /**
                     * This method offsets displayed dates to display to the user in a time zone defined by an administrator. JavaScript's native
                     * Date objects automatically display themselves in the local time of the client machine. For example, if a date reads 3PM in
                     * New York, in general that same date will read 12PM in Los Angeles. This is not appropriate for all applications; sometimes
                     * we would like to make sure a date has the same display value to any user in any location. The current method accomplishes that.
                     * @param date The date to modify for display.
                     * @param databaseTimeZoneId The time zone of the date as stored in the database.
                     * @param displayTimeZoneId The time zone in which the date should be displayed.
                     */
                    function correctDatesForDisplayInDisplayTimeZone(date, databaseTimeZoneId, displayTimeZoneId) {
                        // If we're missing a database ID, we proceed under the assumption that no offset for that time zone should be applied,
                        // which is best accomplished by using UTC.
                        if (!databaseTimeZoneId) {
                            databaseTimeZoneId = TimeZoneUtils.UTC_ZONE_ID;
                        }
                        // If we have no user time zone, then we have no business being in this function, and we'll give back the date corrected
                        // for database time.
                        if (!displayTimeZoneId) {
                            return correctDatesForDisplayInLocalTime(date, databaseTimeZoneId);
                        }
                        // JavaScript's dateObj.getTimezoneOffset() method returns the number of minutes from the client machine's time zone
                        // to UTC. The moment.tz(date, time zone).utcOffset() method returns the number of minutes from UTC to the given time
                        // zone. We normalize the expected offsets by negating the date's offset.
                        var browserOffsetFromUtc = -date.getTimezoneOffset();
                        var displayZoneOffsetFromUtc = moment.tz(date.getTime(), displayTimeZoneId).utcOffset();
                        // Next we combine the offsets and get the date object in its proper database time (i.e., so that JavaScript's native client offset
                        // will yield the correct result when the client and server are both in the same time zone). The dateInDatabaseTime has the
                        // correct UTC timestamp for the date in its own time zone, while the combined offset will alter the UTC timestamp so that it
                        // reflects the same clock reading as the database time in the client's time zone, no matter where the client is located.
                        var deltaOffset = -(browserOffsetFromUtc - displayZoneOffsetFromUtc);
                        var dateInDatabaseTime = correctDatesForDisplayInLocalTime(date, databaseTimeZoneId);
                        return moment(dateInDatabaseTime).add(deltaOffset, "minutes").toDate();
                    }
                    TimeZoneUtils.correctDatesForDisplayInDisplayTimeZone = correctDatesForDisplayInDisplayTimeZone;
                    /**
                     * Many users store dates in their local time zones, and they may not advertise this fact to ArcGIS Server.
                     * This may cause a mismatch when ArcGIS Server serializes the date field as a UNIX timestamp,
                     * whose time zone is always UTC (also known as GMT). Thus the browser will offset the dates it displays in local time, assuming
                     * that its Date objects are generated from UNIX timestamps; in this function, dates' presentable values are offset to their true
                     * UTC values, depending on the time zone ID for the layer (or map service, or site) containing this date. If there is no time
                     * zone ID, this function should not be called; if the time zone ID is a UTC equivalent (e.g., Etc/GMT, Etc/UCT, Etc/UCT), then
                     * no offset should be applied.
                     * @param date The date to potentially offset.
                     * @param timeZoneId The IANA ID of the time zone in which the data are recorded in the database
                     */
                    function correctDatesForDisplayInLocalTime(date, timeZoneId) {
                        // If we don't have a time zone ID, we should not make an offset.
                        if (!timeZoneId) {
                            return date;
                        }
                        // The moment.tz(date, time zone).utcOffset() method reflects the offset from UTC (in minutes) to the given 
                        // time zone; we are interested in reversing this offset (i.e., getting the actual UTC time value for the date 
                        // stored in the database, which was potentially misconsumed as being in UTC in the first place). Thus we 
                        // reverse the offset and apply it to the original date. In this way, a browser will correctly display the
                        // date as though it were stored in UTC all along.
                        var offsetFromUtc = moment.tz(date.getTime(), timeZoneId).utcOffset();
                        var minuteOffset = -offsetFromUtc;
                        return moment(date).add(minuteOffset, "minutes").toDate();
                    }
                    TimeZoneUtils.correctDatesForDisplayInLocalTime = correctDatesForDisplayInLocalTime;
                    /**
                     * Many users store dates in their local time zones, and they may not advertise this fact to ArcGIS Server.
                     * This may cause a mismatch when ArcGIS Server serializes the date field as a UNIX timestamp,
                     * whose time zone is always UTC (also known as GMT). Thus the browser will submit dates to the server in UTC, regardless of
                     * which time zone the data are stored in; in this function, dates' submitted values are offset to their true
                     * UTC values, depending on the time zone ID for the layer (or map service, or site) containing this date. If there is no time
                     * zone ID, this function should not be called; if the time zone ID is a UTC equivalent (e.g., Etc/GMT, Etc/UCT, Etc/UCT), then
                     * no offset should be applied.
                     * @param date The date to offset
                     * @param databaseTimeZoneId The IANA ID of the time zone in which the data are recorded in the database
                     * @param displayTimeZoneId The IANA ID of the time zone in which the data are displayed to the user.
                     */
                    function correctDatesToSubmitInDatabaseTime(date, databaseTimeZoneId, displayTimeZoneId) {
                        if (!databaseTimeZoneId) {
                            databaseTimeZoneId = TimeZoneUtils.UTC_ZONE_ID;
                        }
                        // We add a UTC offset to the date, so that the date the user sees being submitted is the actual
                        // date submitted to the server.
                        var databaseOffsetToUtc = moment.tz(date.getTime(), databaseTimeZoneId).utcOffset();
                        if (!displayTimeZoneId) {
                            return moment(date).add(databaseOffsetToUtc, "minutes").toDate();
                        }
                        // If we have a display time zone, then the time we are consuming actually belongs to that time zone.
                        // We must add the offset bewtween the display and database time zones to get the proper timestamp submitted.
                        var displayZoneOffsetToUtc = moment.tz(date.getTime(), displayTimeZoneId).utcOffset();
                        var deltaOffset = databaseOffsetToUtc - displayZoneOffsetToUtc;
                        var browserOffsetFromUtc = -date.getTimezoneOffset();
                        return moment(date).add(browserOffsetFromUtc + deltaOffset, "minutes").toDate();
                    }
                    TimeZoneUtils.correctDatesToSubmitInDatabaseTime = correctDatesToSubmitInDatabaseTime;
                    /**
                     * The QueryBuilder takes date objects implicitly in local time (with respect to the browser) and parses them as strings, which
                     * we then submit as a query. This is not always appropriate if, for example, the database is properly-configured in UTC, or if
                     * it happens to be in another time zone. Hence this method corrects a date from the browser's time to the zone corresponding to
                     * the given database and display time zone IDs.
                     * @param date The date to offset
                     * @param databaseTimeZoneId The IANA ID of the time zone in which the data are recorded in the database
                     * @param displayTimeZoneId The IANA ID of the time zone in which the data are displayed.
                     */
                    function correctDatesToQueryInDatabaseTime(date, databaseTimeZoneId, displayTimeZoneId) {
                        // If we don't have a databse time zone ID, we proceed under the assumption that the database is in UTC,
                        // or its time zone is otherwise accounted for.
                        if (!databaseTimeZoneId) {
                            databaseTimeZoneId = TimeZoneUtils.UTC_ZONE_ID;
                        }
                        var offsetFromUtcToDatabaseTime = moment.tz(date.getTime(), databaseTimeZoneId).utcOffset();
                        if (!displayTimeZoneId) {
                            // If we don't have a display time zone ID, then the user is seeing the database time corrected
                            // for the client machine's time zone, and so we nudge the date object to the database's time zone.
                            var offsetFromBrowserToUtc = date.getTimezoneOffset();
                            return moment(date).add(offsetFromBrowserToUtc + offsetFromUtcToDatabaseTime, "minutes").toDate();
                        }
                        // We have a display time zone ID, and so the user is seeing times normalized in the display time zone. Thus we can ignore
                        // the time zone of the client, and simply nudge the date object to the database's time zone from the display time zone.
                        var offsetFromUtcToDisplayTimeZone = moment.tz(date.getTime(), displayTimeZoneId).utcOffset();
                        var deltaOffset = offsetFromUtcToDatabaseTime - offsetFromUtcToDisplayTimeZone;
                        return moment(date).add(deltaOffset, "minutes").toDate();
                    }
                    TimeZoneUtils.correctDatesToQueryInDatabaseTime = correctDatesToQueryInDatabaseTime;
                })(TimeZoneUtils = infrastructure.TimeZoneUtils || (infrastructure.TimeZoneUtils = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ui;
                (function (ui) {
                    var components;
                    (function (components) {
                        var ColorPicker;
                        (function (ColorPicker) {
                            /**
                             * The ColorPicker widget view.
                             */
                            var ColorPickerView = (function (_super) {
                                __extends(ColorPickerView, _super);
                                function ColorPickerView() {
                                    _super.apply(this, arguments);
                                }
                                /**
                                 * Acquire the currently selected color swatch.
                                 */
                                ColorPickerView.prototype.getSelectedColorSwatch = function () {
                                    var swatches = this.viewModel.colorSwatches.get();
                                    for (var i = 0; i < swatches.length; i++) {
                                        var swatch = swatches[i];
                                        var radio = this.colorSwatchFieldSet.children[i].querySelector("input[type=radio]");
                                        if (radio.checked) {
                                            return swatch;
                                        }
                                    }
                                };
                                ColorPickerView.prototype.activated = function () {
                                    _super.prototype.activated.call(this);
                                    this.reset();
                                };
                                /**
                                 * Attach this view to its view-model.
                                 */
                                ColorPickerView.prototype.attach = function (viewModel) {
                                    viewModel.initialize(this.configuration);
                                    _super.prototype.attach.call(this, viewModel);
                                };
                                /**
                                 * This widget attaches a reference to itself onto the parent view.
                                 */
                                ColorPickerView.prototype.added = function (parentView) {
                                    parentView.colorPickerWidget = this;
                                    _super.prototype.added.call(this, parentView);
                                };
                                /**
                                 * Reset the ColorPicker widget to its initial state.
                                 */
                                ColorPickerView.prototype.reset = function () {
                                    var _this = this;
                                    var configuration = this.viewModel.configuration;
                                    this.viewModel.colorSwatches.clear();
                                    // Set black
                                    var black = {
                                        hex: "#000000",
                                        setName: this.viewModel.swatchSetName
                                    };
                                    // Set initial values.
                                    var orig;
                                    // If there was an original color set, use it
                                    if (!!this.viewModel.originalColor.get()) {
                                        orig = {
                                            hex: this.viewModel.originalColor.get().toHex(),
                                            setName: this.viewModel.swatchSetName
                                        };
                                    }
                                    else {
                                        orig = {
                                            hex: this.viewModel.defaultColor.get().toHex(),
                                            setName: this.viewModel.swatchSetName
                                        };
                                    }
                                    // Set the input color displayed in the panel to the default/original color
                                    this.colorInput.value = orig.hex;
                                    // Don't add the default/original color if it's black, so there aren't any duplicatess
                                    if (black.hex !== orig.hex) {
                                        this.viewModel.colorSwatches.addItem(orig);
                                    }
                                    // Initialize color swatches.
                                    this.viewModel.colorSwatches.addItem(black);
                                    this.viewModel.colorSwatches.addItems(generateRandomColors(configuration.numberOfColorSwatches).map(function (hex) { return ({ hex: hex, setName: _this.viewModel.swatchSetName }); }));
                                    this.viewModel.colorSwatches.get().forEach(function (swatch, index) {
                                        var label = _this.colorSwatchFieldSet.children[index];
                                        label.style.backgroundColor = swatch.hex;
                                    });
                                    this.colorSwatchFieldSet.querySelector(".color-swatch:first-child > input[type=radio]").checked = true;
                                    // Pulse to update the view-model with this initial state.
                                    this.handleChange();
                                };
                                /**
                                 * Set view-model observables and populate the `symbols` object based on any changes here in the view.
                                 */
                                ColorPickerView.prototype.handleChange = function () {
                                    // Gathering the information needed to create the symbols.
                                    var color = this.viewModel.useColorSwatches.get()
                                        ? esri.Color.fromHex(this.getSelectedColorSwatch().hex)
                                        : esri.Color.fromHex(this.colorInput.value);
                                    this.viewModel.selectedColor.set(color);
                                };
                                return ColorPickerView;
                            }(geocortex.framework.ui.ViewBase));
                            ColorPicker.ColorPickerView = ColorPickerView;
                            /**
                             * Generate a single bright, vibrant random color.
                             */
                            function generateRandomColor() {
                                return generateColorFromHSV(Math.random(), 0.8, 1);
                            }
                            /**
                             * Generate a color wheel starting from a random point.
                             * Each color will be unique, repeats are impossible.
                             */
                            function generateRandomColors(n) {
                                if (n === void 0) { n = 6; }
                                var hues = [];
                                var startingHue = Math.random();
                                for (var i = 0; i < n; i++) {
                                    hues.push(startingHue + ((1 / n) * i));
                                }
                                return hues.map(function (hue) { return generateColorFromHSV(hue, 0.8, 1); });
                            }
                            //// This function was copy-pasted from `geocortex.essentialsHtmlViewer.sdk.samples.modules.viewerviews.Utilities.GenerateHSVColor`.
                            // Generates the hexidecimal color code for a color in HSV (hue, saturation, value) color space.
                            // This is far preferable to using RGB for mapping applications, as random colors generated
                            // in RGB will trend towards the dark and unsaturated, and often look quite similar.
                            // To use, supply a number between 0 and 1 for each parameter below.
                            // To generate a series of random colors with a consistent tone, supply a random number for 'hue' only.
                            function generateColorFromHSV(hue, saturation, value) {
                                // See https://en.wikipedia.org/wiki/HSL_and_HSV#Converting_to_RGB for a detailed discussion of this algorithm.
                                var r, g, b;
                                var chroma = saturation * value; // The chroma is the largest component of the color.
                                var h_prime = hue * 6; // The hue will fall within sectors 0 to 6 in the HSV colorspace.
                                var x = chroma * (1 - Math.abs((h_prime % 2) - 1)); // x represents the second largest component of the color.
                                var min = value - chroma; // A minimum floor is added to each component to match the desired value.
                                switch (Math.floor(h_prime) % 6) {
                                    case 0:
                                        r = chroma + min, g = x + min, b = min;
                                        break;
                                    case 1:
                                        r = x + min, g = chroma + min, b = min;
                                        break;
                                    case 2:
                                        r = min, g = chroma + min, b = x + min;
                                        break;
                                    case 3:
                                        r = min, g = x + min, b = chroma + min;
                                        break;
                                    case 4:
                                        r = x + min, g = min, b = chroma + min;
                                        break;
                                    case 5:
                                        r = chroma + min, g = min, b = x + min;
                                        break;
                                }
                                var r_hex = ("00" + (Math.floor(r * 255)).toString(16)).slice(-2);
                                var g_hex = ("00" + (Math.floor(g * 255)).toString(16)).slice(-2);
                                var b_hex = ("00" + (Math.floor(b * 255)).toString(16)).slice(-2);
                                return "#" + r_hex + b_hex + g_hex;
                            }
                        })(ColorPicker = components.ColorPicker || (components.ColorPicker = {}));
                    })(components = ui.components || (ui.components = {}));
                })(ui = infrastructure.ui || (infrastructure.ui = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ui;
                (function (ui) {
                    var components;
                    (function (components) {
                        var ColorPicker;
                        (function (ColorPicker) {
                            /**
                             * View-model for the ColorPicker widget.
                             */
                            var ColorPickerViewModel = (function (_super) {
                                __extends(ColorPickerViewModel, _super);
                                function ColorPickerViewModel(app, libraryId, swatchName) {
                                    _super.call(this, app, libraryId);
                                    /** Whether or not to use swatches instead of native color input. */
                                    this.useColorSwatches = new Observable(true);
                                    /** Color swatches available to choose from. */
                                    this.colorSwatches = new ObservableCollection();
                                    this.selectedColor = new Observable();
                                    this.defaultColor = new Observable();
                                    this.originalColor = new Observable();
                                    this.swatchSetName = swatchName;
                                }
                                /**
                                 * Initialize the widget based on configuration.
                                 */
                                ColorPickerViewModel.prototype.initialize = function (configuration) {
                                    if (configuration === void 0) { configuration = {}; }
                                    this.configuration = configuration;
                                    // Default for alwaysUseColorSwatches.
                                    configuration.alwaysUseColorSwatches = (configuration.alwaysUseColorSwatches != undefined) ? configuration.alwaysUseColorSwatches
                                        : false;
                                    // Default for numberOfColorSwatches.
                                    configuration.numberOfColorSwatches = (!configuration.numberOfColorSwatches) ? configuration.numberOfColorSwatches : 6;
                                    // Setting the `useColorSwatches` observable. We use the color swatches if either `alwaysUseColorSwatches` is true, or if the color input is not supported.
                                    this.useColorSwatches.set(configuration.alwaysUseColorSwatches || !isColorInputSupported());
                                };
                                return ColorPickerViewModel;
                            }(geocortex.framework.ui.ViewModelBase));
                            ColorPicker.ColorPickerViewModel = ColorPickerViewModel;
                            /**
                             * Detect whether or not the native color input type is supported by the current browser.
                             * Returns true when color input is supported, false otherwise.
                             */
                            function isColorInputSupported() {
                                var input = document.createElement("input");
                                input.setAttribute("type", "color");
                                return input.type !== "text";
                            }
                        })(ColorPicker = components.ColorPicker || (components.ColorPicker = {}));
                    })(components = ui.components || (ui.components = {}));
                })(ui = infrastructure.ui || (infrastructure.ui = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ui;
                (function (ui) {
                    var components;
                    (function (components) {
                        var PagingControls;
                        (function (PagingControls) {
                            // A widget module for adding paging controls to tables.
                            var PagingControlsView = (function (_super) {
                                __extends(PagingControlsView, _super);
                                function PagingControlsView() {
                                    _super.apply(this, arguments);
                                    this.libraryId = "Mapping.Infrastructure";
                                }
                                PagingControlsView.prototype.attach = function (viewModel) {
                                    this.viewModel = viewModel;
                                };
                                PagingControlsView.prototype.handlePageFirst = function (evt, el, ctx) {
                                    if (this.viewModel.collectionViewModel.presentableResults.currPageNumber.get() > 1) {
                                        this.viewModel.collectionViewModel.presentableResults.currPageNumber.set(1);
                                    }
                                };
                                PagingControlsView.prototype.handlePagePrev = function (evt, el, ctx) {
                                    if (this.viewModel.collectionViewModel.presentableResults.currPageNumber.get() > 1) {
                                        var page = this.viewModel.collectionViewModel.presentableResults.currPageNumber.get() - 1;
                                        this.viewModel.collectionViewModel.presentableResults.currPageNumber.set(page);
                                    }
                                };
                                PagingControlsView.prototype.handlePageNext = function (evt, el, ctx) {
                                    if (this.viewModel.collectionViewModel.presentableResults.lastPageNumber.get() > this.viewModel.collectionViewModel.presentableResults.currPageNumber.get()) {
                                        var page = this.viewModel.collectionViewModel.presentableResults.currPageNumber.get() + 1;
                                        this.viewModel.collectionViewModel.presentableResults.currPageNumber.set(page);
                                    }
                                };
                                PagingControlsView.prototype.handlePageLast = function (evt, el, ctx) {
                                    if (this.viewModel.collectionViewModel.presentableResults.currPageNumber.get() < this.viewModel.collectionViewModel.presentableResults.lastPageNumber.get()) {
                                        var page = this.viewModel.collectionViewModel.presentableResults.lastPageNumber.get();
                                        this.viewModel.collectionViewModel.presentableResults.currPageNumber.set(page);
                                    }
                                };
                                return PagingControlsView;
                            }(geocortex.framework.ui.ViewBase));
                            PagingControls.PagingControlsView = PagingControlsView;
                        })(PagingControls = components.PagingControls || (components.PagingControls = {}));
                    })(components = ui.components || (ui.components = {}));
                })(ui = infrastructure.ui || (infrastructure.ui = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ui;
                (function (ui) {
                    var components;
                    (function (components) {
                        var PagingControls;
                        (function (PagingControls) {
                            // A widget module for adding paging controls to tables.
                            var PagingControlsViewModel = (function (_super) {
                                __extends(PagingControlsViewModel, _super);
                                function PagingControlsViewModel(app, collectionViewModel) {
                                    _super.call(this, app, "Mapping.Infrastructure");
                                    this.libraryId = "Mapping.Infrastructure";
                                    this.collectionViewModel = collectionViewModel;
                                    this.presentableResults = this.collectionViewModel.presentableResults;
                                    this.numberOfItems = this.presentableResults.items.length();
                                }
                                return PagingControlsViewModel;
                            }(geocortex.framework.ui.ViewModelBase));
                            PagingControls.PagingControlsViewModel = PagingControlsViewModel;
                        })(PagingControls = components.PagingControls || (components.PagingControls = {}));
                    })(components = ui.components || (ui.components = {}));
                })(ui = infrastructure.ui || (infrastructure.ui = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../../_Definitions/jqueryui.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ui;
                (function (ui_1) {
                    var components;
                    (function (components) {
                        var Slider;
                        (function (Slider) {
                            /**
                             * A  generic slider with the ability to be displayed horizontally or vertically in any target region.
                             */
                            var SliderViewBase = (function (_super) {
                                __extends(SliderViewBase, _super);
                                function SliderViewBase() {
                                    _super.apply(this, arguments);
                                    /**
                                     * A reference to the actual slider element in the DOM.
                                     */
                                    this.sliderElement = null;
                                    /**
                                     * The HTML element reference for the slider min label.
                                     */
                                    this.sliderMinLabelElement = null;
                                    /**
                                     * The HTML element reference for the slider max label.
                                     */
                                    this.sliderMaxLabelElement = null;
                                    /**
                                     * The current raw values for the slider handles.
                                     */
                                    this._sliderCurrentRawValues = [];
                                    this._sliderCurrentHandlePos = [];
                                    this._widgetHostElement = null;
                                    this._minHandleBindingToken = null;
                                    this._maxHandleBindingToken = null;
                                    this._isEnabledBindingToken = null;
                                    this._isAdded = false;
                                }
                                /** @inherited */
                                SliderViewBase.prototype.attach = function (viewModel) {
                                    if (!viewModel) {
                                        return;
                                    }
                                    _super.prototype.attach.call(this, viewModel);
                                    // We should initialize the widget only after its been added. In cases when a widget is being re-rendered in a host element, it may have been added already.
                                    if (this._isAdded) {
                                        this._initializeIfEnabled(this.viewModel.isEnabled.get());
                                    }
                                };
                                SliderViewBase.prototype.added = function (widgetViewHost) {
                                    _super.prototype.added.call(this, widgetViewHost);
                                    this._isAdded = true;
                                    this._widgetHostElement = widgetViewHost;
                                    this._cleanUp(true);
                                    this._isEnabledBindingToken = this.viewModel.isEnabled.bind(this, this._initializeIfEnabled);
                                    this._initializeIfEnabled(this.viewModel.isEnabled.get());
                                };
                                SliderViewBase.prototype.onDestroy = function () {
                                    _super.prototype.onDestroy.call(this);
                                    this._cleanUp(true);
                                };
                                SliderViewBase.prototype.refreshLabelPositions = function () {
                                    this._updateLabelPosition(0);
                                    this._updateLabelPosition(1);
                                };
                                SliderViewBase.prototype._setupViewModelBindings = function () {
                                    var _this = this;
                                    this._minHandleBindingToken = this.viewModel.sliderMinHandleCurrentItem.bind(this, function (item) { return _this._setSliderValueAndUpdateLabels(0, _this.viewModel.getRawSliderValueForItem(item)); });
                                    if (this.viewModel.range) {
                                        this._maxHandleBindingToken = this.viewModel.sliderMaxHandleCurrentItem.bind(this, function (item) { return _this._setSliderValueAndUpdateLabels(1, _this.viewModel.getRawSliderValueForItem(item)); });
                                    }
                                };
                                SliderViewBase.prototype._generateJQuerySlider = function () {
                                    var _this = this;
                                    var vm = this.viewModel;
                                    // Setup the jQuery UI Slider options - http://api.jqueryui.com/slider/
                                    var options = {
                                        animate: vm.animate,
                                        min: vm.isNumeric ? vm.numericSliderMinVal : 0,
                                        max: vm.isNumeric ? vm.numericSliderMaxVal : vm.items.length() - 1,
                                        step: vm.isNumeric ? vm.numericSliderStep : 1,
                                        orientation: "horizontal",
                                        range: vm.range,
                                        slide: function (e, ui) { return _this._handleSliderRawValueSlide(e, ui); },
                                        change: function (e, ui) { return _this._handleSliderRawValueChange(e, ui); }
                                    };
                                    var setDefaultStartHandleVals = function () {
                                        if (options.range) {
                                            options.values = [options.min, options.min + options.step];
                                        }
                                        else {
                                            options.value = options.min;
                                        }
                                    };
                                    var preventSameStartStopVals = function () {
                                        if (options.values[0] === options.values[1]) {
                                            var nextVal = options.values[0] + options.step;
                                            var prevVal = options.values[0] - options.step;
                                            if (nextVal <= options.max) {
                                                options.values[1] = nextVal;
                                            }
                                            else {
                                                options.values[0] = prevVal;
                                            }
                                        }
                                    };
                                    // Setup slider handle starting positions.
                                    if (vm.isNumeric && vm.numericSliderHandleStartValues.length) {
                                        if (options.range && !isNaN(vm.numericSliderHandleStartValues[0]) && !isNaN(vm.numericSliderHandleStartValues[1])) {
                                            options.values = vm.numericSliderHandleStartValues.slice(0, 2);
                                            if (vm.lockMinSliderHandleAtMinVal) {
                                                options.values[0] = options.min;
                                            }
                                            preventSameStartStopVals();
                                        }
                                        else if (!options.range && !isNaN(vm.numericSliderHandleStartValues[0])) {
                                            options.value = vm.numericSliderHandleStartValues[0];
                                        }
                                        else {
                                            setDefaultStartHandleVals();
                                        }
                                    }
                                    else if (!vm.isNumeric && vm.sliderHandleStartLabels.length) {
                                        var startItem = vm.getSliderItemByItemLabel(vm.sliderHandleStartLabels[0]);
                                        var endItem = vm.getSliderItemByItemLabel(vm.sliderHandleStartLabels[1]);
                                        if (options.range && startItem && endItem) {
                                            options.values = [vm.items.indexOf(startItem) - 1, vm.items.indexOf(endItem) - 1];
                                            if (vm.lockMinSliderHandleAtMinVal) {
                                                options.values[0] = options.min;
                                            }
                                            preventSameStartStopVals();
                                        }
                                        else if (!options.range && startItem) {
                                            options.value = vm.items.indexOf(startItem) - 1;
                                        }
                                        else {
                                            setDefaultStartHandleVals();
                                        }
                                    }
                                    else {
                                        setDefaultStartHandleVals();
                                    }
                                    var slider = $(this.sliderElement);
                                    slider.slider(options);
                                    // Update the view model with the current slider items once the host view is activated. Activation is necessary to find the absolute position of the slider labels.
                                    var targetView = this._widgetHostElement ? this._widgetHostElement : this;
                                    if (targetView.isActive) {
                                        this._applyInitViewModelState(options);
                                    }
                                    else {
                                        var viewActivatedToken = this.app.event("ViewActivatedEvent").subscribe(this, function (view) {
                                            if (view !== targetView) {
                                                return;
                                            }
                                            _this.app.event("ViewActivatedEvent").unsubscribe(viewActivatedToken);
                                            viewActivatedToken = null;
                                            _this._applyInitViewModelState(options);
                                        });
                                    }
                                };
                                SliderViewBase.prototype._applyInitViewModelState = function (options) {
                                    if (options.range) {
                                        this.viewModel.setSelectedSliderItem(0, this.viewModel.getSliderItemByRawSliderValue(options.values[0]));
                                        this.viewModel.setSelectedSliderItem(1, this.viewModel.getSliderItemByRawSliderValue(options.values[1]));
                                    }
                                    else {
                                        this.viewModel.setSelectedSliderItem(0, this.viewModel.getSliderItemByRawSliderValue(options.value));
                                    }
                                };
                                SliderViewBase.prototype._handleSliderRawValueChange = function (event, ui) {
                                    var handleIndex = this._getSliderHandleIndex(ui);
                                    var sliderItem = this.viewModel.getSliderItemByRawSliderValue(ui.value);
                                    // Update the current handle value only after its actually changed.
                                    this._sliderCurrentRawValues[handleIndex] = ui.value;
                                    return true;
                                };
                                SliderViewBase.prototype._handleSliderRawValueSlide = function (event, ui) {
                                    if (!ui || !ui.handle || ui.value === undefined) {
                                        return false;
                                    }
                                    var handleIndex = this._getSliderHandleIndex(ui);
                                    // If the slider is in range mode and lockMinSliderHandleAtMinVal is true, don't let the min handle slide.
                                    if (this.viewModel.range && this.viewModel.lockMinSliderHandleAtMinVal && (handleIndex === 0)) {
                                        return false;
                                    }
                                    // Get the current slider item, handle index and associated raw value.
                                    var sliderItem = this.viewModel.getSliderItemByRawSliderValue(ui.value);
                                    var rawValue = ui.value;
                                    // If the current slider item is not active, select the previous or next active slider item depending on the direction in which the user is sliding the handle.
                                    if (sliderItem && !sliderItem.active) {
                                        var currHandleVal = this._sliderCurrentRawValues[handleIndex];
                                        sliderItem = (currHandleVal === undefined || ui.value > currHandleVal) ? this.viewModel.getNextActiveSliderItem(sliderItem) : this.viewModel.getPreviousActiveSliderItem(sliderItem);
                                        rawValue = this.viewModel.getRawSliderValueForItem(sliderItem);
                                    }
                                    // If the slider is in 'range' mode, don't allow both handles to be at the same data point. If users want this, they can switch to instance mode.
                                    // GVH-11101: Also don't allow the max handle to 'cross over' and set a value below that of the min handle (and vice versa)
                                    if (sliderItem && this.viewModel.range) {
                                        var otherHandleItem = handleIndex === 0 ? this.viewModel.sliderMaxHandleCurrentItem.get() : this.viewModel.sliderMinHandleCurrentItem.get();
                                        var crossOverError = handleIndex === 0 ? sliderItem.value > otherHandleItem.value : sliderItem.value < otherHandleItem.value;
                                        if (otherHandleItem && (crossOverError || (sliderItem.value === otherHandleItem.value))) {
                                            sliderItem = handleIndex === 0 ? this.viewModel.getPreviousActiveSliderItem(sliderItem) : this.viewModel.getNextActiveSliderItem(sliderItem);
                                            rawValue = this.viewModel.getRawSliderValueForItem(sliderItem);
                                        }
                                    }
                                    // At this point, if we dont have a valid sliderItem, cancel this event. i.e. don't let the slider slide to this value.
                                    if (!sliderItem) {
                                        return false;
                                    }
                                    // This will automatically update the raw value (if different from the user chosen one) and refresh the labels via data binding.
                                    this.viewModel.setSelectedSliderItem(handleIndex, sliderItem);
                                    // Cancel the event if the computed raw value is different from the original user chosen raw value
                                    return (rawValue !== ui.value) ? false : true;
                                };
                                SliderViewBase.prototype._getSliderHandleIndex = function (ui) {
                                    var handleIndex = 0;
                                    if (ui.values && ui.values[1] !== undefined) {
                                        handleIndex = (ui.values[0] === ui.values[1])
                                            ? ui.handle.nextElementSibling === null || ui.handle.nextElementSibling === undefined ? 1 : 0
                                            : ui.values.indexOf(ui.value);
                                    }
                                    return handleIndex;
                                };
                                /**
                                 * Sets the raw slider value if different from the current value and updates the label positions. This function is intended to be invoked automatically
                                 * via data binding whenever the selected item is updated in the view model.
                                 * @param handleIndex The index of the handle to update.
                                 * @param rawValue The raw value to set.
                                 */
                                SliderViewBase.prototype._setSliderValueAndUpdateLabels = function (handleIndex, rawValue) {
                                    if (rawValue === null) {
                                        return;
                                    }
                                    if ((handleIndex !== 0 && handleIndex !== 1) || isNaN(parseInt(rawValue, 10))) {
                                        this.app.trace.error("SliderViewBase: Could not set slider values and update UI. Required arguments invalid.");
                                        return;
                                    }
                                    this._setSliderRawValue(handleIndex, rawValue);
                                    this._updateLabelPosition(handleIndex);
                                };
                                /**
                                 * Updates the slider raw value for the given handle, if different from what the current value is.
                                 * @param handleIndex The index of the handle to update.
                                 * @param rawValue The raw value to set.
                                 */
                                SliderViewBase.prototype._setSliderRawValue = function (handleIndex, rawValue) {
                                    if (this.viewModel.range) {
                                        var currVals = $(this.sliderElement).slider("values");
                                        if (currVals[handleIndex] !== rawValue) {
                                            $(this.sliderElement).slider("values", handleIndex, rawValue);
                                        }
                                    }
                                    else {
                                        var currVal = $(this.sliderElement).slider("value");
                                        if (currVal !== rawValue) {
                                            $(this.sliderElement).slider("value", rawValue);
                                        }
                                    }
                                };
                                SliderViewBase.prototype._updateLabelPosition = function (handleIndex) {
                                    var _this = this;
                                    // For a smoother label positioning effect, we'll do this twice. The first time will update instantaneously for when the user is manually dragging
                                    // the slider handle. This prevents the lag that would otherwise occur if we simply wrapped this in a timeout as we later do for the reasons stated below.
                                    this._updateLabelPositionImpl(handleIndex);
                                    // We yield here in the second iteration as sometimes, when setting raw values programmatically and especially when animation is active, it takes a 
                                    // while for the DOM to update. This is needed for the label postions to update accurately and consistently.
                                    setTimeout(function () { return _this._updateLabelPositionImpl(handleIndex); }, this.viewModel.animate ? 400 : 100);
                                };
                                /**
                                 * Updates the label for the given handle. This will be invoked automatically when the currently selected item is updated in the view model.
                                 * @param handleIndex The index of the handle whose label we wish to update.
                                 */
                                SliderViewBase.prototype._updateLabelPositionImpl = function (handleIndex) {
                                    if (handleIndex === null || handleIndex === undefined || (handleIndex !== 0 && handleIndex !== 1)) {
                                        return;
                                    }
                                    if (!this.viewModel.range && handleIndex === 1) {
                                        return;
                                    }
                                    var handles = $(".ui-slider-handle", this.sliderElement).toArray();
                                    if (handles.length === 0) {
                                        return;
                                    }
                                    var labelWidthPadding = 5;
                                    // Align the center of the selected item label with the slider handle...
                                    var labelWidth = (handleIndex === 0 ? $(this.sliderMinLabelElement).width() + labelWidthPadding : $(this.sliderMaxLabelElement).width()) + labelWidthPadding;
                                    var sliderWidth = $(this.sliderElement).width();
                                    var handleWidth = $(handles[handleIndex]).width();
                                    // The first () group below positions the label start point precicely at the mid point of the slider handle. The second () group centers the label.
                                    var position = ($(handles[handleIndex]).position().left + $(this.sliderElement).position().left + (handleWidth * 0.5)) - (labelWidth * 0.5);
                                    // ... but keep it confined within the bounds of the slider. 
                                    position = Math.max($(this.sliderElement).position().left - (handleWidth * 0.5), position);
                                    position = Math.min((sliderWidth + $(this.sliderElement).position().left + (handleWidth * 0.5)) - labelWidth, position);
                                    // ... 1) also dont allow the labels to overlap if the handles are too close together 2) Dont allow handle 0 to take on a position that will force handle 1 (if in range mode) out of 
                                    // the extent of the slider. This is important because handle 0 will always be set before handle 1.
                                    var otherHandlePos = this._sliderCurrentHandlePos[(handleIndex + 1) % 2];
                                    var otherLabelWidth = (handleIndex === 0 ? $(this.sliderMaxLabelElement).width() + labelWidthPadding : $(this.sliderMinLabelElement).width()) + labelWidthPadding;
                                    // The other label width can never be very different from the current label width. Definitely not less than half of it. If that's the case, use the current label width. Also,
                                    // the other handle position can be null if its not yet been created, or its been reset because of a setting change. In such cases, choose a logical value if this is range mode.
                                    otherLabelWidth = otherLabelWidth < (labelWidth * 0.5) ? labelWidth : otherLabelWidth;
                                    otherHandlePos = isNaN(otherHandlePos) && this.viewModel.range ? (sliderWidth + $(this.sliderElement).position().left + (handleWidth * 0.5)) - otherLabelWidth : otherHandlePos;
                                    if (!isNaN(otherHandlePos)) {
                                        if (handleIndex === 0) {
                                            // First restrain the positon of handle 0 so it doesnt overlap handle 1 IF that does not make handle 0 underflow the slider width. Second ensure that handle 0 allows
                                            // enough room from the end for handle 1 if handle 1 is right at the very end. Else handle 1 will overflow the width of the slider at the next pass.
                                            position = otherHandlePos >= labelWidth ? Math.min(otherHandlePos - labelWidth, position) : position;
                                            position = Math.min((sliderWidth + $(this.sliderElement).position().left + (handleWidth * 0.5)) - (otherLabelWidth + labelWidth - labelWidthPadding), position);
                                        }
                                        else if (handleIndex === 1) {
                                            position = Math.max(otherHandlePos + otherLabelWidth + (handleWidth * 0.5), position);
                                        }
                                    }
                                    this._sliderCurrentHandlePos[handleIndex] = position;
                                    if (handleIndex === 0) {
                                        this.sliderMinLabelElement.style.left = position + "px";
                                    }
                                    else {
                                        this.sliderMaxLabelElement.style.left = position + "px";
                                    }
                                };
                                SliderViewBase.prototype._processInitRoutine = function () {
                                    this._cleanUp();
                                    this._setupViewModelBindings();
                                    this._generateJQuerySlider();
                                };
                                SliderViewBase.prototype._initializeIfEnabled = function (val) {
                                    if (val) {
                                        this._processInitRoutine();
                                    }
                                };
                                SliderViewBase.prototype._cleanUp = function (clearIsEnabledBinding) {
                                    if (clearIsEnabledBinding === void 0) { clearIsEnabledBinding = false; }
                                    if (this.sliderElement && $(this.sliderElement).hasClass("ui-slider")) {
                                        $(this.sliderElement).slider("destroy");
                                    }
                                    if (this.viewModel) {
                                        if (this._isEnabledBindingToken && clearIsEnabledBinding) {
                                            this.viewModel.isEnabled.unbind(this._isEnabledBindingToken);
                                            this._isEnabledBindingToken = null;
                                        }
                                        if (this._minHandleBindingToken) {
                                            this.viewModel.sliderMinHandleCurrentItem.unbind(this._minHandleBindingToken);
                                        }
                                        if (this._maxHandleBindingToken) {
                                            this.viewModel.sliderMaxHandleCurrentItem.unbind(this._maxHandleBindingToken);
                                        }
                                    }
                                    this._sliderCurrentHandlePos = [];
                                    this._sliderCurrentRawValues = [];
                                    this._minHandleBindingToken = null;
                                    this._maxHandleBindingToken = null;
                                };
                                return SliderViewBase;
                            }(geocortex.framework.ui.ViewBase));
                            Slider.SliderViewBase = SliderViewBase;
                        })(Slider = components.Slider || (components.Slider = {}));
                    })(components = ui_1.components || (ui_1.components = {}));
                })(ui = infrastructure.ui || (infrastructure.ui = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ui;
                (function (ui) {
                    var components;
                    (function (components) {
                        var Slider;
                        (function (Slider) {
                            /**
                             * The view model for the Slider widget.
                             */
                            var SliderViewModelBase = (function (_super) {
                                __extends(SliderViewModelBase, _super);
                                /**@inherited */
                                function SliderViewModelBase(app, libraryId, sliderConfig) {
                                    _super.call(this, app, libraryId);
                                    /**
                                     * The items that participate in this slider. This collection is automatically set when an underlying collection is attached to.
                                     * It need not be set if the slider is configured to display an integer range. This includes a date range measured as milliseconds from epoch.
                                     */
                                    this.items = new ObservableCollection([]);
                                    /**
                                    * The label for the slider's minimum value.
                                    */
                                    this.sliderMinLabel = new Observable("");
                                    /**
                                    * The label for the slider's maximum value.
                                    */
                                    this.sliderMaxLabel = new Observable("");
                                    /**
                                     * The currently selected label for the first slider handle.
                                     */
                                    this.sliderMinHandleLabel = new Observable("");
                                    /**
                                    * The currently selected label for the second slider handle (if configured as a range slider).
                                    */
                                    this.sliderMaxHandleLabel = new Observable("");
                                    /**
                                     * The item currently associated with the min slider handle.
                                     */
                                    this.sliderMinHandleCurrentItem = new Observable(null);
                                    /**
                                     * The item currently associated with the max slider handle if range mode is active.
                                     */
                                    this.sliderMaxHandleCurrentItem = new Observable(null);
                                    /**
                                     * Indicates whether this slider should be a range slider (two handles) or a solo slider. Defaults to false.
                                     */
                                    this.range = false;
                                    /**
                                     * Indicates whether snapping to data items or labels is disabled altogether when the slider is in numeric mode - i.e. all data item values are numeric. Defauls to true.
                                     */
                                    this.disableSnappingForNumericValues = true;
                                    /**
                                     * If true, will lock the min slider handle at the min value, provided the slider is in range mode. Ineffective in non-range mode.
                                     */
                                    this.lockMinSliderHandleAtMinVal = false;
                                    /**
                                     * Indicates whether the generated slider is animated or not. Defaults to false.
                                     */
                                    this.animate = false;
                                    /**
                                     * Indicates whether this slider contains numeric data only or other types of objects.
                                     */
                                    this.isNumeric = null;
                                    /**
                                     * Defines the steps the time slider will take if the data is numeric. This may be overridden if the next available item is not active.
                                     */
                                    this.numericSliderStep = null;
                                    /**
                                     * The min value for the slider if in numeric mode.
                                     */
                                    this.numericSliderMinVal = null;
                                    /**
                                     * The max value for the slider if in numeric mode.
                                     */
                                    this.numericSliderMaxVal = null;
                                    /**
                                    * The label generator function which, if defined, will be applied to compute the labels corresponding to each item in the underlying collection.
                                    */
                                    this.labelGenerator = null;
                                    /**
                                    * The predicate which, will be applied to compute whether an item is active (i.e. selectable) each time it is selected in the slider. Returns true by default.
                                    */
                                    this.itemActivePredicate = null;
                                    /**
                                     * The start labels for the slider handles when the slider is in non-numeric mode.
                                     */
                                    this.sliderHandleStartLabels = [];
                                    /**
                                     * The numeric start values for the slider handles when the slider is in numeric mode.
                                     */
                                    this.numericSliderHandleStartValues = [];
                                    /**
                                     * The ticks for the slider.
                                     */
                                    this.sliderTicks = new ObservableCollection();
                                    /**
                                     * Enable or disable the slider.
                                     */
                                    this.isEnabled = new Observable(false);
                                    /**
                                     * The underlying collection of observable items, if any, that this slider is bound to.
                                     * WARNING: Do not modify this collection in any manner whatsoever since it is a reference to an external observableCollection we're binding to.
                                     */
                                    this._underlyingCollection = null;
                                    /**
                                     * The token representing the binding to the underlying collection.
                                     */
                                    this._underlyingCollectionBindingToken = null;
                                    /**
                                     * The configuration options for this slider.
                                     */
                                    this._config = null;
                                    /**
                                     * The default label generator for a number series.
                                     */
                                    this._defaultNumericLabelGenerator = function (item, index) { return item + ""; };
                                    /**
                                     * The default predicate which determines whether a slider item is active (ie selectable) in the slider or not. This function will be executed each time an item is selected.
                                     */
                                    this._defaultItemActivePredicate = function (item, index) { return true; };
                                    /**
                                     * In numeric mode, the items collection is kept empty. We create SliderItems based on the actual numeric value the user selects. This is an internal cache of previously created SliderItem
                                     * objects so we can reuse older objects once they've been created.
                                     */
                                    this._numericSliderItemCache = {};
                                    this._maxSliderTicks = 50;
                                    this._defaultSliderDivisions = 5;
                                    this.itemActivePredicate = this._defaultItemActivePredicate;
                                    if (sliderConfig) {
                                        this.initialize(sliderConfig);
                                    }
                                }
                                /**
                                 * Initializes the slider configuration. Can either be initialized using the "initialize" method or by passing in the config object directly during instantiation.
                                 * Explicitly initializing will overwrite any previous configuration settings that may have been applied during slider instantiation.
                                 */
                                SliderViewModelBase.prototype.initialize = function (config) {
                                    this._applyConfig(config);
                                };
                                /**
                                 * Triggered on every mouse-move during slide. The value provided represents the value that the handle will have as a result of the current movement.
                                 * @param value The SliderItem corresponding to the current slider value.
                                 * @param handleIndex The index of the handle which has currently been slid. This will possible values of 0 or 1.
                                 */
                                SliderViewModelBase.prototype.sliderHandleSlide = function (value, handleIndex) {
                                    // Override or dojo.aspect this function to achive intended functionality.
                                };
                                SliderViewModelBase.prototype.setNextSliderItem = function (handleIndex) {
                                    return this._setNextOrPreviousSliderItem(handleIndex, "next");
                                };
                                SliderViewModelBase.prototype.setPreviousSliderItem = function (handleIndex) {
                                    return this._setNextOrPreviousSliderItem(handleIndex, "previous");
                                };
                                /**
                                 * Set the selected slider item for the specified handle in the view model. This function is intended to be invoked by the view code behind and does not update the slider UI widget itself.
                                 * @param handleIndex The index of the slider handle for which to set the selected slider item.
                                 * @param item The SliderItem to update the selected handle value to.
                                 */
                                SliderViewModelBase.prototype.setSelectedSliderItem = function (handleIndex, item) {
                                    if ((handleIndex !== 0 && handleIndex !== 1) || !item) {
                                        throw new Error("SliderViewModelBase: Could not set selected slider item.");
                                    }
                                    var currVal = null;
                                    if (handleIndex === 0) {
                                        currVal = this.sliderMinHandleCurrentItem.get();
                                        if (!currVal || currVal.value !== item.value) {
                                            this.sliderMinHandleLabel.set(item.label);
                                            this.sliderMinHandleCurrentItem.set(item);
                                        }
                                    }
                                    else {
                                        currVal = this.sliderMaxHandleCurrentItem.get();
                                        if (!currVal || currVal.value !== item.value) {
                                            this.sliderMaxHandleLabel.set(item.label);
                                            this.sliderMaxHandleCurrentItem.set(item);
                                        }
                                    }
                                    this.sliderHandleSlide(item, handleIndex);
                                };
                                /**
                                 * Attaches to an ObservableCollection and automatically generates relevant SliderItems.
                                 * @param collection The collection to attach to.
                                 * @param labelGenerator Optional function which will be called for each item in the collection. Generates a string label for the item. For example (item: Feature, index: number) => `${index + 1}: ${item.label.get()}`;
                                 * @param itemActivePredicate Optional. A function which determines whether the current item is active (ie is selectable in the slider) or not. This function will be executed each time an item is selected. If not specified, returns true.
                                 * @param startItemLabels Optional. An array of strings containing one or two values, depicting the start labels of the handle (or handles if in range mode) of the slider.  These values will be applied on a best effort basis:
                                 *                          1) At slider creation time:: If the startup label values are valid, they will be applied.
                                 *                          2) When an attached collection is updated:: If the startup label value has not yet been applied and the slider handle has not been moved manually by the user at the point in time
                                 *                          when the collection is updated, the startup label values will be applied provided they are valid. Once the user moves either one of the slider handles manually, the startup label values will
                                 *                          no longer be respected. If no startup label values are provided, the handles will start at the first and second data points respectively by default.
                                 */
                                SliderViewModelBase.prototype.attachToCollection = function (collection, labelGenerator, itemActivePredicate, startItemLabels) {
                                    var _this = this;
                                    this.cleanUp();
                                    this.isNumeric = false;
                                    if (!collection || !(collection instanceof ObservableCollection)) {
                                        throw new Error("SliderViewModelBase: Could not attach to collection.");
                                    }
                                    if (labelGenerator && dojo.isFunction(labelGenerator)) {
                                        this.labelGenerator = labelGenerator;
                                    }
                                    if (startItemLabels && startItemLabels.length) {
                                        this.sliderHandleStartLabels = startItemLabels.slice(0);
                                    }
                                    this.itemActivePredicate = (itemActivePredicate && dojo.isFunction(itemActivePredicate)) ? itemActivePredicate : this._defaultItemActivePredicate;
                                    this._underlyingCollection = collection;
                                    this.items.set(this._underlyingCollection.get().map(function (item, index) { return _this._createSliderItem(item, index); }));
                                    this._underlyingCollectionBindingToken = this._underlyingCollection.bind(this, this._handleUnderlyingCollectionChanges);
                                    this._initializeUIObservables();
                                };
                                /**
                                 * Puts the slider into numeric mode. This will clear out all underlying attached collections if attached previously and convert the slider into a vanilla
                                 * jQuery numeric slider, albeit with configurable labels. The items collection will remain empty and so will the underlying collection.
                                 * @param minVal The minimum value of the numveric range this slider will represent.
                                 * @param maxVal The maximum value fo the numeric range this slider will represent.
                                 * @param steps Optional parameter defining the number of steps between two data items. If not provided, a default value of 1 will be used for values over 1. 0.1 will be used for values below 1.
                                 * @param labelGenerator Optional parameter defining the rules by which labels should be generated. If not provided, the label will be a string representation of the number itself.
                                 * @param itemActivePredicate Optional. A function which determines whether the current item is active (ie is selectable in the slider) or not. This function will be executed each time an item is selected. If not specified, returns true.
                                 * @param startItemValues Optional. An array of numbers containing one or two values, depicting the start values of the handle (or handles if in range mode) of the slider. These values will be applied on a best effort basis:
                                 *                          1) At slider creation time:: If the startup values are valid, they will be applied.
                                 *                          2) When an attached collection is updated:: If the startup value has not yet been applied and the slider handle has not been moved manually by the user at the point in time
                                 *                          when the collection is updated, the startup values will be applied provided they are valid. Once the user moves either one of the slider handles manually, the startup values will
                                 *                          no longer be respected. If no startup values are provided, the handles will start at the first and second data points respectively by default.
                                 */
                                SliderViewModelBase.prototype.setupNumericSlider = function (minVal, maxVal, steps, labelGenerator, itemActivePredicate, startItemValues) {
                                    this.cleanUp();
                                    this.isNumeric = true;
                                    minVal = parseFloat(minVal);
                                    maxVal = parseFloat(maxVal);
                                    steps = parseFloat(steps);
                                    if (isNaN(minVal) || isNaN(maxVal)) {
                                        throw new Error("SliderViewModelBase: Could not set numeric slider range. Minimum and/or maximum values invalid.");
                                    }
                                    if (startItemValues && startItemValues.length) {
                                        this.numericSliderHandleStartValues = startItemValues.slice(0);
                                    }
                                    this.numericSliderMinVal = minVal;
                                    this.numericSliderMaxVal = maxVal;
                                    this.labelGenerator = (labelGenerator && dojo.isFunction(labelGenerator)) ? labelGenerator : this._defaultNumericLabelGenerator;
                                    this.itemActivePredicate = (itemActivePredicate && dojo.isFunction(itemActivePredicate)) ? itemActivePredicate : this._defaultItemActivePredicate;
                                    this.numericSliderStep = (!isNaN(steps) && steps < (maxVal - minVal)) ? steps : null;
                                    if (this.numericSliderStep === null) {
                                        var range = maxVal - minVal;
                                        if (range) {
                                            this.numericSliderStep = range <= 1 ? (range / this._defaultSliderDivisions) : Math.round(range / this._defaultSliderDivisions);
                                        }
                                    }
                                    this._initializeUIObservables();
                                };
                                /**
                                 * Retrieve the updated slider item corresponding to the raw slider value. Returns the slider item if found, null otherwise.
                                 * @param sliderValue The raw numeric value returned by the slider. This will represent the index of the item in the items collection if the slider is non numeric and the actual numeric value if it's numeric.
                                 */
                                SliderViewModelBase.prototype.getSliderItemByRawSliderValue = function (rawSliderValue) {
                                    if (rawSliderValue === undefined || rawSliderValue === null) {
                                        return null;
                                    }
                                    var item = null;
                                    var itemIndex = this.isNumeric ? rawSliderValue - this.numericSliderMinVal : rawSliderValue;
                                    if (this.isNumeric) {
                                        if (rawSliderValue >= this.numericSliderMinVal && rawSliderValue <= this.numericSliderMaxVal) {
                                            item = this._getUpdatedNumericItemAndUpdateCache(rawSliderValue, itemIndex);
                                        }
                                    }
                                    else {
                                        if (itemIndex > -1 && itemIndex < this.items.length()) {
                                            item = this.items.getAt(itemIndex);
                                            // Update the label and active variables in case they've changed since the last time this item was retrieved. In case of numeric 
                                            // values, _getUpdatedNumericItemAndUpdateCache does it for us.
                                            this._updateSliderItem(item, itemIndex);
                                        }
                                    }
                                    return item;
                                };
                                /**
                                 * Retrieve the updated slider item corresponding to the given slider label. Returns the slider item if found, null otherwise. If more than one item exists with the same label, we'll return the first match.
                                 * @param label
                                 */
                                SliderViewModelBase.prototype.getSliderItemByItemLabel = function (label) {
                                    if (!label) {
                                        return null;
                                    }
                                    var item = null;
                                    if (this.isNumeric) {
                                        if (this.labelGenerator) {
                                            for (var x = this.numericSliderMinVal, index = 0; x <= this.numericSliderMaxVal; x += this.numericSliderStep, index++) {
                                                var currLabel = this.labelGenerator(x, index);
                                                if (currLabel === label) {
                                                    item = this._getUpdatedNumericItemAndUpdateCache(x, index);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    else {
                                        for (var y = 0, len = this.items.length(); y < len; y++) {
                                            var currItem = this.items.getAt(y);
                                            this._updateSliderItem(currItem, y);
                                            if (currItem.label === label) {
                                                item = currItem;
                                                break;
                                            }
                                        }
                                    }
                                    return item;
                                };
                                /**
                                 * Retrieve the updated slider item corresponding to the given item value. Returns the slider item if found, null otherwise.
                                 * @param value
                                 */
                                SliderViewModelBase.prototype.getSliderItemByItemValue = function (value) {
                                    var _this = this;
                                    if (value === undefined || value === null || (this.isNumeric && typeof value !== "number")) {
                                        return null;
                                    }
                                    var item = null;
                                    if (this.isNumeric) {
                                        var itemIndex = value - this.numericSliderMinVal;
                                        item = this._getUpdatedNumericItemAndUpdateCache(value, itemIndex);
                                    }
                                    else {
                                        item = this.items.get().filter(function (item, index) {
                                            if (item.value !== value) {
                                                return false;
                                            }
                                            _this._updateSliderItem(item, index);
                                            return true;
                                        })[0];
                                        item = item || null;
                                    }
                                    return item;
                                };
                                /**
                                * Get the next slider item.
                                * @param sliderItem The current slider item with respect to which we want to find the next item.
                                */
                                SliderViewModelBase.prototype.getNextSliderItem = function (sliderItem) {
                                    return this._getAdjacentSliderItem(sliderItem, "next");
                                };
                                /**
                                 * Get the next active slider item.
                                 * @param sliderItem The current slider item with respect to which we want to find the next active item.
                                 */
                                SliderViewModelBase.prototype.getNextActiveSliderItem = function (sliderItem) {
                                    return this._getAdjacentSliderItem(sliderItem, "next", "active");
                                };
                                /**
                                 * Get the next inactive slider item.
                                 * @param sliderItem The current slider item with respect to which we want to find the next inactive item.
                                 */
                                SliderViewModelBase.prototype.getNextInactiveSliderItem = function (sliderItem) {
                                    return this._getAdjacentSliderItem(sliderItem, "next", "inactive");
                                };
                                /**
                               * Get the previous slider item.
                               * @param sliderItem The current slider item with respect to which we want to find the previous item.
                               */
                                SliderViewModelBase.prototype.getPreviousSliderItem = function (sliderItem) {
                                    return this._getAdjacentSliderItem(sliderItem, "prev");
                                };
                                /**
                                 * Get the previous active slider item.
                                 * @param sliderItem The current slider item with respect to which we want to find the previous active item.
                                 */
                                SliderViewModelBase.prototype.getPreviousActiveSliderItem = function (sliderItem) {
                                    return this._getAdjacentSliderItem(sliderItem, "prev", "active");
                                };
                                /**
                                 * Get the previous inactive slider item.
                                 * @param sliderItem The current slider item with respect to which we want to find the previous inactive item.
                                 */
                                SliderViewModelBase.prototype.getPreviousInactiveSliderItem = function (sliderItem) {
                                    return this._getAdjacentSliderItem(sliderItem, "prev", "inactive");
                                };
                                /**
                                 * Get the raw slider value for a give slider item. Returns the raw slider value or null if the item does not exist.
                                 * @param sliderItem
                                 */
                                SliderViewModelBase.prototype.getRawSliderValueForItem = function (sliderItem) {
                                    var rawValue = null;
                                    if (sliderItem) {
                                        if (this.isNumeric) {
                                            var val = sliderItem.value;
                                            if (val >= this.numericSliderMinVal && val <= this.numericSliderMaxVal) {
                                                rawValue = val;
                                            }
                                        }
                                        else {
                                            var itemIndex = this.items.get().map(function (item) { return item.value; }).indexOf(sliderItem.value);
                                            if (itemIndex > -1 && itemIndex < this.items.length()) {
                                                rawValue = itemIndex;
                                            }
                                        }
                                    }
                                    return rawValue;
                                };
                                SliderViewModelBase.prototype.cleanUp = function () {
                                    this.isEnabled.set(false);
                                    this.labelGenerator = null;
                                    this.items.clear();
                                    this.isNumeric = null;
                                    this.sliderMaxHandleCurrentItem.set(null);
                                    this.sliderMinHandleCurrentItem.set(null);
                                    this.sliderMinHandleLabel.set("");
                                    this.sliderMaxHandleLabel.set("");
                                    this.sliderMaxLabel.set("");
                                    this.sliderMinLabel.set("");
                                    this.numericSliderStep = null;
                                    this.numericSliderMinVal = null;
                                    this.numericSliderMaxVal = null;
                                    this._numericSliderItemCache = {};
                                    this.numericSliderHandleStartValues = [];
                                    this.sliderHandleStartLabels = [];
                                    this.itemActivePredicate = this._defaultItemActivePredicate;
                                    this.sliderTicks.clear();
                                    if (this._underlyingCollection) {
                                        if (this._underlyingCollectionBindingToken) {
                                            this._underlyingCollection.unbind(this._underlyingCollectionBindingToken);
                                            this._underlyingCollectionBindingToken = null;
                                        }
                                        // Remove the reference to the external observableCollection we had bound to. DO NOT CLEAR IT.
                                        this._underlyingCollection = null;
                                    }
                                };
                                // Internal implementation to set either the "next" or the "previous" slider item. Returns true if successfully set. False otherwise.
                                SliderViewModelBase.prototype._setNextOrPreviousSliderItem = function (handleIndex, qualifier) {
                                    if (handleIndex !== 0 && handleIndex !== 1) {
                                        this.app.trace.error("SliderViewModelBase: Could not set " + qualifier + " slider item. Invalid handle index.Handle index must be 0 or 1.");
                                        return false;
                                    }
                                    var currItem = handleIndex === 0 ? this.sliderMinHandleCurrentItem.get() : this.sliderMaxHandleCurrentItem.get();
                                    var otherHandleItem = handleIndex === 0 ? this.sliderMaxHandleCurrentItem.get() : this.sliderMinHandleCurrentItem.get();
                                    if (!currItem) {
                                        this.app.trace.error("SliderViewModelBase: Could not set " + qualifier + " slider item. Please set current item first.");
                                        return false;
                                    }
                                    var targetItem = (qualifier === "next") ? this.getNextActiveSliderItem(currItem) : this.getPreviousActiveSliderItem(currItem);
                                    if (targetItem && (!otherHandleItem || (otherHandleItem && otherHandleItem.value !== targetItem.value))) {
                                        this.setSelectedSliderItem(handleIndex, targetItem);
                                        return true;
                                    }
                                    return false;
                                };
                                // Setup slider UI observables
                                SliderViewModelBase.prototype._initializeUIObservables = function () {
                                    this._setupSliderTicks();
                                    this._setupSliderMinMaxLabels();
                                    this.isEnabled.set(true);
                                };
                                // Setup ticks along the slider.
                                SliderViewModelBase.prototype._setupSliderTicks = function () {
                                    this.sliderTicks.clear();
                                    var numItems = this.isNumeric ? (this.numericSliderMaxVal - this.numericSliderMinVal) / this.numericSliderStep : this.items.length();
                                    numItems = numItems > this._maxSliderTicks ? this._maxSliderTicks : numItems;
                                    var tickStep = Math.round(100 / numItems);
                                    for (var position = 0; position < 100; position += tickStep) {
                                        this.sliderTicks.addItem({ position: position + "%" });
                                    }
                                };
                                // Set up the min and max values
                                SliderViewModelBase.prototype._setupSliderMinMaxLabels = function () {
                                    var minSliderItem = this.isNumeric ? this.getSliderItemByItemValue(this.numericSliderMinVal) : this.items.getAt(0);
                                    var maxSliderItem = this.isNumeric ? this.getSliderItemByItemValue(this.numericSliderMaxVal) : this.items.getAt(this.items.length() - 1);
                                    this.sliderMinLabel.set(minSliderItem ? minSliderItem.label : "");
                                    this.sliderMaxLabel.set(maxSliderItem ? maxSliderItem.label : "");
                                };
                                /**
                                 * Internal implementation to get the next or previous active slider item. Returns the item if it exists, null otherwise.
                                 * @param sliderItem The slider item for which we want to retrieve the next or previous active slider item.
                                 * @param position May have two distinct values - "next" for the next active slider item or "prev" for the previous active slider item. Defaults to "next"
                                 * @param status May have three distinct values - "active" for active slider item, "inactive" for inactive slider item or "any" for a slider item with any status. Defaults to "any".
                                 */
                                SliderViewModelBase.prototype._getAdjacentSliderItem = function (sliderItem, position, status) {
                                    if (position === void 0) { position = "next"; }
                                    if (status === void 0) { status = "any"; }
                                    var rawSliderValue = this.getRawSliderValueForItem(sliderItem);
                                    if (rawSliderValue === null) {
                                        return null;
                                    }
                                    var item = null;
                                    var currItem = null;
                                    do {
                                        if (this.isNumeric) {
                                            rawSliderValue = position === "prev" ? rawSliderValue - this.numericSliderStep : rawSliderValue + this.numericSliderStep;
                                        }
                                        else {
                                            rawSliderValue = position === "prev" ? rawSliderValue - 1 : rawSliderValue + 1;
                                        }
                                        currItem = this.getSliderItemByRawSliderValue(rawSliderValue);
                                        if (currItem) {
                                            switch (status) {
                                                case "active":
                                                    item = currItem.active ? currItem : null;
                                                    break;
                                                case "inactive":
                                                    item = !currItem.active ? currItem : null;
                                                    break;
                                                default:
                                                    item = currItem;
                                            }
                                        }
                                    } while (currItem && !item);
                                    return item;
                                };
                                /**
                                 * Apply configuration settings or defaults if no settings are available.
                                 */
                                SliderViewModelBase.prototype._applyConfig = function (config) {
                                    this._config = config || {};
                                    this.range = this._config.range === undefined ? false : !!this._config.range;
                                    this.animate = this._config.animate === undefined ? false : !!this._config.animate;
                                    this.disableSnappingForNumericValues = this._config.disableSnappingForNumericValues === undefined ? true : !!this._config.disableSnappingForNumericValues;
                                    this.lockMinSliderHandleAtMinVal = this._config.lockMinSliderHandleAtMinVal === undefined ? false : !!this._config.lockMinSliderHandleAtMinVal;
                                };
                                /**
                                 * Update the items collection as the underlying collection changes.
                                 */
                                SliderViewModelBase.prototype._handleUnderlyingCollectionChanges = function (args) {
                                    var _this = this;
                                    var targetItems;
                                    switch (args.type) {
                                        case "clear":
                                            this.items.clear();
                                            break;
                                        case "insert":
                                            targetItems = args.sender.getRange(args.rangeStart, args.rangeEnd);
                                            this.items.insertItems(args.rangeStart, targetItems.map(function (item, index) { return _this._createSliderItem(item, args.rangeStart + index); }));
                                            break;
                                        case "append":
                                            targetItems = args.sender.getRange(args.rangeStart, args.rangeEnd);
                                            this.items.addItems(targetItems.map(function (item, index) { return _this._createSliderItem(item, args.rangeStart + index); }));
                                            break;
                                        case "remove":
                                            this.items.removeRange(args.rangeStart, args.rangeEnd);
                                            break;
                                    }
                                    this._initializeUIObservables();
                                };
                                /**
                                 * Create a SliderItem for the given underlying item.
                                 */
                                SliderViewModelBase.prototype._createSliderItem = function (item, index) {
                                    return {
                                        "value": item,
                                        "label": this._getItemLabel(item, index),
                                        "active": this.itemActivePredicate(item, index)
                                    };
                                };
                                /**
                                 * Get the label for the current item
                                 */
                                SliderViewModelBase.prototype._getItemLabel = function (item, index) {
                                    var label = "";
                                    if (this.labelGenerator) {
                                        label = this.labelGenerator(item, index);
                                        label = (label === null || label === undefined) ? "" : label + "";
                                    }
                                    return label;
                                };
                                /*
                                 * Update the label and active variables of a slider item based on the labelGenerator and itemActivePredicates.
                                 */
                                SliderViewModelBase.prototype._updateSliderItem = function (item, index) {
                                    item.label = this._getItemLabel(item.value, index);
                                    item.active = this.itemActivePredicate(item.value, index);
                                    return item;
                                };
                                /**
                                 * Retrieve a numeric slider item by value and update the numeric item cache so subsequent retrievals return the same object.
                                 */
                                SliderViewModelBase.prototype._getUpdatedNumericItemAndUpdateCache = function (value, index) {
                                    if (value === null || value === undefined || index === null || index === undefined) {
                                        return null;
                                    }
                                    var item = this._numericSliderItemCache[value + ""];
                                    if (item) {
                                        this._updateSliderItem(item, index);
                                    }
                                    else {
                                        item = this._createSliderItem(value, index);
                                    }
                                    this._numericSliderItemCache[value + ""] = item;
                                    return item;
                                };
                                return SliderViewModelBase;
                            }(geocortex.framework.ui.ViewModelBase));
                            Slider.SliderViewModelBase = SliderViewModelBase;
                        })(Slider = components.Slider || (components.Slider = {}));
                    })(components = ui.components || (ui.components = {}));
                })(ui = infrastructure.ui || (infrastructure.ui = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ui;
                (function (ui) {
                    var components;
                    (function (components) {
                        var Table;
                        (function (Table) {
                            (function (SortState) {
                                SortState[SortState["UNSORTED"] = 0] = "UNSORTED";
                                SortState[SortState["ASCENDING"] = 1] = "ASCENDING";
                                SortState[SortState["DESCENDING"] = 2] = "DESCENDING";
                            })(Table.SortState || (Table.SortState = {}));
                            var SortState = Table.SortState;
                        })(Table = components.Table || (components.Table = {}));
                    })(components = ui.components || (ui.components = {}));
                })(ui = infrastructure.ui || (infrastructure.ui = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ui;
                (function (ui) {
                    var components;
                    (function (components) {
                        var WizardPanel;
                        (function (WizardPanel) {
                            /**
                             * A wizard fragment is a piece of user interface (i.e. a view) that can be placed within a wizard container.
                             */
                            var WizardFragmentView = (function (_super) {
                                __extends(WizardFragmentView, _super);
                                /**
                                * Initializes a new instance of the {@link WizardFragmentView} class.
                                * @param app The {@link geocortex.framework.application.Application} that this view belongs to.
                                * @param libraryId
                                */
                                function WizardFragmentView(app, libraryId) {
                                    _super.call(this, app, libraryId);
                                }
                                /**
                                 * Associates this view with its view model and its parental ViewContainerView.
                                 */
                                WizardFragmentView.prototype.attach = function (viewModel) {
                                    var _this = this;
                                    _super.prototype.attach.call(this, viewModel);
                                    // Listen for the ViewContainerActivatedEvent to keep a reference to the parent wizard container view.
                                    if (!this._viewContainerActivatedEventToken) {
                                        this._viewContainerActivatedEventToken = this.app.event("ViewContainerActivatedEvent").subscribe(this, function (container) {
                                            if (_this.parentContainer == null && _this._isViewHostedInContainer(container)) {
                                                _this.parentContainer = container;
                                            }
                                        });
                                    }
                                };
                                /**
                                 * Determines whether this view is hosted within the supplied view container.
                                 */
                                WizardFragmentView.prototype._isViewHostedInContainer = function (container) {
                                    if (container instanceof geocortex.framework.ui.ViewContainer.ViewContainerView) {
                                        var containerRegion = container.viewModel.regionName.get();
                                        var region = this.app.viewManager.getRegionForViewId(this.id);
                                        // Check whether the view's region matches the container region.
                                        if (region && region.name === containerRegion) {
                                            return true;
                                        }
                                    }
                                    return false;
                                };
                                /**
                                 * Completes the wizard.
                                 */
                                WizardFragmentView.prototype.finishWizard = function () {
                                    if (this.parentContainer) {
                                        this.parentContainer.finish();
                                    }
                                };
                                /**
                                 * Cancels the wizard and discards any data that has been entered so far.
                                 */
                                WizardFragmentView.prototype.cancelWizard = function () {
                                    if (this.parentContainer) {
                                        this.parentContainer.cancel();
                                    }
                                };
                                /**
                                 * Cleans up the ViewContainerActivatedEvent subscription.
                                 */
                                WizardFragmentView.prototype.destroy = function () {
                                    _super.prototype.destroy.call(this);
                                    if (this._viewContainerActivatedEventToken) {
                                        this.app.event("ViewContainerActivatedEvent").unsubscribe(this._viewContainerActivatedEventToken);
                                        this._viewContainerActivatedEventToken = null;
                                    }
                                    if (this.parentContainer) {
                                        this.parentContainer = null;
                                    }
                                };
                                /**
                                 * Validator function that is dedicated to this dialog.
                                 * Override this method to provide your own validation rules.
                                 * @return Array of validation problems.
                                 */
                                WizardFragmentView.prototype._validator = function () {
                                    return [];
                                };
                                /**
                                 * Performs validation on a dialog, and populates the validation problems observable of the view-model.
                                 * @param options Optional parameters to use while validating this dialog.
                                 * @return `true` if the form validates, `false` if it fails.
                                 */
                                WizardFragmentView.prototype.validate = function (options) {
                                    this.validationProblems = this._validator();
                                    return this.validationProblems.length < 1;
                                };
                                /**
                                 * Derived classes might override this method to reset a dialog to its default state. Allows dialogs to be reused.
                                 */
                                WizardFragmentView.prototype.reset = function () {
                                    this.viewModel.reset();
                                };
                                /**
                                 * Derived classes might override to this method to fetch data that is to be presented by this wizard fragment.
                                 */
                                WizardFragmentView.prototype.loadState = function () {
                                };
                                /**
                                 * Derived classes might override to this method to save the data captured within this wizard fragment.
                                 */
                                WizardFragmentView.prototype.saveState = function () {
                                    var args = [];
                                    for (var _i = 0; _i < arguments.length; _i++) {
                                        args[_i - 0] = arguments[_i];
                                    }
                                };
                                /**
                                 * Advances the wizard to the next step. Usually involves activating a new dialog and closing the current one.
                                 * Must be overridden in derived classes.
                                 */
                                WizardFragmentView.prototype.goNext = function () {
                                    var args = [];
                                    for (var _i = 0; _i < arguments.length; _i++) {
                                        args[_i - 0] = arguments[_i];
                                    }
                                    throw new Error("This method is abstract");
                                };
                                /**
                                 * Takes the wizard one step back.
                                 * Must be overridden in derived classes.
                                 */
                                WizardFragmentView.prototype.goBack = function () {
                                    var args = [];
                                    for (var _i = 0; _i < arguments.length; _i++) {
                                        args[_i - 0] = arguments[_i];
                                    }
                                    throw new Error("This method is abstract");
                                };
                                return WizardFragmentView;
                            }(geocortex.framework.ui.ViewBase));
                            WizardPanel.WizardFragmentView = WizardFragmentView;
                        })(WizardPanel = components.WizardPanel || (components.WizardPanel = {}));
                    })(components = ui.components || (ui.components = {}));
                })(ui = infrastructure.ui || (infrastructure.ui = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ui;
                (function (ui) {
                    var components;
                    (function (components) {
                        var SmartPanel;
                        (function (SmartPanel) {
                            /**
                             * A Smart Panel is an extension of {@link framework.ui.ViewContainer.ViewContainerView} that adds the ability to "hoist" menu widgets
                             * from views within the panel's managed region.
                             * When a menu is "hoisted" from a view, a new menu view is created for the same menu, and a button appears in the panel's header that
                             * will activate the menu view.
                             * While a menu is hoisted, it is hidden in the originating view.
                             * Any menu created via {@link menus.MenuRegistry.createMenuWidget} can be hoisted.
                             */
                            var SmartPanelView = (function (_super) {
                                __extends(SmartPanelView, _super);
                                function SmartPanelView() {
                                    _super.apply(this, arguments);
                                    /** Whether the panel is able to be resized vertically */
                                    this.resizeY = false;
                                    /** Whether the panel is able to be resized horizontally */
                                    this.resizeX = false;
                                    /** Menu views created by this component, tracked to ensure we don't "leak" any instances of {@link MenuView}. */
                                    this._menuViews = {};
                                    /** Subscription token for the binding event for the menu item invoked event */
                                    this._menuItemInvokedSubscriptionToken = null;
                                }
                                /** @inherited */
                                SmartPanelView.prototype.attach = function (viewModelArg) {
                                    var _this = this;
                                    _super.prototype.attach.call(this, viewModelArg);
                                    if (this.configuration.resizableParentRegion) {
                                        if (this.app.site && this.app.site.isInitialized) {
                                            var regionToResize = this.app.viewManager.getExistingRegionByName(this.configuration.resizableParentRegion);
                                            this.resizableRegion = regionToResize.domElement;
                                        }
                                        else {
                                            this.app.event("SiteInitializedEvent").once(this, function () {
                                                var regionToResize = _this.app.viewManager.getExistingRegionByName(_this.configuration.resizableParentRegion);
                                                _this.resizableRegion = regionToResize.domElement;
                                            });
                                        }
                                    }
                                    else {
                                        // Load the region associated with the view if none is provided by config.
                                        if (this.app.site && this.app.site.isInitialized) {
                                            var regionToResize = this.app.viewManager.getExistingRegionByName(this.regionName);
                                            this.resizableRegion = regionToResize.domElement;
                                        }
                                        else {
                                            this.app.event("SiteInitializedEvent").once(this, function () {
                                                var regionToResize = _this.app.viewManager.getExistingRegionByName(_this.regionName);
                                                _this.resizableRegion = regionToResize.domElement;
                                            });
                                        }
                                    }
                                    // Better to get 'resizeX/Y' from the ViewModel, but this isn't always possible so there's the option to get it from
                                    // the view's config as well.
                                    if (this.viewModel.resizeX) {
                                        this.resizeX = this.viewModel.resizeX;
                                    }
                                    else if (this.configuration.resizeX) {
                                        this.resizeX = this.configuration.resizeX;
                                    }
                                    if (this.viewModel.resizeY) {
                                        this.resizeY = this.viewModel.resizeY;
                                    }
                                    else if (this.configuration.resizeY) {
                                        this.resizeY = this.configuration.resizeY;
                                    }
                                    // Makes it so any click event will take away the resize preview.
                                    // This in place so if an error happens during resize the user can still dismiss the preview.
                                    $(this.app.getHostElement()).on("onclick.handle-resize-error", function (event) {
                                        // In case the touchmove bindings are set we need to wipe them out, they prevent the default event.
                                        $(_this.app.getHostElement()).off("mousemove.header-resize touchmove.header-resize");
                                        if (_this.resizePreviewElement.parentNode != null) {
                                            _this.resizableRegion.parentNode.removeChild(_this.resizePreviewElement);
                                        }
                                    });
                                    // Change the attribute on the element whenever the panelMaximized boolean is flipped.
                                    this.viewModel.panelMaximized.bind(this, function (isMaximized) {
                                        if (isMaximized) {
                                            $(_this.resizableRegion).attr("data-maximized", "true");
                                        }
                                        else {
                                            $(_this.resizableRegion).attr("data-maximized", "false");
                                        }
                                    });
                                    // If configured, bind to `statusRegionName`, `statusRegionType`. Otherwise, delete placeholder div from DOM
                                    if (this.viewModel.statusRegion) {
                                        $(this.statusRegionElement).attr("data-region-name", this.viewModel.statusRegion);
                                        $(this.statusRegionElement).attr("data-region-adapter", this.viewModel.statusRegionType);
                                    }
                                    else if (this.statusRegionElement && this.statusRegionElement.parentNode) {
                                        this.statusRegionElement.parentNode.removeChild(this.statusRegionElement);
                                        this.statusRegionElement = null;
                                    }
                                    this._initializeEvents();
                                    this.app.command("MaximizePanel").register(this, function (viewId) { return _this._togglePanelMaximized(viewId, "maximize"); }, this._canExecuteMaximizeRestoreOperations);
                                    this.app.command("RestorePanel").register(this, function (viewId) { return _this._togglePanelMaximized(viewId, "restore"); }, this._canExecuteMaximizeRestoreOperations);
                                };
                                /*
                                 * Initialize events that the view will be listening for.
                                 */
                                SmartPanelView.prototype._initializeEvents = function () {
                                    var _this = this;
                                    // Ensure that if a panel in a region is maximized that the state is applied to all other panels in the region.
                                    var token1 = this.app.event("PanelRegionRestoredEvent").subscribe(this, function (region) {
                                        if (region === _this.resizableRegion) {
                                            _this.viewModel.panelMaximized.set(false);
                                        }
                                    });
                                    var token2 = this.app.event("PanelRegionMaximizedEvent").subscribe(this, function (region) {
                                        if (region === _this.resizableRegion) {
                                            _this.viewModel.panelMaximized.set(true);
                                        }
                                    });
                                    // Make sure event handlers are disposed when this view is destroyed
                                    this.trackSubscription(this.app.event("PanelRegionRestoredEvent"), token1);
                                    this.trackSubscription(this.app.event("PanelRegionMaximizedEvent"), token2);
                                    // When status messages are shown (or dismissed), the position of the scroll region element should be recalculated
                                    if (this.viewModel.statusRegion) {
                                        var token3 = this.app.event("RegionActivatedEvent").subscribe(this, this._handleRegionActivatedOrDeactivated);
                                        var token4 = this.app.event("RegionDeactivatedEvent").subscribe(this, this._handleRegionActivatedOrDeactivated);
                                        this.trackSubscription(this.app.event("RegionActivatedEvent"), token3);
                                        this.trackSubscription(this.app.event("RegionDeactivatedEvent"), token4);
                                    }
                                };
                                /** When status messages are shown (or dismissed), the position of the scroll region element should be recalculated */
                                SmartPanelView.prototype._handleRegionActivatedOrDeactivated = function (region) {
                                    var statusRegionName = this.viewModel ? this.viewModel.statusRegion : null;
                                    if (region && region.name === statusRegionName) {
                                        this.delayedResize();
                                    }
                                };
                                /*
                                 * Handles the "MaximizePanel" and "RestorePanel" commands.
                                 * @param viewId The ID of the targeted view.
                                 * @param operation The operation to perform: either "maximize" or "restore"
                                 */
                                SmartPanelView.prototype._togglePanelMaximized = function (viewId, operation) {
                                    if (viewId === this.id && operation === "maximize") {
                                        this.maximizePanel();
                                    }
                                    if (viewId === this.id && operation === "restore") {
                                        this.minimizePanel();
                                    }
                                };
                                /*
                                 * Checks to see if the maximize/restore operations are valid.
                                 * As for now, any smart panel that has a viewmodel that allows the maximize/minimize button to be shown is considered valid.
                                 * This could be made more sophisticated in the future. (Ooh la la.)
                                 */
                                SmartPanelView.prototype._canExecuteMaximizeRestoreOperations = function () {
                                    if (this.viewModel.showingMaximizeButton.get()) {
                                        return true;
                                    }
                                    return false;
                                };
                                /** @inherited */
                                SmartPanelView.prototype._handleViewActivatedInContainerEvent = function (view) {
                                    _super.prototype._handleViewActivatedInContainerEvent.call(this, view);
                                    // Not a view that we are hosting? Bail out.
                                    if (!this.viewModel || !this.viewModel.getDescriptorForActiveView(view)) {
                                        return;
                                    }
                                    // Set panel parents.
                                    if (view instanceof SmartPanelView === true) {
                                        view.setParentPanel(this);
                                        // GVH-6952: If another SmartPanel is activated within this SmartPanel container and a view is currently active in it, we'll need to hoist any menu within that view.
                                        var currViewInSmartPanel = view.viewModel.currentView;
                                        if (currViewInSmartPanel && currViewInSmartPanel.viewModel && currViewInSmartPanel.isActive) {
                                            this.hoistMenuForView(currViewInSmartPanel);
                                        }
                                    }
                                    else {
                                        // Find the topmost panel with a visible header.
                                        // NOTE: It's possible to change a header's visibility after a menu has been hoisted, and we're not doing anything
                                        // about it here. Why not? 1) It's a bit of an edge case and 2) The next time the menu is hoisted it will be hoisted
                                        // with respect to the update header visibility. 
                                        var parentPanel = this._parentPanel;
                                        var topMostPanelWithHeader;
                                        while (parentPanel) {
                                            if (parentPanel.viewModel.headerIsVisible.get()) {
                                                topMostPanelWithHeader = parentPanel;
                                            }
                                            parentPanel = parentPanel._parentPanel;
                                        }
                                        if (topMostPanelWithHeader) {
                                            topMostPanelWithHeader.hoistMenuForView(view);
                                            return;
                                        }
                                        else {
                                            this.hoistMenuForView(view);
                                        }
                                    }
                                };
                                /** @inherited */
                                SmartPanelView.prototype.activated = function () {
                                    _super.prototype.activated.call(this);
                                };
                                /** @inherited */
                                SmartPanelView.prototype.deactivated = function () {
                                    _super.prototype.deactivated.call(this);
                                };
                                /** @inherited */
                                SmartPanelView.prototype.destroy = function () {
                                    _super.prototype.destroy.call(this);
                                    this._unsubscribeMenuItemInvokedSubscription();
                                    // Destroy any remaining menu views that we've created.
                                    for (var menuViewId in this._menuViews) {
                                        if (!this._menuViews.hasOwnProperty(menuViewId)) {
                                            continue;
                                        }
                                        this.app.viewManager.destroyView(this._menuViews[menuViewId]);
                                    }
                                    this._menuViews = null;
                                    this._parentPanel = null;
                                };
                                /**
                                 * Opens the hoisted menu as its own view in a particular region.
                                 * @param regionName The name of the region to activate the menu view in.
                                 */
                                SmartPanelView.prototype.openHoistedMenuInRegion = function (regionName) {
                                    this._destroyHoistedMenuOwnerViewIfExists();
                                    this.hoistedMenuOwnerView = this.createMenuView(this.viewModel.hoistedMenuViewModel.get());
                                    this.hoistedMenuOwnerView.regionName = regionName;
                                    this.app.viewManager.activateView(this.hoistedMenuOwnerView);
                                };
                                /** @inherited */
                                SmartPanelView.prototype.resolveWidget = function (widgetId, context, binding) {
                                    // We don't bother with the widget if the panel opens hoisted menus in a specific region.
                                    if (widgetId === "SmartPanelHoistedMenu") {
                                        // If we haven't hoisted a view, we don't need to do anything.
                                        if (!this.hoistedMenuId) {
                                            return;
                                        }
                                        this._destroyHoistedMenuOwnerViewIfExists();
                                        this.hoistedMenuOwnerView = this.createMenuView(context);
                                        // If we're activating menus in a particular region, don't return a widget to place in the view.
                                        // In this case, we'll hold onto the menu view because we need it. Unfortunately, `MenuView` does a bunch of work and carries
                                        // logic that dictates whether or not it has executable items (rather than, say, the view model carrying that logic).
                                        // It's not a bad thing to have a view queued up and ready to go, it's just an awkward requirement here in order for us to 
                                        // know if we have executable items or not.
                                        return this.viewModel.menuRegion ? null : this.hoistedMenuOwnerView;
                                    }
                                    return null;
                                };
                                /**
                                 * Creates a new instance of {@link menus.MenuView} with the default menu template.
                                 * @param viewModel The view model for the new menu view.
                                 */
                                SmartPanelView.prototype.createMenuView = function (viewModel) {
                                    var _this = this;
                                    // Create a representation of the menu using the standard menu template.
                                    var menuView = this.app.viewManager.createView({
                                        markupResource: "Mapping/infrastructure/menus/MenuView.html",
                                        typeName: "geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuView",
                                        libraryId: "Mapping.Infrastructure"
                                    });
                                    // Switch the library ID so the menu can resolve its resources from whatever library is using this panel.
                                    menuView.libraryId = this.libraryId;
                                    menuView.configuration.menuId = this.hoistedMenuId;
                                    if (viewModel) {
                                        menuView.attach(viewModel);
                                        // Close the menu (or separate view) when no executable items are present.
                                        this.auto(viewModel.hasExecutableMenuItems, this, function (value) {
                                            if (!value && !_this.viewModel.menuRegion) {
                                                _this.viewModel.inlineMenuIsOpen.set(false);
                                            }
                                        });
                                    }
                                    // Keep track of menus created so we can clean up after ourselves when we're done.
                                    this._menuViews[menuView.id] = menuView;
                                    // Deactivate menu views when an option is invoked. There may be a case where this behaviour is not desired,
                                    // but it's easy enough to cross that bridge when the time comes.
                                    this._unsubscribeMenuItemInvokedSubscription();
                                    this._menuItemInvokedSubscriptionToken = this.app.event("MenuItemInvokedEvent").subscribe(this, function (args) {
                                        if (args.menuView.id in _this._menuViews) {
                                            // If we're not hosting the menu view in a separate region, deactivate the inline one.
                                            if (!_this.viewModel.menuRegion) {
                                                _this.viewModel.inlineMenuIsOpen.set(false);
                                            }
                                            _this.app.viewManager.deactivateView(args.menuView);
                                        }
                                    });
                                    // Destroy menu views when they're deactivated.
                                    var viewDeactivatedToken = this.app.event("ViewDeactivatedEvent").subscribe(this, function (view) {
                                        if (view === menuView) {
                                            _this.app.event("ViewDeactivatedEvent").unsubscribe(viewDeactivatedToken);
                                            // Destroying a menu view will destroy it's view model as well. We'll null out the reference to the view model
                                            // prior to destroying this menu view since we may need to reuse it later.
                                            view.viewModel = null;
                                            _this.app.viewManager.destroyView(view);
                                            delete _this._menuViews[menuView.id];
                                        }
                                    });
                                    // Need to pulse the menu context so the MenuView refreshes the canExecute for its hosted commands
                                    viewModel.menuContext.pulse();
                                    return menuView;
                                };
                                /**
                                 * Handles a click or a tap on the hoisted menu button and opens the menu either as a popup, or as a new view in a region
                                 * whose name provided in configuration for the view model.
                                 */
                                SmartPanelView.prototype.handleTapMenuButton = function () {
                                    var _this = this;
                                    if (this.viewModel.menuRegion) {
                                        if (this.hoistedMenuOwnerView && this.hoistedMenuOwnerView.regionName === this.viewModel.menuRegion && this.hoistedMenuOwnerView.isActive) {
                                            var menuSourceView = this.hoistedMenuOwnerView.viewModel && this.hoistedMenuOwnerView.viewModel.menuSourceView;
                                            this._destroyHoistedMenuOwnerViewIfExists();
                                            // When a menu is hoisted in a separate region, we must reactivate the source view so the user has a predictable experience. Otherwise, if the target region is in another container,
                                            // the next view from that target container will suddenly get activated when the menu is destroyed.
                                            if (menuSourceView) {
                                                this.app.viewManager.activateView(menuSourceView);
                                            }
                                        }
                                        else {
                                            this.openHoistedMenuInRegion(this.viewModel.menuRegion);
                                        }
                                        return;
                                    }
                                    this.viewModel.inlineMenuIsOpen.set(!this.viewModel.inlineMenuIsOpen.get());
                                    if (this.viewModel.inlineMenuIsOpen.get()) {
                                        this.app.event("FlyoutActivated").publish(this);
                                        var tapToDismissArgs = {
                                            view: this.hoistedMenuOwnerView,
                                            onOtherInteracted: function (evt) {
                                                _this.viewModel.inlineMenuIsOpen.set(false);
                                                _this.app.event("FlyoutDeactivated").publish(_this);
                                            }
                                        };
                                        this.app.command("TapToDismiss").execute(tapToDismissArgs);
                                    }
                                };
                                /**
                                 * "Hoists" the first menu found in a given view, hosting a copy of the menu either as a popup/dropdown menu in the header,
                                 * or as a new view that will be activated in a region specified in view model configuration.
                                 * @param view The view to try hoisting a menu from.
                                 */
                                SmartPanelView.prototype.hoistMenuForView = function (view) {
                                    var _this = this;
                                    if (view === this.hoistedMenuOwnerView) {
                                        return;
                                    }
                                    var menuWidgetEntries = this.app.menuRegistry.getMenuWidgetsForView(view);
                                    if (menuWidgetEntries) {
                                        // Only consider the entries with hoisting enabled.
                                        menuWidgetEntries = menuWidgetEntries.filter(function (entry) { return entry.hoistMenu; });
                                    }
                                    if (!menuWidgetEntries || !menuWidgetEntries.length) {
                                        if (this.viewModel.inlineMenuIsOpen.get()) {
                                            this.viewModel.inlineMenuIsOpen.set(false);
                                        }
                                        this.viewModel.hasHoistedMenu.set(false);
                                        this.viewModel.hoistedMenuViewModel.set(SmartPanel.SmartPanelViewModel.emptyMenuViewModel);
                                        this.viewModel.hasExecutableMenuItems.removeSync();
                                        this.viewModel.hasExecutableMenuItems.set(false);
                                        return;
                                    }
                                    // We consider the first menu found as the primary/main menu of the view.
                                    var menuToHoist = menuWidgetEntries[0];
                                    var menuViewModel = new geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuViewModel(this.app, this.libraryId);
                                    // GVH-6952: We'll record the source view for the menu so that if we're hosting the menu in a different region (as we do in handheld), we can reactivate 
                                    // the source view when the menu is closed.
                                    menuViewModel.menuSourceView = view;
                                    // Sync to the original source context of the menuToHoist if it's an observable, else we'll sync to the menuContext of the viewModel.
                                    if (menuToHoist.context && menuToHoist.context.isObservable) {
                                        menuViewModel.menuContext.sync(menuToHoist.context);
                                    }
                                    else {
                                        menuViewModel.menuContext.sync(menuToHoist.widgetViewModel.menuContext);
                                    }
                                    this.hoistedMenuId = menuToHoist.menuId;
                                    // Note: Since the hoisted menu is a widget and its widget-context is `hoistedMenuViewModel`, setting the property will trigger
                                    // the widget to be reconstructed via the panel view's `resolvedWidget` method.
                                    this.viewModel.hoistedMenuViewModel.set(menuViewModel);
                                    this.viewModel.hasHoistedMenu.set(true);
                                    this.viewModel.hasExecutableMenuItems.sync(menuViewModel.hasExecutableMenuItems);
                                    // Hide the DOM element hosting the original menu.
                                    $(menuToHoist.domElement).addClass(SmartPanelView.HoistedClassName);
                                    // Unhide view's menu again if it leaves our clutches.
                                    var activatedEventToken = this.app.event("ViewUnhostedEvent").subscribe(this, function (args) {
                                        if (args.view === view) {
                                            _this.app.event("ViewUnhostedEvent").unsubscribe(activatedEventToken);
                                            $(menuToHoist.domElement).removeClass("hidden-hoisted-menu");
                                        }
                                    });
                                };
                                /**
                                 * Sets the parent panel of this one. This allows for nested panels to perform hoisting.
                                 * @param parentPanel The panel considered the parent of this one.
                                 */
                                SmartPanelView.prototype.setParentPanel = function (parentPanel) {
                                    this._parentPanel = parentPanel;
                                };
                                /**
                                 * Handles the maximize or minimize click events
                                 * @param evt The triggering event.
                                 * @param el The targeted element.
                                 * @ctx ctx The current context.
                                 */
                                SmartPanelView.prototype.handleMaximizeToggleClick = function (evt, el, ctx) {
                                    if (this.viewModel.panelMaximized.get()) {
                                        this.minimizePanel();
                                    }
                                    else {
                                        this.maximizePanel();
                                    }
                                };
                                /**
                                 * Maximizes the panel.
                                 */
                                SmartPanelView.prototype.maximizePanel = function () {
                                    this.viewModel.panelMaximized.set(true);
                                    this.app.command("ResizeShell").execute();
                                    this.app.event("ApplicationResizedEvent").publish();
                                    this.app.event("PanelRegionMaximizedEvent").publish(this.resizableRegion);
                                };
                                /**
                                 * Minimizes the panel.
                                 */
                                SmartPanelView.prototype.minimizePanel = function () {
                                    this.viewModel.panelMaximized.set(false);
                                    this.app.command("ResizeShell").execute();
                                    this.app.event("ApplicationResizedEvent").publish();
                                    this.app.event("PanelRegionRestoredEvent").publish(this.resizableRegion);
                                };
                                SmartPanelView.prototype._unsubscribeMenuItemInvokedSubscription = function () {
                                    if (this._menuItemInvokedSubscriptionToken) {
                                        this.app.event("MenuItemInvokedEvent").unsubscribe(this._menuItemInvokedSubscriptionToken);
                                        this._menuItemInvokedSubscriptionToken = null;
                                    }
                                };
                                /*
                                 * Handles the mousedown event, which is used to initiate panel resizing.
                                 * @param evt An event that can be either a 'mousedown' or 'touchstart' event.
                                 * @el The targeted element.
                                 * @ctx The context.
                                 */
                                SmartPanelView.prototype.handleHeaderMouseDown = function (evt, el, ctx) {
                                    var _this = this;
                                    if (this.viewModel.panelMaximized.get()) {
                                        return true;
                                    }
                                    if (evt.target !== evt.currentTarget) {
                                        return true;
                                    }
                                    // Just in case the binding is already set.
                                    // Otherwise in certain cases the binding can cause a loop to happen that will make it so resizing is not possible.
                                    $(this.app.getHostElement()).off("mouseup.header-click touchend.header-click");
                                    var resizeDelay = 250;
                                    var mouseDown = true;
                                    // Start a timeout to see if the click is held - if so then call the function to start resizing the smart panel.
                                    $(this.app.getHostElement()).one("mouseup.header-click touchend.header-click", function () { mouseDown = false; });
                                    setTimeout(function () {
                                        if (mouseDown && _this.resizableRegion) {
                                            $(_this.app.getHostElement()).off("mouseup.header-click touchend.header-click");
                                            _this.resizeSmartPanel(evt.pageX, evt.pageY);
                                            // Need to prevent the default or else text selection will sometimes happen.
                                            // For IE8 we must do this after we start the resize.
                                            evt.preventDefault();
                                        }
                                    }, resizeDelay);
                                    evt.preventDefault();
                                    evt.stopImmediatePropagation();
                                    return true;
                                };
                                /*
                                 * Handles the touchstart event, which is used to initiate panel resizing.
                                 * @param evt An event that can be either a 'mousedown' or 'touchstart' event.
                                 * @el The targeted element.
                                 * @ctx The context.
                                 */
                                SmartPanelView.prototype.handleHeaderTouchStart = function (evt, el, ctx) {
                                    var _this = this;
                                    if (this.viewModel.panelMaximized.get()) {
                                        return true;
                                    }
                                    // Since we prevent the default event behaviour below, we need to make sure that everything still works for interacting with the
                                    // buttons and menu items. (Default is prevented to stop Chrome on Android from selecting the header/below area when resize on the
                                    // bottom panel is initiated and then the user moves their finger to the left/right.)
                                    // If a button (other than the resize-handle) has been touched then we won't worry about resizing.
                                    var testedElement = evt.target || evt.srcElement;
                                    var isButton = false;
                                    while (testedElement != this.root) {
                                        if ($(testedElement).is("button") && !$(testedElement).hasClass("resize-handle")) {
                                            return true;
                                        }
                                        testedElement = testedElement.parentElement;
                                    }
                                    // Just in case the binding is already set.
                                    // Otherwise in certain cases the binding can cause a loop to happen that will make it so resizing is not possible.
                                    $(this.app.getHostElement()).off("touchend.header-click");
                                    var resizeDelay = 250;
                                    var touchDown = true;
                                    // Start a timeout to see if the click is held - if so then call the function to start resizing the smart panel.
                                    $(this.app.getHostElement()).one("touchend.header-click", function () { touchDown = false; });
                                    setTimeout(function () {
                                        if (touchDown && _this.resizableRegion) {
                                            evt.preventDefault();
                                            $(_this.app.getHostElement()).off("touchend.header-click");
                                            _this.resizeSmartPanel(evt.targetTouches[0].pageX, evt.targetTouches[0].pageY);
                                        }
                                    }, resizeDelay);
                                    evt.preventDefault();
                                    return true;
                                };
                                /** @inherited */
                                SmartPanelView.prototype.resize = function () {
                                    // Override resize method (inherited from ViewContainerView) to account for status region height in smart panels
                                    if (this.headerElement && this.scrollRegionElement && this.containerElement) {
                                        var $statusElement = $(this.statusRegionElement);
                                        var $headerElement = $(this.headerElement);
                                        var $footerElement = $(this.footerElement);
                                        var $scrollRegionElement = $(this.scrollRegionElement);
                                        // Gathering height of inserts, so long as they are not explicitly hidden by `display:none`.
                                        var statusHeight = $statusElement.length && $statusElement.css("display") !== "none"
                                            ? $statusElement.outerHeight()
                                            : 0;
                                        var headerHeight = $headerElement.length && $headerElement.css("display") !== "none"
                                            ? $headerElement.outerHeight()
                                            : 0;
                                        var footerHeight = $footerElement.length && $footerElement.css("display") !== "none"
                                            ? $footerElement.outerHeight()
                                            : 0;
                                        // Account for optional status message region when calculating the scroll region position
                                        headerHeight += statusHeight;
                                        // Don't bother with a "top" style if the scroll region element is not positioned absolutely.
                                        if ($scrollRegionElement.css("position") !== "relative") {
                                            $scrollRegionElement.css("top", headerHeight + "px");
                                        }
                                        $scrollRegionElement.css("bottom", footerHeight + "px");
                                    }
                                };
                                /*
                                 * Initiates panel resizing from a 'mousedown' or 'touchstarted' event.
                                 * @param evt An event that can be either a 'mousedown' or 'touchstart' event.
                                 */
                                SmartPanelView.prototype.resizeSmartPanel = function (initialX, initialY) {
                                    var _this = this;
                                    if (!this.resizeX && !this.resizeY) {
                                        this.app.trace.debug("This panel is not configured to be resizable!");
                                        return;
                                    }
                                    var resizeInformation = {};
                                    resizeInformation.initialX = initialX;
                                    resizeInformation.initialY = initialY;
                                    this.app.event("PanelResizeStartEvent").publish({ viewId: this.id, resizeInformation: resizeInformation });
                                    // Create the element that will be used to show the dimensions of the resized panel.
                                    if (this.resizePreviewElement === null || this.resizePreviewElement === undefined) {
                                        this.resizePreviewElement = document.createElement("div");
                                        this.resizePreviewElement.className = "resize-hint";
                                    }
                                    if (this.resizePreviewElement.parentElement === null) {
                                        this.app.getHostElement().appendChild(this.resizePreviewElement);
                                        // Z-indexes aren't always respected when dragging the preview over other panels.
                                        // Setting width/height to 100% for the axis that we're not resizing causes overlap on other
                                        // elements as well. So we need to place the resize hint in the proper area.
                                        $(this.resizePreviewElement).css("left", this.root.getBoundingClientRect().left);
                                    }
                                    resizeInformation.initialPanelHeight = $(this.resizableRegion).height();
                                    resizeInformation.initialPanelWidth = $(this.resizableRegion).width();
                                    // Due to how the desktop/tablet shell is laid out the height of the region can be zero.
                                    // But the parent <div> has the correct height information.
                                    // We also need to see if the panel is larger than the available viewport - otherwise the preview will show up in the banner.
                                    if (resizeInformation.initialPanelHeight === 0 || resizeInformation.initialPanelHeight > $(this.resizableRegion.parentElement).height()) {
                                        resizeInformation.initialPanelHeight = $(this.resizableRegion.parentElement).height();
                                    }
                                    if (resizeInformation.initialPanelWidth === 0 || resizeInformation.initialPanelWidth > $(this.resizableRegion.parentElement).width()) {
                                        resizeInformation.initialPanelWidth = $(this.resizableRegion.parentElement).width();
                                    }
                                    // TODO: Make this compatible with an element that is resizable both vertically and horizontally.
                                    // TODO: Make it so that the css retrieval is sensitive to px, %, em, etc.
                                    //       Do some googling on how to get the browser's computed CSS values.
                                    if (this.resizeX) {
                                        $(this.resizePreviewElement).width(resizeInformation.initialPanelWidth);
                                        $(this.resizePreviewElement).height(resizeInformation.initialPanelHeight);
                                        resizeInformation.minWidth = parseInt($(this.resizableRegion).css("min-width"));
                                        resizeInformation.maxWidth = parseInt($(this.resizableRegion).css("max-width"));
                                    }
                                    else if (this.resizeY) {
                                        $(this.resizePreviewElement).width(resizeInformation.initialPanelWidth);
                                        $(this.resizePreviewElement).height(resizeInformation.initialPanelHeight);
                                        resizeInformation.minHeight = parseInt($(this.resizableRegion).css("min-height"));
                                        resizeInformation.maxHeight = parseInt($(this.resizableRegion).css("max-height"));
                                    }
                                    this._resizeAccordingToSizeConstraints(resizeInformation, this.resizePreviewElement);
                                    // Handle when the user lifts their finger from the mouse/screen, ending the resize.
                                    $(this.app.getHostElement()).one("mouseup.header-resize touchend.header-resize", function (evt) { return _this._handleResizeEnd(evt, resizeInformation); });
                                    // Event listeners for updating changes to position
                                    $(this.app.getHostElement()).on("mousemove.header-resize ", function (event) {
                                        _this.app.event("PanelResizingEvent").publish({ viewId: _this.id, resizeInformation: resizeInformation });
                                        resizeInformation.currentX = event.pageX;
                                        resizeInformation.currentY = event.pageY;
                                        _this._resizeAccordingToSizeConstraints(resizeInformation, _this.resizePreviewElement);
                                        // Preventing the default event stops text selection from happening.
                                        event.preventDefault();
                                        return false;
                                    });
                                    $(this.app.getHostElement()).on("touchmove.header-resize", function (event) {
                                        _this.app.event("PanelResizingEvent").publish({ viewId: _this.id, resizeInformation: resizeInformation });
                                        var touchEvent = event.originalEvent;
                                        resizeInformation.currentX = touchEvent.targetTouches[0].pageX;
                                        resizeInformation.currentY = touchEvent.targetTouches[0].pageY;
                                        _this._resizeAccordingToSizeConstraints(resizeInformation, _this.resizePreviewElement);
                                        // Need to prevent the default in order to stop rubber banding in iOS.
                                        event.preventDefault();
                                        return false;
                                    });
                                };
                                /*
                                 * Used by resizeSmartPanel() to apply sizing changes.
                                 * @param evt The mouseup/touchend event that initiated this function.
                                 * @param resizeInformation An object containing information about the resizing event.
                                 */
                                SmartPanelView.prototype._handleResizeEnd = function (evt, resizeInformation) {
                                    $(this.app.getHostElement()).off("mousemove.header-resize touchmove.header-resize");
                                    if (this.resizePreviewElement.parentNode) {
                                        this.resizePreviewElement.parentNode.removeChild(this.resizePreviewElement);
                                    }
                                    this._resizeAccordingToSizeConstraints(resizeInformation, this.resizableRegion);
                                    this.app.event("PanelResizeEndEvent").publish({ viewId: this.id, resizeInformation: resizeInformation });
                                    this.app.command("ResizeShell").execute();
                                    this.app.event("ApplicationResizedEvent").publish();
                                };
                                /*
                                 * Resizes the a passed element (preview or region) according to the changes that have taken place in the resizing information.
                                 * @param resizeInformation An object containing information about the resizing event.
                                 * @param elementToResize The element to be resized according to the information in resizingInformation. (Typically the hosting region or preview.)
                                 */
                                SmartPanelView.prototype._resizeAccordingToSizeConstraints = function (resizeInformation, elementToResize) {
                                    if (this.resizeX) {
                                        var newWidth = resizeInformation.initialPanelWidth + (resizeInformation.currentX - resizeInformation.initialX);
                                        if (newWidth < resizeInformation.minWidth) {
                                            $(elementToResize).width(resizeInformation.minWidth);
                                        }
                                        else if (newWidth > resizeInformation.maxWidth) {
                                            $(elementToResize).width(resizeInformation.maxWidth);
                                        }
                                        else {
                                            $(elementToResize).width(newWidth);
                                        }
                                    }
                                    if (this.resizeY) {
                                        var newHeight = resizeInformation.initialPanelHeight + (resizeInformation.initialY - resizeInformation.currentY);
                                        if (newHeight < resizeInformation.minHeight) {
                                            $(elementToResize).height(resizeInformation.minHeight);
                                        }
                                        else if (newHeight > resizeInformation.maxHeight) {
                                            $(elementToResize).height(resizeInformation.maxHeight);
                                        }
                                        else {
                                            $(elementToResize).height(newHeight);
                                        }
                                    }
                                };
                                SmartPanelView.prototype._destroyHoistedMenuOwnerViewIfExists = function () {
                                    if (this.hoistedMenuOwnerView) {
                                        var targetView = this.hoistedMenuOwnerView;
                                        // Need to set hoistedmenuOwnderView to null before destroying the view. This is because destroyView, for some reason, resolves the widget
                                        // again, which will end up calling this function and go into a loop unless we set this property to null first.
                                        this.hoistedMenuOwnerView = null;
                                        // Destroying a menu view will destroy it's view model as well. We'll null out the reference to the view model
                                        // prior to destroying this menu view since we may need to reuse it later.
                                        targetView.viewModel = null;
                                        this.app.viewManager.destroyView(targetView);
                                        delete this._menuViews[targetView.id];
                                    }
                                };
                                SmartPanelView.HoistedClassName = "hidden-hoisted-menu";
                                return SmartPanelView;
                            }(geocortex.framework.ui.ViewContainer.ViewContainerView));
                            SmartPanel.SmartPanelView = SmartPanelView;
                        })(SmartPanel = components.SmartPanel || (components.SmartPanel = {}));
                    })(components = ui.components || (ui.components = {}));
                })(ui = infrastructure.ui || (infrastructure.ui = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../SmartPanel/SmartPanelView.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ui;
                (function (ui) {
                    var components;
                    (function (components) {
                        var WizardPanel;
                        (function (WizardPanel) {
                            /**
                             * A Wizard Panel is an extension of {@link infrastructure.ui.components.SmartPanel.SmartPanelViewModel} that adds the ability to
                             * create simple step-by-step wizards within the panel's managed region.
                             *
                             * The container header displays a "Back" button along with a "Close" button. The "Back" button takes the wizard back one step.
                             * The "Close" button quits the wizard and discards any data that has been entered so far. The "Back" button is disabled on the first step.
                             *
                             * It is up to the originating views to define what "Next" means. Typically you would activate the dialog for the next step.
                             */
                            var WizardPanelView = (function (_super) {
                                __extends(WizardPanelView, _super);
                                function WizardPanelView() {
                                    _super.apply(this, arguments);
                                }
                                /**
                                 * Completes the wizard.
                                 */
                                WizardPanelView.prototype.finish = function () {
                                    this.viewModel.closeAllViews();
                                    // TODO Raise event "WizardCompletedEvent"
                                };
                                /**
                                 * Cancels the wizard and discards any data that has been entered so far.
                                 */
                                WizardPanelView.prototype.cancel = function () {
                                    this.viewModel.closeAllViews(true);
                                    // TODO Raise event "WizardCancelledEvent"
                                };
                                WizardPanelView.prototype.handleClickBack = function (evt, el, ctx) {
                                    _super.prototype.handleClickBack.call(this, evt, el, ctx);
                                };
                                WizardPanelView.prototype.handleClickClose = function (evt, el, ctx) {
                                    _super.prototype.handleClickClose.call(this, evt, el, ctx);
                                    this.cancel();
                                };
                                return WizardPanelView;
                            }(infrastructure.ui.components.SmartPanel.SmartPanelView));
                            WizardPanel.WizardPanelView = WizardPanelView;
                        })(WizardPanel = components.WizardPanel || (components.WizardPanel = {}));
                    })(components = ui.components || (ui.components = {}));
                })(ui = infrastructure.ui || (infrastructure.ui = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ui;
                (function (ui) {
                    var components;
                    (function (components) {
                        var SmartPanel;
                        (function (SmartPanel) {
                            /**
                             * Default view model for a {@link SmartPanelView}.
                             */
                            var SmartPanelViewModel = (function (_super) {
                                __extends(SmartPanelViewModel, _super);
                                /** @inherited */
                                function SmartPanelViewModel(app, libraryId) {
                                    _super.call(this, app, libraryId);
                                    /**
                                     * The view model for the currently hoisted menu.
                                     * When there is no hoisted menu present, this should be set to {@link emptyMenuViewModel}.
                                     */
                                    this.hoistedMenuViewModel = new Observable(SmartPanelViewModel.emptyMenuViewModel);
                                    /** Whether or not a menu is available for presentation as a hoisted menu. */
                                    this.hasHoistedMenu = new Observable(false);
                                    /** Whether or not the currently hoisted menu (if present) has any executable menu items. */
                                    this.hasExecutableMenuItems = new Observable(false);
                                    /** Whether or not the inline menu is open. */
                                    this.inlineMenuIsOpen = new Observable(false);
                                    /** Whether or not this panel is currently maximized */
                                    this.panelMaximized = new Observable(false);
                                    /** Whether to display the maximize button on this smart panel. Defaults to false */
                                    this.showingMaximizeButton = new Observable(false);
                                    /** Whether the views that are linked to this are able to be resized on the x axis */
                                    this.resizeX = false;
                                    /** Whether the views that are linked to this are able to be resized on the y axis */
                                    this.resizeY = false;
                                    if (!SmartPanelViewModel.emptyMenuViewModel) {
                                        SmartPanelViewModel.emptyMenuViewModel = new infrastructure.menus.MenuViewModel(app, libraryId);
                                    }
                                }
                                /** @inherited */
                                SmartPanelViewModel.prototype.initialize = function (config) {
                                    _super.prototype.initialize.call(this, config);
                                    this.statusRegion = config.statusRegionName;
                                    this.statusRegionType = config.statusRegionType || "geocortex.framework.ui.DivRegionAdapter";
                                    if (config.resizeX) {
                                        this.resizeX = config.resizeX;
                                    }
                                    if (config.resizeY) {
                                        this.resizeY = config.resizeY;
                                    }
                                    this.menuRegion = config.menuRegion || null;
                                    if (config.showMaximizeButton != undefined) {
                                        this.showingMaximizeButton.set(config.showMaximizeButton);
                                    }
                                };
                                return SmartPanelViewModel;
                            }(geocortex.framework.ui.ViewContainer.ViewContainerViewModel));
                            SmartPanel.SmartPanelViewModel = SmartPanelViewModel;
                        })(SmartPanel = components.SmartPanel || (components.SmartPanel = {}));
                    })(components = ui.components || (ui.components = {}));
                })(ui = infrastructure.ui || (infrastructure.ui = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../SmartPanel/SmartPanelViewModel.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ui;
                (function (ui) {
                    var components;
                    (function (components) {
                        var WizardPanel;
                        (function (WizardPanel) {
                            /**
                             * Default view model for a {@link WizardPanelView}.
                             */
                            var WizardPanelViewModel = (function (_super) {
                                __extends(WizardPanelViewModel, _super);
                                function WizardPanelViewModel(app, libraryId) {
                                    _super.call(this, app, libraryId);
                                }
                                /**
                                 * Provides custom logic for showing "Back" and "Close" buttons.
                                 */
                                WizardPanelViewModel.prototype.showOrHideCloseButtons = function () {
                                    var rootViewDescriptor = this.viewDescriptors.getAt(0);
                                    if (!rootViewDescriptor) {
                                        return;
                                    }
                                    // The "Back" button should be disabled on the first step.
                                    // The "Close" button should always be displayed (regardless of configuration saying otherwise)
                                    var isFirstStep = this.currentView === rootViewDescriptor.view;
                                    this.showingBackButton.set(!isFirstStep);
                                    this.showingXButton.set(true);
                                };
                                /**
                                 * Removes all views from the container region.
                                 */
                                WizardPanelViewModel.prototype.closeAllViews = function (abort) {
                                    for (var i = 0; i < this.viewDescriptors.length(); i++) {
                                        var descriptor = this.viewDescriptors.getAt(i);
                                        var view = descriptor.view;
                                        var viewModel = view.viewModel;
                                        // Give views a chance to clean-up
                                        if (this._isWizardFragment(viewModel)) {
                                            viewModel.reset();
                                        }
                                        this.app.viewManager.deactivateView(view);
                                    }
                                };
                                WizardPanelViewModel.prototype._isWizardFragment = function (x) {
                                    return x.reset !== undefined;
                                };
                                return WizardPanelViewModel;
                            }(infrastructure.ui.components.SmartPanel.SmartPanelViewModel));
                            WizardPanel.WizardPanelViewModel = WizardPanelViewModel;
                        })(WizardPanel = components.WizardPanel || (components.WizardPanel = {}));
                    })(components = ui.components || (ui.components = {}));
                })(ui = infrastructure.ui || (infrastructure.ui = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var undo;
                (function (undo) {
                    /** Indicates the status of the {@link UndoTransaction} */
                    var TransactionStatus;
                    (function (TransactionStatus) {
                        TransactionStatus.PENDING = "pending";
                        TransactionStatus.COMMITTING = "committing";
                        TransactionStatus.COMMITTED = "committed";
                        TransactionStatus.ABORTING = "aborting";
                        TransactionStatus.ABORTED = "aborted";
                    })(TransactionStatus = undo.TransactionStatus || (undo.TransactionStatus = {}));
                })(undo = infrastructure.undo || (infrastructure.undo = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/bluebird.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var sharing;
                (function (sharing) {
                    /** Describes the priority of link providers that modify the map extent. */
                    (function (ExtentLinkPriority) {
                        /**
                         * Scale must be applied first, or else its value is lost
                         * when scale is recalculated upon changing the center or extent.
                        */
                        ExtentLinkPriority[ExtentLinkPriority["SCALE"] = 0] = "SCALE";
                        ExtentLinkPriority[ExtentLinkPriority["CENTER"] = 1] = "CENTER";
                        ExtentLinkPriority[ExtentLinkPriority["EXTENT"] = 2] = "EXTENT";
                    })(sharing.ExtentLinkPriority || (sharing.ExtentLinkPriority = {}));
                    var ExtentLinkPriority = sharing.ExtentLinkPriority;
                    /** Describes the priority of link providers that modify the layer list. */
                    (function (LayerListLinkPriority) {
                        /**
                         * Layer theme must be applied first or it will override
                         * changes from the layer url parameter.
                         */
                        LayerListLinkPriority[LayerListLinkPriority["LAYERTHEME"] = 0] = "LAYERTHEME";
                        LayerListLinkPriority[LayerListLinkPriority["LAYERS"] = 1] = "LAYERS";
                    })(sharing.LayerListLinkPriority || (sharing.LayerListLinkPriority = {}));
                    var LayerListLinkPriority = sharing.LayerListLinkPriority;
                    /**
                     * The base class for all sharing link providers.
                     */
                    var SharingLinkProviderBase = (function () {
                        /**
                         * Create a new instance of the {@link SharingLinkProviderBase} class.
                         * @param app The {@link ViewerApplication} that this command belongs to.
                         * @param libraryId The ID of the library this component belongs to.
                         */
                        function SharingLinkProviderBase(app, libraryId) {
                            /** Whether the sharing link provider will apply a url parameter on startup. */
                            this.acceptParameter = true;
                            /** Whether the sharing link provider will produce a parameter when generating a url. */
                            this.generateParameter = true;
                            this.app = app;
                            this.libraryId = libraryId;
                        }
                        /**
                         * Initialize the provider.
                         * @param config The configuration object.
                         */
                        SharingLinkProviderBase.prototype.initialize = function (config) { };
                        /**
                         * Generate the url parameter.
                         */
                        SharingLinkProviderBase.prototype.generate = function () {
                            return "";
                        };
                        /**
                         * Apply the url parameter.
                         * @param urlParameter The url parameter to apply.
                         */
                        SharingLinkProviderBase.prototype.apply = function (urlParameter) { };
                        /**
                         * Gets a language resource from the Application's resource dictionary, given a key, and optional locale.
                         * Returns null if the resource does not exist.
                         * @param key The resource key.
                         * @param locale The locale of the resource to fetch. Defaults to the current application locale.
                         */
                        SharingLinkProviderBase.prototype.getResource = function (resourceKey, locale) {
                            return this.app.getResource(this.libraryId, resourceKey, locale);
                        };
                        return SharingLinkProviderBase;
                    }());
                    sharing.SharingLinkProviderBase = SharingLinkProviderBase;
                })(sharing = infrastructure.sharing || (infrastructure.sharing = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/Framework.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var menus;
                (function (menus) {
                    /**
                     * Holds information and state about an instance of a particular menu.
                     */
                    var MenuViewModel = (function (_super) {
                        __extends(MenuViewModel, _super);
                        function MenuViewModel(app, libraryId) {
                            _super.call(this, app, libraryId);
                            /** The title of this menu, which may be used for presentation purposes. */
                            this.menuTitle = new Observable("");
                            /** The description of this menu. */
                            this.menuDescription = new Observable("");
                            /** Menu items associated with this menu. */
                            this.menuItems = new ObservableCollection([]);
                            /** Menu items that are currently executable or are currently non-executable but have their "hideOnDisable" setting set to false. */
                            this.visibleMenuItems = new ObservableCollection([]);
                            /** A boolean which is`true` if the menu has any executable menu items, `false` if not. */
                            this.hasExecutableMenuItems = new Observable(false);
                            /**
                             * Context associated with the menu. If `commandParameter` is not specified on a menu item, it is passed the `menuContext`
                             * itself upon invocation. If `commandParameter` is specified, it is passed to the specified command.
                             * If `commandParameter` has properties with string value tokens in the format of `{{SomeProperty}}`, these properties will
                             * be resolved against properties of the `menuContext` itself.
                             */
                            this.menuContext = new Observable(null);
                            this.auto(this.menuContext, this, this._handleContextChanged);
                            this.auto(this.menuItems, this, this._handleMenuItemsChanged);
                        }
                        /**
                         * Initializes this menu view model based on the provided configuration
                         * @param config The configuration for this menu view model
                         */
                        MenuViewModel.prototype.initialize = function (config) {
                            _super.prototype.initialize.call(this, config);
                            this.menuId = (config && config.menuId) || null;
                            this.libraryId = (config && config.libraryId) || this.libraryId;
                            // Note: We don't setup the menu at this point since we need to wait till all the view models (menu and non menu) in the system are initialized. The menu 
                            // registry supports loading menus from any view model that requests it. We'll invoke the setupMenu routine when this view model is attached to the view. 
                        };
                        /**
                         * Retrieves the menu for this view model from the menu registry and sets it up. This is done only when the view requests it as part of it's attach routine.
                         * @param id the id of the menu to set up this view model for
                         */
                        MenuViewModel.prototype.setupMenu = function (menuId) {
                            var _this = this;
                            this.menuId = menuId || this.menuId;
                            if (!this.menuId) {
                                this.app.trace.error("MenuViewModel: Could not load menu. Menu id not specified.");
                                return;
                            }
                            this.menuItems.clear();
                            var menu = this.app.menuRegistry.getMenu(this.menuId);
                            if (!menu) {
                                this.app.trace.error("MenuViewModel: Could not load menu '{0}'. Menu not registered.".format(this.menuId));
                                return;
                            }
                            menu.title && this.menuTitle.set(menu.title);
                            menu.description && this.menuDescription.set(menu.description);
                            if (menu.items && menu.items.length) {
                                var menuVmArray = [];
                                menu.items.forEach(function (item) {
                                    var menuItemVm = new menus.MenuItemViewModel(_this, item);
                                    menuVmArray.push(menuItemVm);
                                    _this.auto(menuItemVm.canExecute, _this, _this._computeExecutableMenuItems);
                                });
                                this.menuItems.addItems(menuVmArray);
                            }
                        };
                        /**
                         * Clean up when this menu view model is destroyed
                         */
                        MenuViewModel.prototype.onDestroy = function () {
                            _super.prototype.onDestroy.call(this);
                            this.menuItems.get().forEach(function (item) { return item.destroy(); });
                            this.menuItems.clear();
                            this.visibleMenuItems.clear();
                        };
                        /**
                         * This function executes when the `canExecute` of any of the menu items changes, or a new element is added to the list.
                         */
                        MenuViewModel.prototype._computeExecutableMenuItems = function () {
                            var hasAnyExecutableItems = false;
                            var visibleItems = [];
                            this.visibleMenuItems.clear();
                            for (var i = 0; i < this.menuItems.length(); i++) {
                                var currentItem = this.menuItems.getAt(i);
                                if (currentItem.canExecute.get()) {
                                    hasAnyExecutableItems = true;
                                    visibleItems.push(currentItem);
                                }
                                else {
                                    if (!currentItem.menuItem.hideOnDisable) {
                                        visibleItems.push(currentItem);
                                    }
                                }
                            }
                            this.visibleMenuItems.set(visibleItems);
                            this.hasExecutableMenuItems.set(hasAnyExecutableItems);
                        };
                        /**
                        * Applies menu context changes to all items in the menu.
                        * @param context The new context to be applied to this menu.
                        */
                        MenuViewModel.prototype._handleContextChanged = function (menuContext) {
                            this.menuItems.get().forEach(function (menuitemViewModel) { return menuitemViewModel.refreshCanExecute(); });
                        };
                        /**
                        * When the collection changes, we'll need to decide how to handle the elements. Removals and clears remove from the executable list,
                        * Additions need only re execute canExecuteChanged to decide whether to display or not.
                        * @param changedArgs Indicate the type of change made to the menu items.
                        */
                        MenuViewModel.prototype._handleMenuItemsChanged = function (changedArgs) {
                            if (changedArgs.type === "clear") {
                                this.visibleMenuItems.clear();
                            }
                            else if (changedArgs.type === "append") {
                                this._computeExecutableMenuItems();
                            }
                            else if (changedArgs.type === "remove") {
                                var elements = changedArgs.sender.get().slice(changedArgs.rangeStart, changedArgs.rangeEnd + 1);
                                for (var i = 0; i < elements.length; i++) {
                                    this.visibleMenuItems.removeItem(elements[i]);
                                }
                            }
                            else if (changedArgs.type === "insert") {
                                this._computeExecutableMenuItems();
                            }
                        };
                        /** The default menu context parameter name. */
                        MenuViewModel.DefaultParameterName = "context";
                        return MenuViewModel;
                    }(geocortex.framework.ui.ViewModelBase));
                    menus.MenuViewModel = MenuViewModel;
                })(menus = infrastructure.menus || (infrastructure.menus = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var applicationState;
                (function (applicationState) {
                    /**
                     * Represents a currently active instance of a state.
                     */
                    var ActiveState = (function () {
                        function ActiveState(stateDefinition, activatedBy) {
                            this.stateDefinition = stateDefinition;
                            this.activatedBy = activatedBy;
                        }
                        return ActiveState;
                    }());
                    applicationState.ActiveState = ActiveState;
                })(applicationState = infrastructure.applicationState || (infrastructure.applicationState = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var applicationState;
                (function (applicationState) {
                    var StateManager = (function () {
                        function StateManager(app, libraryId) {
                            // All states that are registered by the state manager.
                            this.registeredStates = [];
                            // The currently active states.
                            this.activeStates = [];
                            // The current modal state.
                            this.modalState = null;
                            // The previous modal state.
                            this.previousModalState = null;
                            // Tokens associated with the registration of commands and events.
                            // Retained so that the command/event listeners can be cleaned up on class destruction.
                            this.commandTokens = [];
                            this.eventTokens = [];
                            this.app = app;
                            this.libraryId = libraryId;
                            // Register all of the states stored in State.ts.
                            for (var i = 0; i < applicationState.definedStates.length; i++) {
                                this.registerState(applicationState.definedStates[i]);
                            }
                        }
                        /**
                         * Used to load the states into the registry. Does not allow for duplicate states.
                         * @param newState The state to add to the registry.
                         */
                        StateManager.prototype.registerState = function (newState) {
                            var _this = this;
                            // Ensure that there are no duplicate named states registered.
                            if (this.registeredStates.some(function (state) { return state.name === newState.name; })) {
                                this.app.trace.info("States with duplicate names registered! New state ignored. Name is: " + newState.name);
                                return;
                            }
                            // Make sure that the parent state (if defined) doesn't have its own parent state.
                            // State manager does not support anything more than parent -> child relationships.
                            var statesWithParentStates = this.registeredStates.filter(function (state) { return state.hasOwnProperty("parentState"); });
                            if (statesWithParentStates.some(function (stateWithParent) { return stateWithParent.name === newState.parentState; })) {
                                this.app.trace.info("Tried to load a state with a parent that references another state that has a parent. Only parent -> child relationships are allowed. State name: " + newState.name);
                                return;
                            }
                            // Get the description and overwrite the language string descriptor.
                            // This can only be done once the libraries are downloaded, so wait for that event.
                            var handle = dojo.connect(this.app, "onLibrariesDownloaded", this, function () {
                                dojo.disconnect(handle);
                                // The management pack seems to spin this up multiple times, which isn't exactly what we want considering that
                                // the description is overwritten. The language strings by default will have no spaces, so let's make sure that
                                // There are none and that the library is loaded since the MP also tries to load this before having Mapping.Infrastructure
                                // available.
                                if (_this.app.hasLibrary(_this.libraryId) && newState.description.search(" ") === -1) {
                                    newState.description = _this.app.getResource(_this.libraryId, newState.description);
                                }
                            });
                            // Set up the commands and events to be listened for - whenever these are called then the state will the entered/exited.
                            if (newState.enterCommands) {
                                newState.enterCommands.forEach(function (commandInstance) {
                                    var token = _this.app.command(commandInstance.name).register(_this, function (args) { return _this._stateEntered(newState, commandInstance, args); });
                                    _this.commandTokens.push({
                                        instance: commandInstance,
                                        token: token
                                    });
                                });
                            }
                            if (newState.exitCommands) {
                                newState.exitCommands.forEach(function (commandInstance) {
                                    var token = _this.app.command(commandInstance.name).register(_this, function (args) { return _this._stateExited(newState, commandInstance, args); });
                                    _this.commandTokens.push({
                                        instance: commandInstance,
                                        token: token
                                    });
                                });
                            }
                            if (newState.enterEvents) {
                                newState.enterEvents.forEach(function (eventInstance) {
                                    var token = _this.app.event(eventInstance.name).subscribe(_this, function (args) { return _this._stateEntered(newState, eventInstance, args); });
                                    _this.eventTokens.push({
                                        instance: eventInstance,
                                        token: token
                                    });
                                });
                            }
                            if (newState.exitEvents) {
                                newState.exitEvents.forEach(function (eventInstance) {
                                    var token = _this.app.event(eventInstance.name).subscribe(_this, function (args) { return _this._stateExited(newState, eventInstance, args); });
                                    _this.eventTokens.push({
                                        instance: eventInstance,
                                        token: token
                                    });
                                });
                            }
                            // Add the state to the registry.
                            this.registeredStates.push(newState);
                            // Add the default state to the active states.
                            // This is a state that always exists. 
                            if (newState.name === "DefaultState") {
                                this.activeStates.push(new applicationState.ActiveState(newState));
                            }
                        };
                        /**
                         * Run when the State Manager is destroyed.
                         */
                        StateManager.prototype.onDestroy = function () {
                            for (var i = 0; i < this.eventTokens.length; i++) {
                                this.app.event(this.eventTokens[i].instance.name).unsubscribe(this.eventTokens[i].token);
                            }
                            for (var i = 0; i < this.commandTokens.length; i++) {
                                this.app.command(this.commandTokens[i].instance.name).unregister(this.commandTokens[i].token);
                            }
                        };
                        /**
                         * Returns an array of the currently active states. Does not return children that currently lack
                         * an active parent.
                         */
                        StateManager.prototype.getActiveStates = function () {
                            var validActiveStatesNames = [];
                            // Form a collection that will be used to see whether the state is an active parent state.
                            for (var i = 0; i < this.activeStates.length; i++) {
                                validActiveStatesNames[this.activeStates[i].stateDefinition.name] = this.activeStates[i];
                            }
                            // Only valid states are those with an active parent or no parent at all.         
                            return this.activeStates.filter(function (activeState) { return activeState.stateDefinition.parentState && validActiveStatesNames[activeState.stateDefinition.parentState] || !activeState.stateDefinition.parentState; });
                        };
                        /**
                         * Returns a state from the manager's registry.
                         * @param stateName The name of the state to retrieve from the registry.
                         */
                        StateManager.prototype.getStateByName = function (stateName) {
                            for (var i = 0; i < this.registeredStates.length; i++) {
                                if (this.registeredStates[i].name === stateName) {
                                    return this.registeredStates[i];
                                }
                            }
                            return null;
                        };
                        /**
                         * Returns the currently active modal state, if any. Returns null if there is no state.
                         */
                        StateManager.prototype.getModalState = function () {
                            return this.modalState || null;
                        };
                        /**
                         * Returns whether a modal state is currently active or not.
                         */
                        StateManager.prototype.isModalStateActive = function () {
                            return this.modalState !== null;
                        };
                        /**
                         * Returns whether a state is currently active or not.
                         * @param stateName The name of the state that is being checked.
                         */
                        StateManager.prototype.isCurrentlyActive = function (stateName) {
                            return this.activeStates.some(function (activeState) { return activeState.stateDefinition.name === stateName; });
                        };
                        /**
                         * Returns an array with the names of all states in the registry.
                         */
                        StateManager.prototype.getAllStateNames = function () {
                            var allStateNames = [];
                            for (var i = 0; i < this.registeredStates.length; i++) {
                                allStateNames.push(this.registeredStates[i].name);
                            }
                            return allStateNames;
                        };
                        /**
                         * Run whenever a state is entered.
                         * @param state The state this is being entered.
                         * @param commandOrEvent The command/event instance that is associated with this state.
                         * @param commandOrEventArgs The command/event's arguments (if any). Only strings are supported.
                         */
                        StateManager.prototype._stateEntered = function (state, commandOrEvent, commandOrEventArgs) {
                            // Check to see if the parent state is enabled (if there is one). If not, then we can't enter this state.
                            if (state.parentState && !this.activeStates.some(function (activeState) { return activeState.stateDefinition.name === state.parentState; })) {
                                return;
                            }
                            // Also don't want to re-enter a state that is already active.
                            if (this.isCurrentlyActive(state.name)) {
                                return;
                            }
                            // If there are args defined in the commandOrEventInstance and they don't match the supplied args then we don't want to activate
                            // the state.
                            if (commandOrEvent.parameter && commandOrEvent.parameter !== commandOrEventArgs) {
                                return;
                            }
                            // Check to see if the args passed are a string. If they are then we can send them along with the event.
                            var eventOrCommandParameter = null;
                            if (typeof commandOrEventArgs === "string" || commandOrEventArgs instanceof String) {
                                eventOrCommandParameter = commandOrEventArgs;
                            }
                            this.app.trace.debug("State entered: " + state.name);
                            if (state.isModal) {
                                if (this.modalState !== null) {
                                    this.previousModalState = this.modalState;
                                    this._exitState(this.modalState, commandOrEvent, eventOrCommandParameter);
                                }
                                this.app.trace.debug("Modal State entered: " + state.name);
                                this.modalState = state;
                            }
                            this.activeStates.push(new applicationState.ActiveState(state, commandOrEvent));
                            this.app.event("StateEnteredEvent").publish({
                                stateDefinition: state,
                                activeStates: this.activeStates,
                                modalState: this.modalState,
                                previousModalState: this.modalState
                            });
                        };
                        /**
                         * Run whenever a state is exited.
                         * @param state The state to exit.
                         * @param commandOrEvent The command/event instance that is associated with this state.
                         * @param commandOrEventArgs The command/event's arguments (if any). Only strings are supported.
                         */
                        StateManager.prototype._stateExited = function (state, commandOrEvent, commandOrEventArgs) {
                            // If there are args defined in the commandOrEventInstance and they don't match the supplied args then we don't want to activate
                            // the state.
                            if (commandOrEvent.parameter && commandOrEvent.parameter !== commandOrEventArgs) {
                                return;
                            }
                            var stateInActiveCollection = false;
                            for (var i = 0; i < this.activeStates.length; i++) {
                                if (this.activeStates[i].stateDefinition === state) {
                                    stateInActiveCollection = true;
                                }
                            }
                            var parentStateActive = false;
                            if (state.parentState) {
                                // Ensure that the parent state is active - this is so that when buffering/snapping is disabled in one transient
                                // it doesn't go and disable it for all. A child state can only be turned off when its parent state is active.
                                parentStateActive = this.activeStates.some(function (activeState) { return activeState.stateDefinition.name === state.parentState; });
                            }
                            if (!stateInActiveCollection || state.parentState && !parentStateActive) {
                                // The state is not currently listed as being active or its parent state is not active, so there is no need to exit it.
                                return;
                            }
                            // Check to see if the args passed are a string. If they are then we can send them along with the event.
                            var eventOrCommandParameter = null;
                            if (typeof commandOrEventArgs === "string" || commandOrEventArgs instanceof String) {
                                eventOrCommandParameter = commandOrEventArgs;
                            }
                            this._exitState(state, commandOrEvent, eventOrCommandParameter);
                        };
                        /**
                         * Deactivates the current state.
                         * Needs to exist outside of _stateExited() as it is also called on state activation in case there is a modal state active.
                         * @param state The state to deactivate.
                         * @param commandOrEvent The command/event instance that is associated with this state.
                         * @param commandOrEventParameter The command/event's arguments (if any). Only strings are supported.
                         */
                        StateManager.prototype._exitState = function (state, commandOrEvent, commandOrEventParameter) {
                            this._exitChildStates(state, commandOrEvent, commandOrEventParameter);
                            for (var i = this.activeStates.length - 1; i >= 0; i--) {
                                var comparedState = this.activeStates[i].stateDefinition;
                                if (comparedState === state) {
                                    this.activeStates.splice(i, 1);
                                    this.app.trace.debug("State exited: " + state.name);
                                }
                            }
                            if (this.modalState === state) {
                                this.modalState = null;
                                this.previousModalState = state;
                                this.app.trace.debug("Modal state exited: " + state.name);
                            }
                            this.app.event("StateExitedEvent").publish({
                                stateDefinition: state,
                                activeStates: this.activeStates,
                                modalState: this.modalState,
                                previousModalState: this.previousModalState
                            });
                        };
                        /**
                         * Exits any child states that should be exiting on the same command/event as the parent state.
                         * @param state The state to deactivate.
                         * @param commandOrEvent The command/event instance that is associated with this state.
                         * @param commandOrEventParameter The command/event's arguments (if any). Only strings are supported.
                         */
                        StateManager.prototype._exitChildStates = function (state, commandOrEvent, commandOrEventParameter) {
                            // If any children states share the same exit command/event then they should be exited as well.
                            // They will be denied if the parent exited before they are, so it's best to take care of them now.
                            var childStatesToExit = [];
                            for (var i = 0; i < this.activeStates.length; i++) {
                                if (this.activeStates[i].stateDefinition.parentState === state.name) {
                                    var currentState = this.activeStates[i].stateDefinition;
                                    if (currentState.exitCommands) {
                                        for (var j = 0; j < currentState.exitCommands.length; j++) {
                                            if (currentState.exitCommands[j].name === commandOrEvent.name &&
                                                (!currentState.exitCommands[j].parameter ||
                                                    currentState.exitCommands[j].parameter === commandOrEventParameter)) {
                                                childStatesToExit.push(currentState);
                                            }
                                        }
                                    }
                                    if (currentState.exitEvents) {
                                        for (var j = 0; j < currentState.exitEvents.length; j++) {
                                            if (currentState.exitEvents[j].name === commandOrEvent.name &&
                                                (!currentState.exitEvents[j].parameter ||
                                                    currentState.exitEvents[j].parameter === commandOrEventParameter)) {
                                                childStatesToExit.push(currentState);
                                            }
                                        }
                                    }
                                }
                            }
                            // Exit the child states that have been collected.
                            for (var i = 0; i < childStatesToExit.length; i++) {
                                this._exitState(childStatesToExit[i], commandOrEvent, commandOrEventParameter);
                            }
                        };
                        return StateManager;
                    }());
                    applicationState.StateManager = StateManager;
                })(applicationState = infrastructure.applicationState || (infrastructure.applicationState = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var applicationState;
                (function (applicationState) {
                    applicationState.definedStates = [
                        /**
                         * Default state - always kept on the stack.
                         */
                        {
                            name: "DefaultState",
                            description: "language-states-default-description",
                            isModal: false
                        },
                        /**
                         * Is active whenever any tool/button based transient is active.
                         */
                        {
                            name: "TransientActiveState",
                            description: "language-states-transient-active-description",
                            isModal: false,
                            enterEvents: [{ name: "TransientActivatedEvent" }],
                            exitEvents: [{ name: "TransientsDeactivatedEvent" }]
                        },
                        /**
                         * Triggered when the default standalone identification tool is active.
                         * This is not modal as it is associated with FindDataState.
                         */
                        {
                            name: "IdentifyState",
                            description: "language-states-identify-state-description",
                            isModal: false,
                            enterCommands: [{ name: "SetActiveTool", parameter: "PointIdentifyTool-Navigation" },
                                { name: "SetActiveTool", parameter: "IdentifyRectangleTool" },
                                { name: "SetActiveTool", parameter: "RectangleIdentifyTool" }],
                            exitEvents: [{ name: "ToolCommandDeactivatedEvent", parameter: "Identify" }]
                        },
                        /**
                         * Triggered when buffering is enabled for the standalone identification tool.
                         */
                        {
                            name: "IdentifyBufferingState",
                            parentState: "IdentifyState",
                            description: "language-states-buffering-description",
                            isModal: false,
                            enterEvents: [{ name: "BufferingActivatedEvent", parameter: "Identify" }],
                            exitEvents: [{ name: "BufferingDeactivatedEvent", parameter: "Identify" }]
                        },
                        /**
                         * Triggered when the plot coordinates tool is active.
                         */
                        {
                            name: "PlotCoordinatesState",
                            description: "language-states-plotcoordinates-state-description",
                            isModal: false,
                            enterCommands: [{ name: "SetActiveTool", parameter: "PlotCoordinatesTool" }],
                            exitEvents: [{ name: "ToolCommandDeactivatedEvent", parameter: "PlotCoordinates" }]
                        },
                        /**
                         * Triggered when snapping is enabled.
                         */
                        {
                            name: "SnappingState",
                            description: "language-states-snapping-description",
                            isModal: false,
                            enterCommands: [{ name: "ActivateSnapping" }],
                            exitCommands: [{ name: "DeactivateSnapping" }]
                        },
                        /**
                         * Triggered when the group identification based tools are active.
                         */
                        {
                            name: "FindDataState",
                            description: "language-states-identify-state-description",
                            isModal: true,
                            enterEvents: [{ name: "ToolCommandActivatedEvent", parameter: "Identify" }],
                            exitEvents: [{ name: "ToolCommandDeactivatedEvent", parameter: "Identify" }]
                        },
                        /**
                         * Triggered when buffering is enabled for the markup drawing tool.
                         */
                        {
                            name: "FindDataBufferingState",
                            parentState: "FindDataState",
                            description: "language-states-buffering-description",
                            isModal: false,
                            enterEvents: [{ name: "BufferingActivatedEvent", parameter: "Identify" }],
                            exitEvents: [{ name: "BufferingDeactivatedEvent", parameter: "Identify" }]
                        },
                        /**
                         * Triggered when any tools that involve drawing markup on the map are active.
                         */
                        {
                            name: "DrawMarkupState",
                            description: "language-states-draw-markup-state-description",
                            isModal: true,
                            enterEvents: [{ name: "ToolCommandActivatedEvent", parameter: "AddMarkup" }, { name: "ToolCommandActivatedEvent", parameter: "AddTextMarkup" }],
                            exitEvents: [{ name: "ToolCommandDeactivatedEvent", parameter: "AddMarkup" }, { name: "ToolCommandDeactivatedEvent", parameter: "AddTextMarkup" }]
                        },
                        /**
                         * Triggered when any tools that involve performing measurements on the map are active.
                         */
                        {
                            name: "MeasureState",
                            description: "language-states-measure-state-description",
                            isModal: true,
                            enterEvents: [{ name: "ToolCommandActivatedEvent", parameter: "MeasureDistance" }, { name: "ToolCommandActivatedEvent", parameter: "MeasureArea" }],
                            exitEvents: [{ name: "ToolCommandDeactivatedEvent", parameter: "MeasureDistance" }, { name: "ToolCommandDeactivatedEvent", parameter: "MeasureArea" }]
                        },
                        /**
                         * Triggered when the tool to select markup on the map for editing is active.
                         */
                        {
                            name: "SelectMarkupForEditingState",
                            description: "language-states-edit-state-description",
                            isModal: true,
                            enterEvents: [{ name: "ToolCommandActivatedEvent", parameter: "DeleteMeasurement" }, { name: "ToolCommandActivatedEvent", parameter: "DeleteMarkup" },
                                { name: "ToolCommandActivatedEvent", parameter: "EditMarkup" }],
                            exitEvents: [{ name: "ToolCommandDeactivatedEvent", parameter: "DeleteMeasurement" }, { name: "ToolCommandDeactivatedEvent", parameter: "DeleteMarkup" },
                                { name: "ToolCommandDeactivatedEvent", parameter: "EditMarkup" }]
                        },
                        /**
                         * Active when the view/edit attributes view is active.
                         */
                        {
                            name: "EditorActiveState",
                            description: "language-states-editing-active-state-description",
                            isModal: false,
                            enterCommands: [{ name: "StartEditingFeature" }, { name: "StartEditingNewFeature" }, { name: "StartEditingNewRelatedRecord" }],
                            exitEvents: [{ name: "EditorClosedEvent" }]
                        },
                        /**
                         * Triggered when a piece of markup is being actively edited.
                         */
                        {
                            name: "EditingMarkupState",
                            description: "language-states-editing-state-description",
                            isModal: false,
                            enterEvents: [{ name: "MarkupEditingStartedEvent" }],
                            exitEvents: [{ name: "MarkupEditingStoppedEvent" }]
                        },
                        /**
                         * Triggered when a piece of markup is being actively edited AND that piece of markup is a measurement.
                         */
                        {
                            name: "EditingMeasurementMarkupState",
                            description: "language-states-editing-state-description",
                            isModal: false,
                            enterEvents: [{ name: "MeasurementEditingStartedEvent" }],
                            exitEvents: [{ name: "MarkupEditingStoppedEvent" }]
                        },
                        /**
                         * Triggered when the the feature editor is started by a template being chosen.
                         */
                        {
                            name: "FeaturePlacementState",
                            description: "language-states-feature-editing-state-description",
                            isModal: true,
                            enterEvents: [{ name: "StartFeaturePlacementEvent" }, { name: "ToolCommandActivatedEvent", parameter: "SetEditorFeatureGeometry" }],
                            exitEvents: [{ name: "StopFeaturePlacementEvent" }, { name: "ToolCommandDeactivatedEvent", parameter: "SetEditorFeatureGeometry" }]
                        },
                        /**
                         * Triggered when the the feature editor's graphic editing state is started.
                         */
                        {
                            name: "FeaturePlacementGraphicState",
                            parentState: "FeaturePlacementState",
                            description: "language-states-feature-editing-state-graphic-description",
                            isModal: false,
                            enterCommands: [{ name: "StartEditingGraphicGeometry" }],
                            enterEvents: [{ name: "ToolCommandActivatedEvent", parameter: "SetEditorFeatureGeometry" }],
                            exitEvents: [{ name: "StopFeaturePlacementEvent" }, { name: "ToolCommandDeactivatedEvent", parameter: "SetEditorFeatureGeometry" }]
                        },
                        /**
                         * Triggered when the the feature editor's graphic editing state is started for a point-based graphic.
                         */
                        {
                            name: "FeaturePlacementPointGraphicState",
                            parentState: "FeaturePlacementState",
                            description: "language-states-feature-editing-state-point-graphic-description",
                            isModal: false,
                            enterEvents: [{ name: "GeometryEditPointActivatedEvent" }],
                            exitEvents: [{ name: "StopFeaturePlacementEvent" }, { name: "ToolCommandDeactivatedEvent", parameter: "SetEditorFeatureGeometry" }]
                        }
                    ];
                })(applicationState = infrastructure.applicationState || (infrastructure.applicationState = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../_Definitions/framework.d.ts"/>
/// <reference path="../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../_Definitions/dojo.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var taskUtils;
                (function (taskUtils) {
                    var LayerParameter = (function () {
                        function LayerParameter() {
                        }
                        return LayerParameter;
                    }());
                    /**
                    * Gets the url that an esri.tasks.QueryTask can be run against for this layer. Suggested to use `getQueryTask` instead.
                    * @param layer The Geocortex/Esri Layer that is to be queried.
                    * @param mapService Required when passing an Esri Layer.
                    * @returns The url for the query endpoint.
                    * @deprecated 2.6 Use `getQueryTask` or `getIntersectTask` instead.
                    */
                    function getQueryTaskUrl(layer, mapService) {
                        var gcxLayer = null;
                        var esriLayer = null;
                        var gcxService;
                        // Get everything set up since the function is polymorphic. 
                        if (layer instanceof geocortex.essentials.Layer) {
                            gcxLayer = layer;
                            gcxService = gcxLayer.mapService;
                            if (mapService) {
                                esriLayer = mapService.serviceLayer;
                            }
                        }
                        else if (layer instanceof esri.layers.Layer) {
                            esriLayer = layer;
                            if (mapService) {
                                gcxService = mapService;
                            }
                        }
                        // Check to see if we're dealing with a related table, if so then we just need the esriLayer's URL.
                        if (esriLayer instanceof esri.layers.FeatureLayer && esriLayer.type === "table" || esriLayer instanceof esri.layers.FeatureLayer && !gcxService) {
                            // Since we don't have a mapService to get the token from just return the URL. Luckily Identity Manager
                            // seems to append the token in all of my test cases.
                            return esriLayer.url;
                        }
                        // Tables don't have a mapService, so we gotta bypass this.
                        if (!canQueryMapService(gcxService)) {
                            return null;
                        }
                        var url = null;
                        if (esriLayer instanceof esri.layers.WMSLayer) {
                            // WMS Layers must point to the Geocortex endpoint.
                            // The majority of other layers are able to use the serviceLayer's URL.
                            if (!gcxLayer) {
                                // Since we require the Geocortex endpoint, this function cannot take a WMS Esri Layer.
                                return null;
                            }
                            url = gcxLayer.url;
                        }
                        else if (gcxLayer) {
                            // Pretty much any layer that isn't WMS has the URL on the ServiceLayer.
                            url = gcxLayer.mapService.serviceLayer.url;
                        }
                        else if (esriLayer) {
                            url = esriLayer.url;
                        }
                        var appendUrl;
                        var dynamicLayerParam = null;
                        if (gcxLayer) {
                            if (gcxLayer.isDynamic) {
                                appendUrl = "dynamicLayer";
                                dynamicLayerParam = _generateDynamicLayerParam(esriLayer, gcxLayer);
                            }
                            else {
                                appendUrl = gcxLayer.id;
                            }
                        }
                        else if (esriLayer) {
                            // If the layer's not dynamic then grab the ID in case the URL is incomplete.
                            appendUrl = esriLayer.id;
                        }
                        if (!(esriLayer instanceof esri.layers.FeatureLayer) && !url.match(/\/\d+(\?.*)?$/)) {
                            // The URL does not have the layer ID - this has to be added manually.
                            var queryIx = url.indexOf("?");
                            var hashIx = url.indexOf("#");
                            if (queryIx != -1) {
                                url = url.substring(0, queryIx) + "/" + appendUrl + url.substring(queryIx);
                            }
                            else if (hashIx != -1) {
                                url = url.substring(0, hashIx) + "/" + appendUrl + url.substring(hashIx);
                            }
                            else {
                                url += "/" + appendUrl;
                            }
                        }
                        // Add the token to the URL, if applicable.
                        url = getTokenizedUrl(url, mapService);
                        // Add all of the dynamic layer information to the URL.
                        if (dynamicLayerParam) {
                            url += url.indexOf("?") > -1 ? "&layer=" : "?layer=";
                            url += encodeURIComponent(JSON.stringify(dynamicLayerParam));
                        }
                        return url;
                    }
                    taskUtils.getQueryTaskUrl = getQueryTaskUrl;
                    /**
                    * Gets an esri.tasks.QueryTask that can be run against for this layer.
                    * @param layer The Geocortex/Esri Layer that is to be queried.
                    * @param mapService Required if using an esri.layers.Layer as the layer parameter.
                    * @returns The constructed esri.tasks.QueryTask for the resource.
                    */
                    function getQueryTask(layer, mapService) {
                        var options = null;
                        var esriLayer = null;
                        var gcxService = null;
                        var gcxLayer = null;
                        // Find the esri layer from the input
                        if (layer instanceof esri.layers.Layer) {
                            esriLayer = layer;
                            if (mapService) {
                                gcxService = mapService;
                            }
                        }
                        else if (layer instanceof geocortex.essentials.Layer && layer.mapService && layer.mapService.serviceLayer) {
                            esriLayer = layer.mapService.serviceLayer;
                            gcxService = layer.mapService;
                            gcxLayer = layer;
                        }
                        else {
                            throw new Error("Cannot generate a QueryTask from the given parameters.");
                        }
                        if (esriLayer) {
                            var version = _getGDBVersion(esriLayer);
                            if (version) {
                                options = { "gdbVersion": version };
                            }
                        }
                        return new esri.tasks.QueryTask(taskUtils.getQueryTaskUrl(gcxLayer ? gcxLayer : esriLayer, gcxService), options);
                    }
                    taskUtils.getQueryTask = getQueryTask;
                    /**
                     * Finds the GDBVersion from an esri.layers.ArcGISDynamicMapServiceLayer or a esri.layers.FeatureLayer.
                     * @param layer The Esri Layer that is to be queried.
                     * @returns The GDBVersion if there is one or null.
                     */
                    function _getGDBVersion(layer) {
                        var version = null;
                        if (layer instanceof esri.layers.ArcGISDynamicMapServiceLayer) {
                            var serviceLayer = layer;
                            if (serviceLayer.gdbVersion) {
                                version = serviceLayer.gdbVersion;
                            }
                        }
                        else if (layer instanceof esri.layers.FeatureLayer) {
                            var serviceLayer = layer;
                            if (serviceLayer.gdbVersion) {
                                version = serviceLayer.gdbVersion;
                            }
                        }
                        return version;
                    }
                    /**
                     * Generates the LayerParameter used to generate a properly formed URL for a Dynamic Layer.
                     * @param layer An esri layer that has the ID of the dynamic layer.
                     * @param gcxLayer The Essentials Layer that contains the dynamic layer information.
                     */
                    function _generateDynamicLayerParam(layer, gcxLayer) {
                        var dynamicLayerParam = null;
                        var dynamicLayerInfo = gcxLayer.mapService.getDynamicLayerInfoById(gcxLayer.id);
                        if ((dynamicLayerInfo && dynamicLayerInfo.source) && (dynamicLayerInfo.source instanceof esri.layers.LayerDataSource || dynamicLayerInfo.source instanceof esri.layers.LayerMapSource)) {
                            // handle dynamic layer parameter here.
                            dynamicLayerParam = new LayerParameter();
                            dynamicLayerParam.source = dynamicLayerInfo.source.toJson();
                            if (dynamicLayerInfo.id) {
                                dynamicLayerParam.id = dynamicLayerInfo.id;
                            }
                            var definitionExpression = gcxLayer.getDefinitionExpression(gcxLayer.mapService.serviceLayer);
                            if (definitionExpression) {
                                dynamicLayerParam.definitionExpression = definitionExpression;
                            }
                            return dynamicLayerParam;
                        }
                        else {
                            throw new Error("A dynamic layer must have a DataSource!");
                        }
                    }
                    /**
                     * Get the service URL, or return null if we don't support identify operations for that service.
                     */
                    function getIdentifyTaskUrl(mapService) {
                        if (!mapService || !mapService.serviceUrl) {
                            return null;
                        }
                        if (mapService.mapServiceType === geocortex.essentials.MapServiceType.WMS) {
                            for (var i = 0; i < mapService.layers.length; i++) {
                                if (canIdentifyLayer(mapService.layers[i])) {
                                    // One of the sub-layers in the WMS service is identifiable.
                                    return getTokenizedUrl(mapService.url, mapService);
                                }
                            }
                            return null;
                        }
                        if (!canQueryMapService(mapService)) {
                            return null;
                        }
                        if (mapService instanceof geocortex.essentials.FeatureLayerService) {
                            // Return the URL to the underlying map service 
                            var serviceUrl = mapService.serviceUrl.substring(0, mapService.serviceUrl.lastIndexOf("/"));
                            var mapServiceUrl = serviceUrl.replace(/FeatureServer$/i, "MapServer");
                            return mapServiceUrl;
                        }
                        if (mapService.mapServiceType == geocortex.essentials.MapServiceType.DYNAMIC || mapService.mapServiceType == geocortex.essentials.MapServiceType.TILED) {
                            return getTokenizedUrl(mapService.serviceUrl, mapService);
                        }
                        return null;
                    }
                    taskUtils.getIdentifyTaskUrl = getIdentifyTaskUrl;
                    /**
                     * Gets an esri.tasks.IdentifyTask for a {@link geocortex.essentials.MapService}.
                     * @param mapService The {@link geocortex.essentials.MapService}.
                     * @returns The constructed esri.tasks.IdentifyTask for the resource.
                     */
                    function getIdentifyTask(mapService) {
                        var options = null;
                        if (mapService.serviceLayer) {
                            var version = _getGDBVersion(mapService.serviceLayer);
                            if (version) {
                                options = { "gdbVersion": version };
                            }
                        }
                        return new esri.tasks.IdentifyTask(taskUtils.getIdentifyTaskUrl(mapService), options);
                    }
                    taskUtils.getIdentifyTask = getIdentifyTask;
                    /**
                     * Takes a (presumably properly formatted) url string and associated MapService returns with an added token if needed.
                     * @param url String for the URL that is going to be used in the Task.
                     * @param mapService The MapService associated with the passed URL.
                     */
                    function getTokenizedUrl(url, mapService) {
                        if (!url) {
                            return null;
                        }
                        if (!mapService) {
                            return url;
                        }
                        // SECURITY: Since WMS MapServices use Essentials endpoints for querying/identifying and a the actual WMS endpoint for image
                        // retrieval, we must treat the token slightly different - it has to be appended here rather than associated when
                        // the MapService is created or else the WMS endpoint ends up receiving the token as well. 
                        if (mapService.mapServiceType === geocortex.essentials.MapServiceType.WMS) {
                            var token = geocortex.essentials.RestHelperHTTPService.getTokenForScope(mapService.url);
                            if (token) {
                                url += url.indexOf("?") > -1 ? "&token=" : "?token=";
                                url += encodeURIComponent(token);
                            }
                        }
                        else if (mapService.serviceToken && !/.*token=.*/.test(url)) {
                            // All MapServices that aren't WMS end up down here.
                            // We need a token and it's not yet in the url.
                            url += url.indexOf("?") > -1 ? "&token=" : "?token=";
                            url += encodeURIComponent(mapService.serviceToken);
                        }
                        return url;
                    }
                    taskUtils.getTokenizedUrl = getTokenizedUrl;
                    /**
                     * Evaluates whether a provided Layer can be identified.
                     * @param layer A Layer that is to be tested for its ability to be identified.
                     */
                    function canIdentifyLayer(layer) {
                        if (!layer) {
                            return false;
                        }
                        if (!layer.identifiable || !layer.supportsIdentify) {
                            return false;
                        }
                        return true;
                    }
                    taskUtils.canIdentifyLayer = canIdentifyLayer;
                    /**
                     * Evaluates whether a provided Layer can be queried.
                     * @param layer A Layer that is to be tested for its ability to be queried.
                     */
                    function canQueryLayer(layer) {
                        if (!layer) {
                            return false;
                        }
                        if (!layer.queryable || !layer.supportsQuery) {
                            return false;
                        }
                        return true;
                    }
                    taskUtils.canQueryLayer = canQueryLayer;
                    /**
                     * Evaluates whether a provided MapService can be queried.
                     * @param service A MapService that is to be tested for its ability to be queried.
                     */
                    function canQueryMapService(mapService) {
                        if (!mapService || !mapService.serviceLayer) {
                            return false;
                        }
                        // WMS Layers need to have all of their sub-layers checked to ensure that one layer is queryable.
                        if (mapService.mapServiceType === geocortex.essentials.MapServiceType.WMS) {
                            for (var i = 0; i < mapService.layers.length; i++) {
                                if (canQueryLayer(mapService.layers[i])) {
                                    // One of the sub-layers in the WMS service is queryable.
                                    return true;
                                }
                            }
                            // Didn't find an identifiable layer.
                            return false;
                        }
                        // A number of Esri layer types support 'capabilities', so let's just check the properties to see if it's there.
                        // Not the most type-safe, but otherwise we need to check 5+ layer types.
                        var serviceLayer = mapService.serviceLayer;
                        if (!serviceLayer.capabilities) {
                            // We don't have access to an applicable ServiceLayer - we need one with .capabilities.
                            return false;
                        }
                        if (serviceLayer.version < 10) {
                            // Capabilities not published before AGS 10, so we'll just assume true - this may result in some errors, but we can swallow them.
                            return true;
                        }
                        // Return for the ArcGISDyanmicMapServiceLayer whether we can query.
                        return serviceLayer.capabilities && serviceLayer.capabilities.indexOf("Query") >= 0;
                    }
                    taskUtils.canQueryMapService = canQueryMapService;
                    /**
                     * Creates a where clause that will search every provided fields with the search text provided.
                     * @param layer The layer to create the where clause for
                     * @param fields The fields that will be part of the where clause
                     * @param searchText The search text to use in those fields
                     * @param trace The trace object for logging purposes (optional)
                     */
                    function getSearchTextWhereClause(layer, fields, searchText, trace) {
                        if (!layer || !fields || fields.length == 0 || !searchText) {
                            return "";
                        }
                        var searchTextLower = String(searchText).toLowerCase();
                        var where = "";
                        for (var i = 0; i < fields.length; i++) {
                            var field = fields[i];
                            if (!field.searchable) {
                                continue;
                            }
                            if (field.name === "gml:id") {
                                // Can't use the ID in queries for WMS/OGC layers - it's inaccessible.
                                continue;
                            }
                            if (field.isCodedValueDomain() || field.hasSubtypeCodedValueDomains()) {
                                var codedValues = [];
                                var domain = field.getCodedValueDomain();
                                if (domain) {
                                    domain.codedValues.forEach(function (codedValue) { return codedValues.push(codedValue); });
                                }
                                // For the purposes of searching, we can combine all domain values across all subtypes.
                                var subtypeDomains = field.getSubtypeCodedValueDomains();
                                for (var typeID in subtypeDomains) {
                                    if (!subtypeDomains.hasOwnProperty(typeID)) {
                                        continue;
                                    }
                                    subtypeDomains[typeID].codedValues.forEach(function (value) { return codedValues.push(value); });
                                }
                                codedValues.forEach(function (codedValue) {
                                    if (codedValue.name.toLowerCase().indexOf(searchTextLower) > -1) {
                                        // The search text matches a resolved value of the coded domain. Add a clause to
                                        // search for the corresponding raw code.
                                        if (where.length > 0) {
                                            where += " OR ";
                                        }
                                        if (field.type === geocortex.essentials.EsriFieldTypes.esriFieldTypeString) {
                                            where += encodeURI(field.name) + " = '" + codedValue.code.replace("'", "''") + "'";
                                        }
                                        else {
                                            where += encodeURI(field.name) + " = " + codedValue.code;
                                        }
                                    }
                                });
                                continue;
                            }
                            switch (field.type) {
                                case geocortex.essentials.EsriFieldTypes.esriFieldTypeString:
                                    if (where.length > 0) {
                                        where += " OR ";
                                    }
                                    // Essentials' SQL translation thingies doesn't take kindly to LOWER()'s kind when we're dealing with WMS layers...
                                    if (layer.mapService.serviceLayer instanceof esri.layers.WMSLayer) {
                                        where += encodeURI(field.name) + " LIKE '%" + searchText.replace("'", "''") + "%'";
                                    }
                                    else {
                                        where += "LOWER(" + field.name + ") LIKE '%" + searchTextLower.replace("'", "''") + "%'";
                                    }
                                    break;
                                case geocortex.essentials.EsriFieldTypes.esriFieldTypeSmallInteger:
                                case geocortex.essentials.EsriFieldTypes.esriFieldTypeInteger:
                                case geocortex.essentials.EsriFieldTypes.esriFieldTypeOID:
                                case geocortex.essentials.EsriFieldTypes.esriFieldTypeSingle:
                                case geocortex.essentials.EsriFieldTypes.esriFieldTypeDouble:
                                    // GVH-10576: We need to restrict the formats that we recognize here, otherwise a string like "abc123"
                                    // is parsed as the number 123, which isn't what we want to search for. 
                                    var numberFormats = [
                                        infrastructure.NumberFormat.ACCOUNTING,
                                        infrastructure.NumberFormat.CURRENCY,
                                        infrastructure.NumberFormat.FIXED_POINT,
                                        infrastructure.NumberFormat.NUMBER,
                                        infrastructure.NumberFormat.PERCENT,
                                        infrastructure.NumberFormat.ROUND_TRIP
                                    ];
                                    var num = infrastructure.FormatUtils.parseNumber(searchText, numberFormats);
                                    if (isNaN(num)) {
                                        // The input isn't a number, so can't match this field.
                                        break;
                                    }
                                    if (where.length > 0) {
                                        where += " OR ";
                                    }
                                    // Produce a range of values to search. For example, if the user typed "12.33", search
                                    // between 12.33 and 12.34 so that a value like 12.333 is a match.
                                    var invariantNum = infrastructure.FormatUtils.formatNumber(num, infrastructure.NumberFormat.ROUND_TRIP);
                                    var epsilon;
                                    if (invariantNum.indexOf(".")) {
                                        var numFractionalDigits = invariantNum.length - invariantNum.indexOf(".") - 1;
                                        epsilon = Math.pow(10, -numFractionalDigits);
                                    }
                                    else {
                                        epsilon = 1;
                                    }
                                    var lowerBound, upperBound;
                                    if (num < 0) {
                                        lowerBound = infrastructure.FormatUtils.formatNumber(num - epsilon, infrastructure.NumberFormat.ROUND_TRIP);
                                        upperBound = invariantNum;
                                    }
                                    else {
                                        lowerBound = invariantNum;
                                        upperBound = infrastructure.FormatUtils.formatNumber(num + epsilon, infrastructure.NumberFormat.ROUND_TRIP);
                                    }
                                    where += "(" + encodeURI(field.name.toLowerCase()) + " <= " + upperBound + " AND " + encodeURI(field.name.toLowerCase()) + " >= " + lowerBound + ")";
                                    break;
                                case geocortex.essentials.EsriFieldTypes.esriFieldTypeDate:
                                    // Oh god what format would we even search it in?
                                    break;
                                case geocortex.essentials.EsriFieldTypes.esriFieldTypeGlobalID: // GVH-3692
                                case geocortex.essentials.EsriFieldTypes.esriFieldTypeBlob:
                                    // Ignore
                                    break;
                                default:
                                    if (trace) {
                                        trace.warning("Unhandled layer data type: '{0}'. Field '{1}' in layer '{2}' has been excluded from search.".format(field.type, field.alias, layer.displayName));
                                    }
                            }
                        }
                        // The defintionExpression is not respected in dynamic layers when defining the layer param.
                        // A definition expression may also have been set manually on feature layers.
                        var defExp = layer.getDefinitionExpression(layer.mapService.serviceLayer);
                        if (defExp) {
                            where = "(" + where + ")" + " AND (" + defExp + ")";
                        }
                        return where;
                    }
                    taskUtils.getSearchTextWhereClause = getSearchTextWhereClause;
                })(taskUtils = infrastructure.taskUtils || (infrastructure.taskUtils = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/framework.d.ts"/>
/// <reference path="../../CommandViewModel.ts"/>
/// <reference path=".././ToolbarGroupRegistry.ts"/>
/// <reference path="../../../Viewer.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var toolbarGroup;
                (function (toolbarGroup) {
                    (function (ToggleButtonState) {
                        ToggleButtonState[ToggleButtonState["TOGGLE_BUTTON_OFF"] = 0] = "TOGGLE_BUTTON_OFF";
                        ToggleButtonState[ToggleButtonState["TOGGLE_BUTTON_ON"] = 1] = "TOGGLE_BUTTON_ON";
                    })(toolbarGroup.ToggleButtonState || (toolbarGroup.ToggleButtonState = {}));
                    var ToggleButtonState = toolbarGroup.ToggleButtonState;
                    var ToolbarToggleButton = (function (_super) {
                        __extends(ToolbarToggleButton, _super);
                        function ToolbarToggleButton(app, libraryId, entry) {
                            var _this = this;
                            _super.call(this, app, libraryId, entry);
                            this.state = new Observable(null);
                            this.toggleButtonEntry = entry;
                            this.toggleOnCommand = new infrastructure.CommandViewModel(this.app, libraryId, entry.toggleOn.command, entry.toggleOn.commandParameter);
                            this.toggleOffCommand = new infrastructure.CommandViewModel(this.app, libraryId, entry.toggleOff.command, entry.toggleOff.commandParameter);
                            this.isToggledOn = new Observable(false);
                            this.iconUri = new Observable(null);
                            this.state.bind(this, function (value) { return _this.setState(value); });
                            // Check to see whether the toggle button's state will be controlled by the state manager or the canExecutes of the associated commands.
                            if (this.toggleButtonEntry.toggleStateName && this.toggleButtonEntry.toggleStateName !== "") {
                                // State is dictated by the state manager.
                                // Set up the events that will manage the state according to the state manager.
                                this.app.event("StateEnteredEvent").subscribe(this, function (args) {
                                    if (args.stateDefinition.name === _this.toggleButtonEntry.toggleStateName) {
                                        _this.state.set(ToggleButtonState.TOGGLE_BUTTON_ON);
                                    }
                                    if (!_this.isToggledOn.get()) {
                                        return;
                                    }
                                    if (args.stateDefinition.name === "TransientActiveState") {
                                        _this.activeTransient.set(true);
                                    }
                                });
                                this.app.event("StateExitedEvent").subscribe(this, function (args) {
                                    if (args.stateDefinition.name === _this.toggleButtonEntry.toggleStateName) {
                                        _this.state.set(ToggleButtonState.TOGGLE_BUTTON_OFF);
                                    }
                                    if (args.stateDefinition.name === "TransientActiveState") {
                                        _this.activeTransient.set(false);
                                    }
                                });
                            }
                            else {
                                // No state associated, use canExecutes of commands to determine state.
                                this._setUpBindings();
                            }
                            // BETA-25: If the site is not initialized yet, we'll need to raise the canExecuteChanged for this command once it is.
                            if (!this.app.site || !this.app.site.isInitialized) {
                                this.app.event("SiteInitializedEvent").once(this, function () {
                                    _this.toggleOffCommand.commandName && _this.app.command(_this.toggleOffCommand.commandName).raiseCanExecuteChanged();
                                    _this.toggleOnCommand.commandName && _this.app.command(_this.toggleOnCommand.commandName).raiseCanExecuteChanged();
                                    // This is needed for when we're running without binding to the canExecutes as whether the button is disabled is still managed by them.
                                    if (_this.state.get() === ToggleButtonState.TOGGLE_BUTTON_OFF) {
                                        _this.disabled.set(!_this.toggleOffCommand.canExecute.get());
                                    }
                                    else {
                                        _this.disabled.set(!_this.toggleOnCommand.canExecute.get());
                                    }
                                });
                            }
                            // Check to see if the corresponding state is currently active.
                            if (entry.toggleStateName && this.app.stateManager.isCurrentlyActive(entry.toggleStateName)) {
                                this.state.set(ToggleButtonState.TOGGLE_BUTTON_ON);
                            }
                            else {
                                // Default.
                                this.state.set(ToggleButtonState.TOGGLE_BUTTON_OFF);
                            }
                        }
                        ToolbarToggleButton.prototype.execute = function () {
                            // Execute the current command
                            if (this.command && this.command.commandName) {
                                if (this.command.commandParameter) {
                                    this.app.commandRegistry.command(this.command.commandName).execute(this.command.commandParameter);
                                }
                                else {
                                    this.app.commandRegistry.command(this.command.commandName).execute();
                                }
                            }
                            // Our command post execute functions will automatically set the button state for the next command - if we are not listening to state.
                        };
                        ToolbarToggleButton.prototype.setState = function (state) {
                            if (state === ToggleButtonState.TOGGLE_BUTTON_OFF) {
                                var name = this.toggleButtonEntry.toggleOn.name || this.toggleButtonEntry.name || "";
                                var iconUri = this.toggleButtonEntry.toggleOn.iconUri || this.toggleButtonEntry.iconUri || null;
                                var tooltip = this.toggleButtonEntry.toggleOn.tooltip || this.toggleButtonEntry.tooltip || null;
                                var hideOnDisable = this.toggleButtonEntry.toggleOn.hideOnDisable != undefined ? !!this.toggleButtonEntry.toggleOn.hideOnDisable : !!this.toggleButtonEntry.hideOnDisable;
                                var isToggledOn = false;
                            }
                            else {
                                var name = this.toggleButtonEntry.toggleOff.name || this.toggleButtonEntry.name || "";
                                var iconUri = this.toggleButtonEntry.toggleOff.iconUri || this.toggleButtonEntry.iconUri || null;
                                var tooltip = this.toggleButtonEntry.toggleOff.tooltip || this.toggleButtonEntry.tooltip || null;
                                var hideOnDisable = this.toggleButtonEntry.toggleOff.hideOnDisable != undefined ? !!this.toggleButtonEntry.toggleOff.hideOnDisable : !!this.toggleButtonEntry.hideOnDisable;
                                var isToggledOn = true;
                            }
                            this.name.set(name);
                            this.isToggledOn.set(isToggledOn);
                            this.iconUri.set(iconUri);
                            this.tooltip.set(tooltip);
                            this.command = state === ToggleButtonState.TOGGLE_BUTTON_OFF ? this.toggleOnCommand : this.toggleOffCommand;
                            this.disabled.set(!this.command.canExecute.get());
                            this.hideOnDisable.set(hideOnDisable);
                            this.setHidden();
                            this.app.event("ToggleButtonStateChangedEvent").publish({
                                toggleButtonEntry: this.toggleButtonEntry,
                                state: state
                            });
                        };
                        ToolbarToggleButton.prototype.onDestroy = function () {
                            this._disconnectBindings();
                        };
                        ToolbarToggleButton.prototype._setUpBindings = function () {
                            var _this = this;
                            this._toggleOnCommandCanExecuteBindingToken = this.toggleOnCommand.canExecute.bind(this, function (state) { return _this._handleCommandCanExecuteChanged(_this.toggleOnCommand, state); });
                            this._toggleOnCommandPostExecSubscriptionToken = this.app.command(this.toggleButtonEntry.toggleOn.command).postExecute.subscribe(this, this._handleToggleOnCommandPostExecute);
                            this._toggleOffCommandCanExecuteBindingToken = this.toggleOffCommand.canExecute.bind(this, function (state) { return _this._handleCommandCanExecuteChanged(_this.toggleOffCommand, state); });
                            this._toggleOffCommandPostExecSubscriptionToken = this.app.command(this.toggleButtonEntry.toggleOff.command).postExecute.subscribe(this, this._handleToggleOffCommandPostExecute);
                        };
                        ToolbarToggleButton.prototype._disconnectBindings = function () {
                            this.toggleOnCommand.canExecute.unbind(this._toggleOnCommandCanExecuteBindingToken);
                            this.app.command(this.toggleButtonEntry.toggleOn.command).postExecute.unsubscribe(this._toggleOnCommandPostExecSubscriptionToken);
                            this.toggleOffCommand.canExecute.unbind(this._toggleOffCommandCanExecuteBindingToken);
                            this.app.command(this.toggleButtonEntry.toggleOff.command).postExecute.unsubscribe(this._toggleOffCommandPostExecSubscriptionToken);
                        };
                        ToolbarToggleButton.prototype._handleToggleOnCommandPostExecute = function (commandParameter) {
                            if (commandParameter && this.command.commandParameter !== commandParameter) {
                                return;
                            }
                            if (this.state.get() === ToggleButtonState.TOGGLE_BUTTON_ON) {
                                return;
                            }
                            this.state.set(ToggleButtonState.TOGGLE_BUTTON_ON);
                        };
                        ToolbarToggleButton.prototype._handleToggleOffCommandPostExecute = function (commandParameter) {
                            if (commandParameter && this.command.commandParameter !== commandParameter) {
                                return;
                            }
                            if (this.state.get() === ToggleButtonState.TOGGLE_BUTTON_OFF) {
                                return;
                            }
                            this.state.set(ToggleButtonState.TOGGLE_BUTTON_OFF);
                        };
                        ToolbarToggleButton.prototype._handleCommandCanExecuteChanged = function (source, state) {
                            if (this.command === source) {
                                this.disabled.set(!state);
                                this.setHidden();
                            }
                        };
                        return ToolbarToggleButton;
                    }(toolbarGroup.ToolbarGroupItemBase));
                    toolbarGroup.ToolbarToggleButton = ToolbarToggleButton;
                })(toolbarGroup = infrastructure.toolbarGroup || (infrastructure.toolbarGroup = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/framework.d.ts"/>
/// <reference path="../../CommandViewModel.ts"/>
/// <reference path=".././ToolbarGroupRegistry.ts"/>
/// <reference path="../../../Viewer.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var toolbarGroup;
                (function (toolbarGroup) {
                    var ToolbarGroup = (function (_super) {
                        __extends(ToolbarGroup, _super);
                        function ToolbarGroup(app, libraryId, entry) {
                            var _this = this;
                            _super.call(this, app, libraryId, entry);
                            if (entry.layout && entry.layout.toLowerCase() === "small") {
                                this.hasSmallLayout.set(true);
                            }
                            this.items = new ObservableCollection();
                            for (var i = 0; i < entry.items.length; i++) {
                                var item = this.getToolbarItemType(entry.items[i]);
                                if (item) {
                                    this.items.addItem(item);
                                }
                            }
                            this.disabled.set(this.areAllHidden(this.items));
                            this.setHidden();
                            this.disabled.bind(this, function (args) {
                                _this.setHidden();
                            });
                        }
                        ToolbarGroup.prototype.getToolbarItemType = function (item) {
                            var toolbarGroupItem = null;
                            if (item.type == "button") {
                                return new geocortex.essentialsHtmlViewer.mapping.infrastructure.toolbarGroup.ToolbarButton(this.app, this.libraryId, item);
                            }
                            else if (item.type == "toggleButton") {
                                return new geocortex.essentialsHtmlViewer.mapping.infrastructure.toolbarGroup.ToolbarToggleButton(this.app, this.libraryId, item);
                            }
                            else if (item.type == "region") {
                                return new geocortex.essentialsHtmlViewer.mapping.infrastructure.toolbarGroup.ToolbarRegion(this.app, this.libraryId, item);
                            }
                            else if (item.type == "tool") {
                                return new geocortex.essentialsHtmlViewer.mapping.infrastructure.toolbarGroup.ToolbarTool(this.app, this.libraryId, item);
                            }
                            else if (item.type == "toolbarGroup") {
                                return new geocortex.essentialsHtmlViewer.mapping.infrastructure.toolbarGroup.ToolbarGroup(this.app, this.libraryId, item);
                            }
                            else if (item.type == "flyout") {
                                return new geocortex.essentialsHtmlViewer.mapping.infrastructure.toolbarGroup.ToolbarFlyout(this.app, this.libraryId, item);
                            }
                        };
                        return ToolbarGroup;
                    }(toolbarGroup.ToolbarGroupItemBase));
                    toolbarGroup.ToolbarGroup = ToolbarGroup;
                })(toolbarGroup = infrastructure.toolbarGroup || (infrastructure.toolbarGroup = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/framework.d.ts"/>
/// <reference path="../../CommandViewModel.ts"/>
/// <reference path=".././ToolbarGroupRegistry.ts"/>
/// <reference path="toolbargroup.ts" />
/// <reference path="../../../Viewer.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var toolbarGroup;
                (function (toolbarGroup) {
                    var ToolbarFlyout = (function (_super) {
                        __extends(ToolbarFlyout, _super);
                        function ToolbarFlyout(app, libraryId, entry) {
                            var _this = this;
                            _super.call(this, app, libraryId, entry);
                            this.flyoutButtonDescription = new Observable("");
                            // Set the first item to be selected.
                            this.selectedTool.set(this.items.getAt(0));
                            this.flyoutButtonDescription.set(this.app.getResource(this.libraryId, "language-toolbar-flyout-description").format(this.name.get()));
                            // If a tool within the flyout is activated we want it to become the selected tool.
                            this.app.event("ActiveToolChangedEvent").subscribe(this, function (args) {
                                var valid = _this.items.get().filter(function (currentToolItemBase) { return _this._seeIfActiveToolIsInFlyout(currentToolItemBase, args); });
                                if (valid.length > 0) {
                                    _this.selectedTool.set(valid[0]);
                                }
                            });
                        }
                        ToolbarFlyout.prototype._seeIfActiveToolIsInFlyout = function (currentToolItemBase, args) {
                            if (!(currentToolItemBase.tool instanceof infrastructure.tools.MapTool)) {
                                return false;
                            }
                            var currentTool = currentToolItemBase.tool;
                            if (args.tool instanceof infrastructure.tools.MapTool) {
                                var testedTool = args.tool;
                                return currentTool.command === testedTool.command && currentTool.drawMode === testedTool.drawMode;
                            }
                            return false;
                        };
                        ToolbarFlyout.prototype.toggleFlyout = function () {
                            this.toolChangeActive.set(!this.toolChangeActive.get());
                        };
                        ToolbarFlyout.prototype.switchActiveFlyoutTool = function (ctx) {
                            if (ctx.type === "tool") {
                                this.selectedTool.set(ctx);
                            }
                            ctx.execute();
                        };
                        ToolbarFlyout.prototype.getToolbarItemType = function (item) {
                            var toolbarGroupItem = null;
                            if (item.type == "button") {
                                return new geocortex.essentialsHtmlViewer.mapping.infrastructure.toolbarGroup.ToolbarButton(this.app, this.libraryId, item);
                            }
                            else if (item.type == "toggleButton") {
                                return new geocortex.essentialsHtmlViewer.mapping.infrastructure.toolbarGroup.ToolbarToggleButton(this.app, this.libraryId, item);
                            }
                            else if (item.type == "region") {
                                return new geocortex.essentialsHtmlViewer.mapping.infrastructure.toolbarGroup.ToolbarRegion(this.app, this.libraryId, item);
                            }
                            else if (item.type == "tool") {
                                return new geocortex.essentialsHtmlViewer.mapping.infrastructure.toolbarGroup.ToolbarTool(this.app, this.libraryId, item);
                            }
                            else if (item.type == "toolbarGroup") {
                                return new geocortex.essentialsHtmlViewer.mapping.infrastructure.toolbarGroup.ToolbarGroup(this.app, this.libraryId, item);
                            }
                            return null;
                        };
                        return ToolbarFlyout;
                    }(toolbarGroup.ToolbarGroup));
                    toolbarGroup.ToolbarFlyout = ToolbarFlyout;
                })(toolbarGroup = infrastructure.toolbarGroup || (infrastructure.toolbarGroup = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/framework.d.ts"/>
/// <reference path="../../CommandViewModel.ts"/>
/// <reference path=".././ToolbarGroupRegistry.ts"/>
/// <reference path="../../../Viewer.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var toolbarGroup;
                (function (toolbarGroup) {
                    var ToolbarButton = (function (_super) {
                        __extends(ToolbarButton, _super);
                        function ToolbarButton(app, libraryId, entry) {
                            var _this = this;
                            _super.call(this, app, libraryId, entry);
                            var commandName = entry.command;
                            var commandParameter = entry.commandParameter;
                            this.command = new mapping.modules.command.CommandViewModel(this.app, undefined, commandName, commandParameter);
                            this.disabled.set(!this.command.canExecute.get());
                            this.setHidden();
                            this.command.canExecute.bind(this, function (args) {
                                _this.disabled.set(!args);
                                _this.setHidden();
                            });
                            this.iconUri = new Observable(entry.iconUri);
                            // BETA-25: If the site is not initialized yet, we'll need to raise the canExecuteChanged for this command once it is.
                            if (!this.app.site || !this.app.site.isInitialized) {
                                this.app.event("SiteInitializedEvent").once(this, this._raiseCommandCanExecuteChanged);
                            }
                        }
                        ToolbarButton.prototype.execute = function () {
                            if (this.command && this.command.commandName) {
                                if (this.command.commandParameter) {
                                    this.app.commandRegistry.command(this.command.commandName).execute(this.command.commandParameter);
                                }
                                else {
                                    this.app.commandRegistry.command(this.command.commandName).execute();
                                }
                            }
                            var eventArgs = {
                                commandName: this.command.commandName,
                                commandParameter: this.command.commandParameter,
                                id: this.id,
                                name: this.name.get(),
                                libraryId: this.libraryId
                            };
                            this.app.event("ToolbarButtonClickedEvent").publish(eventArgs);
                        };
                        ToolbarButton.prototype._raiseCommandCanExecuteChanged = function () {
                            this.command.commandName && this.app.command(this.command.commandName).raiseCanExecuteChanged();
                        };
                        return ToolbarButton;
                    }(toolbarGroup.ToolbarGroupItemBase));
                    toolbarGroup.ToolbarButton = ToolbarButton;
                })(toolbarGroup = infrastructure.toolbarGroup || (infrastructure.toolbarGroup = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/framework.d.ts"/>
/// <reference path="../../CommandViewModel.ts"/>
/// <reference path=".././ToolbarGroupRegistry.ts"/>
/// <reference path="../../../Viewer.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var toolbarGroup;
                (function (toolbarGroup) {
                    var ToolbarRegion = (function (_super) {
                        __extends(ToolbarRegion, _super);
                        function ToolbarRegion(app, libraryId, entry) {
                            _super.call(this, app, libraryId, entry);
                            this.regionName = entry.regionName;
                        }
                        return ToolbarRegion;
                    }(toolbarGroup.ToolbarGroupItemBase));
                    toolbarGroup.ToolbarRegion = ToolbarRegion;
                })(toolbarGroup = infrastructure.toolbarGroup || (infrastructure.toolbarGroup = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/framework.d.ts"/>
/// <reference path="../../CommandViewModel.ts"/>
/// <reference path=".././ToolbarGroupRegistry.ts"/>
/// <reference path="../../../Viewer.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var toolbarGroup;
                (function (toolbarGroup) {
                    var ToolbarTool = (function (_super) {
                        __extends(ToolbarTool, _super);
                        function ToolbarTool(app, libraryId, entry) {
                            var _this = this;
                            _super.call(this, app, libraryId, entry);
                            if (!entry) {
                                return;
                            }
                            // Work around the bug where two tools with same name crashes the toolbar
                            var config = {};
                            for (var prop in entry) {
                                if (!prop) {
                                    break;
                                }
                                config[prop] = entry[prop];
                            }
                            config["name"] = entry["id"];
                            var formattedConfig = [];
                            formattedConfig.push(config);
                            // GVH-6422: Modules with commands that don't use the standard MapTool can register any tool type using the 'registerToolTypeForCommand' function of the tool registry. This
                            // means that we'll have to wait for all libraries and their modules to load in order to ensure we're using the correct tool type, before initializing the tool.
                            if (this.app.allLibrariesLoaded) {
                                this._initializeTool(formattedConfig);
                            }
                            else {
                                this.disabled.set(true);
                                this.setHidden();
                                this.app.event("ViewerLibrariesDownloadedEvent").once(this, function () {
                                    _this.disabled.set(false);
                                    _this.setHidden();
                                    _this._initializeTool(formattedConfig);
                                });
                            }
                            this.isActive.set(false);
                            this.iconUri = new Observable(entry.iconUri);
                            // Listen to State changes so we know whether the transient should be active for this or not.
                            this.app.event("StateEnteredEvent").subscribe(this, function (args) {
                                if (!_this.isActive.get()) {
                                    return;
                                }
                                if (args.stateDefinition.name === "TransientActiveState") {
                                    _this.activeTransient.set(true);
                                }
                            });
                            this.app.event("StateExitedEvent").subscribe(this, function (args) {
                                if (args.stateDefinition.name === "TransientActiveState") {
                                    _this.activeTransient.set(false);
                                }
                            });
                        }
                        ToolbarTool.prototype.execute = function () {
                            if (this.isActive.get() || this.tool.isActive) {
                                // Toggle tool's activation on click event
                                this.app.commandRegistry.command("ClearActiveTool").execute();
                            }
                            else if (!this.tool.enabled || this.tool.enabled.get()) {
                                // The id seems to come from a mixin to the constructor :(
                                this.app.commandRegistry.command("SetActiveTool").execute(this.tool.id);
                            }
                        };
                        ToolbarTool.prototype._initializeTool = function (formattedConfig) {
                            var _this = this;
                            this.tool = this.app.toolRegistry.createTools(formattedConfig, true)[0];
                            if (!this.tool) {
                                this.disabled.set(true);
                                this.setHidden();
                            }
                            else if (this.tool.enabled) {
                                this.disabled.set(!this.tool.enabled.get());
                                this.setHidden();
                                this.tool.enabled.bind(this, function (enabled) {
                                    _this.disabled.set(!enabled);
                                    _this.setHidden();
                                    if (!enabled && (_this.isActive.get() || _this.tool.isActive)) {
                                        _this.app.commandRegistry.command("ClearActiveTool").execute();
                                    }
                                });
                            }
                        };
                        return ToolbarTool;
                    }(toolbarGroup.ToolbarGroupItemBase));
                    toolbarGroup.ToolbarTool = ToolbarTool;
                })(toolbarGroup = infrastructure.toolbarGroup || (infrastructure.toolbarGroup = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/dojo.d.ts" />
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="./ToolBase.ts"/>
/// <reference path="../../Viewer.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var tools;
                (function (tools) {
                    var MapTool = (function (_super) {
                        __extends(MapTool, _super);
                        /**
                         * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.tools.MapTool} class.
                         * @class
                         * <p>MapTool provides a general purpose, loosely coupled model for creating components that require map interaction.</p>
                         * @constructs
                         * @memberOf geocortex.essentialsHtmlViewer.mapping.infrastructure.tools
                         * @param app The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this tool belongs to.
                         * @param mixin An object to provide additional configuration of this tool.
                         */
                        function MapTool(app, mixin) {
                            _super.call(this, app, mixin);
                            /**
                             * The activate state of the Esri drawing surface.
                             * The Esri drawing surface does not provide an indication of whether it is active or not. We'll keep
                             * track of this state ourselves so that we don't call deactivate unnecessarily.
                             */
                            this._drawIsActive = false;
                            /**
                             * @private: Handler Tokens
                             */
                            this._drawEndHandlerToken = null;
                            this._inputMethodChangeHandle = null;
                            /**
                             * @private: Handle to map hover for auto panning.
                             */
                            this._mapMouseHoverToken = null;
                            /**
                             * @private: Handle to map right-click to auto-deactivate the tool.
                             */
                            this._mapMouseDownToken = null;
                            /**
                             * @private: Pixel area from edge of map to trigger auto pan.
                             */
                            this._autoPanPixelTolerance = 15;
                            /**
                             * @private: Percentage of map to pan when triggering auto pan.
                             */
                            this._autoPanStep = 1.0 / 3.0;
                            /**
                             * @private: Draw modes which don't support auto panning.
                             */
                            this._unsupportedAutoPanDrawModes = ["FREEHAND_POLYGON", "FREEHAND_POLYLINE", "POINT", "MULTI_POINT"];
                            /**
                             * @private: Whether the tool's draw end handler is suspended (see GVH-4732)
                             */
                            this._drawEndSuspended = false;
                        }
                        MapTool.prototype._createDrawObject = function () {
                            // Setup the drawing surface
                            // TODO load symbol styles/colors from an external resource
                            this._drawObject = this.app.accessibilityManager.createComponent("geocortex.accessibility.draw", this.app.map);
                            this._drawObject.setMarkerSymbol(new esri.symbol.SimpleMarkerSymbol(esri.symbol.SimpleMarkerSymbol.STYLE_CIRCLE, 10, new esri.symbol.SimpleLineSymbol(esri.symbol.SimpleLineSymbol.STYLE_SOLID, new esri.Color([0, 0, 0, 0.8]), 2), new esri.Color([0, 0, 0, 0.8])));
                            this._drawObject.setFillSymbol(new esri.symbol.SimpleFillSymbol(esri.symbol.SimpleFillSymbol.STYLE_SOLID, new esri.symbol.SimpleLineSymbol(esri.symbol.SimpleLineSymbol.STYLE_SOLID, new esri.Color([0, 0, 0, 0.8]), 2), new esri.Color([0, 0, 0, 0.25])));
                            this._drawObject.setLineSymbol(new esri.symbol.SimpleLineSymbol(esri.symbol.SimpleLineSymbol.STYLE_SOLID, new esri.Color([0, 0, 0, 0.8]), 2));
                        };
                        MapTool.prototype._activateToolbar = function () {
                            if (!this._drawObject) {
                                this._createDrawObject();
                            }
                            // Subscribe to the onDrawEnd event
                            if (!this._drawEndHandlerToken) {
                                this._drawEndHandlerToken = dojo.aspect.after(this._drawObject, "onDrawEnd", dojo.hitch(this, "onDrawEnd"), true);
                            }
                            // Subscribe to onInputMethodChange event
                            if (this._drawObject instanceof geocortex.essentialsHtmlViewer.mapping.infrastructure.accessibility.Draw) {
                                this._inputMethodChangeHandle = dojo.aspect.after(this._drawObject, "onInputMethodChange", dojo.hitch(this, "onInputMethodChange"), true);
                            }
                            // Activate the drawing surface with the specified mode
                            this._drawObject.activate(esri.toolbars.Draw[this.drawMode]);
                            this._drawIsActive = true;
                            this._drawEndSuspended = false;
                        };
                        /**
                         * Deactivates the drawing surface
                         * @private
                         */
                        MapTool.prototype._deactivateToolbar = function () {
                            if (this._drawEndHandlerToken) {
                                this._drawEndHandlerToken.remove();
                                this._drawEndHandlerToken = null;
                            }
                            if (this._inputMethodChangeHandle) {
                                this._inputMethodChangeHandle.remove();
                                this._inputMethodChangeHandle = null;
                            }
                            if (this._drawObject && this._drawIsActive) {
                                this._drawObject.deactivate();
                                this._drawIsActive = false;
                                this._drawEndSuspended = false;
                            }
                        };
                        /**
                         * Called when the tool is activated.
                         */
                        MapTool.prototype.onActivated = function () {
                            if (!this._drawObject) {
                                this._createDrawObject();
                            }
                            if (this._drawIsActive) {
                                this._deactivateToolbar();
                            }
                            if (this.drawMode == "CURRENT_EXTENT") {
                                // Complete immediately with the current map extent
                                this.onDrawEnd(this.app.map.extent);
                            }
                            else {
                                // Note: If map.graphics is null here (as is the case when MapServices fail to load), don't bother - the Draw operation will bomb.
                                if (!this.app.map.graphics) {
                                    return;
                                }
                                // Make sure to show the map (and the focus is set) before activating the Draw tools
                                this.app.command("ShowMap").execute();
                                this._activateToolbar();
                            }
                            this._mapMouseDownToken = this.app.event("MapMouseDownEvent").subscribe(this, this.onMapMouseDown);
                            this._mapMouseHoverToken = this.app.event("MapMouseHoverEvent").subscribe(this, this.onMapMouseHover);
                        };
                        /**
                         * Called when the tool is deactivated.
                         */
                        MapTool.prototype.onDeactivated = function () {
                            if (this._mapMouseHoverToken) {
                                this.app.event("MapMouseHoverEvent").unsubscribe(this._mapMouseHoverToken);
                                this._mapMouseHoverToken = null;
                            }
                            if (this._mapMouseDownToken) {
                                this.app.event("MapMouseDownEvent").unsubscribe(this._mapMouseDownToken);
                                this._mapMouseDownToken = null;
                            }
                            this._deactivateToolbar();
                            // Place focus on the map to allow for better flow w/ keyboard accessibility.
                            this.app.command("ShowMap").execute();
                        };
                        /**
                         * Called when drawing completes.
                         */
                        MapTool.prototype.onDrawEnd = function (geometry) {
                            var _this = this;
                            if (this._drawEndSuspended) {
                                return;
                            }
                            // Fire the tool's command
                            if (this.command) {
                                var cmd = this.app.command(this.command);
                                if (cmd.canExecute(geometry)) {
                                    cmd.execute(geometry);
                                    this.app.command("LogOptimizerEvent").execute(this.name, this.command);
                                }
                                else {
                                    this.app.trace.warning("Could not invoke command '{0}' for tool '{1}'.".format(this.command, this.name));
                                }
                            }
                            // Note: Removed previous fix for GVH-3135 - since we now guard against esri firing and extra click on draw-end. See GVH-3523.
                            if (!this.isSticky) {
                                this.setActive(false);
                            }
                            else {
                                // Toolbar is deactivated/reactivated to fix a bug w/ esri's API on Safari iOS that causes a click to be fired immediately after
                                // a drawEnd event when the drawing is < 10px or so from the origin of the touch event.
                                this._drawEndSuspended = true;
                                // Capture any immediate clicks to prevent iOS Safari from drawing two pieces of markup.
                                // If the event handler isn't run within 100ms let's discard it and enable the toolbar.
                                setTimeout(function () { return _this._drawEndSuspended = false; }, 100);
                            }
                        };
                        /**
                         * Called when the input method (e.g. keyboard, mouse) for the drawing component has changed.
                         */
                        MapTool.prototype.onInputMethodChange = function (result) {
                            var eventArgs = {
                                tool: this,
                                previousMethod: result ? result.previousMethod : null,
                                newMethod: result ? result.newMethod : null
                            };
                            this.app.event("ToolInputMethodChangedEvent").publish(eventArgs);
                        };
                        MapTool.prototype.onMapMouseDown = function (evt) {
                            // Detect right-click on the map and clean-up the draw
                            if (evt.which === 3) {
                                if (this._drawObject) {
                                    // Clean up
                                    this.app.command("ClearActiveTool").execute();
                                    this._deactivateToolbar();
                                    this.app.command("RemoveStatus").execute();
                                }
                            }
                        };
                        MapTool.prototype.onMapMouseHover = function (mouseHoverCoords) {
                            if (this._drawObject == null || !this._drawIsActive || this._unsupportedAutoPanDrawModes.indexOf(this.drawMode) >= 0) {
                                return;
                            }
                            // Expecting {clientY, clientY} mouse hover coordinates
                            if (!mouseHoverCoords.hasOwnProperty("clientX") || !mouseHoverCoords.hasOwnProperty("clientY")) {
                                return;
                            }
                            var mapOffset = $(this.app.map.root).offset();
                            if (mouseHoverCoords.clientX < mapOffset.left + this._autoPanPixelTolerance) {
                                this.app.command("PanLeft").execute(this._autoPanStep);
                            }
                            else if (mapOffset.left + this.app.map.width - this._autoPanPixelTolerance < mouseHoverCoords.clientX) {
                                this.app.command("PanRight").execute(this._autoPanStep);
                            }
                            else if (mouseHoverCoords.clientY < mapOffset.top + this._autoPanPixelTolerance) {
                                this.app.command("PanUp").execute(this._autoPanStep);
                            }
                            else if (mapOffset.top + this.app.map.height - this._autoPanPixelTolerance < mouseHoverCoords.clientY) {
                                this.app.command("PanDown").execute(this._autoPanStep);
                            }
                        };
                        return MapTool;
                    }(tools.ToolBase));
                    tools.MapTool = MapTool;
                    MapTool.prototype.command = null;
                    MapTool.prototype.drawMode = null;
                    MapTool.prototype.isSticky = false;
                })(tools = infrastructure.tools || (infrastructure.tools = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="./MapTool.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var tools;
                (function (tools) {
                    /**
                     * An extension of MapTool that implements ToolBase's ```enabled: Observable<boolean>``` by calling
                     * the command's canExecute with no arguments.  This is playing fast and loose with what 'canExecute'
                     * means because of course the command can't actually execute without the geometry input.  However
                     * we don't have that geometry until after the tool executes so it's a chicken and egg problem.
                     * This functionality is not in MapTool because not all Commands do (should?) follow this convention.
                     */
                    var DisablingMapTool = (function (_super) {
                        __extends(DisablingMapTool, _super);
                        function DisablingMapTool(app, mixin) {
                            var _this = this;
                            _super.call(this, app, mixin);
                            this.enabled = new Observable(true);
                            if (mixin.command) {
                                var command = app.command(mixin.command);
                                this.enabled.set(command.canExecute());
                                command.canExecuteChanged.subscribe(this, function () {
                                    var canExecute = command.canExecute();
                                    if (!canExecute && _this.isActive) {
                                        _this.setActive(false);
                                    }
                                    _this.enabled.set(canExecute);
                                });
                            }
                        }
                        return DisablingMapTool;
                    }(tools.MapTool));
                    tools.DisablingMapTool = DisablingMapTool;
                })(tools = infrastructure.tools || (infrastructure.tools = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var featureDetails;
                (function (featureDetails) {
                    var FeatureProviderBase = (function (_super) {
                        __extends(FeatureProviderBase, _super);
                        function FeatureProviderBase(app, libraryId) {
                            _super.call(this, app, libraryId);
                            /**
                             * The current Feature this provider is providing details for
                             */
                            this.currentFeature = new Observable(null);
                            /**
                             * Determines whether this provider can function currently or not. This is akin to the 'canExecute' function for commands.
                             */
                            this.providerEnabled = new Observable(false);
                            this.currentFeature.bind(this, this.handleCurrentFeatureChanged);
                        }
                        FeatureProviderBase.prototype.initialize = function (config) { };
                        /**
                         * This is called when the current feature changes, so that we might update our displays. This will likely change when
                         * a new result is selected from one of the result views.
                         * @param feature A Geocortex Feature that we are displaying.
                         */
                        FeatureProviderBase.prototype.handleCurrentFeatureChanged = function (feature) { };
                        /**
                         * Convenience method to update the provider state only if the current feature is available and the state has changed.
                         * @param value The current provider state. Provider will be set to enabled only if the current feature is available as well.
                         */
                        FeatureProviderBase.prototype.updateProviderState = function (value) {
                            var currentState = !!this.currentFeature.get() && !!value;
                            if (this.providerEnabled.get() !== currentState) {
                                this.providerEnabled.set(currentState);
                            }
                        };
                        /**
                         * This method creates attached and data bound views for each markup type (compactView and expandedView - if configured separately) specified in config
                         * Override this method if a provider needs to create more than one view (for e.g. DataLinks) for each markup type specified in config.
                         * @param featureProviderConfig The configuration for this feature provider
                         * @param viewModeRegionConfig: An object that specifies the target region for each view mode for which a view needs to be created. If a view is not specified in the view mode
                         * config, it will simply be ignored. If a "default" parameter is supplied, then this will be used if only a single markup is supplied in featureProviderConfig as a string.
                         * @param onViewsCreated Optional. A callback function which, if specified, is triggered after the views have been created, with the views as arguments. Useful for asynchronous providers like Datalinks.
                         * @param customContext Optional. If provided, will be used as the context for the created views. Otherwise the FeatureProviderBase class will itself be used as the context/viewModel for the views
                         */
                        FeatureProviderBase.prototype.createAttachedViews = function (featureProviderConfig, viewModeRegionConfig, onViewsCreated, customContext) {
                            var _this = this;
                            var views = [];
                            if (!featureProviderConfig.viewType || !featureProviderConfig.markup || !viewModeRegionConfig) {
                                this.app.trace.warning("FeatureProviderBase: View type, markup or region not specified. Cannot create view for {0}".format(featureProviderConfig.type));
                            }
                            else {
                                var createAttachedView = function (viewMarkup, viewMode, id) {
                                    var targetRegion = viewModeRegionConfig[viewMode];
                                    // If the target region is specifically set to null, this is an indication that we should not create this particular view. Return.
                                    if (targetRegion === null) {
                                        return;
                                    }
                                    // Creates view for the current provider if the target region has been resolved successfully
                                    if (targetRegion) {
                                        var currentProviderView = _this.app.viewManager.createView({
                                            viewId: id,
                                            markupResource: viewMarkup,
                                            typeName: featureProviderConfig.viewType,
                                            iconUri: featureProviderConfig.iconUri,
                                            title: featureProviderConfig.title || "",
                                            regionName: targetRegion,
                                            isVisible: true,
                                            libraryId: featureProviderConfig.libraryId || _this.libraryId,
                                            configuration: featureProviderConfig.viewConfig
                                        });
                                        // Attaches the view to current provider or to the current context if set
                                        currentProviderView.attach(customContext || _this);
                                        views.push(currentProviderView);
                                    }
                                    else {
                                        _this.app.trace.warning("FeatureProviderBase: Could not resolve target region for view mode {0}. Failed to create view with id {1}".format(viewMode, id));
                                    }
                                };
                                if (typeof (featureProviderConfig.markup) === "string") {
                                    createAttachedView(featureProviderConfig.markup, "default", featureProviderConfig.viewId || null);
                                }
                                else {
                                    for (var prop in featureProviderConfig.markup) {
                                        if (featureProviderConfig.markup.hasOwnProperty(prop)) {
                                            var viewId = featureProviderConfig.viewId ? "{0}-{1}".format(featureProviderConfig.viewId, prop) : null;
                                            createAttachedView(featureProviderConfig.markup[prop], prop, viewId);
                                        }
                                    }
                                }
                                if (onViewsCreated && (typeof onViewsCreated === "function")) {
                                    onViewsCreated(views);
                                }
                            }
                        };
                        return FeatureProviderBase;
                    }(geocortex.framework.ui.ViewModelBase));
                    featureDetails.FeatureProviderBase = FeatureProviderBase;
                })(featureDetails = infrastructure.featureDetails || (infrastructure.featureDetails = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var gis;
                (function (gis) {
                    var ServiceLayerInfo = (function () {
                        function ServiceLayerInfo() {
                            this.layers = [];
                            this.tables = [];
                            this.isUserCreated = false; // Indicates if this layer was created and added by the user at runtime. Needs to be manually set if object created from esri layer
                            this.includeInLayerList = true; // true by default
                            this.isExpanded = true; // true by default
                            this._delayedRefreshToken = null;
                        }
                        ServiceLayerInfo.fromEsriLayer = function (layer) {
                            var instance = new ServiceLayerInfo();
                            instance.serviceLayer = layer;
                            instance.serviceType = gis.GisUtils.getServiceLayerType(layer);
                            instance.id = layer.id;
                            if (layer instanceof esri.layers.ArcGISDynamicMapServiceLayer || layer instanceof esri.layers.ArcGISTiledMapServiceLayer) {
                                // Treat the layer as dynamic, even though it could also be tiled.
                                // This works out since we're just accessing the layerInfos property.
                                var arcGisDynamicLayer = layer;
                                instance.capabilities = arcGisDynamicLayer.capabilities.split(",");
                                for (var i = 0; i < arcGisDynamicLayer.layerInfos.length; i++) {
                                    var esriLayerInfo = arcGisDynamicLayer.layerInfos[i];
                                    var layerInfo = gis.LayerInfo.fromEsriLayerInfo(esriLayerInfo, layer);
                                    layerInfo.serviceLayerInfo = instance;
                                    instance.layers.push(layerInfo);
                                }
                            }
                            else if (layer instanceof esri.layers.FeatureLayer) {
                                var featureLayer = layer;
                                instance.displayName = featureLayer.name;
                                instance.capabilities = featureLayer.capabilities.split(",");
                                var layerInfo = gis.LayerInfo.fromEsriFeatureLayer(featureLayer);
                                layerInfo.serviceLayerInfo = instance;
                                if (featureLayer.type === "Table") {
                                    instance.tables.push(layerInfo);
                                }
                                else {
                                    instance.layers.push(layerInfo);
                                }
                            }
                            return instance;
                        };
                        ServiceLayerInfo.fromGcxMapService = function (mapService) {
                            var instance = new ServiceLayerInfo();
                            instance.gcxMapService = mapService;
                            instance.serviceType = mapService.mapServiceType;
                            instance.serviceLayerFunction = mapService.mapServiceFunction;
                            instance.serviceLayer = mapService.serviceLayer;
                            instance.id = mapService.id;
                            instance.isExpanded = mapService.isExpanded;
                            instance.isUserCreated = mapService.isUserCreated;
                            instance.includeInLayerList = mapService.includeInLayerList;
                            instance.displayName = mapService.displayName;
                            if (mapService.serviceLayer.capabilities) {
                                instance.capabilities = mapService.serviceLayer.capabilities.split(",");
                            }
                            for (var i = 0; i < mapService.layers.length; i++) {
                                var layer = mapService.layers[i];
                                var layerInfo = gis.LayerInfo.fromGcxLayer(layer);
                                layerInfo.serviceLayerInfo = instance;
                                if (layer.type === geocortex.essentials.LayerType.TABLE_LAYER) {
                                    instance.tables.push(layerInfo);
                                }
                                else {
                                    instance.layers.push(layerInfo);
                                }
                            }
                            for (var i = 0; i < mapService.tables.length; i++) {
                                var table = mapService.tables[i];
                                var tableInfo = gis.LayerInfo.fromGcxLayer(table);
                                tableInfo.serviceLayerInfo = instance;
                                instance.tables.push(tableInfo);
                            }
                            return instance;
                        };
                        ServiceLayerInfo.prototype.findLayerById = function (id) {
                            for (var x = 0, len = this.layers.length; x < len; x++) {
                                var layer = this.layers[x];
                                if (id === layer.id.toString()) {
                                    return layer;
                                }
                            }
                            return null;
                        };
                        /**
                         * Gets whether the serviceLayer represented by this ServiceLayerInfo object is currently visible.
                         */
                        ServiceLayerInfo.prototype.isVisible = function () {
                            var visible = false;
                            if (this.serviceLayer && typeof this.serviceLayer.visible === "boolean") {
                                visible = this.serviceLayer.visible;
                            }
                            return visible;
                        };
                        ServiceLayerInfo.prototype.setVisibility = function (visible) {
                            if (this.gcxMapService) {
                                this.gcxMapService.setVisibility(visible);
                            }
                            else if (this.serviceLayer !== null) {
                                this.serviceLayer.setVisibility(visible);
                            }
                        };
                        /**
                         * Gets the opacity of the service.
                         */
                        ServiceLayerInfo.prototype.opacity = function () {
                            if (this.gcxMapService) {
                                return this.gcxMapService.opacity;
                            }
                            else if (this.serviceLayer) {
                                return this.serviceLayer.opacity;
                            }
                            return null;
                        };
                        /**
                         * Sets the opacity of this service.
                         */
                        ServiceLayerInfo.prototype.setOpacity = function (opacity) {
                            if (this.gcxMapService) {
                                this.gcxMapService.setOpacity(opacity);
                            }
                            else if (this.serviceLayer) {
                                if (opacity == null || isNaN(opacity)) {
                                    opacity = 1; // In case of invalid input, set to full opacity.
                                }
                                opacity = Math.min(1, Math.max(0, opacity));
                                this.serviceLayer.setOpacity(opacity);
                            }
                        };
                        /**
                         * Refreshes the map service by making a new request to the server.
                         * @param refreshTimeoutMs An optional parameter which if specified, will cause the map refresh to occur after the specified timeout. Any previous refresh timeouts
                         * will be cancelled when a new refresh timeout is set - ensuring that only one request goes out within the speicfied threshold. If undefined, the map refreshes immediately.
                         * @param disableClientCaching An optional parameter which, if set will disable client caching on the service layer (if supported) prior to refreshing it. Defaults to false.
                         */
                        ServiceLayerInfo.prototype.refresh = function (refreshTimeoutMs, disableClientCaching) {
                            var _this = this;
                            var serviceLayer = this.serviceLayer;
                            if (!serviceLayer || (typeof serviceLayer.refresh !== "function")) {
                                return;
                            }
                            var executeRefresh = function () {
                                _this._delayedRefreshToken = null;
                                if (disableClientCaching === true && typeof (serviceLayer.setDisableClientCaching) === "function") {
                                    // Temporarily disable client caching if this service layer supports it
                                    var disableClientCaching = serviceLayer.disableClientCaching;
                                    serviceLayer.setDisableClientCaching(true);
                                    serviceLayer.refresh();
                                    serviceLayer.setDisableClientCaching(disableClientCaching);
                                }
                                else {
                                    serviceLayer.refresh();
                                }
                            };
                            if (this._delayedRefreshToken) {
                                clearTimeout(this._delayedRefreshToken);
                            }
                            if (typeof refreshTimeoutMs !== "number") {
                                executeRefresh();
                            }
                            else {
                                this._delayedRefreshToken = setTimeout(executeRefresh, refreshTimeoutMs);
                            }
                        };
                        /**
                         * Returns whether or not this service supports layer visibility.
                         */
                        ServiceLayerInfo.prototype.supportsLayerVisibility = function () {
                            switch (this.serviceType) {
                                case geocortex.essentials.MapServiceType.FEATURE:
                                case geocortex.essentials.MapServiceType.GEORSS:
                                case geocortex.essentials.MapServiceType.KML:
                                case geocortex.essentials.MapServiceType.BING:
                                case geocortex.essentials.MapServiceType.TILED:
                                case geocortex.essentials.MapServiceType.WMTS:
                                case geocortex.essentials.MapServiceType.IMAGE:
                                case geocortex.essentials.MapServiceType.WEBTILED:
                                    return false;
                                case geocortex.essentials.MapServiceType.DYNAMIC:
                                    return this.serviceLayer !== null && !!this.serviceLayer.visibleLayers;
                            }
                            return true; // Will return true for last type - WMS
                        };
                        ServiceLayerInfo.prototype.loaded = function () {
                            var _this = this;
                            if (this._loadedDeferred) {
                                return this._loadedDeferred;
                            }
                            this._loadedDeferred = new dojo.Deferred();
                            if (this.serviceLayer.loaded) {
                                this._loadedDeferred.resolve(this.serviceLayer);
                            }
                            else if (this.serviceLayer.loadError) {
                                this._loadedDeferred.resolve(this.serviceLayer.loadError);
                            }
                            else {
                                var loadHandle = this.serviceLayer.on("load", function () {
                                    loadHandle.remove();
                                    errorHandle.remove();
                                    _this._loadedDeferred.resolve(_this.serviceLayer);
                                });
                                var errorHandle = this.serviceLayer.on("error", function (error) {
                                    loadHandle.remove();
                                    errorHandle.remove();
                                    _this._loadedDeferred.errback(error);
                                });
                            }
                            return this._loadedDeferred;
                        };
                        return ServiceLayerInfo;
                    }());
                    gis.ServiceLayerInfo = ServiceLayerInfo;
                })(gis = infrastructure.gis || (infrastructure.gis = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../gis/ServiceLayerInfo.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var layerList;
                (function (layerList) {
                    /**
                     * A node in the layer list hierarchy.
                     * In addition to layer list items, the layer list itself is considered to be a node,
                     * specifically it acts as the root node in the hierarchy.
                     */
                    var LayerListNode = (function () {
                        /**
                         * Initializes a new instance of the {@link LayerListNode} class.
                         * @param id The unique string identifier for this node
                         * @param parentNode This node's parent node if any
                         */
                        function LayerListNode(id, parentNode) {
                            /**
                            * The unique identifier for this layer list item. Will be "GCXLayerListRootNode-[random string]" if this is the root node.
                            */
                            this.id = new Observable("");
                            /**
                             * A {@link LayerListItemCollection} object, representing the current node's children
                             */
                            this.children = null;
                            /**
                             * The current node's parent - if any
                             */
                            this.parent = null;
                            if (id) {
                                this.id.set(id);
                            }
                            if (parentNode) {
                                this.parent = parentNode;
                            }
                        }
                        /**
                        * Gets the root node in the layer list hierarchy.
                        */
                        LayerListNode.prototype.getRoot = function () {
                            var rootNode = this;
                            while (rootNode.parent != null) {
                                rootNode = rootNode.parent;
                            }
                            return rootNode;
                        };
                        /**
                         * Gets the collection of ancestor nodes, ordered from nearest to farthest.
                         */
                        LayerListNode.prototype.getAncestors = function () {
                            var ancestors = null;
                            if (this.parent) {
                                ancestors = [];
                                var parent = this.parent;
                                while (parent != null) {
                                    ancestors.push(parent);
                                    parent = parent.parent;
                                }
                            }
                            return ancestors;
                        };
                        /**
                         * Gets this node, as well as it's ancestors, ordered from nearest to farthest
                         */
                        LayerListNode.prototype.getSelfAndAncestors = function () {
                            var ancestors = this.getAncestors();
                            ancestors = (ancestors && ancestors.length) ? ancestors : [];
                            ancestors.unshift(this);
                            return ancestors;
                        };
                        /**
                         * Gets all of this node's siblings, in the order that they appear in the layer list.
                         * @param includSelf A boolean which when set to true will return siblings with this node in the correct position. Defaults to false
                         */
                        LayerListNode.prototype.getSiblings = function (includeSelf) {
                            if (includeSelf === void 0) { includeSelf = false; }
                            var siblings = null;
                            if (this.parent && this.parent.children) {
                                siblings = this.parent.children.get();
                                if (!includeSelf) {
                                    siblings = siblings.slice(0);
                                    for (var x = 0; x < siblings.length; x++) {
                                        if (siblings[x] === this) {
                                            siblings.splice(x, 1);
                                            break;
                                        }
                                    }
                                }
                            }
                            return siblings;
                        };
                        /**
                         * Gets all of this node's descendant items, in depth-first traversal order.
                         */
                        LayerListNode.prototype.getDescendants = function () {
                            if (!this.children) {
                                return;
                            }
                            var descendants = [];
                            var children = this.children.get();
                            for (var x = 0; x < children.length; x++) {
                                var child = children[x];
                                descendants.push(child);
                                var descendantsOfChild = child.getDescendants();
                                for (var y = 0; y < descendantsOfChild.length; y++) {
                                    descendants.push(descendantsOfChild[y]);
                                }
                            }
                            return descendants;
                        };
                        /**
                         * Gets this node, as well as it's descendants, in depth-first traversal order
                         */
                        LayerListNode.prototype.getSelfAndDescendants = function () {
                            var descendants = this.getDescendants();
                            descendants = (descendants && descendants.length) ? descendants : [];
                            descendants.unshift(this);
                            return descendants;
                        };
                        return LayerListNode;
                    }());
                    layerList.LayerListNode = LayerListNode;
                })(layerList = infrastructure.layerList || (infrastructure.layerList = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="LayerListNode.ts" />
/// <reference path="LayerListConfigurationParams.ts" />
/// <reference path="../../../_Definitions/LayerList.Rest.d.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var layerList;
                (function (layerList) {
                    /**
                     * Represents the site's layer list, also known as table of contents.
                     */
                    var LayerList = (function (_super) {
                        __extends(LayerList, _super);
                        /**
                         * Creates a new instance of the (@link LayerList} class
                         * @param map The {@link geocortex.essentials.models.MapInfo} that the layer list belongs to
                         * @param url Optional. The URL for the essentials layer list rest endpoint if the layer list rest endpoint is not available
                         * @param layerListRestEndpoint Optional. The layer list rest endpoint if available. If this is available, the url will not be used
                         * @param options Optional. An object containing options to configure the layer list
                         */
                        function LayerList(appInfo, url, layerListRestEndpoint, options) {
                            var _this = this;
                            _super.call(this, "GCXLayerListRootNode-".concat(geocortex.framework.utils.alphaNumericToken()));
                            /** Whether or not the layer list was successfully initialized. */
                            this.layerListInitialized = false;
                            /**
                             * The exception that occurred if the layer list could not be initialized.
                             */
                            this.layerListInitializationFailure = null;
                            /**
                             * Occurs when initialization of the layer list fails.
                             * @event
                             */
                            this.onLayerListInitializationFailed = function (error) { };
                            /**
                             * Occurs when initialization of the layer list succeeds with a response from the REST endpoint. Depending on the API,
                             * this response may actually be an error message served as a correct HTTP response.
                             * @event
                             */
                            this.onLayerListInitialized = function (sender) { };
                            /**
                             * A boolean indicating whether legend integration should be enabled for this layer list
                             */
                            this.enableLegendIntegration = false;
                            /**
                             * A boolean indicating whether swatches are to be shown for invisible layers for this layer list
                             */
                            this.onlyShowSwatchesOnVisibleLayers = false;
                            /**
                             * A boolean indicating whether visibility all parent items should be automatically activated/set to true when the
                             * visibility of an item is set to true. In effect, this setting ensures that an item when set to visible will necessarily
                             * be effectively visible as well.
                             */
                            this.autoActivateAncestorVisibilities = false;
                            this._addedFolderReferences = [];
                            this._handledMapServiceReferences = [];
                            this._allMapServiceReferences = [];
                            this._outOfFolderMapServiceReferences = [];
                            /** Private members */
                            this._initializing = false;
                            this._groupByOperationalAndBase = true; // Whether to group items by operational and base maps. Only applicable for Essentials < v4.2 - i.e. in non 'configurable' mode
                            this._layerListRestEndpoint = null;
                            this._suspendMapUpdates = false;
                            if (!appInfo || !appInfo.mapInfo) {
                                throw new Error("LayerList: Initialization failed. AppInfo/MapInfo cannot be null");
                            }
                            this.appInfo = appInfo;
                            this.mapInfo = appInfo.mapInfo;
                            this.url = url || "";
                            this._libraryId = "Mapping.Infrastructure"; // The library id to use for retrieving language resources from the mapping.infrastructure project
                            this._layerListRestEndpoint = layerListRestEndpoint || null;
                            // Grab configured options
                            this.enableLegendIntegration = options && (options.enableLegendIntegration != undefined) ? options.enableLegendIntegration : false;
                            this.onlyShowSwatchesOnVisibleLayers = options && (options.onlyShowSwatchesOnVisibleLayers != undefined) ? options.onlyShowSwatchesOnVisibleLayers : false;
                            this.autoActivateAncestorVisibilities = options && (options.autoActivateAncestorVisibilities != undefined) ? options.autoActivateAncestorVisibilities : false;
                            this._groupByOperationalAndBase = options && (options.groupByOperationalAndBase != undefined) ? options.groupByOperationalAndBase : true;
                            this.enableLayerIcons = options && (options.enableLayerIcons != undefined) ? options.enableLayerIcons : false; // GVH-4369
                            this.serviceLoadFailureIconUri = options ? options.serviceLoadFailureIconUri || "" : "";
                            this.serviceLoadFailureIconTooltip = options ? options.serviceLoadFailureIconTooltip || "" : "";
                            this.multiLegendSwatchElement = options ? options.multiLegendSwatchElement || "" : "";
                            this.singleLegendIconTooltip = options ? options.singleLegendIconTooltip || "" : "";
                            this.multiLegendIconTooltip = options ? options.multiLegendIconTooltip || "" : "";
                            // GVH-10801: these bindings prevents any updates from being written to the map while the layer theme is 
                            // changing, then apply all the changes simultaneously once the loading is done.
                            dojo.connect(this.mapInfo.gcxMap.layerThemesInfo, "layerThemeChangingEvent", dojo.hitch(this, function () { return _this.suspendMapUpdates = true; }));
                            dojo.connect(this.mapInfo.gcxMap.layerThemesInfo, "layerThemeChangedEvent", dojo.hitch(this, function () { return _this.suspendMapUpdates = false; }));
                        }
                        Object.defineProperty(LayerList.prototype, "suspendMapUpdates", {
                            /**
                             * If set to true, then changing items' visibilities will not update the map until this setting is turned off,
                             * at which point all the new visibility settings will be applied. This setting is useful when changing the
                             * visibilities of mulitple items at once, since it avoid unnecessary map updates.
                             */
                            get: function () {
                                return this._suspendMapUpdates;
                            },
                            set: function (value) {
                                if (value === this._suspendMapUpdates) {
                                    return;
                                }
                                this._suspendMapUpdates = value;
                                if (this._suspendMapUpdates) {
                                    this._enableDeferredItemVisibilities(this.children.get());
                                }
                                else {
                                    this._applyDeferredItemVisibilities(this.children.get());
                                }
                            },
                            enumerable: true,
                            configurable: true
                        });
                        /**
                         * Initializes this instance of the {@link LayerList} class.
                         * This is an asynchronous method, you may subscribe to the {@link onLayerListInitialized}
                         * and {@link onLayerListInitializationFailed} events for completion information.
                         */
                        LayerList.prototype.initialize = function () {
                            // If it is already initialized or is initializing, then exit.
                            if (this.layerListInitialized || this._initializing) {
                                return;
                            }
                            // Indicate that the initialization is happening
                            this._initializing = true;
                            // Create the object that will hold the layer list items. 
                            // /** Note: If changing parent from null to something else, make appropriate changes in LayerListFolderItem **/
                            this.children = new layerList.LayerListItemCollection(null);
                            this.children.layerList = this;
                            // If we have the layer list rest endpoint defined, simply use that to initialize the layer list.
                            if (this._layerListRestEndpoint) {
                                this._layerListInitializationHandler(this._layerListRestEndpoint);
                            }
                            else if (this.url && this.appInfo.essentialsVersion && this.appInfo.essentialsVersion >= 4.02) {
                                geocortex.request({
                                    url: this.url,
                                    content: {
                                        f: "json"
                                    },
                                    load: dojo.hitch(this, this._layerListInitializationHandler),
                                    error: dojo.hitch(this, this._layerListInitializationErrorHandler),
                                    callbackParamName: "CallBack"
                                });
                            }
                            else {
                                this._layerListInitializationHandler(null);
                            }
                        };
                        /**
                         * Adds a user-added layer to the Layer List. Returns true if the layer was added, false otherwise.
                         */
                        LayerList.prototype.addUserAddedServiceLayer = function (serviceLayer, index) {
                            var sLayer = serviceLayer;
                            if (!this.layerListInitialized) {
                                return false;
                            }
                            if (!(sLayer instanceof infrastructure.gis.ServiceLayerInfo)) {
                                if (sLayer instanceof geocortex.essentials.MapService) {
                                    sLayer = infrastructure.gis.ServiceLayerInfo.fromGcxMapService(sLayer);
                                }
                                else if (sLayer instanceof esri.layers.Layer) {
                                    sLayer = infrastructure.gis.ServiceLayerInfo.fromEsriLayer(sLayer);
                                }
                                else {
                                    this.appInfo.gcxApp.trace.error("addUserAddedServiceLayer: Could not add layer. Invalid layer type.");
                                    return false;
                                }
                            }
                            // Make sure the service is flagged as user created.
                            sLayer.isUserCreated = true;
                            var serviceLayerItems = this._generateLayerListItemsFromServiceLayer(sLayer, this, true);
                            if (serviceLayerItems && serviceLayerItems.length) {
                                if (index !== null && index !== undefined) {
                                    return this._addItemsToUserAddedFolder(serviceLayerItems, index);
                                }
                                else {
                                    return this._addItemsToUserAddedFolder(serviceLayerItems);
                                }
                            }
                            return false;
                        };
                        LayerList.prototype.removeServiceLayer = function (serviceLayer) {
                            var sLayer = serviceLayer;
                            if (!this.layerListInitialized) {
                                return false;
                            }
                            if (!(sLayer instanceof esri.layers.Layer)) {
                                if (sLayer instanceof geocortex.essentials.MapService || sLayer instanceof infrastructure.gis.ServiceLayerInfo) {
                                    sLayer = sLayer.serviceLayer;
                                }
                                else {
                                    this.appInfo.gcxApp.trace.error("removeServiceLayer: Could not remove layer. Invalid layer type.");
                                    return false;
                                }
                            }
                            var listItems = this.getDescendants();
                            if (listItems.length) {
                                for (var x = 0; x < listItems.length; x++) {
                                    var listItem = listItems[x];
                                    if (listItem.mapService && listItem.mapService.serviceLayer === sLayer) {
                                        var parent = listItem.parent;
                                        if (parent) {
                                            parent.children.removeItem(listItem);
                                            if (parent instanceof layerList.LayerListItem) {
                                                parent.refreshOnDemandItemCollection();
                                            }
                                        }
                                        else {
                                            this.children.removeItem(listItem); // If parent is not defined, then it's a root level item.
                                        }
                                    }
                                }
                                return true; // success!
                            }
                            return false;
                        };
                        /**
                         * Updates the layer list with the adds and removes for the given service. It will not add duplicate items.
                         * @param mapService The {@link essentials.MapService} or {@link: infrastructure.gis.ServiceLayerInfo} that contains the updates.
                         * @param newItems An array of {@link essentials.Layer} items that are being added to the layer list.
                         * @param oldItems An array of {@link essentials.Layer} items that are being removed from the layer list.
                         * @returns A boolean of whether or not the update was successful.
                         */
                        LayerList.prototype.updateServiceLayer = function (mapService, newItems, oldItems) {
                            if (!this.layerListInitialized || !mapService) {
                                return false;
                            }
                            newItems = newItems || [];
                            oldItems = oldItems || [];
                            var sLayer;
                            if (mapService instanceof geocortex.essentials.MapService) {
                                sLayer = infrastructure.gis.ServiceLayerInfo.fromGcxMapService(mapService);
                            }
                            else if (mapService instanceof infrastructure.gis.ServiceLayerInfo) {
                                sLayer = mapService;
                            }
                            else {
                                this.appInfo.gcxApp.trace.error("updateServiceLayer: Could not update layer. Invalid layer type.");
                                return false;
                            }
                            var currentItems = this.getDescendants();
                            var matchingServices = currentItems.filter(function (layerListItem) {
                                return layerListItem.mapService && layerListItem.mapService && layerListItem.mapService.gcxMapService === sLayer.gcxMapService;
                            });
                            // If we don't currently have something in the layer list that matches, we should add it instead of trying to update.
                            if (!matchingServices.length) {
                                return this.addUserAddedServiceLayer(sLayer);
                            }
                            // At this point we know we have a service layer in the layer list that contains some of the items we are adding.
                            // However, the layers could be spread out throughout the entire layer list, so we need to loop through them all to remove only the ones we want.
                            // We will remove them in place.
                            if (oldItems && oldItems.length) {
                                var currentItems = this.getDescendants();
                                for (var i = 0; i < currentItems.length; i++) {
                                    var currentItem = currentItems[i];
                                    if (currentItem.type === layerList.LayerListItemType.LAYER) {
                                        var layerItem = currentItem;
                                        var gcxLayer = layerItem.layer && layerItem.layer.gcxLayer ? layerItem.layer.gcxLayer : null;
                                        if (gcxLayer && gcxLayer.isUserCreated && oldItems.indexOf(gcxLayer) >= 0) {
                                            var parent = layerItem.parent;
                                            if (parent) {
                                                parent.children.removeItem(layerItem);
                                                if (parent instanceof layerList.LayerListItem) {
                                                    parent.refreshOnDemandItemCollection();
                                                }
                                            }
                                            else {
                                                this.children.removeItem(layerItem); // If parent is not defined, then it's a root level item.
                                                this.children.pulse();
                                            }
                                        }
                                    }
                                }
                            }
                            // Add all of the new items to the user added layers folder.
                            if (newItems && newItems.length) {
                                var currentItems = this.getDescendants();
                                var newLayerListItems = new Array();
                                for (var i = 0; i < newItems.length; i++) {
                                    var layer = newItems[i];
                                    var lyrInfo = sLayer.findLayerById(layer.id);
                                    if (!lyrInfo) {
                                        lyrInfo = infrastructure.gis.LayerInfo.fromGcxLayer(layer);
                                        lyrInfo.serviceLayerInfo = sLayer;
                                        sLayer.layers.push(lyrInfo);
                                    }
                                    // We also need to check for the id in addition to checking the actual item. If the layer exists in the layer list from the site from the layer catalog, that isn't reflected there.
                                    // So we actually have a whole new layer object, but we still don't want to add it, because it references the same 
                                    var matchingItems = currentItems.filter(function (layerListItem) {
                                        return layerListItem.layer && (layerListItem.layer.gcxLayer === lyrInfo.gcxLayer);
                                    });
                                    // Don't add duplicate layers
                                    if (matchingItems.length) {
                                        continue;
                                    }
                                    var layerListLayerItem = new layerList.LayerListLayerItem(lyrInfo.id, lyrInfo, this, layerList.LayerListItemType.LAYER);
                                    newLayerListItems.push(layerListLayerItem);
                                }
                                if (newLayerListItems.length) {
                                    return this._addItemsToUserAddedFolder(newLayerListItems);
                                }
                            }
                            return false;
                        };
                        /**
                         * Updates the legend items in the layer list for a given map service. Returns true if the layer was added, false otherwise.
                         * @param mapService That map service that needs to have its layer list item updated.
                         */
                        LayerList.prototype.updateServiceLayerLegendSwatch = function (mapService) {
                            if (!this.layerListInitialized) {
                                return false;
                            }
                            var serviceLayer = mapService.serviceLayer;
                            if (!serviceLayer) {
                                this.appInfo.gcxApp.trace.error("updateServiceLayerLegendSwatch: Could not update layer swatch. Invalid layer type.");
                                return false;
                            }
                            var listItems = this.getDescendants();
                            var listItemsForService = listItems.filter(function (listItem) { return listItem.mapService && listItem.mapService.serviceLayer.id === serviceLayer.id; });
                            if (listItemsForService.length > 0) {
                                for (var i = 0; i < listItemsForService.length; i++) {
                                    var listItem = listItemsForService[i];
                                    if (listItem && listItem instanceof layerList.LayerListLayerItem) {
                                        listItem.updateLegendItems();
                                    }
                                }
                                return true;
                            }
                            return false;
                        };
                        /**
                         * Obtains the index value within the user-added layers folder for a given service layer. Returns the value of the index.
                         * If the index value does not exist, returns null.
                         * @param serviceLayer That service layer whose index number within the user-added layers folder needs to be determined.
                         */
                        LayerList.prototype.getUserAddedLayersFolderIndex = function (serviceLayer) {
                            var sLayer = serviceLayer;
                            if (!this.layerListInitialized) {
                                return null;
                            }
                            if (!(sLayer instanceof esri.layers.Layer)) {
                                if (sLayer instanceof geocortex.essentials.MapService || sLayer instanceof infrastructure.gis.ServiceLayerInfo) {
                                    sLayer = sLayer.serviceLayer;
                                }
                                else {
                                    this.appInfo.gcxApp.trace.error("removeServiceLayer: Could not remove layer. Invalid layer type.");
                                    return null;
                                }
                            }
                            var destination = this._userAddedLayersFolder || this;
                            if (destination.children && destination.children.length) {
                                var listItems = destination.children.get();
                                for (var x = 0; x < listItems.length; x++) {
                                    var listItem = listItems[x];
                                    if (listItem.mapService && listItem.mapService.serviceLayer === sLayer) {
                                        return x;
                                    }
                                }
                            }
                            return null;
                        };
                        /**
                         * This is an internal function, though not private to this class. The configurable layer list initializes all layers and filters layer visibilities based on configuration settings
                         * and preset rules. In order to avoid flickers on the map and excessive visibility requests, all visibilities are applied at once after processing is complete. This function
                         * should be invoked in order to finally apply these visibilities after all processing is completed.
                         * @private
                         */
                        LayerList.prototype._applyDeferredItemVisibilities = function (LLItemArray) {
                            var _this = this;
                            dojo.forEach(LLItemArray, function (child) {
                                child._applyDeferredInitialVisibility();
                                if (child.children && child.children.length()) {
                                    _this._applyDeferredItemVisibilities(child.children.get());
                                }
                            });
                        };
                        LayerList.prototype._enableDeferredItemVisibilities = function (items) {
                            var _this = this;
                            items.forEach(function (item) {
                                if (geocortex.framework.utils.isNullOrUndefined(item._deferredVisibilitySetting)) {
                                    // All future calls to this item's setVisibility function will be deferred until _applyDeferredItemVisibilities() is called.
                                    item._deferredVisibilitySetting = item.isVisible.get();
                                }
                                _this._enableDeferredItemVisibilities(item.children.get());
                            });
                        };
                        /** @private */
                        LayerList.prototype._layerListInitializationErrorHandler = function (error) {
                            this.layerListInitializationFailure = error;
                            if (this.onLayerListInitializationFailed) {
                                this.onLayerListInitializationFailed(error);
                            }
                            this._initializing = false;
                        };
                        /** @private */
                        LayerList.prototype._layerListInitializationHandler = function (result) {
                            var _this = this;
                            var postConfigurationRoutine = function () {
                                _this.layerListInitialized = true;
                                _this._initializing = false;
                                // Need to process the linked map services before applying the startup layer theme - see GVH-4548
                                _this._processEligibleSingleMapServiceFolders();
                                _this._processUnhandledMapServices(); // See comments on GVH-4329
                                // GVH-5148: Add a transparency slider to folders containing one or more hidden items that would otherwise
                                // have sliders.
                                _this._setupOpacityBindingsForParentsOfHiddenItemsWithOpacityBindings();
                                // Apply the initial layer theme (as defined in the site or through URL parameters)
                                _this._applyInitialLayerTheme();
                                _this._applyDeferredItemVisibilities(_this.children.get());
                                if (_this.onLayerListInitialized) {
                                    _this.onLayerListInitialized(_this);
                                }
                            };
                            if (result) {
                                this._configureLayerListFromRestResponse(result, postConfigurationRoutine, this._layerListInitializationErrorHandler);
                            }
                            else {
                                this._configureLayerListFromMapInfo(this.mapInfo, postConfigurationRoutine, this._layerListInitializationErrorHandler);
                            }
                        };
                        /** @private */
                        LayerList.prototype._configureLayerListFromMapInfo = function (mapInfo, successCallback, errorCallback) {
                            if (!mapInfo) {
                                this._layerListInitializationErrorHandler(new Error("Error initializing layer list from MapInfo."));
                                return;
                            }
                            // If we have access to the geocortex map, then we'll have access to extra information about whether to group the service layers into operational or base.
                            if (mapInfo.gcxMap) {
                                if (mapInfo.serviceLayers.length && mapInfo.serviceLayers[0].serviceLayerFunction != undefined && this._groupByOperationalAndBase) {
                                    var operationalLayers = new layerList.LayerListFolderItem(this.id.get() + ":Operational", this.appInfo.gcxApp.getResource(this._libraryId, "language-layerlist-operational-maps-folder-title"), this);
                                    var baseMaps = new layerList.LayerListFolderItem(this.id.get() + ":Base", this.appInfo.gcxApp.getResource(this._libraryId, "language-layerlist-base-maps-folder-title"), this);
                                }
                            }
                            try {
                                for (var x = 0; x < mapInfo.serviceLayers.length; x++) {
                                    var serviceLayer = mapInfo.serviceLayers[x];
                                    var serviceLayerItems = this._generateLayerListItemsFromServiceLayer(serviceLayer, this);
                                    if (serviceLayerItems && serviceLayerItems.length) {
                                        if (!this._groupByOperationalAndBase) {
                                            this.children.addItems(serviceLayerItems);
                                        }
                                        else {
                                            switch (serviceLayer.serviceLayerFunction) {
                                                case "Operational":
                                                    operationalLayers.children.addItems(serviceLayerItems);
                                                    break;
                                                case "Base":
                                                    baseMaps.children.addItems(serviceLayerItems);
                                                    break;
                                                default:
                                                    throw new Error("ServiceLayerFunction undefined or not recognized: {0}".format(serviceLayer.serviceLayerFunction));
                                            }
                                        }
                                    }
                                }
                                // If grouping by operational and base, we still have not added the operational and base layers to this list. We'll add them based on whether they have 
                                // any children or not. We don't want an empty "Base Map" category showing up - for instance.
                                if (this._groupByOperationalAndBase) {
                                    if (operationalLayers.children.length()) {
                                        this._generateThemeSettingsForCoreFolder(operationalLayers);
                                        this.children.addItem(operationalLayers);
                                        operationalLayers.isExpanded.set(true);
                                        operationalLayers.isVisible.set(true);
                                        operationalLayers.configuredVisible = true;
                                    }
                                    if (baseMaps.children.length()) {
                                        this._generateThemeSettingsForCoreFolder(baseMaps);
                                        this.children.addItem(baseMaps);
                                        baseMaps.isExpanded.set(true);
                                        baseMaps.isVisible.set(true);
                                        baseMaps.configuredVisible = true;
                                    }
                                }
                            }
                            catch (err) {
                                console.error("Layer List Configuration Error: {0}".format((err && err.message) || "Unknown Error"));
                                errorCallback(err);
                                return;
                            }
                            successCallback();
                        };
                        /**
                         * Apply configuration from the layer list's REST endpoint.
                         * @param rest The serialized layer list configuration from the rest endpoint.
                         * @param successCallback Called when the configuration is successfully applied to this layer list.
                         * @param errorCallback Called when an error occurs while attempting to apply the configuration to this layer list.
                         * @private
                         */
                        LayerList.prototype._configureLayerListFromRestResponse = function (rest, successCallback, errorCallback) {
                            try {
                                // Handling general data failure.
                                if (!rest || !rest.items) {
                                    throw new Error("Layer list failed to load (general data failure).");
                                }
                                // Setting user added layers destination.
                                this._userAddedLayersDestinationId = rest.userAddedLayersDestinationId;
                                // Creating layer list items.
                                for (var _i = 0, _a = rest.items; _i < _a.length; _i++) {
                                    var restItem = _a[_i];
                                    var layerListItem = this._createLayerListItemFromRestResult(restItem, this);
                                    if (layerListItem) {
                                        this.children.addItem(layerListItem);
                                    }
                                }
                            }
                            // Handling errors from above.
                            catch (error) {
                                error.name = "LayerListConfigurationError/" + error.name;
                                this._layerListInitializationErrorHandler(error);
                                errorCallback(error);
                                return;
                            }
                            // We reach success if no errors have occurred.
                            successCallback();
                        };
                        /**
                         * Creates one or more layer list items from the service layer information for the item(s). Multiple items are possible only when the parent mapService is configured
                         * to not be included in the layer list whereas it's children are included. This is an edge case we need to support for backwards compatibility.
                         * @param jsonRestItem The JSON rest item.
                         * @param parent The {@link LayerListNode} representing the parent of the created item. If provided, the item's parent will be set to this value.
                         * @param isUserAddedLayer A boolean indicating if this is a user added layer. If it is then it will be included in all themes. Default is false.
                         * @return A new {@link LayerList} item corresponding to the input.
                         */
                        LayerList.prototype._generateLayerListItemsFromServiceLayer = function (serviceLayerInfo, parent, isUserAddedLayer) {
                            var _this = this;
                            if (isUserAddedLayer === void 0) { isUserAddedLayer = false; }
                            var layerListItems = [];
                            var item = null;
                            var recursivelyAddLayers = function (layer, layerListItem) {
                                var subIds = layer.subLayerIds || [];
                                if (subIds.length > 0) {
                                    for (var subIndex = 0; subIndex < subIds.length; subIndex++) {
                                        var subModelLayer = serviceLayerInfo.findLayerById(subIds[subIndex]);
                                        if (subModelLayer) {
                                            subModelLayer["processed"] = true;
                                            if (subModelLayer.includeInLayerList) {
                                                var subLayer = new layerList.LayerListLayerItem(subModelLayer.id, subModelLayer, _this);
                                                processIfUserAddedLayerItem(subLayer);
                                                layerListItem.children.addItem(subLayer);
                                                recursivelyAddLayers(subModelLayer, subLayer);
                                            }
                                        }
                                    }
                                }
                                layerListItem.isExpanded.set(layer.isExpanded && !!(layer.subLayerIds && layer.subLayerIds.length));
                            };
                            var processIfUserAddedLayerItem = function (item) {
                                if (item && isUserAddedLayer) {
                                    item.unbindFromActiveTheme();
                                    item.inActiveTheme.set(true);
                                }
                            };
                            if (serviceLayerInfo.includeInLayerList) {
                                item = new layerList.LayerListMapServiceItem(serviceLayerInfo.id, serviceLayerInfo, this);
                                processIfUserAddedLayerItem(item);
                            }
                            if (serviceLayerInfo.serviceLayer instanceof esri.layers.GraphicsLayer && serviceLayerInfo.layers.length === 1) {
                                item = this._handleGraphicsLayerItem(serviceLayerInfo, item);
                                processIfUserAddedLayerItem((item && item.children.length()) ? item.children.getAt(0) : item);
                            }
                            else if (serviceLayerInfo.layers.length) {
                                dojo.forEach(serviceLayerInfo.layers, function (modelLayer) {
                                    if ((modelLayer.includeInLayerList || modelLayer.isUserCreated) && !modelLayer["processed"]) {
                                        var layer = new layerList.LayerListLayerItem(modelLayer.id, modelLayer, _this);
                                        processIfUserAddedLayerItem(layer);
                                        if (item) {
                                            item.children.addItem(layer);
                                        }
                                        else {
                                            layerListItems.push(layer);
                                        }
                                        recursivelyAddLayers(modelLayer, layer);
                                    }
                                });
                                if (item) {
                                    item.isExpanded.set(serviceLayerInfo.isExpanded && !!serviceLayerInfo.layers.length);
                                }
                            }
                            if (item) {
                                layerListItems.push(item);
                                if (parent) {
                                    item.parent = parent;
                                }
                            }
                            return layerListItems;
                        };
                        // Special processing for graphics layer items when the layer list is being run in "compatibility mode" for pre 4.2 versions of essentials.
                        LayerList.prototype._handleGraphicsLayerItem = function (serviceLayerInfo, listItem) {
                            var processedItem = listItem;
                            if (serviceLayerInfo.layers[0].includeInLayerList || serviceLayerInfo.layers[0].isUserCreated) {
                                var modelLayer = serviceLayerInfo.layers[0];
                                var graphicsLayer = new layerList.LayerListGraphicsLayerItem(modelLayer.id, serviceLayerInfo.layers[0], this);
                                graphicsLayer.isExpanded.set(modelLayer.isExpanded && !!(modelLayer.subLayerIds && modelLayer.subLayerIds.length));
                                if (processedItem) {
                                    // Edge Case: Disable child layer visibility assignment if both parent and child feature layers included in layer list. In this case, set 
                                    // child layer visibility to true - always. The user can toggle visibility using the parent layer.
                                    processedItem.isVisible.set(graphicsLayer.isVisible.get());
                                    graphicsLayer.isVisible.set(true);
                                    graphicsLayer.canNotAssignVisibility.set(true);
                                    processedItem.children.addItem(graphicsLayer);
                                    processedItem.isExpanded.set(serviceLayerInfo.isExpanded && !!serviceLayerInfo.layers.length);
                                }
                                else {
                                    processedItem = graphicsLayer;
                                }
                            }
                            return processedItem;
                        };
                        /**
                         * Creates a layer list item from the JSON representation of the item.
                         * @param jsonRestItem The JSON rest item.
                         * @param parent The {@link LayerListNode} representing the parent of the created item. If provided, the item's parent will be set to this value.
                         * @return A new {@link LayerList} item corresponding to the input.
                         */
                        LayerList.prototype._createLayerListItemFromRestResult = function (jsonRestItem, parent) {
                            var _this = this;
                            var item = null;
                            var objectNotFoundError = function (type) {
                                var desc = (type === layerList.LayerListItemType.MAPSERVICE) ? "MapService" : (type === layerList.LayerListItemType.LAYER) ? "Map Layer" : "Object";
                                console.error("Layer List Error: {0} with ID: {1} not available. Excluding from layer list. Please check your security settings.".format(desc, jsonRestItem.mapServiceID));
                            };
                            switch (jsonRestItem.type) {
                                case "folder":
                                    item = new layerList.LayerListFolderItem(jsonRestItem.id, jsonRestItem.name, this);
                                    // If the folder doesn't have sub items, we don't display it, and we collapse it.
                                    if (!(jsonRestItem.items && jsonRestItem.items.length && this._subItemIncludedInLayerList(jsonRestItem.items))) {
                                        item.displayItem.set(false);
                                        item.isExpanded.set(false);
                                    }
                                    // If this folder is marked as the user added layers destination, mark it down as such.
                                    if (this._userAddedLayersDestinationId && jsonRestItem.id === this._userAddedLayersDestinationId) {
                                        this._userAddedLayersFolder = item;
                                    }
                                    break;
                                case "mapService":
                                    var mapService = this.mapInfo.findMapServiceById(jsonRestItem.mapServiceID);
                                    if (!mapService) {
                                        objectNotFoundError(layerList.LayerListItemType.MAPSERVICE);
                                    }
                                    if (mapService && mapService.includeInLayerList) {
                                        item = new layerList.LayerListMapServiceItem(jsonRestItem.id, mapService, this);
                                    }
                                    break;
                                case "layer":
                                    var mapService = this.mapInfo.findMapServiceById(jsonRestItem.mapServiceID);
                                    if (!mapService) {
                                        objectNotFoundError(layerList.LayerListItemType.MAPSERVICE);
                                    }
                                    if (mapService) {
                                        var layer = mapService.findLayerById(jsonRestItem.layerID);
                                        if (!layer) {
                                            objectNotFoundError(layerList.LayerListItemType.LAYER);
                                        }
                                        if (layer && layer.includeInLayerList) {
                                            if (mapService.serviceLayer instanceof esri.layers.GraphicsLayer) {
                                                item = new layerList.LayerListGraphicsLayerItem(jsonRestItem.id, layer, this);
                                            }
                                            else {
                                                item = new layerList.LayerListLayerItem(jsonRestItem.id, layer, this);
                                            }
                                        }
                                    }
                                    break;
                                default:
                                    throw new Error("Unknown layer list item type. Reported type: {0}".format(jsonRestItem.type));
                            }
                            if (item) {
                                if (parent) {
                                    item.parent = parent;
                                }
                                // Recursively create child items.
                                if (jsonRestItem.items != null && jsonRestItem.items.length) {
                                    dojo.forEach(jsonRestItem.items, function (restLayerListItem) {
                                        var childItem = _this._createLayerListItemFromRestResult(restLayerListItem, item);
                                        if (childItem) {
                                            item.children.addItem(childItem);
                                        }
                                    });
                                }
                                this._processItem(item, jsonRestItem);
                            }
                            return item;
                        };
                        /** @private */
                        LayerList.prototype._subItemIncludedInLayerList = function (subItems) {
                            var _this = this;
                            var includedInLayerList = function (subItem) {
                                if (subItem.type === "folder") {
                                    return (subItem.items && subItem.items.length) ? _this._subItemIncludedInLayerList(subItem.items) : false;
                                }
                                else if (subItem.type === "mapService") {
                                    var mapService = _this.mapInfo.findMapServiceById(subItem.mapServiceID);
                                    return mapService ? !!(mapService.includeInLayerList) : false;
                                }
                                else if (subItem.type === "layer") {
                                    var mapService = _this.mapInfo.findMapServiceById(subItem.mapServiceID);
                                    var layer = mapService.findLayerById(subItem.layerID);
                                    return layer ? !!(layer.includeInLayerList) : false;
                                }
                            };
                            for (var x = 0; x < subItems.length; x++) {
                                var subItem = subItems[x];
                                if (includedInLayerList(subItem)) {
                                    return true;
                                }
                            }
                            return false;
                        };
                        /**
                         * @private Performs any processing that may be needed for items
                         */
                        LayerList.prototype._processItem = function (item, jsonRestItem) {
                            // Folders will need some special processing. Care should be taken to set the 'isExpanded' flag for the first time AFTER the item's children have been created
                            // since this will populate the onDemandItemCollection we maintain for UI performance reasons.
                            if (item.type === layerList.LayerListItemType.FOLDER) {
                                if (this.mapInfo.gcxMap && jsonRestItem.themeSettings && jsonRestItem.themeSettings.length) {
                                    for (var x = 0; x < jsonRestItem.themeSettings.length; x++) {
                                        var themeSetting = jsonRestItem.themeSettings[x];
                                        var theme = this.mapInfo.gcxMap.layerThemesInfo.getTheme(themeSetting.themeID);
                                        if (theme) {
                                            var visibility = (themeSetting.visible != undefined) ? themeSetting.visible : jsonRestItem.isVisible;
                                            item.layerThemeSettings.push(new geocortex.essentials.LayerThemeSetting(theme, visibility));
                                        }
                                    }
                                }
                                item._deferredVisibilitySetting = jsonRestItem.isVisible; // We want the visibilities to be applied to the map right at the end - after the model is completely built.
                                item.isVisible.set(jsonRestItem.isVisible);
                                item.configuredVisible = jsonRestItem.isVisible;
                                item.isExpanded.set(jsonRestItem.isExpanded && !!(jsonRestItem.items && jsonRestItem.items.length));
                                this._disableFolderIfParentTiled(item);
                            }
                            if (item.type === layerList.LayerListItemType.MAPSERVICE) {
                                item.isExpanded.set(item.mapService.isExpanded);
                            }
                            if (item.type === layerList.LayerListItemType.LAYER) {
                                item.isExpanded.set(item.layer.isExpanded && !!(item.layer.subLayerIds && item.layer.subLayerIds.length));
                            }
                            if (item.type === layerList.LayerListItemType.FOLDER) {
                                var iconUri = jsonRestItem.iconUri;
                                if (iconUri) {
                                    if (this.mapInfo.gcxMap && this.mapInfo.gcxMap.site) {
                                        // If the URI comes from an Essentials site, then it might contain 
                                        // tokens that need to be expanded first.
                                        iconUri = geocortex.essentials.RestHelper.processClientSideTokens(this.mapInfo.gcxMap.site, iconUri);
                                    }
                                    item.iconUri.set(iconUri);
                                    item.iconTooltip.set(item.name.get());
                                }
                            }
                            item.canDisplayItem.set(jsonRestItem.isVisibleInLayerList !== false);
                            if (jsonRestItem.layerVisibilityType === layerList.LayerVisibilityType.MutuallyExclusive && jsonRestItem.items && jsonRestItem.items.length > 1) {
                                // Configure child items to have radio buttons instead of check boxes.
                                var groupToken = geocortex.framework.utils.alphaNumericToken(32);
                                for (var i = 0; i < item.children.length(); i++) {
                                    item.children.getAt(i).isMutuallyExclusive.set(true);
                                    item.children.getAt(i).hasRadioToggle.set(true);
                                    item.children.getAt(i).radioGroup.set(groupToken);
                                }
                            }
                        };
                        /**
                         * @private Edge case: If a tiled map service has nested sublayers, then intermediary layers will be converted into folders. These folders should have "canNotAssignVisibility"
                         * set to true because all their children will be layers for which we cannot assign visibility and which in effect, cannot be controlled by the parent.
                         */
                        LayerList.prototype._disableFolderIfParentTiled = function (item) {
                            var parent = item.parent;
                            while (parent && (parent.id !== this.id) && (parent.type === layerList.LayerListItemType.MAPSERVICE || parent.type === layerList.LayerListItemType.FOLDER)) {
                                if ((parent.type === layerList.LayerListItemType.FOLDER && parent.canNotAssignVisibility.get()) ||
                                    (parent.type === layerList.LayerListItemType.MAPSERVICE && parent.mapService.serviceType === geocortex.essentials.MapServiceType.TILED)) {
                                    item.canNotAssignVisibility.set(true);
                                    break;
                                }
                                parent = parent.parent;
                            }
                        };
                        /** @private */
                        LayerList.prototype._generateThemeSettingsForCoreFolder = function (folder, isUserDefinedLayersFolder) {
                            if (isUserDefinedLayersFolder === void 0) { isUserDefinedLayersFolder = false; }
                            if (isUserDefinedLayersFolder) {
                                if (this.mapInfo.gcxMap && this.mapInfo.gcxMap.layerThemesInfo.layerThemesConfigured) {
                                    var themes = this.mapInfo.gcxMap.layerThemesInfo.themes;
                                    for (var x = 0; x < themes.length; x++) {
                                        folder.layerThemeSettings.push(new geocortex.essentials.LayerThemeSetting(themes[x], true));
                                    }
                                }
                                folder.inActiveTheme.set(true); // Immediately display this folder. Don't wait for the theme to be changed.
                                return;
                            }
                            var populatedLayerThemeIds = {};
                            for (var x = 0, len = folder.children.length(); x < len; x++) {
                                var child = folder.children.getAt(x);
                                var themeSettings = null;
                                switch (child.type) {
                                    case layerList.LayerListItemType.FOLDER:
                                        themeSettings = child.layerThemeSettings;
                                        break;
                                    case layerList.LayerListItemType.MAPSERVICE:
                                        themeSettings = (child.mapService.gcxMapService) ? child.mapService.gcxMapService.layerThemeSettings : null;
                                        break;
                                    case layerList.LayerListItemType.LAYER:
                                    case layerList.LayerListItemType.GRAPHICSLAYER:
                                        themeSettings = (child.layer.gcxLayer) ? (child.layer.gcxLayer).layerThemeSettings : null;
                                        break;
                                }
                                if (themeSettings && themeSettings.length) {
                                    for (var y = 0; y < themeSettings.length; y++) {
                                        var themeId = themeSettings[y].theme.id;
                                        if (populatedLayerThemeIds[themeId] == undefined) {
                                            folder.layerThemeSettings.push(new geocortex.essentials.LayerThemeSetting(themeSettings[y].theme, true));
                                            populatedLayerThemeIds[themeId] = true; // Theme id already assigned to folder. We don't want to assign it each time a layer is included in the same theme.
                                        }
                                    }
                                }
                            }
                        };
                        /** @private */
                        LayerList.prototype._applyInitialLayerTheme = function () {
                            if (this.mapInfo.gcxMap && this.mapInfo.gcxMap.layerThemesInfo.layerThemesConfigured) {
                                this.mapInfo.gcxMap.applyStartupTheme();
                            }
                        };
                        LayerList.prototype._processEligibleSingleMapServiceFolders = function () {
                            var processedMapServices = this._handledMapServiceReferences.slice(0);
                            var eligibleMsFolders = this._getFoldersContainingSingleMapService();
                            // Check eligibility and filter the singleMapServiceFolders
                            eligibleMsFolders = this._filterEligibleSingleMsFolders(eligibleMsFolders);
                            // Select the deepest level Ms folders to attach the map service to (which in turn allows transparency sliders etc to be placed on them)
                            eligibleMsFolders = this._selectDeepestLevelSingleMapServiceFolders(eligibleMsFolders);
                            for (var x = 0; x < eligibleMsFolders.length; x++) {
                                var ms = eligibleMsFolders[x];
                                if ((ms.containedMapServices[0].serviceLayer instanceof esri.layers.GraphicsLayer) || (processedMapServices.indexOf(ms.containedMapServices[0]) !== -1) || (this._outOfFolderMapServiceReferences.indexOf(ms.containedMapServices[0]) !== -1)) {
                                    continue;
                                }
                                ms.linkWithMapService(ms.containedMapServices[0]);
                                processedMapServices.push(ms.containedMapServices[0]);
                            }
                        };
                        LayerList.prototype._setupOpacityBindingsForParentsOfHiddenItemsWithOpacityBindings = function () {
                            // If an item with opacity bindings is hidden, either directly or indirectly due to a hidden ancestor, 
                            // then set up opacity bindings on the nearest displayed ancestor, if there is one.
                            var items = this.getDescendants();
                            items = dojo.filter(items, function (item) { return item.canAdjustOpacity.get(); });
                            for (var i = 0; i < items.length; i++) {
                                var folder = items[i];
                                if (!this.isEffectivelyDisplayed(folder)) {
                                    var displayedAncestor = folder.parent;
                                    while (displayedAncestor instanceof layerList.LayerListItem && !this.isEffectivelyDisplayed(displayedAncestor)) {
                                        displayedAncestor = displayedAncestor.parent;
                                    }
                                    if (displayedAncestor instanceof layerList.LayerListItem) {
                                        displayedAncestor._setupOpacityBindings();
                                    }
                                }
                            }
                        };
                        /**
                         * Indicates whether the given item is effectively visible in the layer list.
                         */
                        LayerList.prototype.isEffectivelyDisplayed = function (item) {
                            if (!item.displayItem.get()) {
                                return false;
                            }
                            else if (item.parent instanceof layerList.LayerListItem) {
                                return this.isEffectivelyDisplayed(item.parent);
                            }
                            else {
                                return true;
                            }
                        };
                        LayerList.prototype._getFoldersContainingSingleMapService = function () {
                            var folderList = [];
                            for (var x = 0; x < this._addedFolderReferences.length; x++) {
                                if (this._addedFolderReferences[x].containedMapServices.length === 1) {
                                    folderList.push(this._addedFolderReferences[x]);
                                }
                            }
                            return folderList;
                        };
                        LayerList.prototype._filterEligibleSingleMsFolders = function (sourceFolders) {
                            var _this = this;
                            if (!sourceFolders) {
                                return;
                            }
                            var result = [];
                            var topLevelSingleMsFolders = this._filterTopLevelFolders(sourceFolders);
                            for (var x = 0; x < sourceFolders.length; x++) {
                                var currFolder = sourceFolders[x];
                                var msFoldersWithIdenticalMs = dojo.filter(this._addedFolderReferences, function (x) { return ((x.id !== currFolder.id) && x.containedMapServices.length > 0 && (x.containedMapServices.indexOf(currFolder.containedMapServices[0]) !== -1)); }) || [];
                                var multipleMsFoldersWithIdenticalMs = msFoldersWithIdenticalMs.filter(function (folder) { return folder.containedMapServices.length > 1; }) || [];
                                // The single map service source Folders are eligible for a transparency slider ONLY if:
                                // 1) none of the multiple mapService folders contain direct child layers from the currFolder mapService
                                // 2) All mapService folders that contain the same map service are descendants or ancestors of the current folder
                                if (this._noChildItemsWithMapService(currFolder.containedMapServices[0], multipleMsFoldersWithIdenticalMs) && this._allFoldersAncestorsOrDescendantsOf(currFolder, msFoldersWithIdenticalMs)) {
                                    // GVH-10114: We've considered multiple mapService folders across all layer trees. We don't want to consider single mapService folders from the same tree as currFolder since the "selectDeepestLevelSingleMapServiceFolder" function 
                                    // will check which folder is the deepest in a given tree and attach a transparency slider to it. However, in case of single mapService folders in a different layer tree (i.e. layerList contains two or more
                                    // top level folders and one is a single mapService folder), we'll have to filter out currFolder if it has the same mapService.
                                    // GVH-10803: We also need to make sure that currFolder isn't a descendant of tlFolder, otherwise only the top layer folders will ever get opacity sliders
                                    if (!topLevelSingleMsFolders.some(function (tlFolder) { return tlFolder.containedMapServices[0] === currFolder.containedMapServices[0] && !_this._allFoldersAncestorsOf(currFolder, [tlFolder]) && currFolder.id !== tlFolder.id; })) {
                                        result.push(currFolder);
                                    }
                                }
                            }
                            return result;
                        };
                        LayerList.prototype._filterTopLevelFolders = function (sourceFolders) {
                            return this.children.get().filter(function (listItem) { return listItem.type === infrastructure.layerList.LayerListItemType.FOLDER && sourceFolders.indexOf(listItem) !== -1; });
                        };
                        LayerList.prototype._selectDeepestLevelSingleMapServiceFolders = function (sourceFolders) {
                            if (!sourceFolders) {
                                return;
                            }
                            var result = [];
                            var addedMapServiceReferences = [];
                            for (var x = 0; x < sourceFolders.length; x++) {
                                var sf = sourceFolders[x];
                                if (addedMapServiceReferences.indexOf(sf.containedMapServices[0]) !== -1) {
                                    continue;
                                }
                                var foldersWithIdenticalMapService = dojo.filter(sourceFolders, function (x) { return ((x.id !== sf.id) && (x.containedMapServices.indexOf(sf.containedMapServices[0]) !== -1)); }) || [];
                                if (!foldersWithIdenticalMapService.length) {
                                    result.push(sf);
                                    addedMapServiceReferences.push(sf.containedMapServices[0]);
                                    continue;
                                }
                                var currFolder = sf, index;
                                for (index = 0; index < foldersWithIdenticalMapService.length; index++) {
                                    if (this._onlyFolderItems(currFolder.children.get())) {
                                        if (this._allFoldersDescendantsOf(currFolder, foldersWithIdenticalMapService.slice(index))) {
                                            if (currFolder.children.length() > 1) {
                                                break;
                                            }
                                            currFolder = foldersWithIdenticalMapService[index];
                                            continue;
                                        }
                                    }
                                    currFolder = (index >= 1) ? foldersWithIdenticalMapService[index - 1] : currFolder;
                                    break;
                                }
                                if (this._allFoldersDescendantsOf(currFolder, foldersWithIdenticalMapService.slice(index))) {
                                    result.push(currFolder);
                                    addedMapServiceReferences.push(currFolder.containedMapServices[0]);
                                }
                            }
                            return result;
                        };
                        LayerList.prototype._allFoldersDescendantsOf = function (targetFolder, foldersToCheck) {
                            for (var x = 0; x < foldersToCheck.length; x++) {
                                var ancestors = foldersToCheck[x].getAncestors();
                                if (!ancestors || ancestors.indexOf(targetFolder) === -1) {
                                    return false;
                                }
                            }
                            return true;
                        };
                        LayerList.prototype._allFoldersAncestorsOf = function (targetFolder, foldersToCheck) {
                            var ancestors = targetFolder.getAncestors();
                            if (ancestors) {
                                for (var x = 0; x < foldersToCheck.length; x++) {
                                    if (ancestors.indexOf(foldersToCheck[x]) === -1) {
                                        return false;
                                    }
                                }
                                return true;
                            }
                            return false;
                        };
                        LayerList.prototype._allFoldersAncestorsOrDescendantsOf = function (targetFolder, foldersToCheck) {
                            var relatives = Array.prototype.concat(targetFolder.getAncestors() || [], targetFolder.getDescendants() || []);
                            if (relatives) {
                                for (var x = 0; x < foldersToCheck.length; x++) {
                                    if (relatives.indexOf(foldersToCheck[x]) === -1) {
                                        return false;
                                    }
                                }
                                return true;
                            }
                            return false;
                        };
                        // This function is non recursive on purpose. We don't care about child folders. We're only checking for actual mapServices/layers within the folders.
                        LayerList.prototype._noChildItemsWithMapService = function (ms, foldersToCheck) {
                            for (var x = 0; x < foldersToCheck.length; x++) {
                                var children = foldersToCheck[x].children.get();
                                for (var y = 0; y < children.length; y++) {
                                    if (children[y].mapService && (children[y].mapService === ms)) {
                                        return false;
                                    }
                                }
                            }
                            return true;
                        };
                        LayerList.prototype._onlyFolderItems = function (items) {
                            for (var x = 0; x < items.length; x++) {
                                if (items[x].type !== infrastructure.layerList.LayerListItemType.FOLDER) {
                                    return false;
                                }
                            }
                            return true;
                        };
                        /** See comments on GVH-4329 */
                        LayerList.prototype._processUnhandledMapServices = function () {
                            var _this = this;
                            var unhandledMapServices = dojo.filter(this._allMapServiceReferences, function (ms) { return (_this._handledMapServiceReferences.indexOf(ms) === -1); });
                            // GVH-10817: the use of the function() notation rather than big arrow notation here is important to 
                            // establish a new scope when creating the event listeners, avoiding the javascript loop closure issue
                            unhandledMapServices.forEach(function (currMapService) {
                                if ((currMapService.serviceLayer instanceof esri.layers.ArcGISDynamicMapServiceLayer) || (currMapService.serviceLayer instanceof esri.layers.WMSLayer)) {
                                    currMapService.serviceLayer.on("visibility-change", function (visibility) {
                                        // This event will not affect the layer list since it's not handled - and its not handled because either there are a mixture of layers within a folder or layers
                                        // are spread across various folders. The closest thing to normal we can do to maintain the sanctity of the information in the layer list is to set visibility of all layers 
                                        // to false. We'll maintain state about visible layers so we can revert later.
                                        if (!visibility.visible) {
                                            if (currMapService.serviceLayer instanceof esri.layers.ArcGISDynamicMapServiceLayer) {
                                                currMapService._esriLayerStateBackup = currMapService.serviceLayer.visibleLayers ? currMapService.serviceLayer.visibleLayers.slice(0) : [-1]; // Maintain state
                                                currMapService.serviceLayer.setVisibleLayers(["-1"]);
                                            }
                                            else {
                                                currMapService._esriLayerStateBackup = currMapService.serviceLayer.visibleLayers ? currMapService.serviceLayer.visibleLayers.slice(0) : [];
                                                currMapService.serviceLayer.setVisibleLayers([]);
                                            }
                                        }
                                        else {
                                            if (currMapService._esriLayerStateBackup) {
                                                currMapService.serviceLayer.setVisibleLayers(currMapService._esriLayerStateBackup);
                                                currMapService._esriLayerStateBackup = null;
                                            }
                                        }
                                    });
                                }
                            });
                        };
                        /**
                         * Add layer list items to the indexed position in the user added layers folder.
                         * If no index parameter is included, add the item to the top of the folder.
                         * If the user added layers folder is not designated, items will just be added to the top of the layer list.
                         * @private
                         * @param items Array of layer list items.
                         * @returns Boolean for whether or not all items were added successfully (passing validation).
                         */
                        LayerList.prototype._addItemsToUserAddedFolder = function (items, index) {
                            // The destination for user added layers is either the designated folder, or the root layer list node itself.
                            var destination = this._userAddedLayersFolder || this;
                            var indexValue = index || 0;
                            // Validating and inserting the layer list items into the destination. We need to validate and insert individually 
                            // because even if one item fails validation we still want to be able to add the other ones that succeed.
                            // IMPORTANT: Do not use Array.every() here, we really need to iterate over all elements.
                            // The method .every() stops looping the first time the iterator returns false or something falsey.
                            // GVH-10660: Array.reduceRight() processes the array from the end. Alternatively it could have been items.reverse().reduce()
                            var result = items.reduceRight(function (previousValue, item, index) { return destination.children.validateAndInsertItem(indexValue, item) && previousValue; }, true);
                            // Making sure the user added layers folder is visible and expanded.
                            if (this._userAddedLayersFolder) {
                                this._userAddedLayersFolder.displayItem.set(true);
                                this._userAddedLayersFolder.isExpanded.set(true);
                                this._userAddedLayersFolder.isVisible.set(true);
                                // Refreshing the parent folder.
                                if (this._userAddedLayersFolder.parent instanceof layerList.LayerListFolderItem) {
                                    this._userAddedLayersFolder.parent.refreshOnDemandItemCollection();
                                }
                            }
                            this._applyDeferredItemVisibilities(destination.children.get());
                            return result;
                        };
                        return LayerList;
                    }(layerList.LayerListNode));
                    layerList.LayerList = LayerList;
                })(layerList = infrastructure.layerList || (infrastructure.layerList = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="LayerList.ts" />
/// <reference path="LayerListNode.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var layerList;
                (function (layerList_1) {
                    (function (LayerListItemType) {
                        LayerListItemType[LayerListItemType["FOLDER"] = 0] = "FOLDER";
                        LayerListItemType[LayerListItemType["MAPSERVICE"] = 1] = "MAPSERVICE";
                        LayerListItemType[LayerListItemType["LAYER"] = 2] = "LAYER";
                        LayerListItemType[LayerListItemType["GRAPHICSLAYER"] = 3] = "GRAPHICSLAYER";
                        LayerListItemType[LayerListItemType["KMLFOLDER"] = 4] = "KMLFOLDER";
                    })(layerList_1.LayerListItemType || (layerList_1.LayerListItemType = {}));
                    var LayerListItemType = layerList_1.LayerListItemType;
                    /**
                     * An item that appears in the {@link LayerList}
                     */
                    var LayerListItem = (function (_super) {
                        __extends(LayerListItem, _super);
                        /**
                         * Creates a new instance of the {@link LayerListItem} class
                         */
                        function LayerListItem(id, type, layerList) {
                            var _this = this;
                            _super.call(this, id);
                            /**
                            * The mapService associated with the current node - if any
                            */
                            this.mapService = null;
                            /**
                             * The current opacity of the associated mapService. This will remain undefined unless the opacity of this LayerList item can be adjusted.
                             */
                            this.opacity = null;
                            this._opacityChangeHandle = null;
                            this._themeChangingHandle = null;
                            this._themeChangedHandle = null;
                            if (!id) {
                                throw new Error("LayerListItem: Initialization failed. Layer list item id cannot be null");
                            }
                            if (!layerList) {
                                throw new Error("LayerListItem: Initialization failed. LayerList cannot be null");
                            }
                            this.type = type;
                            this.layerList = layerList;
                            this.allAncestorsVisible = true; // true by default - updated when item added to LayerListItemCollection
                            this.isVisible = new Observable(false);
                            this.isEffectivelyVisible = new Observable(false);
                            this.parentEffectivelyVisible = new Observable(true);
                            this.inVisibleScaleRange = new Observable(true); // defaults to true for all items unless set otherwise
                            this.isEffectivelyVisible.syncTransform(this.isVisible, function (visible) {
                                return visible && !!_this.allAncestorsVisible;
                            });
                            this.name = new Observable("");
                            this.isExpanded = new Observable(false);
                            this.expandLegend = new Observable(false);
                            this.canNotAssignVisibility = new Observable(false);
                            this.canAdjustOpacity = new Observable(false);
                            this.inActiveTheme = new Observable(true); // All layer list items are in the default active theme (i.e. where all layers are available)
                            this.canDisplayItem = new Observable(true);
                            this.displayItem = new Observable(true);
                            this.hasDisplayedChildren = new Observable(false);
                            this.children = new layerList_1.LayerListItemCollection(this);
                            this.onDemandItemCollection = new ObservableCollection([]);
                            this.legendItems = new ObservableCollection([]);
                            this.legendSwatch = new Observable("");
                            this.legendHasMultipleItems = new Observable(false);
                            this.enableLayerActions = false;
                            this.enableMapServiceActions = false;
                            this.iconUri = new Observable("");
                            this.iconTooltip = new Observable("");
                            this.legendTooltip = new Observable("");
                            this.layerFolderToggleTooltip = new Observable("");
                            this.layerActionsTooltip = new Observable("");
                            this.layerToggleTooltip = new Observable("");
                            this.mapServiceActionsTooltip = new Observable("");
                            this.isMutuallyExclusive = new Observable(false);
                            this.hasRadioToggle = new Observable(false);
                            this.radioGroup = new Observable("");
                            this.isVisible.bind(this, this.setVisibility);
                            this.isExpanded.bind(this, this.refreshOnDemandItemCollection);
                            this.inActiveTheme.bind(this, this._onActiveThemeChanged);
                            this.canDisplayItem.bind(this, this._updateDisplayItem);
                            this.currentUserClickOriginator = false;
                            this.legendIsVisible = new Observable(false);
                            if (this.layerList.onlyShowSwatchesOnVisibleLayers) {
                                this.isEffectivelyVisible.bind(this, this._processLegendVisibility);
                                this.inVisibleScaleRange.bind(this, this._processLegendVisibility);
                                this.legendItems.bind(this, this._processLegendVisibility);
                            }
                            // GVH-7052 - Keyboard focus hits non-existent legend icon on layer group parent
                            // We want to make sure that the parent span (controlled by 'legendIsVisible') can be visible
                            //  only if the child element has HTML (controlled by 'legendSwatch')
                            this.legendSwatch.bind(this, function (data) {
                                if (_this.layerList.enableLegendIntegration) {
                                    _this._processLegendVisibility();
                                }
                            });
                            if (this.layerList && this.layerList.mapInfo && this.layerList.mapInfo.gcxMap && this.layerList.mapInfo.gcxMap.layerThemesInfo) {
                                this._themeChangingHandle = dojo.connect(this.layerList.mapInfo.gcxMap.layerThemesInfo, "layerThemeChangingEvent", dojo.hitch(this, this._handleLayerThemeChangingEvent));
                                this._themeChangedHandle = dojo.connect(this.layerList.mapInfo.gcxMap.layerThemesInfo, "layerThemeChangedEvent", dojo.hitch(this, this._handleLayerThemeChangedEvent));
                            }
                        }
                        /**
                         * Updates inActiveTheme when it changes in the underlying geocortex map service or layer (if available)
                         */
                        LayerListItem.prototype.bindToActiveTheme = function () { };
                        /**
                         * Removes the binding to the active theme
                         */
                        LayerListItem.prototype.unbindFromActiveTheme = function () { };
                        /**
                         * Remove any bindings and perform any necessary logic for item removal
                         */
                        LayerListItem.prototype.cleanUp = function () {
                            if (this._opacityChangeHandle) {
                                this._opacityChangeHandle.remove();
                                this._opacityChangeHandle = null;
                            }
                            if (this._themeChangingHandle) {
                                dojo.unsubscribe(this._themeChangingHandle);
                                this._themeChangingHandle = null;
                            }
                            if (this._themeChangedHandle) {
                                dojo.unsubscribe(this._themeChangedHandle);
                                this._themeChangedHandle = null;
                            }
                            this.unbindFromActiveTheme();
                        };
                        LayerListItem.prototype.notifyActiveThemeChanged = function (childrenInActiveTheme) {
                            // Keep "inActiveTheme" property of the parent in sync with the child's "inActiveTheme" property.
                            if (childrenInActiveTheme && !this.inActiveTheme.get()) {
                                this.inActiveTheme.set(true);
                            }
                            if (this.type === LayerListItemType.FOLDER && !childrenInActiveTheme && this.inActiveTheme.get() && this.children) {
                                if (dojo.every(this.children.get(), function (x) { return !x.inActiveTheme.get(); })) {
                                    this.inActiveTheme.set(false);
                                }
                            }
                        };
                        /**
                         * Set the visibility of this item in the layer list. This is a special function which should be called in preference to setting isVisible directly, since
                         * it also keeps track of whether this item is the originator of the current user click.
                         */
                        LayerListItem.prototype.setItemVisibility = function (visible) {
                            this.currentUserClickOriginator = true;
                            this.isVisible.set(visible);
                        };
                        /**
                         * Set the visibility of the service associated with this item in the layer list
                         */
                        LayerListItem.prototype.setVisibility = function (visible) {
                            this._updateDisplayItem();
                            // Return if ancestor visibility has not been set as yet. It will be set (and this function re-invoked) when the setAncestorVisibility method is invoked
                            // as part of this item's addition to the LayerListItemCollection.
                            if (this.allAncestorsVisible === undefined) {
                                return;
                            }
                            if (this._deferredVisibilitySetting != undefined) {
                                this._deferredVisibilitySetting = visible;
                                return;
                            }
                            // If an item in a mutually exclusive group and is made visible, then turn off the visibility of its siblings.
                            // GVH-6062: If the layer theme is currently changing, don't do anything.
                            if (visible && this.isMutuallyExclusive.get() && this.parent && !this.layerList.mapInfo.gcxMap.layerThemesInfo.themeChangeInProgress) {
                                for (var i = 0; i < this.parent.children.length(); i++) {
                                    var sibling = this.parent.children.getAt(i);
                                    if (sibling !== this && sibling.isVisible.get()) {
                                        sibling.isVisible.set(false);
                                    }
                                }
                            }
                        };
                        /**
                         * Sets the ancestor visibility. This should be set to true only if all ancestors are set visible
                         * NOTE: This function call will not check to see if all ancestors are actually visible or not. Use with caution.
                         */
                        LayerListItem.prototype.setAncestorVisibility = function (ancestorVisibility) {
                            this.allAncestorsVisible = ancestorVisibility;
                            this.isVisible.pulse(); // Recompute visibilities for self and children
                        };
                        /**
                         * Manages the on demand item collection. This collection is only populated when the needed - i.e. when the respective layer list folder is expanded. When not
                         * needed, it's pulled out from the collection and from the dom. This has a slight insignificant penalty for smaller layer lists but a huge benefit for large ones
                         */
                        LayerListItem.prototype.refreshOnDemandItemCollection = function (expanded) {
                            var expandedState = (expanded == undefined) ? this.isExpanded.get() : expanded;
                            this.onDemandItemCollection.clear();
                            if (this.children && this.children.length()) {
                                if (expandedState) {
                                    for (var x = 0, len = this.children.length(); x < len; x++) {
                                        var child = this.children.getAt(x);
                                        if (this._notFolderOrContainsAtLeastOneChildLayer(child)) {
                                            this.onDemandItemCollection.addItem(child); // This approach seems more responsive than adding all items at one go.
                                        }
                                    }
                                }
                            }
                        };
                        /**
                        * Populates the containedMapServices array of any parent folder. This method must be invoked manually when needed.
                        */
                        LayerListItem.prototype.populateMapServicesInParentFolders = function () {
                            var _this = this;
                            if (this.type === infrastructure.layerList.LayerListItemType.FOLDER || !this.mapService) {
                                return;
                            }
                            var targetFolders = [];
                            var currParent = this.parent;
                            var noContainingFolder = true;
                            while (currParent) {
                                if (currParent.type === infrastructure.layerList.LayerListItemType.MAPSERVICE && currParent.mapService === this.mapService) {
                                    return; // If a mapServiceItem exists, we don't want to show either transparency sliders or handle mapService events within folders.
                                }
                                if (currParent.type === infrastructure.layerList.LayerListItemType.FOLDER) {
                                    noContainingFolder = false;
                                    if ((currParent.containedMapServices.indexOf(this.mapService) === -1) && (currParent.id.get().indexOf(this.layerList.id.get()) === -1)) {
                                        targetFolders.push(currParent);
                                    }
                                }
                                currParent = currParent.parent;
                            }
                            if (noContainingFolder) {
                                this.layerList._outOfFolderMapServiceReferences.push(this.mapService);
                            }
                            else {
                                dojo.forEach(targetFolders, function (folder) {
                                    folder.containedMapServices.push(_this.mapService);
                                });
                            }
                        };
                        /**
                         * Applies the previously deferred visibility (if any) to this item after the complete layer list model is set up and ready
                         */
                        LayerListItem.prototype._applyDeferredInitialVisibility = function () {
                            if (this._deferredVisibilitySetting == undefined || this.layerList.suspendMapUpdates) {
                                return;
                            }
                            var temp = this._deferredVisibilitySetting;
                            delete (this._deferredVisibilitySetting); // Deleting this param will activate the setVisibility function calls for the items
                            this.setVisibility(temp);
                        };
                        LayerListItem.prototype._setupOpacityBindings = function () {
                            var _this = this;
                            if (this.type === infrastructure.layerList.LayerListItemType.LAYER || this.type === infrastructure.layerList.LayerListItemType.GRAPHICSLAYER) {
                                return;
                            }
                            if (this.mapService && this.mapService.serviceLayer && this.mapService.serviceLayer.opacity != undefined && this.mapService.serviceLayer.setOpacity != undefined
                                && this.mapService.serviceType !== geocortex.essentials.MapServiceType.FEATURE /* GVH-4257 */) {
                                this.canAdjustOpacity.set(true);
                                this.opacity = new Observable(this.mapService.serviceLayer.opacity);
                                var adjustedOpacity = 1;
                                this.opacity.bind(this, function (opacity) {
                                    _this.mapService.setOpacity(opacity);
                                });
                                this._opacityChangeHandle = this.mapService.serviceLayer.on("opacity-change", function () { return _this.opacity.set(_this.mapService.opacity()); });
                            }
                        };
                        /** @private */
                        LayerListItem.prototype._notFolderOrContainsAtLeastOneChildLayer = function (item) {
                            if (item.type !== infrastructure.layerList.LayerListItemType.FOLDER) {
                                return true;
                            }
                            if (item.children && item.children.length()) {
                                for (var x = 0, len = item.children.length(); x < len; x++) {
                                    if (this._notFolderOrContainsAtLeastOneChildLayer(item.children.getAt(x))) {
                                        return true;
                                    }
                                }
                            }
                            return false;
                        };
                        /** @protected */
                        LayerListItem.prototype._handleLayerThemeChangingEvent = function (args) {
                            this._processLegendVisibility();
                        };
                        /** @protected */
                        LayerListItem.prototype._handleLayerThemeChangedEvent = function (args) {
                            this._processLegendVisibility();
                        };
                        LayerListItem.prototype._updateDisplayItem = function () {
                            this.displayItem.set(this.canDisplayItem.get() && this.inActiveTheme.get());
                            // If all but one item in an exclusive group are hidden, then make the single
                            // remaining item non-exclusive (i.e. render a checkbox next to it instead of
                            // a radio button). Similarly, when another item is displayed again, convert
                            // it back to an exclusive item.
                            var siblings = this.getSiblings(true);
                            if (siblings && siblings.length) {
                                var displayedSiblings = 0;
                                for (var i = 0; i < siblings.length; i++) {
                                    var sibling = siblings[i];
                                    if (sibling.displayItem.get()) {
                                        displayedSiblings++;
                                    }
                                }
                                for (var i = 0; i < siblings.length; i++) {
                                    var sibling = siblings[i];
                                    sibling.hasRadioToggle.set(sibling.isMutuallyExclusive.get() && displayedSiblings !== 1);
                                }
                            }
                        };
                        LayerListItem.prototype._onActiveThemeChanged = function (value) {
                            this._updateDisplayItem();
                            // Notify the parent that the active theme has changed so it can act accordingly.
                            var parent = this.parent;
                            if (parent && (parent.id !== this.layerList.id)) {
                                parent.notifyActiveThemeChanged(value);
                            }
                        };
                        LayerListItem.prototype._processLegendVisibility = function () {
                            if (this.layerList.onlyShowSwatchesOnVisibleLayers) {
                                this.legendIsVisible.set(this.isEffectivelyVisible.get() && this.inVisibleScaleRange.get() && !!this.legendItems.length() && !!this.legendSwatch.get());
                            }
                            else {
                                this.legendIsVisible.set(!!this.legendItems.length() && !!this.legendSwatch.get());
                            }
                            if (this.legendItems.length() == 1) {
                                this.expandLegend.set(false);
                            }
                        };
                        /**
                         * Set up the descriptive tooltips to include the name of the layer and to state whether the layer is in visible range.
                         * This is done for WCAG purposes.
                         */
                        LayerListItem.prototype._setTooltips = function () {
                            var _this = this;
                            var layerToggleDescription = this.layerList.appInfo.gcxApp.getResource(this.layerList._libraryId, "language-layerlist-toggle").format(this.name.get());
                            var layerActionsTooltipDescription = this.layerList.appInfo.gcxApp.getResource(this.layerList._libraryId, "language-layer-actions-tooltip").format(this.name.get());
                            var visibleScaleDescription = this.layerList.appInfo.gcxApp.getResource(this.layerList._libraryId, "language-layerlist-visible-at-extent");
                            var notVisibleScaleDescriptin = this.layerList.appInfo.gcxApp.getResource(this.layerList._libraryId, "language-layerlist-not-visible-at-extent");
                            var folderToggleTooltip = this.layerList.appInfo.gcxApp.getResource(this.layerList._libraryId, "language-layerlist-expand").format(this.name.get());
                            this.layerActionsTooltip.set(layerActionsTooltipDescription);
                            this.layerFolderToggleTooltip.set(folderToggleTooltip);
                            if (this.inVisibleScaleRange.get()) {
                                this.layerToggleTooltip.set(layerToggleDescription + " " + visibleScaleDescription);
                            }
                            else {
                                this.layerToggleTooltip.set(layerToggleDescription + " " + notVisibleScaleDescriptin);
                            }
                            this.inVisibleScaleRange.bind(this, function (isVisible) {
                                if (isVisible) {
                                    _this.layerToggleTooltip.set(layerToggleDescription + " " + visibleScaleDescription);
                                }
                                else {
                                    _this.layerToggleTooltip.set(layerToggleDescription + " " + notVisibleScaleDescriptin);
                                }
                            });
                        };
                        return LayerListItem;
                    }(layerList_1.LayerListNode));
                    layerList_1.LayerListItem = LayerListItem;
                })(layerList = infrastructure.layerList || (infrastructure.layerList = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/Essentials.d.ts" />
/// <reference path="LayerListItem.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var layerList;
                (function (layerList_2) {
                    /**
                     * A item in the layer list representing a folder in a KML service.
                     */
                    var LayerListKmlFolderItem = (function (_super) {
                        __extends(LayerListKmlFolderItem, _super);
                        /**
                         * Initializes a new instance of the {@link LayerListKmlFolderItem} class.
                         * @param id The unique ID for the item.
                         * @param layerList The layer list
                         * @param kmlLayer The {@link esri.layers.KMLLayer} object that contains the folder.
                         * @param kmlFolder The {@link esri.layers.KMLFolder} object that this layer list item is associated with.
                         */
                        function LayerListKmlFolderItem(id, layerList, kmlLayer, kmlFolder) {
                            _super.call(this, id, layerList_2.LayerListItemType.KMLFOLDER, layerList);
                            if (!kmlLayer) {
                                throw new Error("LayerListKmlFolderItem: Initialization failed. KML layer object cannot be null.");
                            }
                            if (!kmlFolder) {
                                throw new Error("LayerListKmlFolderItem: Initialization failed. KML folder object cannot be null.");
                            }
                            this._kmlLayer = kmlLayer;
                            this._kmlFolder = kmlFolder;
                            this.name = new Observable(kmlFolder.name);
                            this._setTooltips();
                            this.isVisible.set(!!kmlFolder.visibility);
                        }
                        /**
                         * Set the visibility of this item in the layer list. This is a special function which should be called in preference to setting isVisible directly, since
                         * it also keeps track of whether this item is the originator of the current user click.
                         */
                        LayerListKmlFolderItem.prototype.setItemVisibility = function (visible) {
                            _super.prototype.setItemVisibility.call(this, visible);
                            this._kmlLayer.setFolderVisibility(this._kmlFolder, visible);
                        };
                        return LayerListKmlFolderItem;
                    }(layerList_2.LayerListItem));
                    layerList_2.LayerListKmlFolderItem = LayerListKmlFolderItem;
                })(layerList = infrastructure.layerList || (infrastructure.layerList = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ArrayUtils = (function () {
                    function ArrayUtils() {
                    }
                    /**
                     * Sorts an array based on a particular property or function value.
                     */
                    ArrayUtils.sortBy = function (items, selector) {
                        items.sort(function (a, b) {
                            var aValue = selector(a);
                            var bValue = selector(b);
                            if (aValue == bValue) {
                                return 0;
                            }
                            return aValue < bValue ? -1 : 1;
                        });
                        return items;
                    };
                    /**
                     * Calculates the sum of all items based on a callback selector value.
                     */
                    ArrayUtils.sum = function (items, callback) {
                        var total = 0;
                        for (var i = 0; i < items.length; i++) {
                            total += callback(items[i]);
                        }
                        return total;
                    };
                    /**
                     * Calculates the maximum of all items based on a callback selector value.
                     */
                    ArrayUtils.max = function (items, callback) {
                        var max = null;
                        for (var i = 0; i < items.length; i++) {
                            var callbackResult = callback(items[i]);
                            if (max == null || max < callbackResult) {
                                max = callbackResult;
                            }
                        }
                        return max;
                    };
                    /**
                     * Similar to Array.map, except that any time that an item in the input causes the callback function to throw an error,
                     * an error handler will be invoked rather than aborting. These items will be skipped in the output, so unlike Array.map(),
                     * it's possible that the output array may contain a different number of items from the input.
                     */
                    ArrayUtils.mapWithErrorCallback = function (array, callback, errCallback, thisArg) {
                        if (typeof callback !== "function") {
                            throw new Error("Callback required.");
                        }
                        else if (typeof errCallback !== "function") {
                            throw new Error("Error callback required.");
                        }
                        if (!array) {
                            return array;
                        }
                        var result = [];
                        for (var i = 0; i < array.length; i++) {
                            var item = array[i];
                            try {
                                result.push(callback.call(thisArg, item, i, array));
                            }
                            catch (error) {
                                errCallback.call(thisArg, item, error, result);
                            }
                        }
                        return result;
                    };
                    return ArrayUtils;
                }());
                infrastructure.ArrayUtils = ArrayUtils;
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var Dictionary = (function () {
                    /**
                    An implementation of a dictionary. This is really similar to a plain old object
                    in JavaScript except that it's typed for TypeScript.
                    @class
                     */
                    function Dictionary() {
                        this._backingStore = {};
                    }
                    Dictionary.prototype.containsKey = function (key) {
                        return this._backingStore.hasOwnProperty(key);
                    };
                    Dictionary.prototype.get = function (key) {
                        return this._backingStore[key];
                    };
                    Dictionary.prototype.set = function (key, value) {
                        this._backingStore[key] = value;
                    };
                    Dictionary.prototype.remove = function (key) {
                        if (this.containsKey(key)) {
                            delete this._backingStore[key];
                            return true;
                        }
                        return false;
                    };
                    Dictionary.prototype.clear = function () {
                        this._backingStore = {};
                    };
                    Dictionary.prototype.values = function () {
                        var values = [];
                        for (var i in this._backingStore) {
                            if (this._backingStore.hasOwnProperty(i)) {
                                values.push(this._backingStore[i]);
                            }
                        }
                        return values;
                    };
                    Dictionary.prototype.keys = function () {
                        var keys = [];
                        for (var i in this._backingStore) {
                            if (this._backingStore.hasOwnProperty(i)) {
                                keys.push(i + "");
                            }
                        }
                        return keys;
                    };
                    return Dictionary;
                }());
                infrastructure.Dictionary = Dictionary;
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/Framework.d.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var results;
                (function (results) {
                    var ResultsViewModel = (function (_super) {
                        __extends(ResultsViewModel, _super);
                        // Set up the view model's initial state.
                        function ResultsViewModel(app, libraryId) {
                            _super.call(this, app, libraryId);
                            this._emptyFeatureSetCollection = null;
                            /** Stores binding event subscription tokens so we can unsubscribe later */
                            this._watchHandles = new infrastructure.Dictionary();
                            this.featureSetCollection = new Observable();
                            this.featureActions = new ObservableCollection();
                            this.currentFeature = new Observable();
                            this.hasFeatureSets = new Observable(false);
                            this.isBusy = new Observable(false);
                            /** Whether the feature set collection has been modified */
                            this.isModified = new Observable(false);
                            this.defaultIsPaged = true;
                            this.defaultPageSize = 50;
                            this.headerText = new Observable(this.app.getResource(this.libraryId, "language-common-results"));
                            this.searchSuggestion = new Observable(this.app.getResource(this.libraryId, "language-common-no-results-desc"));
                            this.featureSetCollection.bind(this, this.handleCollectionChanged);
                            this.registerCommands();
                            this.subscribeEvents();
                        }
                        ResultsViewModel.prototype.subscribeEvents = function () {
                            this.app.event("FSMCollectionOpenedEvent").subscribe(this, this._openFSC);
                            this.app.event("FSMCollectionClosedEvent").subscribe(this, this._closeFSC);
                            this.app.event("FSMCollectionRemovedEvent").subscribe(this, this._removeFSC);
                            this.app.event("FSMCollectionChangedEvent").subscribe(this, this._changeFSC);
                            this.app.event("FeatureEditedEvent").subscribe(this, this._pulseFeatureSetsInCollection);
                            this.app.event("FeatureDeletedEvent").subscribe(this, this._pulseFeatureSetsInCollection);
                            this.app.event("RelatedRecordEditedEvent").subscribe(this, this._pulseFeatureSetsInCollection);
                        };
                        ResultsViewModel.prototype.handleCollectionChanged = function (collection) {
                            var currCollection = collection && this.app.featureSetManager.getCollectionById(collection.id);
                            // Collection not in the feature set manager? Use the provided collection as is - if it's a valid collection object.
                            if (!currCollection && collection && collection.featureSets) {
                                currCollection = collection;
                            }
                            if (currCollection) {
                                this.isBusy.set(this.app.featureSetManager.isCollectionOpen(currCollection.id));
                                this.updateHeaderText(currCollection.countFeatures()); // GVH-10505 
                                this.hasFeatureSets.set(this._featureSetsHaveFeatures(currCollection.featureSets));
                                this._watchDisplayNameChanges();
                                this._watchIsModifiedChanges();
                            }
                            else {
                                this.isBusy.set(false);
                                this._unwatchDisplayNameChanges();
                                this._unwatchIsModifiedChanges();
                            }
                            if (this.presentableResults != null) {
                                this.presentableResults.numberOfItems.bind(this, this.updateHeaderText);
                            }
                        };
                        ResultsViewModel.prototype.handleFeatureSetsChanged = function (changedArgs) {
                            var featureSets = changedArgs.sender;
                            var hasFs = this._featureSetsHaveFeatures(featureSets);
                            if (this.hasFeatureSets.get() !== hasFs) {
                                this.hasFeatureSets.set(hasFs);
                            }
                        };
                        /** Updates the header text.  Can be overridden by subclasses. */
                        ResultsViewModel.prototype.updateHeaderText = function (count) {
                            var fscDisplayName = null;
                            var countString = "";
                            var modified = false;
                            var modificationIndicator = "*";
                            if (count) {
                                countString = " (" + count + ")";
                            }
                            if (this.featureSetCollection.get()) {
                                fscDisplayName = this.featureSetCollection.get().displayName.get();
                                modified = this.featureSetCollection.get().isModified.get();
                            }
                            // Save current count for later
                            this._count = count;
                            // Format display name; e.g. Search Results: Park (35)
                            var text = "{0}{1}{2}".format(fscDisplayName ? fscDisplayName : this.app.getResource(this.libraryId, "language-common-results"), countString, modified ? modificationIndicator : "");
                            this.headerText.set(text);
                        };
                        ResultsViewModel.prototype._featureSetsHaveFeatures = function (featureSets) {
                            if (featureSets) {
                                for (var i = 0; i < featureSets.length(); i++) {
                                    if ((featureSets.getAt(i).features && featureSets.getAt(i).features.length() > 0) ||
                                        (featureSets.getAt(i).esriFeatureSet && featureSets.getAt(i).esriFeatureSet.features &&
                                            featureSets.getAt(i).esriFeatureSet.features.length > 0)) {
                                        return true;
                                    }
                                }
                            }
                            return false;
                        };
                        ResultsViewModel.prototype._openFSC = function (args) {
                            if (this.featureSetCollection.get() && args && args.featureSetCollectionId && args.featureSetCollectionId == this.featureSetCollection.get().id) {
                                this.isBusy.set(true);
                                this.hasFeatureSets.set(false);
                                var searchSuggestion = this.app.featureSetManager.getSearchSuggestion(this.featureSetCollection.get().sourceName);
                                this.searchSuggestion.set(searchSuggestion ? searchSuggestion : this.app.getResource(this.libraryId, "language-common-no-results-desc"));
                            }
                        };
                        ResultsViewModel.prototype._closeFSC = function (args) {
                            if (this.featureSetCollection.get() && args && args.featureSetCollectionId && args.featureSetCollectionId == this.featureSetCollection.get().id) {
                                this.isBusy.set(false);
                            }
                            //GVH-3657: Need to pulse the collection on FSC close so all menu canExecute functions (if any) are re-evaluated with the final populated featureSetCollection.
                            this.featureSetCollection.pulse();
                        };
                        ResultsViewModel.prototype._removeFSC = function (args) {
                            if (this.featureSetCollection.get() && args && args.featureSetCollectionId && args.featureSetCollectionId == this.featureSetCollection.get().id) {
                                this.featureSetCollection.set(this._getEmptyFeatureSetCollection());
                            }
                        };
                        ResultsViewModel.prototype._changeFSC = function (args) {
                            if (this.featureSetCollection.get() && args && args.featureSetCollectionId && args.featureSetCollectionId == this.featureSetCollection.get().id) {
                                this.featureSetCollection.pulse();
                            }
                        };
                        ResultsViewModel.prototype._getEmptyFeatureSetCollection = function () {
                            if (this._emptyFeatureSetCollection == null) {
                                this._emptyFeatureSetCollection = new geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection();
                            }
                            else {
                                this._emptyFeatureSetCollection.clear(); // just in case
                            }
                            return this._emptyFeatureSetCollection;
                        };
                        ResultsViewModel.prototype.registerCommands = function () {
                            var _this = this;
                            this.app.command("ShowResultsListFeatureAction").register(this, function (feature) {
                                _this.currentFeature.set(feature);
                                _this.getResultsFeatureActions();
                                _this.app.command("ActivateView").execute("ResultsFeatureActionsView");
                            });
                            // GVH-10025:
                            // When a user-added layer is removed from the layer list, remove any of its features from the results list.
                            this.app.command("RemoveUserAddedLayer").register(this, function (gcxLayer) {
                                if (!_this.featureSetCollection.get()) {
                                    return;
                                }
                                var fs = _this.featureSetCollection.get().featureSets.get();
                                var newFSC = _this.featureSetCollection.get();
                                for (var i = 0; i < fs.length; i++) {
                                    if (fs[i].layer === gcxLayer) {
                                        newFSC.featureSets.removeItem(fs[i]);
                                        break;
                                    }
                                }
                                _this.featureSetCollection.set(newFSC);
                            });
                            this.app.command("ClearSelection").register(this, function () {
                                _this.app.command("RemoveFeatureSetCollection").execute(_this.featureSetCollection.get());
                            });
                        };
                        ResultsViewModel.prototype.getResultsFeatureActions = function () {
                            this.featureActions.clear();
                            var tempFeatureAction = this.app.menuRegistry.getMenu("ResultsListFeatureAction");
                            var defaultIconUri = this.app.menuRegistry.getDefaultIconUri("ResultsListFeatureAction");
                            if (tempFeatureAction) {
                                this.featureActions.addItems(tempFeatureAction.items);
                            }
                            else {
                                throw new Error("Results Feature Actions not found");
                            }
                        };
                        // Pulse feature set collection so the List/Table contents are updated. Note that we don't need to remove any empty featuresets from the collection 
                        // here (as we did previously) since the editor viewmodel takes care of that now whenever a feature is edited/ deleted.
                        ResultsViewModel.prototype._pulseFeatureSetsInCollection = function () {
                            if (this.featureSetCollection && this.featureSetCollection.get() && this.featureSetCollection.get().featureSets
                                && (this.featureSetCollection.get().featureSets.length() > 0)) {
                                this.featureSetCollection.get().featureSets.pulse();
                            }
                        };
                        ResultsViewModel.prototype._watchDisplayNameChanges = function () {
                            var _this = this;
                            // Destroy any previously bound handler
                            this._unwatchDisplayNameChanges();
                            // Watch for changes
                            var source = this.featureSetCollection.get() ? this.featureSetCollection.get().displayName : null;
                            if (!source) {
                                return null;
                            }
                            var token = source.bind(this, function () { return _this.updateHeaderText(_this._count); });
                            var handle = {
                                remove: function () { return source.unbind(token); }
                            };
                            this._watchHandles.set("displayName", handle);
                            return handle;
                        };
                        ResultsViewModel.prototype._unwatchDisplayNameChanges = function () {
                            var handle = this._watchHandles.get("displayName");
                            if (handle) {
                                handle.remove();
                            }
                            this._watchHandles.remove("displayName");
                        };
                        ResultsViewModel.prototype._watchIsModifiedChanges = function () {
                            var _this = this;
                            // Destroy any previously bound handler
                            this._unwatchIsModifiedChanges();
                            // Watch for changes
                            var source = this.featureSetCollection.get() ? this.featureSetCollection.get().isModified : null;
                            if (!source) {
                                return null;
                            }
                            var token = source.bind(this, function () { return _this.updateHeaderText(_this._count); });
                            var handle = {
                                remove: function () { return source.unbind(token); }
                            };
                            this._watchHandles.set("isModified", handle);
                            return handle;
                        };
                        ResultsViewModel.prototype._unwatchIsModifiedChanges = function () {
                            var handle = this._watchHandles.get("isModified");
                            if (handle) {
                                handle.remove();
                            }
                            this._watchHandles.remove("isModified");
                        };
                        return ResultsViewModel;
                    }(geocortex.framework.ui.ViewModelBase));
                    results.ResultsViewModel = ResultsViewModel;
                })(results = infrastructure.results || (infrastructure.results = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/Framework.d.ts" />
/// <reference path="../../../_Definitions/Framework.UI.d.ts" />
/// <reference path="./ResultsViewModel.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var results;
                (function (results_1) {
                    var FlatResultsViewModel = (function (_super) {
                        __extends(FlatResultsViewModel, _super);
                        /**
                         * FlatResultsViewModel flattens the feature set collections and presents the data as a single
                         * ObservableCollection.
                         */
                        function FlatResultsViewModel(app, libraryId) {
                            var _this = this;
                            _super.call(this, app, libraryId);
                            this.pageControlsEnabled = new Observable(false);
                            this.resultsList = new Observable("results-list");
                            this.pagingControlClassName = new Observable("paging-control no-pages");
                            this.contentField = new Observable("description");
                            this._featureSetsBindingToken = null;
                            this._boundFeatureSetCollection = null;
                            this._featureViewMap = {};
                            this.results = new geocortex.framework.ui.ObservableCollectionAggregator(new ObservableCollection());
                            this.presentableResults = new geocortex.framework.ui.PresentableCollection(this.results);
                            // GVH-5660: Use throttling on the presentable results collection so response time for populating the results table is reduced.
                            this.presentableResults.items.useThrottling = true;
                            this.resultsPage = this.presentableResults.items;
                            this.presentableResults.pageSize.set(this.defaultPageSize);
                            if (this.defaultIsPaged != this.presentableResults.isPaginated.get()) {
                                this.presentableResults.isPaginated.set(this.defaultIsPaged);
                            }
                            this.resultsPage.bind(this, this.handlePageResultsChange);
                            this.presentableResults.numberOfItems.bind(this, function (value) {
                                if (value > 0) {
                                    _this.pagingControlClassName.set("paging-control has-pages");
                                }
                                else {
                                    _this.pagingControlClassName.set("paging-control no-pages");
                                }
                                _this.updateHeaderText(value);
                            });
                            this.app.command("ShowResultsList").register(this, this.showResultsList);
                            this.app.command("SwitchToTabularResultsView").register(this, this._switchToTabularResultsViewImpl, this._canExecuteSwitchToTabularResultsView);
                        }
                        FlatResultsViewModel.prototype.subscribeEvents = function () {
                            _super.prototype.subscribeEvents.call(this);
                            this.app.event("FeatureChangedEvent").subscribe(this, this.handleFeatureChanged);
                        };
                        // If the featureset collection changes, Watch its FeatureSets for changes.
                        FlatResultsViewModel.prototype.handleCollectionChanged = function (collection) {
                            _super.prototype.handleCollectionChanged.call(this, collection);
                            this._clearResetUnderlyingCollection(true);
                            // collection.featureSets needs to defined; otherwise abort
                            if (!collection || !collection.featureSets) {
                                return;
                            }
                            // Watch for changes to the feature sets
                            this._featureSetsBindingToken = collection.featureSets.bind(this, this.handleFeatureSetsChanged);
                            this._boundFeatureSetCollection = collection;
                            // Add existing feature sets to our underlying collection (the one that feeds the presentable values)
                            var underlying = this.results.getCollectionSource();
                            for (var i = 0, len = collection.featureSets.length(); i < len; i++) {
                                underlying.addItem(collection.featureSets.getAt(i).features);
                            }
                        };
                        FlatResultsViewModel.prototype.handleFeatureSetsChanged = function (changedArgs) {
                            _super.prototype.handleFeatureSetsChanged.call(this, changedArgs);
                            var underlying = this.results.getCollectionSource();
                            if (changedArgs.type === "append") {
                                var newFSs = changedArgs.sender.getRange(changedArgs.rangeStart, changedArgs.rangeEnd);
                                for (var i = 0; i < newFSs.length; i++) {
                                    underlying.addItem(newFSs[i].features);
                                }
                            }
                            else if (changedArgs.type === "remove") {
                                var removedFSs = changedArgs.sender.getRange(changedArgs.rangeStart, changedArgs.rangeEnd);
                                for (var i = 0; i < removedFSs.length; i++) {
                                    underlying.removeItem(removedFSs[i].features);
                                }
                            }
                            else if (changedArgs.type === "clear") {
                                // Clear underlying collection but do not unbind from the collection.
                                this._clearResetUnderlyingCollection(false);
                                // Hack: Clearing the underlying collection of the ObservableCollectionAggregator doesn't fire binding event 
                                // hence invoking manually. Without this, if there's only one item in an identify and that feature is deleted,
                                // the results list still shows it since _itemsCollection is never cleared (is related to GVH - 2217)
                                this.results.bindingEvent.publish(changedArgs);
                            }
                        };
                        /**
                        * Handles changes in the Results Page.  This is intended to keep the FeatureViewMap from getting overloaded
                        * with deprecated views.
                        */
                        FlatResultsViewModel.prototype.handlePageResultsChange = function (changeArgs) {
                            var _this = this;
                            changeArgs = changeArgs ? changeArgs : { type: null };
                            if (changeArgs.type === "clear") {
                                // If we cleared the page, all the views will be re-determined, so it's time to clear the map as well
                                Object.keys(this._featureViewMap)
                                    .map(function (key) { return _this._featureViewMap[key]; })
                                    .forEach(function (view) { return _this.app.viewManager.destroyView(view); });
                                this._featureViewMap = {};
                            }
                            else if (changeArgs.type === "remove") {
                                // If we removed an element from the list, it's time to remove it from the map as well
                                if (changeArgs.sender.value.length > changeArgs.rangeStart) {
                                    var feature = changeArgs.sender.getAt(changeArgs.rangeStart);
                                    this._destroyViewForToken(feature.token);
                                    this._destroyViewForToken(feature.token + "-label");
                                }
                            }
                            // GVH-4164, GVH-9105
                            var isEmptyPage = changeArgs.type === "clear" || (changeArgs.type === "remove" && changeArgs.sender.value.length <= 1);
                            // GVH-3711 Raise event to notify handlers that the current page of results have changed
                            var args = new infrastructure.eventArgs.ResultsPageChangedEventArgs();
                            args.featureSetCollection = this.featureSetCollection.get();
                            args.newValue = isEmptyPage ? new ObservableCollection() : this.resultsPage;
                            this.app.event("ResultsPageChangedEvent").publish(args);
                        };
                        /**
                        * Handles a dataLink resolved event to update the display for the given feature.
                        * This was done so that tokens would be added asynchronously as they arrive
                        * @param context The feature that was updated
                        */
                        FlatResultsViewModel.prototype.handleFeatureChanged = function (context) {
                            if (!context || !this._featureViewMap.hasOwnProperty(context.token)) {
                                return;
                            }
                            // Get the current view for this feature
                            var descriptionView = this._featureViewMap[context.token];
                            var labelView = this._featureViewMap[context.token + "-label"];
                            // Dispose description + label views.
                            labelView.destroyBindings();
                            descriptionView.destroyBindings();
                            // Rebind
                            labelView.attach(context);
                            descriptionView.attach(context);
                        };
                        FlatResultsViewModel.prototype._destroyViewForToken = function (token) {
                            if (!token || !this._featureViewMap.hasOwnProperty(token)) {
                                return;
                            }
                            var view = this._featureViewMap[token];
                            if (!view) {
                                return;
                            }
                            // Remove the existing bindings
                            this.app.viewManager.destroyView(view);
                            delete this._featureViewMap[token];
                        };
                        FlatResultsViewModel.prototype.showResultsList = function (fsc) {
                            var featureSetCollection;
                            if (typeof fsc === "string") {
                                featureSetCollection = this.app.featureSetManager.getCollectionById(fsc);
                            }
                            else {
                                featureSetCollection = fsc;
                            }
                            if (featureSetCollection && featureSetCollection !== this.featureSetCollection.get()) {
                                this.unbindFeatureSet();
                                this.featureSetCollection.set(featureSetCollection);
                            }
                            else {
                                // GVH-5660: If the collection is the same and we're just switching views, invoke handlePageResultsChange to account for the potentially different pages in the two views
                                this.handlePageResultsChange();
                            }
                            // Set the results mapping to open the results list by default the next time this same source is invoked.
                            this.app.command("_setResultMappingCommand").execute(featureSetCollection.sourceName, "ShowResultsList");
                            this.presentableResults.numberOfItems.bind(this, this.updateHeaderText);
                        };
                        FlatResultsViewModel.prototype._switchToTabularResultsViewImpl = function () {
                            this.app.command("ShowResultsTable").execute(this.featureSetCollection.get());
                        };
                        FlatResultsViewModel.prototype._canExecuteSwitchToTabularResultsView = function () {
                            return !!this.featureSetCollection.get();
                        };
                        FlatResultsViewModel.prototype.getFeatureView = function (token) {
                            return this._featureViewMap[token];
                        };
                        FlatResultsViewModel.prototype.setFeatureView = function (token, view) {
                            this._featureViewMap[token] = view;
                        };
                        FlatResultsViewModel.prototype.unbindFeatureSet = function () {
                            if (this._featureSetsBindingToken && this._boundFeatureSetCollection) {
                                this._boundFeatureSetCollection.featureSets.unbind(this._featureSetsBindingToken);
                                this._featureSetsBindingToken = null;
                                this._boundFeatureSetCollection = null;
                            }
                        };
                        FlatResultsViewModel.prototype.exportState = function (resultsState) {
                            var results = this.featureSetCollection.get();
                            resultsState.results = this.app.project.convert.fromGcxFeatureSetCollection(results);
                            resultsState.page = this.presentableResults.currPageNumber.get();
                            resultsState.viewMode = "list";
                        };
                        FlatResultsViewModel.prototype.applyState = function (args) {
                            var _this = this;
                            args.promises.push(this.app.project.convert.toGcxFeatureSetCollection(args.state.results).then(function (results) {
                                if (!results) {
                                    return;
                                }
                                if (results !== _this.featureSetCollection.get()) {
                                    _this.unbindFeatureSet();
                                    _this.featureSetCollection.set(results);
                                }
                                if (!geocortex.framework.utils.isNullOrUndefined(args.state.page)) {
                                    _this.presentableResults.currPageNumber.set(args.state.page);
                                }
                                if (args.state.viewMode === "list") {
                                    // Set the results mapping to open the results table by default the next time this same source is invoked.
                                    _this.app.command("_setResultMappingCommand").execute(results.sourceName, "ShowResultsList");
                                }
                            }));
                        };
                        // Remember the page number when the feature set is pulsed due to a feature edited/deleted event
                        FlatResultsViewModel.prototype._pulseFeatureSetsInCollection = function () {
                            var currPage = this.presentableResults.currPageNumber.get();
                            _super.prototype._pulseFeatureSetsInCollection.call(this);
                            this.presentableResults.currPageNumber.set(currPage);
                        };
                        FlatResultsViewModel.prototype._clearResetUnderlyingCollection = function (unbindFeatureSet) {
                            // This indicates we've reset, as the collection changed. Set the current page to 1.
                            var underlying = this.results.getCollectionSource();
                            underlying.clear();
                            this.presentableResults.currPageNumber.set(1);
                            // Unbind the old feature set, before we bind the new one (otherwise we keep binding)
                            if (unbindFeatureSet) {
                                this.unbindFeatureSet();
                                // Since we just cleared the results, we will destroy the features views.
                                // This means we should reset the map, as we will reconstruct the views.
                                this._featureViewMap = {};
                            }
                        };
                        return FlatResultsViewModel;
                    }(results_1.ResultsViewModel));
                    results_1.FlatResultsViewModel = FlatResultsViewModel;
                })(results = infrastructure.results || (infrastructure.results = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/Framework.d.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var results;
                (function (results) {
                    var ResultsAttributeHeaderViewModel = (function () {
                        function ResultsAttributeHeaderViewModel(sharedState, attribute, type, index) {
                            this.sortState = new Observable(0);
                            this.sortClass = new Observable("");
                            this._sortingPredicate = null;
                            this._reverseSortingPredicate = null;
                            this.displayName = attribute.displayName;
                            this._sharedState = sharedState;
                            if (type === "DateTime") {
                                this._sortingPredicate = this.buildDateSortingFunction(index);
                                this._reverseSortingPredicate = this.buildReverseDateSortingFunction(index);
                            }
                            else {
                                this._sortingPredicate = this.buildSortingFunction(index);
                                this._reverseSortingPredicate = this.buildReverseSortingFunction(index);
                            }
                            this.sortClass.syncTransform(this.sortState, function (state) {
                                switch (state) {
                                    case 0:
                                        return sharedState.unsortedClass;
                                    case 1:
                                        return sharedState.sortedClass;
                                    case 2:
                                        return sharedState.reverseSortedClass;
                                }
                                return sharedState.unsortedClass;
                            });
                            this.sortState.bind(this, this.onSortStateChange);
                        }
                        ResultsAttributeHeaderViewModel.prototype.buildSortingFunction = function (index) {
                            return function (a, b) {
                                return geocortex.essentialsHtmlViewer.mapping.infrastructure.results.ResultsAttributeHeaderViewModel.collator(a.attributes.getAt(index).presentableValue.get(), b.attributes.getAt(index).presentableValue.get());
                            };
                        };
                        ResultsAttributeHeaderViewModel.prototype.buildReverseSortingFunction = function (index) {
                            return function (a, b) {
                                return geocortex.essentialsHtmlViewer.mapping.infrastructure.results.ResultsAttributeHeaderViewModel.collator(b.attributes.getAt(index).presentableValue.get(), a.attributes.getAt(index).presentableValue.get());
                            };
                        };
                        ResultsAttributeHeaderViewModel.prototype.buildDateSortingFunction = function (index) {
                            return function (a, b) {
                                var aVal = a.attributes.getAt(index).value.get();
                                var bVal = b.attributes.getAt(index).value.get();
                                var aDate = new Date(aVal);
                                var bDate = new Date(bVal);
                                var aIsDate = aDate != "Invalid Date";
                                var bIsDate = bDate != "Invalid Date";
                                if (aIsDate !== bIsDate) {
                                    return aIsDate ? -1 : 1;
                                }
                                else if (aIsDate) {
                                    return aDate.getTime() - bDate.getTime();
                                }
                                else {
                                    return geocortex.essentialsHtmlViewer.mapping.infrastructure.results.ResultsAttributeHeaderViewModel.collator(aVal, bVal);
                                }
                            };
                        };
                        ResultsAttributeHeaderViewModel.prototype.buildReverseDateSortingFunction = function (index) {
                            return function (b, a) {
                                var aVal = a.attributes.getAt(index).value.get();
                                var bVal = b.attributes.getAt(index).value.get();
                                var aDate = new Date(aVal);
                                var bDate = new Date(bVal);
                                var aIsDate = aDate != "Invalid Date";
                                var bIsDate = bDate != "Invalid Date";
                                if (aIsDate !== bIsDate) {
                                    return aIsDate ? -1 : 1;
                                }
                                else if (aIsDate) {
                                    return aDate.getTime() - bDate.getTime();
                                }
                                else {
                                    return geocortex.essentialsHtmlViewer.mapping.infrastructure.results.ResultsAttributeHeaderViewModel.collator(aVal, bVal);
                                }
                            };
                        };
                        ResultsAttributeHeaderViewModel.prototype.onSortStateChange = function (state) {
                            if (this._sharedState.ignoreStateChange) {
                                return;
                            }
                            if (state < 0 || state > 2) {
                                throw new Error("Illegal column sort state: " + state);
                            }
                            if (state == 0) {
                                if (this._sharedState.lastSortedColumn != this) {
                                    throw new Error("Column sort state out of sync");
                                }
                                this._sharedState.lastSortedColumn = null;
                                this._sharedState.presentableResults.sortingPredicate = null;
                                this._sharedState.presentableResults.unsortCollection();
                            }
                            else {
                                if (this._sharedState.lastSortedColumn != null && this._sharedState.lastSortedColumn != this) {
                                    this._sharedState.ignoreStateChange = true;
                                    this._sharedState.lastSortedColumn.sortState.set(0);
                                    this._sharedState.ignoreStateChange = false;
                                }
                                this._sharedState.lastSortedColumn = this;
                                if (state == 1) {
                                    this._sharedState.presentableResults.sortingPredicate = this._sortingPredicate;
                                }
                                else if (state == 2) {
                                    this._sharedState.presentableResults.sortingPredicate = this._reverseSortingPredicate;
                                }
                                else {
                                    throw new Error("Invalid column sort state.");
                                }
                                this._sharedState.presentableResults.sortCollection();
                            }
                        };
                        return ResultsAttributeHeaderViewModel;
                    }());
                    results.ResultsAttributeHeaderViewModel = ResultsAttributeHeaderViewModel;
                    var ResultsAttributeHeaderViewModel;
                    (function (ResultsAttributeHeaderViewModel) {
                        /**
                         * Manual comparison function. Slower than native.
                         */
                        ResultsAttributeHeaderViewModel.manualCollator = function (a, b) {
                            if (!isNaN(a) && !isNaN(b)) {
                                return +a - b;
                            }
                            if (a < b) {
                                return -1;
                            }
                            if (a > b) {
                                return 1;
                            }
                            return 0;
                        };
                        /**
                         * The fastest comparison function available.
                         */
                        ResultsAttributeHeaderViewModel.collator = typeof Intl == "object" && typeof Intl.Collator == "function"
                            ? new Intl.Collator(undefined, { numeric: true }).compare
                            : geocortex.essentialsHtmlViewer.mapping.infrastructure.results.ResultsAttributeHeaderViewModel.manualCollator;
                        /**
                         * Holds state shared between columns.
                         */
                        var SharedState = (function () {
                            function SharedState(presentableResults, unsortedClass, sortedClass, reverseSortedClass) {
                                this.lastSortedColumn = null;
                                this.presentableResults = presentableResults;
                                this.unsortedClass = unsortedClass;
                                this.sortedClass = sortedClass;
                                this.reverseSortedClass = reverseSortedClass;
                                this.reset();
                            }
                            SharedState.prototype.reset = function () {
                                this.ignoreStateChange = false;
                                this.lastSortedColumn = null;
                            };
                            return SharedState;
                        }());
                        ResultsAttributeHeaderViewModel.SharedState = SharedState;
                    })(ResultsAttributeHeaderViewModel = results.ResultsAttributeHeaderViewModel || (results.ResultsAttributeHeaderViewModel = {}));
                })(results = infrastructure.results || (infrastructure.results = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/Framework.d.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var results;
                (function (results) {
                    var ResultsFeatureActionsView = (function (_super) {
                        __extends(ResultsFeatureActionsView, _super);
                        function ResultsFeatureActionsView() {
                            _super.apply(this, arguments);
                        }
                        ResultsFeatureActionsView.prototype.handleMenuItemClick = function (event, element, context) {
                            context.execute(this.viewModel.currentFeature.get());
                        };
                        ResultsFeatureActionsView.prototype.handleGetDescription = function (event, element, context) {
                            element.title = context.description.get();
                        };
                        return ResultsFeatureActionsView;
                    }(geocortex.framework.ui.ViewBase));
                    results.ResultsFeatureActionsView = ResultsFeatureActionsView;
                })(results = infrastructure.results || (infrastructure.results = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/Framework.d.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var results;
                (function (results) {
                    var ResultsViewBase = (function (_super) {
                        __extends(ResultsViewBase, _super);
                        function ResultsViewBase(app, libraryId) {
                            var _this = this;
                            _super.call(this, app, libraryId);
                            this.isCollapsed = true;
                            this.isContainerCollapsed = true;
                            this._longPressTimer = null;
                            this._pressStartTime = null;
                            this._pressLengthMs = 1500;
                            this._firedTouchOrPress = false;
                            this._ignoreMouseEventFlag = false;
                            // Used by tablet/handheld to differentiate between a results click/press and a one-/two-finger scroll
                            this._pressYStart = null;
                            this._lastTouchY = null;
                            this._scrollYDeltaThreshold = 35;
                            this._firstEvent = null;
                            // Results views can be hosted within view containers. If that's the case, we need to 
                            // fire the appropriate events whenever a view container hosting this view is activated/deactivated.
                            this.app.event("ViewContainerActivatedEvent").subscribe(this, function (container) {
                                if (!_this.isCollapsed && _this._isViewHostedInContainer(container)) {
                                    _this.app.event("ResultsViewOpenedEvent").publish(_this);
                                    _this.isContainerCollapsed = false;
                                }
                            });
                            this.app.event("ViewContainerDeactivatedEvent").subscribe(this, function (container) {
                                if (!_this.isCollapsed && _this._isViewHostedInContainer(container)) {
                                    _this.app.event("ResultsViewCollapsedEvent").publish(_this);
                                    _this.isContainerCollapsed = true;
                                }
                            });
                            this.app.event("ViewContainerViewClosedEvent").subscribe(this, function (eventArgs) {
                                if (eventArgs.viewId === _this.id) {
                                    _this.app.event("ResultsViewClosedEvent").publish(_this);
                                    _this.isContainerCollapsed = true;
                                }
                            });
                        }
                        ResultsViewBase.prototype.activated = function () {
                            _super.prototype.activated.call(this);
                            this.isCollapsed = false;
                            this.app.event("ResultsViewOpenedEvent").publish(this);
                        };
                        ResultsViewBase.prototype.deactivated = function () {
                            _super.prototype.deactivated.call(this);
                            this.isCollapsed = true;
                            this.app.event("ResultsViewCollapsedEvent").publish(this);
                        };
                        ResultsViewBase.prototype.handleTouchStart = function (evt, el, ctx) {
                            if (!this._firstEvent) {
                                this._firstEvent = "touch start";
                                this._beginLongPress(ctx);
                            }
                            return true;
                        };
                        ResultsViewBase.prototype.handleTouchMove = function (evt, el, ctx) {
                            if (this._firstEvent === "touch start") {
                                this._firstEvent = null;
                                this._cancelLongPress();
                            }
                            return true;
                        };
                        ResultsViewBase.prototype.handleTouchEnd = function (evt, el, ctx) {
                            if (this._firstEvent === "touch start") {
                                this._firstEvent = null;
                                this._cancelLongPress();
                            }
                            return true;
                        };
                        ResultsViewBase.prototype.handleTouchCancel = function (evt, el, ctx) {
                            if (this._firstEvent === "touch start") {
                                this._firstEvent = null;
                                this._cancelLongPress();
                            }
                            return true;
                        };
                        ResultsViewBase.prototype.handleMouseDown = function (evt, el, ctx) {
                            if (!this._firstEvent) {
                                this._firstEvent = "mouse down";
                                this._beginLongPress(ctx);
                            }
                            return true;
                        };
                        ResultsViewBase.prototype.handleClick = function (evt, el, ctx) {
                            if (this._firstEvent) {
                                this._firstEvent = null;
                                this._cancelLongPress();
                            }
                            // GVH-4102: Allow bubbling for images contained within anchor tags that have their href attribute specified (ie images that are clickable).
                            var evtTarget = evt.target;
                            var isClickableImage = !!(evtTarget.tagName === "IMG" && evtTarget.parentElement && evtTarget.parentElement.tagName === "A" && evtTarget.parentElement.href);
                            if (evtTarget.tagName === "A" || isClickableImage) {
                                return true;
                            }
                            else {
                                this.app.command("ClearFeatureInformation").execute(); // GVH-1363 - Need to clear state information before opening new base feature.
                                this.app.event(this.featureClickedEventName).publish(ctx);
                            }
                            return false;
                        };
                        ResultsViewBase.prototype.handleMouseUp = function (evt, el, ctx) {
                            if (this._firstEvent === "mouse down") {
                                this._firstEvent = null;
                                this._cancelLongPress();
                            }
                            return true;
                        };
                        ResultsViewBase.prototype.handleMouseOut = function (evt, el, ctx) {
                            if (this._firstEvent === "mouse down") {
                                this._firstEvent = null;
                                this._cancelLongPress();
                            }
                        };
                        ResultsViewBase.prototype._beginLongPress = function (ctx) {
                            var _this = this;
                            if (this._longPressTimer) {
                                clearTimeout(this._longPressTimer);
                            }
                            this._longPressTimer = setTimeout(function () {
                                _this.app.event(_this.featurePressedEventName).publish(ctx);
                            }, this._pressLengthMs);
                        };
                        ResultsViewBase.prototype._cancelLongPress = function () {
                            if (this._longPressTimer) {
                                clearTimeout(this._longPressTimer);
                                this._longPressTimer = null;
                            }
                        };
                        /**
                         * If this view is hosted within a ViewContainer (and it's currently active), we want to notify listeners that
                         * the container has been activated or deactivated.
                         * NOTE: Child views hosted within a ViewContainerView are not activated/deactivated when the container is
                         * activated/deactivated so this gives someone a chance to know that a view has been "hidden" because its
                         * container was deactivated.
                         */
                        ResultsViewBase.prototype._isViewHostedInContainer = function (container) {
                            if (container instanceof geocortex.framework.ui.ViewContainer.ViewContainerView) {
                                var containerRegion = container.viewModel.regionName.get();
                                var region = this.app.viewManager.getRegionForViewId(this.id);
                                // If the view's region matches the container region, then fire the event to notify the visibility change.
                                if (region && region.name === containerRegion) {
                                    return true;
                                }
                            }
                            return false;
                        };
                        // Modified for GVH-2309 - to enable tabs to remember their vertical scroll positions
                        ResultsViewBase.prototype.scrollView = function (pos) {
                            if (this["scrollContainerElement"]) {
                                this["scrollContainerElement"].scrollTop = pos || 0;
                            }
                        };
                        return ResultsViewBase;
                    }(geocortex.framework.ui.ViewBase));
                    results.ResultsViewBase = ResultsViewBase;
                    ResultsViewBase.prototype.featureClickedEventName = "ResultsListFeatureClickedEvent";
                    ResultsViewBase.prototype.featurePressedEventName = "ResultsListFeaturePressedEvent";
                })(results = infrastructure.results || (infrastructure.results = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/Framework.d.ts" />
/// <reference path="./ResultsViewBase.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var results;
                (function (results) {
                    var ResultsListView = (function (_super) {
                        __extends(ResultsListView, _super);
                        function ResultsListView(app, libraryId) {
                            _super.call(this, app, libraryId);
                            this.featureClickedEventName = "ResultsListFeatureClickedEvent";
                            this.featurePressedEventName = "ResultsListFeaturePressedEvent";
                            // Stores event subscription tokens so we can unsubscribe later
                            this._subscriptions = null;
                            this._scrollTop = 0;
                            this.app.command("ShowResultsList").register(this, this.showResultsList);
                            // Auxilliary implementation for housekeeping/cleanup purposes. For main implementation see "TabbedResultsViewModel.ts"
                            this.app.command("ShowResultsTable").register(this, this._handleShowResultsTable);
                            // Auxilliary implementation for housekeeping/cleaning/canExecute purposes. For main  implementation see "FlatResultsViewModel.ts".
                            this.app.command("SwitchToTabularResultsView").register(this, this._switchToTabularResultsViewImpl, this._canExecuteSwitchToTabularResultsView);
                            this.app.command("_ExportResultsViewState").register(this, this._exportState);
                            this.app.command("_ApplyResultsViewState").register(this, this._applyState);
                        }
                        ResultsListView.prototype.activated = function () {
                            var _this = this;
                            _super.prototype.activated.call(this);
                            // GVH-3589 If the results list is hosted in the Data Frame, listen for data-frame events and 
                            // re-broadcast them as results list opened/collapsed events.
                            this._unsubscribeFromEvents();
                            if (this.regionName === "DataFrameResultsContainerRegion" || this.regionName === "DataRegion") {
                                var token1 = this.app.event("DataFrameOpenedEvent").subscribe(this, this._dataFrameOpenedEventHandler);
                                var token2 = this.app.event("DataFrameClosedEvent").subscribe(this, this._dataFrameClosedEventHandler);
                                // Keep track of event subscriptions so we can unsubscribe later.
                                this._subscriptions = [
                                    { eventName: "DataFrameOpenedEvent", token: token1 },
                                    { eventName: "DataFrameClosedEvent", token: token2 }
                                ];
                            }
                            // HACK ALERT!!! See GVH-1083. An iOS rendering issue has forced our hand here. The Results List's core UL element disappears
                            // when switching between views. Jiggling the "display" style causes the element to be re-rendered correctly.
                            if (this["resultsList"]) {
                                var ul = this["resultsList"];
                                setTimeout(function () {
                                    dojo.style(ul, {
                                        display: "block"
                                    });
                                }, 1);
                            }
                            this.viewModel.featureSetCollection.bind(this, function (featureSetCollection) {
                                _this.app.trace.debug("View focused in results list: " + _this.id);
                                // It's an allowed view, let's activate it.
                                _this.app.command("FocusOnFirstInputInView").execute(_this);
                            });
                        };
                        ResultsListView.prototype.deactivated = function () {
                            _super.prototype.deactivated.call(this);
                            this._unsubscribeFromEvents();
                        };
                        ResultsListView.prototype.attach = function (viewModel) {
                            var _this = this;
                            this.title.sync(viewModel.headerText);
                            this.isBusy.sync(viewModel.isBusy);
                            if (this.configuration["isPaged"] != undefined) {
                                viewModel.presentableResults.isPaginated.set(this.configuration["isPaged"]);
                            }
                            if (this.configuration["pageSize"]) {
                                viewModel.presentableResults.pageSize.set(this.configuration["pageSize"]);
                            }
                            if (this.configuration["contentField"]) {
                                viewModel.contentField.set(this.configuration["contentField"]);
                            }
                            viewModel.presentableResults.currPageNumber.bindingEvent.subscribe(this, function () {
                                _this.scrollViewTop();
                            });
                            this.scrollViewTop(this._scrollTop);
                            _super.prototype.attach.call(this, viewModel);
                        };
                        ResultsListView.prototype.showResultsList = function (fsc) {
                            this.app.viewManager.activateView(this);
                        };
                        ResultsListView.prototype.handlePageFirst = function (evt, el, ctx) {
                            if (this.viewModel.presentableResults.currPageNumber.get() > 1) {
                                this.viewModel.presentableResults.currPageNumber.set(1);
                            }
                        };
                        ResultsListView.prototype.handlePagePrev = function (evt, el, ctx) {
                            if (this.viewModel.presentableResults.currPageNumber.get() > 1) {
                                this.viewModel.presentableResults.currPageNumber.set(this.viewModel.presentableResults.currPageNumber.get() - 1);
                            }
                        };
                        ResultsListView.prototype.handlePageNext = function (evt, el, ctx) {
                            if (this.viewModel.presentableResults.lastPageNumber.get() > this.viewModel.presentableResults.currPageNumber.get()) {
                                this.viewModel.presentableResults.currPageNumber.set(this.viewModel.presentableResults.currPageNumber.get() + 1);
                            }
                        };
                        ResultsListView.prototype.handlePageLast = function (evt, el, ctx) {
                            if (this.viewModel.presentableResults.currPageNumber.get() < this.viewModel.presentableResults.lastPageNumber.get()) {
                                this.viewModel.presentableResults.currPageNumber.set(this.viewModel.presentableResults.lastPageNumber.get());
                            }
                        };
                        ResultsListView.prototype.handleScrollChange = function (evt, el, ctx) {
                            if (!ctx) {
                                return;
                            }
                            this._scrollTop = el.scrollTop;
                        };
                        ResultsListView.prototype.getDescription = function (evt, el, ctx) {
                            el.title = ctx.description.get();
                        };
                        ResultsListView.prototype.scrollViewTop = function (position) {
                            if (this["scrollContainerElement"]) {
                                this["scrollContainerElement"].scrollTop = position || 0;
                            }
                        };
                        ResultsListView.prototype.resolveWidget = function (widgetId, context, binding) {
                            _super.prototype.resolveWidget.call(this, widgetId, context);
                            switch (widgetId) {
                                case "GetLabel":
                                    var view = new infrastructure.FeatureDescriptionPresenterView(this.app, this.libraryId);
                                    view.contentField = "label";
                                    view.root = dojo.create("div");
                                    view.root.className = "feature-label";
                                    view.attach(context);
                                    this.viewModel.setFeatureView(context.token + "-label", view);
                                    return view;
                                case "GetDescription":
                                    var view = new infrastructure.FeatureDescriptionPresenterView(this.app, this.libraryId);
                                    view.contentField = this.viewModel.contentField.get();
                                    view.root = dojo.create("div");
                                    view.root.className = "feature-description";
                                    view.attach(context);
                                    this.viewModel.setFeatureView(context.token, view);
                                    return view;
                                case "ResultsListActionsWidget":
                                    var menuWidget = this.app.menuRegistry.createMenuWidget(this, context, binding);
                                    if (menuWidget) {
                                        return menuWidget;
                                    }
                                    break;
                                default:
                                    return undefined;
                            }
                        };
                        ResultsListView.prototype._handleShowResultsTable = function () {
                            this.app.viewManager.deactivateView(this);
                            // GVH-5660: This collection will now not be unbound when a user switches views. This results in the entire view needing to be rebound each a user keeps switches among the two views, which slows down the ux.
                            //this.viewModel.unbindFeatureSet();
                            //this.viewModel.featureSetCollection.set(this.viewModel._getEmptyFeatureSetCollection());
                        };
                        ResultsListView.prototype._switchToTabularResultsViewImpl = function () {
                            this.app.command("CloseDataFrame").execute();
                        };
                        ResultsListView.prototype._canExecuteSwitchToTabularResultsView = function () {
                            return this.isActive && !this.app.configuration.mobileMode;
                        };
                        /** Fire event only if the view container is active in the data frame */
                        ResultsListView.prototype._dataFrameOpenedEventHandler = function () {
                            if (!this.isContainerCollapsed) {
                                this.app.event("ResultsViewOpenedEvent").publish(this);
                            }
                        };
                        /** Fire event only if the view container is active in the data frame */
                        ResultsListView.prototype._dataFrameClosedEventHandler = function () {
                            if (!this.isContainerCollapsed) {
                                this.app.event("ResultsViewCollapsedEvent").publish(this);
                            }
                        };
                        /** Invokes the stored delegates to unsubscribe from events. */
                        ResultsListView.prototype._unsubscribeFromEvents = function () {
                            if (this._subscriptions) {
                                for (var i = 0; i < this._subscriptions.length; i++) {
                                    var sub = this._subscriptions[i];
                                    this.app.event(sub.eventName).unsubscribe(sub.token);
                                }
                            }
                            this._subscriptions = null;
                        };
                        ResultsListView.prototype._exportState = function (resultsState) {
                            if (!this.isActive) {
                                // Don't save anything if the view isn't active.
                                return;
                            }
                            this.viewModel.exportState(resultsState);
                        };
                        ResultsListView.prototype._applyState = function (args) {
                            this.viewModel.applyState(args);
                        };
                        return ResultsListView;
                    }(results.ResultsViewBase));
                    results.ResultsListView = ResultsListView;
                })(results = infrastructure.results || (infrastructure.results = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/Framework.d.ts" />
/// <reference path="../ui/components/Table/SortState.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var results;
                (function (results) {
                    var FeatureSetCollectionItem = (function () {
                        function FeatureSetCollectionItem() {
                        }
                        FeatureSetCollectionItem.prototype.toJSONString = function () {
                            return JSON.stringify({
                                "name": this.name,
                                "featureSet": this.featureSet.toJson()
                            });
                        };
                        return FeatureSetCollectionItem;
                    }());
                    ;
                    var ResultsModule = (function (_super) {
                        __extends(ResultsModule, _super);
                        function ResultsModule() {
                            _super.apply(this, arguments);
                            this._supportedFormats = ["csv", "xlsx", "shp"];
                            this._showInvisibleAttributes = false;
                        }
                        // Initializes this module.
                        ResultsModule.prototype.initialize = function (config) {
                            var _this = this;
                            _super.prototype.initialize.call(this, config);
                            if (config) {
                                this.resultMappings = config.resultMappings;
                                if (config.customSearchSuggestions) {
                                    this.app.featureSetManager.addSearchSuggestions(config.customSearchSuggestions);
                                }
                            }
                            if (config.showInvisibleAttributesOnExport) {
                                this._showInvisibleAttributes = config.showInvisibleAttributesOnExport;
                            }
                            this.wireUpResultMapping();
                            this.app.command("ExportResultsTo").register(this, function (obj) {
                                var exportFormat = "csv";
                                if (obj.fsc) {
                                    if (!obj.format) {
                                        _this.app.trace.warning("ExportResultsTo: file format not specified. Defaulting to csv.");
                                    }
                                    else {
                                        if (_this._supportedFormats.indexOf(obj.format) === -1) {
                                            _this.app.trace.warning("ExportResultsTo: {0} file format not recognized. Defaulting to csv.".format(obj.format));
                                        }
                                        else {
                                            exportFormat = obj.format;
                                        }
                                    }
                                    _this.exportTo({ fsc: obj.fsc, format: exportFormat });
                                }
                                else {
                                    _this.app.trace.error("ExportResultsTo: Cannot export, no feature set collection specified.");
                                }
                            }, this.exportToCanExecute);
                        };
                        ResultsModule.prototype.getStateFilter = function () {
                            var numberValidator = new infrastructure.validation.NumberValidator();
                            return {
                                featureSetCollections: {
                                    item: this.app.project.filter.featureSetCollection
                                },
                                results: this.app.project.filter.featureSetCollection,
                                viewMode: true,
                                page: numberValidator,
                                tableOptions: {
                                    selectedFeatureSet: this.app.project.filter.featureSet,
                                    sortColumn: numberValidator,
                                    sortDirection: true
                                }
                            };
                        };
                        ResultsModule.prototype.exportState = function () {
                            var _this = this;
                            var state = {
                                // Save the entire set of collections registered with the feature set manager.
                                featureSetCollections: this.app.featureSetManager.featureSetCollections.get().map(function (fsc) { return _this.app.project.convert.fromGcxFeatureSetCollection(fsc); })
                            };
                            // Save the state of the current results view, if there is one.
                            return Promise.try(function () {
                                _this.app.command("_ExportResultsViewState").execute(state);
                                return state;
                            });
                        };
                        ResultsModule.prototype.applyState = function (state) {
                            var _this = this;
                            // Restore feature set manager state.
                            return infrastructure.PromiseUtils.mapSkipRejected(state.featureSetCollections, function (fsc) { return _this.app.project.convert.toGcxFeatureSetCollection(fsc); })
                                .then(function () { return _this.app.waitUntilAllLibrariesLoaded(); })
                                .then(function () {
                                // Restore the results view(s). Each registered view will initialize itself from the passed-in data,
                                // adding a promise that will be fulfilled when the initialization is complete.
                                var applyResultsViewStateArgs = {
                                    state: state,
                                    promises: []
                                };
                                _this.app.command("_ApplyResultsViewState").execute(applyResultsViewStateArgs);
                                return Promise.all(applyResultsViewStateArgs.promises).return();
                            });
                        };
                        ResultsModule.prototype.wireUpResultMapping = function () {
                            this.app.event("FSMCollectionOpenedEvent").subscribe(this, this.fsmCollectionOpenedHandler);
                            // Internal command. Do not document
                            this.app.command("_setResultMappingCommand").register(this, this.fsmCollectionSetCommand);
                            // @deprecated since v2.4. This command should not be used anymore. 
                            this.app.command("FSMCollectionSetCommand").register(this, this.fsmCollectionSetCommand);
                        };
                        ResultsModule.prototype.fsmCollectionOpenedHandler = function (args) {
                            var fsc = args.featureSetCollection;
                            // Invoke the mapped command for the particular action
                            if (this.resultMappings) {
                                var resultCommandNameArray = this.resultMappings[fsc.sourceName];
                                if (resultCommandNameArray) {
                                    for (var i = 0; i < resultCommandNameArray.length; i++) {
                                        var resultCommandName = resultCommandNameArray[i];
                                        this.app.command(resultCommandName).execute(fsc.id);
                                        this._lastCommand = resultCommandName;
                                    }
                                }
                            }
                        };
                        ResultsModule.prototype.fsmCollectionSetCommand = function (sourceName, command) {
                            if (!command) {
                                return;
                            }
                            var replaceCommand = null;
                            if (command === "ShowResultsList") {
                                replaceCommand = "ShowResultsTable";
                            }
                            else if (command === "ShowResultsTable") {
                                replaceCommand = "ShowResultsList";
                            }
                            if (replaceCommand) {
                                if (this.resultMappings && this.resultMappings[sourceName]) {
                                    var commandMapping = this.resultMappings[sourceName];
                                    var indexToReplace = commandMapping.indexOf(replaceCommand);
                                    if (indexToReplace > -1) {
                                        commandMapping[indexToReplace] = command;
                                    }
                                    else {
                                        if (commandMapping.indexOf(command) === -1) {
                                            commandMapping.push(command);
                                        }
                                    }
                                }
                            }
                        };
                        ResultsModule.prototype.exportTo = function (params) {
                            var _this = this;
                            var args = new geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.AddStatusArgs(this.app.getResource(this.libraryId, "language-results-export-to-status-message").format(params.format));
                            var messageId = "exportTo " + params.format + "StatusMessage";
                            args.id = messageId;
                            args.showBusyIcon = true;
                            this.app.command("AddStatus").execute(args);
                            var siteUrl = this.app.site.url;
                            var restUrl = siteUrl.substring(0, siteUrl.toLowerCase().lastIndexOf("/sites/"));
                            var extractRestUrl = restUrl + "/Utilities/Extract";
                            geocortex.request({
                                url: extractRestUrl,
                                content: {
                                    "format": params.format,
                                    "featureSets": this.fscToJson(params.fsc),
                                    f: "json"
                                },
                                load: dojo.hitch(this, function (data) { return _this.exportToSuccess(data, params.format); }),
                                error: function (request) {
                                    _this.app.command("RemoveStatus").execute(messageId);
                                    _this.app.commandRegistry.command("Alert").execute(request.message, _this.app.getResource(_this.libraryId, "language-results-export-to-alert-error-message").format(params.format));
                                }
                            });
                        };
                        ResultsModule.prototype.exportToSuccess = function (data, format) {
                            var _this = this;
                            if (data && data.hasOwnProperty("href")) {
                                var downloadUrl = data.href;
                                var content = this.app.getResource(this.libraryId, "language-results-export-to-confirm-content").format(format);
                                var title = this.app.getResource(this.libraryId, "language-results-export-to-confirm-title").format(format);
                                var messageId = "exportTo " + format + "StatusMessage";
                                this.app.command("RemoveStatus").execute(messageId);
                                this.app.commandRegistry.command("Confirm").execute(content, title, function (ok) {
                                    if (ok) {
                                        if (_this.app.isNative.get()) {
                                            // GMAF
                                            window.open(downloadUrl, "_blank");
                                        }
                                        else {
                                            // Not GMAF
                                            window.location.assign(downloadUrl);
                                        }
                                    }
                                });
                            }
                        };
                        ResultsModule.prototype.exportToCanExecute = function (args) {
                            var fsc = null;
                            if (args) {
                                if (args instanceof infrastructure.FeatureSetCollection) {
                                    fsc = args;
                                }
                                else if (args.fsc && (args.fsc instanceof infrastructure.FeatureSetCollection)) {
                                    fsc = args.fsc;
                                }
                            }
                            return fsc && fsc.featureSets.get() && fsc.featureSets.get().length > 0;
                        };
                        ResultsModule.prototype.getFields = function (gcxFs) {
                            var esriFields = [];
                            if (gcxFs.esriFeatureSet && gcxFs.esriFeatureSet.features && gcxFs.esriFeatureSet.features.length > 0) {
                                esriFields = this.getFieldsFromEsriLayer(gcxFs.esriFeatureSet.features[0].getLayer(), gcxFs);
                            }
                            if (esriFields.length === 0) {
                                // Fields in the Geocortex format maybe available as well. We can easily convert those to the ESRI types.
                                if (gcxFs.layer && gcxFs.layer.fields && gcxFs.layer.fields.length > 0) {
                                    esriFields = this.getFieldsFromEssentialsLayer(gcxFs.layer);
                                }
                                else if (gcxFs.attributes.get() && gcxFs.attributes.get().length > 0) {
                                    // Information about the attribute's types may be available inside the Geocortex feature set 
                                    esriFields = this.getFieldsFromGcxFeatureSetAttributes(gcxFs.attributes.get(), gcxFs);
                                }
                                else if (gcxFs.features.get() && gcxFs.features.get().length > 0 &&
                                    gcxFs.features.getAt(0).attributes.get() && gcxFs.features.getAt(0).attributes.get().length > 0) {
                                    // Information about the attributes may be still available in the attributes of a single feature
                                    esriFields = this.getFieldsFromGcxFeatureAttributes(gcxFs.features.getAt(0).attributes.get(), gcxFs);
                                }
                                else {
                                    // This is the worst case scenario. We'll try to guess the types from the values.
                                    if (gcxFs.esriFeatureSet && gcxFs.esriFeatureSet.features && gcxFs.esriFeatureSet.features.length > 0 &&
                                        gcxFs.esriFeatureSet.features[0].attributes && gcxFs.esriFeatureSet.features[0].attributes.length > 0) {
                                        esriFields = this.getFieldsFromEsriFeatureAttributeValues(gcxFs.esriFeatureSet.features);
                                    }
                                    else if (gcxFs.features.get() && gcxFs.features.get().length > 0 &&
                                        gcxFs.features.getAt(0).attributes.get() && gcxFs.features.getAt(0).attributes.get().length > 0) {
                                        // Otherwise use features and attributes from the Geocortex feature set
                                        esriFields = this.getFieldsFromGcxFeatureAttributeValues(gcxFs.features.get());
                                    }
                                }
                            }
                            return esriFields;
                        };
                        ResultsModule.prototype.getFieldsFromEsriLayer = function (esriLayer, gcxFs) {
                            var tmpEsriFields = [];
                            // This is the best case scenario. We have an ESRI layer and the information about the fields
                            // are already stored in it in the format that we expect on the REST endpoint (with types in the ESRI format)
                            if (esriLayer && esriLayer.fields) {
                                tmpEsriFields = esriLayer.fields.slice(0);
                                // Since when exporting to CSV the name of the columns will be the field alias we might want to 
                                // change the alias of the fields so that it uses the display name that is what the user actually sees in the UI
                                if (gcxFs && gcxFs.features.get() && gcxFs.features.getAt(0).attributes.get()) {
                                    var gcxFeatureAttributes = gcxFs.features.getAt(0).attributes.get();
                                    if (gcxFeatureAttributes.length === tmpEsriFields.length) {
                                        gcxFeatureAttributes.forEach(function (attribute, index) {
                                            tmpEsriFields[index].alias = attribute.displayName.get() ? attribute.displayName.get() : tmpEsriFields[index].alias;
                                        });
                                    }
                                }
                            }
                            return tmpEsriFields;
                        };
                        ResultsModule.prototype.getFieldsFromEssentialsLayer = function (essentialsLayer) {
                            var tmpEsriFields = [];
                            var tmpField = new esri.layers.Field();
                            essentialsLayer.fields.forEach(function (field) {
                                tmpField = new esri.layers.Field();
                                tmpField.name = field.name;
                                tmpField.alias = field.displayName;
                                tmpField.type = geocortex.essentials.Field.convertToEsriFieldType(field.dataType);
                                tmpEsriFields.push(tmpField);
                            });
                            return tmpEsriFields;
                        };
                        ResultsModule.prototype.getFieldsFromGcxFeatureSetAttributes = function (gcxFeatureSetAttributes, gcxFs) {
                            var _this = this;
                            var tmpEsriFields = [];
                            var tmpField = new esri.layers.Field();
                            gcxFeatureSetAttributes.forEach(function (attribute, index) {
                                tmpField = new esri.layers.Field();
                                tmpField.name = attribute.name.get();
                                tmpField.alias = attribute.displayName.get();
                                if (attribute.type.get()) {
                                    tmpField.type = geocortex.essentials.Field.convertToEsriFieldType(attribute.type.get());
                                }
                                else if (gcxFs.features.get().length > 0 && gcxFs.features.getAt(0).attributes.get() &&
                                    gcxFs.features.getAt(0).attributes.get().length > 0) {
                                    // If we can't get the information about the types from the attribute type we try to guess the value
                                    // starting from the value of the features. 
                                    tmpField.type = _this.getTypeFromGcxFeatures(gcxFs.features.get(), index);
                                }
                                else {
                                    // This will give us a default of a type = string
                                    tmpField.type = _this.getEsriTypeFromValue(null);
                                }
                                tmpEsriFields.push(tmpField);
                            });
                            return tmpEsriFields;
                        };
                        ResultsModule.prototype.getFieldsFromGcxFeatureAttributes = function (gcxFeatureAttributes, gcxFs) {
                            var _this = this;
                            var tmpEsriFields = [];
                            var tmpField = new esri.layers.Field();
                            gcxFeatureAttributes.forEach(function (attribute, index) {
                                tmpField = new esri.layers.Field();
                                tmpField.name = attribute.name.get();
                                tmpField.alias = attribute.displayName.get();
                                if (attribute.type.get()) {
                                    tmpField.type = geocortex.essentials.Field.convertToEsriFieldType(attribute.type.get());
                                }
                                else {
                                    tmpField.type = _this.getTypeFromGcxFeatures(gcxFs.features.get(), index);
                                }
                                tmpEsriFields.push(tmpField);
                            });
                            return tmpEsriFields;
                        };
                        ResultsModule.prototype.getFieldsFromEsriFeatureAttributeValues = function (esriFeatures) {
                            var index = 0;
                            var tmpEsriFields = [];
                            var tmpField = new esri.layers.Field();
                            var esriFeatureAttributes = esriFeatures[0].attributes;
                            var esriFeatures = esriFeatures;
                            for (var name in esriFeatureAttributes) {
                                if (!esriFeatureAttributes.hasOwnProperty(name)) {
                                    continue;
                                }
                                tmpField = new esri.layers.Field();
                                tmpField.name = name;
                                tmpField.alias = name;
                                tmpField.type = this.getTypeFromEsriFeatures(esriFeatures, index);
                                tmpEsriFields.push(tmpField);
                                index++;
                            }
                            return tmpEsriFields;
                        };
                        ResultsModule.prototype.getFieldsFromGcxFeatureAttributeValues = function (gcxFeatures) {
                            var index = 0;
                            var tmpEsriFields = [];
                            var tmpField = new esri.layers.Field();
                            // Otherwise use features and attributes from the Geocortex feature set
                            var gcxFeatureAttributes = gcxFeatures[0].attributes.get();
                            var gcxFeatures = gcxFeatures;
                            for (var name in gcxFeatureAttributes) {
                                if (!gcxFeatureAttributes.hasOwnProperty(name)) {
                                    continue;
                                }
                                tmpField = new esri.layers.Field();
                                tmpField.name = name;
                                tmpField.alias = name;
                                tmpField.type = this.getTypeFromGcxFeatures(gcxFeatures, index);
                                tmpEsriFields.push(tmpField);
                                index++;
                            }
                            return tmpEsriFields;
                        };
                        ResultsModule.prototype.getTypeFromEsriFeatures = function (features, attributeIndex) {
                            var _this = this;
                            var esriType = this.getEsriTypeFromValue(null);
                            features.forEach(function (feature) {
                                var attributeValue = feature.attributes[attributeIndex];
                                if (attributeValue) {
                                    esriType = _this.getEsriTypeFromValue(attributeValue);
                                }
                            });
                            return esriType;
                        };
                        ResultsModule.prototype.getTypeFromGcxFeatures = function (features, attributeIndex) {
                            var _this = this;
                            var esriType = this.getEsriTypeFromValue(null);
                            features.forEach(function (feature) {
                                var attributeValue = feature.attributes.getAt(attributeIndex).value.get();
                                if (attributeValue) {
                                    esriType = _this.getEsriTypeFromValue(attributeValue);
                                }
                            });
                            return esriType;
                        };
                        ResultsModule.prototype.getEsriTypeFromValue = function (value) {
                            var type = "esriFieldTypeString";
                            if (typeof (value) === "number") {
                                type = "esriFieldTypeDouble";
                            }
                            else if (value instanceof Date) {
                                type = "esriFieldTypeDate";
                            }
                            return type;
                        };
                        ResultsModule.prototype.getFeatureSets = function (fsc) {
                            var _this = this;
                            var tmpFeatureSet = new esri.tasks.FeatureSet();
                            var tmpGraphic = new esri.Graphic();
                            var featureSets = [];
                            // Creates an handy list of esri feature sets with associated the name available in the feature set collection
                            // starting from the Geocortex feature set. This will facilitate the operation of serializing the feature set collection
                            // to send over to the server for the export operation.
                            fsc.featureSets.get().forEach(function (gcxFeatureSet, index) {
                                var esriFields = _this.getFields(gcxFeatureSet);
                                tmpFeatureSet = new esri.tasks.FeatureSet();
                                if (gcxFeatureSet && gcxFeatureSet.features.get() && gcxFeatureSet.features.get().length > 0) {
                                    var attributeNames = [];
                                    var forbiddenAttributeNames = [];
                                    gcxFeatureSet.features.getAt(0).attributes.get().forEach(function (featureAttribute) {
                                        var showAttribute = featureAttribute.visible.get() || _this._showInvisibleAttributes;
                                        if (showAttribute) {
                                            attributeNames.push(featureAttribute.name.get());
                                        }
                                        else {
                                            forbiddenAttributeNames.push(featureAttribute.name.get());
                                        }
                                    });
                                    gcxFeatureSet.features.get().forEach(function (feature) {
                                        var attributes = {};
                                        // Process feature attributes so that they reflect the esri field type
                                        var esriFeatureAttributes = feature.esriFeature.get().attributes;
                                        feature.getAttributes().forEach(function (featureAttribute) {
                                            var showAttribute = featureAttribute.visible.get() || _this._showInvisibleAttributes;
                                            if (showAttribute) {
                                                var attributeName = featureAttribute.name.get();
                                                var attributeValue = featureAttribute.presentableValue.get();
                                                // Get corresponding Esri Field Type
                                                var esriFieldType;
                                                for (var esriFieldIndex in esriFields) {
                                                    var esriField = esriFields[esriFieldIndex];
                                                    if (esriField.name === featureAttribute.name.get()) {
                                                        esriFieldType = esriField.type;
                                                        // If SEP has been enabled we would like to export the coded value as well other than
                                                        // the actual code in two different columns. The fields will have this information already,
                                                        // it's up to us to properly manage the list of attributes.
                                                        var relatedSEPCodedDomains = esriFields.filter(function (ef) {
                                                            return ef.name.indexOf(".Name()", ef.name.length - ".Name()".length) !== -1 && ef.name.substr(0, ef.name.length - ".Name()".length) === esriField.name;
                                                        });
                                                        if (relatedSEPCodedDomains && relatedSEPCodedDomains.length > 0) {
                                                            // The coded domain has been solved by SEP
                                                            var sepFieldName = relatedSEPCodedDomains[0].name; // This will have .Name() at the end
                                                            if (sepFieldName && esriFeatureAttributes && esriFeatureAttributes.hasOwnProperty(sepFieldName)) {
                                                                var esriFeatureAttributeCodedDomainSolvedValue = esriFeatureAttributes[esriField.name];
                                                                // The attribute we found had the coded value instead of the code.
                                                                // We want to swap the value back to the code since we are exporting both
                                                                var tmpSolvedValue = esriFeatureAttributeCodedDomainSolvedValue;
                                                                esriFeatureAttributeCodedDomainSolvedValue = attributeValue;
                                                                attributeValue = tmpSolvedValue;
                                                                // Add the field for sep solved coded domain so that can be included in the export
                                                                attributes[sepFieldName] = esriFeatureAttributeCodedDomainSolvedValue;
                                                            }
                                                        }
                                                        break;
                                                    }
                                                }
                                                if (attributeValue && attributeName) {
                                                    if (esriField.domain && esriField.domain.type == "codedValue") {
                                                        // Use the presentable value for coded domain fields.
                                                        esriField.type = geocortex.essentials.EsriFieldTypes.esriFieldTypeString;
                                                        attributes[attributeName] = featureAttribute.presentableValue.get();
                                                    }
                                                    else if (esriField.type === geocortex.essentials.EsriFieldTypes.esriFieldTypeDouble ||
                                                        esriField.type === geocortex.essentials.EsriFieldTypes.esriFieldTypeSingle) {
                                                        attributes[attributeName] = infrastructure.FormatUtils.parseNumber(featureAttribute.value.get());
                                                    }
                                                    else if (esriFieldType === geocortex.essentials.EsriFieldTypes.esriFieldTypeInteger ||
                                                        esriField.type === geocortex.essentials.EsriFieldTypes.esriFieldTypeSmallInteger) {
                                                        attributes[attributeName] = Math.floor(infrastructure.FormatUtils.parseNumber(featureAttribute.value.get()));
                                                    }
                                                    else if (esriFieldType === geocortex.essentials.EsriFieldTypes.esriFieldTypeDate) {
                                                        attributes[attributeName] = infrastructure.FormatUtils.parseDate(featureAttribute.value.get());
                                                    }
                                                    else {
                                                        attributes[attributeName] = attributeValue;
                                                    }
                                                }
                                            }
                                        });
                                        tmpFeatureSet.displayFieldName = gcxFeatureSet.esriFeatureSet.displayFieldName;
                                        tmpGraphic = new esri.Graphic(feature.esriFeature.get().geometry, null, attributes, null);
                                        tmpFeatureSet.features.push(tmpGraphic);
                                    });
                                }
                                else if (gcxFeatureSet && gcxFeatureSet.features.get().length > 0) {
                                    gcxFeatureSet.features.get().forEach(function (feature) {
                                        tmpGraphic = feature.esriFeature.get();
                                        tmpFeatureSet.features.push(tmpGraphic);
                                    });
                                }
                                if (tmpFeatureSet.features.length > 0) {
                                    if (esriFields && esriFields.length > 0) {
                                        // Even if the default type (esri feature set) doesn't contain the fields property we will insert one
                                        // Since it is required by the server to properly deserialize the feature set collection.
                                        var fieldsToAdd = [];
                                        esriFields.forEach(function (field) {
                                            if ($.inArray(field.name, forbiddenAttributeNames) == -1) {
                                                fieldsToAdd.push(field);
                                            }
                                        });
                                        tmpFeatureSet.fields = fieldsToAdd;
                                    }
                                    var fscItem = new FeatureSetCollectionItem();
                                    fscItem.name = fsc.featureSets.getAt(index).displayName.get();
                                    fscItem.featureSet = tmpFeatureSet;
                                    var duplicateNamesCounter = 0;
                                    featureSets.forEach(function (fsci) {
                                        if (fscItem.name === fsci.name) {
                                            duplicateNamesCounter = duplicateNamesCounter + 1;
                                        }
                                    });
                                    if (duplicateNamesCounter > 0) {
                                        fscItem.name = fscItem.name + duplicateNamesCounter;
                                    }
                                    featureSets.push(fscItem);
                                }
                            });
                            return featureSets;
                        };
                        ResultsModule.prototype.fscToJson = function (fsc) {
                            var featureSets = this.getFeatureSets(fsc);
                            var fscJson = "[";
                            featureSets.forEach(function (value, index, array) {
                                var featureSetCollectionItem = new FeatureSetCollectionItem();
                                featureSetCollectionItem.featureSet = value.featureSet;
                                featureSetCollectionItem.name = value.name;
                                fscJson += featureSetCollectionItem.toJSONString();
                                if (index !== array.length - 1) {
                                    fscJson += ",";
                                }
                            });
                            fscJson += "]";
                            return fscJson;
                        };
                        return ResultsModule;
                    }(geocortex.framework.application.ModuleBase));
                    results.ResultsModule = ResultsModule;
                })(results = infrastructure.results || (infrastructure.results = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/Framework.d.ts" />
/// <reference path="./ResultsViewBase.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var results;
                (function (results) {
                    var ResultsTableView = (function (_super) {
                        __extends(ResultsTableView, _super);
                        function ResultsTableView(app, libraryId) {
                            _super.call(this, app, libraryId);
                            this.featureClickedEventName = "ResultsTableFeatureClickedEvent";
                            this.featurePressedEventName = "ResultsTableFeaturePressedEvent";
                            this.scrollContainerElement = null;
                            this.tabContainerElement = null;
                            this.tabElements = null;
                            this.scrollTabLeftElement = null;
                            this.scrollTabRightElement = null;
                            this._fsBindingToken = null;
                            this._boundFs = null;
                            this.app.command("ShowResultsTable").register(this, this.showResultsTable);
                            // Auxilliary implementation for housekeeping/cleanup purposes. For main implementation see "FlatResultsViewModel.ts"
                            this.app.command("ShowResultsList").register(this, this._handleShowResultsList);
                            // Auxilliary implementation for housekeeping/cleanup/canExecute purposes. For main implementation see "TabbedResultsViewModel.ts"
                            this.app.command("SwitchToListResultsView").register(this, this._switchToListResultsViewImpl, this._canExecuteSwitchToListResultsView);
                            this.app.command("_ExportResultsViewState").register(this, this._exportState);
                            this.app.command("_ApplyResultsViewState").register(this, this._applyState);
                        }
                        ResultsTableView.prototype.attach = function (viewModel) {
                            var _this = this;
                            this.title.sync(viewModel.headerText);
                            this.isBusy.sync(viewModel.isBusy);
                            if (this.configuration["isPaged"] != undefined) {
                                viewModel.presentableResults.isPaginated.set(this.configuration["isPaged"]);
                            }
                            if (this.configuration["pageSize"]) {
                                viewModel.presentableResults.pageSize.set(this.configuration["pageSize"]);
                            }
                            viewModel.presentableResults.currPageNumber.bindingEvent.subscribe(this, function () {
                                var currFeat = _this.viewModel.curFeatureSet.get();
                                var scrollPos = currFeat ? (_this.viewModel.currScrollPosWithinTab[currFeat.uniqueId] || 0) : 0;
                                _this.scrollView(scrollPos);
                            });
                            _super.prototype.attach.call(this, viewModel);
                        };
                        ResultsTableView.prototype.resolveWidget = function (widgetId, context, binding) {
                            _super.prototype.resolveWidget.call(this, widgetId, context);
                            switch (widgetId) {
                                case "ResultsTableActionsWidget":
                                    return this.app.menuRegistry.createMenuWidget(this, context, binding);
                                case "TableViewWidget":
                                    var widgetContext = this.viewModel;
                                    var widgetView = this.app.viewManager.createView({
                                        typeName: "geocortex.essentialsHtmlViewer.mapping.infrastructure.ui.components.Table.TableView",
                                        markupResource: "Mapping/infrastructure/ui/components/Table/TableView.html",
                                        libraryId: this.libraryId,
                                        isVisible: true
                                    });
                                    if (widgetView) {
                                        var widgetVm = new geocortex.essentialsHtmlViewer.mapping.infrastructure.ui.components.Table.TableViewModel(this.app, this.libraryId);
                                        widgetVm.addRecordClickEvents(this.featureClickedEventName);
                                        widgetVm.addRecordLongPressEvents(this.featurePressedEventName);
                                        widgetVm.columnHeaders = this.viewModel.columnHeaders;
                                        widgetVm.attachToPresentableCollection(widgetContext.presentableResults);
                                        widgetView.attach(widgetVm);
                                        this.scrollContainerElement = widgetView.tableContainerElement;
                                    }
                                    return widgetView;
                                default:
                                    this.app.trace.warning("ResultsTableView: Unknown Widget");
                            }
                        };
                        ResultsTableView.prototype.showResultsTable = function (fsc) {
                            var _this = this;
                            this.app.viewManager.activateView(this);
                            if (this.viewModel.featureSetCollection.get()) {
                                this._unbindFromPrevFeatureSet();
                                this._boundFs = this.viewModel.featureSetCollection.get().featureSets;
                                if (this._boundFs) {
                                    this._fsBindingToken = this.viewModel.featureSetCollection.get().featureSets.bind(this, this._refreshTabControlVisibility);
                                }
                            }
                            var delayedExecuteToken = null;
                            var appResizedSubToken = this.app.event("ApplicationResizedEvent").subscribe(this, function () {
                                if (_this.isActive) {
                                    if (delayedExecuteToken) {
                                        clearTimeout(delayedExecuteToken);
                                        delayedExecuteToken = null;
                                    }
                                    delayedExecuteToken = setTimeout(function () {
                                        _this._refreshTabControlVisibility();
                                    }, 200);
                                }
                                else {
                                    _this.app.event("ApplicationResizedEvent").unsubscribe(appResizedSubToken);
                                    appResizedSubToken = null;
                                }
                            });
                            this._refreshTabControlVisibility();
                        };
                        ResultsTableView.prototype._refreshTabControlVisibility = function () {
                            var _this = this;
                            // GVH-6133: We'll need to give the DOM elements some time to render, specially if this is an append to the feature sets since we're using the offsetWidth of the tabElements and
                            // the containerElements. Execute this function within an appropriate timeout.
                            setTimeout(function () {
                                if (_this.tabContainerElement && _this.tabElements) {
                                    _this.viewModel.tabControlsEnabled.set(_this.tabElements.offsetWidth > _this.tabContainerElement.offsetWidth);
                                    _this._updateScrollTabDisabledStatus();
                                }
                            }, 100);
                        };
                        // Selects the current FS according to which UI tab has been selected by the user.
                        ResultsTableView.prototype.handleTabClick = function (evt, el, ctx) {
                            // Store the current vertical scroll position of the current tab in the view model
                            if (this.scrollContainerElement) {
                                this.viewModel.currScrollPosWithinTab[this.viewModel.curFeatureSet.get().uniqueId] = this.scrollContainerElement.scrollTop;
                            }
                            var filteredArr = dojo.filter(this.viewModel.featureSetCollection.get().featureSets.get(), function (item) {
                                return item.uniqueId === ctx.uniqueId;
                            });
                            if (filteredArr && filteredArr[0] && this.viewModel.curFeatureSet.get() !== filteredArr[0]) {
                                this.viewModel.setCurrentSelectedFeatureSet(filteredArr[0]);
                                this.viewModel.setCurrentPageWithinTab(ctx.uniqueId); // GVH-2309 - Remember current page no. within tab
                            }
                            this.app.command("FocusOnFirstInputInView").execute(this);
                        };
                        // TODO: Incorporate these controls into the widget with a single view and markup source shared by RelatedFeatures
                        // and DataLinks. (See GVH-7146.)
                        ResultsTableView.prototype.handlePageFirst = function (evt, el, ctx) {
                            if (this.viewModel.presentableResults.currPageNumber.get() > 1) {
                                this.viewModel.updateCurrentPageAndScrollPosWithinTab(1, 0); // GVH-2309
                                this.viewModel.presentableResults.currPageNumber.set(1);
                            }
                        };
                        ResultsTableView.prototype.handlePagePrev = function (evt, el, ctx) {
                            if (this.viewModel.presentableResults.currPageNumber.get() > 1) {
                                var page = this.viewModel.presentableResults.currPageNumber.get() - 1;
                                this.viewModel.updateCurrentPageAndScrollPosWithinTab(page, 0); // GVH-2309
                                this.viewModel.presentableResults.currPageNumber.set(page);
                            }
                        };
                        ResultsTableView.prototype.handlePageNext = function (evt, el, ctx) {
                            if (this.viewModel.presentableResults.lastPageNumber.get() > this.viewModel.presentableResults.currPageNumber.get()) {
                                var page = this.viewModel.presentableResults.currPageNumber.get() + 1;
                                this.viewModel.updateCurrentPageAndScrollPosWithinTab(page, 0); // GVH-2309
                                this.viewModel.presentableResults.currPageNumber.set(page);
                            }
                        };
                        ResultsTableView.prototype.handlePageLast = function (evt, el, ctx) {
                            if (this.viewModel.presentableResults.currPageNumber.get() < this.viewModel.presentableResults.lastPageNumber.get()) {
                                var page = this.viewModel.presentableResults.lastPageNumber.get();
                                this.viewModel.updateCurrentPageAndScrollPosWithinTab(page, 0); // GVH-2309
                                this.viewModel.presentableResults.currPageNumber.set(page);
                            }
                        };
                        ResultsTableView.prototype.handleTabScrollBack = function (evt, el, ctx) {
                            var tabContainer = $(this.tabContainerElement);
                            var targetPos = tabContainer.scrollLeft() - (this.scrollTabLeftElement.offsetWidth * 2);
                            tabContainer.scrollLeft((targetPos < 0) ? 0 : targetPos);
                            this._updateScrollTabDisabledStatus();
                        };
                        ResultsTableView.prototype.handleTabScrollForward = function (evt, el, ctx) {
                            var tabContainer = $(this.tabContainerElement);
                            var maxScrollOffset = this.tabContainerElement.scrollWidth - this.tabContainerElement.offsetWidth;
                            var targetPos = tabContainer.scrollLeft() + (this.scrollTabRightElement.offsetWidth * 2);
                            tabContainer.scrollLeft((targetPos > maxScrollOffset) ? maxScrollOffset : targetPos);
                            this._updateScrollTabDisabledStatus();
                        };
                        ResultsTableView.prototype.handleClickFeature = function (evt, el, ctx) {
                            this.app.event("ResultsTableFeatureClickedEvent").publish(ctx);
                        };
                        ResultsTableView.prototype.handleColumnHeadClick = function (evt, el, ctx) {
                            ctx.sortState.set((ctx.sortState.get() + 1) % 3);
                        };
                        ResultsTableView.prototype._handleShowResultsList = function () {
                            this.app.viewManager.deactivateView(this);
                            // GVH-5660: This collection will now not be unbound when a user switches views. This results in the entire view needing to be rebound each a user keeps switches among the two views, which slows down the ux.
                            //this.viewModel.unbindFeatureSet();
                            //this.viewModel.featureSetCollection.set(this.viewModel._getEmptyFeatureSetCollection());
                        };
                        ResultsTableView.prototype._switchToListResultsViewImpl = function () {
                            this.app.command("CloseBottomRegion").execute();
                        };
                        ResultsTableView.prototype._canExecuteSwitchToListResultsView = function () {
                            return this.isActive && !this.app.configuration.mobileMode;
                        };
                        ResultsTableView.prototype._updateScrollTabDisabledStatus = function () {
                            if (this.tabContainerElement) {
                                var maxScrollOffset = this.tabContainerElement.scrollWidth - this.tabContainerElement.offsetWidth;
                                this.viewModel.leftScrollTabDisabled.set(this.tabContainerElement.scrollLeft === 0);
                                this.viewModel.rightScrollTabDisabled.set(this.tabContainerElement.scrollLeft > maxScrollOffset - 1);
                            }
                        };
                        ResultsTableView.prototype._unbindFromPrevFeatureSet = function () {
                            if (this._fsBindingToken && this._boundFs) {
                                this._boundFs.unbind(this._fsBindingToken);
                            }
                            this._fsBindingToken = this._boundFs = null;
                        };
                        ResultsTableView.prototype._exportState = function (resultsState) {
                            if (!this.isActive) {
                                // Don't save anything if the view isn't active.
                                return;
                            }
                            this.viewModel.exportState(resultsState);
                        };
                        ResultsTableView.prototype._applyState = function (args) {
                            this.viewModel.applyState(args);
                        };
                        return ResultsTableView;
                    }(results.ResultsViewBase));
                    results.ResultsTableView = ResultsTableView;
                })(results = infrastructure.results || (infrastructure.results = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/Framework.d.ts" />
/// <reference path="../../../_Definitions/Framework.UI.d.ts" />
/// <reference path="./ResultsAttributeHeaderViewModel.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var results;
                (function (results_2) {
                    var ArrayUtils = geocortex.framework.utils.ArrayUtils;
                    var SortState = mapping.infrastructure.ui.components.Table.SortState;
                    var TabbedResultsViewModel = (function (_super) {
                        __extends(TabbedResultsViewModel, _super);
                        /**
                         * TabbedResultsViewModel leaves the feature set collections separate to be
                         * presented as tabs (or whatever).
                         */
                        function TabbedResultsViewModel(app, libraryId) {
                            _super.call(this, app, libraryId);
                            this.curFeatureSet = new Observable(null);
                            this.currPageWithinTab = {};
                            this.currScrollPosWithinTab = {};
                            this.presentableResults = new geocortex.framework.ui.PresentableCollection();
                            this.pageControlsEnabled = new Observable(false);
                            this.tabControlsEnabled = new Observable(false);
                            this.resultsTable = new Observable("results-table");
                            this.columnSharedState = null;
                            this.columnHeaders = new ObservableCollection([]);
                            this.leftScrollTabDisabled = new Observable(false);
                            this.rightScrollTabDisabled = new Observable(false);
                            // GVH-989: Used to control the first visible tab if no. of tabs exceed container width
                            this._firstVisibleTab = 0;
                            this._emptyFeatureSet = new geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSet({ "app": this.app });
                            this._boundFeatureSets = null;
                            this._featureSetsBindingToken = null;
                            // GVH-5660: Use throttling on the presentable results collection so response time for populating the results table is reduced.
                            this.presentableResults.items.useThrottling = true;
                            this.resultsPage = this.presentableResults.items;
                            this.presentableResults.pageSize.set(this.defaultPageSize);
                            if (this.defaultIsPaged != this.presentableResults.isPaginated.get()) {
                                this.presentableResults.isPaginated.set(this.defaultIsPaged);
                            }
                            this.curFeatureSet.bind(this, this.handleCurrentFeatureSetChanged);
                            this.presentableResults.numberOfItems.bind(this, this.updateHeaderText);
                            this.resultsPage.bind(this, this._handlePageResultsChange);
                            this.app.command("ShowResultsTable").register(this, this.showResultsTable);
                            this.app.command("SwitchToListResultsView").register(this, this._switchToListResultsViewImpl, this._canExecuteSwitchToListResultsView);
                        }
                        TabbedResultsViewModel.prototype.handleCollectionChanged = function (collection) {
                            _super.prototype.handleCollectionChanged.call(this, collection);
                            this.unbindFeatureSets();
                            // collection.featureSets needs to defined; otherwise abort
                            if (!collection || !collection.featureSets) {
                                return;
                            }
                            // Watch for changes to the feature sets
                            this._featureSetsBindingToken = collection.featureSets.bind(this, this.handleFeatureSetsChanged);
                            this._boundFeatureSets = collection.featureSets;
                            // Set the first tab as the first visible one and reset the last visible tab to null
                            this._firstVisibleTab = 0;
                            // Choose which feature set will be the current one.
                            var newCurFeatSet = null;
                            for (var i = 0; i < collection.featureSets.length(); i++) {
                                if (collection.featureSets.getAt(i).isSelectedInCollection.get()) {
                                    newCurFeatSet = collection.featureSets.getAt(i);
                                    break;
                                }
                            }
                            if (!newCurFeatSet && collection.featureSets.length() > 0) {
                                newCurFeatSet = collection.featureSets.getAt(0);
                            }
                            // If the new feature set is different, set it.
                            if (newCurFeatSet !== this.curFeatureSet.get()) {
                                this.setCurrentSelectedFeatureSet(newCurFeatSet);
                                // Reset the current page and scroll position tracker objects (GVH-2309)
                                this.currPageWithinTab = {};
                                this.currScrollPosWithinTab = {};
                            }
                        };
                        TabbedResultsViewModel.prototype.handleCurrentFeatureSetChanged = function (featureSet) {
                            this.presentableResults.sortingPredicate = null;
                            this.presentableResults.attachToCollection(featureSet.features);
                            this.buildColumnHeaders(featureSet);
                        };
                        TabbedResultsViewModel.prototype.handleFeatureSetsChanged = function (changedArgs) {
                            _super.prototype.handleFeatureSetsChanged.call(this, changedArgs);
                            var collection = changedArgs.sender;
                            // Check if we have at least one feature set.
                            if (changedArgs.type === "append") {
                                // If this is an append, and the appended element is 0, it is the first added. Set it as the current feature set.
                                // This only works because we can't append into slot 0. Inserts will need to be treated differently
                                if (changedArgs.rangeStart === 0) {
                                    this.setCurrentSelectedFeatureSet(collection.getAt(0));
                                }
                                // If any of the new feature sets are set as selected, choose the first one to 
                                // be the current feature set.
                                for (var i = changedArgs.rangeStart; i <= changedArgs.rangeEnd; i++) {
                                    if (collection.getAt(i).isSelectedInCollection.get()) {
                                        this.setCurrentSelectedFeatureSet(collection.getAt(i));
                                    }
                                }
                            }
                            else if (changedArgs.type === "remove") {
                                // Pick a new current feature set if the existing one is removed.
                                var currentFeatureSet = this.curFeatureSet.get();
                                if (currentFeatureSet) {
                                    var currentIndex = collection.indexOf(currentFeatureSet);
                                    if (currentIndex >= changedArgs.rangeStart && currentIndex <= changedArgs.rangeEnd) {
                                        if (changedArgs.rangeEnd + 1 < collection.length()) {
                                            // Pick the next feature set.
                                            this.setCurrentSelectedFeatureSet(collection.getAt(changedArgs.rangeEnd + 1));
                                        }
                                        else if (changedArgs.rangeStart > 0) {
                                            // Pick the previous feature set.
                                            this.setCurrentSelectedFeatureSet(collection.getAt(changedArgs.rangeStart - 1));
                                        }
                                        else {
                                            // No more feature sets. Clear the current feature set.
                                            this.setCurrentSelectedFeatureSet(null);
                                        }
                                    }
                                }
                            }
                        };
                        TabbedResultsViewModel.prototype.showResultsTable = function (fsc) {
                            var featureSetCollection;
                            if (typeof fsc === "string") {
                                featureSetCollection = this.app.featureSetManager.getCollectionById(fsc);
                            }
                            else {
                                featureSetCollection = fsc;
                            }
                            if (featureSetCollection) {
                                if (featureSetCollection !== this.featureSetCollection.get()) {
                                    this.unbindFeatureSets();
                                    this.featureSetCollection.set(featureSetCollection);
                                }
                                else {
                                    // GVH-5660: If the collection is the same and we're just switching views, invoke handlePageResultsChange to account for the potentially different pages in the two views
                                    this._handlePageResultsChange();
                                }
                                // Set the results mapping to open the results table by default the next time this same source is invoked.
                                this.app.command("_setResultMappingCommand").execute(featureSetCollection.sourceName, "ShowResultsTable");
                            }
                            // Reset the current page and scroll position tracker objects (GVH-2309)
                            this.currPageWithinTab = {};
                            this.currScrollPosWithinTab = {};
                        };
                        TabbedResultsViewModel.prototype._switchToListResultsViewImpl = function () {
                            this.app.command("ShowResultsList").execute(this.featureSetCollection.get());
                        };
                        TabbedResultsViewModel.prototype._canExecuteSwitchToListResultsView = function () {
                            return !!this.featureSetCollection.get();
                        };
                        // Set the current Feature Set, and in so doing, cause a rebinding (see below)
                        TabbedResultsViewModel.prototype.setCurrentSelectedFeatureSet = function (featureSet) {
                            var featureSets = this.featureSetCollection.get().featureSets;
                            for (var i = 0; i < featureSets.length(); i++) {
                                featureSets.getAt(i).isSelectedInCollection.set(featureSets.getAt(i) === featureSet);
                            }
                            if (featureSet) {
                                this.curFeatureSet.set(featureSet);
                            }
                        };
                        TabbedResultsViewModel.prototype.unbindFeatureSets = function () {
                            if (this._featureSetsBindingToken && this._boundFeatureSets) {
                                this._boundFeatureSets.unbind(this._featureSetsBindingToken);
                            }
                            this._boundFeatureSets = null;
                            this._featureSetsBindingToken = null;
                        };
                        TabbedResultsViewModel.prototype.buildColumnHeaders = function (featureSet) {
                            this.columnHeaders.clear();
                            if (!this.columnSharedState) {
                                this.columnSharedState = new geocortex.essentialsHtmlViewer.mapping.infrastructure.ui.components.Table.TableColumnHeaderViewModel.SharedState(this.presentableResults, "sort", "sort-up", "sort-down");
                            }
                            else {
                                this.columnSharedState.reset();
                            }
                            var i;
                            var types = {};
                            if (featureSet.layer && featureSet.layer.fields) {
                                for (i = 0; i < featureSet.layer.fields.length; i++) {
                                    var field = featureSet.layer.fields[i];
                                    types[field.name] = field.dataType;
                                }
                                ;
                            }
                            var attributesLength = featureSet.attributes.length();
                            if (!attributesLength) {
                                featureSet.loadAttributes();
                                attributesLength = featureSet.attributes.length();
                            }
                            for (i = 0; i < attributesLength; i++) {
                                var attribute = featureSet.attributes.getAt(i);
                                if (attribute.visible && !attribute.visible.get()) {
                                    continue;
                                }
                                this.columnHeaders.addItem(new geocortex.essentialsHtmlViewer.mapping.infrastructure.ui.components.Table.TableColumnHeaderViewModel(this.app, this.libraryId, this.columnSharedState, attribute.displayName.get(), types[attribute.name.get()], i));
                            }
                        };
                        // GVH-2309 - Set the current page number within this feature set to whatever page the user was on last
                        TabbedResultsViewModel.prototype.setCurrentPageWithinTab = function (featureSetId) {
                            if (this.currPageWithinTab[featureSetId]) {
                                if (this.currPageWithinTab[featureSetId] !== this.presentableResults.currPageNumber.get()) {
                                    this.presentableResults.currPageNumber.set(this.currPageWithinTab[featureSetId]);
                                }
                            }
                            else {
                                this.currPageWithinTab[featureSetId] = this.presentableResults.currPageNumber.get();
                            }
                        };
                        // GVH-2309 - Update the current page within given tab so users get back to where they left off
                        // Also, changing the page should reset scroll position to top of page (or whatever the user defines)
                        TabbedResultsViewModel.prototype.updateCurrentPageAndScrollPosWithinTab = function (page, pos) {
                            this.currScrollPosWithinTab[this.curFeatureSet.get().uniqueId] = pos;
                            this.currPageWithinTab[this.curFeatureSet.get().uniqueId] = page;
                        };
                        TabbedResultsViewModel.prototype.exportState = function (resultsState) {
                            // Save the results.
                            var results = this.featureSetCollection.get();
                            resultsState.results = this.app.project.convert.fromGcxFeatureSetCollection(results);
                            resultsState.viewMode = "table";
                            resultsState.page = this.presentableResults.currPageNumber.get();
                            // Save the selected tab and sort option.
                            var selectedFeatureSet = ArrayUtils.firstOrDefault(results.featureSets.get(), function (fs) { return fs.isSelectedInCollection.get(); });
                            if (selectedFeatureSet) {
                                resultsState.tableOptions = {
                                    selectedFeatureSet: this.app.project.convert.fromGcxFeatureSet(selectedFeatureSet)
                                };
                                var sortColumn = ArrayUtils.firstOrDefault(this.columnHeaders.get(), function (c) { return c.sortState.get() !== SortState.UNSORTED; });
                                if (sortColumn) {
                                    resultsState.tableOptions.sortColumn = this.columnHeaders.get().indexOf(sortColumn);
                                    resultsState.tableOptions.sortDirection = sortColumn.sortState.get() === SortState.ASCENDING ? "asc" : "desc";
                                }
                            }
                        };
                        TabbedResultsViewModel.prototype.applyState = function (args) {
                            var _this = this;
                            var promises = {
                                results: this.app.project.convert.toGcxFeatureSetCollection(args.state.results),
                                selectedFeatureSet: args.state.tableOptions ? this.app.project.convert.toGcxFeatureSet(args.state.tableOptions.selectedFeatureSet).catch(function (e) { }) : null
                            };
                            args.promises.push(Promise.props(promises).then(function (values) {
                                if (!values.results) {
                                    return;
                                }
                                // Restore results.
                                if (values.results !== _this.featureSetCollection.get()) {
                                    _this.unbindFeatureSets();
                                    _this.featureSetCollection.set(values.results);
                                }
                                if (args.state.viewMode === "table") {
                                    // Set the results mapping to open the results table by default the next time this same source is invoked.
                                    _this.app.command("_setResultMappingCommand").execute(values.results.sourceName, "ShowResultsTable");
                                }
                                // Restore selected tab.
                                var selectedFeatureSet = ArrayUtils.firstOrDefault(values.results.featureSets.get(), function (fs) { return fs === values.selectedFeatureSet; });
                                if (selectedFeatureSet) {
                                    _this.setCurrentSelectedFeatureSet(selectedFeatureSet);
                                    // Restore page.
                                    if (!geocortex.framework.utils.isNullOrUndefined(args.state.page)) {
                                        _this.updateCurrentPageAndScrollPosWithinTab(_this.presentableResults.currPageNumber.get(), 0);
                                        _this.presentableResults.currPageNumber.set(args.state.page);
                                    }
                                    // Restore sort options.
                                    if (!geocortex.framework.utils.isNullOrUndefined(args.state.tableOptions.sortColumn)) {
                                        var column = _this.columnHeaders.getAt(args.state.tableOptions.sortColumn);
                                        if (column) {
                                            column.sortState.set(args.state.tableOptions.sortDirection === "desc" ? SortState.DESCENDING : SortState.ASCENDING);
                                        }
                                    }
                                }
                            }));
                        };
                        TabbedResultsViewModel.prototype._handlePageResultsChange = function (changeArgs) {
                            changeArgs = changeArgs ? changeArgs : { type: null };
                            // GVH-4164, GVH-9105
                            var isEmptyPage = changeArgs.type === "clear" || (changeArgs.type === "remove" && changeArgs.sender.value.length <= 1);
                            // GVH-3711 Raise event to notify handlers that the current page of results have changed
                            var args = new infrastructure.eventArgs.ResultsPageChangedEventArgs();
                            args.featureSetCollection = this.featureSetCollection.get();
                            args.newValue = isEmptyPage ? new ObservableCollection() : this.resultsPage;
                            this.app.event("ResultsPageChangedEvent").publish(args);
                        };
                        return TabbedResultsViewModel;
                    }(results_2.ResultsViewModel));
                    results_2.TabbedResultsViewModel = TabbedResultsViewModel;
                })(results = infrastructure.results || (infrastructure.results = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/Framework.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var search;
                (function (search) {
                    var SearchHintItem = (function () {
                        /**
                         * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.search.SearchHintItem} class.
                         * @class
                         * The text that comes back from a search hint provider might have embedded markup.
                         * We bind these highlights to an items source on an autocomplete box.
                         * We however want the selection from the autocomplete to not contain
                         * embedded markup.
                         * That is the purpose of this class - to provide two views of the hints - with and without markup.
                         * @param text The text (with markup) to initialize
                         * @param options Optional parameter that sets the options for emphasizing text that might also contain unsafe HTML content.
                         */
                        function SearchHintItem(text, options) {
                            var _this = this;
                            /**
                             * The {@link Observable} icon URI associated with this search hint.
                             * Can be null if no icon is available.
                             * @observable
                             * @type {String}
                             */
                            this.iconUri = new Observable("");
                            // Unsafe HTML.
                            this.text = new Observable(text);
                            // Creating the sanitized plain-text version of the unsafe HTML.
                            this.plainText = new Observable("");
                            this.plainText.syncTransform(this.text, function (unsafe) {
                                return infrastructure.FilterUtils.stripHtml(unsafe);
                            });
                            // Creating the safely sanitized version of the unsafe HTML.
                            this.safeText = new Observable("");
                            this.safeText.syncTransform(this.text, function (unsafe) {
                                return _this.sanitizeText(unsafe);
                            });
                        }
                        SearchHintItem.prototype.sanitizeText = function (value) {
                            // SECURITY: HTML is sanitized. GVH-9760.
                            // Frames are not allowed.
                            // All URIs are allowed.
                            var filterOptions = {
                                allowFrames: false,
                                uriTransformer: function (uri) { return uri; }
                            };
                            return value ? infrastructure.FilterUtils.sanitize(value, filterOptions) : "";
                        };
                        SearchHintItem.prototype.toString = function () {
                            return this.plainText.get();
                        };
                        return SearchHintItem;
                    }());
                    search.SearchHintItem = SearchHintItem;
                })(search = infrastructure.search || (infrastructure.search = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var tools;
                (function (tools) {
                    var DrawMode = (function () {
                        function DrawMode() {
                        }
                        DrawMode.POINT = "POINT";
                        DrawMode.MULTI_POINT = "MULTI_POINT";
                        DrawMode.LINE = "LINE";
                        DrawMode.POLYGON = "POLYGON";
                        DrawMode.FREEHAND_POLYGON = "FREEHAND_POLYGON";
                        DrawMode.POLYLINE = "POLYLINE";
                        DrawMode.FREEHAND_POLYLINE = "FREEHAND_POLYLINE";
                        DrawMode.RECTANGLE = "RECTANGLE";
                        DrawMode.TRIANGLE = "TRIANGLE";
                        DrawMode.CIRCLE = "CIRCLE";
                        DrawMode.ELLIPSE = "ELLIPSE";
                        DrawMode.ARROW = "ARROW";
                        DrawMode.LEFT_ARROW = "LEFT_ARROW";
                        DrawMode.RIGHT_ARROW = "RIGHT_ARROW";
                        DrawMode.UP_ARROW = "UP_ARROW";
                        DrawMode.DOWN_ARROW = "DOWN_ARROW";
                        DrawMode.EXTENT = "EXTENT";
                        return DrawMode;
                    }());
                    tools.DrawMode = DrawMode;
                })(tools = infrastructure.tools || (infrastructure.tools = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../smartpanel/smartpanelviewmodel.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ui;
                (function (ui) {
                    var components;
                    (function (components) {
                        var MultiPane;
                        (function (MultiPane) {
                            var MultiPaneViewModel = (function (_super) {
                                __extends(MultiPaneViewModel, _super);
                                function MultiPaneViewModel() {
                                    _super.apply(this, arguments);
                                    /**
                                     * The collection of available pane items.
                                     */
                                    this.paneItems = new ObservableCollection();
                                    /**
                                     * The collection of pane items to display by default whenever the multi pane view is activated.
                                     */
                                    this.defaultPaneItems = new ObservableCollection();
                                    /**
                                     * The collection of pane items currently being displayed in the multi pane view.
                                     */
                                    this.displayedPaneItems = new ObservableCollection();
                                    /**
                                     * Whether the multi pane view is expanded (active).
                                     */
                                    this.expanded = new Observable(false);
                                    this.headerIsVisible = new Observable(true);
                                    this.showXButton = new Observable(true);
                                    this.selectorIconUri = new Observable("");
                                    this.selectorText = new Observable("");
                                }
                                MultiPaneViewModel.prototype.initialize = function (config) {
                                    _super.prototype.initialize.call(this, config);
                                    if (config) {
                                        if (config.hasOwnProperty("headerIsVisible")) {
                                            this.headerIsVisible.set(!!config.headerIsVisible);
                                        }
                                        if (config.hasOwnProperty("showXButton")) {
                                            this.showXButton.set(!!config.showXButton);
                                        }
                                        if (config.hasOwnProperty("selectorIconUri")) {
                                            this.selectorIconUri.set(config.selectorIconUri);
                                        }
                                        if (config.hasOwnProperty("selectorText")) {
                                            this.selectorText.set(config.selectorText);
                                        }
                                    }
                                };
                                MultiPaneViewModel.prototype.findPaneItemById = function (paneItemId) {
                                    return geocortex.framework.utils.ArrayUtils.firstOrDefault(this.paneItems.getItems(), function (x) { return x.id && x.id === paneItemId; });
                                };
                                MultiPaneViewModel.prototype.findDisplayedPaneItemById = function (paneItemId) {
                                    return geocortex.framework.utils.ArrayUtils.firstOrDefault(this.displayedPaneItems.getItems(), function (x) { return x.id && x.id === paneItemId; });
                                };
                                return MultiPaneViewModel;
                            }(geocortex.essentialsHtmlViewer.mapping.infrastructure.ui.components.SmartPanel.SmartPanelViewModel));
                            MultiPane.MultiPaneViewModel = MultiPaneViewModel;
                        })(MultiPane = components.MultiPane || (components.MultiPane = {}));
                    })(components = ui.components || (ui.components = {}));
                })(ui = infrastructure.ui || (infrastructure.ui = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ui;
                (function (ui) {
                    var components;
                    (function (components) {
                        var MultiPane;
                        (function (MultiPane) {
                            var PaneViewModel = (function (_super) {
                                __extends(PaneViewModel, _super);
                                function PaneViewModel() {
                                    _super.apply(this, arguments);
                                    /**
                                     * The panel item being displayed in this container view.
                                     */
                                    this.currentPaneItem = new Observable(null);
                                    this.headerIsVisible = new Observable(true);
                                    this.showXButton = new Observable(true);
                                }
                                PaneViewModel.prototype.initialize = function (config) {
                                    _super.prototype.initialize.call(this, config);
                                    if (config) {
                                        if (config.hasOwnProperty("headerIsVisible")) {
                                            this.headerIsVisible.set(!!config.headerIsVisible);
                                        }
                                        if (config.hasOwnProperty("showXButton")) {
                                            this.showXButton.set(!!config.showXButton);
                                        }
                                    }
                                };
                                PaneViewModel.prototype.onDestroy = function () {
                                    _super.prototype.onDestroy.call(this);
                                    this.currentPaneItem.set(null);
                                    this.currentPaneItem = null;
                                    this.app = null;
                                };
                                return PaneViewModel;
                            }(geocortex.framework.ui.ViewModelBase));
                            MultiPane.PaneViewModel = PaneViewModel;
                        })(MultiPane = components.MultiPane || (components.MultiPane = {}));
                    })(components = ui.components || (ui.components = {}));
                })(ui = infrastructure.ui || (infrastructure.ui = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="PaneViewModel.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ui;
                (function (ui) {
                    var components;
                    (function (components) {
                        var MultiPane;
                        (function (MultiPane) {
                            /**
                             * This class provides a single container view designed to host a pane.
                             */
                            var PaneView = (function (_super) {
                                __extends(PaneView, _super);
                                function PaneView() {
                                    _super.apply(this, arguments);
                                    this._isDestroyed = false;
                                }
                                /**
                                 * Clean up the pane item while destroying this view.
                                 */
                                PaneView.prototype.destroy = function () {
                                    _super.prototype.destroy.call(this);
                                    this._isDestroyed = true;
                                };
                                /**
                                 * Invoked when the pane is closed.
                                 * @event
                                 */
                                PaneView.prototype.onClose = function (paneItem) { };
                                PaneView.prototype.handleClickClose = function (evt, el, ctx) {
                                    if (this.viewModel && this.onClose) {
                                        this.onClose(this.viewModel.currentPaneItem.get());
                                    }
                                    if (!this._isDestroyed) {
                                        // Destroying via command is more extensible than directly via the ViewManager.
                                        this.app.command("DestroyView").execute(this.id);
                                    }
                                };
                                return PaneView;
                            }(geocortex.framework.ui.ViewBase));
                            MultiPane.PaneView = PaneView;
                        })(MultiPane = components.MultiPane || (components.MultiPane = {}));
                    })(components = ui.components || (ui.components = {}));
                })(ui = infrastructure.ui || (infrastructure.ui = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="MultiPaneViewModel.ts" />
/// <reference path="PaneView.ts" />
/// <reference path="../smartpanel/smartpanelview.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ui;
                (function (ui) {
                    var components;
                    (function (components) {
                        var MultiPane;
                        (function (MultiPane) {
                            var MultiPaneView = (function (_super) {
                                __extends(MultiPaneView, _super);
                                function MultiPaneView(app, libraryId) {
                                    _super.call(this, app, libraryId);
                                    this._panes = [];
                                    this.app.event("ApplicationResizedEvent").subscribe(this, this.handleApplicationResizedEvent);
                                    this.app.event("ViewDeactivatedEvent").subscribe(this, this.handleViewDeactivatedEvent);
                                }
                                /**
                                 * Called when the view has been activated.
                                 */
                                MultiPaneView.prototype.activated = function () {
                                    var _this = this;
                                    _super.prototype.activated.call(this);
                                    if (this.viewModel) {
                                        this.viewModel.expanded.set(true);
                                    }
                                    // GVH-4319: We have to wait until after the view is finished activation before resizing everything, as the region
                                    // hosting it may not be done laying things out until after. Simply deferring the resize to the end of the call queue works.
                                    setTimeout(function () {
                                        _this.handleApplicationResizedEvent();
                                    }, 0);
                                };
                                /**
                                 * Called when the view has been deactivated.
                                 */
                                MultiPaneView.prototype.deactivated = function () {
                                    _super.prototype.deactivated.call(this);
                                    if (this.viewModel) {
                                        this.viewModel.expanded.set(false);
                                    }
                                };
                                /**
                                 * Displays the default panes on the container view.
                                 * Only runs if no other panes are currently shown.
                                 */
                                MultiPaneView.prototype.addDefaultPanes = function () {
                                    if (this.viewModel.displayedPaneItems.getLength() > 0) {
                                        return;
                                    }
                                    for (var i = 0; i < this.viewModel.defaultPaneItems.getLength(); i++) {
                                        var paneItem = this.viewModel.defaultPaneItems.getAt(i);
                                        this.addPaneItem(paneItem);
                                    }
                                };
                                /**
                                 * Add a pane item with the specified ID to the layout by creating a new pane and loading the specified pane item.
                                 * @param paneItemId The ID of the pane item to add.
                                 */
                                MultiPaneView.prototype.addPaneItemById = function (paneItemId) {
                                    var paneItem = this.viewModel.findPaneItemById(paneItemId);
                                    this.addPaneItem(paneItem);
                                };
                                /**
                                 * Add a pane item to the layout by creating a new pane and loading the specified pane item.
                                 * @param paneItem The pane item to be added to the layout.
                                 */
                                MultiPaneView.prototype.addPaneItem = function (paneItem) {
                                    throw new Error("Not implemented");
                                };
                                MultiPaneView.prototype.canAddPaneItem = function (paneItem) {
                                    if (paneItem && this.viewModel) {
                                        return !this.viewModel.displayedPaneItems.contains(paneItem);
                                    }
                                    return false;
                                };
                                /**
                                 * Removes a pane item with the specified ID from the layout.
                                 * @param paneItemId The ID of the pane item to remove.
                                 */
                                MultiPaneView.prototype.destroyPaneItemById = function (paneItemId) {
                                    var paneItem = this.viewModel.findDisplayedPaneItemById(paneItemId);
                                    this.destroyPaneItem(paneItem);
                                };
                                /**
                                 * Remove a pane item from the layout.
                                 * @param paneItem The pane item to remove from the layout.
                                 */
                                MultiPaneView.prototype.destroyPaneItem = function (paneItem) {
                                    if (paneItem && this.canDestroyPaneItem(paneItem)) {
                                        var pane = this.findPaneForPaneItem(paneItem);
                                        if (!pane) {
                                            // TODO: WARNING
                                            return false;
                                        }
                                        this.viewModel.displayedPaneItems.removeItem(paneItem);
                                        this.selector.unselectItem(paneItem);
                                        this.app.command("DestroyView").execute(pane.id);
                                        // Close the multi pane view if we have no header and are not displaying items
                                        if (this.viewModel.displayedPaneItems.length() == 0 && !this.viewModel.headerIsVisible.get()) {
                                            this.app.command("DeactivateView").execute(this.id);
                                        }
                                        return true;
                                    }
                                    return false;
                                };
                                MultiPaneView.prototype.canDestroyPaneItem = function (paneItem) {
                                    if (paneItem && this.viewModel) {
                                        return this.viewModel.displayedPaneItems.contains(paneItem);
                                    }
                                    return false;
                                };
                                /**
                                 * Removes all pane items from the multi pane view.
                                 */
                                MultiPaneView.prototype.clearPaneItems = function () {
                                    var i = this.viewModel.displayedPaneItems.getLength();
                                    while (i--) {
                                        var paneItemToRemove = this.viewModel.displayedPaneItems.getAt(i);
                                        this.destroyPaneItem(paneItemToRemove);
                                    }
                                };
                                MultiPaneView.prototype.handleSelectPane = function (paneItem) {
                                    this.addPaneItem(paneItem);
                                };
                                MultiPaneView.prototype.handleUnSelectPane = function (paneItem) {
                                    this.destroyPaneItem(paneItem);
                                };
                                MultiPaneView.prototype.handleClickClose = function () {
                                    this.deactivateContainer();
                                };
                                MultiPaneView.prototype.handleApplicationResizedEvent = function () {
                                    if (!this.viewModel) {
                                        return;
                                    }
                                    var isStack = this.viewModel.regionType.get().indexOf("Stack") > -1;
                                    var multiPaneArea = this["scrollRegionElement"];
                                    var paneElements = $(".view .pane", multiPaneArea);
                                    if (!isStack || paneElements.length === 0) {
                                        return;
                                    }
                                    // Note: $(multiPaneArea).width() does not factor in the scrollbar.
                                    var width = multiPaneArea.clientWidth;
                                    var paneMarginHoriz = 5;
                                    var targetPaneWidth = (width / paneElements.length) - paneMarginHoriz;
                                    $(paneElements).width(targetPaneWidth);
                                };
                                MultiPaneView.prototype.handleViewDeactivatedEvent = function (view) {
                                    // Was a pane deactivated (or destroyed)? Re-layout.
                                    if (geocortex.framework.utils.ArrayUtils.firstOrDefault(this._panes, function (PaneView) { return view === PaneView; })) {
                                        geocortex.framework.utils.ArrayUtils.removeItem(this._panes, view);
                                        this.handleApplicationResizedEvent();
                                    }
                                };
                                MultiPaneView.prototype.findPaneForPaneItem = function (paneItem) {
                                    for (var i = 0; i < this._panes.length; i++) {
                                        var pane = this._panes[i];
                                        if (pane.viewModel.currentPaneItem.get() === paneItem) {
                                            return pane;
                                        }
                                    }
                                    return null;
                                };
                                MultiPaneView.prototype._executeShowMultiPaneView = function () {
                                    this.app.command("ActivateView").execute(this.id);
                                    this.addDefaultPanes();
                                    // Is the container view being activated and there are charts to display? Re-layout.
                                    if (this.viewModel.displayedPaneItems.getLength() > 0) {
                                        this.handleApplicationResizedEvent();
                                    }
                                };
                                return MultiPaneView;
                            }(geocortex.essentialsHtmlViewer.mapping.infrastructure.ui.components.SmartPanel.SmartPanelView));
                            MultiPane.MultiPaneView = MultiPaneView;
                        })(MultiPane = components.MultiPane || (components.MultiPane = {}));
                    })(components = ui.components || (ui.components = {}));
                })(ui = infrastructure.ui || (infrastructure.ui = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ui;
                (function (ui) {
                    var components;
                    (function (components) {
                        var Table;
                        (function (Table) {
                            /**
                             * Default view model for a {@link TableView}.
                             */
                            var TableColumnHeaderViewModel = (function () {
                                function TableColumnHeaderViewModel(app, libraryId, sharedState, displayName, type, index) {
                                    this.visible = new Observable(true);
                                    this.value = new Observable("");
                                    this.presentableValue = new Observable("");
                                    this.columnDescriptor = new Observable("");
                                    this.sortState = new Observable(Table.SortState.UNSORTED);
                                    this.sortClass = new Observable("");
                                    this._sortingPredicate = null;
                                    this._reverseSortingPredicate = null;
                                    this.app = app;
                                    this.libraryId = libraryId;
                                    this.value.set(displayName);
                                    this.presentableValue.set(displayName);
                                    this.columnDescriptor.set(this.app.getResource(this.libraryId, "language-ui-table-unsorted").format(this.presentableValue.get()));
                                    this._sharedState = sharedState;
                                    if (type === "DateTime") {
                                        this._sortingPredicate = this.buildDateSortingFunction(index);
                                        this._reverseSortingPredicate = this.buildReverseDateSortingFunction(index);
                                    }
                                    else {
                                        this._sortingPredicate = this.buildSortingFunction(index);
                                        this._reverseSortingPredicate = this.buildReverseSortingFunction(index);
                                    }
                                    this.sortClass.syncTransform(this.sortState, function (state) {
                                        switch (state) {
                                            case 0:
                                                return sharedState.unsortedClass;
                                            case 1:
                                                return sharedState.sortedClass;
                                            case 2:
                                                return sharedState.reverseSortedClass;
                                        }
                                        return sharedState.unsortedClass;
                                    });
                                    this.sortState.bind(this, this.onSortStateChange);
                                }
                                TableColumnHeaderViewModel.prototype.buildSortingFunction = function (index) {
                                    return function (a, b) {
                                        return geocortex.essentialsHtmlViewer.mapping.infrastructure.results.ResultsAttributeHeaderViewModel.collator(a.attributes.getAt(index).presentableValue.get(), b.attributes.getAt(index).presentableValue.get());
                                    };
                                };
                                TableColumnHeaderViewModel.prototype.buildReverseSortingFunction = function (index) {
                                    return function (a, b) {
                                        return geocortex.essentialsHtmlViewer.mapping.infrastructure.results.ResultsAttributeHeaderViewModel.collator(b.attributes.getAt(index).presentableValue.get(), a.attributes.getAt(index).presentableValue.get());
                                    };
                                };
                                TableColumnHeaderViewModel.prototype.buildDateSortingFunction = function (index) {
                                    return function (a, b) {
                                        var aVal = a.attributes.getAt(index).value.get();
                                        var bVal = b.attributes.getAt(index).value.get();
                                        var aDate = infrastructure.FormatUtils.parseDate(aVal);
                                        var bDate = infrastructure.FormatUtils.parseDate(bVal);
                                        var aIsDate = aDate != "Invalid Date";
                                        var bIsDate = bDate != "Invalid Date";
                                        if (aIsDate !== bIsDate) {
                                            return aIsDate ? -1 : 1;
                                        }
                                        else if (aIsDate) {
                                            return aDate.getTime() - bDate.getTime();
                                        }
                                        else {
                                            return geocortex.essentialsHtmlViewer.mapping.infrastructure.results.ResultsAttributeHeaderViewModel.collator(aVal, bVal);
                                        }
                                    };
                                };
                                TableColumnHeaderViewModel.prototype.buildReverseDateSortingFunction = function (index) {
                                    return function (b, a) {
                                        var aVal = a.attributes.getAt(index).value.get();
                                        var bVal = b.attributes.getAt(index).value.get();
                                        var aDate = infrastructure.FormatUtils.parseDate(aVal);
                                        var bDate = infrastructure.FormatUtils.parseDate(bVal);
                                        var aIsDate = aDate != "Invalid Date";
                                        var bIsDate = bDate != "Invalid Date";
                                        if (aIsDate !== bIsDate) {
                                            return aIsDate ? -1 : 1;
                                        }
                                        else if (aIsDate) {
                                            return aDate.getTime() - bDate.getTime();
                                        }
                                        else {
                                            return geocortex.essentialsHtmlViewer.mapping.infrastructure.results.ResultsAttributeHeaderViewModel.collator(aVal, bVal);
                                        }
                                    };
                                };
                                TableColumnHeaderViewModel.prototype.onSortStateChange = function (state) {
                                    if (this._sharedState.ignoreStateChange) {
                                        return;
                                    }
                                    if (state < Table.SortState.UNSORTED || state > Table.SortState.DESCENDING) {
                                        throw new Error("Illegal column sort state: " + state);
                                    }
                                    if (state == 0) {
                                        if (this._sharedState.lastSortedColumn != this) {
                                            throw new Error("Column sort state out of sync");
                                        }
                                        this._sharedState.lastSortedColumn = null;
                                        this._sharedState.presentableResults.sortingPredicate = null;
                                        this._sharedState.presentableResults.unsortCollection();
                                        this.columnDescriptor.set(this.app.getResource(this.libraryId, "language-ui-table-unsorted").format(this.presentableValue.get()));
                                    }
                                    else {
                                        if (this._sharedState.lastSortedColumn != null && this._sharedState.lastSortedColumn != this) {
                                            this._sharedState.ignoreStateChange = true;
                                            this._sharedState.lastSortedColumn.sortState.set(Table.SortState.UNSORTED);
                                            this._sharedState.ignoreStateChange = false;
                                        }
                                        this._sharedState.lastSortedColumn = this;
                                        if (state == Table.SortState.ASCENDING) {
                                            this._sharedState.presentableResults.sortingPredicate = this._sortingPredicate;
                                            this.columnDescriptor.set(this.app.getResource(this.libraryId, "language-ui-table-sorted-ascending").format(this.presentableValue.get()));
                                        }
                                        else if (state == Table.SortState.DESCENDING) {
                                            this._sharedState.presentableResults.sortingPredicate = this._reverseSortingPredicate;
                                            this.columnDescriptor.set(this.app.getResource(this.libraryId, "language-ui-table-sorted-descending").format(this.presentableValue.get()));
                                        }
                                        else {
                                            throw new Error("Invalid column sort state.");
                                        }
                                        this._sharedState.presentableResults.sortCollection();
                                    }
                                };
                                return TableColumnHeaderViewModel;
                            }());
                            Table.TableColumnHeaderViewModel = TableColumnHeaderViewModel;
                            var TableColumnHeaderViewModel;
                            (function (TableColumnHeaderViewModel) {
                                /**
                                 * Manual comparison function. Slower than native.
                                 */
                                TableColumnHeaderViewModel.manualCollator = function (a, b) {
                                    if (!isNaN(a) && !isNaN(b)) {
                                        return +a - b;
                                    }
                                    if (a < b) {
                                        return -1;
                                    }
                                    if (a > b) {
                                        return 1;
                                    }
                                    return 0;
                                };
                                /**
                                 * The fastest comparison function available.
                                 */
                                TableColumnHeaderViewModel.collator = typeof Intl == "object" && typeof Intl.Collator == "function"
                                    ? new Intl.Collator(undefined, { numeric: true }).compare
                                    : geocortex.essentialsHtmlViewer.mapping.infrastructure.results.ResultsAttributeHeaderViewModel.manualCollator;
                                /**
                                 * Holds state shared between columns.
                                 */
                                var SharedState = (function () {
                                    function SharedState(presentableResults, unsortedClass, sortedClass, reverseSortedClass) {
                                        this.lastSortedColumn = null;
                                        this.presentableResults = presentableResults;
                                        this.unsortedClass = unsortedClass;
                                        this.sortedClass = sortedClass;
                                        this.reverseSortedClass = reverseSortedClass;
                                        this.reset();
                                    }
                                    SharedState.prototype.reset = function () {
                                        this.ignoreStateChange = false;
                                        this.lastSortedColumn = null;
                                    };
                                    return SharedState;
                                }());
                                TableColumnHeaderViewModel.SharedState = SharedState;
                            })(TableColumnHeaderViewModel = Table.TableColumnHeaderViewModel || (Table.TableColumnHeaderViewModel = {}));
                        })(Table = components.Table || (components.Table = {}));
                    })(components = ui.components || (ui.components = {}));
                })(ui = infrastructure.ui || (infrastructure.ui = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ui;
                (function (ui) {
                    var components;
                    (function (components) {
                        var Table;
                        (function (Table) {
                            // ToDo: Sync with column headers somehow. Enforce that the number of columns headers matches the number of visible table columns
                            var TableColumnViewModelInterface = (function () {
                                function TableColumnViewModelInterface() {
                                }
                                return TableColumnViewModelInterface;
                            }());
                            Table.TableColumnViewModelInterface = TableColumnViewModelInterface;
                        })(Table = components.Table || (components.Table = {}));
                    })(components = ui.components || (ui.components = {}));
                })(ui = infrastructure.ui || (infrastructure.ui = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="./TableColumnViewModelInterface.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ui;
                (function (ui) {
                    var components;
                    (function (components) {
                        var Table;
                        (function (Table) {
                            // ToDo: Sync with column headers somehow. Enforce that the number of columns headers matches the number of visible table columns
                            var TableColumnHeaderViewModelInterface = (function (_super) {
                                __extends(TableColumnHeaderViewModelInterface, _super);
                                function TableColumnHeaderViewModelInterface() {
                                    _super.apply(this, arguments);
                                }
                                return TableColumnHeaderViewModelInterface;
                            }(Table.TableColumnViewModelInterface));
                            Table.TableColumnHeaderViewModelInterface = TableColumnHeaderViewModelInterface;
                        })(Table = components.Table || (components.Table = {}));
                    })(components = ui.components || (ui.components = {}));
                })(ui = infrastructure.ui || (infrastructure.ui = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ui;
                (function (ui) {
                    var components;
                    (function (components) {
                        var Table;
                        (function (Table) {
                            var TableView = (function (_super) {
                                __extends(TableView, _super);
                                function TableView() {
                                    _super.apply(this, arguments);
                                    /** The reference to the element containing this table */
                                    this.tableContainerElement = null;
                                    this._longPressTimer = null;
                                    this._pressStartTime = null;
                                    this._firedTouchOrPress = false;
                                    this._ignoreMouseEventFlag = false;
                                    // Used by tablet/handheld to differentiate between a results click/press and a one-/two-finger scroll
                                    this._pressYStart = null;
                                    this._lastTouchY = null;
                                    this._scrollYDeltaThreshold = 35;
                                    this._firstEvent = null;
                                }
                                TableView.prototype.handleColumnHeadClick = function (evt, el, ctx) {
                                    ctx.sortState.set((ctx.sortState.get() + 1) % 3);
                                };
                                TableView.prototype.handleMouseDown = function (evt, el, ctx) {
                                    this._beginLongPressIfNoEventsInProgress(ctx, "mouse-down");
                                    return true;
                                };
                                TableView.prototype.handleMouseUp = function (evt, el, ctx) {
                                    this._cancelLongPressIfEventInProgress("mouse-down");
                                    return true;
                                };
                                TableView.prototype.handleTouchStart = function (evt, el, ctx) {
                                    this._beginLongPressIfNoEventsInProgress(ctx, "touch-start");
                                    return true;
                                };
                                TableView.prototype.handleTouchMove = function (evt, el, ctx) {
                                    return this.handleTouchEnd(evt, el, ctx);
                                };
                                TableView.prototype.handleTouchEnd = function (evt, el, ctx) {
                                    this._cancelLongPressIfEventInProgress("touch-start");
                                    return true;
                                };
                                TableView.prototype.handleClick = function (evt, el, ctx) {
                                    var _this = this;
                                    if (this.viewModel && this.viewModel.recordClickEvents.length) {
                                        this.viewModel.recordClickEvents.forEach(function (entry) { return _this.app.event(entry).publish(ctx); });
                                    }
                                    return true;
                                };
                                TableView.prototype.handleClickAttributelink = function (event, element, attribute) {
                                    return this.app.followNavigationLink({ url: attribute.value.get(), element: element });
                                };
                                TableView.prototype._beginLongPressIfNoEventsInProgress = function (ctx, eventName) {
                                    if (!this._firstEvent) {
                                        this._firstEvent = eventName;
                                        this._beginLongPress(ctx);
                                    }
                                };
                                TableView.prototype._cancelLongPressIfEventInProgress = function (eventName) {
                                    if (this._firstEvent === eventName) {
                                        this._firstEvent = null;
                                        this._cancelLongPress();
                                    }
                                };
                                TableView.prototype._beginLongPress = function (ctx) {
                                    var _this = this;
                                    this._cancelLongPress();
                                    if (this.viewModel && this.viewModel.recordLongPressEvents.length) {
                                        this._longPressTimer = setTimeout(function () {
                                            _this.viewModel.recordLongPressEvents.forEach(function (entry) {
                                                _this.app.event(entry).publish(ctx);
                                            }, _this.viewModel.recordLongPressDuration || 1000);
                                        });
                                    }
                                };
                                TableView.prototype._cancelLongPress = function () {
                                    if (this._longPressTimer) {
                                        clearTimeout(this._longPressTimer);
                                        this._longPressTimer = null;
                                    }
                                };
                                return TableView;
                            }(geocortex.framework.ui.ViewBase));
                            Table.TableView = TableView;
                        })(Table = components.Table || (components.Table = {}));
                    })(components = ui.components || (ui.components = {}));
                })(ui = infrastructure.ui || (infrastructure.ui = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ui;
                (function (ui) {
                    var components;
                    (function (components) {
                        var Table;
                        (function (Table) {
                            /**
                             * Default view model for a {@link TableView}.
                             */
                            var TableViewModel = (function (_super) {
                                __extends(TableViewModel, _super);
                                /** @inherited */
                                function TableViewModel(app, libraryId) {
                                    _super.call(this, app, libraryId);
                                    /**
                                     * An observable collection of column headers for the table
                                     */
                                    this.columnHeaders = new ObservableCollection([]);
                                    /**
                                     * The various records (rows) contained in this table
                                     */
                                    this.records = new ObservableCollection([]);
                                    /**
                                     * The Presentable Collection, if any, backing this table. This is optional and a module may choose to manipulate the 'records' parameter directly as well.
                                     */
                                    this.presentableRecordCollection = null;
                                    /**
                                     * The events to fire when a particular record is clicked with the particular record as context parameter
                                     */
                                    this.recordClickEvents = [];
                                    /**
                                    * The events to fire when a particular record is pressed for a preset duration (1000ms default) with the particular record as context parameter
                                    */
                                    this.recordLongPressEvents = [];
                                    /**
                                     * The amount of time (in milliseconds) after which a press on a record is considered a long press. Defaults to 1000ms.
                                     */
                                    this.recordLongPressDuration = 1000;
                                }
                                /** Optional */
                                TableViewModel.prototype.attachToPresentableCollection = function (source) {
                                    if (source && (source instanceof geocortex.framework.ui.PresentableCollection)) {
                                        this.presentableRecordCollection = source;
                                        this.records = this.presentableRecordCollection.items;
                                    }
                                };
                                TableViewModel.prototype.addRecordClickEvents = function (eventName) {
                                    this._executeAddEvents(eventName, 0);
                                };
                                TableViewModel.prototype.addRecordLongPressEvents = function (eventName) {
                                    this._executeAddEvents(eventName, 1);
                                };
                                /**
                                 * Mode: 0 adds click events. Mode 1 adds long press events
                                 */
                                TableViewModel.prototype._executeAddEvents = function (eventName, mode) {
                                    var _this = this;
                                    var addEvent = function (entry) {
                                        if (entry && (typeof entry === "string")) {
                                            if (mode === 0) {
                                                _this.recordClickEvents = _this.recordClickEvents.filter(function (val) { return val !== entry; }); // Ensure no duplicates
                                                _this.recordClickEvents.push(entry);
                                            }
                                            else if (mode === 1) {
                                                _this.recordLongPressEvents = _this.recordLongPressEvents.filter(function (val) { return val !== entry; });
                                                _this.recordLongPressEvents.push(entry);
                                            }
                                        }
                                    };
                                    if (eventName && dojo.isArray(eventName)) {
                                        eventName.forEach(function (entry) { return addEvent(entry); });
                                    }
                                    else {
                                        addEvent(eventName);
                                    }
                                };
                                return TableViewModel;
                            }(geocortex.framework.ui.ViewModelBase));
                            Table.TableViewModel = TableViewModel;
                        })(Table = components.Table || (components.Table = {}));
                    })(components = ui.components || (ui.components = {}));
                })(ui = infrastructure.ui || (infrastructure.ui = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/bluebird.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var undo;
                (function (undo) {
                    /**
                     * An {@link UndoTransaction} is used to group one or more undo operations into a single item in the undo/redo history.
                     * Multiple undo operations can be added to a transaction's private stack. When a transaction is committed, the whole transaction
                     * will be pushed to the top of the undo stack of the {@link UndoManager}. Rolling back a transaction will invoke all contained
                     * undo operations, but they won't be pushed to the undo history of the {@link UndoManager}.
                     */
                    var UndoTransaction = (function () {
                        function UndoTransaction(owner, name, state) {
                            if (name === void 0) { name = "[anonymous]"; }
                            if (state === void 0) { state = {}; }
                            if (!owner) {
                                throw new Error("Transaction manager is required");
                            }
                            this.owner = owner;
                            this.displayName = name;
                            this.state = state;
                            this.transactionStatus = undo.TransactionStatus.PENDING;
                            this.changes = [];
                        }
                        /** Whether this is a top-level transaction. Top-level transactions have no parent and thus are not nested. */
                        UndoTransaction.prototype.isTopLevel = function () {
                            return !this.parentTransaction;
                        };
                        /** Whether we can add more undo operations to the list of changes for this transaction. */
                        UndoTransaction.prototype.isComplete = function () {
                            return this.isCommitted() || this.isAborted();
                        };
                        /** Whether this transaction was aborted (rolled back) */
                        UndoTransaction.prototype.isAborted = function () {
                            return this.transactionStatus == undo.TransactionStatus.ABORTED;
                        };
                        /** Whether this transaction was committed. */
                        UndoTransaction.prototype.isCommitted = function () {
                            return this.transactionStatus == undo.TransactionStatus.COMMITTED;
                        };
                        /**
                         * Records an undo operation as part of this transaction. Transactions are undone (or redone) as a single atomic operation.
                         * @param undoable The undo operation to record within this transaction.
                         */
                        UndoTransaction.prototype.add = function (name, undoable, state) {
                            if (state === void 0) { state = {}; }
                            if (!undoable || this.isComplete()) {
                                return;
                            }
                            // Wrap every operation in a transaction
                            var transaction;
                            if (undoable instanceof UndoTransaction) {
                                transaction = undoable;
                            }
                            else {
                                transaction = this._wrapInTransaction(name, undoable, state);
                            }
                            this.changes.push(transaction);
                        };
                        UndoTransaction.prototype._wrapInTransaction = function (name, undoable, state) {
                            if (state === void 0) { state = {}; }
                            // Make sure local state object is associated with undo operation
                            undoable.state = undoable.state || state;
                            var transaction = new UndoTransaction(this.owner, name);
                            transaction.transactionStatus = undo.TransactionStatus.PENDING;
                            transaction.parentTransaction = this;
                            transaction.changes.push(undoable);
                            return transaction;
                        };
                        /** Returns a boolean value indicating whether any undo operations have been recorded for this transaction. */
                        UndoTransaction.prototype.hasChanges = function () {
                            return this.changes.length > 0;
                        };
                        /** Commits the undo operation of this {@link UndoTransaction} */
                        UndoTransaction.prototype.commit = function () {
                            return this.owner.commitTransaction(this);
                        };
                        /** Rolls back (aborts) the transaction and calls the undo operations to recover the state before the {@link UndoTransaction} was created. */
                        UndoTransaction.prototype.rollback = function () {
                            return this.owner.rollbackTransaction(this);
                        };
                        /** Invokes the `performUndo` method for all contained {@link Undoable}s in the reverse of the order in which they were added. */
                        UndoTransaction.prototype.performUndo = function (state, transaction) {
                            var _this = this;
                            if (!this.hasChanges()) {
                                return Promise.resolve();
                            }
                            var reducer = function (_, current) {
                                if (current) {
                                    return current.performUndo(current.state, _this);
                                }
                            };
                            // Promise reduce guarantees that promises are executed sequentially and waits for the previous to settle before invoking the next one.
                            // Reverse mutates the source array so we need to create a copy with slice.
                            return Promise.reduce(this.changes.slice().reverse(), reducer, null);
                        };
                        /** Invokes the `performRedo` method for all contained {@link Undoable}s in the order in which they were added. */
                        UndoTransaction.prototype.performRedo = function (state, transaction) {
                            var _this = this;
                            if (!this.hasChanges()) {
                                return Promise.resolve();
                            }
                            var reducer = function (_, current) {
                                if (current) {
                                    return current.performRedo(current.state, _this);
                                }
                            };
                            // Promise reduce guarantees that promises are executed sequentially and waits for the previous to settle before invoking the next one.
                            return Promise.reduce(this.changes, reducer, null);
                        };
                        return UndoTransaction;
                    }());
                    undo.UndoTransaction = UndoTransaction;
                })(undo = infrastructure.undo || (infrastructure.undo = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var UrlUtils;
                (function (UrlUtils) {
                    /**
                     * Convert a dictionary of query parameters into a string.
                     * @param queryStrings The query string dictionary
                     * @return The string of all the query parameters
                     */
                    function queryStringDictionaryToString(queryStrings) {
                        var result = "";
                        if (!queryStrings) {
                            return result;
                        }
                        var keys = queryStrings.keys();
                        for (var i = 0; i < keys.length; i++) {
                            if (result.length > 0) {
                                result += "&";
                            }
                            result += "{0}={1}".format(keys[i], queryStrings.get(keys[i]));
                        }
                        // Return the string, inserting a question mark only if we had any query parameters
                        return "{0}{1}".format(result.length > 0 ? "?" : "", result);
                    }
                    UrlUtils.queryStringDictionaryToString = queryStringDictionaryToString;
                    /**
                     * Parses a URL query string into a dictionary of key/value pairs.
                     */
                    function queryStringToDictionary(queryString) {
                        var result = new infrastructure.Dictionary();
                        if (!queryString) {
                            return result;
                        }
                        // Stip off leading "?" if present.
                        if (queryString.startsWith("?")) {
                            queryString = queryString.slice(1);
                        }
                        queryString.split(/[&;]/g).forEach(function (keyValuePair) {
                            if (!keyValuePair) {
                                return;
                            }
                            var keyValueParts = keyValuePair.split("=", 2);
                            result.set(keyValueParts[0], keyValueParts[1]);
                        });
                        return result;
                    }
                    UrlUtils.queryStringToDictionary = queryStringToDictionary;
                    /**
                     * Parses a URL into its component parts.
                     * Note that the object returned from this method will suffer from quirks of IE. It's pathname will not have a leading '/',
                     * Unless we add it to a document. See https://connect.microsoft.com/IE/Feedback/Details/1002846
                     * @param url The URL to parse.
                     */
                    function parseUrl(url) {
                        var a = document.createElement("a");
                        a.href = url;
                        return a;
                    }
                    UrlUtils.parseUrl = parseUrl;
                    /**
                     * Adds (or updates) a query parameter in a URL.
                     * @param url The URL to add a parameter to.
                     * @param parameter The name of the query parameter to add. If it already exists, the value will be updated.
                     * @param value The value for the query parameter.
                     */
                    function addQueryParameter(url, parameter, value) {
                        var urlParts = parseUrl(url);
                        var queryParts = queryStringToDictionary(urlParts.search);
                        queryParts.set(parameter, value);
                        urlParts.search = queryStringDictionaryToString(queryParts);
                        return urlParts.toString();
                    }
                    UrlUtils.addQueryParameter = addQueryParameter;
                    /**
                     * Removes a query parameter from a URL, if it exists.
                     * @param url The URL to add a parameter to.
                     * @param parameter The name of the query parameter to remove.
                     */
                    function removeQueryParameter(url, parameter) {
                        var urlParts = parseUrl(url);
                        var queryParts = queryStringToDictionary(urlParts.search);
                        queryParts.remove(parameter);
                        urlParts.search = queryStringDictionaryToString(queryParts);
                        return urlParts.toString();
                    }
                    UrlUtils.removeQueryParameter = removeQueryParameter;
                    /**
                     * Gets the URL to the containing "folder" for the given URL. For exmple:
                     * getFolder("http://server.com/foo/bar/img.jpeg") -> "http://server.com/foo/bar/"
                     * getFolder("http://server.com/foo/bar") -> "http://server.com/foo/bar/"
                     * Note that the query string and fragment are discarded in the result.
                     * Note that the object returned from this method will suffer from quirks of IE. It's pathname will not have a leading '/',
                     * Unless we add it to a document. See https://connect.microsoft.com/IE/Feedback/Details/1002846
                     * @param url The URL to extract the folder from.
                     */
                    function getFolder(url) {
                        var result = typeof url === "string" ? parseUrl(url) : dojo.clone(url);
                        var pathname = result.pathname == null ? "" : result.pathname;
                        if (pathname == null) {
                            return result;
                        }
                        var pathParts = pathname.split("/");
                        var lastPart = pathParts[pathParts.length - 1];
                        if (lastPart.indexOf(".") >= 0) {
                            pathParts.pop();
                            result.pathname = pathParts.join("/");
                        }
                        if (!result.pathname.endsWith("/")) {
                            result.pathname = result.pathname + "/";
                        }
                        result.search = "";
                        result.hash = "";
                        // IE introduces ?#
                        // Moved fix of GVH-10205 in UrlUtils rather having it in caller.
                        result.href = result.href.replace(/[\?#]+$/, "");
                        return result;
                    }
                    UrlUtils.getFolder = getFolder;
                    /**
                     * Removes all query parameters from the url.
                     * Note that the query string and fragment are discarded in the result.
                     * Note that the object returned from this method will suffer from quirks of IE. It's pathname will not have a leading '/',
                     * Unless we add it to a document. See https://connect.microsoft.com/IE/Feedback/Details/1002846
                     * @param url The URL to extract the new url from which does not contain query parameters.
                     */
                    function removeParameters(url) {
                        var result = typeof url === "string" ? parseUrl(url) : dojo.clone(url);
                        var pathname = result.pathname == null ? "" : result.pathname;
                        if (pathname == null) {
                            return result;
                        }
                        if (!result.pathname.endsWith("/")) {
                            result.pathname = result.pathname + "/";
                        }
                        result.search = "";
                        result.hash = "";
                        // IE introduces ?#
                        // Moved fix of GVH-10205 in UrlUtils rather having it in caller.
                        result.href = result.href.replace(/[\?#]+$/, "");
                        return result;
                    }
                    UrlUtils.removeParameters = removeParameters;
                })(UrlUtils = infrastructure.UrlUtils || (infrastructure.UrlUtils = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var validation;
                (function (validation) {
                    /**
                     * Validates that a value is a number. The context may specify a flag "invalidNumbersAsNaN", in which
                     * case values that aren't numbers will be converted to NaN instead of being rejected.
                     */
                    var NumberValidator = (function () {
                        function NumberValidator() {
                        }
                        NumberValidator.prototype.validate = function (value, context) {
                            var invalidAsNaN = context && !!context.invalidNumbersAsNaN;
                            var result = infrastructure.FormatUtils.parseNumber(value);
                            if (geocortex.framework.utils.isNullOrUndefined(value)) {
                                return Promise.resolve({ validatedValue: value });
                            }
                            return isNaN(result) && !invalidAsNaN ? Promise.reject(new Error("Invalid number.")) : Promise.resolve({ validatedValue: result });
                        };
                        return NumberValidator;
                    }());
                    validation.NumberValidator = NumberValidator;
                })(validation = infrastructure.validation || (infrastructure.validation = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var validation;
                (function (validation) {
                    /**
                     * Validator which sanitizes HTML content to eliminate XSS (cross-site scripting) security risks.
                     * This validator has some special functionality surrounding the handling of URIs as they are sanitized:
                     *  - When the HTML is sanitized, we place all URIs into an array, replacing them in the HTML with replacement tokens.
                     *  - The URIs are then run through the Content Policy instance, which asynchronously determines the fate of each URI. At this point, the user might be prompted about allowing dangerous URIs. The Content Policy overwrites the URIs in-place.
                     *  - The manipulated URIs are then injected back into the sanitized HTML, and in the correct locations (token replacement).
                     *  - The final sanitized HTML string is returned in the ValidationResult.
                     */
                    var XssHtmlValidator = (function () {
                        /**
                         * Construct an XSS HTML Validator.
                         * @param options {@link XssHtmlValidatorOptions}
                         */
                        function XssHtmlValidator(options) {
                            if (options === void 0) { options = {}; }
                            // We use token replacement to mark the locations of URIs so that we can rewrite them into the correct locations.
                            this._tokenLeft = "{";
                            this._tokenRight = "}";
                            this._tokenLeftEscaped = "\\{";
                            this._tokenRightEscaped = "\\}";
                            if (options.contentPolicy) {
                                this._contentPolicy = options.contentPolicy;
                            }
                        }
                        /**
                         * Sanitize a string of HTML to eliminate XSS risks.
                         *  - Use FilterUtils to sanitize the HTML. Compile all URIs into an array, and replace them in the HTML with replacement tokens.
                         *  - Pass URIs through the Content Policy (which rewrites them), and insert them back into the HTML (token replacement).
                         *  - Return the sanitized HTML.
                         * @param html The string HTML which needs to be sanitized.
                         * @return String of sanitized HTML.
                         */
                        XssHtmlValidator.prototype.validate = function (html, context) {
                            var _this = this;
                            if (context === void 0) { context = { XssHtmlValidator: {} }; }
                            var process = {
                                html: html,
                                uris: [],
                                contentPolicy: this._contentPolicy || context.XssHtmlValidator.defaultContentPolicy
                            };
                            if (!process.contentPolicy) {
                                throw new Error("XssHtmlValidator cannot perform validation without a ContentPolicy instance.");
                            }
                            var sanitizeOptions = context.sanitizeOptions;
                            return Promise.resolve(process)
                                .then(function (process) { return _this._escape(process); })
                                .then(function (process) { return _this._sanitize(process, sanitizeOptions); })
                                .then(function (process) { return _this._runUrisThroughContentPolicy(process); })
                                .then(function (process) { return _this._applyUris(process); })
                                .then(function (process) { return _this._unescape(process); })
                                .then(function (process) { return ({ validatedValue: process.html }); });
                        };
                        /**
                         * Escape the HTML prior to the upcoming insertion of token replacements.
                         */
                        XssHtmlValidator.prototype._escape = function (process) {
                            process.html = process.html.split(this._tokenLeft).join(this._tokenLeftEscaped);
                            process.html = process.html.split(this._tokenRight).join(this._tokenRightEscaped);
                            return process;
                        };
                        /**
                         * Sanitize the HTML.
                         * Compile all URIs into an array.
                         * Replace all URIs in the HTML with replacement tokens.
                         */
                        XssHtmlValidator.prototype._sanitize = function (process, sanitizeOptions) {
                            var _this = this;
                            if (sanitizeOptions === void 0) { sanitizeOptions = {}; }
                            var previousUriTransformer = sanitizeOptions ? sanitizeOptions.uriTransformer : null;
                            // Note that while we are provided our own transformer here, we are respecting the one passed in via `sanitizeOptions`.
                            var uriTransformer = function (uri, details) {
                                // Call the original, if supplied. We just wish to aggregate the transformed URLs in order to verify them against some
                                // sort of trust mechanism.
                                if (previousUriTransformer) {
                                    uri = previousUriTransformer(uri, details);
                                    details.uri = uri;
                                }
                                if (sanitizeOptions.allowArbitraryHyperlinks && details.type === infrastructure.FilterUtils.UriType.NavigableLink) {
                                    return uri;
                                }
                                process.uris.push(details);
                                return _this._tokenize(process.uris.length - 1);
                            };
                            sanitizeOptions.uriTransformer = uriTransformer;
                            process.html = infrastructure.FilterUtils.sanitize(process.html, sanitizeOptions);
                            return process;
                        };
                        /**
                         * Pass URIs through the Content Policy.
                         */
                        XssHtmlValidator.prototype._runUrisThroughContentPolicy = function (process) {
                            // use the validator's content policy by default, but if it is undefined, use the process' content policy instead
                            return this._contentPolicy ? this._contentPolicy.screenUris(process.uris)
                                .then(function (uriDetailsCollection) { return process; })
                                : process.contentPolicy.screenUris(process.uris)
                                    .then(function (uriDetailsCollection) { return process; });
                        };
                        /**
                         * Insert the rewritten URIs into the HTML (token replacement).
                         */
                        XssHtmlValidator.prototype._applyUris = function (process) {
                            var _this = this;
                            process.uris.forEach(function (details, index) {
                                var token = _this._tokenize(index);
                                process.html = process.html.replace(token, details.uri);
                            });
                            return process;
                        };
                        /**
                         * Unescape data after replacing tokens.
                         */
                        XssHtmlValidator.prototype._unescape = function (process) {
                            process.html = process.html.split(this._tokenLeftEscaped).join(this._tokenLeft);
                            process.html = process.html.split(this._tokenRightEscaped).join(this._tokenRight);
                            return process;
                        };
                        /**
                         * Turn an index number into a replacement token.
                         */
                        XssHtmlValidator.prototype._tokenize = function (index) {
                            return this._tokenLeft + index.toString() + this._tokenRight;
                        };
                        return XssHtmlValidator;
                    }());
                    validation.XssHtmlValidator = XssHtmlValidator;
                })(validation = infrastructure.validation || (infrastructure.validation = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var validation;
                (function (validation) {
                    /**
                     * A validator that determines whether the input is a URL that is defined by the Essentials site
                     * (i.e. the URL either matches the site endpoint or one of its services).
                     */
                    var SiteUrlValidator = (function () {
                        function SiteUrlValidator(app) {
                            if (!app) {
                                throw new Error("Argument \"app\" is required.");
                            }
                            this.app = app;
                            // As soon as the site is ready, setup the allowed URLs. This will allow us to synchronously
                            // follow trusted URLs.
                            this._initializeAllowedUrls();
                            this.app.command("ClearTrustedUrls").register(this, this.executeClearTrustedUrls);
                        }
                        // Clears list of trusted urls which are added by clicking 'yes' on potentially untrusted content popup.
                        SiteUrlValidator.prototype.executeClearTrustedUrls = function () {
                            var keys = Object.keys(window.localStorage);
                            for (var index = 0; index < keys.length; index++) {
                                if (keys[index].match("^uri.markup|^uri.css|^uri.navigablelink")) {
                                    window.localStorage.removeItem(keys[index]);
                                }
                            }
                        };
                        SiteUrlValidator.prototype.validate = function (value, context) {
                            var _this = this;
                            if (!value) {
                                return Promise.resolve({
                                    validatedValue: value
                                });
                            }
                            else if (typeof value !== "string") {
                                return Promise.reject(new Error("Input is not a URL."));
                            }
                            return this._initializeAllowedUrls()
                                .then(function () {
                                var url = infrastructure.UrlUtils.parseUrl(geocortex.essentials.RestHelper.processClientSideTokens(_this.app.site, value));
                                if (_this._allowedUrls.some(function (allowedUrl) { return _this._isMatch(allowedUrl, url); })) {
                                    return Promise.resolve({
                                        validatedValue: value
                                    });
                                }
                                else {
                                    var message = "The following URL is not defined by this Essentials site and will be skipped: {0}".format(value);
                                    return Promise.reject(message);
                                }
                            });
                        };
                        SiteUrlValidator.prototype.tryValidateSynchronously = function (value) {
                            var _this = this;
                            if (!this._allowedUrls) {
                                return false;
                            }
                            var url = infrastructure.UrlUtils.parseUrl(geocortex.essentials.RestHelper.processClientSideTokens(this.app.site, value));
                            return this._allowedUrls.some(function (allowedUrl) { return _this._isMatch(allowedUrl, url); });
                        };
                        SiteUrlValidator.prototype._isMatch = function (allowedUrl, testUrl) {
                            if (testUrl.protocol === "mailto:") {
                                // GVH-10098: Always allow mailto URLs. Aside from ones defined by administrators, GVH command
                                // hyperlinks are temporarily turned into mailto links.
                                return true;
                            }
                            // GVH - 10272 IE will not have leading '/'. Hence, we cannot return false if string is empty.
                            if (geocortex.framework.utils.isNullOrUndefined(testUrl.pathname)) {
                                return false;
                            }
                            return testUrl.host == allowedUrl.host
                                && testUrl.protocol == allowedUrl.protocol
                                && (testUrl.pathname.startsWith(allowedUrl.pathname) || testUrl.pathname + "/" === allowedUrl.pathname);
                        };
                        SiteUrlValidator.prototype._initializeAllowedUrls = function () {
                            var _this = this;
                            if (this._allowedUrls) {
                                return Promise.resolve();
                            }
                            return this.app.waitUntilSiteInitialized()
                                .then(function () {
                                var site = _this.app.site;
                                _this._allowedUrls = [];
                                _this._allowUrl(site.url);
                                // Allowing default GMAF links. This is not a future proof solution, as these URLs can be controlled
                                // by administrators in the near future.
                                _this._allowUrl("http://localhost:8181");
                                _this._allowUrl("http://127.0.0.1:8181");
                                // GE-7861 Administrators can define a custom white list of URLs in RestAppSettings which applies to all sites.
                                for (var i = 0; i < site.trustedUrls.length; i++) {
                                    _this._allowUrl(site.trustedUrls[i]["url"]);
                                }
                                // Administrators can define a custom white list of URLs in a site property as a comma-separated list.
                                if (site.properties["trustedUrls"]) {
                                    site.properties["trustedUrls"].split(",").forEach(function (url) {
                                        _this._allowUrl(url);
                                    });
                                }
                                if (!site.essentialsMap) {
                                    return;
                                }
                                // Scan each map service for valid URLs.
                                var serviceUrls = site.essentialsMap.mapServices
                                    .filter(function (ms) { return !ms.isUserCreated; }) // <-- Important for security!
                                    .forEach(function (ms) {
                                    _this._allowUrl(ms.serviceUrl);
                                    _this._allowUrl(ms.tileRestUrl);
                                    _this._allowUrl(ms.mapUrl);
                                    _this._allowUrl(ms.iconUri);
                                    (ms.layerHyperlinks || []).forEach(function (hyperlink) {
                                        _this._allowUrl(hyperlink.uri);
                                        _this._allowUrl(hyperlink.iconUri);
                                    });
                                    // Scan each layer for valid URLs.
                                    (ms.layers || []).forEach(function (layer) {
                                        _this._allowUrl(layer.getLayerUrl());
                                        _this._allowUrl(layer.legendUrl);
                                        _this._allowUrl(layer.iconUri);
                                        (layer.featureHyperlinks || []).forEach(function (hyperlink) {
                                            _this._allowUrl(hyperlink.uri);
                                            _this._allowUrl(hyperlink.iconUri);
                                        });
                                        (layer.layerHyperlinks || []).forEach(function (hyperlink) {
                                            _this._allowUrl(hyperlink.uri);
                                            _this._allowUrl(hyperlink.iconUri);
                                        });
                                        // Extract URLs embedded in feature settings.
                                        _this._extractUrls(layer.featureLabel).forEach(function (url) { return _this._allowUrl(url); });
                                        _this._extractUrls(layer.featureDescription).forEach(function (url) { return _this._allowUrl(url); });
                                        _this._extractUrls(layer.featureLongDescription).forEach(function (url) { return _this._allowUrl(url); });
                                    });
                                });
                            });
                        };
                        SiteUrlValidator.prototype._allowUrl = function (url) {
                            if (!url) {
                                return;
                            }
                            try {
                                this._allowedUrls.push(infrastructure.UrlUtils.getFolder(url));
                            }
                            catch (e) {
                            }
                        };
                        SiteUrlValidator.prototype._extractUrls = function (text) {
                            if (!text) {
                                return [];
                            }
                            // There are many fancier URL regex's out there, but for the purposes of this
                            // class this is sufficient. Each extracted URL gets passed through UrlUtils.parseUrl()
                            // anyway.
                            return (text.match(/(https?:\/\/[A-Za-z0-9\-\._~:\/\?#[\]@!\$&'()*\+,;=%]+)/g) || [])
                                .map(function (url) {
                                // If the URL contains substitution tokens, trust from the first token onwards.
                                if (url.indexOf("{") >= 0) {
                                    return url.slice(0, url.indexOf("{"));
                                }
                                return url;
                            });
                        };
                        return SiteUrlValidator;
                    }());
                    validation.SiteUrlValidator = SiteUrlValidator;
                })(validation = infrastructure.validation || (infrastructure.validation = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var VisualizationUtils;
                (function (VisualizationUtils) {
                    /**
                     * Gets the feature heat map settings for a geocortex layer.
                     * @param gcxLayer the layer to get the feature heat map from.
                     * @returns The feature heat map or null.
                     */
                    function getFeatureHeatMap(gcxLayer) {
                        if (gcxLayer && gcxLayer.mapService) {
                            if (gcxLayer.includeInLegend && gcxLayer.mapService.heatMap) {
                                gcxLayer.mapService.heatMap.includeInLegend = gcxLayer.includeInLegend;
                            }
                            return gcxLayer.mapService.heatMap;
                        }
                        return null;
                    }
                    VisualizationUtils.getFeatureHeatMap = getFeatureHeatMap;
                    /**
                     * Gets the heat map renderer for a geocortex layer.
                     * @param gcxLayer The layer to get the heat map renderer from.
                     * @returns The heat map renderer or null.
                     */
                    function getHeatMapRenderer(gcxLayer) {
                        if (!gcxLayer || !gcxLayer.mapService || !gcxLayer.mapService.serviceLayer) {
                            return null;
                        }
                        var renderer = gcxLayer.mapService.serviceLayer.renderer;
                        if (renderer instanceof esri.renderer.HeatmapRenderer) {
                            return renderer;
                        }
                        return null;
                    }
                    VisualizationUtils.getHeatMapRenderer = getHeatMapRenderer;
                })(VisualizationUtils = infrastructure.VisualizationUtils || (infrastructure.VisualizationUtils = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var visualization;
                (function (visualization) {
                    /** Base string for creating unique ids for each symbology widget container */
                    visualization.WIDGET_ID_BASE = "__CLASSWIDGET__";
                    /**
                     * The symbology settings widget view.
                     */
                    var AttributeSymbologySettingsView = (function (_super) {
                        __extends(AttributeSymbologySettingsView, _super);
                        function AttributeSymbologySettingsView() {
                            _super.apply(this, arguments);
                            /** Flag to stop change events from being applied while configuring */
                            this.configuring = false;
                        }
                        /**
                         * Attach this view to its view-model.
                         */
                        AttributeSymbologySettingsView.prototype.attach = function (viewModel) {
                            viewModel.initialize(this.configuration);
                            _super.prototype.attach.call(this, viewModel);
                        };
                        /**
                         * This widget attaches a reference to itself onto the parent view.
                         */
                        AttributeSymbologySettingsView.prototype.added = function (parentView) {
                            parentView.attributeSettingsWidget = this;
                            _super.prototype.added.call(this, parentView);
                            this._setupJQuerySliders();
                        };
                        /**
                        * Apply the configured settings to the widget.
                        */
                        AttributeSymbologySettingsView.prototype.applyConfiguration = function () {
                            var _this = this;
                            this.configuring = true;
                            // Update the class breaks slider UI
                            $(this.classBreaksSlider).slider("option", "value", this.viewModel.numBreaks.get());
                            // Starting color for class breaks gradient
                            this.startColorInput.value = this.viewModel.startColors[0].toHex();
                            this.viewModel.startColorSwatches.set(this.viewModel.startColors.map(function (color) { return ({ hex: color.toHex() }); }));
                            this.viewModel.startColorSwatches.get().forEach(function (swatch, index) {
                                var label = _this.startColorSwatchFieldSet.children[index];
                                label.style.backgroundColor = swatch.hex;
                            });
                            this.startColorSwatchFieldSet.querySelector(".start-color-swatch:first-child > input[type=radio]").checked = true;
                            // Ending color for class breaks gradient
                            this.endColorInput.value = this.viewModel.endColors[0].toHex();
                            this.viewModel.endColorSwatches.set(this.viewModel.endColors.map(function (color) { return ({ hex: color.toHex() }); }));
                            this.viewModel.endColorSwatches.get().forEach(function (swatch, index) {
                                var label = _this.endColorSwatchFieldSet.children[index];
                                label.style.backgroundColor = swatch.hex;
                            });
                            this.endColorSwatchFieldSet.querySelector(".end-color-swatch:first-child > input[type=radio]").checked = true;
                            // Set initial values for the sliders
                            $(this.transparencySlider).slider("option", "value", this.viewModel.transparency.get());
                            $(this.markerSizeSlider).slider("option", "value", this.viewModel.markerSize.get());
                            $(this.lineWidthSlider).slider("option", "value", this.viewModel.lineWidth.get());
                            // Maker style dropdown
                            this.markerStyleInput.selectedIndex = this.viewModel.markerStyleIndex >= 0 ? this.viewModel.markerStyleIndex : 0;
                            // Apply configuration to the symbol widgets
                            for (var _i = 0, _a = this.viewModel.classSymbolWidgets; _i < _a.length; _i++) {
                                var symbolWidget = _a[_i];
                                symbolWidget.applyConfiguration();
                            }
                            // Pulse to update the view-model with this initial state.
                            this.configuring = false;
                            this.handleChange();
                        };
                        /**
                         * Restore this widget's settings to the default
                         */
                        AttributeSymbologySettingsView.prototype.reset = function () {
                            this.viewModel.reset();
                            if (!this.viewModel.currentAttribute.get()) {
                                // Add the select text to the pick list. 
                                // If it is disabled, selected, and hidden the result is that it displays until you pick something, but it can't be picked itself.
                                var selectOption = document.createElement("option");
                                selectOption.disabled = true;
                                selectOption.selected = true;
                                selectOption.hidden = true;
                                selectOption.value = "";
                                selectOption.text = this.app.getResource(this.libraryId, "language-symbology-settings-attribute-select");
                                this.attributeInput.add(selectOption, 0);
                            }
                        };
                        /**
                         * Set view-model observables and populate the `symbols` object based on any changes here in the view.
                         */
                        AttributeSymbologySettingsView.prototype.handleChange = function () {
                            var _this = this;
                            if (this.configuring) {
                                return;
                            }
                            // Get the selected attribute
                            var attribute;
                            // There's an extra item in the input when nothing has been selected yet
                            if (this.viewModel.attributes.getLength() < this.attributeInput.length) {
                                attribute = this.viewModel.attributes.getAt(this.attributeInput.selectedIndex - 1);
                            }
                            else {
                                attribute = this.viewModel.attributes.getAt(this.attributeInput.selectedIndex);
                            }
                            // If a new attribute or number of breaks has been selected, then update 
                            // IF the attribute exists AND it isn't the current attribute OR we are in class breaks mode and the number of breaks has changed.
                            // The 'symbolizing' flag exists because the act of configuring the widget fires change events from the jQuery sliders, so it sets this while configuring
                            if (attribute && (attribute.displayName !== this.viewModel.currentAttribute.get()
                                || (!this.viewModel.symbolizing && this.viewModel.isNumericAttribute.get() && this.viewModel.numBreaks.get() !== this.viewModel.symbologyClasses.getLength()))) {
                                this.viewModel.symbolizing = true;
                                this.viewModel.getFieldInfo(attribute).then(function (fieldInfo) {
                                    var attributeInfo = {
                                        field: attribute,
                                        fieldInfo: fieldInfo
                                    };
                                    // If this is a string field or a coded domain, make a unique value renderer
                                    if (attribute.dataType === geocortex.essentials.EssentialsFieldTypes.essentialsFieldTypeString
                                        || (attributeInfo.fieldInfo.isCodedValueDomain() || attributeInfo.fieldInfo.hasSubtypeCodedValueDomains())) {
                                        _this.viewModel.classBreaksMode.set(false);
                                        _this.viewModel.isNumericAttribute.set(false);
                                        _this.viewModel.createUniqueValues(attributeInfo);
                                    }
                                    else {
                                        _this.viewModel.classBreaksMode.set(true);
                                        _this.viewModel.isNumericAttribute.set(true);
                                        _this.viewModel.createClassBreaks(attributeInfo);
                                    }
                                });
                                // Set the currently selected attribute
                                this.viewModel.currentAttribute.set(attribute.displayName);
                            }
                            if (this.viewModel.isNumericAttribute.get()) {
                                // Set the selected colors
                                this.viewModel.selectedStartSwatch = this._getSelectedColorSwatch(this.viewModel.startColorSwatches.getItems(), this.startColorSwatchFieldSet);
                                this.viewModel.selectedEndSwatch = this._getSelectedColorSwatch(this.viewModel.endColorSwatches.getItems(), this.endColorSwatchFieldSet);
                                var selectedStart = this.viewModel.useColorSwatches.get()
                                    ? new visualization.SymbolColor(this.viewModel.selectedStartSwatch.hex)
                                    : new visualization.SymbolColor(this.startColorInput.value);
                                var selectedEnd = this.viewModel.useColorSwatches.get()
                                    ? new visualization.SymbolColor(this.viewModel.selectedEndSwatch.hex)
                                    : new visualization.SymbolColor(this.endColorInput.value);
                                if (!this.viewModel.startColors[0].equals(selectedStart)) {
                                    this.viewModel.startColors[0] = selectedStart;
                                    this.viewModel.createRendererClasses();
                                }
                                if (!this.viewModel.endColors[0].equals(selectedEnd)) {
                                    this.viewModel.endColors[0] = selectedEnd;
                                    this.viewModel.createRendererClasses();
                                }
                            }
                            // Note: Slider controls are handled directly in their configured event handlers. See _setupJQuerySliders()
                            // Handle marker style dropdown
                            if (!this.viewModel.symbolizing && this.viewModel.markerStyleIndex !== this.markerStyleInput.selectedIndex) {
                                this.viewModel.markerStyleIndex = this.markerStyleInput.selectedIndex;
                                for (var _i = 0, _a = this.viewModel.classSymbolWidgets; _i < _a.length; _i++) {
                                    var widget = _a[_i];
                                    widget.viewModel.markerStyleIndex = this.markerStyleInput.selectedIndex;
                                    widget.applyConfiguration();
                                }
                            }
                        };
                        /**
                         * Hide / Show symbology widget and set class as selected / unselected
                         * If a selected item is clicked, remove the symbology widget and unselect it
                         * If an unselected item is clicked, show the symbology widget and unselect the currently selected.
                         * The selected color from the widget will be propagated to the swatch in the class list at this point.
                         */
                        AttributeSymbologySettingsView.prototype.handleSymbolClassSelected = function (event) {
                            var _this = this;
                            var divElement = event.currentTarget.children[0];
                            var symbolClass = divElement.textContent || divElement.innerText;
                            var selectedInfo = this.viewModel.symbologyClasses.getItems().filter(function (sc) { return sc.name === symbolClass; })[0];
                            var widgetIndex = this.viewModel.symbologyClasses.indexOf(selectedInfo);
                            if (symbolClass === this.viewModel.selectedClass) {
                                // Deselecting a currently selected item
                                this.viewModel.selectedClass = null;
                                selectedInfo.selected = false;
                                // Set the color of the swatch from the selected color in the widget
                                selectedInfo.color = this.viewModel.classSymbolWidgets[widgetIndex].viewModel.getColor().toHex();
                            }
                            else {
                                // Deselect the previously selected item, if there is one
                                var previouslySelected = this.viewModel.symbologyClasses.getItems().filter(function (sc) { return sc.name === _this.viewModel.selectedClass; })[0];
                                var prevWidgetIndex = this.viewModel.symbologyClasses.indexOf(previouslySelected);
                                var previousWidget = this.viewModel.classSymbolWidgets[prevWidgetIndex];
                                if (previouslySelected) {
                                    previouslySelected.selected = false;
                                    // Set the color of the swatch from the selected color in the widget
                                    previouslySelected.color = previousWidget.viewModel.getColor().toHex();
                                }
                                // Select the new item
                                this.viewModel.selectedClass = symbolClass;
                                selectedInfo.selected = true;
                            }
                            // Update the UI
                            this.viewModel.symbologyClasses.pulse();
                            // Place the selected symbology widget. These cannot be correctly bound inside the template, so jQuery is used.
                            $(this.viewModel.classSymbolWidgets[widgetIndex].container).appendTo($("#" + selectedInfo.widgetId));
                        };
                        /**
                         * Intialize jQuery sliders so that they work when called upon
                         */
                        AttributeSymbologySettingsView.prototype._setupJQuerySliders = function () {
                            var _this = this;
                            var configuration = this.viewModel.config;
                            // Apply class breaks slider configuration.
                            $(this.classBreaksSlider).slider({
                                min: 2,
                                max: this.viewModel.maxRenderClasses,
                                value: 5,
                                step: 1,
                                slide: function (e, ui) { return _this._handleSliderValueChanged(e, ui, _this.viewModel.numBreaks); }
                            });
                            // Apply transparency slider configuration and handle change events
                            $(this.transparencySlider).slider({
                                min: configuration.transparency.min,
                                max: configuration.transparency.max,
                                value: configuration.transparency.value,
                                step: configuration.transparency.step,
                                slide: function (e, ui) {
                                    _this._handleSliderValueChanged(e, ui, _this.viewModel.transparency);
                                    if (!_this.viewModel.symbolizing) {
                                        for (var _i = 0, _a = _this.viewModel.classSymbolWidgets; _i < _a.length; _i++) {
                                            var widget = _a[_i];
                                            widget.viewModel.transparency.set(ui.value);
                                            widget.applyConfiguration();
                                        }
                                    }
                                }
                            });
                            // Apply marker size slider configuration and handle change events.
                            $(this.markerSizeSlider).slider({
                                min: configuration.markerSize.min,
                                max: configuration.markerSize.max,
                                value: configuration.markerSize.value,
                                step: configuration.markerSize.step,
                                slide: function (e, ui) {
                                    _this._handleSliderValueChanged(e, ui, _this.viewModel.markerSize);
                                    if (!_this.viewModel.symbolizing) {
                                        for (var _i = 0, _a = _this.viewModel.classSymbolWidgets; _i < _a.length; _i++) {
                                            var widget = _a[_i];
                                            widget.viewModel.markerSize.set(ui.value);
                                            widget.applyConfiguration();
                                        }
                                    }
                                }
                            });
                            // Apply line width slider configuration and handle change events.
                            $(this.lineWidthSlider).slider({
                                min: configuration.lineWidth.min,
                                max: configuration.lineWidth.max,
                                value: configuration.lineWidth.value,
                                step: configuration.lineWidth.step,
                                slide: function (e, ui) {
                                    _this._handleSliderValueChanged(e, ui, _this.viewModel.lineWidth);
                                    if (!_this.viewModel.symbolizing) {
                                        for (var _i = 0, _a = _this.viewModel.classSymbolWidgets; _i < _a.length; _i++) {
                                            var widget = _a[_i];
                                            widget.viewModel.lineWidth.set(ui.value);
                                            widget.applyConfiguration();
                                        }
                                    }
                                }
                            });
                            for (var _i = 0, _a = this.viewModel.classSymbolWidgets; _i < _a.length; _i++) {
                                var symbolWidget = _a[_i];
                                symbolWidget.setupJQuerySliders();
                            }
                            // Realizing jQuery slider changes as legitmate change events.
                            $(this.classBreaksSlider).add(this.transparencySlider).add(this.markerSizeSlider).add(this.lineWidthSlider)
                                .off("slidechange").on("slidechange", function (event) {
                                // jQuery's `.trigger` isn't firing our data-bindings, so we're using native DOM methods which appear to work instead.
                                var changeEvent = document.createEvent("Event");
                                changeEvent.initEvent("change", true, true);
                                _this.container.dispatchEvent(changeEvent);
                            });
                        };
                        AttributeSymbologySettingsView.prototype._handleSliderValueChanged = function (event, ui, prop) {
                            if (ui && ui.value != undefined) {
                                prop.set(ui.value);
                            }
                        };
                        /**
                         * Acquire the currently selected color swatch.
                         */
                        AttributeSymbologySettingsView.prototype._getSelectedColorSwatch = function (swatches, swatchFieldSet) {
                            for (var i = 0; i < swatches.length; i++) {
                                var swatch = swatches[i];
                                var radio = swatchFieldSet.children[i].querySelector("input[type=radio]");
                                if (radio.checked) {
                                    return swatch;
                                }
                            }
                        };
                        return AttributeSymbologySettingsView;
                    }(geocortex.framework.ui.ViewBase));
                    visualization.AttributeSymbologySettingsView = AttributeSymbologySettingsView;
                })(visualization = infrastructure.visualization || (infrastructure.visualization = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var visualization;
                (function (visualization) {
                    /**
                     * View-model for the attribute symbology settings widget.
                     * This widget
                     * Marker and fill symbolization options are optional.
                     */
                    var AttributeSymbologySettingsViewModel = (function (_super) {
                        __extends(AttributeSymbologySettingsViewModel, _super);
                        function AttributeSymbologySettingsViewModel() {
                            _super.apply(this, arguments);
                            /** Attributes to symbolize on */
                            this.attributes = new ObservableCollection();
                            this.currentAttribute = new Observable("");
                            /** What kind of symbolization is it? */
                            this.classBreaksMode = new Observable(false);
                            /** What kind of field is it? Numeric fields are sometimes unique value renderers if data is limited. */
                            this.isNumericAttribute = new Observable(false);
                            /** Symbology class info for binding to view */
                            this.symbologyClasses = new ObservableCollection([]);
                            /** The widgets used to configure the symbology for each class */
                            this.classSymbolWidgets = [];
                            /** Observable for the selected number of class breaks. */
                            this.numBreaks = new Observable(5);
                            /** Whether or not to use swatches instead of native color input. */
                            this.useColorSwatches = new Observable(true);
                            /** Color swatches available to choose from for class breaks gradient */
                            this.startColorSwatches = new ObservableCollection();
                            this.endColorSwatches = new ObservableCollection();
                            /** Observable for the user-selected marker size. */
                            this.markerSize = new Observable(10);
                            /** Observable for the user-selected line width. */
                            this.lineWidth = new Observable(2);
                            /** Observable for the user-selected fill transparency. */
                            this.transparency = new Observable(10);
                            /** Disables availability of marker related options. */
                            this.noMarker = new Observable(false);
                            /** Styles available to point markers. */
                            this.markerStyles = new ObservableCollection([
                                {
                                    style: esri.symbol.SimpleMarkerSymbol.STYLE_CIRCLE,
                                    label: this.getResource("language-symbology-settings-marker-style-circle")
                                },
                                {
                                    style: esri.symbol.SimpleMarkerSymbol.STYLE_CROSS,
                                    label: this.getResource("language-symbology-settings-marker-style-cross")
                                },
                                {
                                    style: esri.symbol.SimpleMarkerSymbol.STYLE_DIAMOND,
                                    label: this.getResource("language-symbology-settings-marker-style-diamond")
                                },
                                {
                                    style: esri.symbol.SimpleMarkerSymbol.STYLE_SQUARE,
                                    label: this.getResource("language-symbology-settings-marker-style-square")
                                },
                                {
                                    style: esri.symbol.SimpleMarkerSymbol.STYLE_X,
                                    label: this.getResource("language-symbology-settings-marker-style-x")
                                }
                            ]);
                            /** These are used to translate style ids from Esri JS API to Esri REST API form */
                            this.markerStyleIdLookup = {
                                "circle": "esriSMSCircle",
                                "cross": "esriSMSCross",
                                "diamond": "esriSMSDiamond",
                                "square": "esriSMSSquare",
                                "x": "esriSMSX"
                            };
                            /** Track when we are in the process of symbolizing, so that the event change handler doesn't initiate multiple symbolization passes */
                            this.symbolizing = false;
                        }
                        /**
                         * Initialize the widget based on configuration.
                         */
                        AttributeSymbologySettingsViewModel.prototype.initialize = function (configuration) {
                            if (configuration === void 0) { configuration = {}; }
                            this.config = configuration;
                            // Maximum allowed renderer classes
                            this.maxRenderClasses = this.config.maxRenderClasses > 1 ? this.config.maxRenderClasses : 12;
                            // Max samples to use to create classes
                            this.maxSamples = this.config.maxSamples || 1000;
                            // Default for numberOfColorSwatches.
                            configuration.numberOfColorSwatches = (!configuration.numberOfColorSwatches) ? configuration.numberOfColorSwatches : 6;
                            // Set up default symbols
                            this.defaultLineSymbol = new esri.symbol.SimpleLineSymbol();
                            this.defaultLineSymbol.setColor(new esri.Color(this.config.defaultLineColor || [75, 75, 75, 1]));
                            this.defaultLineSymbol.setWidth(this.config.defaultLineWidth || 2);
                            this.defaultPointSymbol = new esri.symbol.SimpleMarkerSymbol();
                            this.defaultPointSymbol.setColor(new esri.Color(this.config.defaultPointColor || [150, 150, 150, 0.8]));
                            this.defaultPointSymbol.setSize(this.config.defaultPointSize || 12);
                            this.defaultPointSymbol.setOutline(this.defaultLineSymbol);
                            this.defaultPolygonSymbol = new esri.symbol.SimpleFillSymbol();
                            this.defaultPolygonSymbol.setColor(new esri.Color(this.config.defaultFillColor || [150, 150, 150, 0.3]));
                            this.defaultPolygonSymbol.setOutline(this.defaultLineSymbol);
                            // Create the SymbologySettingsWidgets for each renderer class
                            for (var i = 0; i < this.maxRenderClasses; i++) {
                                var ssView = void 0;
                                // Create the view
                                ssView = this.app.viewManager.createView({
                                    markupResource: "Mapping/infrastructure/visualization/SymbologySettings/SymbologySettingsView.html",
                                    typeName: "geocortex.essentialsHtmlViewer.mapping.infrastructure.visualization.SymbologySettingsView",
                                    isVisible: true,
                                    libraryId: "Mapping.Infrastructure"
                                });
                                // Attach the view model
                                var ssViewModel = new infrastructure.visualization.SymbologySettingsViewModel(this.app, "Mapping.Infrastructure");
                                ssView.attach(ssViewModel);
                                // Configure widget
                                ssViewModel.initialize(this.config.defaultSymbologySettingsConfig);
                                ssView.applyConfiguration();
                                this.classSymbolWidgets.push(ssView);
                            }
                            // Setting the `useColorSwatches` observable. We use the color swatches if either `alwaysUseColorSwatches` is true, or if the color input is not supported.
                            this.useColorSwatches.set(configuration.alwaysUseColorSwatches || !infrastructure.ColorUtils.isColorInputSupported());
                            // Set initial colors for the symbology
                            this.startColors = infrastructure.ColorUtils.generateRandomColors(configuration.numberOfColorSwatches);
                            this.endColors = infrastructure.ColorUtils.generateRandomColors(configuration.numberOfColorSwatches);
                            // Create a gradient from light to dark
                            var baseColor = infrastructure.ColorUtils.generateRandomColor();
                            this.startColors[0] = baseColor.lighten(0.9);
                            this.endColors[0] = baseColor.darken(0.6);
                            // Defaults for transparency range configuration.
                            this.config.transparency = configuration.transparency ? configuration.transparency
                                : { min: 0, max: 90, value: 10, step: 5 };
                            this.transparency.set(this.config.transparency.value);
                            // Defaults for markerSize range configuration.
                            this.config.markerSize = configuration.markerSize ? configuration.markerSize
                                : { min: 1, max: 50, value: 10, step: 1 };
                            this.markerSize.set(this.config.markerSize.value);
                            // Defaults for lineWidth range configuration.
                            this.config.lineWidth = configuration.lineWidth ? configuration.lineWidth
                                : { min: 0, max: 5, value: 2, step: 1 };
                            this.lineWidth.set(this.config.lineWidth.value);
                            // Marker styles must match those configured in the symbol widgets
                            this.markerStyles.set(this.classSymbolWidgets[0].viewModel.markerStyles.getItems());
                            this.markerStyleIndex = 0;
                        };
                        /**
                         * Restores settings to the default state
                         */
                        AttributeSymbologySettingsViewModel.prototype.reset = function () {
                            this.attributes.set([]);
                            this.currentAttribute.set("");
                            this.classBreaksMode.set(false);
                            this.isNumericAttribute.set(false);
                            this.symbologyClasses.set([]);
                            this.selectedClass = "";
                            // Reset global controls
                            this.transparency.set(this.config.transparency.value);
                            this.markerSize.set(this.config.markerSize.value);
                            this.lineWidth.set(this.config.lineWidth.value);
                            this.markerStyleIndex = 0;
                            // Set initial colors for the symbology
                            this.startColors = infrastructure.ColorUtils.generateRandomColors(this.config.numberOfColorSwatches);
                            this.endColors = infrastructure.ColorUtils.generateRandomColors(this.config.numberOfColorSwatches);
                            // Create a gradient from light to dark
                            var baseColor = infrastructure.ColorUtils.generateRandomColor();
                            this.startColors[0] = baseColor.lighten(0.9);
                            this.endColors[0] = baseColor.darken(0.6);
                            for (var _i = 0, _a = this.classSymbolWidgets; _i < _a.length; _i++) {
                                var symbolWidget = _a[_i];
                                symbolWidget.reset();
                            }
                        };
                        /**
                         * Returns a renderer based on the current widget setttings as a JSON string
                         */
                        AttributeSymbologySettingsViewModel.prototype.getRenderer = function () {
                            var _this = this;
                            var renderer;
                            var defaultSymbol;
                            // No renderer has been configured, return an empty string
                            if (this.symbologyClasses.getLength() === 0) {
                                return "";
                            }
                            // Set the default symbol
                            if (this.featureType === "Point") {
                                defaultSymbol = this.defaultPointSymbol;
                            }
                            else if (this.featureType === "Line") {
                                defaultSymbol = this.defaultLineSymbol;
                            }
                            else {
                                defaultSymbol = this.defaultPolygonSymbol;
                            }
                            var field = this.attributes.getItems().filter(function (a) { return a.displayName === _this.currentAttribute.get(); })[0];
                            // Make a class breaks renderer
                            if (this.classBreaksMode.get()) {
                                renderer = new esri.renderer.ClassBreaksRenderer(defaultSymbol, field.name);
                                for (var i = 0; i < this.symbologyClasses.getLength(); i++) {
                                    var symbolClass = this.symbologyClasses.getAt(i);
                                    var symbolWidget = this.classSymbolWidgets[i];
                                    renderer.addBreak({
                                        minValue: symbolClass.min,
                                        maxValue: symbolClass.max,
                                        symbol: esri.symbol.fromJson(JSON.parse(symbolWidget.viewModel.getSymbol())),
                                        label: symbolClass.name
                                    });
                                }
                            }
                            else {
                                renderer = new esri.renderer.UniqueValueRenderer(defaultSymbol, field.name);
                                for (var i = 0; i < this.symbologyClasses.getLength(); i++) {
                                    var symbolClass = this.symbologyClasses.getAt(i);
                                    var symbolWidget = this.classSymbolWidgets[i];
                                    renderer.addValue({
                                        value: symbolClass.value,
                                        symbol: esri.symbol.fromJson(JSON.parse(symbolWidget.viewModel.getSymbol())),
                                        label: symbolClass.name
                                    });
                                }
                            }
                            return JSON.stringify(renderer.toJson());
                        };
                        /**
                         * Sets the state of the widget based on a supplied class breaks or unique value renderer
                         * @param renderer
                         */
                        AttributeSymbologySettingsViewModel.prototype.setFromRenderer = function (renderer) {
                            var _this = this;
                            var ro = renderer.toJson();
                            this.symbolizing = true;
                            // Get the field used
                            var field = this.attributes.getItems().filter(function (a) { return a.name === ro.field || a.name === ro.field1; })[0];
                            // Get a fieldInfo object for this field
                            this.getFieldInfo(field).then(function (fieldInfo) {
                                _this.isNumericAttribute.set(field.dataType !== geocortex.essentials.EssentialsFieldTypes.essentialsFieldTypeString
                                    && !fieldInfo.isCodedValueDomain()
                                    && !fieldInfo.hasSubtypeCodedValueDomains());
                                if (ro.type === "classBreaks") {
                                    _this.classBreaksMode.set(true);
                                    var minValue = ro.minValue;
                                    // Update the current number of class breaks
                                    _this.numBreaks.set(ro.classBreakInfos.length);
                                    var _loop_1 = function(i) {
                                        var cbInfo = ro.classBreakInfos[i];
                                        var symbolWidget = _this.classSymbolWidgets[i];
                                        var color = new esri.Color(cbInfo.symbol.color);
                                        // Configure the symbology widget
                                        symbolWidget.reset();
                                        symbolWidget.viewModel.noMarker.set(_this.featureType !== "Point");
                                        symbolWidget.viewModel.noFill.set(_this.featureType !== "Polygon");
                                        symbolWidget.viewModel.setFromSymbol(esri.symbol.fromJson(cbInfo.symbol));
                                        symbolWidget.applyConfiguration();
                                        // Find minimum value of the break. Sometimes the 'classMinValue' will be dropped from the renderer object...
                                        if (cbInfo.classMinValue) {
                                            minValue = cbInfo.classMinValue;
                                        }
                                        // Add a symbology class for this break
                                        _this.symbologyClasses.addItem({
                                            name: fieldInfo.formatValue(minValue) + " - " + fieldInfo.formatValue(cbInfo.classMaxValue),
                                            min: minValue,
                                            max: cbInfo.classMaxValue,
                                            color: color.toHex(),
                                            selected: false,
                                            widgetId: visualization.WIDGET_ID_BASE + i.toString()
                                        });
                                        minValue = cbInfo.classMaxValue;
                                        // Set the color pickers and global sliders
                                        if (i === 0) {
                                            _this.startColors[0] = new visualization.SymbolColor(color.toHex());
                                            // set transparency, respecting the step values of the slider
                                            _this.transparency.set(Math.floor(Math.ceil(((255 - cbInfo.symbol.color[3]) / 255) * 100) / _this.config.transparency.step) * _this.config.transparency.step);
                                            // Set marker size
                                            _this.markerSize.set($.isNumeric(cbInfo.symbol.size) ? Math.floor(cbInfo.symbol.size * visualization.POINTS_TO_PIXELS) : _this.config.markerSize.value);
                                            // Set marker style
                                            var markerStyle = _this.markerStyles.getItems().filter(function (ms) { return _this.markerStyleIdLookup[ms.style] === cbInfo.symbol.style; })[0];
                                            _this.markerStyleIndex = markerStyle ? _this.markerStyles.indexOf(markerStyle) : 0;
                                            // Set line width
                                            var lineSymbol = (_this.featureType !== "Point" && _this.featureType !== "Polygon") ? cbInfo.symbol : cbInfo.symbol.outline;
                                            _this.lineWidth.set($.isNumeric(lineSymbol.width) ? Math.floor(lineSymbol.width * visualization.POINTS_TO_PIXELS) : _this.config.lineWidth.value);
                                        }
                                        if (i === ro.classBreakInfos.length - 1) {
                                            _this.endColors[0] = new visualization.SymbolColor(color.toHex());
                                        }
                                    };
                                    for (var i = 0; i < ro.classBreakInfos.length; i++) {
                                        _loop_1(i);
                                    }
                                }
                                else if (ro.type === "uniqueValue") {
                                    _this.classBreaksMode.set(false);
                                    var _loop_2 = function(i) {
                                        var uvInfo = ro.uniqueValueInfos[i];
                                        var symbolWidget = _this.classSymbolWidgets[i];
                                        var color = new esri.Color(uvInfo.symbol.color);
                                        // Configure the symbology widget
                                        symbolWidget.reset();
                                        symbolWidget.viewModel.noMarker.set(_this.featureType !== "Point");
                                        symbolWidget.viewModel.noFill.set(_this.featureType !== "Polygon");
                                        symbolWidget.viewModel.setFromSymbol(esri.symbol.fromJson(uvInfo.symbol));
                                        symbolWidget.applyConfiguration();
                                        // Resolve Coded Domains
                                        var name_1 = void 0;
                                        if (fieldInfo.isCodedValueDomain() || fieldInfo.hasSubtypeCodedValueDomains()) {
                                            name_1 = fieldInfo.esriField.domain.getName(uvInfo.value);
                                        }
                                        if (!name_1) {
                                            name_1 = fieldInfo.formatValue(uvInfo.value);
                                        }
                                        _this.symbologyClasses.addItem({
                                            name: name_1,
                                            value: uvInfo.value,
                                            color: color.toHex(),
                                            selected: false,
                                            widgetId: visualization.WIDGET_ID_BASE + i.toString()
                                        });
                                        // Set the color pickers and global sliders
                                        if (i === 0) {
                                            _this.startColors[0] = new visualization.SymbolColor(color.toHex());
                                            // set transparency, respecting the step values of the slider
                                            _this.transparency.set(Math.floor(Math.ceil(((255 - uvInfo.symbol.color[3]) / 255) * 100) / _this.config.transparency.step) * _this.config.transparency.step);
                                            // Set marker size
                                            _this.markerSize.set($.isNumeric(uvInfo.symbol.size) ? Math.floor(uvInfo.symbol.size * visualization.POINTS_TO_PIXELS) : _this.config.markerSize.value);
                                            // Set marker style
                                            var markerStyle = _this.markerStyles.getItems().filter(function (ms) { return _this.markerStyleIdLookup[ms.style] === uvInfo.symbol.style; })[0];
                                            _this.markerStyleIndex = markerStyle ? _this.markerStyles.indexOf(markerStyle) : 0;
                                            // Set line width
                                            var lineSymbol = (_this.featureType !== "Point" && _this.featureType !== "Polygon") ? uvInfo.symbol : uvInfo.symbol.outline;
                                            _this.lineWidth.set($.isNumeric(lineSymbol.width) ? Math.floor(lineSymbol.width * visualization.POINTS_TO_PIXELS) : _this.config.lineWidth.value);
                                        }
                                        if (i === ro.uniqueValueInfos.length - 1) {
                                            _this.endColors[0] = new visualization.SymbolColor(color.toHex());
                                        }
                                    };
                                    for (var i = 0; i < ro.uniqueValueInfos.length; i++) {
                                        _loop_2(i);
                                    }
                                }
                                _this.symbolizing = false;
                                _this.symbologyClasses.pulse();
                            });
                        };
                        /**
                         * Given a quantitative value field, automatically create a set of class breaks to use for a renderer
                         * @param attribute
                         */
                        AttributeSymbologySettingsViewModel.prototype.createClassBreaks = function (attribute) {
                            var _this = this;
                            // Clear the current symbology classes
                            this.symbologyClasses.set([]);
                            // Start with the current extent of the map
                            var startExtent = this.app.map.extent;
                            this.executeExtentQuery(attribute.field, startExtent).then(function (extent) {
                                _this.executeQuery(attribute.field, extent).then(function (results) {
                                    // We need more unique values than the current number of classes in order to do this. 
                                    // If this doesn't happen we'll bail and just use the unique values instead.
                                    var uniqueCount = _this._findDistinctValues(results, attribute.field.name).length;
                                    if (uniqueCount <= _this.numBreaks.get()) {
                                        _this.classBreaksMode.set(false);
                                        _this.createUniqueValues(attribute);
                                        return;
                                    }
                                    // Get an array of raw data from the featureSet
                                    var data = results.features.map(function (f) { return f.attributes[attribute.field.name]; });
                                    // A number to divide all data points by so that when they are floored and then multiplied by this number 
                                    // the result will have the correct number of significant figures
                                    var significance = infrastructure.DataClassification.findSignificanceFactor(data);
                                    // Classify the data. 
                                    var classes = infrastructure.DataClassification.ckmeans(data, _this.numBreaks.get());
                                    // Adjust the working values by the significance factor
                                    if (significance !== 0 && significance !== 1) {
                                        for (var i = 0; i < classes.length; i++) {
                                            classes[i] = classes[i].map(function (n) { return n / significance; });
                                        }
                                    }
                                    // Create critera for breaks
                                    for (var i = 0; i < classes.length; i++) {
                                        var min = void 0, max = void 0;
                                        // Breaks should be made continuous, as our sample may not contain all possible values.
                                        // Min
                                        if (i === 0) {
                                            min = Math.floor(Math.min.apply(Math, classes[i]));
                                        }
                                        else {
                                            var classMin = Math.min.apply(Math, classes[i]);
                                            if (classMin > Math.max.apply(Math, classes[i - 1]) + 1) {
                                                min = Math.floor(classMin - (classMin - Math.max.apply(Math, classes[i - 1])) / 2);
                                                if (significance === 1) {
                                                    min++;
                                                }
                                            }
                                            else {
                                                min = Math.floor(classMin);
                                            }
                                        }
                                        // Max
                                        if (i === classes.length - 1) {
                                            max = Math.ceil(Math.max.apply(Math, classes[i]));
                                        }
                                        else {
                                            var classMax = Math.max.apply(Math, classes[i]);
                                            var upperClassMin = Math.min.apply(Math, classes[i + 1]);
                                            if (classMax < upperClassMin - 1) {
                                                max = Math.floor(classMax + ((upperClassMin - classMax) / 2));
                                            }
                                            else {
                                                if (significance <= 1) {
                                                    max = Math.floor(classMax);
                                                }
                                                else {
                                                    max = Math.floor(upperClassMin);
                                                }
                                            }
                                        }
                                        // Restore the calculated break values to the correct range
                                        if (significance !== 0 && significance !== 1) {
                                            min = min * significance;
                                            max = max * significance;
                                        }
                                        // Don't display class breaks like 0 - 0. Just use the whole number instead. 
                                        var name_2 = void 0;
                                        if (max - min === 0) {
                                            name_2 = attribute.fieldInfo.formatValue(min);
                                        }
                                        else {
                                            name_2 = attribute.fieldInfo.formatValue(min) + " - " + attribute.fieldInfo.formatValue(max);
                                        }
                                        // Add a symbology class for this break
                                        _this.symbologyClasses.addItem({
                                            name: name_2,
                                            min: min,
                                            max: max,
                                            count: classes[i].length,
                                            color: "#FFFFFF",
                                            selected: false,
                                            widgetId: visualization.WIDGET_ID_BASE + _this.symbologyClasses.getLength().toString()
                                        });
                                    }
                                    // Construct default symbology for these classes
                                    _this.createRendererClasses();
                                    _this.symbolizing = false;
                                });
                            });
                        };
                        /**
                         * Given a string field, automatically create a set of unique values to use for a renderer
                         * @param attribute
                         */
                        AttributeSymbologySettingsViewModel.prototype.createUniqueValues = function (attribute) {
                            var _this = this;
                            // Clear the current symbology classes
                            this.symbologyClasses.set([]);
                            // Start with the current extent of the map
                            var startExtent = this.app.map.extent;
                            this.executeExtentQuery(attribute.field, startExtent).then(function (extent) {
                                _this.executeQuery(attribute.field, extent).then(function (results) {
                                    // Loop through the featureset, looking for unique strings in the attribute of interest
                                    var _loop_3 = function(feature) {
                                        var value = feature.attributes[attribute.field.name] != null && feature.attributes[attribute.field.name].toString().trim() !== ""
                                            ? feature.attributes[attribute.field.name].toString()
                                            : null;
                                        // We don't want to symbolize empty or null strings, or undefined values.
                                        if (value) {
                                            // Resolve Coded Domains
                                            var name_3 = void 0;
                                            if (attribute.fieldInfo.isCodedValueDomain() || attribute.fieldInfo.hasSubtypeCodedValueDomains()) {
                                                name_3 = attribute.fieldInfo.esriField.domain.getName(feature.attributes[attribute.field.name]);
                                            }
                                            if (!name_3) {
                                                name_3 = attribute.fieldInfo.formatValue(value);
                                            }
                                            // Keep a count of string values that have been previously encountered
                                            var existingClass = _this.symbologyClasses.getItems().filter(function (x) { return x.value === value; })[0];
                                            if (existingClass) {
                                                existingClass.count++;
                                            }
                                            else {
                                                _this.symbologyClasses.addItem({
                                                    name: name_3,
                                                    value: value,
                                                    count: 1,
                                                    color: "#FFFFFF",
                                                    selected: false,
                                                    widgetId: visualization.WIDGET_ID_BASE + _this.symbologyClasses.getLength().toString()
                                                });
                                            }
                                        }
                                    };
                                    for (var _i = 0, _a = results.features; _i < _a.length; _i++) {
                                        var feature = _a[_i];
                                        _loop_3(feature);
                                    }
                                    // Make sure there are some values to render
                                    if (_this.symbologyClasses.getLength() === 0) {
                                        _this.app.command("Alert").execute(_this.app.getResource(_this.libraryId, "language-symbology-settings-nodata"), _this.app.getResource(_this.libraryId, "language-symbology-settings-nodata-title"));
                                        _this.symbolizing = false;
                                        _this.currentAttribute.set("");
                                        return;
                                    }
                                    // Make sure that there aren't too many unique values to render
                                    _this.constrainToMaxClasses(attribute.field).then(function () {
                                        // Sort the classes
                                        if (_this.isNumericAttribute.get()) {
                                            _this.symbologyClasses.getItems().sort(function (a, b) { return Number(a.value) - Number(b.value); });
                                        }
                                        else {
                                            _this.symbologyClasses.getItems().sort();
                                        }
                                        // Construct default symbology for these classes
                                        _this.createRendererClasses();
                                        _this.symbolizing = false;
                                    });
                                });
                            });
                        };
                        /**
                         * Assign default colors to classes and configure the symbology widgets
                         * @param attribute
                         */
                        AttributeSymbologySettingsViewModel.prototype.createRendererClasses = function () {
                            var colors = [];
                            var outlineColor;
                            var numberOfClasses = this.symbologyClasses.getLength();
                            // Assign colors to the resulting renderer classes
                            if (this.isNumericAttribute.get()) {
                                // Class breaks defaults to a single color gradient from dark to light
                                for (var i = 0; i < numberOfClasses; i++) {
                                    var gradientStop = numberOfClasses > 1 ? i / (numberOfClasses - 1) : 0.5;
                                    colors.push(this.startColors[0].blend(gradientStop, this.endColors[0]));
                                }
                                if (this.startColors[0].value >= 0.7) {
                                    outlineColor = this.startColors[0].darken(0.6);
                                }
                                else {
                                    outlineColor = this.startColors[0].lighten(0.9);
                                }
                            }
                            else {
                                // Unique value renderers have randomly assigned colors. 
                                colors = infrastructure.ColorUtils.generateRandomColors(numberOfClasses);
                                outlineColor = new visualization.SymbolColor(this.defaultLineSymbol.color.toHex());
                            }
                            // Configure each class color swatch and symbology widget
                            for (var i = 0; i < numberOfClasses; i++) {
                                var rendererClass = this.symbologyClasses.getAt(i);
                                // Set the color of the class swatch
                                rendererClass.color = colors[i].toHex();
                                // Set the color of the symbol widget
                                var symbolWidget = this.classSymbolWidgets[i];
                                symbolWidget.viewModel.colors[0] = colors[i];
                                symbolWidget.viewModel.outlineColors[0] = outlineColor;
                                // Set the geometry type of the symbol widget
                                symbolWidget.viewModel.noMarker.set(this.featureType !== "Point");
                                symbolWidget.viewModel.noFill.set(this.featureType !== "Polygon");
                                // Apply configuration to the widget
                                symbolWidget.applyConfiguration();
                            }
                            // Update the UI
                            this.symbologyClasses.pulse();
                        };
                        /**
                         * Set up the query task, then return a promise of the results
                         * @param attribute
                         */
                        AttributeSymbologySettingsViewModel.prototype.executeQuery = function (attribute, extent) {
                            // For user added layers we'll need to extract the data directly from the layer
                            if (attribute.layer instanceof mapping.infrastructure.LayerIntegrationUtils.LocalLayer) {
                                // Create a feature set from the graphics collection
                                var graphicsCollection = attribute.layer.mapService.serviceLayer.graphics;
                                var featureSet = new esri.tasks.FeatureSet();
                                featureSet.features = graphicsCollection;
                                // Return a resolved promise
                                return Promise.resolve(featureSet);
                            }
                            else {
                                // Set up the query task
                                var query = new esri.tasks.Query();
                                var queryTask = infrastructure.taskUtils.getQueryTask(attribute.layer);
                                query.returnGeometry = false;
                                query.geometry = extent;
                                query.outFields = [attribute.name];
                                // Execute the query
                                return queryTask.execute(query);
                            }
                        };
                        /**
                         * Query successively larger extents until the desired number of features return, or no more features are available.
                         * Each query will double the size of the extent used.
                         * @param attribute
                         * @param extent
                         */
                        AttributeSymbologySettingsViewModel.prototype.executeExtentQuery = function (attribute, extent) {
                            // Local layers can't be queried, and we already have all the features
                            if (attribute.layer instanceof mapping.infrastructure.LayerIntegrationUtils.LocalLayer) {
                                return Promise.resolve(extent);
                            }
                            else {
                                if (this.classBreaksMode.get()) {
                                    return this.executeClassBreaksExtentQuery(attribute, extent);
                                }
                                else {
                                    return this.executeUniqueValueExtentQuery(attribute, extent);
                                }
                            }
                        };
                        /**
                         * For unique values we want to stop increasing the extent when we have reached the maximum number of unique values allowed.
                         * @param attribute
                         * @param extent
                         */
                        AttributeSymbologySettingsViewModel.prototype.executeUniqueValueExtentQuery = function (attribute, extent) {
                            var _this = this;
                            // Create a promise that will contain the final extent
                            var promise = new Promise(function (resolve, reject) {
                                var lastCount = 0;
                                // This function will call itself again if criteria to proceed are not met
                                var queryRecursive = function () {
                                    // Set up the query task
                                    var query = new esri.tasks.Query();
                                    var queryTask = infrastructure.taskUtils.getQueryTask(attribute.layer);
                                    query.returnGeometry = false;
                                    query.geometry = extent;
                                    query.outFields = [attribute.name];
                                    // Execute the query
                                    queryTask.execute(query).then(function (featureSet) {
                                        var distinctValues = _this._findDistinctValues(featureSet, attribute.name);
                                        var count = distinctValues.length;
                                        var targetClasses = _this.isNumericAttribute.get() ? _this.numBreaks.get() : _this.maxRenderClasses;
                                        // If we have enough features, or we aren't getting any more, then resolve with the current extent
                                        if (count >= targetClasses || count === lastCount || featureSet.exceededTransferLimit) {
                                            resolve(extent);
                                        }
                                        else {
                                            lastCount = count;
                                            extent = extent.expand(2);
                                            queryRecursive();
                                        }
                                    }, function (error) {
                                        resolve(extent);
                                    });
                                };
                                // Kick off the recursive extent queries
                                queryRecursive();
                            });
                            // Return the promise which will contain the final query extent
                            return promise;
                        };
                        /**
                         * For class breaks we want to keep increasing the extent until we have reached the maximum number of samples allowed.
                         */
                        AttributeSymbologySettingsViewModel.prototype.executeClassBreaksExtentQuery = function (attribute, extent) {
                            var _this = this;
                            // Create a promise that will contain the final extent
                            var promise = new Promise(function (resolve, reject) {
                                var lastCount = 0;
                                // This function will call itself again if criteria to proceed are not met
                                var queryRecursive = function () {
                                    // Set up the query task
                                    var query = new esri.tasks.Query();
                                    var queryTask = infrastructure.taskUtils.getQueryTask(attribute.layer);
                                    query.returnGeometry = false;
                                    query.geometry = extent;
                                    // Execute the query
                                    queryTask.executeForCount(query).then(function (count) {
                                        // If we have enough features, or we aren't getting any more, then resolve with the current extent
                                        if (count >= _this.maxSamples || count === lastCount) {
                                            resolve(extent);
                                        }
                                        else {
                                            lastCount = count;
                                            extent = extent.expand(2);
                                            queryRecursive();
                                        }
                                    }, function (error) {
                                        resolve(extent);
                                    });
                                };
                                // Kick off the recursive extent queries
                                queryRecursive();
                            });
                            // Return the promise which will contain the final query extent
                            return promise;
                        };
                        /**
                         * Sorts symbol classes by count and closeness to the user, and constrains the collection to 'maxRenderClasses' items
                         * @param results
                         */
                        AttributeSymbologySettingsViewModel.prototype.constrainToMaxClasses = function (attribute) {
                            var _this = this;
                            var promise = new Promise(function (resolve, reject) {
                                if (_this.symbologyClasses.getLength() > _this.maxRenderClasses || (_this.symbologyClasses.getLength() > _this.numBreaks.get() || _this.isNumericAttribute.get())) {
                                    if (_this.symbologyClasses.getLength() > _this.maxRenderClasses && !_this.isNumericAttribute.get()) {
                                        // Show an alert to inform the user of the constraint
                                        _this.app.command("Alert").execute(_this.app.getResource(_this.libraryId, "language-symbology-settings-exceeded-max-classes").format(_this.maxRenderClasses), _this.app.getResource(_this.libraryId, "language-symbology-settings-exceeded-max-classes-title"));
                                    }
                                    var targetClasses_1 = _this.isNumericAttribute.get() ? _this.numBreaks.get() : _this.maxRenderClasses;
                                    // Local layers can't be queried, so we'll just sort these by count
                                    if (attribute.layer instanceof mapping.infrastructure.LayerIntegrationUtils.LocalLayer) {
                                        // Sort and slice the array of classes
                                        var sortedItems = _this.symbologyClasses.getItems().sort(function (a, b) {
                                            if (a.count < b.count) {
                                                return 1;
                                            }
                                            if (a.count > b.count) {
                                                return -1;
                                            }
                                            return 0;
                                        });
                                        _this.symbologyClasses.set(sortedItems.slice(0, targetClasses_1));
                                        resolve();
                                    }
                                    else {
                                        // Prefer features that occur within the map extent
                                        var extent = _this.app.map.extent;
                                        // Set up the query task
                                        var query = new esri.tasks.Query();
                                        var queryTask = infrastructure.taskUtils.getQueryTask(attribute.layer);
                                        query.returnGeometry = false;
                                        query.geometry = extent;
                                        query.outFields = [attribute.name];
                                        queryTask.execute(query).then(function (featureSet) {
                                            var localFeatures = _this._findDistinctValues(featureSet, attribute.name);
                                            // Sort and slice the array of classes
                                            var sortedItems = _this.symbologyClasses.getItems().sort(function (a, b) {
                                                if (localFeatures.indexOf(a.name) === -1 && localFeatures.indexOf(b.name) > -1) {
                                                    return 1;
                                                }
                                                if (localFeatures.indexOf(a.name) > -1 && localFeatures.indexOf(b.name) === -1) {
                                                    return -1;
                                                }
                                                if (a.count < b.count) {
                                                    return 1;
                                                }
                                                if (a.count > b.count) {
                                                    return -1;
                                                }
                                                return 0;
                                            });
                                            _this.symbologyClasses.set(sortedItems.slice(0, targetClasses_1));
                                            resolve();
                                        });
                                    }
                                }
                                else {
                                    resolve();
                                }
                            });
                            return promise;
                        };
                        /**
                         * Returns distinct values for an attribute in a feature set
                         * Note that a distinct value query using esri's API methods does not work on some layers, specifically FeatureService feature layers
                         * @param featureSet
                         * @param attribute
                         */
                        AttributeSymbologySettingsViewModel.prototype._findDistinctValues = function (featureSet, attribute) {
                            var unique = {};
                            var distinct = [];
                            var rawValues = featureSet.features.map(function (f) { return f.attributes[attribute]; });
                            for (var i = 0; i < rawValues.length; i++) {
                                if (!unique[rawValues[i]]) {
                                    distinct.push(rawValues[i]);
                                }
                                unique[rawValues[i]] = true;
                            }
                            return distinct;
                        };
                        /**
                         * Given an essentials field, get the fieldInfo object used for formatting and resolving domains
                         * @param field
                         */
                        AttributeSymbologySettingsViewModel.prototype.getFieldInfo = function (field) {
                            var esriField;
                            var promise = new Promise(function (resolve, reject) {
                                // If this is a feature layer already we can just grab the info we need from there
                                if (field.layer.mapService.serviceLayer instanceof esri.layers.FeatureLayer) {
                                    var featureLayer = field.layer.mapService.serviceLayer;
                                    esriField = featureLayer.getField(field.name);
                                    resolve(infrastructure.gis.FieldInfo.fromEsriField(esriField, featureLayer, field));
                                }
                                else {
                                    field.layer.getFeatureLayer().then(function (featureLayer) {
                                        esriField = featureLayer.getField(field.name);
                                        resolve(infrastructure.gis.FieldInfo.fromEsriField(esriField, featureLayer, field));
                                    });
                                }
                            });
                            return promise;
                        };
                        return AttributeSymbologySettingsViewModel;
                    }(geocortex.framework.ui.ViewModelBase));
                    visualization.AttributeSymbologySettingsViewModel = AttributeSymbologySettingsViewModel;
                })(visualization = infrastructure.visualization || (infrastructure.visualization = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var DataClassification;
                (function (DataClassification) {
                    /**
                    * Ckmeans clustering is an improvement on heuristic-based clustering
                    * approaches like Jenks. The algorithm was developed by
                    * Haizhou Wang and Mingzhou Song (http://journal.r-project.org/archive/2011-2/RJournal_2011-2_Wang+Song.pdf)
                    * as a dynamic programming(https://en.wikipedia.org/wiki/Dynamic_programming) approach
                    * to the problem of clustering numeric data into groups with the least
                    * within-group sum-of-squared-deviations.
                    *
                    * Minimizing the difference within groups - what Wang & Song refer to as
                    * `withinss`, or within sum-of-squares, means that groups are optimally
                    * homogenous within and the data is split into representative groups.
                    * This is very useful for visualization, where you may want to represent
                    * a continuous variable in discrete color or style groups. This function
                    * can provide groups that emphasize differences between data.
                    *
                    * From the JavaScript implementation by Tom MacWright
                    * https://github.com/simple-statistics
                    * Original copyright notice follows:
                    *
                    * Copyright (c) 2014, Tom MacWright
                    *
                    * Permission to use, copy, modify, and/or distribute this software for any
                    * purpose with or without fee is hereby granted, provided that the above
                    * copyright notice and this permission notice appear in all copies.
                    *
                    * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
                    * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
                    * FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
                    * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
                    * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
                    * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
                    * PERFORMANCE OF THIS SOFTWARE.
                    *
                    * @param data The data to classify
                    * @param numClusters The number of desired classes
                    */
                    function ckmeans(data, numClusters) {
                        // Cannot generate more clusters than there are data values
                        if (numClusters > data.length) {
                            return [];
                        }
                        // Sort data in numerical order
                        var sorted = data.slice().sort(function (a, b) { return a - b; });
                        // Maximum number of classes
                        var uniqueCount = DataClassification.uniqueCountSorted(sorted);
                        // Matrix and backtrack matrix
                        var matrix = DataClassification.createMatrix(numClusters, sorted.length);
                        var backtrackMatrix = DataClassification.createMatrix(numClusters, sorted.length);
                        // This is a dynamic programming way to solve the problem of minimizing
                        // within-cluster sum of squares. It's similar to linear regression
                        // in this way, and this calculation incrementally computes the
                        // sum of squares that are later read.
                        // The outer loop iterates through clusters, from 0 to numClusters
                        for (var cluster = 0; cluster < numClusters; cluster++) {
                            // At the start of each loop, the mean starts as the first element
                            var firstClusterMean = sorted[0];
                            // sIndex: sortedIndex. Iterate through all sorted values, starting at the minimum number required to create 'cluster' clusters.
                            for (var sIndex = Math.max(cluster, 1); sIndex < sorted.length; sIndex++) {
                                if (cluster === 0) {
                                    // Increase the running sum of squares calculation by this new value
                                    var squaredDifference = Math.pow(sorted[sIndex] - firstClusterMean, 2);
                                    // We are iteratively computing the following
                                    // d(x1,...,xi) = d(x1,...,xi-1) + (i - (1 / i)) * Math.pow(xi - mi-1, 2)
                                    // Where 'mi-1' denotes the mean of the first i-1 elements
                                    // And d(x1,...,xi) will represent the minimum sum of squares when 'i' elements are placed in 'cluster' clusters
                                    matrix[cluster][sIndex] = matrix[cluster][sIndex - 1] + (sIndex / (sIndex + 1)) * squaredDifference;
                                    // Computing a running mean by taking the previous mean value, multiplying it by the number of elements
                                    // seen so far, and then dividing it by the number of elements total.
                                    var newSum = sIndex * firstClusterMean + sorted[sIndex];
                                    firstClusterMean = newSum / (sIndex + 1);
                                }
                                else {
                                    var sumSquaredDistances = 0;
                                    var meanXJ = 0;
                                    // Starting from the current index, progressively compute d(xj,...,xi) based on d(xj+1,...,xi)
                                    for (var j = sIndex; j >= cluster; j--) {
                                        // Running sum of squares calculation
                                        sumSquaredDistances += (sIndex - j) / (sIndex - j + 1) * Math.pow(sorted[j] - meanXJ, 2);
                                        // Running mean calculation
                                        meanXJ = (sorted[j] + (sIndex - j) * meanXJ) / (sIndex - j + 1);
                                        // First iteration of the loop through sorted values
                                        if (j === sIndex) {
                                            // Assign initial values to the matrix and backtrackMatrix
                                            matrix[cluster][sIndex] = sumSquaredDistances;
                                            backtrackMatrix[cluster][sIndex] = j;
                                            // d[cluster - 1][j - 1] will represent an optimal solution for j - 1 points
                                            if (j > 0) {
                                                matrix[cluster][sIndex] += matrix[cluster - 1][j - 1];
                                            }
                                        }
                                        else {
                                            // If this is a better solution, store and index it
                                            if (sumSquaredDistances + matrix[cluster - 1][j - 1] < matrix[cluster][sIndex]) {
                                                matrix[cluster][sIndex] = sumSquaredDistances + matrix[cluster - 1][j - 1];
                                                backtrackMatrix[cluster][sIndex] = j;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        // The real work of Ckmeans clustering happens in the matrix generation:
                        // the generated matrices encode all possible clustering combinations, and
                        // once they're generated we can solve for the best clustering groups very quickly.
                        var clusters = [];
                        var clusterRight = backtrackMatrix[0].length - 1;
                        // Backtrack the clusters from the dynamic programming matrix. This
                        // starts at the bottom-right corner of the matrix (if the top-left is 0, 0),
                        // and moves the cluster target with the loop.
                        for (var cluster = backtrackMatrix.length - 1; cluster >= 0; cluster--) {
                            var clusterLeft = backtrackMatrix[cluster][clusterRight];
                            // Fill the cluster from the sorted input by taking a slice of the
                            // array. The backtrack matrix makes this easy - it stores the
                            // indexes where the cluster should start and end.
                            clusters[cluster] = sorted.slice(clusterLeft, clusterRight + 1);
                            if (cluster > 0) {
                                clusterRight = clusterLeft - 1;
                            }
                        }
                        return clusters;
                    }
                    DataClassification.ckmeans = ckmeans;
                    /**
                     * Create a new column x row matrix.
                     */
                    function createMatrix(columns, rows) {
                        var matrix = [];
                        for (var i = 0; i < columns; i++) {
                            var column = [];
                            for (var j = 0; j < rows; j++) {
                                column.push(0);
                            }
                            matrix.push(column);
                        }
                        return matrix;
                    }
                    DataClassification.createMatrix = createMatrix;
                    /**
                     * For a sorted input, counting the number of unique values
                     * is possible in constant time and constant memory. This is
                     * a simple implementation of the algorithm.
                     *
                     * Values are compared with `===`, so objects and non-primitive objects
                     * are not handled in any special way.
                     */
                    function uniqueCountSorted(input) {
                        var uniqueValueCount = 0;
                        var lastSeenValue;
                        for (var i = 0; i < input.length; i++) {
                            if (i === 0 || input[i] != lastSeenValue) {
                                lastSeenValue = input[i];
                                uniqueValueCount++;
                            }
                        }
                        return uniqueValueCount;
                    }
                    DataClassification.uniqueCountSorted = uniqueCountSorted;
                    /**
                     * Attempts to find a reasonable number of significant digits for the created breaks
                     * Probably not possible to be 100% correct with all possible data sets,
                     * but should err on the side of too much significance, rather than too little.
                     * @param numbers
                     */
                    function findSignificanceFactor(numbers) {
                        var decimalPoint = DataClassification.getDecimalSeparator();
                        // Find the decimal portion of each number. 
                        // Uses string manipulation as n - Math.floor(n) produces bad results with too much significance.
                        var decimalPortion = numbers.filter(function (n) { return n !== null; }).map(function (n) {
                            var decimal = n.toString().split(decimalPoint)[1];
                            return decimal ? parseFloat(decimal) / Math.pow(10, decimal.length) : 0;
                        });
                        // Find the whole portion of each number
                        var wholeNumbers = numbers.filter(function (n) { return n !== null; }).map(function (n) {
                            return Math.floor(n);
                        });
                        // Find the minimum power of 10 in the whole number dataset
                        var minWhole = Math.min.apply(Math, wholeNumbers.filter(function (w) { return w !== 0; }));
                        var minPower;
                        if (minWhole === 0 || minWhole === Infinity) {
                            minPower = 0;
                        }
                        else {
                            minPower = Math.floor(Math.log(Math.abs(minWhole)) / Math.LN10);
                        }
                        // Find the maximum power of 10 in the whole number dataset
                        var maxWhole = Math.max.apply(Math, wholeNumbers);
                        var maxPower;
                        if (maxWhole === 0) {
                            minPower = 0;
                        }
                        else {
                            maxPower = Math.floor(Math.log(Math.abs(maxWhole)) / Math.LN10);
                        }
                        // How many powers of 10 the whole numbers span
                        var powerRange = maxPower - minPower;
                        // Find the maximum power of 10 in the decimal dataset
                        var maxDecimal = Math.max.apply(Math, decimalPortion.filter(function (d) { return d !== 0; }));
                        // No decimals? Return the range of the powers of the numbers - the power of the range of numbers as the significance
                        if (maxDecimal === 0 || Math.abs(maxDecimal) === Infinity) {
                            var numericRange = maxWhole - minWhole;
                            var numericRangePower = Math.floor(Math.log(Math.abs(numericRange)) / Math.LN10);
                            return Math.pow(10, powerRange - numericRangePower < 0 ? 0 : powerRange - numericRangePower);
                        }
                        // Find the maximum power of 10 in the decimals dataset
                        var maxDecimalPower = Math.floor(Math.log(Math.abs(maxDecimal)) / Math.LN10);
                        // Find the minimum power of 10 in the decimal dataset
                        var minDecimal = Math.min.apply(Math, decimalPortion.filter(function (d) { return d !== 0; }));
                        var minDecimalPower;
                        if (minDecimal === 0 || Math.abs(minDecimal) === Infinity) {
                            minDecimalPower = 0;
                        }
                        else {
                            minDecimalPower = Math.floor(Math.log(Math.abs(minDecimal)) / Math.LN10);
                        }
                        // Find the range of the decimal powers
                        var decimalPowerRange = maxDecimalPower - minDecimalPower;
                        // If the range of the decimals is small, include all of them
                        if (decimalPowerRange <= 1) {
                            var decimalPlaces = decimalPortion.map(function (d) {
                                var decimal = d.toString().split(decimalPoint)[1];
                                return decimal ? decimal.length : 0;
                            });
                            var maxDecimalPlaces = Math.max.apply(Math, decimalPlaces);
                            return (Math.pow(10, -maxDecimalPlaces));
                        }
                        return Math.pow(10, minDecimalPower + powerRange);
                    }
                    DataClassification.findSignificanceFactor = findSignificanceFactor;
                    /**
                     * Gets the internationalized decimal separator
                     */
                    function getDecimalSeparator() {
                        var n = 1.1;
                        var separator = n.toLocaleString().substring(1, 2);
                        return separator;
                    }
                    DataClassification.getDecimalSeparator = getDecimalSeparator;
                })(DataClassification = infrastructure.DataClassification || (infrastructure.DataClassification = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var visualization;
                (function (visualization) {
                    /**
                     * Encapulates some common color operations useful for making symbology.
                     * Primary use is to generate the RGB hexidecimal color code for a color in HSV (hue, saturation, value) color space.
                     * This is far preferable to using RGB for mapping applications, as random colors generated
                     * in RGB will trend towards the dark and unsaturated, and often look quite similar.
                     * To use, supply a number between 0 and 1 for each of hue, saturation, and value.
                     * To generate a series of random colors with a consistent tone, supply a random number for 'hue' only.
                     */
                    var SymbolColor = (function () {
                        /**
                         * SymbolColor can be instantiated with HSV values, RGB values, or a RGB hex string
                         * All raw values supplied should be in the range 0..1
                         * @param color
                         */
                        function SymbolColor(color) {
                            if (this.isHSV(color)) {
                                this.hue = this.clamp(color.h, 0, 1);
                                this.value = this.clamp(color.v, 0, 1);
                                this.saturation = this.clamp(color.s, 0, 1);
                            }
                            else if (this.isRGB(color)) {
                                var hsv = this.fromRGB({ r: this.clamp(color.r, 0, 1), g: this.clamp(color.g, 0, 1), b: this.clamp(color.b, 0, 1) });
                                this.hue = hsv.h;
                                this.value = hsv.v;
                                this.saturation = hsv.s;
                            }
                            else {
                                var rgb = this.hexToRGB(color);
                                var hsv = this.fromRGB(rgb);
                                this.hue = hsv.h;
                                this.value = hsv.v;
                                this.saturation = hsv.s;
                            }
                        }
                        /**
                         * Returns a hexidecimal string representing the color.
                         */
                        SymbolColor.prototype.toHex = function () {
                            var color = this.toRGB();
                            return this.rgbToHex(color);
                        };
                        /**
                         * Darkens the color by an amount and returns a hex string
                         * @param amount ranges from 0..1
                         */
                        SymbolColor.prototype.darken = function (amount) {
                            amount = this.clamp(amount, 0, 1);
                            return new SymbolColor({ h: this.hue, v: this.value * (1 - amount), s: this.saturation });
                        };
                        /**
                         * Lightens the color by an amount and returns a hex string
                         * @param amount ranges from 0..1
                         */
                        SymbolColor.prototype.lighten = function (amount) {
                            amount = this.clamp(amount, 0, 1);
                            return new SymbolColor({ h: this.hue, v: this.value + ((1 - this.value) * amount), s: this.saturation * (1 - amount) });
                        };
                        /**
                         * Blend this color with another by an amount and return a new color
                         * Uses linear interpolation in the RGB colorspace.
                         * @param amount ranges from 0..1
                         * @param color another instance of SymbolColor
                         */
                        SymbolColor.prototype.blend = function (amount, color) {
                            amount = this.clamp(amount, 0, 1);
                            var target = color.toRGB();
                            var origin = this.toRGB();
                            var r = origin.r + (target.r - origin.r) * amount;
                            var b = origin.b + (target.b - origin.b) * amount;
                            var g = origin.g + (target.g - origin.g) * amount;
                            return new SymbolColor({ r: r, g: g, b: b });
                        };
                        /**
                         * Returns the raw RGB values of the color
                         * See https://en.wikipedia.org/wiki/HSL_and_HSV#Converting_to_RGB for a detailed discussion of this algorithm.
                         */
                        SymbolColor.prototype.toRGB = function () {
                            var r, g, b;
                            var chroma = this.saturation * this.value; // The chroma is the largest component of the color.
                            var h_prime = this.hue * 6; // The hue will fall within sectors 0 to 6 in the HSV colorspace.
                            var x = chroma * (1 - Math.abs((h_prime % 2) - 1)); // x represents the second largest component of the color.
                            var min = this.value - chroma; // A minimum floor is added to each component to match the desired value.
                            switch (Math.floor(h_prime) % 6) {
                                case 0:
                                    r = chroma + min, g = x + min, b = min;
                                    break;
                                case 1:
                                    r = x + min, g = chroma + min, b = min;
                                    break;
                                case 2:
                                    r = min, g = chroma + min, b = x + min;
                                    break;
                                case 3:
                                    r = min, g = x + min, b = chroma + min;
                                    break;
                                case 4:
                                    r = x + min, g = min, b = chroma + min;
                                    break;
                                case 5:
                                    r = chroma + min, g = min, b = x + min;
                                    break;
                            }
                            return { r: r, g: g, b: b };
                        };
                        /**
                         * Is this color the same as the supplied color?
                         * @param color
                         */
                        SymbolColor.prototype.equals = function (color) {
                            if (color.hue === this.hue && color.value === this.value && color.saturation === this.saturation) {
                                return true;
                            }
                            return false;
                        };
                        /**
                         * Converts raw RGB values to their HSV equivalents. Reverse of the above
                         * Also discussed on this page: https://en.wikipedia.org/wiki/HSL_and_HSV
                         * @param color
                         */
                        SymbolColor.prototype.fromRGB = function (color) {
                            var h, s, v;
                            var max = Math.max(color.r, color.g, color.b);
                            var min = Math.min(color.r, color.g, color.b);
                            var chroma = max - min;
                            // hue
                            var h_prime;
                            if (chroma === 0) {
                                h_prime = 0;
                            }
                            else if (max === color.r) {
                                h_prime = (color.g - color.b) / chroma;
                            }
                            else if (max === color.g) {
                                h_prime = 2 + (color.b - color.r) / chroma;
                            }
                            else {
                                h_prime = 4 + (color.r - color.g) / chroma;
                            }
                            h = h_prime / 6;
                            if (h < 0) {
                                h = h + 1;
                            }
                            // saturation
                            s = chroma === 0 ? 0 : chroma / max;
                            // value
                            v = max;
                            return { h: h, s: s, v: v };
                        };
                        /**
                         * Convert raw RGB values to a hex string
                         * @param color
                         */
                        SymbolColor.prototype.rgbToHex = function (color) {
                            var r_hex = ("00" + (Math.floor(color.r * 255)).toString(16)).slice(-2);
                            var g_hex = ("00" + (Math.floor(color.g * 255)).toString(16)).slice(-2);
                            var b_hex = ("00" + (Math.floor(color.b * 255)).toString(16)).slice(-2);
                            return "#" + r_hex + g_hex + b_hex;
                        };
                        /**
                         * Returns rgb values from 0..1 given an RGB hex string. Short format is acceptable.
                         * See: http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
                         * @param hex
                         */
                        SymbolColor.prototype.hexToRGB = function (hex) {
                            // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
                            var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                            hex = hex.replace(shorthandRegex, function (m, r, g, b) {
                                return r + r + g + g + b + b;
                            });
                            var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                            return result ? {
                                r: parseInt(result[1], 16) / 255,
                                g: parseInt(result[2], 16) / 255,
                                b: parseInt(result[3], 16) / 255
                            } : null;
                        };
                        /**
                         * Clamp a number between two values
                         * @param n
                         * @param min
                         * @param max
                         */
                        SymbolColor.prototype.clamp = function (n, min, max) {
                            return Math.min(Math.max(n, min), max);
                        };
                        /**
                         * Custom type guard for raw values in HSV format
                         * @param a
                         */
                        SymbolColor.prototype.isHSV = function (a) {
                            if ($.isNumeric(a.h) && $.isNumeric(a.s) && $.isNumeric(a.v)) {
                                return true;
                            }
                            return false;
                        };
                        /**
                         * Custom type guard for raw values in RGB format
                         * @param a
                         */
                        SymbolColor.prototype.isRGB = function (a) {
                            if ($.isNumeric(a.r) && $.isNumeric(a.g) && $.isNumeric(a.b)) {
                                return true;
                            }
                            return false;
                        };
                        return SymbolColor;
                    }());
                    visualization.SymbolColor = SymbolColor;
                })(visualization = infrastructure.visualization || (infrastructure.visualization = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var visualization;
                (function (visualization) {
                    /**
                     * The symbology settings widget view.
                     */
                    var SymbologySettingsView = (function (_super) {
                        __extends(SymbologySettingsView, _super);
                        function SymbologySettingsView() {
                            _super.apply(this, arguments);
                        }
                        /**
                         * Acquire the currently selected color swatch.
                         */
                        SymbologySettingsView.prototype.getSelectedColorSwatch = function () {
                            var swatches = this.viewModel.colorSwatches.get();
                            for (var i = 0; i < swatches.length; i++) {
                                var swatch = swatches[i];
                                var radio = this.colorSwatchFieldSet.children[i].querySelector("input[type=radio]");
                                if (radio.checked) {
                                    return swatch;
                                }
                            }
                        };
                        /**
                         * Attach this view to its view-model.
                         */
                        SymbologySettingsView.prototype.attach = function (viewModel) {
                            viewModel.initialize(this.configuration);
                            _super.prototype.attach.call(this, viewModel);
                            this.setupJQuerySliders();
                        };
                        /**
                         * This widget attaches a reference to itself onto the parent view.
                         */
                        SymbologySettingsView.prototype.added = function (parentView) {
                            parentView.symbologySettingsWidget = this;
                            _super.prototype.added.call(this, parentView);
                        };
                        /**
                         * Apply the configured settings to the widget.
                         */
                        SymbologySettingsView.prototype.applyConfiguration = function () {
                            var _this = this;
                            var configuration = this.viewModel.config;
                            // Set this flag so that the event handler doesn't run on the slider changes we are making here
                            this.configuring = true;
                            // Set initial values.
                            this.colorInput.value = this.viewModel.colors[0].toHex();
                            this.markerStyleInput.selectedIndex = this.viewModel.markerStyleIndex >= 0 ? this.viewModel.markerStyleIndex : 0;
                            this.lineStyleInput.selectedIndex = this.viewModel.lineStyleIndex >= 0 ? this.viewModel.lineStyleIndex : 0;
                            this.fillStyleInput.selectedIndex = this.viewModel.fillStyleIndex >= 0 ? this.viewModel.fillStyleIndex : 0;
                            // Initialize color swatches.
                            this.viewModel.colorSwatches.set(this.viewModel.colors.map(function (color) { return ({ hex: color.toHex() }); }));
                            this.viewModel.colorSwatches.get().forEach(function (swatch, index) {
                                var label = _this.colorSwatchFieldSet.children[index];
                                label.style.backgroundColor = swatch.hex;
                            });
                            this.colorSwatchFieldSet.querySelector(".color-swatch:first-child > input[type=radio]").checked = true;
                            // Set initial values for the sliders
                            $(this.transparencySlider).slider("option", "value", this.viewModel.transparency.get());
                            $(this.markerSizeSlider).slider("option", "value", this.viewModel.markerSize.get());
                            $(this.lineWidthSlider).slider("option", "value", this.viewModel.lineWidth.get());
                            // Pulse to update the view-model with this initial state.
                            this.configuring = false;
                            this.handleChange();
                        };
                        SymbologySettingsView.prototype.reset = function () {
                            this.viewModel.reset();
                        };
                        /**
                         * Set view-model observables and populate the `symbols` object based on any changes here in the view.
                         */
                        SymbologySettingsView.prototype.handleChange = function () {
                            // If in the process of configuring the widget, wait untill all changes have been applied
                            if (this.configuring) {
                                return;
                            }
                            // Setting some observables that are used to provide feedback to the user.
                            this.viewModel.transparency.set($(this.transparencySlider).slider("value"));
                            this.viewModel.markerSize.set($(this.markerSizeSlider).slider("value"));
                            this.viewModel.lineWidth.set($(this.lineWidthSlider).slider("value"));
                            // Gathering and preserving the information needed to create the symbols.
                            var color = this.viewModel.useColorSwatches.get()
                                ? esri.Color.fromHex(this.getSelectedColorSwatch().hex)
                                : esri.Color.fromHex(this.colorInput.value);
                            this.viewModel.markerStyleIndex = this.markerStyleInput.selectedIndex;
                            var markerStyle = this.viewModel.markerStyles.getAt(this.viewModel.markerStyleIndex).style;
                            this.viewModel.lineStyleIndex = this.lineStyleInput.selectedIndex;
                            var lineStyle = this.viewModel.lineStyles.getAt(this.viewModel.lineStyleIndex).style;
                            this.viewModel.fillStyleIndex = this.fillStyleInput.selectedIndex;
                            var fillStyle = this.viewModel.fillStyles.getAt(this.viewModel.fillStyleIndex).style;
                            var markerSize = this.viewModel.markerSize.get();
                            var lineWidth = this.viewModel.lineWidth.get();
                            // Setting color alpha (opacity) based on transparency.
                            color.a = ((this.viewModel.transparency.get() / 100) * -1) + 1; // Inverting transparency into opacity.
                            var line = new esri.symbol.SimpleLineSymbol();
                            // If this is a polyline or being used in a "cross" or "x" type simplemarkersymbol just set the line color to the color
                            if ((this.viewModel.noFill.get() && this.viewModel.noMarker.get()) || (!this.viewModel.noMarker.get() && (markerStyle === "cross" || markerStyle === "x"))) {
                                line.setColor(color);
                            }
                            else {
                                if (this.viewModel.config.selectOutlineColor) {
                                    // Use the selected outline color
                                    line.setColor(esri.Color.fromHex(this.viewModel.outlineColors[0].toHex()));
                                }
                                else {
                                    // Generate an appropriate outline color given the selected color
                                    var symbolColor = new visualization.SymbolColor(color.toHex());
                                    // If the color is light, darken the outline
                                    if (symbolColor.value >= 0.7) {
                                        line.setColor(esri.Color.fromHex(symbolColor.darken(0.5).toHex()));
                                    }
                                    else {
                                        line.setColor(esri.Color.fromHex(symbolColor.lighten(0.9).toHex()));
                                    }
                                }
                            }
                            line.setStyle(lineStyle);
                            line.setWidth(lineWidth);
                            // Points.
                            var marker = new esri.symbol.SimpleMarkerSymbol();
                            marker.setColor(color);
                            marker.setStyle(markerStyle);
                            marker.setSize(markerSize);
                            marker.setOutline(line);
                            // Polygons.
                            var fill = new esri.symbol.SimpleFillSymbol();
                            fill.setColor(color);
                            fill.setStyle(fillStyle);
                            fill.setOutline(line);
                            // Setting the symbols on the view-model.
                            this.viewModel.symbols = { marker: marker, line: line, fill: fill };
                            // Let the view model know what color was selected 
                            this.viewModel.selectedSwatch = this.getSelectedColorSwatch();
                            this.viewModel.colors[0] = new visualization.SymbolColor(this.colorInput.value);
                        };
                        /**
                         * The sliders need to be set up before they are functional
                         */
                        SymbologySettingsView.prototype.setupJQuerySliders = function () {
                            var _this = this;
                            var configuration = this.viewModel.config;
                            // Apply transparency slider configuration.
                            $(this.transparencySlider).slider({
                                min: configuration.transparency.min,
                                max: configuration.transparency.max,
                                value: configuration.transparency.value,
                                step: configuration.transparency.step,
                                slide: function (e, ui) { return _this._handleSliderValueChanged(e, ui, _this.viewModel.transparency); }
                            });
                            // Apply marker size slider configuration.
                            $(this.markerSizeSlider).slider({
                                min: configuration.markerSize.min,
                                max: configuration.markerSize.max,
                                value: configuration.markerSize.value,
                                step: configuration.markerSize.step,
                                slide: function (e, ui) { return _this._handleSliderValueChanged(e, ui, _this.viewModel.markerSize); }
                            });
                            // Apply line width slider configuration.
                            $(this.lineWidthSlider).slider({
                                min: configuration.lineWidth.min,
                                max: configuration.lineWidth.max,
                                value: configuration.lineWidth.value,
                                step: configuration.lineWidth.step,
                                slide: function (e, ui) { return _this._handleSliderValueChanged(e, ui, _this.viewModel.lineWidth); }
                            });
                            // Realizing jQuery slider changes as legitmate change events.
                            $(this.transparencySlider).add(this.markerSizeSlider).add(this.lineWidthSlider)
                                .off("slidechange").on("slidechange", function (event) {
                                // jQuery's `.trigger` isn't firing our data-bindings, so we're using native DOM methods which appear to work instead.
                                var changeEvent = document.createEvent("Event");
                                changeEvent.initEvent("change", true, true);
                                _this.container.dispatchEvent(changeEvent);
                            });
                        };
                        SymbologySettingsView.prototype._handleSliderValueChanged = function (event, ui, prop) {
                            if (ui && ui.value != undefined) {
                                prop.set(ui.value);
                            }
                        };
                        return SymbologySettingsView;
                    }(geocortex.framework.ui.ViewBase));
                    visualization.SymbologySettingsView = SymbologySettingsView;
                })(visualization = infrastructure.visualization || (infrastructure.visualization = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var visualization;
                (function (visualization) {
                    /**
                     * View-model for the symbology settings widget.
                     * Line symbolization options are always needed (of course for polylines, but also for points and polygons as outlines).
                     * Marker and fill symbolization options are optional.
                     */
                    var SymbologySettingsViewModel = (function (_super) {
                        __extends(SymbologySettingsViewModel, _super);
                        function SymbologySettingsViewModel() {
                            _super.apply(this, arguments);
                            /** Disables availability of marker related options. */
                            this.noMarker = new Observable(false);
                            /** Disables availability of fill related options. */
                            this.noFill = new Observable(false);
                            /** Observable for the user-selected fill transparency. */
                            this.transparency = new Observable(10);
                            /** Observable for the outline transparency */
                            this.outlineTransparency = new Observable(0);
                            /** Observable for the user-selected marker size. */
                            this.markerSize = new Observable(10);
                            /** Observable for the user-selected line width. */
                            this.lineWidth = new Observable(2);
                            /** Whether or not to use swatches instead of native color input. */
                            this.useColorSwatches = new Observable(true);
                            /** Color swatches available to choose from. */
                            this.colorSwatches = new ObservableCollection();
                            /** These are used to translate style ids from Esri JS API to Esri REST API form */
                            this.markerStyleIdLookup = {
                                "circle": "esriSMSCircle",
                                "cross": "esriSMSCross",
                                "diamond": "esriSMSDiamond",
                                "square": "esriSMSSquare",
                                "x": "esriSMSX"
                            };
                            this.lineStyleIdLookup = {
                                "solid": "esriSLSSolid",
                                "dash": "esriSLSDash",
                                "dashdot": "esriSLSDashDot",
                                "dashdotdot": "esriSLSLDashDotDot",
                                "dot": "esriSLSDot",
                                "longdash": "esriSLSLongDash",
                                "longdashdot": "esriSLSLongDashDot",
                                "shortdash": "esriSLSShortDash",
                                "shortdashdot": "esriSLSShortDashDot",
                                "shortdashdotdot": "esriSLSShortDashDotDot",
                                "shortdot": "esriSLSShortDot"
                            };
                            this.fillStyleIdLookup = {
                                "solid": "esriSFSSolid",
                                "horizontal": "esriSFSHorizontal",
                                "vertical": "esriSFSVertical",
                                "cross": "esriSFSCross",
                                "diagonalcross": "esriSFSDiagonalCross",
                                "forwarddiagonal": "esriSFSForwardDiagonal",
                                "backwarddiagonal": "esriSFSBackwardDiagonal",
                                "null": "esriSFSNull"
                            };
                            /** Styles available to point markers. */
                            this.markerStyles = new ObservableCollection([
                                {
                                    style: esri.symbol.SimpleMarkerSymbol.STYLE_CIRCLE,
                                    label: this.getResource("language-symbology-settings-marker-style-circle")
                                },
                                {
                                    style: esri.symbol.SimpleMarkerSymbol.STYLE_CROSS,
                                    label: this.getResource("language-symbology-settings-marker-style-cross")
                                },
                                {
                                    style: esri.symbol.SimpleMarkerSymbol.STYLE_DIAMOND,
                                    label: this.getResource("language-symbology-settings-marker-style-diamond")
                                },
                                {
                                    style: esri.symbol.SimpleMarkerSymbol.STYLE_SQUARE,
                                    label: this.getResource("language-symbology-settings-marker-style-square")
                                },
                                {
                                    style: esri.symbol.SimpleMarkerSymbol.STYLE_X,
                                    label: this.getResource("language-symbology-settings-marker-style-x")
                                }
                            ]);
                            /** Styles available to lines. */
                            this.lineStyles = new ObservableCollection([
                                {
                                    style: esri.symbol.SimpleLineSymbol.STYLE_SOLID,
                                    label: this.getResource("language-symbology-settings-line-style-solid"),
                                    styleId: "esriSLSSolid"
                                },
                                {
                                    style: esri.symbol.SimpleLineSymbol.STYLE_DASH,
                                    label: this.getResource("language-symbology-settings-line-style-dash"),
                                    styleId: "esriSLSDash"
                                },
                                {
                                    style: esri.symbol.SimpleLineSymbol.STYLE_DASHDOT,
                                    label: this.getResource("language-symbology-settings-line-style-dashdot"),
                                    styleId: "esriSLSDashDot"
                                },
                                {
                                    style: esri.symbol.SimpleLineSymbol.STYLE_DASHDOTDOT,
                                    label: this.getResource("language-symbology-settings-line-style-dashdotdot"),
                                    styleId: "esriSLSDashDotDot"
                                },
                                {
                                    style: esri.symbol.SimpleLineSymbol.STYLE_DOT,
                                    label: this.getResource("language-symbology-settings-line-style-dot"),
                                    styleId: "esriSLSDot"
                                },
                                {
                                    style: esri.symbol.SimpleLineSymbol.STYLE_LONGDASH,
                                    label: this.getResource("language-symbology-settings-line-style-longdash"),
                                    styleId: "esriSLSLongDash"
                                },
                                {
                                    style: esri.symbol.SimpleLineSymbol.STYLE_LONGDASHDOT,
                                    label: this.getResource("language-symbology-settings-line-style-longdashdot"),
                                    styleId: "esriSLSLongDashDot"
                                },
                                {
                                    style: esri.symbol.SimpleLineSymbol.STYLE_SHORTDASH,
                                    label: this.getResource("language-symbology-settings-line-style-shortdash"),
                                    styleId: "esriSLSShortDash"
                                },
                                {
                                    style: esri.symbol.SimpleLineSymbol.STYLE_SHORTDASHDOT,
                                    label: this.getResource("language-symbology-settings-line-style-shortdashdot"),
                                    styleId: "esriSLSShortDashDot"
                                },
                                {
                                    style: esri.symbol.SimpleLineSymbol.STYLE_SHORTDASHDOTDOT,
                                    label: this.getResource("language-symbology-settings-line-style-shortdashdotdot"),
                                    styleId: "esriSLSShortDashDotDot"
                                },
                                {
                                    style: esri.symbol.SimpleLineSymbol.STYLE_SHORTDOT,
                                    label: this.getResource("language-symbology-settings-line-style-shortdot"),
                                    styleId: "esriSLSShortDot"
                                }
                            ]);
                            /** Styles available to polygon fills. */
                            this.fillStyles = new ObservableCollection([
                                {
                                    style: esri.symbol.SimpleFillSymbol.STYLE_SOLID,
                                    label: this.getResource("language-symbology-settings-fill-style-solid"),
                                    styleId: "esriSFSSolid"
                                },
                                {
                                    style: esri.symbol.SimpleFillSymbol.STYLE_HORIZONTAL,
                                    label: this.getResource("language-symbology-settings-fill-style-horizontal"),
                                    styleId: "esriSFSHorizontal"
                                },
                                {
                                    style: esri.symbol.SimpleFillSymbol.STYLE_VERTICAL,
                                    label: this.getResource("language-symbology-settings-fill-style-vertical"),
                                    styleId: "esriSFSVertical"
                                },
                                {
                                    style: esri.symbol.SimpleFillSymbol.STYLE_CROSS,
                                    label: this.getResource("language-symbology-settings-fill-style-cross"),
                                    styleId: "esriSFSCross"
                                },
                                {
                                    style: esri.symbol.SimpleFillSymbol.STYLE_DIAGONAL_CROSS,
                                    label: this.getResource("language-symbology-settings-fill-style-diagonal-cross"),
                                    styleId: "esriSFSDiagonalCross"
                                },
                                {
                                    style: esri.symbol.SimpleFillSymbol.STYLE_FORWARD_DIAGONAL,
                                    label: this.getResource("language-symbology-settings-fill-style-forward-diagonal"),
                                    styleId: "esriSFSForwardDiagonal"
                                },
                                {
                                    style: esri.symbol.SimpleFillSymbol.STYLE_BACKWARD_DIAGONAL,
                                    label: this.getResource("language-symbology-settings-fill-style-backward-diagonal"),
                                    styleId: "esriSFSBackwardDiagonal"
                                },
                                {
                                    style: esri.symbol.SimpleFillSymbol.STYLE_NULL,
                                    label: this.getResource("language-symbology-settings-fill-style-null"),
                                    styleId: "esriSFSNull"
                                }
                            ]);
                        }
                        /**
                         * Initialize the widget based on configuration.
                         */
                        SymbologySettingsViewModel.prototype.initialize = function (configuration) {
                            if (configuration === void 0) { configuration = {}; }
                            this.config = configuration;
                            // Default for alwaysUseColorSwatches.
                            configuration.alwaysUseColorSwatches = (configuration.alwaysUseColorSwatches != undefined) ? configuration.alwaysUseColorSwatches
                                : false;
                            // Default for numberOfColorSwatches.
                            configuration.numberOfColorSwatches = (!configuration.numberOfColorSwatches) ? configuration.numberOfColorSwatches : 6;
                            // Defaults for transparency range configuration.
                            this.config.transparency = configuration.transparency ? configuration.transparency
                                : { min: 0, max: 90, value: 10, step: 5 };
                            this.transparency.set(this.config.transparency.value);
                            // Defaults for markerSize range configuration.
                            this.config.markerSize = configuration.markerSize ? configuration.markerSize
                                : { min: 1, max: 25, value: 10, step: 1 };
                            this.markerSize.set(this.config.markerSize.value);
                            // Defaults for lineWidth range configuration.
                            this.config.lineWidth = configuration.lineWidth ? configuration.lineWidth
                                : { min: 0, max: 5, value: 2, step: 1 };
                            this.lineWidth.set(this.config.lineWidth.value);
                            // Overwriting the `markerStyles` observable with configuration, if it's specified.
                            if (configuration.markerStyles !== undefined) {
                                this.markerStyles.set(configuration.markerStyles);
                                this.markerStyleIndex = 0;
                            }
                            // Overwriting the `lineStyles` observable with configuration, if it's specified.
                            if (configuration.lineStyles !== undefined) {
                                this.lineStyles.set(configuration.lineStyles);
                                this.lineStyleIndex = 0;
                            }
                            // Overwriting the `fillStyles` observable with configuration, if it's specified.
                            if (configuration.fillStyles !== undefined) {
                                this.fillStyles.set(configuration.fillStyles);
                                this.fillStyleIndex = 0;
                            }
                            // Setting the `useColorSwatches` observable. We use the color swatches if either `alwaysUseColorSwatches` is true, or if the color input is not supported.
                            this.useColorSwatches.set(configuration.alwaysUseColorSwatches || !infrastructure.ColorUtils.isColorInputSupported());
                            // Set initial colors for the symbology
                            this.colors = infrastructure.ColorUtils.generateRandomColors(configuration.numberOfColorSwatches);
                            // Outline colors for when setting outline independently 
                            var colorIndex = 0;
                            this.outlineColors = this.colors.map(function (c) {
                                colorIndex++;
                                if (colorIndex % 2 === 0) {
                                    return c.darken(0.6);
                                }
                                else {
                                    return c.lighten(0.8);
                                }
                            });
                        };
                        /**
                         * Returns the widget to the default state (as defined by the configuration object)
                         */
                        SymbologySettingsViewModel.prototype.reset = function () {
                            this.transparency.set(this.config.transparency.value);
                            this.markerSize.set(this.config.markerSize.value);
                            this.lineWidth.set(this.config.lineWidth.value);
                            this.markerStyleIndex = 0;
                            this.lineStyleIndex = 0;
                            this.fillStyleIndex = 0;
                            this.colors = infrastructure.ColorUtils.generateRandomColors(this.config.numberOfColorSwatches);
                        };
                        /**
                         * Returns a renderer based on the current widget setttings as a JSON string
                         */
                        SymbologySettingsViewModel.prototype.getRenderer = function () {
                            var renderer = null;
                            // SimpleMarkerSymbol
                            if (!this.noMarker.get()) {
                                renderer = new esri.renderer.SimpleRenderer(this.symbols.marker);
                            }
                            else if (this.noFill.get()) {
                                renderer = new esri.renderer.SimpleRenderer(this.symbols.line);
                            }
                            else {
                                renderer = new esri.renderer.SimpleRenderer(this.symbols.fill);
                            }
                            return JSON.stringify(renderer.toJson());
                        };
                        /**
                         * Returns a symbol as a json string, based on the current widget settings
                         */
                        SymbologySettingsViewModel.prototype.getSymbol = function () {
                            var symbol = null;
                            // SimpleMarkerSymbol
                            if (!this.noMarker.get()) {
                                symbol = this.symbols.marker;
                            }
                            else if (this.noFill.get()) {
                                symbol = this.symbols.line;
                            }
                            else {
                                symbol = this.symbols.fill;
                            }
                            return JSON.stringify(symbol.toJson());
                        };
                        /**
                         * Returns the currently selected color
                         */
                        SymbologySettingsViewModel.prototype.getColor = function () {
                            if (this.useColorSwatches.get()) {
                                return new visualization.SymbolColor(this.selectedSwatch.hex);
                            }
                            else {
                                return this.colors[0];
                            }
                        };
                        /**
                         * Sets the state of the widget based on a supplied simple renderer
                         * @param renderer
                         */
                        SymbologySettingsViewModel.prototype.setFromRenderer = function (renderer) {
                            var ro = renderer.toJson();
                            if (ro.type === "simple" && ro.symbol) {
                                this._setFromSymbolObject(ro.symbol);
                            }
                        };
                        /**
                         * Sets the state of the widget based on a supplied symbol
                         * @param symbol
                         */
                        SymbologySettingsViewModel.prototype.setFromSymbol = function (symbol) {
                            var so = symbol.toJson();
                            this._setFromSymbolObject(so);
                        };
                        SymbologySettingsViewModel.prototype._setFromSymbolObject = function (so) {
                            var _this = this;
                            // set color
                            this.colors[0] = new visualization.SymbolColor({
                                r: so.color[0] / 255,
                                g: so.color[1] / 255,
                                b: so.color[2] / 255
                            });
                            // set outlineColor
                            var markerStyleId;
                            for (var key in this.markerStyleIdLookup) {
                                if (this.markerStyleIdLookup.hasOwnProperty(key) && so.style === this.markerStyleIdLookup[key]) {
                                    markerStyleId = key;
                                    break;
                                }
                            }
                            if (so.outline && (markerStyleId !== esri.symbol.SimpleMarkerSymbol.STYLE_CROSS && markerStyleId !== esri.symbol.SimpleMarkerSymbol.STYLE_X)) {
                                this.outlineColors[0] = new visualization.SymbolColor({
                                    r: so.outline.color[0] / 255,
                                    g: so.outline.color[1] / 255,
                                    b: so.outline.color[2] / 255
                                });
                            }
                            // set transparency, respecting the step values of the slider
                            this.transparency.set(Math.floor(Math.ceil(((255 - so.color[3]) / 255) * 100) / this.config.transparency.step) * this.config.transparency.step);
                            // set marker size and style
                            var markerStyle = this.markerStyles.getItems().filter(function (ms) { return ms.style === markerStyleId; })[0];
                            this.markerSize.set($.isNumeric(so.size) ? Math.floor(so.size * visualization.POINTS_TO_PIXELS) : this.config.markerSize.value);
                            this.markerStyleIndex = markerStyle ? this.markerStyles.indexOf(markerStyle) : 0;
                            // set line/outline size and style
                            var lineSymbol = (this.noFill.get() && this.noMarker.get()) ? so : so.outline;
                            this.lineWidth.set($.isNumeric(lineSymbol.width) ? Math.floor(lineSymbol.width * visualization.POINTS_TO_PIXELS) : this.config.lineWidth.value);
                            this.lineStyleIndex = lineSymbol.style
                                ? this.lineStyles.indexOf(this.lineStyles.getItems().filter(function (ls) { return _this.lineStyleIdLookup[ls.style] === lineSymbol.style; })[0])
                                : 0;
                            // set fill style
                            var fillStyle = this.fillStyles.getItems().filter(function (fs) { return _this.fillStyleIdLookup[fs.style] === so.style; })[0];
                            this.fillStyleIndex = fillStyle ? this.fillStyles.indexOf(fillStyle) : 0;
                        };
                        return SymbologySettingsViewModel;
                    }(geocortex.framework.ui.ViewModelBase));
                    visualization.SymbologySettingsViewModel = SymbologySettingsViewModel;
                    /**
                     * The size values in a renderer JSON object need to be converted from points to pixels in order
                     * to be able to recreate the same renderer using the JSAPI. 96dpi is assumed and there are 72 points in an inch.
                     */
                    visualization.POINTS_TO_PIXELS = 96 / 72;
                })(visualization = infrastructure.visualization || (infrastructure.visualization = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var visualization;
                (function (visualization_1) {
                    /**
                     * Base implementation of a {@link VisualizationProviderBase}.
                     * Not implemented.
                     */
                    var VisualizationProviderBase = (function () {
                        function VisualizationProviderBase(app, libraryId) {
                            /**
                             * The information about the visualizations provided by this provider in the visualization options.
                             */
                            this.visualizations = [];
                            /**
                             * The currently enabled visualization for this provider, if any
                             */
                            this.enabledVisualization = null;
                            /**
                             * The current geocortex layer this provider is providing visualization options for.
                             */
                            this.currentLayer = new Observable(null);
                            /**
                             * Whether or not this provider is enabled for the current layer.
                             */
                            this.isEnabled = new Observable(false);
                            /**
                             * Whether or not this provider is supported for the current layer.
                             */
                            this.isSupported = new Observable(false);
                            this.app = app;
                            this.libraryId = libraryId;
                            this.currentLayer.bind(this, this.handleCurrentLayerChanged);
                        }
                        /**
                         * Initialize the provider.
                         * @param config The configuration object.
                         */
                        VisualizationProviderBase.prototype.initialize = function (config) {
                            if (config.viewId) {
                                this.viewId = config.viewId;
                            }
                            if (config.displayName) {
                                this.displayName = config.displayName;
                            }
                        };
                        /**
                         * Whether or not the given layer supports this visualization provider.
                         * @param gcxLayer The layer to check if it supports this visualization.
                         */
                        VisualizationProviderBase.prototype.canSupport = function (gcxLayer) {
                            return false;
                        };
                        /**
                         * Handles updating the provider settings for the layer being set. This involves
                         * setting whether this visualization is enabled and supported for the given layer.
                         * @param gcxLayer The current layer.
                         */
                        VisualizationProviderBase.prototype.handleCurrentLayerChanged = function (gcxLayer) {
                            throw new Error("Not implemented");
                        };
                        /**
                         * Handles how to activate the visualization for the current layer.
                         */
                        VisualizationProviderBase.prototype.handleActivate = function (visualization) {
                            throw new Error("Not implemented");
                        };
                        /**
                         * Handles how to apply the visualization settings for the current layer.
                         */
                        VisualizationProviderBase.prototype.handleApply = function () {
                            throw new Error("Not implemented");
                        };
                        return VisualizationProviderBase;
                    }());
                    visualization_1.VisualizationProviderBase = VisualizationProviderBase;
                })(visualization = infrastructure.visualization || (infrastructure.visualization = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var highlightedLabel;
                (function (highlightedLabel) {
                    var HighlightedLabelUtils;
                    (function (HighlightedLabelUtils) {
                        var emHeight = null;
                        var emWidthDict = {};
                        var newLineRegex = /\r\n|\r|\n/g;
                        /**
                         * Measures the actual rendered size of a text label in pixels. Adding an actual element to the document is expensive, and since the measurement tool will always ask for dimensions of
                         * one single fixed font family and size, we cache dimensions for each letter of a font in a dictionary for later reuse. This ensures  only a limited number of page element additions
                         * and removals no matter how many labels are measured (this may be a large number if we're measuring actual features on the map using layer actions).
                         * @param labelStr The text label to measure label size for
                         * @param fontFamily The font family to be applied to the text
                         * @param size The size of the text in pixels
                         * @return An object with the width and height of the speciified label
                         */
                        function getLabelSize(labelStr, fontFamily, fontSize, layerId) {
                            var createElement = true;
                            var page = null;
                            var container = null;
                            var textNode = null;
                            var textSize = ((fontSize != undefined) && (typeof fontSize === "number")) ? fontSize + "px" : fontSize; // Esri's js api 3.8 reports size as a number - in pixels. Safeguard.
                            var numberOfLines = getNumberOfLines(labelStr);
                            var setCharSize = function (alphabet) {
                                if (createElement) {
                                    // GVH-8075 The text that is rendered on the map is not just a simple text within a div, rather it is a SVG path.
                                    // This is an important distinction to make since the rendered size of a SVG text might be different compared to the same text with
                                    // the same font information within a div. This is especially important when it comes to cross browser compatibility.
                                    var drawingMeasurementLayer = document.getElementById(layerId + "_layer");
                                    container = document.createElementNS("http://www.w3.org/2000/svg", "text");
                                    container.setAttributeNS(null, "font-size", fontSize);
                                    container.setAttributeNS(null, "font-family", fontFamily);
                                    container.setAttributeNS(null, "visibility", "hidden");
                                    container.textContent = alphabet;
                                    drawingMeasurementLayer.appendChild(container);
                                    createElement = false;
                                }
                                else {
                                    container.textContent = alphabet;
                                }
                                var bbox = container.getBBox();
                                // GVH-8127 There are potentially different ways of detecting the height and width of the text.
                                // Initially we were using container.clientHeight and container.clientWidht that was only working in Chrome.
                                // Using the bounding box looked like a good cross browser solution but only for the height since bbox.width would be non existent in IE.
                                // For the width the only cross browser solution looked like being using the getComputedTextLenght method on the container.
                                // This combination should get the proper size on Chrome, IE and Firefox.
                                emHeight = (emHeight === null) ? bbox.height : emHeight; // Height remains constant for all characters
                                emWidthDict[alphabet] = container.getComputedTextLength();
                                return emWidthDict[alphabet];
                            };
                            var textLines = getTextLines(labelStr);
                            var maxWidth = 0;
                            for (var lineIndex = 0; textLines && lineIndex < textLines.length; lineIndex++) {
                                var numChars = labelStr.length;
                                var labelWidth = 0;
                                for (var x = 0; x < numChars; x++) {
                                    var alphabet = textLines[lineIndex].charAt(x);
                                    alphabet = (alphabet === " ") ? "." : alphabet; //If char is a space, replace with '.'. Their sizes are the same in most fonts.
                                    labelWidth += (emWidthDict.hasOwnProperty(alphabet)) ? emWidthDict[alphabet] : setCharSize(alphabet);
                                }
                                if (labelWidth > maxWidth) {
                                    maxWidth = labelWidth;
                                }
                            }
                            if (page && container) {
                                page.removeChild(container);
                            }
                            return {
                                width: Math.ceil(maxWidth),
                                height: Math.ceil(emHeight * numberOfLines)
                            };
                        }
                        HighlightedLabelUtils.getLabelSize = getLabelSize;
                        function getTextLines(text) {
                            return text.split(newLineRegex);
                        }
                        HighlightedLabelUtils.getTextLines = getTextLines;
                        function generateSvgHighlightLabelPath(width, height, radius, showPointer, pointerWidth) {
                            if (showPointer === void 0) { showPointer = false; }
                            if (pointerWidth === void 0) { pointerWidth = width / 5; }
                            var path = "";
                            if (radius === 0) {
                                path = "M1,0h" + width +
                                    "v" + height;
                            }
                            else {
                                path = "M1,0"
                                    + "h" + (width - radius)
                                    + "a" + radius + "," + radius + " 0 0 1 " + radius + "," + radius
                                    + "v" + (height - 2 * radius)
                                    + "a" + radius + "," + radius + " 0 0 1 " + -radius + "," + radius;
                            }
                            if (showPointer) {
                                path += "h" + ((radius - (width - pointerWidth)) / 2)
                                    + "l" + -(pointerWidth / 2) + "," + (pointerWidth / 2)
                                    + "l" + -(pointerWidth / 2) + "," + -(pointerWidth / 2)
                                    + "h" + ((radius - (width - pointerWidth)) / 2);
                            }
                            else {
                                path += "h" + (radius - width);
                            }
                            if (radius === 0) {
                                path += "z";
                            }
                            else {
                                path += "a" + radius + "," + radius + " 0 0 1 " + -radius + "," + -radius
                                    + "v" + (2 * radius - height)
                                    + "a" + radius + "," + radius + " 0 0 1 " + radius + "," + -radius
                                    + "z";
                            }
                            return path;
                        }
                        HighlightedLabelUtils.generateSvgHighlightLabelPath = generateSvgHighlightLabelPath;
                        function generateSvgCirclePath(radius) {
                            var path = "";
                            if (!radius) {
                                throw new Error("HighlightLabelUtils: Cannot generate SVG circle path. Radius cannot be zero or undefined.");
                            }
                            path = "M0,0"
                                + "a" + radius + "," + radius + " 0 0 1 " + radius + "," + radius
                                + "a" + radius + "," + radius + " 0 0 1 " + -radius + "," + radius
                                + "a" + radius + "," + radius + " 0 0 1 " + -radius + "," + -radius
                                + "a" + radius + "," + radius + " 0 0 1 " + radius + "," + -radius
                                + "z";
                            return path;
                        }
                        HighlightedLabelUtils.generateSvgCirclePath = generateSvgCirclePath;
                        function getNumberOfLines(text) {
                            return (newLineRegex.test(text) ? text.match(newLineRegex).length : 0) + 1;
                        }
                    })(HighlightedLabelUtils = highlightedLabel.HighlightedLabelUtils || (highlightedLabel.HighlightedLabelUtils = {}));
                })(highlightedLabel = infrastructure.highlightedLabel || (infrastructure.highlightedLabel = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="ServiceLayer.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var webMap;
                (function (webMap) {
                    /**
                     * Constants for well-known basemap types.
                     */
                    var BaseMapType;
                    (function (BaseMapType) {
                        BaseMapType.OPEN_STREET_MAP = "OpenStreetMap";
                        BaseMapType.BING_AERIAL = "BingMapsAerial";
                        BaseMapType.BING_ROAD = "BingMapsRoad";
                        BaseMapType.BING_HYBRID = "BingMapsHybrid";
                        BaseMapType.WEB_TILED = "WebTiledLayer";
                    })(BaseMapType = webMap.BaseMapType || (webMap.BaseMapType = {}));
                })(webMap = infrastructure.webMap || (infrastructure.webMap = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="ServiceLayer.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var webMap;
                (function (webMap) {
                    var OperationalLayerType;
                    (function (OperationalLayerType) {
                        OperationalLayerType.CSV = "CSV";
                        OperationalLayerType.WMS = "WMS";
                        OperationalLayerType.KML = "KML";
                    })(OperationalLayerType = webMap.OperationalLayerType || (webMap.OperationalLayerType = {}));
                })(webMap = infrastructure.webMap || (infrastructure.webMap = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="OperationalLayer.ts" />
/// <reference path="OperationalLayer.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var webMap;
                (function (webMap) {
                    var RendererType;
                    (function (RendererType) {
                        RendererType.SIMPLE = "simple";
                        RendererType.UNIQUE_VALUE = "uniqueValue";
                        RendererType.CLASS_BREAKS = "classBreaks";
                        RendererType.HEATMAP = "heatmap";
                    })(RendererType = webMap.RendererType || (webMap.RendererType = {}));
                    var NormalizationType;
                    (function (NormalizationType) {
                        NormalizationType.BY_FIELD = "esriNormalizeByField";
                        NormalizationType.BY_LOG = "esriNormalizeByLog";
                        NormalizationType.BY_PERCENT_OF_TOTAL = "esriNormalizeByPercentOfTotal";
                    })(NormalizationType = webMap.NormalizationType || (webMap.NormalizationType = {}));
                    var ClassificationMethod;
                    (function (ClassificationMethod) {
                        ClassificationMethod.NATURAL_BREAKS = "esriClassifyNaturalBreaks";
                        ClassificationMethod.EQUAL_INTERVAL = "esriClassifyEqualInterval";
                        ClassificationMethod.QUANTILE = "esriClassifyQuantile";
                        ClassificationMethod.STANDARD_DEVIATION = "esriClassifyStandardDeviation";
                        ClassificationMethod.GEOMETRICAL_INTERVAL = "esriClassifyGeometricalInterval";
                    })(ClassificationMethod = webMap.ClassificationMethod || (webMap.ClassificationMethod = {}));
                })(webMap = infrastructure.webMap || (infrastructure.webMap = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var webMap;
                (function (webMap) {
                    var DomainType;
                    (function (DomainType) {
                        DomainType.INHERITED = "inherited";
                        DomainType.RANGE = "range";
                        DomainType.CODED_VALUE = "codedValue";
                    })(DomainType = webMap.DomainType || (webMap.DomainType = {}));
                })(webMap = infrastructure.webMap || (infrastructure.webMap = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var webMap;
                (function (webMap) {
                    /**
                     * Geometry type constants used in ArcGIS REST API and web map specifications.
                     */
                    var GeometryType;
                    (function (GeometryType) {
                        GeometryType.POINT = "esriGeometryPoint";
                        GeometryType.MULTIPOINT = "esriGeometryMultipoint";
                        GeometryType.POLYLINE = "esriGeometryPolyline";
                        GeometryType.POLYGON = "esriGeometryPolygon";
                        GeometryType.EXTENT = "esriGeometryEnvelope";
                        /**
                         * Converts from geometry type constants used in the esri JavaScript API to their web map equivalents.
                         */
                        function fromEsriGeometryType(type) {
                            if (!type) {
                                return undefined;
                            }
                            else if (type.startsWith("esriGeometry")) {
                                return type;
                            }
                            switch (type) {
                                case "point":
                                    return GeometryType.POINT;
                                case "multipoint":
                                    return GeometryType.MULTIPOINT;
                                case "polyline":
                                    return GeometryType.POLYLINE;
                                case "polygon":
                                    return GeometryType.POLYGON;
                                case "extent":
                                    return GeometryType.EXTENT;
                                default:
                                    throw new Error("GeometryType.fromEsriGeometryType: Unrecognized geometry type.");
                            }
                        }
                        GeometryType.fromEsriGeometryType = fromEsriGeometryType;
                    })(GeometryType = webMap.GeometryType || (webMap.GeometryType = {}));
                })(webMap = infrastructure.webMap || (infrastructure.webMap = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var webMap;
                (function (webMap) {
                    // This property is used by WebMapConverter and must be allowed even though it's not part of
                    // the web map spec.
                    var CONVERSION_TYPE_PROPERTY = "__conversionType";
                    /**
                     * Provides a set of filters for use with {@link: ObjectFilter.filter} corresponding to web map interfaces.
                     */
                    var WebMapFilter = (function () {
                        function WebMapFilter(app) {
                            var _this = this;
                            this._numberValidator = new infrastructure.validation.NumberValidator();
                            /**
                             * A generic filter for objects whose schema is unknown.
                             */
                            this.object = function (object) {
                                // TODO: if (typeof object === "string") { XSS Filter }
                                if (!object || typeof object !== "object") {
                                    return true;
                                }
                                else if (Array.isArray(object)) {
                                    return {
                                        item: _this.object
                                    };
                                }
                                // Look for well-known web map types that have been tagged with a conversion type.
                                switch (object[CONVERSION_TYPE_PROPERTY]) {
                                    case webMap.ConversionType.GCX_MAP_SERVICE:
                                    case webMap.ConversionType.ESRI_LAYER:
                                        return _this.serviceLayer;
                                    case webMap.ConversionType.GCX_LAYER:
                                        return _this.layer;
                                    case webMap.ConversionType.GCX_FEATURE_SET:
                                    case webMap.ConversionType.ESRI_FEATURE_SET:
                                        return _this.featureSet;
                                    case webMap.ConversionType.GCX_FEATURE:
                                    case webMap.ConversionType.ESRI_GRAPHIC:
                                        return _this.feature;
                                    case webMap.ConversionType.ESRI_GEOMETRY:
                                        return _this.geometry;
                                    case webMap.ConversionType.ESRI_SYMBOL:
                                        return _this.symbol;
                                    case webMap.ConversionType.ESRI_RENDERER:
                                        return _this.renderer;
                                    case webMap.ConversionType.ESRI_SPATIAL_REFERENCE:
                                        return _this.spatialReference;
                                }
                                // Recursively filter each property.
                                var filter = {};
                                for (var _i = 0, _a = Object.keys(object); _i < _a.length; _i++) {
                                    var key = _a[_i];
                                    filter[key] = _this.object;
                                }
                                return filter;
                            };
                            this.app = app;
                            this._urlValidator = new infrastructure.validation.SiteUrlValidator(app);
                        }
                        Object.defineProperty(WebMapFilter.prototype, "baseMap", {
                            get: function () {
                                if (!this._baseMap) {
                                    this._baseMap = {
                                        baseMapLayers: {
                                            item: this.baseMapLayer
                                        },
                                        title: true
                                    };
                                }
                                return this._baseMap;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "baseMapLayer", {
                            get: function () {
                                if (!this._baseMapLayer) {
                                    this._baseMapLayer = $.extend({}, this._serviceLayerCommon, {
                                        type: true,
                                        isReference: true,
                                        templateUrl: this._urlValidator
                                    });
                                    this._baseMapLayer[CONVERSION_TYPE_PROPERTY] = true;
                                }
                                return this._baseMapLayer;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "bookmark", {
                            get: function () {
                                if (!this._bookmark) {
                                    this._bookmark = {
                                        name: true,
                                        extent: this.extent
                                    };
                                }
                                return this._bookmark;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "color", {
                            get: function () {
                                if (!this._color) {
                                    this._color = {
                                        item: this._numberValidator
                                    };
                                }
                                return this._color;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "csvLayer", {
                            get: function () {
                                if (!this._csvLayer) {
                                    this._csvLayer = $.extend({}, this.operationalLayer, {
                                        columnDelimiter: true,
                                        locationInfo: this.locationInfo
                                    });
                                }
                                return this._csvLayer;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "domain", {
                            get: function () {
                                var _this = this;
                                if (!this._domain) {
                                    this._domain = function (domain) {
                                        if (!domain) {
                                            return false;
                                        }
                                        switch (domain.type) {
                                            case webMap.DomainType.INHERITED:
                                                return _this.inheritedDomain;
                                            case webMap.DomainType.RANGE:
                                                return _this.rangeDomain;
                                            case webMap.DomainType.CODED_VALUE:
                                                return _this.codedValueDomain;
                                            default:
                                                return false;
                                        }
                                    };
                                }
                                return this._domain;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "inheritedDomain", {
                            get: function () {
                                if (!this._inheritedDomain) {
                                    this._inheritedDomain = {
                                        type: true
                                    };
                                }
                                return this._inheritedDomain;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "rangeDomain", {
                            get: function () {
                                if (!this._rangeDomain) {
                                    this._rangeDomain = {
                                        type: true,
                                        name: true,
                                        range: {
                                            item: this._numberValidator
                                        }
                                    };
                                }
                                return this._rangeDomain;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "codedValueDomain", {
                            get: function () {
                                if (!this._codedValueDomain) {
                                    this._codedValueDomain = {
                                        type: true,
                                        name: true,
                                        codedValues: {
                                            item: {
                                                name: true,
                                                code: true
                                            }
                                        }
                                    };
                                }
                                return this._codedValueDomain;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "drawingInfo", {
                            get: function () {
                                if (!this._drawingInfo) {
                                    this._drawingInfo = {
                                        renderer: this.renderer,
                                        fixedSymbols: true
                                    };
                                }
                                return this._drawingInfo;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "feature", {
                            get: function () {
                                if (!this._feature) {
                                    this._feature = {
                                        attributes: this.object,
                                        geometry: this.geometry
                                    };
                                    this._feature[CONVERSION_TYPE_PROPERTY] = true;
                                }
                                return this._feature;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "featureCollection", {
                            get: function () {
                                if (!this._featureCollection) {
                                    this._featureCollection = {
                                        layers: {
                                            item: this.layer
                                        },
                                        showLegend: true
                                    };
                                }
                                return this._featureCollection;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "featureSet", {
                            get: function () {
                                if (!this._featureSet) {
                                    this._featureSet = {
                                        features: {
                                            item: this.feature
                                        },
                                        geometryType: true
                                    };
                                    this._featureSet[CONVERSION_TYPE_PROPERTY] = true;
                                }
                                return this._featureSet;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "field", {
                            get: function () {
                                if (!this._field) {
                                    this._field = {
                                        alias: true,
                                        domain: this.domain,
                                        editable: true,
                                        length: true,
                                        name: true,
                                        nullable: true,
                                        type: true
                                    };
                                }
                                return this._field;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "geometry", {
                            get: function () {
                                var _this = this;
                                if (!this._geometry) {
                                    this._geometry = function (geometry) {
                                        if (!geometry) {
                                            return false;
                                        }
                                        if (geometry.hasOwnProperty("x")) {
                                            return _this.point;
                                        }
                                        else if (geometry.hasOwnProperty("points")) {
                                            return _this.multiPoint;
                                        }
                                        else if (geometry.hasOwnProperty("paths")) {
                                            return _this.polyline;
                                        }
                                        else if (geometry.hasOwnProperty("rings")) {
                                            return _this.polygon;
                                        }
                                        else if (geometry.hasOwnProperty("xmin")) {
                                            return _this.extent;
                                        }
                                        else {
                                            return false;
                                        }
                                    };
                                }
                                return this._geometry;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "point", {
                            get: function () {
                                if (!this._point) {
                                    this._point = {
                                        spatialReference: this.spatialReference,
                                        x: this._numberValidator,
                                        y: this._numberValidator,
                                        z: this._numberValidator,
                                        m: this._numberValidator
                                    };
                                    this._point[CONVERSION_TYPE_PROPERTY] = true;
                                }
                                return this._point;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "multiPoint", {
                            get: function () {
                                if (!this._multipoint) {
                                    this._multipoint = {
                                        spatialReference: this.spatialReference,
                                        hasM: true,
                                        hasZ: true,
                                        points: {
                                            item: {
                                                item: this._numberValidator
                                            }
                                        }
                                    };
                                    this._multipoint[CONVERSION_TYPE_PROPERTY] = true;
                                }
                                return this._multipoint;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "polyline", {
                            get: function () {
                                if (!this._polyline) {
                                    this._polyline = {
                                        spatialReference: this.spatialReference,
                                        hasM: true,
                                        hasZ: true,
                                        paths: {
                                            item: {
                                                item: {
                                                    item: this._numberValidator
                                                }
                                            }
                                        }
                                    };
                                    this._polyline[CONVERSION_TYPE_PROPERTY] = true;
                                }
                                return this._polyline;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "polygon", {
                            get: function () {
                                if (!this._polygon) {
                                    this._polygon = {
                                        spatialReference: this.spatialReference,
                                        hasM: true,
                                        hasZ: true,
                                        rings: {
                                            item: {
                                                item: {
                                                    item: this._numberValidator
                                                }
                                            }
                                        }
                                    };
                                    this._polygon[CONVERSION_TYPE_PROPERTY] = true;
                                }
                                return this._polygon;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "extent", {
                            get: function () {
                                if (!this._extent) {
                                    this._extent = {
                                        spatialReference: this.spatialReference,
                                        xmin: this._numberValidator,
                                        xmax: this._numberValidator,
                                        ymin: this._numberValidator,
                                        ymax: this._numberValidator,
                                        zmin: this._numberValidator,
                                        zmax: this._numberValidator,
                                        mmin: this._numberValidator,
                                        mmax: this._numberValidator
                                    };
                                    this._extent[CONVERSION_TYPE_PROPERTY];
                                }
                                return this._extent;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "layer", {
                            get: function () {
                                if (!this._layer) {
                                    this._layer = {
                                        featureSet: this.featureSet,
                                        id: true,
                                        layerDefinition: this.layerDefinition,
                                        layerUrl: this._urlValidator,
                                        legendUrl: this._urlValidator,
                                        name: true,
                                        title: true,
                                        popupInfo: this.popupInfo
                                    };
                                    this._layer[CONVERSION_TYPE_PROPERTY] = true;
                                }
                                return this._layer;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "layerDefinition", {
                            get: function () {
                                if (!this._layerDefinition) {
                                    this._layerDefinition = {
                                        definitionExpression: true,
                                        displayField: true,
                                        drawingInfo: this.drawingInfo,
                                        fields: {
                                            item: this.field
                                        },
                                        geometryType: true,
                                        hasAttachments: true,
                                        maxScale: this._numberValidator,
                                        minScale: this._numberValidator,
                                        name: true,
                                        objectIdField: true,
                                        templates: {
                                            item: this.template
                                        },
                                        type: true,
                                        typeIdField: true,
                                        types: {
                                            item: this.type
                                        },
                                        source: {
                                            type: true,
                                            mapLayerId: this._numberValidator
                                        }
                                    };
                                }
                                return this._layerDefinition;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "locationInfo", {
                            get: function () {
                                if (!this._locationInfo) {
                                    this._locationInfo = {
                                        locationType: true,
                                        latitudeFieldName: true,
                                        longitudeFieldName: true
                                    };
                                }
                                return this._locationInfo;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "operationalLayer", {
                            get: function () {
                                if (!this._operationalLayer) {
                                    this._operationalLayer = $.extend({}, this._serviceLayerCommon, {
                                        type: true,
                                        capabilities: true,
                                        featureCollection: this.featureCollection,
                                        itemId: true,
                                        layerDefinition: this.layerDefinition,
                                        layers: {
                                            item: this.layer
                                        },
                                        maxScale: this._numberValidator,
                                        minScale: this._numberValidator,
                                        mode: this._numberValidator,
                                        popupInfo: this.popupInfo,
                                        title: true,
                                        visibleLayers: {
                                            item: true
                                        }
                                    });
                                    this._operationalLayer[CONVERSION_TYPE_PROPERTY] = true;
                                }
                                return this._operationalLayer;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "popupInfo", {
                            get: function () {
                                // TODO: Not implemented.
                                return {};
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "renderer", {
                            get: function () {
                                var _this = this;
                                if (!this._renderer) {
                                    this._renderer = function (renderer) {
                                        if (!renderer) {
                                            return false;
                                        }
                                        switch (renderer.type) {
                                            case webMap.RendererType.SIMPLE:
                                                return _this.simpleRenderer;
                                            case webMap.RendererType.UNIQUE_VALUE:
                                                return _this.uniqueValueRenderer;
                                            case webMap.RendererType.CLASS_BREAKS:
                                                return _this.classBreaksRenderer;
                                            case webMap.RendererType.HEATMAP:
                                                return _this.heatmapRenderer;
                                            default:
                                                return false;
                                        }
                                    };
                                }
                                return this._renderer;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "serviceLayer", {
                            get: function () {
                                if (!this._serviceLayer) {
                                    this._serviceLayer = $.extend({}, this.operationalLayer, this.wmsLayer, this.csvLayer, this.baseMapLayer);
                                }
                                return this._serviceLayer;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "simpleRenderer", {
                            get: function () {
                                if (!this._simpleRenderer) {
                                    this._simpleRenderer = {
                                        type: true,
                                        symbol: this.symbol,
                                        label: true,
                                        description: true
                                    };
                                    this._simpleRenderer[CONVERSION_TYPE_PROPERTY] = true;
                                }
                                return this._simpleRenderer;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "uniqueValueRenderer", {
                            get: function () {
                                if (!this._uniqueValueRenderer) {
                                    this._uniqueValueRenderer = {
                                        type: true,
                                        field1: true,
                                        field2: true,
                                        field3: true,
                                        fieldDelimiter: true,
                                        defaultSymbol: this.symbol,
                                        defaultLabel: true,
                                        uniqueValueInfos: {
                                            item: {
                                                value: true,
                                                label: true,
                                                description: true,
                                                symbol: this.symbol
                                            }
                                        }
                                    };
                                    this._uniqueValueRenderer[CONVERSION_TYPE_PROPERTY] = true;
                                }
                                return this._uniqueValueRenderer;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "classBreaksRenderer", {
                            get: function () {
                                if (!this._classBreaksRenderer) {
                                    this._classBreaksRenderer = {
                                        type: true,
                                        field: true,
                                        classificationMethod: true,
                                        normalizationType: true,
                                        normalizationField: true,
                                        normalizationTotal: this._numberValidator,
                                        defaultSymbol: this.symbol,
                                        defaultLabel: true,
                                        backgroundFillSymbol: this.simpleFillSymbol,
                                        minValue: this._numberValidator,
                                        classBreakInfos: {
                                            item: {
                                                classMinValue: this._numberValidator,
                                                classMaxValue: this._numberValidator,
                                                label: true,
                                                description: true,
                                                symbol: this.symbol
                                            }
                                        }
                                    };
                                    this._classBreaksRenderer[CONVERSION_TYPE_PROPERTY] = true;
                                }
                                return this._classBreaksRenderer;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "heatmapRenderer", {
                            get: function () {
                                if (!this._heatmapRenderer) {
                                    this._heatmapRenderer = {
                                        type: true,
                                        blurRadius: this._numberValidator,
                                        field: true,
                                        maxPixelIntensity: this._numberValidator,
                                        minPixelIntensity: this._numberValidator,
                                        colorStops: {
                                            item: {
                                                ratio: true,
                                                color: this.color
                                            }
                                        }
                                    };
                                }
                                return this._heatmapRenderer;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "_serviceLayerCommon", {
                            get: function () {
                                return {
                                    id: true,
                                    url: this._urlValidator,
                                    visibility: true,
                                    opacity: this._numberValidator,
                                    layerType: true
                                };
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "spatialReference", {
                            get: function () {
                                if (!this._spatialReference) {
                                    this._spatialReference = {
                                        wkid: this._numberValidator,
                                        wkt: true
                                    };
                                    this._spatialReference[CONVERSION_TYPE_PROPERTY] = true;
                                }
                                return this._spatialReference;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "symbol", {
                            get: function () {
                                var _this = this;
                                if (!this._symbol) {
                                    this._symbol = function (symbol) {
                                        if (!symbol) {
                                            return false;
                                        }
                                        switch (symbol.type) {
                                            case webMap.SymbolType.SIMPLE_MARKER:
                                                return _this.simpleMarkerSymbol;
                                            case webMap.SymbolType.SIMPLE_LINE:
                                                return _this.simpleLineSymbol;
                                            case webMap.SymbolType.SIMPLE_FILL:
                                                return _this.simpleFillSymbol;
                                            case webMap.SymbolType.PICTURE_MARKER:
                                                return _this.pictureMarkerSymbol;
                                            case webMap.SymbolType.PICTURE_FILL:
                                                return _this.pictureFillSymbol;
                                            case webMap.SymbolType.TEXT:
                                                return _this.textSymbol;
                                            default:
                                                return false;
                                        }
                                    };
                                }
                                return this._symbol;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "simpleMarkerSymbol", {
                            get: function () {
                                if (!this._simpleMarkerSymbol) {
                                    this._simpleMarkerSymbol = {
                                        type: true,
                                        style: true,
                                        color: this.color,
                                        size: true,
                                        angle: this._numberValidator,
                                        path: true,
                                        xoffset: this._numberValidator,
                                        yoffset: this._numberValidator,
                                        outline: {
                                            type: true,
                                            style: true,
                                            color: this.color,
                                            width: this._numberValidator
                                        }
                                    };
                                    this._simpleMarkerSymbol[CONVERSION_TYPE_PROPERTY] = true;
                                }
                                return this._simpleMarkerSymbol;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "simpleLineSymbol", {
                            get: function () {
                                if (!this._simpleLineSymbol) {
                                    this._simpleLineSymbol = {
                                        type: true,
                                        style: true,
                                        color: this.color,
                                        width: this._numberValidator
                                    };
                                    this._simpleLineSymbol[CONVERSION_TYPE_PROPERTY] = true;
                                }
                                return this._simpleLineSymbol;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "simpleFillSymbol", {
                            get: function () {
                                if (!this._simpleFillSymbol) {
                                    this._simpleFillSymbol = {
                                        type: true,
                                        style: true,
                                        color: this.color,
                                        outline: this.simpleLineSymbol
                                    };
                                    this._simpleFillSymbol[CONVERSION_TYPE_PROPERTY] = true;
                                }
                                return this._simpleFillSymbol;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "pictureMarkerSymbol", {
                            get: function () {
                                if (!this._pictureMarkerSymbol) {
                                    this._pictureMarkerSymbol = {
                                        type: true,
                                        url: this._urlValidator,
                                        imageData: true,
                                        contentType: true,
                                        width: this._numberValidator,
                                        height: this._numberValidator,
                                        angle: this._numberValidator,
                                        xoffset: this._numberValidator,
                                        yoffset: this._numberValidator
                                    };
                                    this._pictureMarkerSymbol[CONVERSION_TYPE_PROPERTY] = true;
                                }
                                return this._pictureMarkerSymbol;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "pictureFillSymbol", {
                            get: function () {
                                if (!this._pictureFillSymbol) {
                                    this._pictureFillSymbol = {
                                        type: true,
                                        url: this._urlValidator,
                                        imageData: true,
                                        contentType: true,
                                        outline: this.simpleLineSymbol,
                                        width: this._numberValidator,
                                        height: this._numberValidator,
                                        angle: this._numberValidator,
                                        xoffset: this._numberValidator,
                                        yoffset: this._numberValidator,
                                        xscale: this._numberValidator,
                                        yscale: this._numberValidator
                                    };
                                    this._pictureFillSymbol[CONVERSION_TYPE_PROPERTY] = true;
                                }
                                return this._pictureFillSymbol;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "textSymbol", {
                            get: function () {
                                if (!this._textSymbol) {
                                    this._textSymbol = {
                                        type: true,
                                        color: this.color,
                                        backgroundColor: this.color,
                                        borderLineSize: this._numberValidator,
                                        borderLineColor: this.color,
                                        haloSize: this._numberValidator,
                                        haloColor: this.color,
                                        verticalAlignment: true,
                                        horizontalAlignment: true,
                                        rightToLeft: true,
                                        angle: this._numberValidator,
                                        xoffset: this._numberValidator,
                                        yoffset: this._numberValidator,
                                        kerning: true,
                                        font: {
                                            family: true,
                                            size: this._numberValidator,
                                            style: true,
                                            weight: true,
                                            decoration: true
                                        },
                                        text: true
                                    };
                                    this._textSymbol[CONVERSION_TYPE_PROPERTY] = true;
                                }
                                return this._textSymbol;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "template", {
                            get: function () {
                                if (!this._template) {
                                    this._template = {
                                        description: true,
                                        drawingTool: true,
                                        name: true,
                                        prototype: this.feature
                                    };
                                }
                                return this._template;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "type", {
                            get: function () {
                                var _this = this;
                                if (!this._type) {
                                    this._type = {
                                        // TODO: Consider adding support to ObjectFilter for dictionary-type objects like this one.
                                        domains: function (domains) {
                                            if (!domains) {
                                                return true;
                                            }
                                            var filter = {};
                                            for (var _i = 0, _a = Object.keys(domains); _i < _a.length; _i++) {
                                                var key = _a[_i];
                                                filter[key] = _this.domain;
                                            }
                                            return filter;
                                        },
                                        id: this._numberValidator,
                                        name: true,
                                        templates: {
                                            item: this.template
                                        }
                                    };
                                }
                                return this._type;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "webMap", {
                            get: function () {
                                if (!this._webMap) {
                                    this._webMap = {
                                        operationalLayers: {
                                            item: this.operationalLayer
                                        },
                                        baseMap: this.baseMap,
                                        bookmarks: {
                                            item: this.bookmark
                                        },
                                        version: true,
                                        applicationProperties: true
                                    };
                                }
                                return this._webMap;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(WebMapFilter.prototype, "wmsLayer", {
                            get: function () {
                                if (!this.wmsLayer) {
                                    this._wmsLayer = $.extend({}, this.operationalLayer, {
                                        copyright: true,
                                        extent: this.extent,
                                        format: true,
                                        mapUrl: this._urlValidator,
                                        maxHeight: this._numberValidator,
                                        maxWidth: this._numberValidator,
                                        spatialReferences: {
                                            item: this._numberValidator
                                        },
                                        version: true
                                    });
                                }
                                return this._wmsLayer;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        return WebMapFilter;
                    }());
                    webMap.WebMapFilter = WebMapFilter;
                })(webMap = infrastructure.webMap || (infrastructure.webMap = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var webMap;
                (function (webMap) {
                    var WebMapManager = (function () {
                        function WebMapManager(app) {
                            if (!app) {
                                throw new Error("ProjectManager: Parameter 'app' is required.");
                            }
                            this.app = app;
                            this.convert = new webMap.WebMapConverter(app);
                            this.filter = new webMap.WebMapFilter(app);
                        }
                        /**
                         * Exports the current state of the viewer to ArcGIS web map format.
                         */
                        WebMapManager.prototype.create = function () {
                            var _this = this;
                            if (!this.app.site || !this.app.site.isInitialized) {
                                throw new Error("WebMapConverter.fromCurrentMap: The Essentials site for this application is missing or not yet initialized.");
                            }
                            this.convert.clearCache();
                            var essentialsMap = this.app.site.essentialsMap;
                            var handleMapServiceError = function (ms, error) {
                                console.warn("Unable to convert map service \"{0}\" to web map format: {1}".format(ms.displayName, error));
                            };
                            // Note: Layers in web maps are ordered in reverse from Essentials (topmost layer is last in array).
                            var operationalMapServices = essentialsMap.mapServices.filter(function (ms) { return ms.mapServiceFunction === geocortex.essentials.MapServiceFunction.OPERATIONAL; }).reverse();
                            var operationalLayers = mapping.infrastructure.ArrayUtils.mapWithErrorCallback(operationalMapServices, function (ms) { return _this.convert.fromGcxMapService(ms); }, handleMapServiceError);
                            // Add eligible graphics layers from the esri map.
                            var exportableGraphicsLayers = infrastructure.GraphicUtils.getUserGraphicsLayers(this.app).filter(function (gl) { return gl.graphics.length > 0; });
                            exportableGraphicsLayers.forEach(function (graphicsLayer) {
                                try {
                                    operationalLayers.push(_this.convert.fromEsriLayer(graphicsLayer));
                                }
                                catch (e) {
                                    console.warn("Unable to convert graphics layer \"{0}\" to web map format: {1}".format(graphicsLayer.id, e));
                                }
                            });
                            // Create a base map from the visible base map services.
                            var baseMapServices = essentialsMap.mapServices.filter(function (ms) { return ms.isVisible() && ms.mapServiceFunction === geocortex.essentials.MapServiceFunction.BASE; }).reverse();
                            var baseMapTitle = "";
                            var baseMapLayers = mapping.infrastructure.ArrayUtils.mapWithErrorCallback(baseMapServices, function (ms) { return _this.convert.fromGcxMapService(ms); }, handleMapServiceError);
                            if (baseMapServices.length) {
                                // If all visible base map services belong to a single Essentials base map, then use the base map's name,
                                // otherwise use the name of the topmost map service (last in the array).
                                var baseMaps = essentialsMap.baseMaps.filter(function (bm) { return baseMapServices.every(function (ms) { return bm.services.some(function (bms) { return bms.mapService === ms; }); }); });
                                if (baseMaps.length === 1) {
                                    baseMapTitle = baseMaps[0].displayName;
                                }
                                else {
                                    baseMapTitle = baseMapServices[baseMapServices.length - 1].displayName;
                                }
                            }
                            if (!baseMapLayers.length) {
                                // A valid web map must have at least one base map layer. Use Esri's Light Gray Canvas as a default base map.
                                // TODO: Make this configurable?
                                baseMapTitle = "Light Gray Canvas";
                                baseMapLayers[0] = {
                                    "id": "World_Light_Gray_Base_1486",
                                    "layerType": "ArcGISTiledMapServiceLayer",
                                    "opacity": 1,
                                    "visibility": true,
                                    "url": "http://services.arcgisonline.com/ArcGIS/rest/services/Canvas/World_Light_Gray_Base/MapServer"
                                };
                            }
                            return this.app.bookmarks.export().then(function (bookmarks) {
                                return {
                                    operationalLayers: operationalLayers,
                                    baseMap: {
                                        title: baseMapTitle,
                                        baseMapLayers: baseMapLayers
                                    },
                                    bookmarks: bookmarks,
                                    version: "1.7"
                                };
                            });
                        };
                        return WebMapManager;
                    }());
                    webMap.WebMapManager = WebMapManager;
                })(webMap = infrastructure.webMap || (infrastructure.webMap = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="OperationalLayer.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var ObjectFilter;
                (function (ObjectFilter) {
                    // A special return value indicating that the property was filtered out.
                    ObjectFilter.FILTERED = {};
                    /**
                     * Filters an object graph according to the rules defined in a filter.
                     * Returns an object graph with the same structure as the original, minus any properties that were removed
                     *     by the filter. Note that prototype chains are NOT preserved by this method -- the result will be a
                     *     simple instance of Object. Cycles and shared object references within the input object will be
                     *     preserved in the output (presuming that they pass the filter).
                     * @param object The object graph to filter.
                     * @param filter A value that determines which properties of the original object are kept in the
                     * result. A filter can take on one of the following values:
                     *   1. A boolean value. If true, then the value will be retained, otherwise it will be discarded.
                     *   2. An object. Each property defined on the filter is itself a filter that is applied to the equivalent
                     * property on the orginal object. Any properties that are not defined in the filter are automatically
                     * excluded from the original object.
                     *   3. An instance of {@link validation.Validator}. The value will be checked against
                     * the validator's `validate()` method, and will be kept only if the validation is successful.
                     *   4. A callback function. The function will be invoked with the value, and the result will be used to
                     * perform further filtering.
                     *
                     * For array properties, the filter value can be an object containing a single property named `item`. In
                     * this case, the value of the filter's `item` property will be used to filter each item in the array, using
                     * the same rules as above.
                     * @param context Arbitrary data that will be passed to validators and callbacks within the filter.
                     */
                    function filter(object, filter, context) {
                        if (!filter) {
                            return Promise.reject(new Error("Filter required."));
                        }
                        // Maps visited input objects to filtered results. This is used to avoid infinite recursion when
                        // the input object graph contain cycles, but also to ensure that the resulting object graph has
                        // a similar structure with regard to shared object references.
                        var alreadyFiltered = new WeakMap();
                        return applyFilter(object, filter, alreadyFiltered, context);
                    }
                    ObjectFilter.filter = filter;
                    function isValidator(filter) {
                        return filter && typeof filter["validate"] === "function";
                    }
                    function getFilteredValue(value, filter, alreadyFiltered, context) {
                        if (typeof value === "object" && alreadyFiltered.has(value)) {
                            // We've already processed this object.
                            return Promise.resolve(alreadyFiltered.get(value));
                        }
                        while (typeof filter === "function") {
                            // Treat the filter as a callback.
                            filter = filter(value, context);
                        }
                        if (isValidator(filter)) {
                            // Consult the validator's validate() method.
                            return filter.validate(value, context)
                                .then(function (result) { return result.validatedValue; });
                        }
                        else if (typeof filter === "object" && typeof value === "object") {
                            // Apply the filter recursively.
                            return applyFilter(value, filter, alreadyFiltered, context);
                        }
                        else if (filter === true) {
                            // Allow it if explicitly whitelisted.
                            return Promise.resolve(value);
                        }
                        return Promise.reject(ObjectFilter.FILTERED);
                    }
                    function applyFilter(object, filter, alreadyFiltered, context) {
                        if (!object) {
                            return Promise.resolve(object);
                        }
                        else if (alreadyFiltered.has(object)) {
                            // Return the previously filtered result.
                            return alreadyFiltered.get(object);
                        }
                        var promise;
                        while (typeof filter === "function") {
                            // Treat the filter as a callback.
                            filter = filter(object, context);
                        }
                        if (typeof filter === "object") {
                            if (Array.isArray(object)) {
                                promise = infrastructure.PromiseUtils.mapSkipRejected(object, function (item) { return getFilteredValue(item, filter.item, alreadyFiltered, context); });
                                alreadyFiltered.set(object, promise);
                            }
                            else {
                                var result_2 = {};
                                alreadyFiltered.set(object, result_2);
                                promise = infrastructure.PromiseUtils.mapSkipRejected(Object.keys(filter), function (key) {
                                    if (!(key in object)) {
                                        return;
                                    }
                                    return getFilteredValue(object[key], filter[key], alreadyFiltered, context)
                                        .then(function (value) {
                                        result_2[key] = value;
                                    });
                                })
                                    .return(result_2);
                            }
                        }
                        else {
                            promise = getFilteredValue(object, filter, alreadyFiltered);
                        }
                        return promise;
                    }
                })(ObjectFilter = infrastructure.ObjectFilter || (infrastructure.ObjectFilter = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts" />
/// <reference path="../../../_Definitions/essentials.d.ts" />
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var legend;
                (function (legend) {
                    var LegendItem = (function () {
                        function LegendItem(layer, useThrottledCollection) {
                            var _this = this;
                            this.esriLayer = layer;
                            this.templateType = "single-item";
                            this.swatchElement = null;
                            this.label = new Observable("");
                            this.description = new Observable("");
                            this.isVisible = new Observable(true);
                            this.isVisibleInLayerListLegend = new Observable(true);
                            this.isCluster = false;
                            this.expanded = new Observable(true);
                            this.expanderClass = new Observable();
                            this.children = new ObservableCollection();
                            // GVH-5902: Use throttling (if configured) on children to speed up view bindings.
                            this.children.useThrottling = !!useThrottledCollection;
                            this.expanderClass.syncTransform(this.expanded, function (expanded) {
                                return expanded ? "tree-expander expanded" : "tree-expander collapsed";
                            });
                            this.expanded.pulse();
                            this.isVisibleInLayerListLegend.syncTransform(this.isVisible, function (isVisible) {
                                // Only clusters have dynamic visibility in the layer list legend.
                                if (!_this.isCluster) {
                                    return true;
                                }
                                return isVisible;
                            });
                        }
                        return LegendItem;
                    }());
                    legend.LegendItem = LegendItem;
                })(legend = infrastructure.legend || (infrastructure.legend = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts" />
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts" />
/// <reference path="LegendItem.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var legend;
                (function (legend) {
                    (function (LegendItemProviderResponseCode) {
                        LegendItemProviderResponseCode[LegendItemProviderResponseCode["NotFound"] = 0] = "NotFound";
                        LegendItemProviderResponseCode[LegendItemProviderResponseCode["Rendered"] = 1] = "Rendered";
                        LegendItemProviderResponseCode[LegendItemProviderResponseCode["Show"] = 2] = "Show";
                        LegendItemProviderResponseCode[LegendItemProviderResponseCode["Hide"] = 3] = "Hide";
                        LegendItemProviderResponseCode[LegendItemProviderResponseCode["Pending"] = 4] = "Pending";
                        LegendItemProviderResponseCode[LegendItemProviderResponseCode["Error"] = 5] = "Error";
                    })(legend.LegendItemProviderResponseCode || (legend.LegendItemProviderResponseCode = {}));
                    var LegendItemProviderResponseCode = legend.LegendItemProviderResponseCode;
                    var LegendItemProviderResponse = (function () {
                        function LegendItemProviderResponse(code, item) {
                            this.code = new Observable(code);
                            this.item = item;
                        }
                        return LegendItemProviderResponse;
                    }());
                    legend.LegendItemProviderResponse = LegendItemProviderResponse;
                })(legend = infrastructure.legend || (infrastructure.legend = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts" />
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts" />
/// <reference path="../../../_Definitions/essentials.d.ts" />
/// <reference path="LegendItem.ts" />
/// <reference path="LegendItemProviderResponse.ts" />
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts" />
/// <reference path="../../../_Definitions/essentials.d.ts" />
/// <reference path="LegendItemProvider.ts" />
// TODO: Rename.
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var legend;
                (function (legend) {
                    var LegendItemProviderEntry = (function () {
                        function LegendItemProviderEntry(identifier, provider) {
                            this.identifier = identifier;
                            this._provider = provider;
                        }
                        return LegendItemProviderEntry;
                    }());
                    legend.LegendItemProviderEntry = LegendItemProviderEntry;
                })(legend = infrastructure.legend || (infrastructure.legend = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts" />
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts" />
/// <reference path="../../../_Definitions/essentials.d.ts" />
/// <reference path="LegendItemProvider.ts" />
/// <reference path="LegendItemProviderEntry.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var legend;
                (function (legend) {
                    var LegendItemProviderFactory = (function () {
                        function LegendItemProviderFactory() {
                        }
                        /*static() {
                            LegendItemProviderFactory._providers = new Array<LegendItemProvider>();
                        }*/
                        LegendItemProviderFactory.registerLegendItemProvider = function (provider) {
                            var _this = this;
                            var fulfilPendingCallbacks = function (uniqueId, item) {
                                for (var q = 0; q < _this._legendItemCallbacks.length; q++) {
                                    if (uniqueId === _this._legendItemCallbacks[q].uniqueId) {
                                        _this._legendItemCallbacks[q].callback(item);
                                        _this._legendItemCallbacks.splice(q, 1);
                                        break;
                                    }
                                }
                            };
                            var allChildrenSingleLayerSingleItems = function (item) {
                                var children = item.children.get();
                                if (children.length) {
                                    var referenceSubLayerId;
                                    for (var q = 0; q < children.length; q++) {
                                        var childSubLayerId = children[q].sublayerId || (children[q].essLayer && children[q].essLayer.id);
                                        if (q === 0) {
                                            referenceSubLayerId = childSubLayerId;
                                        }
                                        if ((childSubLayerId !== referenceSubLayerId) || (children[q].templateType !== "single-item")) {
                                            return false;
                                        }
                                    }
                                }
                                return true;
                            };
                            var populateChildItems = function (item) {
                                if (item.children && item.children.length()) {
                                    for (var x = 0, len = item.children.length(); x < len; x++) {
                                        var child = item.children.getAt(x);
                                        addItemsRecursively(child);
                                    }
                                }
                            };
                            var populateLegendItemInfo = function (id, item) {
                                _this._legendItemInfos.push({ uniqueId: id, legendItem: item });
                                fulfilPendingCallbacks(id, item);
                            };
                            var generateItemUniqueId = function (item) {
                                var mapServiceId = (item.essLayer && item.essLayer.mapService && item.essLayer.mapService.id) ||
                                    (item.children && item.children.length() && item.children.getAt(0).essLayer && item.children.getAt(0).essLayer.mapService && item.children.getAt(0).essLayer.mapService.id) ||
                                    item.esriLayer.id;
                                var layerId = (item.essLayer && item.essLayer.id) || item.sublayerId || null;
                                return mapServiceId + ((layerId != null) ? "." + layerId : "");
                            };
                            var addItemsRecursively = function (item) {
                                if (item) {
                                    if (item.templateType === "group") {
                                        if (item.children.length() && allChildrenSingleLayerSingleItems(item)) {
                                            var currItem = item.children.getAt(0);
                                            populateLegendItemInfo(generateItemUniqueId(currItem), item);
                                            return;
                                        }
                                        populateChildItems(item);
                                    }
                                    if (item.templateType === "single-item") {
                                        populateLegendItemInfo(generateItemUniqueId(item), item);
                                    }
                                }
                            };
                            dojo.aspect.after(provider, "provide", function (legendProviderResponse) {
                                var legendCode = legendProviderResponse.code.get();
                                if (legendCode === legend.LegendItemProviderResponseCode.Pending || legendCode === legend.LegendItemProviderResponseCode.Show) {
                                    var execute = function () {
                                        if (legendProviderResponse.item) {
                                            addItemsRecursively(legendProviderResponse.item);
                                        }
                                    };
                                    if (legendCode === infrastructure.legend.LegendItemProviderResponseCode.Show) {
                                        execute();
                                    }
                                    else {
                                        var legendResponseBindingToken = legendProviderResponse.code.bind(_this, function (code) {
                                            legendProviderResponse.code.unbind(legendResponseBindingToken);
                                            if (code === legend.LegendItemProviderResponseCode.Show) {
                                                execute();
                                            }
                                        });
                                    }
                                }
                                return legendProviderResponse;
                            });
                            this._providers.push(provider);
                        };
                        LegendItemProviderFactory.getProviders = function () {
                            return this._providers;
                        };
                        /**
                         * Convenience method to get legend item using a layerInfo object instance
                         */
                        LegendItemProviderFactory.getLegendItemWhenAvailable = function (layer, callback) {
                            this.getLegendItemByIdWhenAvailable(layer.uniqueId, callback);
                        };
                        /**
                         * This function will invoke the provided callback only when (and if) the legend Item in question is retrieved. If it's not retrieved because of the legend
                         * module not being loaded or in case of some unforeseen error, it will simply do nothing. Programmers should be aware of this while calling this function.
                         * @param uniqueId A uniqueId parameter which is of the form <mapServiceId.layerId> for layers or simply the mapService id in case of map services
                         * @param callback A callback function which will be invoked if, and when, the requested legend item becomes available.
                         */
                        LegendItemProviderFactory.getLegendItemByIdWhenAvailable = function (uniqueId, callback) {
                            if (!uniqueId || !callback) {
                                return;
                            }
                            var item = null;
                            for (var x = 0, len = this._legendItemInfos.length; x < len; x++) {
                                var legendItemInfo = this._legendItemInfos[x];
                                if (legendItemInfo.uniqueId === uniqueId) {
                                    item = legendItemInfo.legendItem;
                                }
                            }
                            if (item) {
                                callback(item);
                            }
                            else {
                                this._legendItemCallbacks.push({ uniqueId: uniqueId, callback: callback }); // To be fulfilled when and if able.
                            }
                        };
                        //private _providers: { [identifier: string]: LegendItemProviderEntry; };
                        LegendItemProviderFactory._providers = [];
                        LegendItemProviderFactory._legendItemInfos = [];
                        LegendItemProviderFactory._legendItemCallbacks = [];
                        return LegendItemProviderFactory;
                    }());
                    legend.LegendItemProviderFactory = LegendItemProviderFactory;
                })(legend = infrastructure.legend || (infrastructure.legend = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../FeatureSetCollection.ts"/>
/// <reference path="../Feature.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var eventArgs;
                (function (eventArgs) {
                    var ResultsPageChangedEventArgs = (function () {
                        /**
                         * Initializes a new instance of the {@link ResultsPageChangedEventArgs} class.
                         */
                        function ResultsPageChangedEventArgs() {
                        }
                        return ResultsPageChangedEventArgs;
                    }());
                    eventArgs.ResultsPageChangedEventArgs = ResultsPageChangedEventArgs;
                })(eventArgs = infrastructure.eventArgs || (infrastructure.eventArgs = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var gis;
                (function (gis) {
                    var AppInfo = (function () {
                        function AppInfo() {
                        }
                        AppInfo.fromGeocortexApp = function (app) {
                            var instance = new AppInfo();
                            instance.gcxApp = app;
                            instance.urlParameters = app.urlParameters;
                            if (app.isArcGisWebApp) {
                                instance.mapInfo = gis.MapInfo.fromEsriMap(app.map);
                            }
                            else {
                                instance.essentialsVersion = app.site.getEssentialsVersion();
                                instance.mapInfo = gis.MapInfo.fromViewerApp(app);
                            }
                            instance.map = instance.mapInfo.map;
                            return instance;
                        };
                        AppInfo.prototype.getGeometryService = function () {
                            if (this._geometryService) {
                                return this._geometryService;
                            }
                            else if (this.geometryServiceUrl) {
                                this._geometryService = new esri.tasks.GeometryService(this.geometryServiceUrl);
                                return this._geometryService;
                            }
                            else if (this.gcxApp) {
                                return infrastructure.GeometryUtils.getGeometryService(this.gcxApp);
                            }
                            else {
                                return null;
                            }
                        };
                        return AppInfo;
                    }());
                    gis.AppInfo = AppInfo;
                })(gis = infrastructure.gis || (infrastructure.gis = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/moment-node.d.ts" />
/// <reference path="../../../_Definitions/moment-timezone.d.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var gis;
                (function (gis) {
                    var FieldInfo = (function () {
                        function FieldInfo() {
                            /**
                             * A list of the field's domains for each subtype, indexed by type ID.
                             */
                            this.subtypeDomains = {};
                            this.subtypeDomainInfos = {};
                            this.isVisible = true;
                        }
                        FieldInfo.fromEsriField = function (esriField, featureLayer, gcxField) {
                            var instance = new FieldInfo();
                            instance.name = esriField.name;
                            instance.type = esriField.type;
                            instance.alias = gcxField ? gcxField.displayName || esriField.alias : esriField.alias;
                            instance.isVisible = gcxField ? gcxField.visible : true;
                            instance.searchable = gcxField ? gcxField.searchable : true;
                            instance.editable = esriField.editable;
                            instance.nullable = esriField.nullable;
                            instance.length = esriField.length;
                            instance.esriField = esriField;
                            instance.isTypeField = featureLayer && featureLayer.typeIdField === esriField.name;
                            if (featureLayer) {
                                // If this is the type field and there is no domain defined, then create
                                // a pseudo-domain out of the type names.
                                if (instance.isTypeField && !esriField.domain) {
                                    var domain = new esri.layers.CodedValueDomain();
                                    domain.codedValues = [];
                                    domain.type = "codedValue";
                                    featureLayer.types.forEach(function (subtype) {
                                        domain.codedValues.push({ name: subtype.name, code: subtype.id });
                                    });
                                    instance.domainInfo = gis.DomainInfo.create(domain);
                                    instance.domain = domain;
                                }
                                else {
                                    instance.domainInfo = gis.DomainInfo.create(esriField.domain);
                                    instance.domain = esriField.domain;
                                }
                                // Populate domains for subtypes.
                                if (featureLayer.types) {
                                    featureLayer.types.forEach(function (subtype) {
                                        for (var fieldName in subtype.domains) {
                                            if (subtype.domains.hasOwnProperty(fieldName) && fieldName === esriField.name && subtype.id !== null) {
                                                var domain = subtype.domains[fieldName];
                                                instance.subtypeDomains[subtype.id.toString()] = domain;
                                                instance.subtypeDomainInfos[subtype.id.toString()] = gis.DomainInfo.create(domain);
                                                break;
                                            }
                                        }
                                    });
                                }
                            }
                            if (gcxField) {
                                instance.format = gcxField.format;
                                if (!instance.format) {
                                    // Apply any default formats defined on the layer or map service.
                                    if (instance._isNumericFormat()) {
                                        var numberFormat = [gcxField.layer.defaultNumberFormat, gcxField.layer.mapService.defaultNumberFormat].filter(function (f) { return !!f; })[0];
                                        if (numberFormat) {
                                            instance.format = "{0:" + numberFormat + "}";
                                        }
                                    }
                                    else if (instance.isDate()) {
                                        var dateFormat = [gcxField.layer.defaultDateFormat, gcxField.layer.mapService.defaultDateFormat].filter(function (f) { return !!f; })[0];
                                        if (dateFormat) {
                                            instance.format = "{0:" + dateFormat + "}";
                                        }
                                    }
                                }
                                if (!instance.timeZoneId) {
                                    instance.timeZoneId = mapping.infrastructure.TimeZoneUtils.getTimeZoneFromLayer(gcxField.layer);
                                }
                                if (!instance.displayTimeZoneId) {
                                    instance.displayTimeZoneId = mapping.infrastructure.TimeZoneUtils.getDisplayTimeZoneFromMapService(gcxField.layer.mapService);
                                }
                            }
                            return instance;
                        };
                        FieldInfo.fromGcxField = function (gcxField) {
                            var esriField = new esri.layers.Field();
                            var instance = new FieldInfo();
                            esriField.name = gcxField.name;
                            esriField.type = geocortex.essentials.Field.convertToEsriFieldType(gcxField.dataType);
                            esriField.alias = gcxField.displayName;
                            esriField.editable = false;
                            esriField.nullable = true;
                            return FieldInfo.fromEsriField(esriField, null, gcxField);
                        };
                        FieldInfo.prototype.isNumeric = function () {
                            var numericTypes = [
                                geocortex.essentials.EsriFieldTypes.esriFieldTypeOID,
                                geocortex.essentials.EsriFieldTypes.esriFieldTypeSmallInteger,
                                geocortex.essentials.EsriFieldTypes.esriFieldTypeInteger,
                                geocortex.essentials.EsriFieldTypes.esriFieldTypeSingle,
                                geocortex.essentials.EsriFieldTypes.esriFieldTypeDouble
                            ];
                            if (dojo.indexOf(numericTypes, this.type) >= 0) {
                                return true;
                            }
                            return false;
                        };
                        FieldInfo.prototype.isDate = function () {
                            var dateTypes = [geocortex.essentials.EsriFieldTypes.esriFieldTypeDate];
                            if (dojo.indexOf(dateTypes, this.type) >= 0) {
                                return true;
                            }
                            return false;
                        };
                        FieldInfo.prototype.isText = function () {
                            var textTypes = [geocortex.essentials.EsriFieldTypes.esriFieldTypeString];
                            if (dojo.indexOf(textTypes, this.type) >= 0) {
                                return true;
                            }
                            return false;
                        };
                        FieldInfo.prototype.isCodedValueDomain = function () {
                            return this.domainInfo && this.domainInfo.isCodedValueDomain();
                        };
                        FieldInfo.prototype.hasSubtypeCodedValueDomains = function () {
                            for (var typeID in this.subtypeDomainInfos) {
                                if (this.subtypeDomainInfos.hasOwnProperty(typeID) && this.subtypeDomainInfos[typeID].isCodedValueDomain()) {
                                    return true;
                                }
                            }
                            return false;
                        };
                        FieldInfo.prototype.getCodedValueDomain = function () {
                            return this.domain;
                        };
                        FieldInfo.prototype.getSubtypeCodedValueDomains = function () {
                            var subtypeCodedValueDomains = {};
                            for (var typeID in this.subtypeDomainInfos) {
                                if (this.subtypeDomainInfos.hasOwnProperty(typeID) && this.subtypeDomainInfos[typeID].isCodedValueDomain()) {
                                    subtypeCodedValueDomains[typeID] = this.subtypeDomainInfos[typeID].domain;
                                }
                            }
                            return subtypeCodedValueDomains;
                        };
                        FieldInfo.prototype.resolveCodedDomainValue = function (code, typeID) {
                            var result = null;
                            if (this.domainInfo) {
                                result = this.domainInfo.getName(code);
                            }
                            if (result == null) {
                                var subtypeDomainInfo = this.subtypeDomainInfos[typeID];
                                if (subtypeDomainInfo) {
                                    result = subtypeDomainInfo.getName(code);
                                }
                            }
                            return result;
                        };
                        FieldInfo.prototype.formatValue = function (value, typeID) {
                            var _this = this;
                            // Resolve coded domain if possible.
                            if (this.isCodedValueDomain() || this.hasSubtypeCodedValueDomains()) {
                                var resolvedValue = this.resolveCodedDomainValue(value, typeID);
                                if (resolvedValue != null) {
                                    return resolvedValue;
                                }
                            }
                            if (this.format) {
                                // Replace any "{0}" specifier in the format string with the field value.
                                return this.format.replace(/\{0(?::([^}]*))?\}/, function (sub, subFormat) {
                                    if (_this.isDate()) {
                                        var options = {
                                            timeZoneId: _this.timeZoneId,
                                            displayTimeZoneId: _this.displayTimeZoneId
                                        };
                                        return infrastructure.FormatUtils.formatDate(infrastructure.FormatUtils.parseDate(value), subFormat, options);
                                    }
                                    else if (_this._isNumericFormat()) {
                                        return infrastructure.FormatUtils.formatNumber(infrastructure.FormatUtils.parseNumber(value), subFormat);
                                    }
                                    else {
                                        return value === null || value === undefined ? value : value.toString();
                                    }
                                });
                            }
                            // Just use a default format according to the type of field.
                            if (this.isDate()) {
                                var options = {
                                    timeZoneId: this.timeZoneId,
                                    displayTimeZoneId: this.displayTimeZoneId
                                };
                                return infrastructure.FormatUtils.formatDate(infrastructure.FormatUtils.parseDate(value), null, options);
                            }
                            else if (this._isNumericFormat()) {
                                return infrastructure.FormatUtils.formatNumber(infrastructure.FormatUtils.parseNumber(value));
                            }
                            else {
                                return value === null || value === undefined ? value : value.toString();
                            }
                        };
                        /**
                         * Determines if values should be formatted as a number.
                         */
                        FieldInfo.prototype._isNumericFormat = function () {
                            return this.isNumeric()
                                && this.type !== geocortex.essentials.EsriFieldTypes.esriFieldTypeOID
                                && (!this.name || this.name.toUpperCase() !== "OBJECTID");
                        };
                        return FieldInfo;
                    }());
                    gis.FieldInfo = FieldInfo;
                })(gis = infrastructure.gis || (infrastructure.gis = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var gis;
                (function (gis) {
                    var LayerInfo = (function () {
                        function LayerInfo() {
                            this.fields = new Array();
                            this.isUserCreated = false; // Indicates if this layer was created and added by the user at runtime. Needs to be manually set if object created from esri layer
                            this.includeInLayerList = true; // true by default
                            this.isExpanded = true; // true by default
                            /**
                            * Whether the layer represented by this layerInfo object is currently visible or not.
                            */
                            this._visible = false;
                            this._fieldsRetrieved = false;
                        }
                        LayerInfo.fromEsriLayerInfo = function (esriLayerInfo, esriLayer) {
                            var instance = new LayerInfo();
                            instance.esriLayerInfo = esriLayerInfo;
                            instance.id = esriLayerInfo.id + "";
                            instance.name = esriLayerInfo.name;
                            instance.displayName = esriLayerInfo.name;
                            instance.parentLayerId = (esriLayerInfo.parentLayerId) ? esriLayerInfo.parentLayerId.toString() : null;
                            instance.subLayerIds = (esriLayerInfo.subLayerIds) ? dojo.map(esriLayerInfo.subLayerIds, function (layerId) {
                                return layerId.toString();
                            }) : null;
                            instance.uniqueId = esriLayer.id.replace(".", "..") + "." + esriLayerInfo.id; // dot replacement for escaping
                            instance.url = geocortex.essentials.utilities.DecomposedUri.appendToPath(esriLayer.url, "/" + esriLayerInfo.id);
                            instance.queryable = true; // Don't know if it is or not, so let's just assume yes
                            instance.dataProvider = "Default";
                            instance._visible = esriLayerInfo.defaultVisibility;
                            return instance;
                        };
                        LayerInfo.fromEsriFeatureLayer = function (featureLayer) {
                            var instance = new LayerInfo();
                            instance.id = featureLayer.id + "";
                            instance.name = featureLayer.name;
                            instance.displayName = featureLayer.name;
                            instance.uniqueId = featureLayer.id;
                            instance.url = featureLayer.url;
                            instance.queryable = true;
                            instance.dataProvider = "Default";
                            instance._featureLayer = featureLayer;
                            instance._visible = featureLayer.defaultVisibility;
                            instance.subLayerIds = null;
                            instance.parentLayerId = null;
                            instance.relationships = featureLayer.relationships;
                            return instance;
                        };
                        LayerInfo.fromGcxLayer = function (gcxLayer) {
                            var instance = new LayerInfo();
                            instance.gcxLayer = gcxLayer;
                            instance.id = gcxLayer.id;
                            instance.name = gcxLayer.name;
                            instance.displayName = gcxLayer.displayName || gcxLayer.name;
                            instance.uniqueId = gcxLayer.mapService.id + "." + gcxLayer.id;
                            instance.dataProvider = gcxLayer.dataProvider || "Default";
                            instance.isExpanded = gcxLayer.isExpanded;
                            instance.isUserCreated = gcxLayer.isUserCreated;
                            instance.relationships = gcxLayer.relationships;
                            if (gcxLayer.mapService.drawingBehavior == geocortex.essentials.DrawingBehavior.FEATURE_LAYER) {
                                instance.url = gcxLayer.mapService.serviceLayer.url;
                            }
                            else if (gcxLayer.mapService.mapServiceType == geocortex.essentials.MapServiceType.DYNAMIC
                                || gcxLayer.mapService.mapServiceType == geocortex.essentials.MapServiceType.TILED) {
                                instance.url = geocortex.essentials.utilities.DecomposedUri.appendToPath(gcxLayer.mapService.serviceLayer.url, "/" + gcxLayer.id);
                            }
                            else if (gcxLayer.mapService.serviceLayer instanceof esri.layers.WMSLayer) {
                                instance.url = gcxLayer.url;
                            }
                            if (gcxLayer.parentLayerId) {
                                instance.parentLayerId = gcxLayer.parentLayerId;
                            }
                            instance.subLayerIds = !!gcxLayer.subLayerIds
                                ? gcxLayer.subLayerIds
                                : null;
                            instance.includeInLayerList = gcxLayer.includeInLayerList;
                            instance.queryable = gcxLayer.queryable && gcxLayer.fields.length > 0 && gcxLayer.supportsQuery;
                            instance._visible = gcxLayer.configuredVisible;
                            return instance;
                        };
                        LayerInfo.prototype.getFields = function () {
                            var _this = this;
                            var deferred = new dojo.Deferred();
                            // Get the fields, or just return them if we have them already
                            if (this._fieldsRetrieved) {
                                // Just "return" the fields (asynchronously)
                                deferred.resolve(this.fields);
                            }
                            else {
                                this.getInitializedFeatureLayer().then(function (featureLayer) {
                                    for (var i = 0; i < featureLayer.fields.length; i++) {
                                        var esriField = featureLayer.fields[i];
                                        var gcxField = _this.gcxLayer ? _this.gcxLayer.getFieldByName(esriField.name) : null;
                                        var fieldInfo = gis.FieldInfo.fromEsriField(esriField, featureLayer, gcxField);
                                        _this.fields.push(fieldInfo);
                                    }
                                    _this._fieldsRetrieved = true;
                                    if (!deferred.isCanceled()) {
                                        deferred.resolve(_this.fields);
                                    }
                                }, function (error) {
                                    deferred.errback(error);
                                });
                            }
                            return deferred;
                        };
                        LayerInfo.prototype.getInitializedFeatureLayer = function () {
                            var _this = this;
                            if (this.gcxLayer) {
                                return this.gcxLayer.getFeatureLayer();
                            }
                            else {
                                return new Promise(function (resolve, reject) {
                                    // Create
                                    if (!_this._featureLayer) {
                                        _this._featureLayer = new esri.layers.FeatureLayer(_this.url);
                                    }
                                    // Load
                                    if (_this._featureLayer.loaded) {
                                        // Already loaded? Done.
                                        resolve(_this._featureLayer);
                                    }
                                    else if (_this._featureLayer["__attached_error"]) {
                                        reject(_this._featureLayer["__attached_error"]);
                                    }
                                    else {
                                        // Not loaded yet - wait for it to load.
                                        var loadHandle = _this._featureLayer.on("load", function () {
                                            loadHandle.remove();
                                            errorHandle.remove();
                                            if (!!_this.gcxLayer.wmsLayerName) {
                                                // The feature layer is returned with non-existant types for the fields when we're working with WMS.
                                                // This is probably a stupid way to do this, as we're not even working with feature layers, but it works.
                                                var gcxFields = _this.gcxLayer.fields;
                                                for (var i = _this._featureLayer.fields.length - 1; i >= 0; i--) {
                                                    var currentFeatureLayerField = _this._featureLayer.fields[i];
                                                    // Don't want to display the 'gml:id' field, it will break on querying.
                                                    if (currentFeatureLayerField.name === "gml:id") {
                                                        _this._featureLayer.fields.splice(i, 1);
                                                    }
                                                    currentFeatureLayerField.type = geocortex.essentials.Field.convertToEsriFieldType(gcxFields[i].dataType);
                                                }
                                            }
                                            resolve(_this._featureLayer);
                                        });
                                        var errorHandle = _this._featureLayer.on("error", function (error) {
                                            loadHandle.remove();
                                            errorHandle.remove();
                                            _this._featureLayer["__attached_error"] = error;
                                            reject(error);
                                        });
                                    }
                                });
                            }
                        };
                        LayerInfo.prototype.setDefinitionExpression = function (definition) {
                            var service = this.serviceLayerInfo.serviceLayer;
                            if (service instanceof esri.layers.ArcGISDynamicMapServiceLayer) {
                                var dynamicMapServiceLayer = service;
                                var existingDefinitions = dynamicMapServiceLayer.layerDefinitions || [];
                                if (!definition || definition == "1 = 1") {
                                    delete existingDefinitions[parseInt(this.id)];
                                }
                                else {
                                    existingDefinitions[parseInt(this.id)] = definition;
                                }
                                dynamicMapServiceLayer.setLayerDefinitions(existingDefinitions);
                            }
                            else if (service instanceof esri.layers.FeatureLayer) {
                                var featureLayer = service;
                                if (!definition || definition == "1 = 1") {
                                    featureLayer.setDefinitionExpression(null);
                                }
                                else {
                                    featureLayer.setDefinitionExpression(definition);
                                }
                            }
                        };
                        LayerInfo.prototype.getDefinitionExpression = function () {
                            var service = this.serviceLayerInfo.serviceLayer;
                            if (service instanceof esri.layers.ArcGISDynamicMapServiceLayer) {
                                var dynamicMapServiceLayer = service;
                                var existingDefinitions = dynamicMapServiceLayer.layerDefinitions || [];
                                return existingDefinitions[parseInt(this.id)];
                            }
                            return null;
                        };
                        /**
                         * Returns whether or not the layer represented by this layerInfo object is currently visible on the map. */
                        LayerInfo.prototype.isVisible = function () {
                            return (this.gcxLayer) ? this.gcxLayer.isVisible() : this._visible;
                        };
                        /**
                         * Gets a value representing whether or not all of this layer's ancestors are currently visible in the map. */
                        LayerInfo.prototype.areAllAncestorsVisible = function () {
                            var parentLayer = this.serviceLayerInfo.findLayerById(this.parentLayerId);
                            while (parentLayer !== null && parentLayer !== undefined) {
                                if (!parentLayer.isVisible()) {
                                    return false;
                                }
                                parentLayer = this.serviceLayerInfo.findLayerById(parentLayer.parentLayerId);
                            }
                            return true;
                        };
                        /**
                         * Sets the visibility for this layer.
                         * @param visible Specifies if the layer is visible or not
                         * @param doNotRefresh An optional parameter which if true, will set the visible layers internally but will not refresh the map automatically. Only applicable for
                         * mapServices that support layer visibility. Defaults to false.
                         * @param applyDeferredRefresh An optional parameter which if true, will refresh the map after a specified timeout in ms. Only applicable for mapServices that support
                         * layer visibility. 'applyDeferredRefresh' will ensure that only once refresh request is sent for all setVisibility requests within the given threshold. Defaults to false.
                         * @param refreshTimeoutMs The timeout in ms after which to refresh the map if applyDeferredRefresh is true. Defaults to 150ms.
                         */
                        LayerInfo.prototype.setVisibility = function (visible, doNotRefresh, applyDeferredRefresh, refreshTimeoutMs) {
                            if (doNotRefresh === void 0) { doNotRefresh = false; }
                            if (applyDeferredRefresh === void 0) { applyDeferredRefresh = false; }
                            if (refreshTimeoutMs === void 0) { refreshTimeoutMs = 150; }
                            var deferRefresh = false;
                            if (applyDeferredRefresh && this.serviceLayerInfo && this.serviceLayerInfo.serviceLayer) {
                                deferRefresh = this.serviceLayerInfo.supportsLayerVisibility();
                            }
                            if (this.gcxLayer) {
                                this.gcxLayer.setVisibility(visible, doNotRefresh || deferRefresh);
                            }
                            else {
                                this.setEsriLayerVisibility(visible, doNotRefresh || deferRefresh);
                            }
                            if (deferRefresh) {
                                this.serviceLayerInfo.refresh(refreshTimeoutMs);
                            }
                        };
                        LayerInfo.prototype.setEsriLayerVisibility = function (visible, doNotRefresh) {
                            if (doNotRefresh === void 0) { doNotRefresh = false; }
                            this._visible = visible;
                            if (!visible && !this.serviceLayerInfo.serviceLayer.visible) {
                                return;
                            }
                            // Logic below lifted from MapService.ts - setVisibility
                            var targetLayer = { mapServiceId: this.serviceLayerInfo.id, layerId: this.id, visibility: visible };
                            var counter, ix;
                            var serviceLayer = this.serviceLayerInfo.serviceLayer;
                            switch (this.serviceLayerInfo.serviceType) {
                                case geocortex.essentials.MapServiceType.DYNAMIC:
                                    if (serviceLayer instanceof esri.layers.FeatureLayer) {
                                        if (visible) {
                                            serviceLayer.show();
                                        }
                                        else {
                                            serviceLayer.hide();
                                        }
                                        // We need to publish the "LayerVisibilityChange" event manually here since esri's setLayerVisibility
                                        // function was not called. The code below publishes an 'array within an array' on purpose
                                        // since dojo seems to strip off the outer array if there's just one object/element in the array!
                                        dojo.publish("LayerVisibilityChange", [new Array(targetLayer)]);
                                    }
                                    else {
                                        // Create a shallow clone of esri's visiblelayers array. We dont want our changes reflecting in esri's layer object.
                                        var visibleLayers = this.serviceLayerInfo.serviceLayer.visibleLayers.slice(0);
                                        if ((visibleLayers && visibleLayers.length) || (serviceLayer.layerInfos && serviceLayer.layerInfos.length)) {
                                            if (visibleLayers.length === 1 && visibleLayers[0] == -1) {
                                                visibleLayers.pop();
                                            }
                                            var layerIndex = visibleLayers.indexOf(parseInt(this.id));
                                            if (!visible) {
                                                if (layerIndex === -1) {
                                                    return;
                                                }
                                                visibleLayers.splice(layerIndex, 1);
                                            }
                                            else {
                                                // If the layers already present in the list of visible layers, return.
                                                if (layerIndex !== -1) {
                                                    return;
                                                }
                                                // if the layer is a group layer - return. Group layers are not included inthe request to setVisibleLayers otherwise they will 
                                                // switch all their children's visibilities on regardless of state. They get switched on automatically if their children are switched on.
                                                if (this.subLayerIds && this.subLayerIds.length) {
                                                    return;
                                                }
                                                visibleLayers.push(parseInt(this.id));
                                            }
                                            if (!visibleLayers.length) {
                                                visibleLayers.push(-1);
                                            }
                                            // Add the special 'InternallyChangedLayer' property to the visibleLayers array object so that the 
                                            // LayerVisibilityEventManager knows that esri's setVisibleLayers has been called internally via the layers setVisibility
                                            // method and not programatically. Note: The event manager will intercept all esri setVisibleLayer calls.
                                            // IMPORTANT: Removing this property will cause the layer list to lose all visibility state information between calls
                                            visibleLayers["InternallyChangedLayer"] = targetLayer;
                                            this.serviceLayerInfo.serviceLayer.setVisibleLayers(visibleLayers, doNotRefresh);
                                        }
                                        else {
                                            serviceLayer.setVisibility(visible);
                                            // We need to publish the "LayerVisibilityChange" event manually here since esri's setLayerVisibility
                                            // function was not called. The code below publishes an 'array within an array' on purpose
                                            // since dojo seems to strip off the outer array if theres just one object/element in the array!
                                            dojo.publish("LayerVisibilityChange", [new Array(targetLayer)]);
                                        }
                                    }
                                    break;
                                case geocortex.essentials.MapServiceType.WMS:
                                    if (serviceLayer !== null) {
                                        var newVisibleWmsLayers = [];
                                        // Add the special 'InternallyChangedLayer' property to the newVisibleWmsLayers array object so that the 
                                        // LayerVisibilityEventManager knows that esri's setVisibleLayers has been called internally 
                                        // and not programatically. Note: The event manager will intercept all esri setVisibleLayer calls.
                                        newVisibleWmsLayers["InternallyChangedLayer"] = targetLayer;
                                        counter = 0;
                                        // We need to make sure that the ordering in Layers is preserved in the 
                                        // list of visible layers because the WMS server will draw the layers in
                                        // the order in which they occur in the list of visible layers.
                                        for (ix = 0; ix < this.serviceLayerInfo.layers.length; ix++) {
                                            var currLayer = this.serviceLayerInfo.layers[ix];
                                            if (currLayer.isVisible() &&
                                                (currLayer.subLayerIds === null || currLayer.subLayerIds.length === 0) &&
                                                currLayer.areAllAncestorsVisible()) {
                                                var wmsName = (currLayer.gcxLayer) ? currLayer.gcxLayer.wmsLayerName : currLayer.serviceLayerInfo.serviceLayer.id;
                                                // WMS layers whose names are empty strings shouldn't be added to the list
                                                // of visible layers.
                                                if ((this.gcxLayer && this.gcxLayer.wmsLayerName === wmsName) || (this.serviceLayerInfo.serviceLayer.id === wmsName) || (wmsName !== null && wmsName !== "")) {
                                                    newVisibleWmsLayers[counter] = wmsName;
                                                    counter++;
                                                }
                                            }
                                        }
                                        if (doNotRefresh) {
                                            this.serviceLayerInfo.serviceLayer.visibleLayers = newVisibleWmsLayers.slice(0);
                                            // We need to publish the "LayerVisibilityChange" event manually here since esri's setLayerVisibility
                                            // function was not called. The code below publishes an 'array within an array' on purpose
                                            // since dojo seems to strip off the outer array if there's just one object/element in the array!
                                            dojo.publish("LayerVisibilityChange", [new Array(targetLayer)]);
                                        }
                                        else {
                                            this.serviceLayerInfo.serviceLayer.setVisibleLayers(newVisibleWmsLayers);
                                        }
                                    }
                                    break;
                                case geocortex.essentials.MapServiceType.FEATURE:
                                case geocortex.essentials.MapServiceType.GEORSS:
                                case geocortex.essentials.MapServiceType.KML:
                                case geocortex.essentials.MapServiceType.BING:
                                case geocortex.essentials.MapServiceType.TILED:
                                case geocortex.essentials.MapServiceType.WMTS:
                                case geocortex.essentials.MapServiceType.IMAGE:
                                case geocortex.essentials.MapServiceType.WEBTILED:
                                    if (serviceLayer !== null) {
                                        // Though the mapService for these layers does not support individual layer visibilities, we support setting visibilities via a sub layer
                                        // if the service has exactly one it's sub layer (e.g. feature layers). Set the service layer to visible in case of feature layers.
                                        if (this.serviceLayerInfo.layers.length === 1) {
                                            if (visible) {
                                                serviceLayer.show();
                                            }
                                            else {
                                                serviceLayer.hide();
                                            }
                                            // We need to publish the "LayerVisibilityChange" event manually here since esri's setLayerVisibilit
                                            // y function was not called. The code below publishes an 'array within an array' on purpose
                                            // since dojo seems to strip off the outer array if there's just one object/element in the array!
                                            dojo.publish("LayerVisibilityChange", [new Array(targetLayer)]);
                                        }
                                        else {
                                            throw new Error("Visibility of individual layers cannot be set for this Map Service: {0}".format(this.displayName));
                                        }
                                    }
                                    break;
                                default:
                                    throw new Error("Cannot set layer visibility. Unknown MapService type.");
                            }
                        };
                        LayerInfo.prototype.getMinScale = function () {
                            var minScale;
                            if (this.gcxLayer) {
                                minScale = this.gcxLayer.minScale;
                            }
                            else {
                                minScale = (this._featureLayer) ? this._featureLayer.minScale : this.esriLayerInfo.minScale;
                            }
                            // If the map service has a more restrictive minScale defined, then it overrides the layer's setting.
                            if (this.serviceLayerInfo && this.serviceLayerInfo.serviceLayer.minScale) {
                                return Math.min(minScale, this.serviceLayerInfo.serviceLayer.minScale);
                            }
                            else {
                                return minScale;
                            }
                        };
                        LayerInfo.prototype.getMaxScale = function () {
                            var maxScale;
                            if (this.gcxLayer) {
                                maxScale = this.gcxLayer.maxScale;
                            }
                            else {
                                maxScale = (this._featureLayer) ? this._featureLayer.maxScale : this.esriLayerInfo.maxScale;
                            }
                            // If the map service has a more restrictive maxScale defined, then it overrides the layer's setting.
                            if (this.serviceLayerInfo && this.serviceLayerInfo.serviceLayer.maxScale) {
                                return Math.max(maxScale, this.serviceLayerInfo.serviceLayer.maxScale);
                            }
                            else {
                                return maxScale;
                            }
                        };
                        return LayerInfo;
                    }());
                    gis.LayerInfo = LayerInfo;
                })(gis = infrastructure.gis || (infrastructure.gis = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var gis;
                (function (gis) {
                    var MapInfo = (function () {
                        function MapInfo() {
                            this.serviceLayers = [];
                            this.markupLayer = new Observable();
                        }
                        MapInfo.fromEsriMap = function (map) {
                            var instance = new MapInfo();
                            instance.map = map;
                            instance.markupLayer.set(map.graphics);
                            var layerIds = map.layerIds.concat(map.graphicsLayerIds);
                            for (var i = 0; i < layerIds.length; i++) {
                                var serviceLayer = map.getLayer(layerIds[i]);
                                var serviceLayerInfo = gis.ServiceLayerInfo.fromEsriLayer(serviceLayer);
                                instance.serviceLayers.push(serviceLayerInfo);
                            }
                            return instance;
                        };
                        MapInfo.fromViewerApp = function (app) {
                            var instance = MapInfo.fromEssentialsMap(app.site.essentialsMap);
                            instance.markupLayer.sync(app.markupLayer);
                            return instance;
                        };
                        MapInfo.fromEssentialsMap = function (map) {
                            var instance = new MapInfo();
                            instance.gcxMap = map;
                            instance.map = map.getMap();
                            instance.markupLayer.set(map.getMap().graphics);
                            for (var i = 0; i < map.mapServices.length; i++) {
                                var mapService = map.mapServices[i];
                                var serviceLayerInfo = gis.ServiceLayerInfo.fromGcxMapService(mapService);
                                instance.serviceLayers.push(serviceLayerInfo);
                            }
                            return instance;
                        };
                        // Gets a flat list of every layer in the map
                        MapInfo.prototype.getLayerInfos = function () {
                            var layerInfos = new Array();
                            for (var i = 0; i < this.serviceLayers.length; i++) {
                                var subLayers = this.serviceLayers[i].layers;
                                for (var j = 0; j < subLayers.length; j++) {
                                    layerInfos.push(subLayers[j]);
                                }
                            }
                            return layerInfos;
                        };
                        // Gets a flat list of every table in the map
                        MapInfo.prototype.getTableInfos = function () {
                            var tableInfos = new Array();
                            for (var i = 0; i < this.serviceLayers.length; i++) {
                                var tables = this.serviceLayers[i].tables;
                                for (var j = 0; j < tables.length; j++) {
                                    tableInfos.push(tables[j]);
                                }
                            }
                            return tableInfos;
                        };
                        MapInfo.prototype.getGraphicsLayers = function () {
                            var graphicsLayers = new Array();
                            graphicsLayers.push(this.map.graphics);
                            for (var i = 0; i < this.map.graphicsLayerIds.length; i++) {
                                graphicsLayers.push(this.map.getLayer(this.map.graphicsLayerIds[i]));
                            }
                            return graphicsLayers;
                        };
                        // Find a map service given an id. Note that if a gxcMapService is present, the id's will be matched against those, else against the esri service layers
                        // Depending on whether we're in AWAB or GVH, both should return the desired output.
                        MapInfo.prototype.findMapServiceById = function (id) {
                            var useGcxMapService = null; // We want this method consistently using either the gcxMapService or esri serviceLayer - not a mix of both (though that should never happen)
                            var targetInfoSource;
                            for (var x = 0, len = this.serviceLayers.length; x < len; x++) {
                                var serviceLayerInfo = this.serviceLayers[x];
                                if (useGcxMapService == null) {
                                    useGcxMapService = !!(serviceLayerInfo && serviceLayerInfo.gcxMapService); // Once set, will apply the same setting across all service layers.
                                }
                                if (useGcxMapService) {
                                    targetInfoSource = serviceLayerInfo.gcxMapService;
                                }
                                else {
                                    targetInfoSource = serviceLayerInfo.serviceLayer;
                                }
                                if (targetInfoSource && targetInfoSource.id === id) {
                                    return serviceLayerInfo;
                                }
                            }
                            return null;
                        };
                        return MapInfo;
                    }());
                    gis.MapInfo = MapInfo;
                })(gis = infrastructure.gis || (infrastructure.gis = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var gis;
                (function (gis) {
                    var DomainInfo = (function () {
                        function DomainInfo() {
                        }
                        DomainInfo.create = function (domain) {
                            var instance = new DomainInfo();
                            instance.domain = domain;
                            return instance;
                        };
                        DomainInfo.prototype.isCodedValueDomain = function () {
                            return this.domain && this.domain.type == "codedValue";
                        };
                        DomainInfo.prototype.getCodedValueDomain = function () {
                            return this.domain;
                        };
                        DomainInfo.prototype.getName = function (code) {
                            if (this.isCodedValueDomain()) {
                                for (var i = 0; i < this.getCodedValueDomain().codedValues.length; i++) {
                                    var codedValue = this.getCodedValueDomain().codedValues[i];
                                    if ((codedValue.code + "") == (code + "")) {
                                        return codedValue.name;
                                    }
                                }
                            }
                            return null;
                        };
                        return DomainInfo;
                    }());
                    gis.DomainInfo = DomainInfo;
                })(gis = infrastructure.gis || (infrastructure.gis = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var identify;
                (function (identify) {
                    /**
                     * Very similar to the SearchProviderBase.
                     */
                    var IdentifyProviderBase = (function () {
                        function IdentifyProviderBase(app, libraryId) {
                            this.app = app;
                            this.libraryId = libraryId;
                        }
                        /**
                         * Initialize the provider.
                         * @param config The configuration object.
                         */
                        IdentifyProviderBase.prototype.initialize = function (config) { };
                        /**
                         * Performs the search.
                         * @param fsc Where search results are to go.
                         * @param searchText What to search for.
                         */
                        IdentifyProviderBase.prototype.search = function (fsc, args) { };
                        /**
                         * Cancels the last search. May be called repeatedly.
                         */
                        IdentifyProviderBase.prototype.cancelSearch = function () { };
                        /**
                         * Gets a language resource from the Application's resource dictionary, given a key, and optional locale.
                         * Returns null if the resource does not exist.
                         * @param key The resource key.
                         * @param locale The locale of the resource to fetch. Defaults to the current application locale.
                         */
                        IdentifyProviderBase.prototype.getResource = function (resourceKey, locale) {
                            return this.app.getResource(this.libraryId, resourceKey, locale);
                        };
                        return IdentifyProviderBase;
                    }());
                    identify.IdentifyProviderBase = IdentifyProviderBase;
                })(identify = infrastructure.identify || (infrastructure.identify = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/Essentials.d.ts" />
/// <reference path="LayerListItem.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var layerList;
                (function (layerList_3) {
                    /**
                     * A category (a.k.a. folder) item in the layer list.
                     */
                    var LayerListFolderItem = (function (_super) {
                        __extends(LayerListFolderItem, _super);
                        /**
                         * Initializes a new instance of the {@link LayerListFolderItem} class.
                         */
                        function LayerListFolderItem(id, name, layerList) {
                            _super.call(this, id, layerList_3.LayerListItemType.FOLDER, layerList);
                            /**
                             * A collection containing the layer theme settings for this category. Theme settings for mapServices and layers will reside in their respective geocortex layers.
                             */
                            this.layerThemeSettings = [];
                            /**
                             * An array of mapServices this folder contains. This information is important for establishing mapService visibility bindings and deciding if transparency sliders should be displayed
                             */
                            this.containedMapServices = [];
                            /**
                             * A boolean indicating whether this folder item was originally configured visible or not. We need to know what state to return to while applying layer themes
                             */
                            this.configuredVisible = false;
                            /**
                             * A boolean indicating if this folder has been user created (not to be confused with the User Added Layers folder)
                             * If a folder has been user created, we do not apply theme changes to it. The state of this folder remains consistant across layer theme changes
                             */
                            this.isUserCreated = false;
                            this._layerVisibilityHandle = null;
                            this.name = new Observable(name || this.layerList.appInfo.gcxApp.getResource(this.layerList._libraryId, "language-layerlist-default-folder-title"));
                            this._setTooltips();
                            layerList._addedFolderReferences.push(this);
                        }
                        /**
                         * Set the visibility of this category in the layer list
                         */
                        LayerListFolderItem.prototype.setVisibility = function (visible) {
                            _super.prototype.setVisibility.call(this, visible);
                            if (this._deferredVisibilitySetting != undefined) {
                                return;
                            }
                            this.currentUserClickOriginator = false; // Reset if this item is the current user click originator
                            if (this.mapService) {
                                this.mapService.setVisibility(visible && this.allAncestorsVisible && (this.inActiveTheme.get() || this.mapService.isUserCreated));
                            }
                        };
                        LayerListFolderItem.prototype.refreshOnDemandItemCollection = function (expanded) {
                            _super.prototype.refreshOnDemandItemCollection.call(this, expanded);
                            this.displayItem.set(!!this.children.length()); // For user added layers
                        };
                        /**
                         * Links the current folder with a mapService so we can perform specialized operations like listening for mapService visibility changes, showing transparency sliders etc.
                         */
                        LayerListFolderItem.prototype.linkWithMapService = function (mapService) {
                            var _this = this;
                            if (!mapService) {
                                return;
                            }
                            this.mapService = mapService;
                            this.layerList._handledMapServiceReferences.push(this.mapService);
                            if (this.layerList._allMapServiceReferences.indexOf(this.mapService) === -1) {
                                this.layerList._allMapServiceReferences.push(this.mapService);
                            }
                            this._setupOpacityBindings(); // Display transparency slider
                            // GVH-4329 - SetMapServiceVisibilty activity does not work with the new layer list
                            this._layerVisibilityHandle = this.mapService.serviceLayer.on("visibility-change", function (eventArgs) {
                                if ((_this._deferredVisibilitySetting == undefined) && (_this.isEffectivelyVisible.get() === eventArgs.visible)) {
                                    // If this layer is in the active theme, we're good. Return. Or if the effective visibility = intended visibility is false we're good.
                                    // However, if intended visibility is true and we're not currently in the active theme, we shouldn't return, because we need to set visibility to false.
                                    if (!_this.isEffectivelyVisible.get() || (_this.inActiveTheme.get() || _this.mapService.isUserCreated)) {
                                        return;
                                    }
                                }
                                var computedVisibility = eventArgs.visible && (_this.inActiveTheme.get() || _this.mapService.isUserCreated);
                                _this.isVisible.set(computedVisibility);
                            });
                        };
                        /** @private */
                        LayerListFolderItem.prototype._setupOpacityBindings = function () {
                            var _this = this;
                            if (this.containedMapServices.length === 1) {
                                _super.prototype._setupOpacityBindings.call(this);
                            }
                            else if (this.containedMapServices.length > 1) {
                                // Set up the opacity binding so that it controls the opacity filter of all the contained map services.
                                // This will blend with the individual opacities of each service and act like a "master" opacity control
                                // (e.g. the way a master volume control works). For the time being, this only works with Essentials
                                // map services.
                                var mapServicesWithOpacity = dojo.filter(this.containedMapServices, function (ms) { return ms.serviceLayer && ms.serviceLayer.setOpacity; });
                                var maxOpacity = Math.max.apply(null, mapServicesWithOpacity.map(function (ms) { return ms.serviceLayer.opacity; }));
                                this.canAdjustOpacity.set(true);
                                this.opacity = new Observable(1);
                                this.opacity.bind(this, function (opacity) {
                                    for (var i = 0; i < _this.containedMapServices.length; i++) {
                                        if (_this.containedMapServices[i].gcxMapService) {
                                            var gcxMapService = _this.containedMapServices[i].gcxMapService;
                                            gcxMapService.setOpacityFilter(opacity);
                                        }
                                    }
                                });
                            }
                        };
                        /**
                         * Remove any bindings and perform any necessary logic for item removal
                         */
                        LayerListFolderItem.prototype.cleanUp = function () {
                            _super.prototype.cleanUp.call(this);
                            if (this._layerVisibilityHandle) {
                                this._layerVisibilityHandle.remove();
                                this._layerVisibilityHandle = null;
                            }
                        };
                        /** @protected */
                        LayerListFolderItem.prototype._handleLayerThemeChangingEvent = function (args) {
                            if (args.currTheme) {
                                // We need to set all folder visibilities to true before a theme changes so that all mapService visibility events are honoured by the layer list
                                // No mapService should be effectively invisible due to a parent folder being invisible.
                                // User created folders should not be touched
                                if (!this.isUserCreated && !this.isVisible.get()) {
                                    this.isVisible.set(true);
                                }
                            }
                        };
                        /** @protected */
                        LayerListFolderItem.prototype._handleLayerThemeChangedEvent = function (args) {
                            var _this = this;
                            if (args.currTheme) {
                                var theme = args.currTheme;
                                var postProcess = function () {
                                    // Re-checking mutually exclusive radio buttons (GVH-6062).
                                    _this._refreshMutuallyExclusiveItemVisibilities();
                                };
                                if (this.isUserCreated) {
                                    this._setInActiveThemeIfChildrenPresent();
                                    postProcess();
                                    return;
                                }
                                if (theme.isDefaultTheme) {
                                    if (this.isVisible.get() !== this.configuredVisible) {
                                        this.isVisible.set(this.configuredVisible);
                                    }
                                    this._setInActiveThemeIfChildrenPresent();
                                    postProcess();
                                    return;
                                }
                                if (this.layerThemeSettings.length) {
                                    for (var x = 0; x < this.layerThemeSettings.length; x++) {
                                        var lts = this.layerThemeSettings[x];
                                        if (theme.id === lts.theme.id) {
                                            var visibility = lts.visible == undefined ? this.configuredVisible : lts.visible;
                                            if (this.isVisible.get() !== visibility) {
                                                this.isVisible.set(visibility);
                                            }
                                            this._setInActiveThemeIfChildrenPresent();
                                            postProcess();
                                            return;
                                        }
                                    }
                                }
                                this.isVisible.set(false);
                                this.inActiveTheme.set(false);
                                postProcess();
                            }
                        };
                        /**
                         * When a layer theme is changed, all folder visibilities are initially set to true so the layer list will
                         * respect the visibility change events fired by the javascript api on theme change.
                         * The javascript api however, has no notion of folders. Subsequently, when folder settings are applied, the
                         * correct state is activated by the layer list. This causes a problem when a folder is a mutually exclusive
                         * radio item. The UI will only allow one item to remain checked.... so if there are two items A and B where
                         * B is a folder and is turned on, the UI flicks off A though the layer list state may have it turned on.
                         * Subsequently, due to theme settings, if the layer list turns B off, the UI does not update the state of A
                         * automatically. We'll need to pulse A if it's visible.
                         * @private
                         */
                        LayerListFolderItem.prototype._refreshMutuallyExclusiveItemVisibilities = function () {
                            this.children.get().forEach(function (child) {
                                if (child.isMutuallyExclusive.get() && child.isVisible.get()) {
                                    child.isVisible.pulse();
                                }
                            });
                        };
                        /** @private */
                        LayerListFolderItem.prototype._setInActiveThemeIfChildrenPresent = function () {
                            var childrenInTheme = this._recursivelyConfirmChildrenInActiveTheme(this.children.get());
                            if (!childrenInTheme && this.inActiveTheme.get()) {
                                this.inActiveTheme.set(false);
                            }
                            if (childrenInTheme && !this.inActiveTheme.get()) {
                                this.inActiveTheme.set(true);
                            }
                        };
                        /** @private */
                        LayerListFolderItem.prototype._recursivelyConfirmChildrenInActiveTheme = function (children) {
                            var _this = this;
                            // Ensure we have at least one layer/map service among our children that's in the active theme. if not, remove this folder from the active theme as well.
                            var includedInActiveTheme = function (item) {
                                if (item.type === infrastructure.layerList.LayerListItemType.FOLDER) {
                                    return (item.children && item.children.length()) ? _this._recursivelyConfirmChildrenInActiveTheme(item.children.get()) : false;
                                }
                                else {
                                    return item.inActiveTheme.get();
                                }
                            };
                            for (var x = 0; x < children.length; x++) {
                                if (includedInActiveTheme(children[x])) {
                                    return true;
                                }
                            }
                            return false;
                        };
                        return LayerListFolderItem;
                    }(layerList_3.LayerListItem));
                    layerList_3.LayerListFolderItem = LayerListFolderItem;
                })(layerList = infrastructure.layerList || (infrastructure.layerList = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="LayerListItem.ts" />
/// <reference path="../gis/LayerInfo.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var layerList;
                (function (layerList_4) {
                    /**
                     * An item in the layer list that corresponds to a layer.
                     */
                    var LayerListLayerItem = (function (_super) {
                        __extends(LayerListLayerItem, _super);
                        /**
                         * Creates a new instance of the {@link LayerListLayerItem} class.
                         */
                        function LayerListLayerItem(id, layer, layerList, type) {
                            _super.call(this, id, type || layerList_4.LayerListItemType.LAYER, layerList);
                            this._themeSyncHandle = null;
                            this._layerVisibilityHandle = null;
                            this._zoomEndHandle = null;
                            this._deferRefreshTimeoutMs = 200;
                            this._forceSetAncestorVisibilityOperationActive = false;
                            if (!layer) {
                                throw new Error("LayerListLayerItem Initialization failed. Layer cannot be null");
                            }
                            // Flag user created items
                            this.isUserCreated = layer.isUserCreated;
                            this.layer = layer;
                            this._updateVisibilityAtCurrentScale();
                            this._zoomEndHandle = this.layerList.appInfo.mapInfo.map.on("zoom-end", dojo.hitch(this, this._updateVisibilityAtCurrentScale));
                            // We'll handle graphics layers separately in a subclass of this class
                            if (this.type === infrastructure.layerList.LayerListItemType.LAYER) {
                                // GVH-5920 && GVH-6252: If the gcxLayer is visible, we MUST respect that as the initial visibility. However, if it's not visible, it may be because it's parent map service is not visible.
                                // In that case, we'll need to respect the configured visibility of the layer because otherwise, a layer under a mapService/folder that's not set to visible will always remain ticked off on 
                                // startup because no layer visibility change event will be triggered unless it's parent mapService is actually set visible.
                                var initVisibility = layer.gcxLayer ? layer.gcxLayer.isVisible() || layer.gcxLayer.configuredVisible : true;
                                this.canNotAssignVisibility.set(!this.layer.serviceLayerInfo.supportsLayerVisibility());
                                this._deferredVisibilitySetting = initVisibility;
                                this.isVisible.set(initVisibility);
                            }
                            this.name.set(layer.displayName || layer.name);
                            this._setTooltips();
                            this.mapService = layer.serviceLayerInfo;
                            if (layerList._allMapServiceReferences.indexOf(this.mapService) === -1) {
                                layerList._allMapServiceReferences.push(this.mapService);
                            }
                            this.enableLayerActions = true;
                            this._subscribeEvents();
                            this._setupGcxBindingsIfAvailable();
                        }
                        /**
                         * Set the visibility of this layer in the layer list
                         */
                        LayerListLayerItem.prototype.setVisibility = function (visible, forceSetAncestorVisibility) {
                            _super.prototype.setVisibility.call(this, visible);
                            this._forceSetAncestorVisibilityOperationActive = this._forceSetAncestorVisibilityOperationActive || forceSetAncestorVisibility;
                            if (this.canNotAssignVisibility && this.canNotAssignVisibility.get()) {
                                return;
                            }
                            // Return if ancestor visibility has not been set as yet. It will be set (and this function re-invoked) when the setAncestorVisibility method is invoked
                            // as part of this item's addition to the LayerListItemCollection.
                            if (this.allAncestorsVisible === undefined) {
                                return;
                            }
                            if (this._deferredVisibilitySetting != undefined) {
                                return;
                            }
                            // GVH-4106: Automatically activate ancestor visibility when a sub layer is set visible
                            if ((this._forceSetAncestorVisibilityOperationActive || (this.layerList.autoActivateAncestorVisibilities && this.currentUserClickOriginator)) && visible === true && !this.allAncestorsVisible) {
                                if (this.isVisible.get() !== visible) {
                                    this.isVisible.set(visible);
                                }
                                var parent = this.parent;
                                while (parent && (parent.id !== this.layerList.id) && parent.isVisible.get()) {
                                    parent = parent.parent;
                                }
                                if (parent && (parent.id !== this.layerList.id)) {
                                    parent.isVisible.set(true);
                                    return;
                                }
                            }
                            // GVH-4487: Defer refresh of mapService if this layer was not individually clicked by the user (ie a parent is toggling visibility) and it supports layer visibility
                            // This is to avoid unnecessary export requests being issued for each layer within a mapService that is toggled.
                            var deferRefresh = !this.currentUserClickOriginator && this.mapService.supportsLayerVisibility();
                            this.currentUserClickOriginator = false; // Reset if this item is the current user click originator
                            this._forceSetAncestorVisibilityOperationActive = false;
                            var computedVisibility = visible && this.allAncestorsVisible && (this.inActiveTheme.get() || this.layer.isUserCreated);
                            if (this.layer.isVisible() !== computedVisibility) {
                                this.layer.setVisibility(computedVisibility, false, deferRefresh, this._deferRefreshTimeoutMs);
                            }
                        };
                        /**
                         * Updates the legend items including the legend swatch for a layer item.
                         */
                        LayerListLayerItem.prototype.updateLegendItems = function () {
                            var _this = this;
                            infrastructure.legend.LegendItemProviderFactory.getLegendItemWhenAvailable(this.layer, dojo.hitch(this, function (layerItem) {
                                // Clear any previous legend items then repopulate
                                _this.legendItems.clear();
                                _this._populateLegendItem(layerItem);
                            }));
                        };
                        /**
                         * Updates inActiveTheme when it changes in the underlying geocortex layer (if available)
                         */
                        LayerListLayerItem.prototype.bindToActiveTheme = function () {
                            var _this = this;
                            _super.prototype.bindToActiveTheme.call(this);
                            this._themeSyncHandle = dojo.subscribe("LayerInActiveThemeChangedEvent", function (sender) {
                                if (sender && sender === _this.layer.gcxLayer) {
                                    _this.inActiveTheme.set(sender.inActiveTheme);
                                }
                            });
                        };
                        /**
                         * Removes the binding to the active theme
                         */
                        LayerListLayerItem.prototype.unbindFromActiveTheme = function () {
                            _super.prototype.unbindFromActiveTheme.call(this);
                            if (this._themeSyncHandle) {
                                dojo.unsubscribe(this._themeSyncHandle);
                            }
                            this._themeSyncHandle = null;
                        };
                        /**
                         * Remove any bindings and perform any necessary logic for item removal
                         */
                        LayerListLayerItem.prototype.cleanUp = function () {
                            _super.prototype.cleanUp.call(this);
                            if (this._layerVisibilityHandle) {
                                dojo.unsubscribe(this._layerVisibilityHandle);
                                this._layerVisibilityHandle = null;
                            }
                            if (this._zoomEndHandle) {
                                this._zoomEndHandle.remove();
                                this._zoomEndHandle = null;
                            }
                        };
                        /** @private */
                        LayerListLayerItem.prototype._subscribeEvents = function () {
                            this._layerVisibilityHandle = dojo.subscribe("LayerVisibilityChange", dojo.hitch(this, this._handleLayerVisibilityChange));
                        };
                        /** @private */
                        LayerListLayerItem.prototype._onServiceLayerProcessed = function () {
                            this._setupIconUri();
                            // If legend integration is enabled, retrieve the legend (if any) for this layer.
                            if (this.layerList.enableLegendIntegration && !this.layer.serviceLayerInfo.serviceLayer.loadError) {
                                infrastructure.legend.LegendItemProviderFactory.getLegendItemWhenAvailable(this.layer, dojo.hitch(this, this._populateLegendItem));
                            }
                        };
                        /** @private */
                        LayerListLayerItem.prototype._handleLayerVisibilityChange = function (results) {
                            if (results && results.length && (results[0].mapServiceId === this.layer.serviceLayerInfo.id)) {
                                for (var x = 0; x < results.length; x++) {
                                    if (results[x].layerId === this.layer.id) {
                                        if ((this._deferredVisibilitySetting == undefined) && (this.isEffectivelyVisible.get() === results[x].visibility)) {
                                            // If this layer is in the active theme, we're good. Break. Or if the effective visibility = intended visibility is false we're good.
                                            // However, if intended visibility is true and we're not currently in the active theme, we shouldn't break, because we need to set visibility to false.
                                            if (!this.isEffectivelyVisible.get() || (this.inActiveTheme.get() || this.layer.isUserCreated)) {
                                                break;
                                            }
                                        }
                                        var computedVisibility = results[x].visibility && (this.inActiveTheme.get() || this.layer.isUserCreated);
                                        this.isVisible.set(computedVisibility);
                                        break;
                                    }
                                }
                            }
                        };
                        /** @private */
                        LayerListLayerItem.prototype._populateLegendItem = function (item) {
                            if (item.templateType === "single-item") {
                                this.expandLegend.set(false);
                                this.legendItems.addItem(item);
                                this.legendSwatch.set(item.swatchElement);
                            }
                            else {
                                this.legendItems.addItems(item.children.get());
                                if (this.legendItems.length() === 1) {
                                    this.legendSwatch.set(this.legendItems.getAt(0).swatchElement);
                                }
                                else if (this.legendItems.length()) {
                                    this.legendSwatch.set(this.layerList.multiLegendSwatchElement || this.legendItems.getAt(0).swatchElement);
                                }
                            }
                            if (this.legendItems.length() > 1) {
                                this.legendHasMultipleItems.set(true);
                            }
                            else {
                                this.legendHasMultipleItems.set(false);
                            }
                            if (this.legendItems.length()) {
                                this.iconUri.set(""); // GVH-4235 If a legend exists for a layer, remove the layer icon.
                                this.legendTooltip.set((this.legendItems.length() === 1) ? this.layerList.singleLegendIconTooltip.format(this.name.get()) : this.layerList.multiLegendIconTooltip); // GVH-4296
                                this.legendTooltip.set(this.legendTooltip.get().format(this.name.get()));
                            }
                        };
                        /** @private */
                        LayerListLayerItem.prototype._setupIconUri = function () {
                            var gcxLayer = this.layer.gcxLayer;
                            var gcxMapService = gcxLayer ? gcxLayer.mapService : null;
                            if (this.layer.serviceLayerInfo.serviceLayer.loadError && this.layerList.serviceLoadFailureIconUri) {
                                this.iconUri.set(this.layerList.serviceLoadFailureIconUri);
                                this.iconTooltip.set(this.layerList.serviceLoadFailureIconTooltip ? this.layerList.serviceLoadFailureIconTooltip : "");
                            }
                            else if (this.layerList && this.layerList.enableLayerIcons && ((gcxLayer && gcxLayer.iconUri) || (gcxMapService && this.type === layerList_4.LayerListItemType.GRAPHICSLAYER && gcxMapService.iconUri))) {
                                this.iconUri.set(gcxLayer.iconUri || gcxMapService.iconUri);
                                this.iconTooltip.set(this.name.get());
                            }
                        };
                        /**
                         * @private
                         * Sets up geocortex layer bindings if the layer is available. The layer will not be available if we're operating in a WAB environment
                         */
                        LayerListLayerItem.prototype._setupGcxBindingsIfAvailable = function () {
                            var _this = this;
                            if (this.layer.gcxLayer) {
                                this.bindToActiveTheme();
                                if (!this.layer.serviceLayerInfo.serviceLayer.loaded && !this.layer.serviceLayerInfo.serviceLayer.loadError) {
                                    var _layerOnLoadToken = null, _layerOnErrorToken = null;
                                    var _disconnectLayerEvents = function () {
                                        _layerOnLoadToken && dojo.disconnect(_layerOnLoadToken);
                                        _layerOnErrorToken && dojo.disconnect(_layerOnErrorToken);
                                        _layerOnLoadToken = _layerOnErrorToken = null;
                                    };
                                    _layerOnLoadToken = dojo.connect(this.mapService.serviceLayer, "onLoad", function () {
                                        _disconnectLayerEvents();
                                        _this._onServiceLayerProcessed();
                                    });
                                    _layerOnErrorToken = dojo.connect(this.mapService.serviceLayer, "onError", function () {
                                        _disconnectLayerEvents();
                                        _this._onServiceLayerProcessed();
                                    });
                                }
                                else {
                                    this._onServiceLayerProcessed();
                                }
                            }
                        };
                        /** @private */
                        LayerListLayerItem.prototype._updateVisibilityAtCurrentScale = function () {
                            var inRange = false;
                            var scale = esri.geometry.getScale(this.layerList.appInfo.mapInfo.map);
                            if ((this.layer.getMaxScale() == 0 && this.layer.getMinScale() == Infinity || undefined)
                                || (isNaN(this.layer.getMaxScale()) && isNaN(this.layer.getMinScale()))) {
                                inRange = true;
                            }
                            this.inVisibleScaleRange.set(inRange || (this.layer.getMaxScale() < scale && scale < this.layer.getMinScale()));
                        };
                        return LayerListLayerItem;
                    }(layerList_4.LayerListItem));
                    layerList_4.LayerListLayerItem = LayerListLayerItem;
                })(layerList = infrastructure.layerList || (infrastructure.layerList = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="LayerListLayerItem.ts" />
/// <reference path="../gis/LayerInfo.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var layerList;
                (function (layerList_5) {
                    /**
                     * An item in the layer list that corresponds to a layer.
                     */
                    var LayerListGraphicsLayerItem = (function (_super) {
                        __extends(LayerListGraphicsLayerItem, _super);
                        /**
                         * Creates a new instance of the {@link LayerListLayerItem} class.
                         */
                        function LayerListGraphicsLayerItem(id, layer, layerList) {
                            _super.call(this, id, layer, layerList, layerList_5.LayerListItemType.GRAPHICSLAYER);
                            if (!layer) {
                                throw new Error("LayerListGraphicsLayerItem Initialization failed. Layer cannot be null.");
                            }
                            // GVH-5920 && GVH-6252: If the gcxLayer is visible, we MUST respect that as the initial visibility. However, if it's not visible, it may be because it's parent map service is not visible.
                            // In that case, we'll need to respect the configured visibility of the layer because otherwise, a layer under a mapService/folder that's not set to visible will always remain ticked off on 
                            // startup because no layer visibility change event will be triggered unless it's parent mapService is actually set visible.
                            var initVisibility = layer.gcxLayer ? layer.gcxLayer.isVisible() || layer.gcxLayer.configuredVisible
                                : layer.serviceLayerInfo.serviceLayer.defaultVisibility || layer.isVisible();
                            this.canNotAssignVisibility.set(false); // Special graphics layer behaviour
                            this._deferredVisibilitySetting = initVisibility;
                            this.isVisible.set(initVisibility);
                        }
                        return LayerListGraphicsLayerItem;
                    }(layerList_5.LayerListLayerItem));
                    layerList_5.LayerListGraphicsLayerItem = LayerListGraphicsLayerItem;
                })(layerList = infrastructure.layerList || (infrastructure.layerList = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="LayerListItem.ts" />
/// <reference path="../gis/LayerInfo.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var layerList;
                (function (layerList_6) {
                    /**
                     * A collection of child items belonging to a node in the layer list.
                     */
                    var LayerListItemCollection = (function (_super) {
                        __extends(LayerListItemCollection, _super);
                        /**
                         * Creates a new instance of the {@link LayerListItemCollection} class.
                         */
                        function LayerListItemCollection(parent, childItemArray) {
                            if (childItemArray === void 0) { childItemArray = []; }
                            _super.call(this, childItemArray || []);
                            this._parent = parent;
                        }
                        /**
                         * Adds an item to the collection. Overriding base class method so parent can automatically be set while inserting
                         */
                        LayerListItemCollection.prototype.addItem = function (item) {
                            if (item) {
                                this._prepItemForAddition(item);
                                _super.prototype.addItem.call(this, item);
                                this._processItemPostAddition(item);
                            }
                            else {
                                throw new Error("Layer list item not defined. Cannot insert in collection.");
                            }
                        };
                        /**
                         * Adds an item after performing validation. Returns true if successful, false otherwise.
                         */
                        LayerListItemCollection.prototype.validateAndAddItem = function (item) {
                            if (!item) {
                                return false;
                            }
                            if (this._validateCanAdd(item)) {
                                this.addItem(item);
                                return true;
                            }
                            console.error("LayerListItemCollection: Cannot add item with id: {0} in collection. Validation failed.".format(item.id.get()));
                            return false;
                        };
                        /**
                         * Adds multiple items to the collection. Overriding base class method so parent can automatically be set while inserting
                         */
                        LayerListItemCollection.prototype.addItems = function (items) {
                            if (items) {
                                this._prepItemsForAddition(items);
                                _super.prototype.addItems.call(this, items);
                                this._processItemsPostAddition(items);
                            }
                            else {
                                throw new Error("Layer list items are not defined. Cannot insert in collection.");
                            }
                        };
                        /**
                         * Adds multiple items after validating all of them. Will either add all or none. Returns true on success, false otherwise.
                         */
                        LayerListItemCollection.prototype.validateAndAddItems = function (items) {
                            if (!items || !items.length) {
                                return false;
                            }
                            for (var x = 0; x < items.length; x++) {
                                if (!this._validateCanAdd(items[x])) {
                                    console.error("LayerListItemCollection: Cannot add items in collection. Validation failed.");
                                    return false;
                                }
                            }
                            this.addItems(items);
                            return true;
                        };
                        /**
                         * Inserts an item into the collection at the specified index. Overriding base class method so parent can be automatically set while inserting
                         */
                        LayerListItemCollection.prototype.insertItem = function (position, item) {
                            if (item) {
                                this._prepItemForAddition(item);
                                _super.prototype.insertItem.call(this, position, item);
                                this._processItemPostAddition(item);
                            }
                            else {
                                throw new Error("Layer list item not defined. Cannot insert at index " + position + " in collection.");
                            }
                        };
                        /**
                         * Inserts multiple item into the collection at the specified index. Overriding base class method so parent can be automatically set while inserting
                         */
                        LayerListItemCollection.prototype.insertItems = function (position, items) {
                            if (items) {
                                this._prepItemsForAddition(items);
                                _super.prototype.insertItems.call(this, position, items);
                                this._processItemsPostAddition(items);
                            }
                            else {
                                throw new Error("Layer list items are not defined. Cannot insert at index " + position + " in collection.");
                            }
                        };
                        /**
                         * Inserts an item into the collection at a specified index if the item passes validation.
                         */
                        LayerListItemCollection.prototype.validateAndInsertItem = function (position, newItem) {
                            if (this._validateCanAdd(newItem)) {
                                this.insertItem(position, newItem);
                                return true;
                            }
                            console.error("LayerListItemCollection: Could not insert item with id: {0} in collection. Validation failed.".format(newItem.id.get()));
                            return false;
                        };
                        /**
                         * Validates and inserts multiple items into the collection at a specified index. Will either insert all if validated, or none at all.
                         */
                        LayerListItemCollection.prototype.validateAndInsertItems = function (position, items) {
                            if (!items || !items.length) {
                                return false;
                            }
                            for (var x = 0; x < items.length; x++) {
                                if (!this._validateCanAdd(items[x])) {
                                    console.error("Could not insert items in collection. Validation failed.");
                                    return false;
                                }
                            }
                            this.insertItems(position, items);
                            return true;
                        };
                        /**
                         * Remove item by reference. Overriding base class method so parent can automatically be set to null on removal
                         */
                        LayerListItemCollection.prototype.removeItem = function (item) {
                            if (item) {
                                this._prepItemForRemoval(item);
                                _super.prototype.removeItem.call(this, item);
                            }
                            else {
                                throw new Error("LayerListItemCollection: Cannot remove item at index from collection.");
                            }
                        };
                        /**
                         * Remove item by index. Overriding base class method so parent can automatically be set to null on removal
                         */
                        LayerListItemCollection.prototype.removeAt = function (position) {
                            var item = this.getAt(position);
                            if (item) {
                                this._prepItemForRemoval(item);
                                _super.prototype.removeAt.call(this, position);
                            }
                            else {
                                throw new Error("LayerListItemCollection: Cannot remove item at index " + position + " from collection.");
                            }
                        };
                        /**
                         * Removes a range of items from the collection. Overriding base class method so parent can automatically be set to null on removal
                         */
                        LayerListItemCollection.prototype.removeRange = function (from, to) {
                            from = (from != undefined) ? Math.max(0, from) : 0;
                            to = (to != undefined) ? Math.min(to, this.getLength() - 1) : this.getLength() - 1;
                            this._prepItemsForRemoval(this.get().slice(from, to + 1)); // removeRange function interprets 'to' as inclusive; slice does not.
                            _super.prototype.removeRange.call(this, from, to);
                        };
                        /**
                         * Clears the collection after first setting the parents to null
                         */
                        LayerListItemCollection.prototype.clear = function () {
                            this._prepItemsForRemoval(this.get());
                            _super.prototype.clear.call(this);
                        };
                        /**
                         * Private method that sets item properties like its parent and observable bindings before its added to this collection
                         */
                        LayerListItemCollection.prototype._prepItemForAddition = function (item) {
                            var _this = this;
                            if (this._parent) {
                                item.parent = this._parent;
                                item.parentEffectivelyVisible.sync(item.parent.isEffectivelyVisible);
                                item.setAncestorVisibility(this._parent.isVisible.get());
                                item._visibilityBindingToken = this._parent.isVisible.bind(item, function (visibility) {
                                    item.setAncestorVisibility(visibility && _this._parent.allAncestorsVisible);
                                });
                                // If adding to a mutually exclusive group, set the item up to be mutually exclusive as well.
                                if (this.length() && this.getAt(0).isMutuallyExclusive.get()) {
                                    item.isMutuallyExclusive.set(true);
                                    item.hasRadioToggle.set(true);
                                    item.radioGroup.set(this.getAt(0).radioGroup.get());
                                }
                                // Keep "hasDisplayedChildren" property of the parent in sync with the child's "displayItem" property.
                                item._displayItemBindingToken = item.displayItem.bind(item, function (displayItem) {
                                    if (displayItem) {
                                        _this._parent.hasDisplayedChildren.set(true);
                                    }
                                    else {
                                        var hasDisplayedChildren = false;
                                        for (var i = 0; i < _this.length(); i++) {
                                            if (_this.getAt(i).displayItem.get()) {
                                                hasDisplayedChildren = true;
                                                break;
                                            }
                                        }
                                        _this._parent.hasDisplayedChildren.set(hasDisplayedChildren);
                                    }
                                });
                                item.displayItem.pulse();
                            }
                        };
                        /**
                         * Any processing that might be needed for an item post addition
                         */
                        LayerListItemCollection.prototype._processItemPostAddition = function (item) {
                            if (item.type === infrastructure.layerList.LayerListItemType.MAPSERVICE || item.type === infrastructure.layerList.LayerListItemType.LAYER || item.type === infrastructure.layerList.LayerListItemType.GRAPHICSLAYER) {
                                item.populateMapServicesInParentFolders();
                            }
                        };
                        /**
                         * Private method that removes/resets item properties like its parent and observable bindings before its removed from this collection
                         */
                        LayerListItemCollection.prototype._prepItemForRemoval = function (item) {
                            item.parentEffectivelyVisible.removeSync();
                            item.parent = null;
                            if (item._visibilityBindingToken && this._parent) {
                                this._parent.isVisible.unbind(item._visibilityBindingToken);
                                item._visibilityBindingToken = null;
                            }
                            if (item._displayItemBindingToken && this._parent) {
                                item.displayItem.unbind(item._displayItemBindingToken);
                                item._displayItemBindingToken = null;
                                if (item.displayItem) {
                                    // Recalculate whether the parent will have any remaining children that are displayed in the layer list.
                                    var hasDisplayedChildren = false;
                                    for (var i = 0; i < this.length(); i++) {
                                        if (this.getAt(i) !== item && this.getAt(i).displayItem.get()) {
                                            hasDisplayedChildren = true;
                                            break;
                                        }
                                    }
                                    this._parent.hasDisplayedChildren.set(hasDisplayedChildren);
                                }
                            }
                            item.cleanUp();
                        };
                        /**
                         * Convenience method to prep multiple items for addition simultaneously
                         */
                        LayerListItemCollection.prototype._prepItemsForAddition = function (items) {
                            var _this = this;
                            dojo.forEach(items, function (item) {
                                _this._prepItemForAddition(item);
                            });
                        };
                        /**
                         * Convenience method to process multiple items simultaneously post addition
                         */
                        LayerListItemCollection.prototype._processItemsPostAddition = function (items) {
                            var _this = this;
                            dojo.forEach(items, function (item) {
                                _this._processItemPostAddition(item);
                            });
                        };
                        /**
                         * Convenience method to prep multiple items for removal simultaneously
                         */
                        LayerListItemCollection.prototype._prepItemsForRemoval = function (items) {
                            var _this = this;
                            dojo.forEach(items, function (item) {
                                _this._prepItemForRemoval(item);
                            });
                        };
                        /**
                         * Invoked just before adding an item as a child of this node. Validates if it can be added or not.
                         */
                        LayerListItemCollection.prototype._validateCanAdd = function (newItem) {
                            var _this = this;
                            var layerList = this.layerList || this._parent.layerList;
                            // Validation 1: Check for duplicate layers
                            var items = layerList.getDescendants();
                            // If it's already an item that's there, fails validation.
                            var matchingItems = items.filter(function (layerListItem) {
                                return layerListItem === newItem;
                            });
                            if (matchingItems.length) {
                                return false;
                            }
                            // Now apply specific rules based on the type.
                            if (newItem.type === layerList_6.LayerListItemType.FOLDER) {
                                var folderItem = newItem;
                                // Check all of the children of the folder
                                return folderItem.children.getItems().every(function (layerListItem) {
                                    return _this._validateCanAdd(layerListItem);
                                });
                            }
                            else if (newItem.type === layerList_6.LayerListItemType.MAPSERVICE) {
                                if (newItem.mapService) {
                                    // If it's a map service layer list item, check the mapService or the underlying service layer.
                                    return !items.some(function (layerListItem) {
                                        return layerListItem.mapService && (layerListItem.mapService === newItem.mapService || layerListItem.mapService.serviceLayer === newItem.mapService.serviceLayer);
                                    });
                                }
                                else {
                                    // If it doesn't have a mapService, not a valid item.
                                    return false;
                                }
                            }
                            else if (newItem.type === layerList_6.LayerListItemType.LAYER) {
                                var layerItem = newItem;
                                if (layerItem.layer) {
                                    // If any of the items match the current item, then we don't want to add this new one.
                                    return !items.some(function (layerListItem) {
                                        return layerListItem.layer && layerListItem.layer === layerItem.layer;
                                    });
                                }
                                else {
                                    // Not a valid layer list layer item if it doesn't have a layer.
                                    return false;
                                }
                            }
                            return true;
                        };
                        return LayerListItemCollection;
                    }(ObservableCollection));
                    layerList_6.LayerListItemCollection = LayerListItemCollection;
                })(layerList = infrastructure.layerList || (infrastructure.layerList = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="LayerListItem.ts" />
/// <reference path="../gis/ServiceLayerInfo.ts" />
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var layerList;
                (function (layerList_7) {
                    /**
                     * In case of the configurable Layer List this class represents a layer list item that corresponds directly to an "atomic" map service, i.e.
                     * one whose visibility is toggled as a whole rather than changing the visibility of individual layers.
                     * In case of a standard layer list or AWAB, this class will behave like a normal map service.
                     */
                    var LayerListMapServiceItem = (function (_super) {
                        __extends(LayerListMapServiceItem, _super);
                        /**
                         * Creates a new instance of the {@link LayerListMapServiceItem} class.
                         */
                        function LayerListMapServiceItem(id, mapService, layerList) {
                            var _this = this;
                            _super.call(this, id, layerList_7.LayerListItemType.MAPSERVICE, layerList);
                            this._themeSyncHandle = null;
                            this._layerVisibilityHandle = null;
                            this._forceSetAncestorVisibilityOperationActive = false;
                            if (!mapService) {
                                throw new Error("LayerListMapServiceItem Initialization failed. MapService cannot be null");
                            }
                            var initVisibility;
                            if (this.layerList && this.layerList.mapInfo && this.layerList.mapInfo.gcxMap && this.layerList.mapInfo.gcxMap.layerThemesInfo && this.layerList.mapInfo.gcxMap.layerThemesInfo.layerThemesConfigured) {
                                // GVH-5920 && GVH-6252: Post the fix for GVH-4725, we set the gcx map service visibility to the initial visibility defined in the theme settings returned by essentials. 
                                // Hence the initVisibility here cannot be the configured visibility because that will not reflect the actual state of the map service visibility. If that happens, esri's service layer
                                // will not fire visibility events for when the initial theme is applied (since visibility is already what is defined in the initial theme) and hence the layer list will fall out of sync.
                                initVisibility = mapService.gcxMapService && mapService.gcxMapService.serviceLayer ? mapService.gcxMapService.serviceLayer.visible : true;
                            }
                            else {
                                initVisibility = mapService.gcxMapService ? mapService.gcxMapService.configuredVisible : true;
                            }
                            this.name.set(mapService.displayName ? mapService.displayName : "" /* TODO: Awab Layer Name */);
                            this._setTooltips();
                            this.mapService = mapService;
                            layerList._handledMapServiceReferences.push(mapService);
                            if (layerList._allMapServiceReferences.indexOf(mapService) === -1) {
                                layerList._allMapServiceReferences.push(mapService);
                            }
                            this._deferredVisibilitySetting = initVisibility;
                            this.isVisible.set(initVisibility);
                            var slType = this.mapService.serviceType;
                            // Flag user created items. The map service actions menu should be available only for user-added services to allow their removal.
                            this.isUserCreated = mapService.isUserCreated;
                            this.enableMapServiceActions = mapService.isUserCreated;
                            this._setupOpacityBindings();
                            this._subscribeEvents();
                            this._setupBindings();
                            if (mapService.serviceLayer instanceof esri.layers.KMLLayer) {
                                var kmlLayer = mapService.serviceLayer;
                                if (kmlLayer.loaded) {
                                    this._kmlLayerLoadHandler(kmlLayer);
                                }
                                else {
                                    kmlLayer.on("load", function (event) { return _this._kmlLayerLoadHandler(event.layer); });
                                }
                            }
                        }
                        /**
                         * Set the visibility of this mapService item in the layer list
                         * @param visible The visibility of this map service item
                         * @param forceSetAncestorVisibility If true, will force ancestor visibilities to sync up with this map service item
                         */
                        LayerListMapServiceItem.prototype.setVisibility = function (visible, forceSetAncestorVisibility) {
                            _super.prototype.setVisibility.call(this, visible);
                            this._forceSetAncestorVisibilityOperationActive = this._forceSetAncestorVisibilityOperationActive || forceSetAncestorVisibility;
                            this._syncChildVisibilitiesIfApplicable(visible);
                            // Return if ancestor visibility has not been set as yet. It will be set (and this function re-invoked) when the setAncestorVisibility method is invoked
                            // as part of this item's addition to the LayerListItemCollection.
                            if (this.allAncestorsVisible === undefined) {
                                return;
                            }
                            if (this._deferredVisibilitySetting != undefined) {
                                return;
                            }
                            // GVH-4106: Automatically activate ancestor visibility when a sub layer is set visible
                            if ((this._forceSetAncestorVisibilityOperationActive || (this.layerList.autoActivateAncestorVisibilities && this.currentUserClickOriginator)) && visible === true && !this.allAncestorsVisible) {
                                if (this.isVisible.get() !== visible) {
                                    this.isVisible.set(visible);
                                }
                                var parent = this.parent;
                                while (parent && (parent.id !== this.layerList.id) && parent.isVisible.get()) {
                                    parent = parent.parent;
                                }
                                if (parent && (parent.id !== this.layerList.id)) {
                                    parent.isVisible.set(true);
                                    return;
                                }
                            }
                            this.currentUserClickOriginator = false; // Reset if this item is the current user click originator
                            this._forceSetAncestorVisibilityOperationActive = false;
                            this.mapService.setVisibility(visible && this.allAncestorsVisible && (this.inActiveTheme.get() || this.mapService.isUserCreated));
                        };
                        /**
                         * Updates inActiveTheme when it changes in the underlying geocortex map service (if available)
                         */
                        LayerListMapServiceItem.prototype.bindToActiveTheme = function () {
                            var _this = this;
                            _super.prototype.bindToActiveTheme.call(this);
                            this._themeSyncHandle = dojo.subscribe("MapServiceInActiveThemeChangedEvent", function (sender) {
                                if (sender && sender === _this.mapService.gcxMapService) {
                                    _this.inActiveTheme.set(sender.inActiveTheme);
                                }
                            });
                        };
                        /**
                         * Removes the binding to the active theme
                         */
                        LayerListMapServiceItem.prototype.unbindFromActiveTheme = function () {
                            _super.prototype.unbindFromActiveTheme.call(this);
                            if (this._themeSyncHandle) {
                                dojo.unsubscribe(this._themeSyncHandle);
                            }
                            this._themeSyncHandle = null;
                        };
                        /**
                         * Remove any bindings and perform any necessary logic for item removal
                         */
                        LayerListMapServiceItem.prototype.cleanUp = function () {
                            _super.prototype.cleanUp.call(this);
                            if (this._layerVisibilityHandle) {
                                this._layerVisibilityHandle.remove();
                                this._layerVisibilityHandle = null;
                            }
                        };
                        /** @private */
                        LayerListMapServiceItem.prototype._subscribeEvents = function () {
                            var _this = this;
                            this._layerVisibilityHandle = this.mapService.serviceLayer.on("visibility-change", function (eventArgs) {
                                if ((_this._deferredVisibilitySetting == undefined) && (_this.isEffectivelyVisible.get() === eventArgs.visible)) {
                                    // If this layer is in the active theme, we're good. Return. Or if the effective visibility = intended visibility is false we're good.
                                    // However, if intended visibility is true and we're not currently in the active theme, we shouldn't return, because we need to set visibility to false.
                                    if (!_this.isEffectivelyVisible.get() || (_this.inActiveTheme.get() || _this.mapService.isUserCreated)) {
                                        return;
                                    }
                                }
                                var computedVisibility = eventArgs.visible && (_this.inActiveTheme.get() || _this.mapService.isUserCreated);
                                _this.isVisible.set(computedVisibility);
                            });
                        };
                        /** @private */
                        LayerListMapServiceItem.prototype._setupIconUri = function () {
                            if (this.mapService.serviceLayer.loadError && this.layerList.serviceLoadFailureIconUri) {
                                this.iconUri.set(this.layerList.serviceLoadFailureIconUri);
                                this.iconTooltip.set(this.layerList.serviceLoadFailureIconTooltip ? this.layerList.serviceLoadFailureIconTooltip : "");
                            }
                            else if (this.mapService.gcxMapService && this.mapService.gcxMapService.iconUri) {
                                this.iconUri.set(this.mapService.gcxMapService.iconUri);
                                this.iconTooltip.set(this.name.get());
                            }
                        };
                        LayerListMapServiceItem.prototype._syncChildVisibilitiesIfApplicable = function (visible) {
                            var _this = this;
                            switch (this.mapService.serviceType) {
                                case geocortex.essentials.MapServiceType.BING:
                                case geocortex.essentials.MapServiceType.TILED:
                                case geocortex.essentials.MapServiceType.WMTS:
                                case geocortex.essentials.MapServiceType.IMAGE:
                                case geocortex.essentials.MapServiceType.WEBTILED:
                                    // GVH-5189: Ensure that all children visibilities are synchronized with the parent mapService
                                    if (this.children.length() > 0) {
                                        var descendants = this.getDescendants();
                                        descendants.forEach(function (item) {
                                            // Ensure only sub lyers of the mapService are synchronized and not any random stuff added under the mapService
                                            if ((item.type === infrastructure.layerList.LayerListItemType.LAYER) && (item.mapService.id === _this.mapService.id)) {
                                                if (item.isVisible.get() !== visible) {
                                                    item.isVisible.set(visible);
                                                }
                                            }
                                        });
                                    }
                                    break;
                                default:
                                    return;
                            }
                        };
                        /**
                         * @private
                         * Sets up bindings.
                         */
                        LayerListMapServiceItem.prototype._setupBindings = function () {
                            var _this = this;
                            if (this.mapService.gcxMapService) {
                                this.bindToActiveTheme();
                            }
                            if (!this.mapService.serviceLayer.loaded && !this.mapService.serviceLayer.loadError) {
                                var _layerOnLoadToken = null, _layerOnErrorToken = null;
                                var _disconnectLayerEvents = function () {
                                    _layerOnLoadToken && dojo.disconnect(_layerOnLoadToken);
                                    _layerOnErrorToken && dojo.disconnect(_layerOnErrorToken);
                                    _layerOnLoadToken = _layerOnErrorToken = null;
                                };
                                _layerOnLoadToken = dojo.connect(this.mapService.serviceLayer, "onLoad", function () {
                                    _disconnectLayerEvents();
                                    _this._setupIconUri();
                                });
                                _layerOnErrorToken = dojo.connect(this.mapService.serviceLayer, "onError", function () {
                                    _disconnectLayerEvents();
                                    _this._setupIconUri();
                                });
                            }
                            else {
                                this._setupIconUri();
                            }
                            if (!this.mapService.serviceLayer.loaded && !this.mapService.serviceLayer.loadError) {
                                var loadHandle = this.mapService.serviceLayer.on("load", function () {
                                    _this._updateVisibilityAtCurrentScale();
                                    loadHandle.remove();
                                });
                            }
                            if (!this.mapService.serviceLayer.getMap()) {
                                var layerAddHandle = this.layerList.appInfo.map.on("layer-add", function (event) {
                                    if (event.layer === _this.mapService.serviceLayer) {
                                        _this._updateVisibilityAtCurrentScale();
                                        layerAddHandle.remove();
                                    }
                                });
                            }
                            this._updateVisibilityAtCurrentScale();
                            this.mapService.serviceLayer.on("scale-visibility-change", function () { return _this._updateVisibilityAtCurrentScale(); });
                        };
                        /**
                         * For KML map services only. Called when the KML service layer is loaded.
                         * @param kmlLayer The newly-loaded KML layer.
                         */
                        LayerListMapServiceItem.prototype._kmlLayerLoadHandler = function (kmlLayer) {
                            // Create layer list sub-items corresponding to folders in the KML. These folders
                            // only exist in the viewer's layer list; they are not part of the configured layer list 
                            // model in Essentials.
                            if (kmlLayer.folders && kmlLayer.folders.length > 1) {
                                this._createKmlFolders(this, kmlLayer.folders[1], kmlLayer);
                                this.refreshOnDemandItemCollection();
                            }
                        };
                        /**
                         * Recursively creates KML folder layer list items from folders defined in a KML service.
                         * @param item The layer list item to add the folder to.
                         * @param folder The {@link esri.layers.KMLFolder} object representing the folder to add.
                         * @param kmlLayer The root {@link esri.layers.KMLLayer} object that owns the folder.
                         */
                        LayerListMapServiceItem.prototype._createKmlFolders = function (item, folder, kmlLayer) {
                            var allFolders = kmlLayer.folders;
                            for (var i = 0; i < folder.subFolderIds.length; i++) {
                                var subFolderID = folder.subFolderIds[i];
                                var subFolder = null;
                                for (var j = 0; j < allFolders.length; j++) {
                                    if (allFolders[j].id === subFolderID) {
                                        subFolder = allFolders[j];
                                        break;
                                    }
                                }
                                if (!subFolder) {
                                    // This should never be reached, unless the KMLLayer's folder graph is invalid.
                                    throw new Error("Could not find KML folder with ID '{0}'.".format(subFolderID));
                                }
                                var subFolderItem = new infrastructure.layerList.LayerListKmlFolderItem(this.mapService.id + subFolderID, this.layerList, kmlLayer, subFolder);
                                this._createKmlFolders(subFolderItem, subFolder, kmlLayer);
                                item.children.addItem(subFolderItem);
                            }
                        };
                        LayerListMapServiceItem.prototype._updateVisibilityAtCurrentScale = function () {
                            // The the "visibleAtMapScale" property only has a meaningful value when the service layer is both loaded and added to the map.
                            if (this.mapService.serviceLayer.loaded && this.mapService.serviceLayer.getMap()) {
                                this.inVisibleScaleRange.set(this.mapService.serviceLayer.visibleAtMapScale);
                            }
                        };
                        /**
                         * Set up the descriptive tooltips to include the name of the layer and to state whether the layer is in visible range.
                         * This is done for WCAG purposes.
                         */
                        LayerListMapServiceItem.prototype._setTooltips = function () {
                            _super.prototype._setTooltips.call(this);
                            // Loading language strings only supported within Geocortex. There's no such thing in Esri WAB! 
                            var geocortexApp = this.layerList.appInfo.gcxApp;
                            if (geocortexApp) {
                                var mapServiceActionsTooltipDescription = geocortexApp.getResource(this.layerList._libraryId, "language-mapservice-actions-tooltip").format(this.name.get());
                                this.mapServiceActionsTooltip.set(mapServiceActionsTooltipDescription);
                            }
                        };
                        return LayerListMapServiceItem;
                    }(layerList_7.LayerListItem));
                    layerList_7.LayerListMapServiceItem = LayerListMapServiceItem;
                })(layerList = infrastructure.layerList || (infrastructure.layerList = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts"/>
/// <reference path="../../../_Definitions/essentials.d.ts"/>
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../Viewer.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var gis;
                (function (gis) {
                    var GisUtils;
                    (function (GisUtils) {
                        function getServiceLayerType(serviceLayer) {
                            // Dynamic map services
                            if (serviceLayer instanceof esri.layers.DynamicMapServiceLayer) {
                                if (serviceLayer instanceof esri.layers.ArcGISDynamicMapServiceLayer) {
                                    return geocortex.essentials.MapServiceType.DYNAMIC;
                                }
                                if (serviceLayer instanceof esri.layers.ArcGISImageServiceLayer) {
                                    return geocortex.essentials.MapServiceType.IMAGE;
                                }
                                if (serviceLayer instanceof esri.layers.WMSLayer) {
                                    return geocortex.essentials.MapServiceType.WMS;
                                }
                                return geocortex.essentials.MapServiceType.DYNAMIC;
                            }
                            // Tiled map services
                            if (serviceLayer instanceof esri.layers.TiledMapServiceLayer) {
                                if (serviceLayer instanceof esri.layers.WMTSLayer) {
                                    return geocortex.essentials.MapServiceType.WMTS;
                                }
                                if (serviceLayer instanceof esri.layers.WebTiledLayer) {
                                    return geocortex.essentials.MapServiceType.WEBTILED;
                                }
                                if (serviceLayer instanceof esri.virtualearth.VETiledLayer) {
                                    return geocortex.essentials.MapServiceType.BING;
                                }
                                return geocortex.essentials.MapServiceType.TILED;
                            }
                            // Graphics layers
                            if (serviceLayer instanceof esri.layers.GraphicsLayer) {
                                if (serviceLayer instanceof esri.layers.FeatureLayer) {
                                    if (esri.layers.StreamLayer && serviceLayer instanceof esri.layers.StreamLayer) {
                                        return geocortex.essentials.MapServiceType.STREAM;
                                    }
                                    if (serviceLayer instanceof esri.layers.CSVLayer) {
                                        return geocortex.essentials.MapServiceType.CSV;
                                    }
                                    return geocortex.essentials.MapServiceType.FEATURE;
                                }
                                if (esri.layers.LabelLayer && serviceLayer instanceof esri.layers.LabelLayer) {
                                    return geocortex.essentials.MapServiceType.LABEL;
                                }
                                return geocortex.essentials.MapServiceType.GRAPHICS;
                            }
                            // GeoRSS Layers
                            if (serviceLayer instanceof esri.layers.GeoRSSLayer) {
                                return geocortex.essentials.MapServiceType.GEORSS;
                            }
                            // XML Layers
                            if (serviceLayer instanceof esri.layers.KMLLayer) {
                                return geocortex.essentials.MapServiceType.KML;
                            }
                            // MapImage Layers
                            if (serviceLayer instanceof esri.layers.MapImageLayer) {
                                return geocortex.essentials.MapServiceType.MAPIMAGE;
                            }
                            // If it gets here, which it never should, we'll return unknown. This will either indicate a problem
                            // or that we haven't updated to include the latest layers introduced by Esri.
                            return geocortex.essentials.MapServiceType.UNKNOWN;
                        }
                        GisUtils.getServiceLayerType = getServiceLayerType;
                    })(GisUtils = gis.GisUtils || (gis.GisUtils = {}));
                })(gis = infrastructure.gis || (infrastructure.gis = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../_Definitions/framework.d.ts"/>
/// <reference path="../../_Definitions/arcgis-js-api.d.ts"/>
/// <reference path="../../_Definitions/dojo.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var SymbolUtils;
                (function (SymbolUtils) {
                    /**
                     * Default color scheme for the symbols.
                     * Not exported so it's private.
                     */
                    var _defaultSymbolColor = {
                        r: 204,
                        g: 51,
                        b: 51,
                        a: 1
                    };
                    /**
                     * Returns default color. If any modifications are provided, we will return a color with those modifications made
                     * @param {Object} [options] modifications to make to the default color
                     * @return {dojo.Color}
                     */
                    function defaultSymbolColor(options) {
                        // If we weren't given any options, just set a blank object, and we'll use the default color
                        if (!options) {
                            options = {};
                        }
                        var colorDef = {
                            a: options.a ? options.a : _defaultSymbolColor.a,
                            r: options.r ? options.r : _defaultSymbolColor.r,
                            g: options.g ? options.g : _defaultSymbolColor.g,
                            b: options.b ? options.b : _defaultSymbolColor.b
                        };
                        return new dojo.Color(colorDef);
                    }
                    SymbolUtils.defaultSymbolColor = defaultSymbolColor;
                    /**
                     * Returns the ESRI default marker symbol
                     */
                    function defaultMarkerSymbol() {
                        return new esri.symbol.SimpleMarkerSymbol(esri.symbol.SimpleMarkerSymbol.STYLE_CIRCLE, 14, null, this.defaultSymbolColor());
                    }
                    SymbolUtils.defaultMarkerSymbol = defaultMarkerSymbol;
                    /**
                     * Returns the ESRI default line symbol
                     */
                    function defaultLineSymbol() {
                        return new esri.symbol.SimpleLineSymbol(esri.symbol.SimpleLineSymbol.STYLE_SOLID, this.defaultSymbolColor({ a: 0.8 }), 2);
                    }
                    SymbolUtils.defaultLineSymbol = defaultLineSymbol;
                    /**
                     * Returns the ESRI default fill symbol
                     */
                    function defaultFillSymbol() {
                        return new esri.symbol.SimpleFillSymbol(esri.symbol.SimpleFillSymbol.STYLE_SOLID, this.defaultLineSymbol(), this.defaultSymbolColor({ a: 0.5 }));
                    }
                    SymbolUtils.defaultFillSymbol = defaultFillSymbol;
                    /**
                     * Returns the ESRI default text symbol
                     */
                    function defaultTextSymbol() {
                        var text = new esri.symbol.TextSymbol("");
                        var font = new esri.symbol.Font();
                        font.setSize("14pt");
                        font.setFamily("Arial");
                        text.setFont(font);
                        text.setAlign(esri.symbol.TextSymbol.ALIGN_START);
                        return text;
                    }
                    SymbolUtils.defaultTextSymbol = defaultTextSymbol;
                })(SymbolUtils = infrastructure.SymbolUtils || (infrastructure.SymbolUtils = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/Framework.d.ts"/>
/// <reference path="../CommandViewModel.ts"/>
/// <reference path="MenuItemModel.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var menus;
                (function (menus) {
                    /**
                     * A general purpose, reusable and loosely coupled view model representing a menu item within a menu view model.
                     */
                    var MenuItemViewModel = (function () {
                        /**
                        * Initializes a new instance of the MenuItemViewModel class.
                        * @param menuVm The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuViewModel} that this MenuItemViewModel is a memeber of.
                        * @param menuItem The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuItemModel} for this MenuItemViewModel.
                        */
                        function MenuItemViewModel(menuVm, menuItem) {
                            this._canExecuteChangedBindingTokens = [];
                            this._contextPropertyBindingTokens = {};
                            if (!menus.MenuViewModel || !menuItem) {
                                throw new Error("MenuViewModel: Could not create menu view model. Input arguments cannot be undefined.");
                            }
                            this.menuViewModel = menuVm;
                            this.menuItem = menuItem;
                            this.app = menuItem.app;
                            this.text = new Observable(menuItem.text);
                            this.description = new Observable(menuItem.description);
                            this.canExecute = new Observable(this.computeCanExecute());
                            this.iconUri = new Observable(menuItem.iconUri);
                            this._setupBindings();
                        }
                        /**
                         * Execute this menu item if it can be executed. Could be a simple menu item or multiple batch menu items.
                         */
                        MenuItemViewModel.prototype.execute = function () {
                            var _this = this;
                            if (!this.computeCanExecute()) {
                                return;
                            }
                            if (this.menuItem.command) {
                                this.menuItem.command.execute(MenuItemViewModel._computeCommandParameter(this, this.menuItem.commandParameter));
                            }
                            else {
                                this.menuItem.batchItems
                                    .forEach(function (item) { return item.command.execute(MenuItemViewModel._computeCommandParameter(_this, item.commandParameter)); });
                            }
                        };
                        /**
                         * Returns the canExecute status of the related menuItem in real time.
                         * @return A boolean which returns true if the menu item backing this menu item view model can be executed.
                         */
                        MenuItemViewModel.prototype.computeCanExecute = function () {
                            if (this.menuItem.batchItems && this.menuItem.batchItems.length) {
                                var canExecuteBatch = !!this.menuItem.batchItems.length;
                                for (var i = 0; i < this.menuItem.batchItems.length; i++) {
                                    var batchItem = this.menuItem.batchItems[i];
                                    // If abortBatchOnFailure is false, then dont bother checking the canExecute. If true, the item needs to be executable in order for the batch to execute
                                    if (canExecuteBatch && batchItem.abortBatchOnFailure) {
                                        canExecuteBatch = batchItem.command && batchItem.command.canExecute(MenuItemViewModel._computeCommandParameter(this, batchItem.commandParameter));
                                    }
                                }
                                return canExecuteBatch;
                            }
                            else {
                                return this.menuItem.command && this.menuItem.command.canExecute(MenuItemViewModel._computeCommandParameter(this, this.menuItem.commandParameter));
                            }
                        };
                        /**
                        * Re-computes and resets the canExecute observable for this MenuItemViewModel.
                        */
                        MenuItemViewModel.prototype.refreshCanExecute = function () {
                            var canExecuteCommand = this.computeCanExecute();
                            if (this.canExecute.get() === canExecuteCommand) {
                                return;
                            }
                            this.canExecute.set(canExecuteCommand);
                        };
                        /**
                         * Unsubscribes from subscriptions and bindings tracked by this MenuItemViewModel
                         */
                        MenuItemViewModel.prototype.destroy = function () {
                            for (var x = (this._canExecuteChangedBindingTokens.length - 1); x >= 0; x--) {
                                var bindingInfo = this._canExecuteChangedBindingTokens[x];
                                bindingInfo.canExecuteEvent.unsubscribe(bindingInfo.token);
                                this._canExecuteChangedBindingTokens.pop();
                            }
                            for (var prop in this._contextPropertyBindingTokens) {
                                if (!this._contextPropertyBindingTokens.hasOwnProperty(prop)) {
                                    continue;
                                }
                                var menuContext = this.menuViewModel.menuContext.get();
                                menuContext[prop] && menuContext[prop].unbind(this._contextPropertyBindingTokens[prop]);
                            }
                            this._contextPropertyBindingTokens = null;
                            this._canExecuteChangedBindingTokens = null;
                        };
                        /**
                         * Sets up the canExecute changed bindings for both simple and batch menu items so the menu can update it's state automatically
                         */
                        MenuItemViewModel.prototype._setupBindings = function () {
                            var _this = this;
                            var registerEventSubscription = function (cmd) {
                                if (cmd) {
                                    _this._canExecuteChangedBindingTokens.push({
                                        canExecuteEvent: cmd.canExecuteChanged,
                                        token: cmd.canExecuteChanged.subscribe(_this, _this.refreshCanExecute)
                                    });
                                }
                            };
                            if (this.menuItem.batchItems && this.menuItem.batchItems.length) {
                                this.menuItem.batchItems.forEach(function (item) {
                                    registerEventSubscription(item.command);
                                });
                            }
                            else {
                                registerEventSubscription(this.menuItem.command);
                            }
                        };
                        /**
                        * Static function that omputes a command parameter to pass to a menu item.
                        * @param menuItemVm The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuItemViewModel} that's requesting the parameter to be resolved.
                        * @param parameter The parameter to resolve against the menu context.
                        * @return An object or string representing the resolved command parameter.
                        */
                        MenuItemViewModel._computeCommandParameter = function (menuItemVm, parameter) {
                            var menuContext = menuItemVm.menuViewModel.menuContext.get();
                            var resolveStringParam = function (param) {
                                var key = param.trim();
                                // If the string has {{ and }} in it we'll replace it wholesale, discarding any extra.
                                if (!(key.indexOf("{{") === 0 && key.indexOf("}}") > 0)) {
                                    return key;
                                }
                                else {
                                    key = key.replace("{{", "").replace("}}", "");
                                    // If the key matches the default parameter name, it refers to the menu context itself.
                                    if (key.toLowerCase() === menus.MenuViewModel.DefaultParameterName.toLowerCase()) {
                                        return menuContext;
                                    }
                                    else if (!menuContext || typeof menuContext[key] === "undefined") {
                                        menuItemVm.app.trace.warning("Could not find menu item '{0}'.".format(key));
                                        return null;
                                    }
                                    else {
                                        if (menuContext[key].isObservable) {
                                            if (menuItemVm._contextPropertyBindingTokens[key]) {
                                                menuContext[key].unbind(menuItemVm._contextPropertyBindingTokens[key]);
                                            }
                                            menuItemVm._contextPropertyBindingTokens[key] = menuContext[key].once(menuItemVm, menuItemVm.refreshCanExecute);
                                        }
                                        return menuContext[key];
                                    }
                                }
                            };
                            // If the menu item has no command parameter, the menu context itself is passed.
                            if (parameter === null || typeof parameter === "undefined") {
                                return menuContext;
                            }
                            // If the menu item has a string configured as a command parameter, resolve and return it immediately.
                            if (typeof parameter === "string") {
                                return resolveStringParam(parameter);
                            }
                            // If the menu item has a `commandParameter` that's an object, and the menu context is complex, populate command parameter tokens.
                            if (menuContext && parameter && typeof parameter === "object") {
                                var populatedParameter = {};
                                for (var prop in parameter) {
                                    if (!parameter.hasOwnProperty(prop)) {
                                        continue;
                                    }
                                    var obj = parameter[prop];
                                    if (typeof obj === "string") {
                                        populatedParameter[prop] = resolveStringParam(obj);
                                    }
                                    else {
                                        populatedParameter[prop] = obj;
                                    }
                                }
                                return populatedParameter;
                            }
                            return parameter;
                        };
                        return MenuItemViewModel;
                    }());
                    menus.MenuItemViewModel = MenuItemViewModel;
                })(menus = infrastructure.menus || (infrastructure.menus = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/framework.d.ts"/>
/// <reference path="./MenuModel.ts"/>
/// <reference path="./MenuRegistry.ts"/>
/// <reference path="./MenuItemViewModel.ts"/>
/// <reference path="../CommandViewModel.ts"/>
/// <reference path="../../Viewer.ts"/>
var geocortex;
(function (geocortex) {
    var essentialsHtmlViewer;
    (function (essentialsHtmlViewer) {
        var mapping;
        (function (mapping) {
            var infrastructure;
            (function (infrastructure) {
                var menus;
                (function (menus) {
                    /**
                     * A generic and flexible menu view that binds to configured menus of commands and provides functionality to hide and show menu items
                     * conditionally based on the `canExecute` status of the bound commands.
                     */
                    var MenuView = (function (_super) {
                        __extends(MenuView, _super);
                        function MenuView() {
                            _super.apply(this, arguments);
                        }
                        /** @inherited */
                        MenuView.prototype.attach = function (viewModel) {
                            var libraryId = this.configuration.libraryId || viewModel.libraryId || this.libraryId;
                            // The proper pattern to create menu's is to attach a 'MenuViewModel' to the 'MenuView'.
                            // If a non 'MenuViewModel' object is passed in, we'll convert it into a 'MenuViewModel' object before attaching it.
                            if (viewModel instanceof menus.MenuViewModel === false) {
                                var menuViewModel = new menus.MenuViewModel(this.app, libraryId);
                                menuViewModel.menuContext.set(viewModel);
                                viewModel = menuViewModel;
                            }
                            this.viewModel = viewModel;
                            if (this.viewModel && !this.viewModel.menuId) {
                                this.viewModel.menuId = (this.configuration && this.configuration.menuId) || null;
                            }
                            // Menu setup is invoked here vs. in the view model, so all other view models in the system have had a chance to register their menus with the registry
                            this.viewModel.setupMenu();
                            if (!this.viewModel || !this.viewModel.menuId) {
                                this.app.trace.warning("Could not set up menu view '{0}'. View model or 'menuId' option not found.".format(this.id));
                                return;
                            }
                            this.title.set(this.getResource("language-menu-default-title"));
                            _super.prototype.attach.call(this, viewModel);
                        };
                        /**
                         * Handles the click event of individual menu items.
                         * @param evt The event.
                         * @param element The element associated with this event.
                         * @param menuItem The menu item that was clicked.
                         */
                        MenuView.prototype.handleMenuItemClick = function (event, element, menuItem) {
                            if (menuItem) {
                                this.app.event("MenuItemInvokedEvent").publish({
                                    menuView: this,
                                    menuId: this.viewModel.menuId,
                                    menuItem: menuItem
                                });
                                menuItem.execute();
                            }
                        };
                        /**
                        * Handle showing the description, if the context has one.
                        * @param evt The event.
                        * @param element The element associated with this event.
                        * @param context The context related to this event.
                        */
                        MenuView.prototype.getDescription = function (event, element, context) {
                            if (context.description) {
                                element.title = context.description.get();
                            }
                        };
                        /**
                         * Destroy associated widget view model and bindings when this menu view is destroyed
                         */
                        MenuView.prototype.onDestroy = function () {
                            _super.prototype.onDestroy.call(this);
                            this.app.menuRegistry.destroyMenuWidget(this);
                        };
                        return MenuView;
                    }(geocortex.framework.ui.ViewBase));
                    menus.MenuView = MenuView;
                })(menus = infrastructure.menus || (infrastructure.menus = {}));
            })(infrastructure = mapping.infrastructure || (mapping.infrastructure = {}));
        })(mapping = essentialsHtmlViewer.mapping || (essentialsHtmlViewer.mapping = {}));
    })(essentialsHtmlViewer = geocortex.essentialsHtmlViewer || (geocortex.essentialsHtmlViewer = {}));
})(geocortex || (geocortex = {}));

/* End Script: mapping.infrastructure_ts_out.js ------------------------- */ 


/* Begin Script: globals.js ------------------------- */ 

// dojo.require("geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetManager");
// dojo.require("geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureAttribute");
// dojo.require("geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature");
// dojo.require("geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSet");
// dojo.require("geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection");


// Global aliases.
var Feature = null;
var FeatureSet = null;
var FeatureSetCollection = null;

dojo.ready(function () {

    // Initialize gloal aliases.
    FeatureAttribute = dojo.getObject("geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureAttribute");
    Feature = dojo.getObject("geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature");
    FeatureSet = dojo.getObject("geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSet");
    FeatureSetCollection = dojo.getObject("geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection");
});

/* End Script: globals.js ------------------------- */ 


/* Begin Script: version.js ------------------------- */ 
if (!geocortex) geocortex = { }; 
if (!geocortex.essentialsHtmlViewer) geocortex.essentialsHtmlViewer = { }; 
geocortex.essentialsHtmlViewer.version = "2.8.0.0003"; 

/* End Script: version.js ------------------------- */ 

geocortex.resourceManager.register("Mapping.Infrastructure","inv","Mapping/infrastructure/documents/GrantEditorView.html","html","PGRpdiBjbGFzcz0iZ3JhbnQtZWRpdG9yIj4NCiAgICA8ZGl2IGNsYXNzPSJncmFudC1lZGl0b3Itb3B0aW9ucyI+DQogICAgICAgIDxkaXYgY2xhc3M9ImdyYW50LWVkaXRvci1zZWFyY2gtb3B0aW9ucyI+DQogICAgICAgICAgICA8c2VsZWN0IGRhdGEtYmluZGluZz0ie0BlbmFibGVkOiBlbmFibGVkfXtAc291cmNlOiBtb25pa2VyS2luZHN9e0B2YWx1ZTogc2VsZWN0ZWRNb25pa2VyS2luZH0iPg0KICAgICAgICAgICAgICAgIDxvcHRpb24gZGF0YS1iaW5kaW5nPSJ7QHRlbXBsYXRlLWZvcjogbW9uaWtlcktpbmRzfXtAdGV4dDogZGlzcGxheU5hbWV9e3ZhbHVlOiBraW5kfSIgLz4NCiAgICAgICAgICAgIDwvc2VsZWN0Pg0KICAgICAgICAgICAgPGlucHV0IGNsYXNzPSJncmFudC1lZGl0b3Itc2VhcmNoIiB0eXBlPSJ0ZXh0IiBkYXRhLWJpbmRpbmc9IntAZW5hYmxlZDogZW5hYmxlZH17QHZhbHVlOiBzZWFyY2hUZXh0fXtAdmFyOiBhdXRvQ29tcGxldGVJbnB1dH17QGV2ZW50LW9uaW5wdXQ6IGhhbmRsZUlucHV0Q2hhbmdlZH17cGxhY2Vob2xkZXI6IEBsYW5ndWFnZS1ncmFudC1lZGl0b3Itc2VhcmNoLXBsYWNlaG9sZGVyfXt0aXRsZTogQGxhbmd1YWdlLWdyYW50LWVkaXRvci1zZWFyY2gtdGl0bGV9e0BldmVudC1ibHVyOiBoYW5kbGVBdXRvQ29tcGxldGVCbHVyfSIgLz4NCiAgICAgICAgPC9kaXY+DQogICAgICAgIDxkaXYgY2xhc3M9ImZvcm0tYnRucyI+DQogICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJidXR0b24gYWRkLWJ1dHRvbiIgZGF0YS1iaW5kaW5nPSJ7QGVuYWJsZWQ6IGlzVmFsaWRNb25pa2VyfXt0aXRsZTogQGxhbmd1YWdlLWdyYW50LWVkaXRvci1hZGQtYnV0dG9uLXRpdGxlfXtAdGV4dDogQGxhbmd1YWdlLWdyYW50LWVkaXRvci1hZGQtYnV0dG9uLXRleHR9e0BldmVudC1vbmNsaWNrOiBoYW5kbGVBZGRNb25pa2VyQnV0dG9uQ2xpY2t9Ij48L2J1dHRvbj4NCiAgICAgICAgPC9kaXY+DQogICAgPC9kaXY+DQogICAgPGRpdiBjbGFzcz0iZ3JhbnQtZWRpdG9yLXRhYmxlIj4NCiAgICAgICAgPHRhYmxlPg0KICAgICAgICAgICAgPHRoZWFkPg0KICAgICAgICAgICAgICAgIDx0cj4NCiAgICAgICAgICAgICAgICAgICAgPHRoPjwvdGg+DQogICAgICAgICAgICAgICAgICAgIDx0aCBkYXRhLWJpbmRpbmc9IntAdGV4dDogQGxhbmd1YWdlLWdyYW50LWVkaXRvci10YWJsZS1oZWFkZXItbm9uZX0iPjwvdGg+DQogICAgICAgICAgICAgICAgICAgIDx0aCBkYXRhLWJpbmRpbmc9IntAdGV4dDogQGxhbmd1YWdlLWdyYW50LWVkaXRvci10YWJsZS1oZWFkZXItdmlld30iPjwvdGg+DQogICAgICAgICAgICAgICAgICAgIDx0aCBkYXRhLWJpbmRpbmc9IntAdGV4dDogQGxhbmd1YWdlLWdyYW50LWVkaXRvci10YWJsZS1oZWFkZXItZWRpdH0iPjwvdGg+DQogICAgICAgICAgICAgICAgPC90cj4NCiAgICAgICAgICAgIDwvdGhlYWQ+DQogICAgICAgICAgICA8dGJvZHkgZGF0YS1iaW5kaW5nPSJ7QHNvdXJjZTogbW9uaWtlcnN9Ij4NCiAgICAgICAgICAgICAgICA8dHIgZGF0YS1iaW5kaW5nPSJ7QHRlbXBsYXRlLWZvcjogbW9uaWtlcnN9e0BjbGFzcy1nbG9iYWwtZ3JhbnQ6IGlzR2xvYmFsfXtAY2xhc3MtZGlzYWJsZWQtZ3JhbnQ6IGlzUmV2b2tlZH0iPg0KICAgICAgICAgICAgICAgICAgICA8dGQgY2xhc3M9ImdyYW50LW5hbWUtY29sdW1uIj4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgZGF0YS1iaW5kaW5nPSJ7c3JjOiBpY29uVXJpfSIgLz4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJncmFudC1uYW1lLWxhYmVsIiBkYXRhLWJpbmRpbmc9IntAdGV4dDogbmFtZX0iPjwvc3Bhbj4NCiAgICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICAgICAgPHRkPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9InJhZGlvIiBkYXRhLWJpbmRpbmc9IntAZW5hYmxlZDogZW5hYmxlZH17bmFtZTogaWR9e2NoZWNrZWQ6IGlzR2xvYmFsfXtAZXZlbnQtb25jbGljazogaGFuZGxlVXBkYXRlTW9uaWtlcn0iIC8+DQogICAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPSJyYWRpbyIgdmFsdWU9InJlYWRlciIgZGF0YS1iaW5kaW5nPSJ7QGVuYWJsZWQ6IGVuYWJsZWR9e25hbWU6IGlkfXtjaGVja2VkOiBjYW5SZWFkfXtAZXZlbnQtb25jbGljazogaGFuZGxlVXBkYXRlTW9uaWtlcn0iIC8+DQogICAgICAgICAgICAgICAgICAgIDwvdGQ+DQogICAgICAgICAgICAgICAgICAgIDx0ZD4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPSJyYWRpbyIgdmFsdWU9IndyaXRlciIgZGF0YS1iaW5kaW5nPSJ7QGVuYWJsZWQ6IGVuYWJsZWR9e0BoaWRkZW46IGlzUHVibGljfXtuYW1lOiBpZH17Y2hlY2tlZDogY2FuV3JpdGV9e0BldmVudC1vbmNsaWNrOiBoYW5kbGVVcGRhdGVNb25pa2VyfSIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgICAgICA8L3RyPg0KICAgICAgICAgICAgPC90Ym9keT4NCiAgICAgICAgPC90YWJsZT4NCiAgICA8L2Rpdj4NCjwvZGl2Pg0K");
geocortex.resourceManager.register("Mapping.Infrastructure","inv","Mapping/infrastructure/menus/IconMenuView.html","html","PGRpdiBjbGFzcz0ibWVudS1uby1pdGVtcyIgZGF0YS1iaW5kaW5nPSJ7QGhpZGRlbjogdmlzaWJsZU1lbnVJdGVtc317QHRleHQ6IEBsYW5ndWFnZS1tZW51LW5vLWl0ZW1zfSI+PCEtLSBObyBJdGVtcy4gLS0+PC9kaXY+DQoNCjxkaXYgY2xhc3M9Imxpc3QtbWVudSBhY3RpdmUgaGFzLWljb24gaWNvbi1tZW51IiBkYXRhLWJpbmRpbmc9IntAdmlzaWJsZTogdmlzaWJsZU1lbnVJdGVtc317QHNvdXJjZTogdmlzaWJsZU1lbnVJdGVtc30iPg0KICAgIDxkaXYgY2xhc3M9Imxpc3QtbWVudS1pdGVtIiBkYXRhLWJpbmRpbmc9IntAdGVtcGxhdGUtZm9yOiB2aXNpYmxlTWVudUl0ZW1zfXtAZW5hYmxlZDogY2FuRXhlY3V0ZX17QGV2ZW50LW9uY2xpY2s6IGhhbmRsZU1lbnVJdGVtQ2xpY2t9Ij4NCiAgICAgICAgPGJ1dHRvbiBjbGFzcz0ibGlzdC1tZW51LWRldGFpbHMiIGRhdGEtYmluZGluZz0ie0BldmVudC1vbmNsaWNrOiBoYW5kbGVNZW51SXRlbUNsaWNrfXt0aXRsZTogZGVzY3JpcHRpb259Ij4NCiAgICAgICAgICAgIDxpbWcgY2xhc3M9Imxpc3QtbWVudS1pY29uIiBkYXRhLWJpbmRpbmc9IntAdmlzaWJsZTogaWNvblVyaX17c3JjOiBpY29uVXJpfSIgYWx0PSIgIiAvPg0KICAgICAgICAgICAgPHN0cm9uZyBjbGFzcz0ibGlzdC1tZW51LW5hbWUiIGRhdGEtYmluZGluZz0ie0B0ZXh0OiB0ZXh0fSI+PC9zdHJvbmc+DQogICAgICAgIDwvYnV0dG9uPg0KICAgIDwvZGl2Pg0KPC9kaXY+DQo=");
geocortex.resourceManager.register("Mapping.Infrastructure","inv","Mapping/infrastructure/menus/MenuHyperlinkView.html","html","PGRpdiBjbGFzcz0ibWVudS1oeXBlcmxpbmtzIj4NCiAgICA8dWwgY2xhc3M9Imxpc3QtbWVudSBhY3RpdmUiIGRhdGEtYmluZGluZz0ie0B2aXNpYmxlOiB2aXNpYmxlTWVudUl0ZW1zfXtAc291cmNlOiB2aXNpYmxlTWVudUl0ZW1zfSI+DQogICAgICAgIDxsaSBjbGFzcz0ibGlzdC1tZW51LWl0ZW0iIGRhdGEtYmluZGluZz0ie0B0ZW1wbGF0ZS1mb3I6IHZpc2libGVNZW51SXRlbXN9Ij4NCiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9Imxpc3QtbWVudS1idXR0b24iIGRhdGEtYmluZGluZz0ie3RpdGxlOiBkZXNjcmlwdGlvbn17QHRleHQ6IHRleHR9e0BldmVudC1vbmNsaWNrOiBoYW5kbGVNZW51SXRlbUNsaWNrfXtAZW5hYmxlZDogY2FuRXhlY3V0ZX0iPjwvYnV0dG9uPg0KICAgICAgICA8L2xpPg0KICAgIDwvdWw+DQo8L2Rpdj4NCg==");
geocortex.resourceManager.register("Mapping.Infrastructure","inv","Mapping/infrastructure/menus/MenuView.html","html","PGRpdiBjbGFzcz0ibWVudS1uby1pdGVtcyIgZGF0YS1iaW5kaW5nPSJ7QGhpZGRlbjogdmlzaWJsZU1lbnVJdGVtc317QHRleHQ6IEBsYW5ndWFnZS1tZW51LW5vLWl0ZW1zfSI+PCEtLSBObyBJdGVtcy4gLS0+PC9kaXY+DQoNCjxkaXYgY2xhc3M9Imxpc3QtbWVudSBhY3RpdmUgaGFzLWljb24iIGRhdGEtYmluZGluZz0ie0B2aXNpYmxlOiB2aXNpYmxlTWVudUl0ZW1zfXtAc291cmNlOiB2aXNpYmxlTWVudUl0ZW1zfSI+DQogICAgPGRpdiBjbGFzcz0ibGlzdC1tZW51LWl0ZW0iIGRhdGEtYmluZGluZz0ie0B0ZW1wbGF0ZS1mb3I6IHZpc2libGVNZW51SXRlbXN9e0BlbmFibGVkOiBjYW5FeGVjdXRlfXtAZXZlbnQtb25jbGljazogaGFuZGxlTWVudUl0ZW1DbGlja30iPg0KICAgICAgICA8aW1nIGNsYXNzPSJsaXN0LW1lbnUtaWNvbiIgZGF0YS1iaW5kaW5nPSJ7QHZpc2libGU6IGljb25Vcml9e3NyYzogaWNvblVyaX17YWx0OiB0ZXh0fSIgLz4NCiAgICAgICAgPGJ1dHRvbiBjbGFzcz0ibGlzdC1tZW51LWRldGFpbHMiIGRhdGEtYmluZGluZz0ie0BldmVudC1vbmNsaWNrOiBoYW5kbGVNZW51SXRlbUNsaWNrfXt0aXRsZTogZGVzY3JpcHRpb259Ij4NCiAgICAgICAgICAgIDxzdHJvbmcgY2xhc3M9Imxpc3QtbWVudS1uYW1lIiBkYXRhLWJpbmRpbmc9IntAdGV4dDogdGV4dH0iPjwvc3Ryb25nPg0KICAgICAgICAgICAgPHNwYW4gY2xhc3M9Imxpc3QtbWVudS1kZXNjIiBkYXRhLWJpbmRpbmc9IntAdmlzaWJsZTogZGVzY3JpcHRpb259e0B0ZXh0OiBkZXNjcmlwdGlvbn0iPjwvc3Bhbj4NCiAgICAgICAgPC9idXR0b24+DQogICAgPC9kaXY+DQo8L2Rpdj4NCg==");
geocortex.resourceManager.register("Mapping.Infrastructure","inv","Mapping/infrastructure/results/ResultsFeatureActionsView.html","html","PGRpdiBjbGFzcz0ibGlzdC1tZW51IiBkYXRhLWJpbmRpbmc9IntAc291cmNlOiBmZWF0dXJlQWN0aW9uc30iPg0KICAgIDxkaXYgY2xhc3M9Imxpc3QtbWVudS1pdGVtIiBkYXRhLWJpbmRpbmc9IntAdGVtcGxhdGUtZm9yOiBmZWF0dXJlQWN0aW9uc317QGV2ZW50LW9ubW91c2VvdmVyOiBoYW5kbGVHZXREZXNjcmlwdGlvbn17QGV2ZW50LW9uY2xpY2s6IGhhbmRsZU1lbnVJdGVtQ2xpY2t9Ij4NCiAgICAgICAgPGJ1dHRvbiBjbGFzcz0ibGlzdC1tZW51LWRldGFpbHMiPg0KICAgICAgICAgICAgPHN0cm9uZyBjbGFzcz0ibGlzdC1tZW51LW5hbWUiIGRhdGEtYmluZGluZz0ie0B0ZXh0OiB0ZXh0fSI+PC9zdHJvbmc+DQogICAgICAgICAgICA8c3BhbiBjbGFzcz0ibGlzdC1tZW51LWRlc2MiIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBkZXNjcmlwdGlvbn0iPjwvc3Bhbj4NCiAgICAgICAgPC9idXR0b24+DQogICAgPC9kaXY+DQo8L2Rpdj4NCg==");
geocortex.resourceManager.register("Mapping.Infrastructure","inv","Mapping/infrastructure/results/ResultsListView.html","html","PGRpdiBjbGFzcz0icmVzdWx0cy1saXN0LWFjdGlvbnMtd2lkZ2V0IiBkYXRhLWJpbmRpbmc9IntAdmlzaWJsZTogZmVhdHVyZVNldENvbGxlY3Rpb259e0B3aWRnZXQ6IFJlc3VsdHNMaXN0QWN0aW9uc1dpZGdldH17QHdpZGdldC1jb250ZXh0OiBmZWF0dXJlU2V0Q29sbGVjdGlvbn17QHdpZGdldC1yZXF1aXJlZDogZmFsc2V9IiBkYXRhLW1lbnUtaWQ9IlJlc3VsdHNMaXN0QWN0aW9ucyIgZGF0YS1tZW51LXRlbXBsYXRlPSJNYXBwaW5nL2luZnJhc3RydWN0dXJlL21lbnVzL01lbnVIeXBlcmxpbmtWaWV3Lmh0bWwiPjwvZGl2Pg0KDQo8ZGl2IGNsYXNzPSJyZXN1bHRzIj4NCiAgICA8IS0tIEJFR0lOOiBObyBSZXN1bHRzIC0tPg0KICAgIDxkaXYgY2xhc3M9Im5vLXJlc3VsdHMiIGRhdGEtYmluZGluZz0ie0BoaWRkZW46IGhhc0ZlYXR1cmVTZXRzfXtAdGV4dDogc2VhcmNoU3VnZ2VzdGlvbn0iIHRhYmluZGV4PSIwIj48L2Rpdj4NCiAgICA8IS0tIEVORDogTm8gUmVzdWx0cyAtLT4NCg0KICAgIDwhLS0gQkVHSU46IFJlc3VsdHMgTGlzdCAtLT4NCiAgICA8IS0tIElmIHRoZSBiZWxvdyAncmVzdWx0cy1saXN0JyBkaXYgaXMgdGFiYmFibGUsIHRoZW4gc2hpZnQrdGFiIGdldHMgc3R1Y2sgaW4gRmlyZUZveC4gLS0+DQogICAgPGRpdiBjbGFzcz0icmVzdWx0cy1saXN0IiBkYXRhLWJpbmRpbmc9IntAdmFyOiBzY3JvbGxDb250YWluZXJFbGVtZW50fXtAZXZlbnQtb25zY3JvbGw6IGhhbmRsZVNjcm9sbENoYW5nZX0iIHRhYmluZGV4PSItMSI+DQoNCiAgICAgICAgPGRpdiBjbGFzcz0ibGlzdC1tZW51IGFjdGl2ZSBoYXMtaWNvbiIgZGF0YS1iaW5kaW5nPSJ7QHNvdXJjZTogcmVzdWx0c1BhZ2V9e0B2aXNpYmxlOiByZXN1bHRzUGFnZX17QHZhcjogcmVzdWx0c0xpc3R9Ij4NCiAgICAgICAgICAgIDxkaXYgY2xhc3M9Imxpc3QtbWVudS1pdGVtIiBkYXRhLWJpbmRpbmc9IntAdGVtcGxhdGUtZm9yOiByZXN1bHRzUGFnZX17QGV2ZW50LW1vdXNlZG93bjogaGFuZGxlTW91c2VEb3dufXtAZXZlbnQtY2xpY2s6IGhhbmRsZUNsaWNrfXtAZXZlbnQtbW91c2VvdXQ6IGhhbmRsZU1vdXNlT3V0fXtAZXZlbnQtbW91c2V1cDogaGFuZGxlTW91c2VVcH17QGV2ZW50LXRvdWNoc3RhcnQ6IGhhbmRsZVRvdWNoU3RhcnR9e0BldmVudC10b3VjaG1vdmU6IGhhbmRsZVRvdWNoTW92ZX17QGV2ZW50LXRvdWNoY2FuY2VsOiBoYW5kbGVUb3VjaENhbmNlbH17QGV2ZW50LXRvdWNoZW5kOiBoYW5kbGVUb3VjaEVuZH0iIHRhYmluZGV4PSIwIj4NCiAgICAgICAgICAgICAgICA8aW1nIGNsYXNzPSJsaXN0LW1lbnUtaWNvbiIgZGF0YS1iaW5kaW5nPSJ7c3JjOiBpY29uVXJpfXthbHQ6IGxhYmVsfXtAdmlzaWJsZTogaWNvblVyaX0iIGFsdD0iICIgYXJpYS1oaWRkZW49InRydWUiIC8+DQogICAgICAgICAgICAgICAgPGltZyBjbGFzcz0ibGlzdC1tZW51LWljb24iIGRhdGEtYmluZGluZz0ie2FsdDogbGFiZWx9e0BoaWRkZW46IGljb25Vcml9IiBzcmM9IlJlc291cmNlcy9JbWFnZXMvSWNvbnMvbWFwLWRlZmF1bHQtMjQucG5nIiBhbHQ9IiAiIGFyaWEtaGlkZGVuPSJ0cnVlIiAvPg0KICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJsaXN0LW1lbnUtZGV0YWlscyI+DQogICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9Imxpc3QtbWVudS1uYW1lIiBkYXRhLWJpbmRpbmc9IntAd2lkZ2V0OiBHZXRMYWJlbH17QHdpZGdldC1jb250ZXh0OiBAY29udGV4dH17QHZpc2libGU6IGxhYmVsfXtAZXZlbnQtbW91c2Vkb3duOiBoYW5kbGVNb3VzZURvd259e0BldmVudC1jbGljazogaGFuZGxlQ2xpY2t9e0BldmVudC1tb3VzZW91dDogaGFuZGxlTW91c2VPdXR9e0BldmVudC1tb3VzZXVwOiBoYW5kbGVNb3VzZVVwfXtAZXZlbnQtdG91Y2hzdGFydDogaGFuZGxlVG91Y2hTdGFydH17QGV2ZW50LXRvdWNobW92ZTogaGFuZGxlVG91Y2hNb3ZlfXtAZXZlbnQtdG91Y2hjYW5jZWw6IGhhbmRsZVRvdWNoQ2FuY2VsfXtAZXZlbnQtdG91Y2hlbmQ6IGhhbmRsZVRvdWNoRW5kfSI+PC9idXR0b24+DQogICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJsaXN0LW1lbnUtZGVzYyIgZGF0YS1iaW5kaW5nPSJ7QHdpZGdldDogR2V0RGVzY3JpcHRpb259e0B3aWRnZXQtY29udGV4dDogQGNvbnRleHR9Ij48L3NwYW4+DQogICAgICAgICAgICAgICAgPC9zcGFuPg0KICAgICAgICAgICAgPC9kaXY+DQogICAgICAgIDwvZGl2Pg0KICAgIDwvZGl2Pg0KICAgIDwhLS0gRU5EOiBSZXN1bHRzIExpc3QgLS0+DQoNCiAgICA8IS0tIEJFR0lOOiBQYWdpbmcgQ29udHJvbHMgLS0+DQogICAgPGRpdiBjbGFzcz0icGFnaW5nLWNvbnRyb2wiIGRhdGEtYmluZGluZz0ie0Bzb3VyY2U6IHByZXNlbnRhYmxlUmVzdWx0c317Y2xhc3NOYW1lOiBwYWdpbmdDb250cm9sQ2xhc3NOYW1lfSI+DQogICAgICAgIDxkaXYgY2xhc3M9InBhZ2luZy1jb250cm9sLWlubmVyIiBkYXRhLWJpbmRpbmc9IntAdGVtcGxhdGUtZm9yOiBwcmVzZW50YWJsZVJlc3VsdHN9Ij4NCiAgICAgICAgICAgIDxkaXYgY2xhc3M9InBhZ2luZy1yZXN1bHQtaW5mbyI+ICAgICAgICAgICAgICAgIA0KICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJwYWdpbmctcmVzdWx0cy10b3RhbCIgZGF0YS1iaW5kaW5nPSJ7QGhpZGRlbjogbnVtYmVyT2ZJdGVtc317QHRleHQ6IEBsYW5ndWFnZS1jb21tb24tbm8tcmVzdWx0c30iPjwvc3Bhbj4NCiAgICAgICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmRpbmc9IntAdmlzaWJsZTogbnVtYmVyT2ZJdGVtc30iPg0KICAgICAgICAgICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmRpbmc9IntAdGV4dDogQGxhbmd1YWdlLXJlc3VsdHMtZGlzcGxheWluZ30iPjwvc3Bhbj4mbmJzcDs8c3BhbiBkYXRhLWJpbmRpbmc9IntAdGV4dDogY3VyckluZGV4U3RhcnRGcm9tT25lfSI+PC9zcGFuPiZuYnNwOy0mbmJzcDs8c3BhbiBkYXRhLWJpbmRpbmc9IntAdGV4dDogY3VyckluZGV4RW5kfSI+PC9zcGFuPiZuYnNwOyg8c3BhbiBkYXRhLWJpbmRpbmc9IntAdGV4dDogQGxhbmd1YWdlLXJlc3VsdHMtdG90YWx9Ij48L3NwYW4+OiZuYnNwOzxzcGFuIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBudW1iZXJPZkl0ZW1zfSI+PC9zcGFuPikNCiAgICAgICAgICAgICAgICA8L3NwYW4+DQogICAgICAgICAgICA8L2Rpdj4NCiAgICAgICAgICAgIDxkaXYgY2xhc3M9InBhZ2luZy1idXR0b25zIiBkYXRhLWJpbmRpbmc9IntAdmlzaWJsZTogbnVtYmVyT2ZJdGVtc30iPg0KICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9ImZpcnN0IiBkYXRhLWJpbmRpbmc9IntAZXZlbnQtb25jbGljazogaGFuZGxlUGFnZUZpcnN0fXt0aXRsZTogQGxhbmd1YWdlLXBhZ2UtZmlyc3R9Ij48aW1nIHNyYz0iUmVzb3VyY2VzL0ltYWdlcy9JY29ucy9wYWdpbmctY29udHJvbC1maXJzdC00NC5wbmciIGFsdD0iICIvPjwvYnV0dG9uPg0KICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9InByZXYiIGRhdGEtYmluZGluZz0ie0BldmVudC1vbmNsaWNrOiBoYW5kbGVQYWdlUHJldn17dGl0bGU6IEBsYW5ndWFnZS1wYWdlLXByZXZ9Ij48aW1nIHNyYz0iUmVzb3VyY2VzL0ltYWdlcy9JY29ucy9wYWdpbmctY29udHJvbC1wcmV2aW91cy00NC5wbmciIGFsdD0iICIvPjwvYnV0dG9uPg0KICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJwYWdpbmctYnV0dG9ucy1pbmZvIiB0YWJpbmRleD0iMCI+DQogICAgICAgICAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBAbGFuZ3VhZ2UtcmVzdWx0cy1wYWdlfSI+PC9zcGFuPiZuYnNwOzxzcGFuIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBjdXJyUGFnZU51bWJlcn0iPjwvc3Bhbj4mbmJzcDs8c3BhbiBkYXRhLWJpbmRpbmc9IntAdGV4dDogQGxhbmd1YWdlLXJlc3VsdHMtcGFnZS1vZn0iPjwvc3Bhbj4mbmJzcDs8c3BhbiBkYXRhLWJpbmRpbmc9IntAdGV4dDogbGFzdFBhZ2VOdW1iZXJ9Ij48L3NwYW4+DQogICAgICAgICAgICAgICAgPC9zcGFuPg0KICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9Im5leHQiIGRhdGEtYmluZGluZz0ie0BldmVudC1vbmNsaWNrOiBoYW5kbGVQYWdlTmV4dH17dGl0bGU6IEBsYW5ndWFnZS1wYWdlLW5leHR9Ij48aW1nIHNyYz0iUmVzb3VyY2VzL0ltYWdlcy9JY29ucy9wYWdpbmctY29udHJvbC1uZXh0LTQ0LnBuZyIgYWx0PSIgIiAvPjwvYnV0dG9uPg0KICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9Imxhc3QiIGRhdGEtYmluZGluZz0ie0BldmVudC1vbmNsaWNrOiBoYW5kbGVQYWdlTGFzdH17dGl0bGU6IEBsYW5ndWFnZS1wYWdlLWxhc3R9Ij48aW1nIHNyYz0iUmVzb3VyY2VzL0ltYWdlcy9JY29ucy9wYWdpbmctY29udHJvbC1sYXN0LTQ0LnBuZyIgYWx0PSIgIiAvPjwvYnV0dG9uPg0KICAgICAgICAgICAgPC9kaXY+DQogICAgICAgIDwvZGl2Pg0KICAgIDwvZGl2Pg0KICAgIDwhLS0gRU5EOiBQYWdpbmcgQ29udHJvbHMgLS0+DQo8L2Rpdj4NCg==");
geocortex.resourceManager.register("Mapping.Infrastructure","inv","Mapping/infrastructure/results/ResultsTableView.html","html","PGRpdiBjbGFzcz0icmVzdWx0cy10YWJsZS1hY3Rpb25zLXdpZGdldCIgZGF0YS1iaW5kaW5nPSJ7QHZpc2libGU6IGZlYXR1cmVTZXRDb2xsZWN0aW9ufXtAd2lkZ2V0OiBSZXN1bHRzVGFibGVBY3Rpb25zV2lkZ2V0fXtAd2lkZ2V0LWNvbnRleHQ6IGZlYXR1cmVTZXRDb2xsZWN0aW9ufXtAd2lkZ2V0LXJlcXVpcmVkOiBmYWxzZX0iDQogICAgIGRhdGEtbWVudS1pZD0iUmVzdWx0c1RhYmxlQWN0aW9ucyIgZGF0YS1tZW51LXRlbXBsYXRlPSJNYXBwaW5nL2luZnJhc3RydWN0dXJlL21lbnVzL01lbnVIeXBlcmxpbmtWaWV3Lmh0bWwiPjwvZGl2Pg0KDQo8ZGl2IGNsYXNzPSJyZXN1bHRzIj4NCg0KICAgIDwhLS0gQkVHSU46IE5vIFJlc3VsdHMgLS0+DQogICAgPGRpdiBjbGFzcz0ibm8tcmVzdWx0cyIgZGF0YS1iaW5kaW5nPSJ7QGhpZGRlbjogaGFzRmVhdHVyZVNldHN9e0B0ZXh0OiBzZWFyY2hTdWdnZXN0aW9ufSI+PC9kaXY+DQogICAgPCEtLSBFTkQ6IE5vIFJlc3VsdHMgLS0+DQoNCiAgICA8IS0tIEJFR0lOOiBTY3JvbGxpbmcgVGFiIENvbnRhaW5lciBBcmVhIC0tPg0KICAgIDxkaXYgY2xhc3M9InRhYi1jb250YWluZXIiIGRhdGEtYmluZGluZz0ie0B2aXNpYmxlOiBoYXNGZWF0dXJlU2V0c317QHZhcjogc2Nyb2xsaW5nVGFiQ29udGFpbmVyRWxlbWVudH0iPg0KICAgICAgICA8dGFibGU+DQogICAgICAgICAgICA8dHI+DQogICAgICAgICAgICAgICAgPHRkIGNsYXNzPSJ0YWItbGVmdC1zY3JvbGwiIGRhdGEtYmluZGluZz0ie0B2aXNpYmxlOiB0YWJDb250cm9sc0VuYWJsZWR9e0BjbGFzcy1kaXNhYmxlZDogbGVmdFNjcm9sbFRhYkRpc2FibGVkfXtAdmFyOiBzY3JvbGxUYWJMZWZ0RWxlbWVudH0iPg0KICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGRhdGEtYmluZGluZz0ie0BldmVudC1vbmNsaWNrOiBoYW5kbGVUYWJTY3JvbGxCYWNrfXt0aXRsZTogQGxhbmd1YWdlLXRhYi1zY3JvbGwtcHJldn0iPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9IlJlc291cmNlcy9JbWFnZXMvSWNvbnMvY2hldnJvbi1sZWZ0LTE2LnBuZyIgYWx0PSIiPg0KICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj4NCiAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDx0ZCBkYXRhLWJpbmRpbmc9IntAc291cmNlOiBmZWF0dXJlU2V0Q29sbGVjdGlvbn0iPg0KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJ0YWItY29udGFpbmVyIiBkYXRhLWJpbmRpbmc9IntAdGVtcGxhdGUtZm9yOiBmZWF0dXJlU2V0Q29sbGVjdGlvbn17QHZhcjogdGFiQ29udGFpbmVyRWxlbWVudH0iPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHVsIGNsYXNzPSJ0YWItY29udHJvbCIgZGF0YS1iaW5kaW5nPSJ7QHNvdXJjZTogZmVhdHVyZVNldHN9e0B2YXI6IHRhYkVsZW1lbnRzfSI+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpIGRhdGEtYmluZGluZz0ie0B0ZW1wbGF0ZS1mb3I6IGZlYXR1cmVTZXRzfSI+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9InRhYiIgZGF0YS1iaW5kaW5nPSJ7QGNsYXNzLXRhYi1hY3RpdmU6IGlzU2VsZWN0ZWRJbkNvbGxlY3Rpb259e0Bub2NsYXNzLXRhYjogaXNTZWxlY3RlZEluQ29sbGVjdGlvbn17QGV2ZW50LW9uY2xpY2s6IGhhbmRsZVRhYkNsaWNrfSI+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Ryb25nIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBkaXNwbGF5TmFtZX17dGl0bGU6IGRpc3BsYXlOYW1lfSI+PC9zdHJvbmc+DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPg0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+DQogICAgICAgICAgICAgICAgICAgICAgICA8L3VsPg0KICAgICAgICAgICAgICAgICAgICA8L2Rpdj4NCiAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgICAgIDx0ZCBjbGFzcz0idGFiLXJpZ2h0LXNjcm9sbCIgZGF0YS1iaW5kaW5nPSJ7QHZpc2libGU6IHRhYkNvbnRyb2xzRW5hYmxlZH17QGNsYXNzLWRpc2FibGVkOiByaWdodFNjcm9sbFRhYkRpc2FibGVkfXtAdmFyOiBzY3JvbGxUYWJSaWdodEVsZW1lbnR9Ij4NCiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBkYXRhLWJpbmRpbmc9IntAZXZlbnQtb25jbGljazogaGFuZGxlVGFiU2Nyb2xsRm9yd2FyZH17dGl0bGU6IEBsYW5ndWFnZS10YWItc2Nyb2xsLW5leHR9Ij4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxpbWcgc3JjPSJSZXNvdXJjZXMvSW1hZ2VzL0ljb25zL2NoZXZyb24tcmlnaHQtMTYucG5nIj4NCiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+DQogICAgICAgICAgICAgICAgPC90ZD4NCiAgICAgICAgICAgIDwvdHI+DQogICAgICAgIDwvdGFibGU+DQogICAgPC9kaXY+DQogICAgPCEtLSBFTkQ6IFNjcm9sbGluZyBUYWIgQ29udGFpbmVyIEFyZWEgLS0+DQoNCg0KICAgIDwhLS0gQkVHSU46IFJlc3VsdHMgVGFibGUgLS0+DQogICAgPGRpdiBjbGFzcz0id2lkZ2V0IiBkYXRhLWJpbmRpbmc9IntAdmlzaWJsZTogaGFzRmVhdHVyZVNldHN9e0B3aWRnZXQ6IFRhYmxlVmlld1dpZGdldH17QHdpZGdldC1jb250ZXh0OiBAY29udGV4dH17QHdpZGdldC1yZXF1aXJlZDogZmFsc2V9Ij48L2Rpdj4NCiAgICA8IS0tIEVORDogUmVzdWx0cyBUYWJsZSAtLT4NCg0KICAgIDwhLS0gQkVHSU46IFBhZ2luZyBDb250cm9scyAtLT4NCiAgICA8ZGl2IGNsYXNzPSJwYWdpbmctY29udHJvbCIgZGF0YS1iaW5kaW5nPSJ7QHNvdXJjZTogcHJlc2VudGFibGVSZXN1bHRzfSI+DQogICAgICAgIDxkaXYgY2xhc3M9InBhZ2luZy1jb250cm9sLWlubmVyIiBkYXRhLWJpbmRpbmc9IntAdGVtcGxhdGUtZm9yOiBwcmVzZW50YWJsZVJlc3VsdHN9Ij4NCiAgICAgICAgICAgIDxkaXYgY2xhc3M9InBhZ2luZy1yZXN1bHQtaW5mbyI+DQogICAgICAgICAgICAgICAgPHNwYW4gZGF0YS1iaW5kaW5nPSJ7QGhpZGRlbjogbnVtYmVyT2ZJdGVtc317QHRleHQ6IEBsYW5ndWFnZS1jb21tb24tbm8tcmVzdWx0c30iPjwvc3Bhbj4NCiAgICAgICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmRpbmc9IntAdmlzaWJsZTogbnVtYmVyT2ZJdGVtc30iPg0KICAgICAgICAgICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmRpbmc9IntAdGV4dDogQGxhbmd1YWdlLXJlc3VsdHMtZGlzcGxheWluZ30iPjwvc3Bhbj4mbmJzcDs8c3BhbiBkYXRhLWJpbmRpbmc9IntAdGV4dDogY3VyckluZGV4U3RhcnRGcm9tT25lfSI+PC9zcGFuPiZuYnNwOy0mbmJzcDs8c3BhbiBkYXRhLWJpbmRpbmc9IntAdGV4dDogY3VyckluZGV4RW5kfSI+PC9zcGFuPiZuYnNwOyg8c3BhbiBkYXRhLWJpbmRpbmc9IntAdGV4dDogQGxhbmd1YWdlLXJlc3VsdHMtdG90YWx9Ij48L3NwYW4+OiZuYnNwOzxzcGFuIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBudW1iZXJPZkl0ZW1zfSI+PC9zcGFuPikNCiAgICAgICAgICAgICAgICA8L3NwYW4+DQogICAgICAgICAgICA8L2Rpdj4NCg0KICAgICAgICAgICAgPGRpdiBjbGFzcz0icGFnaW5nLWJ1dHRvbnMiIGRhdGEtYmluZGluZz0ie0B2aXNpYmxlOiBudW1iZXJPZkl0ZW1zfSI+DQogICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0iZmlyc3QiIGRhdGEtYmluZGluZz0ie0BldmVudC1vbmNsaWNrOiBoYW5kbGVQYWdlRmlyc3R9e3RpdGxlOiBAbGFuZ3VhZ2UtcmVzdWx0cy1wYWdlLWZpcnN0fSI+PGltZyBzcmM9IlJlc291cmNlcy9JbWFnZXMvSWNvbnMvcGFnaW5nLWNvbnRyb2wtZmlyc3QtNDQucG5nIiBhbHQ9IiAiLz48L2J1dHRvbj4NCiAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJwcmV2IiBkYXRhLWJpbmRpbmc9IntAZXZlbnQtb25jbGljazogaGFuZGxlUGFnZVByZXZ9e3RpdGxlOiBAbGFuZ3VhZ2UtcmVzdWx0cy1wYWdlLXByZXZ9Ij48aW1nIHNyYz0iUmVzb3VyY2VzL0ltYWdlcy9JY29ucy9wYWdpbmctY29udHJvbC1wcmV2aW91cy00NC5wbmciIGFsdD0iICIvPjwvYnV0dG9uPg0KICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJwYWdpbmctYnV0dG9ucy1pbmZvIiB0YWJpbmRleD0iMCI+DQogICAgICAgICAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBAbGFuZ3VhZ2UtcmVzdWx0cy1wYWdlfSI+PC9zcGFuPiZuYnNwOzxzcGFuIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBjdXJyUGFnZU51bWJlcn0iPjwvc3Bhbj4mbmJzcDs8c3BhbiBkYXRhLWJpbmRpbmc9IntAdGV4dDogQGxhbmd1YWdlLXJlc3VsdHMtcGFnZS1vZn0iPjwvc3Bhbj4mbmJzcDs8c3BhbiBkYXRhLWJpbmRpbmc9IntAdGV4dDogbGFzdFBhZ2VOdW1iZXJ9Ij48L3NwYW4+DQogICAgICAgICAgICAgICAgPC9zcGFuPg0KICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9Im5leHQiIGRhdGEtYmluZGluZz0ie0BldmVudC1vbmNsaWNrOiBoYW5kbGVQYWdlTmV4dH17dGl0bGU6IEBsYW5ndWFnZS1yZXN1bHRzLXBhZ2UtbmV4dH0iPjxpbWcgc3JjPSJSZXNvdXJjZXMvSW1hZ2VzL0ljb25zL3BhZ2luZy1jb250cm9sLW5leHQtNDQucG5nIiBhbHQ9IiAiLz48L2J1dHRvbj4NCiAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJsYXN0IiBkYXRhLWJpbmRpbmc9IntAZXZlbnQtb25jbGljazogaGFuZGxlUGFnZUxhc3R9e3RpdGxlOiBAbGFuZ3VhZ2UtcmVzdWx0cy1wYWdlLWxhc3R9Ij48aW1nIHNyYz0iUmVzb3VyY2VzL0ltYWdlcy9JY29ucy9wYWdpbmctY29udHJvbC1sYXN0LTQ0LnBuZyIgYWx0PSIgIi8+PC9idXR0b24+DQogICAgICAgICAgICA8L2Rpdj4NCg0KICAgICAgICA8L2Rpdj4NCiAgICA8L2Rpdj4NCiAgICA8IS0tIEVORDogUGFnaW5nIENvbnRyb2xzIC0tPg0KPC9kaXY+DQo=");
geocortex.resourceManager.register("Mapping.Infrastructure","inv","Mapping/infrastructure/ui/components/ColorPicker/ColorPickerView.html","html","PCEtLSBDb2xvciBpbnB1dCAob3Igc3dhdGNoZXMpLiAtLT4NCjxkaXYgY2xhc3M9ImZvcm0tY29udHJvbCIgZGF0YS1iaW5kaW5nPSJ7QGV2ZW50LW9uY2hhbmdlOiBoYW5kbGVDaGFuZ2V9e0BldmVudC1vbmlucHV0OiBoYW5kbGVDaGFuZ2V9Ij4NCiAgICA8aW5wdXQgdHlwZT0iY29sb3IiIGRhdGEtYmluZGluZz0ie0B2YXI6IGNvbG9ySW5wdXR9e0BoaWRkZW46IHVzZUNvbG9yU3dhdGNoZXN9IiAvPg0KICAgIDxkaXYgY2xhc3M9ImlubGluZSBjb2xvci1zd2F0Y2hlcyIgZGF0YS1iaW5kaW5nPSJ7QHZpc2libGU6IHVzZUNvbG9yU3dhdGNoZXN9Ij4NCiAgICAgICAgPGZpZWxkc2V0IGNsYXNzPSJyYWRpby1jb250YWluZXIgaW5saW5lIiBkYXRhLWJpbmRpbmc9IntAdmFyOiBjb2xvclN3YXRjaEZpZWxkU2V0fXtAc291cmNlOiBjb2xvclN3YXRjaGVzfSI+DQogICAgICAgICAgICA8bGFiZWwgY2xhc3M9ImNvbG9yLXN3YXRjaCIgZGF0YS1iaW5kaW5nPSJ7QHRlbXBsYXRlLWZvcjogY29sb3JTd2F0Y2hlc30iPg0KICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPSJyYWRpbyIgZGF0YS1iaW5kaW5nPSJ7bmFtZTogc2V0TmFtZX0iIC8+DQogICAgICAgICAgICA8L2xhYmVsPg0KICAgICAgICA8L2ZpZWxkc2V0Pg0KICAgIDwvZGl2Pg0KPC9kaXY+DQo=");
geocortex.resourceManager.register("Mapping.Infrastructure","inv","Mapping/infrastructure/ui/components/PagingControls/PagingControlsView.html","html","PGRpdiBjbGFzcz0icGFnaW5nLWNvbnRyb2wiIGRhdGEtYmluZGluZz0ie0Bzb3VyY2U6IHByZXNlbnRhYmxlUmVzdWx0c30iPg0KICAgIDxkaXYgY2xhc3M9InBhZ2luZy1jb250cm9sLWlubmVyIiBkYXRhLWJpbmRpbmc9IntAdGVtcGxhdGUtZm9yOiBwcmVzZW50YWJsZVJlc3VsdHN9Ij4NCiAgICAgICAgPGRpdiBjbGFzcz0icGFnaW5nLXJlc3VsdC1pbmZvIj4NCiAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZGluZz0ie0BoaWRkZW46IG51bWJlck9mSXRlbXN9e0B0ZXh0OiBAbGFuZ3VhZ2UtY29tbW9uLW5vLXJlc3VsdHN9Ij48L3NwYW4+DQogICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmRpbmc9IntAdmlzaWJsZTogbnVtYmVyT2ZJdGVtc30iPg0KICAgICAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBAbGFuZ3VhZ2UtcGFnZS1kaXNwbGF5aW5nfSI+PC9zcGFuPiZuYnNwOzxzcGFuIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBjdXJySW5kZXhTdGFydEZyb21PbmV9Ij48L3NwYW4+Jm5ic3A7LSZuYnNwOzxzcGFuIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBjdXJySW5kZXhFbmR9Ij48L3NwYW4+Jm5ic3A7KDxzcGFuIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBAbGFuZ3VhZ2UtcGFnZS10b3RhbH0iPjwvc3Bhbj46Jm5ic3A7PHNwYW4gZGF0YS1iaW5kaW5nPSJ7QHRleHQ6IG51bWJlck9mSXRlbXN9Ij48L3NwYW4+KQ0KICAgICAgICAgICAgPC9zcGFuPg0KICAgICAgICA8L2Rpdj4NCg0KICAgICAgICA8ZGl2IGNsYXNzPSJwYWdpbmctYnV0dG9ucyIgZGF0YS1iaW5kaW5nPSJ7QHZpc2libGU6IG51bWJlck9mSXRlbXN9Ij4NCiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9ImZpcnN0IiBkYXRhLWJpbmRpbmc9IntAZXZlbnQtb25jbGljazogaGFuZGxlUGFnZUZpcnN0fXt0aXRsZTogQGxhbmd1YWdlLXBhZ2UtZmlyc3R9Ij48aW1nIHNyYz0iUmVzb3VyY2VzL0ltYWdlcy9JY29ucy9wYWdpbmctY29udHJvbC1maXJzdC00NC5wbmciIGFsdD0iICIgLz48L2J1dHRvbj4NCiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9InByZXYiIGRhdGEtYmluZGluZz0ie0BldmVudC1vbmNsaWNrOiBoYW5kbGVQYWdlUHJldn17dGl0bGU6IEBsYW5ndWFnZS1wYWdlLXByZXZ9Ij48aW1nIHNyYz0iUmVzb3VyY2VzL0ltYWdlcy9JY29ucy9wYWdpbmctY29udHJvbC1wcmV2aW91cy00NC5wbmciIGFsdD0iICIgLz48L2J1dHRvbj4NCiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJwYWdpbmctYnV0dG9ucy1pbmZvIiB0YWJpbmRleD0iMCI+DQogICAgICAgICAgICAgICAgPHNwYW4gZGF0YS1iaW5kaW5nPSJ7QHRleHQ6IEBsYW5ndWFnZS1wYWdlLXBhZ2V9Ij48L3NwYW4+Jm5ic3A7PHNwYW4gZGF0YS1iaW5kaW5nPSJ7QHRleHQ6IGN1cnJQYWdlTnVtYmVyfSI+PC9zcGFuPiZuYnNwOzxzcGFuIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBAbGFuZ3VhZ2UtcGFnZS1vZn0iPjwvc3Bhbj4mbmJzcDs8c3BhbiBkYXRhLWJpbmRpbmc9IntAdGV4dDogbGFzdFBhZ2VOdW1iZXJ9Ij48L3NwYW4+DQogICAgICAgICAgICA8L3NwYW4+DQogICAgICAgICAgICA8YnV0dG9uIGNsYXNzPSJuZXh0IiBkYXRhLWJpbmRpbmc9IntAZXZlbnQtb25jbGljazogaGFuZGxlUGFnZU5leHR9e3RpdGxlOiBAbGFuZ3VhZ2UtcGFnZS1uZXh0fSI+PGltZyBzcmM9IlJlc291cmNlcy9JbWFnZXMvSWNvbnMvcGFnaW5nLWNvbnRyb2wtbmV4dC00NC5wbmciIGFsdD0iICIgLz48L2J1dHRvbj4NCiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9Imxhc3QiIGRhdGEtYmluZGluZz0ie0BldmVudC1vbmNsaWNrOiBoYW5kbGVQYWdlTGFzdH17dGl0bGU6IEBsYW5ndWFnZS1wYWdlLWxhc3R9Ij48aW1nIHNyYz0iUmVzb3VyY2VzL0ltYWdlcy9JY29ucy9wYWdpbmctY29udHJvbC1sYXN0LTQ0LnBuZyIgYWx0PSIgIiAvPjwvYnV0dG9uPg0KICAgICAgICA8L2Rpdj4NCiAgICA8L2Rpdj4NCjwvZGl2Pg0K");
geocortex.resourceManager.register("Mapping.Infrastructure","inv","Mapping/infrastructure/ui/components/Slider/SliderView.html","html","PGRpdiBjbGFzcz0iZ2N4LXNsaWRlci1jb250YWluZXIiPg0KICAgIDxkaXYgY2xhc3M9ImdjeC1zbGlkZXItY3VycmVudC1sYWJlbC1jb250YWluZXIiPg0KICAgICAgICA8ZGl2IGNsYXNzPSJnY3gtc2xpZGVyLWxhYmVsIGdjeC1zbGlkZXItbGFiZWwtY3VycmVudC1taW4iIGRhdGEtYmluZGluZz0ie0B2aXNpYmxlOiBzbGlkZXJNaW5IYW5kbGVMYWJlbH17QHZhcjogc2xpZGVyTWluTGFiZWxFbGVtZW50fXtAdGV4dDogc2xpZGVyTWluSGFuZGxlTGFiZWx9Ij48L2Rpdj4NCiAgICAgICAgPGRpdiBjbGFzcz0iZ2N4LXNsaWRlci1sYWJlbCBnY3gtc2xpZGVyLWxhYmVsLWN1cnJlbnQtbWF4IiBkYXRhLWJpbmRpbmc9IntAdmlzaWJsZTogc2xpZGVyTWF4SGFuZGxlTGFiZWx9e0B2YXI6IHNsaWRlck1heExhYmVsRWxlbWVudH17QHRleHQ6IHNsaWRlck1heEhhbmRsZUxhYmVsfSI+PC9kaXY+DQogICAgPC9kaXY+DQogICAgPGRpdiBjbGFzcz0iZ2N4LXNsaWRlci1yYW5nZS1jb250YWluZXIiPg0KICAgICAgICA8ZGl2IGNsYXNzPSJnY3gtc2xpZGVyLXRpY2tzIiBkYXRhLWJpbmRpbmc9IntAc291cmNlOiBzbGlkZXJUaWNrc30iPg0KICAgICAgICAgICAgPGRpdiBjbGFzcz0iZ2N4LXRpY2siIGRhdGEtYmluZGluZz0ie0B0ZW1wbGF0ZS1mb3I6IHNsaWRlclRpY2tzfXtAc3R5bGUtbGVmdDogcG9zaXRpb259Ij48L2Rpdj4NCiAgICAgICAgPC9kaXY+DQogICAgICAgIDxkaXYgY2xhc3M9ImdjeC1zbGlkZXIiIGRhdGEtYmluZGluZz0ie0B2YXI6IHNsaWRlckVsZW1lbnR9Ij48L2Rpdj4NCiAgICA8L2Rpdj4NCiAgICA8ZGl2IGNsYXNzPSJnY3gtc2xpZGVyLWxhYmVsLWNvbnRhaW5lciI+DQogICAgICAgIDxzcGFuIGNsYXNzPSJnY3gtc2xpZGVyLWxhYmVsIGdjeC1zbGlkZXItbGFiZWwtbWluIiBkYXRhLWJpbmRpbmc9IntAdGV4dDogc2xpZGVyTWluTGFiZWx9Ij48L3NwYW4+DQogICAgICAgIDxzcGFuIGNsYXNzPSJnY3gtc2xpZGVyLWxhYmVsIGdjeC1zbGlkZXItbGFiZWwtbWF4IiBkYXRhLWJpbmRpbmc9IntAdGV4dDogc2xpZGVyTWF4TGFiZWx9Ij48L3NwYW4+DQogICAgPC9kaXY+DQo8L2Rpdj4NCg==");
geocortex.resourceManager.register("Mapping.Infrastructure","inv","Mapping/infrastructure/ui/components/SmartPanel/SmartPanelView.html","html","PGRpdiBjbGFzcz0idmlldy1jb250YWluZXItdmlldyBzbWFydC1wYW5lbCIgZGF0YS1iaW5kaW5nPSJ7QHZhcjogY29udGFpbmVyRWxlbWVudH0iPg0KICAgIDwhLS0gQkVHSU46IEhlYWRlciAtLT4NCiAgICA8YnV0dG9uIGNsYXNzPSJib3R0b20tcGFuZWwtcmVzaXplIHJlc2l6ZS1oYW5kbGUiIGRhdGEtYmluZGluZz0ie0B2aXNpYmxlOiByZXNpemVZfXtAZXZlbnQtbW91c2Vkb3duOiBoYW5kbGVIZWFkZXJNb3VzZURvd259e0BldmVudC10b3VjaHN0YXJ0OiBoYW5kbGVIZWFkZXJUb3VjaFN0YXJ0fXt0aXRsZTogQGxhbmd1YWdlLXNtYXJ0LXBhbmVsLXJlc2l6ZX0iPg0KICAgICAgICA8c3BhbiBjbGFzcz0iaWNvbi1kcmFnIj48L3NwYW4+DQogICAgPC9idXR0b24+DQogICAgPGRpdiBjbGFzcz0icGFuZWwtaGVhZGVyIGJhbm5lci1ub3NlbGVjdCIgIGRhdGEtYmluZGluZz0ie0B2aXNpYmxlOiBoZWFkZXJJc1Zpc2libGV9e0B2YXI6IGhlYWRlckVsZW1lbnR9e0BldmVudC1tb3VzZWRvd246IGhhbmRsZUhlYWRlck1vdXNlRG93bn0NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QGV2ZW50LXRvdWNoc3RhcnQ6IGhhbmRsZUhlYWRlclRvdWNoU3RhcnR9e0BjbGFzcy1yZXNpemUtaG9yaXpvbnRhbC1oaW50OiByZXNpemVYfQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtAY2xhc3MtcmVzaXplLXZlcnRpY2FsLWhpbnQ6IHJlc2l6ZVl9Ij4NCiAgICAgICAgPGRpdiBkYXRhLWJpbmRpbmc9IntAdmlzaWJsZTogdGl0bGVCYXJJc1Zpc2libGV9Ij4NCiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9InBhbmVsLWhlYWRlci1idXR0b24gcmlnaHQgY2xvc2UtMTYiIGRhdGEtYmluZGluZz0ie0B2aXNpYmxlOiBzaG93aW5nWEJ1dHRvbn17QGV2ZW50LW9uY2xpY2s6IGhhbmRsZUNsaWNrQ2xvc2V9e3RpdGxlOiBAbGFuZ3VhZ2Utc21hcnQtcGFuZWwtY2xvc2V9Ij48L2J1dHRvbj4NCiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9InBhbmVsLWhlYWRlci1idXR0b24gcmlnaHQiIGRhdGEtYmluZGluZz0ie0B2aXNpYmxlOiBzaG93aW5nTWF4aW1pemVCdXR0b259e0BjbGFzcy1taW5pbWl6ZS0xNjogcGFuZWxNYXhpbWl6ZWR9e0Bub2NsYXNzLW1heGltaXplLTE2OiBwYW5lbE1heGltaXplZH17QGV2ZW50LW9uY2xpY2s6IGhhbmRsZU1heGltaXplVG9nZ2xlQ2xpY2t9e3RpdGxlOiBAbGFuZ3VhZ2Utc21hcnQtcGFuZWwtbWF4aW1pemUtcmVzdG9yZX0iPjwvYnV0dG9uPg0KICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0icGFuZWwtaGVhZGVyLWJ1dHRvbiBtZW51LWJ1dHRvbiIgZGF0YS1iaW5kaW5nPSJ7QGVuYWJsZWQ6IGhhc0V4ZWN1dGFibGVNZW51SXRlbXN9e0B2aXNpYmxlOiBoYXNIb2lzdGVkTWVudX17QGV2ZW50LW9uY2xpY2s6IGhhbmRsZVRhcE1lbnVCdXR0b259e0B2YXI6IG1lbnVCdXR0b25FbGVtZW50fXt0aXRsZTogQGxhbmd1YWdlLXNtYXJ0LXBhbmVsLW1lbnV9Ij48L2J1dHRvbj4NCiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9InBhbmVsLWhlYWRlci1idXR0b24gbGVmdCBiYWNrLTE2IiBkYXRhLWJpbmRpbmc9IntAdmlzaWJsZTogc2hvd2luZ0JhY2tCdXR0b259e0BldmVudC1jbGljazogaGFuZGxlQ2xpY2tCYWNrfXt0aXRsZTogQGxhbmd1YWdlLXNtYXJ0LXBhbmVsLWJhY2t9Ij48L2J1dHRvbj4NCg0KICAgICAgICAgICAgPGgyIGNsYXNzPSJwYW5lbC10aXRsZSBiYW5uZXItbm9zZWxlY3QiPg0KICAgICAgICAgICAgICAgIDxpbWcgc3JjPSJSZXNvdXJjZXMvSW1hZ2VzL2xvYWRlci1zbWFsbC5naWYiIGRhdGEtYmluZGluZz0ie0B2aXNpYmxlOiBzaG93QnVzeUluZGljYXRvcn0iIGFsdD0iICIgLz4NCiAgICAgICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmRpbmc9IntAdGV4dDogY29udGFpbmVyVGl0bGV9e0B2aXNpYmxlOiBjb250YWluZXJUaXRsZX0iPjwvc3Bhbj4NCiAgICAgICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmRpbmc9IntAdmlzaWJsZTogY29udGFpbmVyVGl0bGV9Ij4mbmJzcDstJm5ic3A7PC9zcGFuPg0KICAgICAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZGluZz0ie0B0ZXh0OiB2aWV3VGl0bGV9e0B2aXNpYmxlOiB2aWV3VGl0bGV9e3RpdGxlOiB2aWV3VGl0bGV9Ij48L3NwYW4+DQogICAgICAgICAgICA8L2gyPg0KICAgICAgICA8L2Rpdj4NCg0KICAgICAgICA8ZGl2IGNsYXNzPSJzbWFydC1wYW5lbC1ob2lzdGVkLW1lbnUtaW5saW5lIiBkYXRhLWJpbmRpbmc9IntAdmlzaWJsZTogaW5saW5lTWVudUlzT3Blbn17QHdpZGdldDogU21hcnRQYW5lbEhvaXN0ZWRNZW51fXtAd2lkZ2V0LXJlcXVpcmVkOiBmYWxzZX17QHdpZGdldC1jb250ZXh0OiBob2lzdGVkTWVudVZpZXdNb2RlbH0iPjwvZGl2Pg0KDQogICAgICAgIDxkaXYgZGF0YS1iaW5kaW5nPSJ7QGRvbTogaGVhZGVySW5zZXJ0RG9tRWxlbWVudH0iPjwvZGl2Pg0KICAgIDwvZGl2Pg0KICAgIDwhLS0gRU5EOiBIZWFkZXIgLS0+DQoNCiAgICA8IS0tIEJFR0lOOiBPcHRpb25hbCBzdGF0dXMgbWVzc2FnZXMgLS0+DQogICAgPGRpdiBjbGFzcz0icmVnaW9uIHBhbmVsLXN0YXR1cy1yZWdpb24iIGRhdGEtYmluZGluZz0ie0B2YXI6IHN0YXR1c1JlZ2lvbkVsZW1lbnR9Ij48L2Rpdj4NCiAgICA8IS0tIEVORDogT3B0aW9uYWwgc3RhdHVzIG1lc3NhZ2VzIC0tPg0KDQogICAgPCEtLSBCRUdJTjogQ29udGVudCByZWdpb24gLS0+DQogICAgPGRpdiBjbGFzcz0icGFuZWwtc2Nyb2xsLWNvbnRhaW5lciIgZGF0YS1iaW5kaW5nPSJ7ZGF0YS1yZWdpb24tbmFtZTogcmVnaW9uTmFtZX17ZGF0YS1yZWdpb24tYWRhcHRlcjogcmVnaW9uVHlwZX17QHZhcjogc2Nyb2xsUmVnaW9uRWxlbWVudH17QGV2ZW50LW9uc2Nyb2xsOiBoYW5kbGVTY3JvbGxDaGFuZ2V9IiB0YWJpbmRleD0iLTEiPjwvZGl2Pg0KICAgIDwhLS0gRU5EOiBDb250ZW50IHJlZ2lvbiAtLT4NCg0KICAgIDwhLS0gQkVHSU46IE9wdGlvbmFsIGZvb3RlciBjb250ZW50IC0tPg0KICAgIDxkaXYgY2xhc3M9InBhbmVsLWZvb3RlciIgZGF0YS1iaW5kaW5nPSJ7QHZhcjogZm9vdGVyRWxlbWVudH17QHZpc2libGU6IGZvb3Rlckluc2VydERvbUVsZW1lbnR9IiBzdHlsZT0icG9zaXRpb246IGFic29sdXRlIj4NCiAgICAgICAgPGRpdiBjbGFzcz0icGFuZWwtZm9vdGVyLWlubmVyIiBkYXRhLWJpbmRpbmc9IntAZG9tOiBmb290ZXJJbnNlcnREb21FbGVtZW50fSI+PC9kaXY+DQogICAgPC9kaXY+DQogICAgPCEtLSBFTkQ6IE9wdGlvbmFsIGhlYWRlciBjb250ZW50IC0tPg0KDQo8L2Rpdj4NCg==");
geocortex.resourceManager.register("Mapping.Infrastructure","inv","Mapping/infrastructure/ui/components/Table/TableView.html","html","PGRpdiBjbGFzcz0icmVzdWx0cy10YWJsZSIgZGF0YS1iaW5kaW5nPSJ7QHZhcjogdGFibGVDb250YWluZXJFbGVtZW50fSI+DQogICAgPHRhYmxlPg0KICAgICAgICA8dGhlYWQ+DQogICAgICAgICAgICA8dHIgZGF0YS1iaW5kaW5nPSJ7QHNvdXJjZTogY29sdW1uSGVhZGVyc30iPg0KICAgICAgICAgICAgICAgIDx0aCBkYXRhLWJpbmRpbmc9IntAdGVtcGxhdGUtZm9yOiBjb2x1bW5IZWFkZXJzfXtAdmlzaWJsZTogdmlzaWJsZX17QGV2ZW50LW9uY2xpY2s6IGhhbmRsZUNvbHVtbkhlYWRDbGlja30iIHNjb3BlPSJjb2wiPg0KICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGRhdGEtYmluZGluZz0ie2FyaWEtbGFiZWw6IGNvbHVtbkRlc2NyaXB0b3J9Ij4NCiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZGluZz0ie2NsYXNzOiBzb3J0Q2xhc3N9e3RpdGxlOiBAbGFuZ3VhZ2UtcmVzdWx0cy1zb3J0fSI+PC9zcGFuPg0KICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9InJlc3VsdC1oZWFkaW5nIiBkYXRhLWJpbmRpbmc9IntAdGV4dDogcHJlc2VudGFibGVWYWx1ZX0iPjwvc3Bhbj4NCiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+DQogICAgICAgICAgICAgICAgPC90aD4NCiAgICAgICAgICAgIDwvdHI+DQogICAgICAgIDwvdGhlYWQ+DQogICAgICAgIDx0Ym9keSBkYXRhLWJpbmRpbmc9IntAc291cmNlOiByZWNvcmRzfSI+DQogICAgICAgICAgICA8dHIgZGF0YS1iaW5kaW5nPSJ7QHRlbXBsYXRlLWZvcjogcmVjb3Jkc30NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtAc291cmNlOiBhdHRyaWJ1dGVzfQ0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge0BldmVudC1tb3VzZWRvd246IGhhbmRsZU1vdXNlRG93bn0NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtAZXZlbnQtbW91c2V1cDogaGFuZGxlTW91c2VVcH0NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtAZXZlbnQtdG91Y2hzdGFydDogaGFuZGxlVG91Y2hTdGFydH0NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtAZXZlbnQtdG91Y2htb3ZlOiBoYW5kbGVUb3VjaE1vdmV9DQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QGV2ZW50LXRvdWNoZW5kOiBoYW5kbGVUb3VjaEVuZH0NCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtAZXZlbnQtY2xpY2s6IGhhbmRsZUNsaWNrfSI+DQogICAgICAgICAgICAgICAgPHRkIGRhdGEtYmluZGluZz0ie0B0ZW1wbGF0ZS1mb3I6IGF0dHJpYnV0ZXN9e0B2aXNpYmxlOiB2aXNpYmxlfSI+DQogICAgICAgICAgICAgICAgICAgIDxhIGRhdGEtYmluZGluZz0ie0B2aXNpYmxlOiBkaXNwbGF5QXNVcmx9e0BldmVudC1vbmNsaWNrOiBoYW5kbGVDbGlja0F0dHJpYnV0ZWxpbmt9e2hyZWY6IHZhbHVlfXtAdGV4dDogcHJlc2VudGFibGVWYWx1ZX0iIHRhcmdldD0iX2JsYW5rIj48L2E+DQogICAgICAgICAgICAgICAgICAgIDxidXR0b24gZGF0YS1iaW5kaW5nPSJ7QGhpZGRlbjogZGlzcGxheUFzVXJsfXtAdGV4dDogcHJlc2VudGFibGVWYWx1ZX0iIHRhYmluZGV4PSIwIj48L2J1dHRvbj4NCiAgICAgICAgICAgICAgICA8L3RkPg0KICAgICAgICAgICAgPC90cj4NCiAgICAgICAgPC90Ym9keT4NCiAgICA8L3RhYmxlPg0KPC9kaXY+DQoNCg==");
geocortex.resourceManager.register("Mapping.Infrastructure","inv","Mapping/infrastructure/visualization/SymbologySettings/AttributeSymbologySettingsView.html","html","PGRpdiBjbGFzcz0iYXR0cmlidXRlLXN5bWJvbG9neS1zZXR0aW5ncyIgZGF0YS1iaW5kaW5nPSJ7QHZhcjogY29udGFpbmVyfXtAZXZlbnQtb25jaGFuZ2U6IGhhbmRsZUNoYW5nZX17QGV2ZW50LW9uaW5wdXQ6IGhhbmRsZUNoYW5nZX0iPg0KDQogICAgPCEtLSBBdHRyaWJ1dGUgc2VsZWN0b3IgZHJvcC1kb3duLiAtLT4NCiAgICA8ZGl2IGNsYXNzPSJzeW1ib2xvZ3ktZHJvcC1kb3duIj4NCiAgICAgICAgPGxhYmVsIGNsYXNzPSJzeW1ib2xvZ3ktbGFiZWwiIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBAbGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLXBpY2stYXR0cmlidXRlfSI+PC9sYWJlbD4NCiAgICAgICAgPHNlbGVjdCBkYXRhLWJpbmRpbmc9IntAc291cmNlOiBhdHRyaWJ1dGVzfXtAdmFyOiBhdHRyaWJ1dGVJbnB1dH0iPg0KICAgICAgICAgICAgPG9wdGlvbiBkYXRhLWJpbmRpbmc9IntAdGVtcGxhdGUtZm9yOiBhdHRyaWJ1dGVzfXtAdGV4dDogZGlzcGxheU5hbWV9e0B2YWx1ZSBuYW1lfSI+PC9vcHRpb24+DQogICAgICAgIDwvc2VsZWN0Pg0KICAgIDwvZGl2Pg0KDQogICAgPCEtLSBDbGFzcyBicmVha3Mgc2xpZGVyLiAtLT4NCiAgICA8ZGl2IGNsYXNzPSJzeW1ib2xvZ3ktc2xpZGVycyIgZGF0YS1iaW5kaW5nPSJ7QHZpc2libGU6IGlzTnVtZXJpY0F0dHJpYnV0ZX0iPg0KICAgICAgICA8ZGl2IGNsYXNzPSJzeW1ib2xvZ3ktc2xpZGVyIj4NCiAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0ic3ltYm9sb2d5LWxhYmVsIiBkYXRhLWJpbmRpbmc9IntAdGV4dDogQGxhbmd1YWdlLXN5bWJvbG9neS1zZXR0aW5ncy1icmVha3N9Ij48L2xhYmVsPg0KICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2xpZGVyIiBkYXRhLWJpbmRpbmc9IntAdmFyOiBjbGFzc0JyZWFrc1NsaWRlcn0iPjwvZGl2Pg0KICAgICAgICAgICAgPHNwYW4gY2xhc3M9InN5bWJvbG9neS1zbGlkZXItdmFsdWUiPg0KICAgICAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBudW1CcmVha3N9Ij48L3NwYW4+DQogICAgICAgICAgICA8L3NwYW4+DQogICAgICAgIDwvZGl2Pg0KICAgIDwvZGl2Pg0KDQogICAgPCEtLSBHcm91cDogQ2xhc3MgQnJlYWtzIGdyYWRpZW50IGNvbG9ycyAtLT4NCiAgICA8ZGl2IGNsYXNzPSJzeW1ib2xvZ3ktY29sb3JzIiAgZGF0YS1iaW5kaW5nPSJ7QHZpc2libGU6IGlzTnVtZXJpY0F0dHJpYnV0ZX0iPg0KICAgICAgICA8IS0tIFN0YXJ0IENvbG9yIC0tPg0KICAgICAgICA8ZGl2IGNsYXNzPSJzeW1ib2xvZ3ktY2xhc3NicmVhay1jb2xvcnBpY2tlciI+DQogICAgICAgICAgICA8bGFiZWwgY2xhc3M9InN5bWJvbG9neS1sYWJlbCIgZGF0YS1iaW5kaW5nPSJ7QHRleHQ6IEBsYW5ndWFnZS1zeW1ib2xvZ3ktc2V0dGluZ3Mtc3RhcnRjb2xvcn0iPjwvbGFiZWw+DQogICAgICAgICAgICA8ZGl2IGNsYXNzPSJpbmxpbmUiIGRhdGEtYmluZGluZz0ie0BoaWRkZW46IHVzZUNvbG9yU3dhdGNoZXN9Ij4NCiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT0iY29sb3IiIGRhdGEtYmluZGluZz0ie0B2YXI6IHN0YXJ0Q29sb3JJbnB1dH0iIC8+DQogICAgICAgICAgICA8L2Rpdj4NCiAgICAgICAgICAgIDxkaXYgY2xhc3M9ImlubGluZSBjb2xvci1zd2F0Y2hlcyIgZGF0YS1iaW5kaW5nPSJ7QHZpc2libGU6IHVzZUNvbG9yU3dhdGNoZXN9Ij4NCiAgICAgICAgICAgICAgICA8ZmllbGRzZXQgY2xhc3M9InJhZGlvLWNvbnRhaW5lciBpbmxpbmUiIGRhdGEtYmluZGluZz0ie0B2YXI6IHN0YXJ0Q29sb3JTd2F0Y2hGaWVsZFNldH17QHNvdXJjZTogc3RhcnRDb2xvclN3YXRjaGVzfSI+DQogICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0ic3RhcnQtY29sb3Itc3dhdGNoIGNvbG9yLXN3YXRjaCIgZGF0YS1iaW5kaW5nPSJ7QHRlbXBsYXRlLWZvcjogc3RhcnRDb2xvclN3YXRjaGVzfSI+DQogICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT0icmFkaW8iIG5hbWU9InN0YXJ0LWNvbG9yLXN3YXRjaCIgLz4NCiAgICAgICAgICAgICAgICAgICAgPC9sYWJlbD4NCiAgICAgICAgICAgICAgICA8L2ZpZWxkc2V0Pg0KICAgICAgICAgICAgPC9kaXY+DQogICAgICAgIDwvZGl2Pg0KICAgICAgICA8IS0tIEVuZCBDb2xvciAtLT4NCiAgICAgICAgPGRpdiBjbGFzcz0ic3ltYm9sb2d5LWNsYXNzYnJlYWstY29sb3JwaWNrZXIiPg0KICAgICAgICAgICAgPGxhYmVsIGNsYXNzPSJzeW1ib2xvZ3ktbGFiZWwiIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBAbGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLWVuZGNvbG9yfSI+PC9sYWJlbD4NCiAgICAgICAgICAgIDxkaXYgY2xhc3M9ImlubGluZSIgZGF0YS1iaW5kaW5nPSJ7QGhpZGRlbjogdXNlQ29sb3JTd2F0Y2hlc30iPg0KICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPSJjb2xvciIgZGF0YS1iaW5kaW5nPSJ7QHZhcjogZW5kQ29sb3JJbnB1dH0iIC8+DQogICAgICAgICAgICA8L2Rpdj4NCiAgICAgICAgICAgIDxkaXYgY2xhc3M9ImlubGluZSBjb2xvci1zd2F0Y2hlcyIgZGF0YS1iaW5kaW5nPSJ7QHZpc2libGU6IHVzZUNvbG9yU3dhdGNoZXN9Ij4NCiAgICAgICAgICAgICAgICA8ZmllbGRzZXQgY2xhc3M9InJhZGlvLWNvbnRhaW5lciBpbmxpbmUiIGRhdGEtYmluZGluZz0ie0B2YXI6IGVuZENvbG9yU3dhdGNoRmllbGRTZXR9e0Bzb3VyY2U6IGVuZENvbG9yU3dhdGNoZXN9Ij4NCiAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzPSJlbmQtY29sb3Itc3dhdGNoIGNvbG9yLXN3YXRjaCIgZGF0YS1iaW5kaW5nPSJ7QHRlbXBsYXRlLWZvcjogZW5kQ29sb3JTd2F0Y2hlc30iPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9InJhZGlvIiBuYW1lPSJlbmQtY29sb3Itc3dhdGNoIiAvPg0KICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPg0KICAgICAgICAgICAgICAgIDwvZmllbGRzZXQ+DQogICAgICAgICAgICA8L2Rpdj4NCiAgICAgICAgPC9kaXY+DQogICAgPC9kaXY+DQoNCiAgICA8IS0tIEdyb3VwOiBBdHRyaWJ1dGUgUmVuZGVyZXIgR2xvYmFsIENvbnRyb2xzLiAtLT4NCiAgICA8ZGl2IGNsYXNzPSJzeW1ib2xvZ3ktc2xpZGVycyIgZGF0YS1iaW5kaW5nPSJ7QHZpc2libGU6IGN1cnJlbnRBdHRyaWJ1dGV9Ij4NCg0KICAgICAgICA8IS0tIFRyYW5zcGFyZW5jeSBzbGlkZXIuIC0tPg0KICAgICAgICA8ZGl2IGNsYXNzPSJzeW1ib2xvZ3ktc2xpZGVyIj4NCiAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0ic3ltYm9sb2d5LWxhYmVsIiBkYXRhLWJpbmRpbmc9IntAdGV4dDogQGxhbmd1YWdlLXN5bWJvbG9neS1zZXR0aW5ncy10cmFuc3BhcmVuY3l9Ij48L2xhYmVsPg0KICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2xpZGVyIiBkYXRhLWJpbmRpbmc9IntAdmFyOiB0cmFuc3BhcmVuY3lTbGlkZXJ9Ij48L2Rpdj4NCiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJzeW1ib2xvZ3ktc2xpZGVyLXZhbHVlIj4NCiAgICAgICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmRpbmc9IntAdGV4dDogdHJhbnNwYXJlbmN5fSI+PC9zcGFuPg0KICAgICAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBAbGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLXRyYW5zcGFyZW5jeS1zdWZmaXh9Ij48L3NwYW4+DQogICAgICAgICAgICA8L3NwYW4+DQogICAgICAgIDwvZGl2Pg0KDQogICAgICAgIDwhLS0gTWFya2VyIHNpemUgc2xpZGVyLiAtLT4NCiAgICAgICAgPGRpdiBjbGFzcz0ic3ltYm9sb2d5LXNsaWRlciIgZGF0YS1iaW5kaW5nPSJ7QGhpZGRlbjogbm9NYXJrZXJ9Ij4NCiAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0ic3ltYm9sb2d5LWxhYmVsIiBkYXRhLWJpbmRpbmc9IntAdGV4dDogQGxhbmd1YWdlLXN5bWJvbG9neS1zZXR0aW5ncy1tYXJrZXItc2l6ZX0iPjwvbGFiZWw+DQogICAgICAgICAgICA8ZGl2IGNsYXNzPSJzbGlkZXIiIGRhdGEtYmluZGluZz0ie0B2YXI6IG1hcmtlclNpemVTbGlkZXJ9e2Rpc2FibGVkOiBub01hcmtlcn0iPjwvZGl2Pg0KICAgICAgICAgICAgPHNwYW4gY2xhc3M9InN5bWJvbG9neS1zbGlkZXItdmFsdWUiPg0KICAgICAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBtYXJrZXJTaXplfSI+PC9zcGFuPg0KICAgICAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBAbGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLW1hcmtlci1zaXplLXN1ZmZpeH0iPjwvc3Bhbj4NCiAgICAgICAgICAgIDwvc3Bhbj4NCiAgICAgICAgPC9kaXY+DQoNCiAgICAgICAgPCEtLSBMaW5lIHdpZHRoIHNsaWRlci4gLS0+DQogICAgICAgIDxkaXYgY2xhc3M9InN5bWJvbG9neS1zbGlkZXIiPg0KICAgICAgICAgICAgPGxhYmVsIGNsYXNzPSJzeW1ib2xvZ3ktbGFiZWwiIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBAbGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLWxpbmUtd2lkdGh9Ij48L2xhYmVsPg0KICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2xpZGVyIiBkYXRhLWJpbmRpbmc9IntAdmFyOiBsaW5lV2lkdGhTbGlkZXJ9Ij48L2Rpdj4NCiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJzeW1ib2xvZ3ktc2xpZGVyLXZhbHVlIj4NCiAgICAgICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmRpbmc9IntAdGV4dDogbGluZVdpZHRofSI+PC9zcGFuPg0KICAgICAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBAbGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLWxpbmUtd2lkdGgtc3VmZml4fSI+PC9zcGFuPg0KICAgICAgICAgICAgPC9zcGFuPg0KICAgICAgICA8L2Rpdj4NCg0KICAgICAgICA8IS0tIE1hcmtlciBzdHlsZSBkcm9wLWRvd24uIC0tPg0KICAgICAgICA8ZGl2IGNsYXNzPSJzeW1ib2xvZ3ktZHJvcC1kb3duIiBkYXRhLWJpbmRpbmc9IntAaGlkZGVuOiBub01hcmtlcn0iPg0KICAgICAgICAgICAgPGxhYmVsIGNsYXNzPSJzeW1ib2xvZ3ktbGFiZWwiIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBAbGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLW1hcmtlci1zdHlsZX0iPjwvbGFiZWw+DQogICAgICAgICAgICA8c2VsZWN0IGRhdGEtYmluZGluZz0ie0Bzb3VyY2U6IG1hcmtlclN0eWxlc317QHZhcjogbWFya2VyU3R5bGVJbnB1dH17ZGlzYWJsZWQ6IG5vTWFya2VyfSI+DQogICAgICAgICAgICAgICAgPG9wdGlvbiBkYXRhLWJpbmRpbmc9IntAdGVtcGxhdGUtZm9yOiBtYXJrZXJTdHlsZXN9e0B0ZXh0OiBsYWJlbH0iPjwvb3B0aW9uPg0KICAgICAgICAgICAgPC9zZWxlY3Q+DQogICAgICAgIDwvZGl2Pg0KICAgIDwvZGl2Pg0KDQogICAgPCEtLSBTeW1ib2xpemF0aW9uIENsYXNzZXMgLS0+DQogICAgPGRpdiBjbGFzcz0ic3ltYm9sb2d5LWNsYXNzZXMiIGRhdGEtYmluZGluZz0ie0Bzb3VyY2U6IHN5bWJvbG9neUNsYXNzZXN9Ij4NCiAgICAgICAgPGRpdiBkYXRhLWJpbmRpbmc9IntAdGVtcGxhdGUtZm9yOiBzeW1ib2xvZ3lDbGFzc2VzfXtAdmFyOiBzeW1ib2xvZ3lDbGFzc0NvbnRhaW5lcn0iPg0KICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0iYnV0dG9uIHN5bWJvbG9neS1jbGFzcyIgZGF0YS1iaW5kaW5nPSJ7QGNsYXNzLXNlbGVjdGVkOiBzZWxlY3RlZH17QGV2ZW50LW9uY2xpY2s6IGhhbmRsZVN5bWJvbENsYXNzU2VsZWN0ZWR9e3RpdGxlOiBuYW1lfSI+DQogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic3ltYm9sb2d5LXRleHQiIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBuYW1lfSI+PC9kaXY+DQogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ic3ltYm9sb2d5LWNvbG9yIiBkYXRhLWJpbmRpbmc9IntAc3R5bGUtYmFja2dyb3VuZC1jb2xvcjogY29sb3J9Ij48L2Rpdj4NCiAgICAgICAgICAgIDwvYnV0dG9uPg0KICAgICAgICAgICAgPCEtLSBTaW1wbGUgc3ltYm9sb2d5IHNldHR0aW5ncyB3aWRnZXQgd2lsbCBiZSBhdHRhY2hlZCBoZXJlIC0tPg0KICAgICAgICAgICAgPGRpdiBkYXRhLWJpbmRpbmc9IntAdmlzaWJsZTogc2VsZWN0ZWR9e2lkOiB3aWRnZXRJZH0iPjwvZGl2Pg0KICAgICAgICA8L2Rpdj4NCiAgICA8L2Rpdj4NCg0KPC9kaXY+DQo=");
geocortex.resourceManager.register("Mapping.Infrastructure","inv","Mapping/infrastructure/visualization/SymbologySettings/SymbologySettingsView.html","html","PGRpdiBjbGFzcz0ic3ltYm9sb2d5LXNldHRpbmdzIiBkYXRhLWJpbmRpbmc9IntAdmFyOiBjb250YWluZXJ9e0BldmVudC1vbmNoYW5nZTogaGFuZGxlQ2hhbmdlfXtAZXZlbnQtb25pbnB1dDogaGFuZGxlQ2hhbmdlfSI+DQoNCiAgICA8IS0tIEdyb3VwOiBDb2xvcnMuIC0tPg0KICAgIDxkaXYgY2xhc3M9InN5bWJvbG9neS1jb2xvcnMiPg0KDQogICAgICAgIDwhLS0gQ29sb3IgaW5wdXQgKG9yIHN3YXRjaGVzKS4gLS0+DQogICAgICAgIDxkaXY+DQogICAgICAgICAgICA8bGFiZWwgY2xhc3M9InN5bWJvbG9neS1sYWJlbCIgZGF0YS1iaW5kaW5nPSJ7QHRleHQ6IEBsYW5ndWFnZS1zeW1ib2xvZ3ktc2V0dGluZ3MtY29sb3J9Ij48L2xhYmVsPg0KICAgICAgICAgICAgPGRpdiBjbGFzcz0iaW5saW5lIiBkYXRhLWJpbmRpbmc9IntAaGlkZGVuOiB1c2VDb2xvclN3YXRjaGVzfSI+DQogICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9ImNvbG9yIiBkYXRhLWJpbmRpbmc9IntAdmFyOiBjb2xvcklucHV0fSIgLz4NCiAgICAgICAgICAgIDwvZGl2Pg0KICAgICAgICAgICAgPGRpdiBjbGFzcz0iaW5saW5lIGNvbG9yLXN3YXRjaGVzIiBkYXRhLWJpbmRpbmc9IntAdmlzaWJsZTogdXNlQ29sb3JTd2F0Y2hlc30iPg0KICAgICAgICAgICAgICAgIDxmaWVsZHNldCBjbGFzcz0icmFkaW8tY29udGFpbmVyIGlubGluZSIgZGF0YS1iaW5kaW5nPSJ7QHZhcjogY29sb3JTd2F0Y2hGaWVsZFNldH17QHNvdXJjZTogY29sb3JTd2F0Y2hlc30iPg0KICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3M9ImNvbG9yLXN3YXRjaCIgZGF0YS1iaW5kaW5nPSJ7QHRlbXBsYXRlLWZvcjogY29sb3JTd2F0Y2hlc30iPg0KICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9InJhZGlvIiBuYW1lPSJjb2xvci1zd2F0Y2giIC8+DQogICAgICAgICAgICAgICAgICAgIDwvbGFiZWw+DQogICAgICAgICAgICAgICAgPC9maWVsZHNldD4NCiAgICAgICAgICAgIDwvZGl2Pg0KICAgICAgICA8L2Rpdj4NCiAgICA8L2Rpdj4NCg0KICAgIDwhLS0gR3JvdXA6IFNsaWRlcnMuIC0tPg0KICAgIDxkaXYgY2xhc3M9InN5bWJvbG9neS1zbGlkZXJzIj4NCg0KICAgICAgICA8IS0tIFRyYW5zcGFyZW5jeSBzbGlkZXIuIC0tPg0KICAgICAgICA8ZGl2IGNsYXNzPSJzeW1ib2xvZ3ktc2xpZGVyIj4NCiAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0ic3ltYm9sb2d5LWxhYmVsIiBkYXRhLWJpbmRpbmc9IntAdGV4dDogQGxhbmd1YWdlLXN5bWJvbG9neS1zZXR0aW5ncy10cmFuc3BhcmVuY3l9Ij48L2xhYmVsPg0KICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2xpZGVyIiBkYXRhLWJpbmRpbmc9IntAdmFyOiB0cmFuc3BhcmVuY3lTbGlkZXJ9Ij48L2Rpdj4NCiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJzeW1ib2xvZ3ktc2xpZGVyLXZhbHVlIj4NCiAgICAgICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmRpbmc9IntAdGV4dDogdHJhbnNwYXJlbmN5fSI+PC9zcGFuPg0KICAgICAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBAbGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLXRyYW5zcGFyZW5jeS1zdWZmaXh9Ij48L3NwYW4+DQogICAgICAgICAgICA8L3NwYW4+DQogICAgICAgIDwvZGl2Pg0KDQogICAgICAgIDwhLS0gTWFya2VyIHNpemUgc2xpZGVyLiAtLT4NCiAgICAgICAgPGRpdiBjbGFzcz0ic3ltYm9sb2d5LXNsaWRlciIgZGF0YS1iaW5kaW5nPSJ7QGhpZGRlbjogbm9NYXJrZXJ9Ij4NCiAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0ic3ltYm9sb2d5LWxhYmVsIiBkYXRhLWJpbmRpbmc9IntAdGV4dDogQGxhbmd1YWdlLXN5bWJvbG9neS1zZXR0aW5ncy1tYXJrZXItc2l6ZX0iPjwvbGFiZWw+DQogICAgICAgICAgICA8ZGl2IGNsYXNzPSJzbGlkZXIiIGRhdGEtYmluZGluZz0ie0B2YXI6IG1hcmtlclNpemVTbGlkZXJ9e2Rpc2FibGVkOiBub01hcmtlcn0iPjwvZGl2Pg0KICAgICAgICAgICAgPHNwYW4gY2xhc3M9InN5bWJvbG9neS1zbGlkZXItdmFsdWUiPg0KICAgICAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBtYXJrZXJTaXplfSI+PC9zcGFuPg0KICAgICAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBAbGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLW1hcmtlci1zaXplLXN1ZmZpeH0iPjwvc3Bhbj4NCiAgICAgICAgICAgIDwvc3Bhbj4NCiAgICAgICAgPC9kaXY+DQoNCiAgICAgICAgPCEtLSBMaW5lIHdpZHRoIHNsaWRlci4gLS0+DQogICAgICAgIDxkaXYgY2xhc3M9InN5bWJvbG9neS1zbGlkZXIiPg0KICAgICAgICAgICAgPGxhYmVsIGNsYXNzPSJzeW1ib2xvZ3ktbGFiZWwiIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBAbGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLWxpbmUtd2lkdGh9Ij48L2xhYmVsPg0KICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2xpZGVyIiBkYXRhLWJpbmRpbmc9IntAdmFyOiBsaW5lV2lkdGhTbGlkZXJ9Ij48L2Rpdj4NCiAgICAgICAgICAgIDxzcGFuIGNsYXNzPSJzeW1ib2xvZ3ktc2xpZGVyLXZhbHVlIj4NCiAgICAgICAgICAgICAgICA8c3BhbiBkYXRhLWJpbmRpbmc9IntAdGV4dDogbGluZVdpZHRofSI+PC9zcGFuPg0KICAgICAgICAgICAgICAgIDxzcGFuIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBAbGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLWxpbmUtd2lkdGgtc3VmZml4fSI+PC9zcGFuPg0KICAgICAgICAgICAgPC9zcGFuPg0KICAgICAgICA8L2Rpdj4NCiAgICA8L2Rpdj4NCg0KICAgIDwhLS0gR3JvdXA6IERyb3AtZG93bnMuIC0tPg0KICAgIDxkaXYgY2xhc3M9InN5bWJvbG9neS1kcm9wLWRvd25zIj4NCg0KICAgICAgICA8IS0tIE1hcmtlciBzdHlsZSBkcm9wLWRvd24uIC0tPg0KICAgICAgICA8ZGl2IGNsYXNzPSJzeW1ib2xvZ3ktZHJvcC1kb3duIiBkYXRhLWJpbmRpbmc9IntAaGlkZGVuOiBub01hcmtlcn0iPg0KICAgICAgICAgICAgPGxhYmVsIGNsYXNzPSJzeW1ib2xvZ3ktbGFiZWwiIGRhdGEtYmluZGluZz0ie0B0ZXh0OiBAbGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLW1hcmtlci1zdHlsZX0iPjwvbGFiZWw+DQogICAgICAgICAgICA8c2VsZWN0IGRhdGEtYmluZGluZz0ie0Bzb3VyY2U6IG1hcmtlclN0eWxlc317QHZhcjogbWFya2VyU3R5bGVJbnB1dH17ZGlzYWJsZWQ6IG5vTWFya2VyfSI+DQogICAgICAgICAgICAgICAgPG9wdGlvbiBkYXRhLWJpbmRpbmc9IntAdGVtcGxhdGUtZm9yOiBtYXJrZXJTdHlsZXN9e0B0ZXh0OiBsYWJlbH0iPjwvb3B0aW9uPg0KICAgICAgICAgICAgPC9zZWxlY3Q+DQogICAgICAgIDwvZGl2Pg0KDQogICAgICAgIDwhLS0gTGluZSBzdHlsZSBkcm9wLWRvd24uIC0tPg0KICAgICAgICA8ZGl2IGNsYXNzPSJzeW1ib2xvZ3ktZHJvcC1kb3duIiBkYXRhLWJpbmRpbmc9IntAdmlzaWJsZTogbm9NYXJrZXJ9Ij4NCiAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0ic3ltYm9sb2d5LWxhYmVsIiBkYXRhLWJpbmRpbmc9IntAdGV4dDogQGxhbmd1YWdlLXN5bWJvbG9neS1zZXR0aW5ncy1saW5lLXN0eWxlfSI+PC9sYWJlbD4NCiAgICAgICAgICAgIDxzZWxlY3QgZGF0YS1iaW5kaW5nPSJ7QHNvdXJjZTogbGluZVN0eWxlc317QHZhcjogbGluZVN0eWxlSW5wdXR9Ij4NCiAgICAgICAgICAgICAgICA8b3B0aW9uIGRhdGEtYmluZGluZz0ie0B0ZW1wbGF0ZS1mb3I6IGxpbmVTdHlsZXN9e0B0ZXh0OiBsYWJlbH0iPjwvb3B0aW9uPg0KICAgICAgICAgICAgPC9zZWxlY3Q+DQogICAgICAgIDwvZGl2Pg0KDQogICAgICAgIDwhLS0gRmlsbCBzdHlsZSBkcm9wLWRvd24uIC0tPg0KICAgICAgICA8ZGl2IGNsYXNzPSJzeW1ib2xvZ3ktZHJvcC1kb3duIiBkYXRhLWJpbmRpbmc9IntAaGlkZGVuOiBub0ZpbGx9Ij4NCiAgICAgICAgICAgIDxsYWJlbCBjbGFzcz0ic3ltYm9sb2d5LWxhYmVsIiBkYXRhLWJpbmRpbmc9IntAdGV4dDogQGxhbmd1YWdlLXN5bWJvbG9neS1zZXR0aW5ncy1maWxsLXN0eWxlfSI+PC9sYWJlbD4NCiAgICAgICAgICAgIDxzZWxlY3QgZGF0YS1iaW5kaW5nPSJ7QHNvdXJjZTogZmlsbFN0eWxlc317QHZhcjogZmlsbFN0eWxlSW5wdXR9e2Rpc2FibGVkOiBub0ZpbGx9Ij4NCiAgICAgICAgICAgICAgICA8b3B0aW9uIGRhdGEtYmluZGluZz0ie0B0ZW1wbGF0ZS1mb3I6IGZpbGxTdHlsZXN9e0B0ZXh0OiBsYWJlbH0iPjwvb3B0aW9uPg0KICAgICAgICAgICAgPC9zZWxlY3Q+DQogICAgICAgIDwvZGl2Pg0KICAgIDwvZGl2Pg0KPC9kaXY+DQo=");
geocortex.resourceManager.register("Mapping.Infrastructure","inv","Invariant","json","eyJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLXRvZ2dsZS1sb2ctdmlldyI6IkFjdGl2YXRlcyBvciBkZWFjdGl2YXRlcyBsb2cgdmlldy4iLCJsYW5ndWFnZS10b29sYmFyLWlkZW50aWZ5LWZyZWVoYW5kLXRvb2x0aXAiOiJGaW5kIG91dCBhYm91dCBhbiBhcmVhIG9uIHRoZSBtYXAgZGVmaW5lZCBieSBhIGZyZWVoYW5kIHNoYXBlIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1zdGFydC1lZGl0aW5nLW5ldy1mZWF0dXJlIjoiQmVnaW5zIGVkaXRpbmcgYSBuZXcgZmVhdHVyZS4iLCJsYW5ndWFnZS1zdGF0ZXMtZmVhdHVyZS1lZGl0aW5nLXN0YXRlLWRlc2NyaXB0aW9uIjoiVGhlIGNyZWF0ZSBhIGZlYXR1cmUgdG9vbCBpcyBjdXJyZW50bHkgYWN0aXZlLiIsImxhbmd1YWdlLXRvb2xiYXItaWRlbnRpZnktcG9seWxpbmUtZGVzYy1rZXlib2FyZCI6IlRvIGxlYXJuIHdoYXRcdTIwMTlzIHRoZXJlLCB1c2UgYXJyb3dzIHRvIG1vdmUgdGhlIHBvaW50LiBIaXQgRU5URVIgdG8gcGxvdCBhbmQgYmVnaW4gbW92aW5nIHRoZSBuZXh0IHBvaW50LiBIaXQgRU5URVIgdHdpY2UgdG8gZmluaXNoLiIsImxhbmd1YWdlLWNvbW1vbi1jcmVhdGUiOiJDcmVhdGUiLCJsYW5ndWFnZS1zeW1ib2xvZ3ktc2V0dGluZ3MtbWFya2VyLXN0eWxlLXgiOiJYIiwibGFuZ3VhZ2UtbWVudS1wcm9qZWN0cy1hY3Rpb25zLXJlZnJlc2gtZGVzYyI6IlJlZnJlc2ggdGhlIGxpc3Qgb2YgcHJvamVjdHMuIiwibGFuZ3VhZ2UtZ3JhbnQtZWRpdG9yLWdsb2JhbC1ncmFudC1uYW1lLXVzZXIiOiJFdmVyeW9uZSAoc2lnbi1pbiByZXF1aXJlZCkiLCJsYW5ndWFnZS1ncmFudC1lZGl0b3Itc2VhcmNoLXBsYWNlaG9sZGVyIjoiU2VhcmNoLi4uIiwibGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLWV4Y2VlZGVkLW1heC1jbGFzc2VzLXRpdGxlIjoiRXhjZWVkZWQgbWF4aW11bSB1bmlxdWUgdmFsdWVzIiwibGFuZ3VhZ2UtbWVudS1vZmZsaW5lLW1hcC1lZGl0b3ItZ2VvbWV0cnktYWN0aW9ucy1wb2x5Z29uLWRlc2MiOiJEcmF3IGEgcG9seWdvbiBmb3IgdGhlIGFyZWEgb2YgaW50ZXJlc3QgZ2VvbWV0cnkuIiwibGFuZ3VhZ2UtbGF5ZXJsaXN0LXZpc2libGUtYXQtZXh0ZW50IjoiQ3VycmVudGx5IHdpdGhpbiB2aXNpYmxlIHNjYWxlLiIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tc2hvdy1tYXAtdGlwLXJlc3VsdHMiOiJTaG93cyBtYXAgdGlwIHJlc3VsdHMgZm9yIGEgRmVhdHVyZVNldENvbGxlY3Rpb24gcHJldmlvdXNseSBhZGRlZCB0byB0aGUgRmVhdHVyZVNldE1hbmFnZXIuIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1vcGVuLXJlc3VsdHMtZnJhbWUiOiJBY3RpdmF0ZXMgdGhlIFJlc3VsdHNSZWdpb24uIiwibGFuZ3VhZ2Utc3RhdGVzLW1lYXN1cmUtc3RhdGUtZGVzY3JpcHRpb24iOiJUaGUgbWVhc3VyaW5nIHRvb2wgaXMgY3VycmVudGx5IGFjdGl2ZS4iLCJsYW5ndWFnZS1tZW51LXNvY2lhbC1saW5rcy1tZW51LWRlc2MiOiJTb2NpYWwgTGlua3MiLCJsYW5ndWFnZS1tZW51LWFkZC1hLWZlYXR1cmUiOiJDcmVhdGUgYSBmZWF0dXJlIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1oaWdobGlnaHQtZmVhdHVyZS1zZXQiOiJIaWdobGlnaHRzIGFsbCBvZiB0aGUgZmVhdHVyZXMgaW4gdGhlIHNwZWNpZmllZCBmZWF0dXJlIHNldCBpbiB0aGUgYWN0aXZlIGhpZ2hsaWdodCBsYXllci4iLCJsYW5ndWFnZS1wcm9qZWN0LWVycm9yLWRlbGV0ZS1kZW5pZWQiOiJZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byBkZWxldGUgdGhpcyBwcm9qZWN0LiIsImxhbmd1YWdlLW1lbnUtZHJhdy1wb2ludCI6IkRyYXcgYSBQb2ludCIsImxhbmd1YWdlLXRvb2xiYXItdGFza3MtdXBsb2FkLWRhdGEiOiJVcGxvYWQgRGF0YSIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tc2hvdy1yZXN1bHRzLWZlYXR1cmUtYWN0aW9uIjoiQ3JlYXRlcyBSZXN1bHRzTGlzdEZlYXR1cmVBY3Rpb25zVmlldyBhbmQgZGlzcGxheXMgdGhlIEZlYXR1cmUgQWN0aW9ucy4iLCJsYW5ndWFnZS1wYWdlLXRvdGFsIjoiVG90YWwiLCJsYW5ndWFnZS10b29sYmFyLW5hdmlnYXRpb24tcGFuLXRvb2x0aXAiOiJDYW5jZWwgYW55IGFjdGl2ZSB0b29scyBhbmQgcHV0IHRoZSBtYXAgaW50byBwYW4gbW9kZSIsImxhbmd1YWdlLXVpLXRhYmxlLXNvcnRlZC1kZXNjZW5kaW5nIjoiQ29sdW1uIGhlYWRlci4gezB9IC0gU29ydGVkIGRlc2NlbmRpbmcuIiwibGFuZ3VhZ2Utb2ZmbGluZS1wcm9ncmVzcy1iYXNlbWFwZXhwb3J0LWRvd25sb2FkaW5nIjoiezB9IC0gezF9IG9mIHsyfSAoezN9JSkgZG93bmxvYWRlZC4gezR9LiIsImxhbmd1YWdlLWNvbW1vbi1mZWF0dXJlLWVkaXRsb2ctZGVzYyI6IkRpc3BsYXlzIGluZm9ybWF0aW9uIGFib3V0IGVkaXRpbmcgaGlzdG9yeSBvZiB0aGUgZmVhdHVyZSBsYXllci4iLCJsYW5ndWFnZS1jb29yZGluYXRlcy1sb25naXR1ZGUtYWJicmV2IjoiTG9uIiwibGFuZ3VhZ2UtdG9vbGJhci1ncm91cC1hZHZhbmNlZC1tZWFzdXJlbWVudCI6IkFkdmFuY2VkIE1lYXN1cmVtZW50IiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi16b29tLXRvLWZlYXR1cmUiOiJab29tcyB0byBhIGZlYXR1cmUuIiwibGFuZ3VhZ2UtbWludXRlcy1hYmJyIjoiTSIsImxhbmd1YWdlLXRvb2xiYXItZ3JvdXAtZmluZC1kYXRhIjoiRmluZCBEYXRhIiwibGFuZ3VhZ2Utd2VibWFwLWxheWVyLW5hbWUtcG9seWdvbiI6IlBvbHlnb25zIiwibGFuZ3VhZ2UtbWVudS1zaG93LXJlc3VsdHMtbGlzdCI6Ikxpc3QgVmlldyIsImxhbmd1YWdlLW1lbnUtY2VudGVyLXRleHRtYXAtZGVzYyI6IkNlbnRlciB0aGUgbWFwIG9uIHRoZSBwb2ludCBzcGVjaWZpZWQuIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1mZWF0dXJlLWxheWVyLW1vZHVsZS1yZWZyZXNoLWRhdGEiOiJSZWZyZXNoZXMgbGF5ZXIgZWRpdCBzdW1tYXJpZXMgYW5kIHRoZSBcInN5bmMgbmVlZGVkXCIgZmxhZy4iLCJsYW5ndWFnZS10b29sYmFyLWdyb3VwLWFuYWx5c2lzIjoiQW5hbHlzaXMiLCJsYW5ndWFnZS1tZW51LXRpdGxlIjoiSSB3YW50IHRvLi4uIiwibGFuZ3VhZ2UtdG9vbGJhci10YWItdG9vbHMiOiJUb29scyIsImxhbmd1YWdlLXRvb2xiYXItaW5mb3JtYXRpb24tYWN0aW9ucyI6IkluZm9ybWF0aW9uICYgQWN0aW9ucyIsImxhbmd1YWdlLW1lbnUtb2ZmbGluZS1tYXAtZWRpdG9yLWdlb21ldHJ5LWFjdGlvbnMtZWxsaXBzZS1kZXNjIjoiRHJhdyBhbiBlbGxpcHNlIGZvciB0aGUgYXJlYSBvZiBpbnRlcmVzdCBnZW9tZXRyeS4iLCJsYW5ndWFnZS1jb21tb24tZmVhdHVyZS1sYXllci1kZXRhaWxzIjoiU3luYyBTZXR0aW5ncyBmb3IgezB9IiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1zaG93LXJlc3VsdHMtdGFibGUiOiJEaXNwbGF5cyB0aGUgbGlzdCBvZiBmZWF0dXJlcyBpbiB0aGUgZ2l2ZW4gZmVhdHVyZSBzZXQgY29sbGVjdGlvbiBpbiBhIHRhYnVsYXIgdmlldy4iLCJsYW5ndWFnZS1tZW51LW9mZmxpbmUtbWFwLWVkaXRvci1nZW9tZXRyeS1hY3Rpb25zLWN1cnJlbnRleHRlbnQiOiJDdXJyZW50IEV4dGVudCIsImxhbmd1YWdlLXRvb2xiYXItaWRlbnRpZnktc25hcHBpbmctdG9vbHRpcCI6IkVuYWJsZS9EaXNhYmxlIHNuYXBwaW5nIHdoaWxlIGlkZW50aWZ5aW5nIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1hZGQtbWFya3VwIjoiQWRkcyB0aGUgZ2l2ZW4gZ2VvbWV0cnkgdG8gdGhlIG1hcmt1cCBsYXllci4iLCJsYW5ndWFnZS1tZW51LXJlbW92ZS11c2VyLWFkZGVkLW1hcHNlcnZpY2UtZGVzYyI6IlJlbW92ZSB0aGlzIHVzZXIgYWRkZWQgc2VydmljZSBmcm9tIHRoZSBtYXAuIiwibGFuZ3VhZ2UtcmVzdWx0cy1leHBvcnQtdG8tY29uZmlybS10aXRsZSI6IkRvd25sb2FkIFwiLnswfVwiIGZpbGUiLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLWhpZ2hsaWdodC1mZWF0dXJlIjoiSGlnaGxpZ2h0cyB0aGUgZmVhdHVyZSBpbiB0aGUgYWN0aXZlIGhpZ2hsaWdodCBsYXllci4iLCJsYW5ndWFnZS10b29sYmFyLW1hcmt1cC1kcmF3aW5nLXRvb2xzIjoiRHJhdyIsImxhbmd1YWdlLXRvb2xiYXItZ3JvdXAtbWVhc3VyZW1lbnQiOiJNZWFzdXJlIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1zdGVwLXpvb20tb3V0IjoiWm9vbXMgb3V0IGEgc3RlcCIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tY2xlYXItc3RvcmFnZS1mb3ItYXBwbGljYXRpb24iOiJDbGVhcnMgdGhlIG9mZmxpbmUgZGF0YSBmb3IgdGhlIGN1cnJlbnQgYXBwbGljYXRpb24uIiwibGFuZ3VhZ2UtdG9vbGJhci10YXNrcy11cGxvYWQtZGF0YS10b29sdGlwIjoiVXBsb2FkIGxheWVycyBmcm9tIHlvdXIgY29tcHV0ZXIgb250byB0aGUgbWFwIiwibGFuZ3VhZ2UtbWVudS1zaG93LWNoYXJ0aW5nLXZpZXciOiJDaGFydGluZyBWaWV3IiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1jbGVhci1kZWZhdWx0LWhpZ2hsaWdodHMiOiJSZW1vdmVzIHRoZSBoaWdobGlnaHRzIGZyb20gdGhlIGRlZmF1bHQgaGlnaGxpZ2h0IGxheWVyLiIsImxhbmd1YWdlLW1lbnUtem9vbS1vdXQiOiJab29tIG91dCIsImxhbmd1YWdlLW1lbnUtbWFwdGlwLWFjdGlvbnMtZGVzYyI6Ik1hcFRpcCBBY3Rpb25zIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1ydW4td29ya2Zsb3ctd2l0aC1hcmd1bWVudHMiOiJSdW5zIGEgd29ya2Zsb3cgd2l0aCBhIHNldCBvZiBpbnB1dCBhcmd1bWVudHMuIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1jaGFuZ2UtZWRpdC1sb2ctZW50cnkiOiJDaGFuZ2UgYW4gZXhpc3RpbmcgZWRpdCBsb2cgZW50cnkuIiwibGFuZ3VhZ2UtbGF5ZXItYWN0aW9ucy10b29sdGlwIjoiQ2xpY2sgdG8gc2VlIGxheWVyIGFjdGlvbnMgYXZhaWxhYmxlIGZvciB7MH0gbGF5ZXIiLCJsYW5ndWFnZS10b29sYmFyLW1hcmt1cC1yZWN0YW5nbGUtdG9vbHRpcCI6IkRyYXcgYSByZWN0YW5nbGUgb24gdGhlIG1hcCIsImxhbmd1YWdlLXRvb2xiYXItbWFya3VwLWZyZWVoYW5kLWRlc2MiOiJIb2xkIHRoZSBtb3VzZSBidXR0b24gb3IgeW91ciBmaW5nZXJ0aXAgZG93biwgdGhlbiBkcmF3IGEgZnJlZWhhbmQgbGluZS4iLCJsYW5ndWFnZS10b29sYmFyLXNuYXBwaW5nLWRpc2FibGUiOiJEaXNhYmxlIFNuYXBwaW5nIiwibGFuZ3VhZ2UtbGF5ZXJsaXN0LWRlZmF1bHQtZm9sZGVyLXRpdGxlIjoiTGF5ZXIgTGlzdCBGb2xkZXIiLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLWNvbmZpcm0iOiJEaXNwbGF5cyBhIGNvbmZpcm0uIiwibGFuZ3VhZ2UtdWktdGFibGUtdW5zb3J0ZWQiOiJDb2x1bW4gaGVhZGVyLiB7MH0gLSBVbnNvcnRlZCIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tdXBkYXRlLWZlYXR1cmUiOiJVcGRhdGVzIGVpdGhlciBhIG5ldyBvciBleGlzdGluZyBmZWF0dXJlLiIsImxhbmd1YWdlLW9mZmxpbmUtcHJvZ3Jlc3Mta2lsb2J5dGVzIjoiezB9IGtCIiwibGFuZ3VhZ2UtbWVudS1idWZmZXItaWRlbnRpZnktZmVhdHVyZS1kZXNjIjoiSWRlbnRpZnkgbmVhcmJ5IGZlYXR1cmVzIiwibGFuZ3VhZ2UtdG9vbGJhci1tYXJrdXAtZWxsaXBzZS10b29sdGlwIjoiRHJhdyBhbiBlbGxpcHNlIG9uIHRoZSBtYXAiLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLWZzbS1jb2xsZWN0aW9uLXNldC1jb21tYW5kIjoiU2V0IHRoZSBwcmVmZXJyZWQgY29tbWFuZCB0byBvcGVuIHRoZSBmZWF0dXJlIHNldCBjb2xsZWN0aW9uIGZvciB0aGUgZ2l2ZW4gc291cmNlIG5hbWUuIiwibGFuZ3VhZ2UtdG9vbGJhci10YXNrcy1wcmludC1tYXAtdG9vbHRpcCI6IkNyZWF0ZSBhIHByaW50YWJsZSB2ZXJzaW9uIG9mIHRoZSBtYXAiLCJsYW5ndWFnZS10b29sYmFyLWdyb3VwLWFyY2dpcyI6IkFyY0dJUyIsImxhbmd1YWdlLXRvb2xiYXItbWVudS1nbG9iYWwtc2F2ZSI6IlNhdmUiLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLXRvZ2dsZS1kYXRhLWZyYW1lIjoiQWN0aXZhdGVzIG9yIGRlYWN0aXZhdGVzIGRhdGEgZnJhbWUuIiwibGFuZ3VhZ2Utb2ZmbGluZS1wcm9ncmVzcy1iYXNlbWFwZG93bmxvYWQtY29tcGxldGVkIjoiezB9IGRvd25sb2FkZWQuIiwibGFuZ3VhZ2UtY29tbW9uLWRlbGV0ZSI6IkRlbGV0ZSIsImxhbmd1YWdlLW1lbnUtcmVzdWx0cy1hZGQtZmVhdHVyZS1kZXNjIjoiQWRkIHRoaXMgZmVhdHVyZSB0byB0aGUgY3VycmVudCBzZXQgb2YgcmVzdWx0cyIsImxhbmd1YWdlLXN5bWJvbG9neS1zZXR0aW5ncy1saW5lLXN0eWxlLWRvdCI6IkRvdCIsImxhbmd1YWdlLWNvbW1vbi1kb25lIjoiRG9uZSIsImxhbmd1YWdlLW9mZmxpbmUtcHJvZ3Jlc3MtYnl0ZXMtcGVyLXNlY29uZCI6InswfSBieXRlcy9zIiwibGFuZ3VhZ2UtdG9vbGJhci1zaG93LWxheWVybGlzdC1kZXNjIjoiRGlzcGxheSB0aGUgbGlzdCBvZiBhdmFpbGFibGUgbGF5ZXJzIiwibGFuZ3VhZ2UtbWVudS1nbG9iYWwtc2VhcmNoLWRlc2MiOiJTZWFyY2ggZm9yIGZlYXR1cmVzIG9uIHRoZSBtYXAuIiwibGFuZ3VhZ2UtbWVudS1lbnRlci1vZmZsaW5lIjoiR28gdG8gb2ZmbGluZSBtb2RlIiwibGFuZ3VhZ2UtbWVudS1jb21iaW5lLXJlc3VsdHMtaW50ZXJzZWN0LWRlc2MiOiJPbmx5IHNob3cgcmVzdWx0cyB0aGF0IGFyZSBpbiBib3RoIHlvdXIgY3VycmVudCBsaXN0IGFuZCBhIHNhdmVkIHNldCBvZiByZXN1bHRzIiwibGFuZ3VhZ2UtdG9vbGJhci10YXNrcy1zaGFyZSI6IlNoYXJlIiwibGFuZ3VhZ2UtY29udGVudC1wb2xpY3ktcHJvbXB0LXVyaS1yZWplY3QtYnRuIjoiTm8sIGRvIG5vdCBsb2FkIiwibGFuZ3VhZ2UtdG9vbGJhci1pZGVudGlmeS1wb2x5Z29uLWRlc2Mta2V5Ym9hcmQiOiJUbyBsZWFybiB3aGF0XHUyMDE5cyB0aGVyZSwgdXNlIGFycm93cyB0byBtb3ZlIHRoZSBwb2ludC4gSGl0IEVOVEVSIHRvIHBsb3QgYW5kIGJlZ2luIG1vdmluZyB0aGUgbmV4dCBwb2ludC4gSGl0IEVOVEVSIHR3aWNlIHRvIGZpbmlzaC4iLCJsYW5ndWFnZS1tZW51LXJlc3VsdHMtcmVtb3ZlLWZlYXR1cmUiOiJSZW1vdmUgZnJvbSBSZXN1bHRzIiwibGFuZ3VhZ2UtdG9vbGJhci1tYXJrdXAtdGV4dCI6IlRleHQiLCJsYW5ndWFnZS1zdGF0ZXMtc25hcHBpbmctZGVzY3JpcHRpb24iOiJTbmFwcGluZyBpcyBlbmFibGVkIGZvciB0aGUgY3VycmVudCB0b29sLiIsImxhbmd1YWdlLXRvb2xiYXItbWFya3VwLXBvaW50LWRlc2Mta2V5Ym9hcmQiOiJVc2UgYXJyb3dzIHRvIG1vdmUgdGhlIHBvaW50LiBIaXQgRU5URVIgdG8gYWRkIGl0IHRvIHRoZSBtYXAuIiwibGFuZ3VhZ2Utb2ZmbGluZS1lcnJvcnMtYnVuZGxlb2ZmaWxpbmUiOiJDYW5ub3QgY3JlYXRlIGEgYnVuZGxlIHdoaWxlIG9mZmxpbmUuIiwibGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLW5vZGF0YSI6Ik5vIHN5bWJvbGl6YWJsZSBkYXRhIHdhcyBmb3VuZCBpbiB0aGUgc2VsZWN0ZWQgYXR0cmlidXRlLiIsImxhbmd1YWdlLW1lbnUtY29tYmluZS1yZXN1bHRzLXN1YnRyYWN0IjoiU3VidHJhY3Qgc2F2ZWQgcmVzdWx0cyIsImxhbmd1YWdlLXRvb2xiYXItZ3JvdXAtZWRpdGluZyI6IkVkaXQgRHJhd2luZ3MiLCJsYW5ndWFnZS1wcm9qZWN0LWVycm9yLXRpdGxlIjoiUHJvamVjdCBFcnJvciIsImxhbmd1YWdlLWNvb3JkaW5hdGVzLXNvdXRoLWFiYnJldiI6IlMiLCJsYW5ndWFnZS1zdGF0ZXMtcGxvdGNvb3JkaW5hdGVzLXN0YXRlLWRlc2NyaXB0aW9uIjoiVGhlIFBsb3QgQ29vcmRpbmF0ZXMgdG9vbCBpcyBjdXJyZW50bHkgYWN0aXZlLiIsImxhbmd1YWdlLXJlc3VsdHMtbWVudS1kZXNjcmlwdGlvbiI6IkZlYXR1cmUgQWN0aW9ucyBmb3IgUmVzdWx0cyBMaXN0IiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1zdGVwLXpvb20taW4iOiJab29tcyBpbiBhIHN0ZXAiLCJsYW5ndWFnZS1tYXBzZXJ2aWNlLWFjdGlvbnMtdGl0bGUiOiJNYXAgU2VydmljZSBBY3Rpb25zIiwibGFuZ3VhZ2UtY29vcmRpbmF0ZXMtbm9ydGgtYWJicmV2IjoiTiIsImxhbmd1YWdlLWNvbW1vbi1zYXZpbmciOiJTYXZpbmcuLi4iLCJsYW5ndWFnZS1tZW51LWFkZC1hLWZlYXR1cmUtZGVzYyI6IkNyZWF0ZSBhIG5ldyBmZWF0dXJlIG9uIHRoaXMgbGF5ZXIuIiwibGFuZ3VhZ2UtdG9vbGJhci1tYXJrdXAtZWRpdC1kZXNjIjoiQ2xpY2sgb3IgdGFwIGFuIGV4aXN0aW5nIGRyYXdpbmcgdG8gYmVnaW4gZWRpdGluZyBpdC4iLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLXRvZ2dsZS12aWV3IjoiQWN0aXZhdGVzIG9yIGRlYWN0aXZhdGVzIGEgdmlldy4iLCJsYW5ndWFnZS10b29sYmFyLWlkZW50aWZ5LWZyZWVoYW5kIjoiRnJlZWhhbmQiLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLXRha2UtYXBwbGljYXRpb24tb25saW5lIjoiQ29ubmVjdHMgdGhlIGFwcGxpY2F0aW9uIHRvIHRoZSBpbnRlcm5ldC4iLCJsYW5ndWFnZS10b29sYmFyLWlkZW50aWZ5LXBvbHlsaW5lIjoiTGluZSIsImxhbmd1YWdlLWNvbW1vbi1kZWFjdGl2YXRlLXRvb2wiOiJEZWFjdGl2YXRlIFRvb2wiLCJsYW5ndWFnZS10b29sYmFyLW11bHRpdG9vbCI6Ik11bHRpLXRvb2wiLCJsYW5ndWFnZS1tZW51LXNob3ctY2hhcnRpbmctdmlldy1kZXNjIjoiU3dpdGNoIHRvIGNoYXJ0aW5nIHZpZXciLCJsYW5ndWFnZS1tZW51LWxhYmVsLW9wdGlvbnMiOiJDdXN0b21pemUgbGFiZWxzIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1hZGQtdGV4dC1tYXJrdXAiOiJQcm9tcHRzIHRoZSB1c2VyIGZvciB0ZXh0IHRvIGFkZCBhcyBtYXJrdXAuIFdoZW4gY29tcGxldGVkLCB0ZXh0IG1hcmt1cCBpcyBhZGRlZCBhdCB0aGUgcHJvdmlkZWQgZ2VvbWV0cnkuIiwibGFuZ3VhZ2UtdG9vbGJhci10b2dnbGUtYnVmZmVyLW9mZi1uYW1lIjoiQnVmZmVyaW5nIE9uIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi16b29tLW91dC10by1leHRlbnQiOiJab29tcyBvdXQgdG8gdGhlIGdpdmVuIGV4dGVudC4iLCJsYW5ndWFnZS1tZW51LW1hcHRpcC1hY3Rpb25zLXZpZXctZGV0YWlscy1kZXNjIjoiVmlldyBhZGRpdGlvbmFsIGRldGFpbHMgYWJvdXQgdGhpcyBmZWF0dXJlIiwibGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLWZpbGwtc3R5bGUtdmVydGljYWwiOiJWZXJ0aWNhbCIsImxhbmd1YWdlLW1lbnUtcnVuLXdvcmtmbG93IjoiUGVyZm9ybSBhIHRhc2siLCJsYW5ndWFnZS1wYWdlLWRpc3BsYXlpbmciOiJEaXNwbGF5aW5nIiwibGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLWZpbGwtc3R5bGUtY3Jvc3MiOiJDcm9zcyIsImxhbmd1YWdlLWdyYW50LWVkaXRvci10YWJsZS1oZWFkZXItbm9uZSI6Ik5vbmUiLCJsYW5ndWFnZS1vZmZsaW5lLXByb2dyZXNzLW1lZ2FieXRlcy1wZXItc2Vjb25kIjoiezB9IE1CL3MiLCJsYW5ndWFnZS10b29sYmFyLWVkaXRpbmctbWFuYWdlLW9mZmxpbmUtZGF0YSI6Ik1hbmFnZSBPZmZsaW5lIERhdGEiLCJsYW5ndWFnZS10b29sYmFyLXRhc2tzLWFkZC1sYXllcnMtdG9vbHRpcCI6IkFkZCBsYXllcnMgdG8gdGhlIG1hcCIsImxhbmd1YWdlLXBhZ2UtZmlyc3QiOiJGaXJzdCBwYWdlIiwibGFuZ3VhZ2UtdG9vbGJhci1ncm91cC10b29scyI6IlRvb2xzIiwibGFuZ3VhZ2UtdG9vbGJhci1lZGl0aW5nLWNyZWF0ZS1uZXctZmVhdHVyZS1nZW9sb2NhdGlvbiI6IlVzZSBHZW9sb2NhdGlvbiIsImxhbmd1YWdlLXN5bWJvbG9neS1zZXR0aW5ncy1icmVha3MiOiJOdW1iZXIgT2YgQ2xhc3NlczoiLCJsYW5ndWFnZS10b29sYmFyLWVkaXRpbmctZGF0YSI6IkRhdGEiLCJsYW5ndWFnZS1vZmZsaW5lLXByb2dyZXNzLXJlbW92aW5nb2ZmbGluZW1hcCI6IlJlbW92aW5nIG9mZmxpbmUgbWFwLiIsImxhbmd1YWdlLW1lbnUtY2VudGVyLW1hcCI6IkNlbnRlciB0aGUgTWFwIEhlcmUiLCJsYW5ndWFnZS1tZW51LXJlc3VsdHMtdGFibGUtYWN0aW9ucy1kZXNjIjoiUmVzdWx0cyBUYWJsZSBBY3Rpb25zIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1vcGVuLWZlYXR1cmUtc2V0LWNvbGxlY3Rpb24iOiJPcGVucyB0aGUgZmVhdHVyZSBzZXQgY29sbGVjdGlvbi4iLCJsYW5ndWFnZS1jb21tb24tbm90aWZpY2F0aW9uIjoiTm90aWZpY2F0aW9uIiwibGFuZ3VhZ2UtbGF5ZXJzZWxlY3Rvci1pY29uLXRvb2x0aXAiOiJ7MH0gaWNvbiIsImxhbmd1YWdlLXN0YXRlcy1kZWZhdWx0LWRlc2NyaXB0aW9uIjoiVGhlIHZpZXdlciBjdXJyZW50bHkgaGFzIG5vdGhpbmcgYWN0aXZlLiIsImxhbmd1YWdlLXRvb2xiYXItaWRlbnRpZnktcG9pbnQtZGVzYyI6IkNsaWNrIG9yIHRhcCBhIGxvY2F0aW9uIG9uIHRoZSBtYXAgdG8gbGVhcm4gd2hhdFx1MjAxOXMgdGhlcmUuIiwibGFuZ3VhZ2UtdG9vbGJhci1idWZmZXJpbmctZW5hYmxlIjoiRW5hYmxlIGJ1ZmZlcmluZyIsImxhbmd1YWdlLXN5bWJvbG9neS1zZXR0aW5ncy1saW5lLXN0eWxlLXNob3J0ZGFzaGRvdCI6IlNob3J0LWRhc2gtZG90IiwibGFuZ3VhZ2UtdG9vbGJhci1pZGVudGlmeS1wb2x5Z29uLXRvb2x0aXAiOiJEcmF3IGEgY3VzdG9tIHNoYXBlIG9uIHRoZSBtYXAgdG8gZmluZCBvdXQgYWJvdXQgYW4gYXJlYSIsImxhbmd1YWdlLXRvb2xiYXItc2VsZWN0LWxheWVycy10b2dnbGUtb2ZmLW5hbWUiOiJMYXllcnMgYXJlIEZpbHRlcmVkIiwibGFuZ3VhZ2Utb2ZmbGluZS1wcm9ncmVzcy1jb21wbGV0ZSI6IkNvbXBsZXRlLiIsImxhbmd1YWdlLW9mZmxpbmUtcHJvZ3Jlc3Mtc3RhcnRpbmctc3luYyI6IlN0YXJ0aW5nIGZlYXR1cmUgbGF5ZXIgc3luYy4iLCJsYW5ndWFnZS1tZW51LWV4cG9ydC1yZXN1bHRzLXRvLWNzdiI6IkV4cG9ydCB0byBDU1YiLCJsYW5ndWFnZS10b29sYmFyLW1hcmt1cC1jaXJjbGUtdG9vbHRpcCI6IkRyYXcgYSBjaXJjbGUgb24gdGhlIG1hcCIsImxhbmd1YWdlLW1lbnUtb2ZmbGluZS1tYXAtZWRpdG9yLWdlb21ldHJ5LWFjdGlvbnMtcmVjdGFuZ2xlLWRlc2MiOiJEcmF3IGEgcmVjdGFuZ2xlIGZvciB0aGUgYXJlYSBvZiBpbnRlcmVzdCBnZW9tZXRyeS4iLCJsYW5ndWFnZS1tZW51LWdsb2JhbC1vcGVuLWRlc2MiOiJDaG9vc2UgYSBwcmV2aW91c2x5IHNhdmVkIHByb2plY3QgdG8gcmVzdG9yZSB0aGUgc2F2ZWQgc3RhdGUiLCJsYW5ndWFnZS1wcm9qZWN0LWVycm9yLXJlYWQiOiJUaGUgcHJvamVjdCBjb3VsZCBub3QgYmUgb3BlbmVkLiBSZWZlciB0byB0aGUgbG9nIGZvciBtb3JlIGRldGFpbHMuIiwibGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLWNvbG9yIjoiQ29sb3IiLCJsYW5ndWFnZS1jb21tb24tZmVhdHVyZS10ZW1wbGF0ZS1waWNrZXItZGVzYyI6IlNlbGVjdCBhIGZlYXR1cmUgdHlwZS4iLCJsYW5ndWFnZS10b29sYmFyLTNyZC1wYXJ0eS1tYXBzLXNob3ctbWFwcy10b29sdGlwIjoiRGlzcGxheSBsaW5rZWQgbWFwcyBpbiB0aGUgZXh0ZXJuYWwgY29tcG9uZW50IHZpZXciLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLWNsZWFyLW1hcmt1cC1xdWlldCI6IkNsZWFycyBhbGwgb2YgdGhlIG1hcmt1cCBmcm9tIHRoZSBtYXJrdXAgbGF5ZXIgd2l0aG91dCBwcm9tcHRpbmcgZm9yIGNvbmZpcm1hdGlvbi4iLCJsYW5ndWFnZS1tZW51LXBsb3QtY29vcmRpbmF0ZS1kZXNjIjoiUGxvdCBhIGNvb3JkaW5hdGUgb24gdGhlIG1hcC4iLCJsYW5ndWFnZS10b29sYmFyLWJ1ZmZlcmluZy1hbHQtZW5hYmxlIjoiRW5hYmxlIGJ1ZmZlcmluZyBmb3IgYWN0aXZlIHRvb2wiLCJsYW5ndWFnZS10b29sYmFyLWlkZW50aWZ5LWxheWVycy1jaGFuZ2UiOiJJZGVudGlmaWFibGUgTGF5ZXJzIiwibGFuZ3VhZ2UtdG9vbGJhci1pZGVudGlmeS1wb2x5bGluZS10b29sdGlwIjoiRmluZCBvdXQgYWJvdXQgYW4gYXJlYSBvbiB0aGUgbWFwIGRlZmluZWQgYnkgYSBsaW5lIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1jbGVhci10ZW1wb3JhcnktbWFya3VwIjoiUmVtb3ZlcyB0ZW1wb3JhcnkgbWFya3VwIGNyZWF0ZWQgYnkgQWRkVGVtcG9yYXJ5TWFya3VwR2VvbWV0cnkuIiwibGFuZ3VhZ2UtbWVudS1jb21iaW5lLXJlc3VsdHMtZGVzYyI6IlBlcmZvcm0gYWR2YW5jZWQgb3BlcmF0aW9ucyB3aXRoIG11bHRpcGxlIGxpc3RzIG9mIHJlc3VsdHMiLCJsYW5ndWFnZS10b29sYmFyLW1hcmt1cC1yZWN0YW5nbGUiOiJSZWN0YW5nbGUiLCJsYW5ndWFnZS1vZmZsaW5lLWVycm9ycy1pc2FjdGl2ZSI6IkNhbm5vdCByZW1vdmUgdGhlIGFjdGl2ZSBvZmZsaW5lIG1hcC4iLCJsYW5ndWFnZS10b29sYmFyLXRhYi1lZGl0aW5nIjoiRWRpdGluZyIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tc2V0LWhpZ2hsaWdodC1maWxsLWNvbG9yIjoiU2V0cyB0aGUgZmlsbCBjb2xvciB1c2VkIGZvciBuZXcgaGlnaGxpZ2h0cywgc3BlY2lmaWVkIGluIDYgb3IgOCBkaWdpdCBoZXggaW4gUkdCIG9yIEFSR0IgZm9ybS4iLCJsYW5ndWFnZS10b29sYmFyLWFuYWx5c2lzLWxvY2F0aW9uLWluZm9ybWF0aW9uIjoiTG9jYXRpb24gSW5mb3JtYXRpb24iLCJsYW5ndWFnZS1zeW1ib2xvZ3ktc2V0dGluZ3MtbGluZS1zdHlsZS1kYXNoZG90ZG90IjoiRGFzaC1kb3QtZG90IiwibGFuZ3VhZ2UtbWVudS1sYWJlbC1vcHRpb25zLXRvZ2dsZSI6IlRvZ2dsZSBsYWJlbHMiLCJsYW5ndWFnZS1ncmFudC1lZGl0b3ItbW9uaWtlci10eXBlLXJvbGUiOiJHcm91cHMiLCJsYW5ndWFnZS1vZmZsaW5lLXByb2dyZXNzLWJhc2VtYXBleHBvcnQtcHJvY2Vzc2luZyI6InswfSBnZW5lcmF0aW5nLi4uIiwibGFuZ3VhZ2UtdG9vbGJhci1uYXZpZ2F0aW9uLXpvb20taW4iOiJab29tIEluIiwibGFuZ3VhZ2UtbWVudS1yZXN1bHRzLWFkZC1mZWF0dXJlIjoiQWRkIHRvIFJlc3VsdHMiLCJsYW5ndWFnZS10b29sYmFyLWNsZWFyLWFsbCI6IkNsZWFyIiwibGFuZ3VhZ2Utb2ZmbGluZS1wcm9ncmVzcy1iYXNlbWFwZXhwb3J0LWZhaWxlZCI6InswfSBmYWlsZWQuIHsxfSIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tZmVhdHVyZS1sYXllci1jbGVhci1jYWNoZS1zcGVjIjoiU3BlY2lmeSB0aGlzIGxheWVyIGFzIG5vdCB0byBiZSBjYWNoZWQgb24gbmV4dCBzeW5jLiIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tcmVtb3ZlLWhpZ2hsaWdodC1sYXllciI6IlJlbW92ZXMgdGhlIGhpZ2hsaWdodCBsYXllciB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZSwgaWYgdGhlcmUgaXMgb25lLiIsImxhbmd1YWdlLXRvb2xiYXItYXJjZ2lzLXZpZXctbXktY29udGVudC10b29sdGlwIjoiVmlldyB5b3VyIGNvbnRlbnQgc3RvcmVkIGluIEFyY0dJUyIsImxhbmd1YWdlLXN5bWJvbG9neS1zZXR0aW5ncy1tYXJrZXItc3R5bGUtZGlhbW9uZCI6IkRpYW1vbmQiLCJsYW5ndWFnZS1zeW1ib2xvZ3ktc2V0dGluZ3MtbGluZS1zdHlsZSI6IkxpbmUgU3R5bGUiLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLXNob3ctbWFwLWNhbGxvdXQiOiJEaXNwbGF5cyBhIG1hcCBjYWxsb3V0IGFuY2hvcmVkIHRvIGEgZ2l2ZW4gcG9pbnQuIiwibGFuZ3VhZ2UtdG9vbGJhci10YXNrcy1wcmludGluZyI6IlByaW50aW5nIiwibGFuZ3VhZ2UtdG9vbGJhci1tYXJrdXAtZHJhd2luZyI6IkNyZWF0ZSIsImxhbmd1YWdlLWNvbnRlbnQtcG9saWN5LXByb21wdC11cmktYWNjZXB0LWJ0biI6IlllcyIsImxhbmd1YWdlLXRvb2xiYXItbWFya3VwLWNoYW5nZS1tYXJrdXAtc3R5bGUiOiJTdHlsZXMiLCJsYW5ndWFnZS10b29sYmFyLW5hdmlnYXRpb24tZnVsbC1leHRlbnQtdG9vbHRpcCI6IlJldHVybiB0byB0aGUgZnVsbCBleHRlbnQgb2YgdGhlIG1hcCIsImxhbmd1YWdlLXJlc3VsdHMtZXhwb3J0LXRvLWNvbmZpcm0tY29udGVudCI6IlRoZSBcIi57MH1cIiBmaWxlIGlzIGFib3V0IHRvIGJlIGRvd25sb2FkZWQuIENvbmZpcm0/IiwibGFuZ3VhZ2UtbWVudS1mb290ZXItbWVudS1kZXNjIjoiRm9vdGVyIE1lbnUiLCJsYW5ndWFnZS1tYXBzZXJ2aWNlLWFjdGlvbnMtZGVzYyI6IkRpc3BsYXkgYSBsaXN0IG9mIG1hcCBzZXJ2aWNlIGFjdGlvbnMiLCJsYW5ndWFnZS1tZW51LW1hcC1sYXllcnMtZXhwYW5kIjoiRXhwYW5kIGFuZCBjb2xsYXBzZSB7MH0gbGF5ZXIgZ3JvdXAiLCJsYW5ndWFnZS10b29sYmFyLW1hcmt1cC1mcmVlaGFuZC1wb2x5Z29uLXRvb2x0aXAiOiJEcmF3IGEgZnJlZWhhbmQgc2hhcGUgb24gdGhlIG1hcCIsImxhbmd1YWdlLXRvb2xiYXItbWVudS1nbG9iYWwtc2F2ZS1hcy1kZXNjIjoiU2F2ZSB0aGUgc3RhdGUgb2YgeW91ciB2aWV3ZXIgaW4gYSBuZXcgcHJvamVjdCIsImxhbmd1YWdlLW9mZmxpbmUtcHJvZ3Jlc3MtZ2lnYWJ5dGVzIjoiezB9IEdCIiwibGFuZ3VhZ2UtbWVudS16b29tLXRvLXZpc2libGUtc2NhbGUiOiJab29tIHRvIHZpc2libGUgc2NhbGUiLCJsYW5ndWFnZS1wcm9qZWN0LWVycm9yLXJlYWQtZGVuaWVkIjoiWW91IGRvIG5vdCBoYXZlIHBlcm1pc3Npb24gdG8gb3BlbiB0aGlzIHByb2plY3QuIiwibGFuZ3VhZ2UtbWVudS1hZGQtdGV4dC1kZXNjIjoiQWRkIHNvbWUgdGV4dCB0byB0aGUgbWFwLiIsImxhbmd1YWdlLW1lbnUtY29tYmluZS1yZXN1bHRzIjoiQ29tYmluZSBSZXN1bHRzIiwibGFuZ3VhZ2UtY29vcmRpbmF0ZXMtd2VzdC1hYmJyZXYiOiJXIiwibGFuZ3VhZ2UtbWVudS1ib29rbWFyay1hZGQtZGVzYyI6IkFkZCB0aGUgY3VycmVudCBtYXAgZXh0ZW50IHRvIHRoZSBsaXN0IG9mIGJvb2ttYXJrcywgc28gdGhhdCBJIGNhbiByZXR1cm4gdG8gaXQgbGF0ZXIuIiwibGFuZ3VhZ2UtdG9vbGJhci1lcmFzZSI6IkVyYXNlIiwibGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLW1hcmtlci1zdHlsZSI6Ik1hcmtlciBTdHlsZSIsImxhbmd1YWdlLXRvb2xiYXItbWFya3VwLWVsbGlwc2UtZGVzYyI6IkNsaWNrIGFuZCBkcmFnIHRvIGRyYXcgYW4gZWxsaXBzZSBvbiB0aGUgbWFwLiIsImxhbmd1YWdlLXN5bWJvbG9neS1zZXR0aW5ncy1maWxsLXN0eWxlLW51bGwiOiJOb25lIiwibGFuZ3VhZ2Utc2VhcmNoLWZzYy1kaXNwbGF5LW5hbWUiOiJTZWFyY2ggUmVzdWx0czogezB9IiwibGFuZ3VhZ2Utb2ZmbGluZS1lcnJvcnMtY2FuY2VsZWQiOiJDYW5jZWxlZC4iLCJsYW5ndWFnZS1vZmZsaW5lLXByb2dyZXNzLWJhc2VtYXBkb3dubG9hZC1jb25uZWN0aW5nIjoiezB9IGNvbm5lY3RpbmcuLi4iLCJsYW5ndWFnZS1tZW51LW9mZmxpbmUtbWFwLWVkaXRvci1nZW9tZXRyeS1hY3Rpb25zLWN1cnJlbnRleHRlbnQtZGVzYyI6IlVzZSB0aGUgY3VycmVudCBleHRlbnQgZm9yIHRoZSBhcmVhIG9mIGludGVyZXN0IGdlb21ldHJ5LiIsImxhbmd1YWdlLXRvb2xiYXItc25hcHBpbmctc2VsZWN0LWxheWVycyI6IlNlbGVjdCBTbmFwcGluZyBMYXllcnMiLCJsYW5ndWFnZS1tZW51LXNob3ctcmVzdWx0cy1saXN0LWRlc2MiOiJTd2l0Y2ggdG8gTGlzdCBWaWV3IiwibGFuZ3VhZ2UtdG9vbGJhci1ncm91cC1maW5kLWRhdGEtdG9vbHMiOiJGaW5kIiwibGFuZ3VhZ2UtdG9vbGJhci1uYXZpZ2F0aW9uLXpvb20taW4tdG9vbHRpcCI6IkRyYXcgYW4gYXJlYSBvbiB0aGUgbWFwIHRvIHpvb20gdG8iLCJsYW5ndWFnZS10b29sYmFyLWlkZW50aWZ5LXBvaW50LWRlc2Mta2V5Ym9hcmQiOiJVc2UgYXJyb3dzIHRvIG1vdmUgdGhlIHBvaW50LiBIaXQgRU5URVIgdG8gbGVhcm4gd2hhdFx1MjAxOXMgdGhlcmUuIiwibGFuZ3VhZ2UtdG9vbGJhci1pZGVudGlmeS1mcmVlaGFuZC1wb2x5Z29uIjoiRnJlZWhhbmQgU2hhcGUgSWRlbnRpZnkiLCJsYW5ndWFnZS1yZXN1bHRzLXBhZ2UiOiJQYWdlIiwibGFuZ3VhZ2UtbWVudS1jb21iaW5lLXJlc3VsdHMtdW5pb24tZGVzYyI6IkNvbWJpbmUgYSBzYXZlZCBzZXQgb2YgcmVzdWx0cyB3aXRoIHlvdXIgY3VycmVudCByZXN1bHRzIGxpc3QiLCJsYW5ndWFnZS1zeW1ib2xvZ3ktc2V0dGluZ3MtbGluZS13aWR0aCI6IkxpbmUgV2lkdGgiLCJsYW5ndWFnZS10b29sYmFyLWdyb3VwLWVkaXQiOiJFZGl0IiwibGFuZ3VhZ2UtbGF5ZXJsaXN0LXVzZXItYWRkZWQtbGF5ZXJzLWZvbGRlci10aXRsZSI6IlVzZXIgQWRkZWQgTGF5ZXJzIiwibGFuZ3VhZ2UtdG9vbGJhci1tYXJrdXAtcG9seWxpbmUtdG9vbHRpcCI6IkRyYXcgYSBsaW5lIG9uIHRoZSBtYXAiLCJsYW5ndWFnZS1tZW51LXJlbW92ZS11c2VyLWFkZGVkLWxheWVyIjoiUmVtb3ZlIGxheWVyIiwibGFuZ3VhZ2UtdG9vbGJhci1tYXJrdXAtY2lyY2xlIjoiQ2lyY2xlIiwibGFuZ3VhZ2Utb2ZmbGluZS1wcm9ncmVzcy1tZWdhYnl0ZXMiOiJ7MH0gTUIiLCJsYW5ndWFnZS1zbWFydC1wYW5lbC1tYXhpbWl6ZS1yZXN0b3JlIjoiTWF4aW1pemUvUmVzdG9yZSBQYW5lbCIsImxhbmd1YWdlLXRvb2xiYXItZWRpdGluZy10b29scyI6IkVkaXQgRmVhdHVyZXMiLCJsYW5ndWFnZS1tZW51LXJ1bi1yZXBvcnQiOiJSdW4gYSBSZXBvcnQiLCJsYW5ndWFnZS1zeW1ib2xvZ3ktc2V0dGluZ3MtdHJhbnNwYXJlbmN5IjoiVHJhbnNwYXJlbmN5IiwibGFuZ3VhZ2UtdG9vbGJhci10aW1lc2xpZGVyLXNob3d0aW1lc2xpZGVyIjoiVGltZSBTbGlkZXIiLCJsYW5ndWFnZS1vZmZsaW5lLXByb2dyZXNzLXNhdmluZ29mZmxpbmVtYXAiOiJTYXZpbmcgb2ZmbGluZSBtYXAuIiwibGFuZ3VhZ2UtdG9vbGJhci1tYXJrdXAtZGVsZXRlLXRvb2x0aXAiOiJEZWxldGUgYW4gZXhpc3RpbmcgZHJhd2luZyIsImxhbmd1YWdlLWdyYW50LWVkaXRvci10YWJsZS1oZWFkZXItdmlldyI6IlZpZXciLCJsYW5ndWFnZS1jb21tb24tZmVhdHVyZS10ZW1wbGF0ZS1waWNrZXIiOiJDcmVhdGUgTmV3IEZlYXR1cmUiLCJsYW5ndWFnZS1tYXBzZXJ2aWNlLWFjdGlvbnMiOiJQZXJmb3JtIGFuIGFjdGlvbiBvbiB7MH0iLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLWluaXRpYWxpemUtc2l0ZSI6IlRlbGxzIHRoZSBHZW9jb3J0ZXggRXNzZW50aWFscyBTaXRlIG9iamVjdCB0byBiZWdpbiBpbml0aWFsaXphdGlvbi4iLCJsYW5ndWFnZS1tZW51LWxhYmVsLW9wdGlvbnMtdG9nZ2xlLWRlc2MiOiJUdXJuIHRoZSBsYXllcidzIGxhYmVscyBvbiBvciBvZmYuIiwibGFuZ3VhZ2UtdG9vbGJhci1pZGVudGlmeS1mcmVlaGFuZC1wb2x5Z29uLXRvb2x0aXAiOiJJZGVudGlmeSB0aGluZ3Mgb24gdGhlIG1hcCBieSBkcmF3aW5nIGEgZnJlZWhhbmQgc2hhcGUiLCJsYW5ndWFnZS10b29sYmFyLW5hdGl2ZS1zaG93b2ZmbGluZW1hcHMiOiJPZmZsaW5lIE1hcHMiLCJsYW5ndWFnZS1tZW51LXJ1bi13b3JrZmxvdy1kZXNjIjoiU2VsZWN0IGZyb20gYSBsaXN0IG9mIGF2YWlsYWJsZSB0YXNrcy4iLCJsYW5ndWFnZS10b29sYmFyLWdyb3VwLWxheWVycyI6IkxheWVycyIsImxhbmd1YWdlLXN5bWJvbG9neS1zZXR0aW5ncy1saW5lLXN0eWxlLXNob3J0ZGFzaGRvdGRvdCI6IlNob3J0LWRhc2gtZG90LWRvdCIsImxhbmd1YWdlLW1lbnUtYnVmZmVyLWlkZW50aWZ5LWZlYXR1cmUiOiJTaG93IEJ1ZmZlciBPcHRpb25zIiwibGFuZ3VhZ2UtcHJvamVjdC1lcnJvci13cml0ZS1kZW5pZWQiOiJZb3UgZG8gbm90IGhhdmUgcGVybWlzc2lvbiB0byBzYXZlIHRoaXMgcHJvamVjdC4iLCJsYW5ndWFnZS1zeW1ib2xvZ3ktc2V0dGluZ3MtbGluZS1zdHlsZS1zaG9ydGRhc2giOiJTaG9ydC1kYXNoIiwibGFuZ3VhZ2UtdG9vbGJhci1vcGVuLXRvb2xiYXIiOiJPcGVuIHRvb2xiYXIiLCJsYW5ndWFnZS1vZmZsaW5lLWVycm9ycy1sb2FkZmFpbGVkIjoiVW5hYmxlIHRvIGxvYWQuIiwibGFuZ3VhZ2UtdG9vbGJhci10YWItbWFwIjoiTWFwIiwibGFuZ3VhZ2UtdG9vbGJhci1pZGVudGlmeS1mcmVlaGFuZC1kZXNjIjoiQ2xpY2svdGFwIGFuZCBob2xkIGRvd24sIHRoZW4gZHJhdyBhIGZyZWVoYW5kIHNoYXBlIHRvIGxlYXJuIHdoYXRcdTIwMTlzIHRoZXJlLiIsImxhbmd1YWdlLW1lbnUtc3dpdGNoLXRvLWxheWVybGlzdC1kZXNjIjoiRGlzcGxheSB0aGUgbGlzdCBvZiBhdmFpbGFibGUgbGF5ZXJzIiwibGFuZ3VhZ2UtdG9vbGJhci1uYXZpZ2F0aW9uIjoiTmF2aWdhdGlvbiIsImxhbmd1YWdlLXByb2plY3QtZXJyb3ItcmVhZC1ub3QtZm91bmQiOiJDb3VsZCBub3QgZmluZCBhIHByb2plY3Qgd2l0aCBJRCBcInswfVwiLiIsImxhbmd1YWdlLXRvb2xiYXItbWVudS1nbG9iYWwtb3BlbiI6Ik9wZW4iLCJsYW5ndWFnZS1zeW1ib2xvZ3ktc2V0dGluZ3MtbGluZS1zdHlsZS1sb25nZGFzaGRvdCI6IkxvbmctZGFzaC1kb3QiLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLWRlbGV0ZS1mZWF0dXJlIjoiRGVsZXRlcyBlaXRoZXIgYSBuZXcgb3IgZXhpc3RpbmcgZmVhdHVyZS4iLCJsYW5ndWFnZS10b29sYmFyLW5hdmlnYXRpb24tZnVsbC1leHRlbnQiOiJGdWxsIEV4dGVudCIsImxhbmd1YWdlLXRvb2xiYXItdGFza3MtcHJpbnQtbWFwIjoiUHJpbnQiLCJsYW5ndWFnZS1zZWNvbmRzLWFiYnIiOiJTIiwibGFuZ3VhZ2UtdG9vbGJhci1ncm91cC1lZGl0LWZlYXR1cmVzIjoiRWRpdCBGZWF0dXJlcyIsImxhbmd1YWdlLWxheWVybGlzdC1vcGVyYXRpb25hbC1tYXBzLWZvbGRlci10aXRsZSI6Ik9wZXJhdGlvbmFsIExheWVycyIsImxhbmd1YWdlLXRvb2xiYXItdGFza3MtaWRlbnRpZnktdG9vbHRpcCI6IkZpbmQgZGF0YSBvbiB0aGUgbWFwIiwibGFuZ3VhZ2UtbWVudS1nbG9iYWwtc2VhcmNoIjoiU2VhcmNoIiwibGFuZ3VhZ2UtdG9vbGJhci1hcmNnaXMtZXhwb3J0LXdlYi1tYXAiOiJTYXZlIHRvIEFyY0dJUyIsImxhbmd1YWdlLWNvbW1vbi1yZXN1bHRzLXVuaW9uLWNvbmZpcm1hdGlvbiI6Iid7MH0nIHVuaW9uZWQgd2l0aCB7MX0iLCJsYW5ndWFnZS1tZW51LXByb2plY3QtYWN0aW9ucy1kZXNjIjoiVmlldyBvcHRpb25zIHJlbGF0ZWQgdG8gdGhlIHByb2plY3QuIiwibGFuZ3VhZ2UtdG9vbGJhci1tYXJrdXAtcG9seWdvbi1kZXNjIjoiQ2xpY2sgb3IgdGFwIGxvY2F0aW9ucyB0byBkZWZpbmUgYSBwb2x5Z29uLiBEb3VibGUtY2xpY2svdGFwIHRvIGZpbmlzaC4iLCJsYW5ndWFnZS1yZXN1bHRzLXBhZ2Utb2YiOiJvZiIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24taWRlbnRpZnkiOiJFeGVjdXRlcyBhbiBpZGVudGlmeSBvcGVyYXRpb24gb24gYSBnZW9tZXRyeS4iLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLWFkZC10ZW1wb3JhcnktbWFya3VwLWdlb21ldHJ5IjoiQWRkcyBhIHRlbXBvcmFyeSBtYXJrdXAgZ3JhcGhpYyB0byB0aGUgbWFwLiBUaGUgQ2xlYXJUZW1wb3JhcnlNYXJrdXAgY29tbWFuZCB3aWxsIGNsZWFyIHRoaXMgbWFya3VwLiIsImxhbmd1YWdlLWNvbW1vbi1jbG9zZSI6IkNsb3NlIiwibGFuZ3VhZ2UtdG9vbGJhci1zbmFwcGluZy1lbmFibGUiOiJFbmFibGUgU25hcHBpbmciLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLWNsb3NlLXJlc3VsdHMtZnJhbWUiOiJEZWFjdGl2YXRlcyB0aGUgUmVzdWx0c1JlZ2lvbi4iLCJsYW5ndWFnZS1tZW51LWlkZW50aWZ5LWJ1ZmZlcmVkLWZlYXR1cmUtc2V0LWNvbGxlY3Rpb24tZGVzYyI6IklkZW50aWZ5IGZlYXR1cmVzIG5lYXIgdGhlc2UgcmVzdWx0cyIsImxhbmd1YWdlLXRvb2xiYXItZ3JvdXAtM3JkLXBhcnR5LW1hcHMiOiJMaW5rZWQgTWFwcyIsImxhbmd1YWdlLXN0YXRlcy1mZWF0dXJlLWVkaXRpbmctc3RhdGUtZ3JhcGhpYy1kZXNjcmlwdGlvbiI6IlRoZSBjcmVhdGUgYSBmZWF0dXJlIHRvb2wgaXMgY3VycmVudGx5IGVkaXRpbmcgYSBncmFwaGljLiIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tYWN0aXZhdGUtdmlldyI6IkFjdGl2YXRlcyBhIHZpZXcuIiwibGFuZ3VhZ2UtcmVzdWx0cy10b2dnbGUtdGFibGUtdmlldyI6IlN3aXRjaCB0byBUYWJsZSIsImxhbmd1YWdlLXJlc3VsdHMtdG9nZ2xlLWxpc3Qtdmlldy1kZXNjIjoiVmlldyByZXN1bHRzIGluIGxpc3QgZm9ybWF0IiwibGFuZ3VhZ2UtbWVudS16b29tLXRvLWxheWVyLWRlc2MiOiJab29tIHRoZSBtYXAgdG8gdGhlIGZ1bGwgZXh0ZW50IG9mIHRoZSBsYXllci4iLCJsYW5ndWFnZS10b29sYmFyLXRhYi1vZmZsaW5lIjoiT2ZmbGluZSIsImxhbmd1YWdlLXRvb2xiYXItbWVudS1nbG9iYWwtc2F2ZS1kZXNjIjoiU2F2ZSB0aGUgc3RhdGUgb2YgeW91ciB2aWV3ZXIgaW4gYSBwcm9qZWN0IiwibGFuZ3VhZ2UtbWVudS1zaG93LXJlc3VsdHMtdGFibGUtZGVzYyI6IlN3aXRjaCB0byBUYWJsZSBWaWV3IiwibGFuZ3VhZ2UtdG9vbGJhci1tZW51LWdsb2JhbC1zYXZlLWFzIjoiU2F2ZSBhcyIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tdXBkYXRlLWF0dGFjaG1lbnQiOiJVcGRhdGVzIGEgZmVhdHVyZSBhdHRhY2htZW50LiIsImxhbmd1YWdlLXN5bWJvbG9neS1zZXR0aW5ncy1saW5lLXN0eWxlLWRhc2hkb3QiOiJEYXNoLWRvdCIsImxhbmd1YWdlLWNvbW1vbi1yZXN1bHRzLXJlcGxhY2UtY29uZmlybWF0aW9uIjoiJ3swfScgcmVwbGFjZWQgd2l0aCB7MX0iLCJsYW5ndWFnZS1zeW1ib2xvZ3ktc2V0dGluZ3MtbWFya2VyLXNpemUiOiJNYXJrZXIgU2l6ZSIsImxhbmd1YWdlLW1lbnUtaWRlbnRpZnktcG9pbnQiOiJJZGVudGlmeSBieSBwb2ludCIsImxhbmd1YWdlLXRvb2xiYXItdGFiLWhvbWUiOiJIb21lIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1yZW1vdmUtc3RhdHVzIjoiUmVtb3ZlcyB0aGUgc3RhdHVzIGluZGljYXRvciBmcm9tIHRoZSBzY3JlZW4gd2l0aCB0aGUgc3BlY2lmaWVkIElELiIsImxhbmd1YWdlLW1lbnUtZXhwb3J0LXJlc3VsdHMtdG8teGxzeC1kZXNjIjoiRXhwb3J0IHJlc3VsdHMgdG8gWExTWCIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tdG9nZ2xlLXJlc3VsdHMtZnJhbWUiOiJBY3RpdmF0ZXMgb3IgZGVhY3RpdmF0ZXMgUmVzdWx0cyBmcmFtZS4iLCJsYW5ndWFnZS10b29sYmFyLW1hcmt1cC1lZGl0LXRvb2x0aXAiOiJFZGl0IGFuIGV4aXN0aW5nIGRyYXdpbmciLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLXJlbW92ZS1mZWF0dXJlLXNldC1jb2xsZWN0aW9uLWJ5LWlkIjoiUmVtb3ZlcyB0aGUgc3BlY2lmaWVkIGNvbGxlY3Rpb24gZnJvbSB0aGUgZmVhdHVyZSBzZXQgbWFuYWdlci4iLCJsYW5ndWFnZS1sYXllcnNlbGVjdG9yLXN0YXRlLXRvZ2dsZSI6IlRvZ2dsZSB7MH0gbGF5ZXIgdmlzaWJpbGl0eS4iLCJsYW5ndWFnZS10b29sYmFyLW5hdmlnYXRpb24taG9tZSI6IkhvbWUiLCJsYW5ndWFnZS1tZW51LWlkZW50aWZ5LWRlc2MiOiJDbGljaywgdGFwLCBvciBkcmF3IGEgcmVjdGFuZ2xlIG9uIHRoZSBtYXAgdG8gaWRlbnRpZnkgZmVhdHVyZXMuIiwibGFuZ3VhZ2UtbGF5ZXItYWN0aW9ucy1kZXNjIjoiRGlzcGxheSBhIGxpc3Qgb2YgbGF5ZXIgYWN0aW9ucyIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tcnVuLXdvcmtmbG93LXdpdGgtZ2VvbWV0cnkiOiJSdW5zIGEgd29ya2Zsb3cgd2l0aCBhIGdlb21ldHJ5IHVzZWQgYXMgYW4gaW5wdXQgYXJndW1lbnQuIiwibGFuZ3VhZ2UtdG9vbGJhci1uYXZpZ2F0aW9uLWluaXRpYWwtZXh0ZW50LXRvb2x0aXAiOiJSZXR1cm4gdG8gdGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIG1hcCIsImxhbmd1YWdlLWNvb3JkaW5hdGVzLWRlZ3JlZXMiOiLCsCIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tc2hvdy1mZWF0dXJlLWxheWVyLW1vZGFsLW1lc3NhZ2UiOiJDcmVhdGVzIGEgTW9kZWxNZXNzYWdlVmlldyB2aWV3IGFuZCBkaXNwbGF5cyB0aGUgZ2l2ZW4gbWVzc2FnZS4iLCJsYW5ndWFnZS1ncmFudC1lZGl0b3ItdGFibGUtaGVhZGVyLWVkaXQiOiJFZGl0IiwibGFuZ3VhZ2UtdG9vbGJhci1tYXJrdXAtZWRpdCI6IkVkaXQiLCJsYW5ndWFnZS1tZW51LW9mZmxpbmUtbWFwLWVkaXRvci1nZW9tZXRyeS1hY3Rpb25zLWNsZWFyIjoiQ2xlYXIiLCJsYW5ndWFnZS10b29sYmFyLXRhc2tzLXNoYXJlLXRvb2x0aXAiOiJTaGFyZSB0aGUgY3VycmVudCBtYXAgb24gdGhlIG1vc3QgY29tbW9uIHNvY2lhbCBtZWRpYSIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tc2V0LWVkaXRvci1mZWF0dXJlLWdlb21ldHJ5IjoiU2V0cyB0aGUgZ2VvbWV0cnkgb2YgdGhlIGZlYXR1cmUgdGhhdCBpcyBjdXJyZW50bHkgYmVpbmcgZWRpdGVkIGluIHRoZSBBdHRyaWJ1dGUgRWRpdG9yLCBhbmQgYWN0aXZhdGVzIHRoZSBBdHRyaWJ1dGVFZGl0b3IgVmlldy4iLCJsYW5ndWFnZS10b29sYmFyLXRpbWVzbGlkZXItc2hvd3RpbWVzbGlkZXItdG9vbHRpcCI6IkFjdGl2YXRlIHRoZSB0aW1lIHNsaWRlciIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tcGFuLXRvLWZlYXR1cmUiOiJQYW5zIHRvIHRoZSBHZW9jb3J0ZXggZmVhdHVyZS4iLCJsYW5ndWFnZS1tZW51LXZpc3VhbGl6YXRpb24iOiJUdXJuIG9uL29mZiBsYXllciB2aXN1YWxpemF0aW9ucyIsImxhbmd1YWdlLXRvb2xiYXItbWFya3VwLWZyZWVoYW5kLXBvbHlnb24tZGVzYyI6IkhvbGQgdGhlIG1vdXNlIGJ1dHRvbiBvciB5b3VyIGZpbmdlcnRpcCBkb3duLCB0aGVuIGRyYXcgYSBmcmVlaGFuZCBzaGFwZS4iLCJsYW5ndWFnZS1vZmZsaW5lLWVycm9ycy1idW5kbGVub3Rmb3VuZCI6IkJ1bmRsZSBub3QgZm91bmQuIiwibGFuZ3VhZ2UtY29tbW9uLXBhbi1kZXNjcmlwdGlvbiI6IlBhbiB0aGUgbWFwIHRvIGNlbnRlciB0aGlzIGZlYXR1cmUiLCJsYW5ndWFnZS1tZW51LW1hcHRpcC1hY3Rpb25zLXZpZXctZGV0YWlscyI6IlZpZXcgQWRkaXRpb25hbCBEZXRhaWxzIiwibGFuZ3VhZ2UtdG9vbGJhci1uYXZpZ2F0aW9uLXByZXZpb3VzLWV4dGVudCI6IlByZXZpb3VzIEV4dGVudCIsImxhbmd1YWdlLXRvb2xiYXItZ3JvdXAtbWVhc3VyZW1lbnQtdG9vbHMiOiJNZWFzdXJlIiwibGFuZ3VhZ2UtdG9vbGJhci1tYXJrdXAtcG9seWdvbi10b29sdGlwIjoiRHJhdyBhIGN1c3RvbSBzaGFwZSBvbiB0aGUgbWFwIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1kaXNwbGF5LXdvcmtmbG93LWNvbnRhaW5lci1jb250ZW50IjoiRGlzcGxheXMgYSB2aWV3IGluIGEgd29ya2Zsb3cgY29udGFpbmVyLiIsImxhbmd1YWdlLXRvb2xiYXItbWFya3VwLWVkaXQtZGVzYy1rZXlib2FyZCI6IlVzZSBhcnJvd3MgdG8gbW92ZSB0aGUgcG9pbnQuIEhpdCBFTlRFUiB0byBiZWdpbiBlZGl0aW5nIGFuIGV4aXN0aW5nIGRyYXdpbmcuIiwibGFuZ3VhZ2UtbWVudS1sYXRpdHVkZS1nZW9ncmFwaGljcy1kZXNjIjoiTGF0aXR1ZGUgR2VvZ3JhcGhpY3MgR3JvdXAgTHRkLiIsImxhbmd1YWdlLXRvb2xiYXItbWFya3VwLXBvaW50IjoiUG9pbnQiLCJsYW5ndWFnZS1jb29yZGluYXRlcy1lYXN0LWFiYnJldiI6IkUiLCJsYW5ndWFnZS1vZmZsaW5lLXByb2dyZXNzLWJhc2VtYXBkb3dubG9hZC1jYW5jZWxlZCI6InswfSBjYW5jZWxlZC4iLCJsYW5ndWFnZS1sYXllcnNlbGVjdG9yLWl0ZW0tZXhwYW5kIjoiQ29sbGFwc2Ugb3IgZXhwYW5kIHswfSBsYXllciBncm91cCIsImxhbmd1YWdlLXRvb2xiYXItYnVmZmVyLXRvZ2dsZS10b29sdGlwIjoiQnVmZmVyIGFuIGFyZWEgYXJvdW5kIHlvdXIgc2VsZWN0aW9uIiwibGFuZ3VhZ2UtbWVudS1nbG9iYWwtc2F2ZS1hcyI6IlNhdmUgYXMiLCJsYW5ndWFnZS10b29sYmFyLW1hcmt1cC1jaXJjbGUtZGVzYyI6IkRyYWcgYSBjaXJjbGUgb24gdG8gdGhlIG1hcCIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24taGlkZS1mZWF0dXJlLWxheWVyLW1vZGFsLW1lc3NhZ2UiOiJSZW1vdmVzIGEgbW9kYWwgbWVzc2FnZS4iLCJsYW5ndWFnZS1jb21tb24tc3luYy1jb21wbGV0ZSI6IlN5bmNocm9uaXphdGlvbiBjb21wbGV0ZSIsImxhbmd1YWdlLXN5bWJvbG9neS1zZXR0aW5ncy1saW5lLXdpZHRoLXN1ZmZpeCI6InB4IiwibGFuZ3VhZ2UtbWVudS1pZGVudGlmeS1mcmVlaGFuZC1kZXNjIjoiRHJhdyBhIHNoYXBlIHRvIHZpZXcgaW5mb3JtYXRpb24gYWJvdXQgdGhhdCBhcmVhLiIsImxhbmd1YWdlLXRvb2xiYXItbWFya3VwLXBhbGV0dGUtc21hbGwtZWRpdCI6IkVkaXQiLCJsYW5ndWFnZS1zeW1ib2xvZ3ktc2V0dGluZ3MtZmlsbC1zdHlsZS1iYWNrd2FyZC1kaWFnb25hbCI6IkJhY2t3YXJkIERpYWdvbmFsIiwibGFuZ3VhZ2UtbWVudS1zaG93LXJlc3VsdHMtdGFibGUiOiJUYWJsZSBWaWV3IiwibGFuZ3VhZ2UtbWVudS1nbG9iYWwtc2F2ZSI6IlNhdmUiLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLXNob3ctZmVhdHVyZS1kZXRhaWxzIjoiQ3JlYXRlcyBhbmQgZGlzcGxheXMgdGhlIEZlYXR1cmUgRGV0YWlscyBkaWFsb2cgZm9yIHRoZSBmZWF0dXJlIG9yIGZlYXR1cmUgc2V0IGNvbGxlY3Rpb24gc3BlY2lmaWVkLiIsImxhbmd1YWdlLXN5bWJvbG9neS1zZXR0aW5ncy1leGNlZWRlZC1tYXgtY2xhc3NlcyI6Ik1vcmUgdGhhbiB7MH0gdW5pcXVlIHZhbHVlcyB3ZXJlIGZvdW5kIGZvciB0aGlzIGF0dHJpYnV0ZS4gVGhlIHRvcCB7MH0gd2lsbCBiZSBzZWxlY3RlZCBhbmQgdXNlZCBmb3IgdGhlIHJlbmRlcmVyLiIsImxhbmd1YWdlLW1lbnUtYWRkLXRleHQiOiJBZGQgU29tZSBUZXh0IiwibGFuZ3VhZ2Utb2ZmbGluZS1lcnJvcnMtc2F2ZWZhaWxlZCI6IlVuYWJsZSB0byBzYXZlLiIsImxhbmd1YWdlLXRvb2xiYXItbmF2aWdhdGlvbi1uZXh0LWV4dGVudCI6Ik5leHQgRXh0ZW50IiwibGFuZ3VhZ2UtY29udGVudC1wb2xpY3ktcHJvbXB0LXVyaS1kZXNjIjoiVGhlIGFwcGxpY2F0aW9uIGlzIGF0dGVtcHRpbmcgdG8gbG9hZCBjb250ZW50IGZyb20gJ3swfScuIERvIHlvdSByZWNvZ25pemUgYW5kIHRydXN0IHRoaXMgVVJMPyIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tZ2VvbG9jYXRlIjoiWm9vbXMgdG8gdGhlIGN1cnJlbnQgbG9jYXRpb24gb2YgdGhlIGRldmljZS4iLCJsYW5ndWFnZS10b29sYmFyLWdyb3VwLW5hdmlnYXRpb24iOiJOYXZpZ2F0aW9uIiwibGFuZ3VhZ2UtdG9vbGJhci1tYXJrdXAtY2xlYXIiOiJDbGVhciIsImxhbmd1YWdlLXN0YXRlcy1pZGVudGlmeS1zdGF0ZS1kZXNjcmlwdGlvbiI6IlRoZSBpZGVudGlmeSB0b29sIGlzIGN1cnJlbnRseSBhY3RpdmUuIiwibGFuZ3VhZ2UtbWVudS1lbnRlci1vZmZsaW5lLWRlc2MiOiJHbyB0byBvZmZsaW5lIG1vZGUgYW5kIHZpZXcgY2FjaGVkIG1hcCBkYXRhLiIsImxhbmd1YWdlLW1lbnUtem9vbS1pbml0aWFsLWV4dGVudC1kZXNjIjoiUmV0dXJuIHRvIHRoZSBpbml0aWFsIG1hcCBwb3NpdGlvbiBhbmQgem9vbSBsZXZlbC4iLCJsYW5ndWFnZS1jb21tb24tcXVlcnktcmVzdWx0cyI6IlF1ZXJ5IFJlc3VsdHMiLCJsYW5ndWFnZS10b29sYmFyLXRhc2tzLWV4cG9ydC1tYXAtdG9vbHRpcCI6IlNhdmUgYSBtYXAgaW1hZ2UiLCJsYW5ndWFnZS1mcmFtZXdvcmstdWktdmlldy1jb250YWluZXItdmlldy1jbG9zZSI6IkNsb3NlIHswfSIsImxhbmd1YWdlLXRvb2xiYXItbWFya3VwLWZyZWVoYW5kLXRvb2x0aXAiOiJEcmF3IGEgZnJlZWhhbmQgbGluZSBvbiB0aGUgbWFwIiwibGFuZ3VhZ2UtdG9vbGJhci1tZW51LWdsb2JhbC1vcGVuLWRlc2MiOiJDaG9vc2UgYSBwcmV2aW91c2x5IHNhdmVkIHByb2plY3QgdG8gcmVzdG9yZSB0aGUgc2F2ZWQgc3RhdGUiLCJsYW5ndWFnZS10b29sYmFyLWlkZW50aWZ5LWxheWVycy1jaGFuZ2UtdG9vbHRpcCI6IkVuYWJsZS9EaXNhYmxlIGxheWVycyBzZWxlY3RlZCBmb3IgaWRlbnRpZnkgb3BlcmF0aW9ucyIsImxhbmd1YWdlLW1lbnUtb2ZmbGluZS1tYXAtZWRpdG9yLWdlb21ldHJ5LWFjdGlvbnMtY2xlYXItZGVzYyI6IkNsZWFyIHRoZSBhcmVhIG9mIGludGVyZXN0IGdlb21ldHJ5LiIsImxhbmd1YWdlLXJlc3VsdHMtZXhwb3J0LXRvLWFsZXJ0LWVycm9yLW1lc3NhZ2UiOiJFcnJvciBleHBvcnRpbmcgdG8gXCIuezB9XCIiLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLW1hcC1yZXNpemUiOiJUZWxscyB0aGUgbWFwIGNvbnRyb2wgdG8gcmVzaXplIGl0c2VsZi4gVGhpcyBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIGFsdGVyaW5nIHRoZSBtYXAgY29udGFpbmVyJ3MgZGltZW5zaW9ucy4iLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLWNsZWFyLXN0b3JhZ2UtZm9yLWRvbWFpbiI6IkNsZWFycyBhbGwgb2ZmbGluZSBkYXRhIGZvciB0aGUgY3VycmVudCBkb21haW4uIFRoaXMgaW5jbHVkZXMgZGF0YSBmb3IgYWxsIGFwcGxpY2F0aW9ucyBsb2FkZWQgZnJvbSB0aGUgY3VycmVudCBkb21haW4uIiwibGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLXRyYW5zcGFyZW5jeS1zdWZmaXgiOiIlIiwibGFuZ3VhZ2UtY29tbW9uLXBhbiI6IlBhbiIsImxhbmd1YWdlLW1lbnUtb2ZmbGluZS1tYXAtZWRpdG9yLWdlb21ldHJ5LWFjdGlvbnMtZnJlZWhhbmRwb2x5Z29uLWRlc2MiOiJEcmF3IGEgZnJlZWhhbmQgcG9seWdvbiBmb3IgdGhlIGFyZWEgb2YgaW50ZXJlc3QgZ2VvbWV0cnkuIiwibGFuZ3VhZ2Utb2ZmbGluZS1wcm9ncmVzcy1zdGFydGluZy1iYXNlbWFwLWRvd25sb2FkIjoiU3RhcnRpbmcgYmFzZW1hcCBkb3dubG9hZHMuIiwibGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLWxpbmUtc3R5bGUtbnVsbCI6Ik5vbmUiLCJsYW5ndWFnZS10b29sYmFyLW1hcmt1cC1lZGl0LXpvb21pbi10b29sIjoiWm9vbUluVG9vbCIsImxhbmd1YWdlLXN0YXRlcy1kcmF3LW1hcmt1cC1zdGF0ZS1kZXNjcmlwdGlvbiI6IlRoZSBkcmF3IHRvb2wgaXMgY3VycmVudGx5IGFjdGl2ZS4iLCJsYW5ndWFnZS10b29sYmFyLWlkZW50aWZ5LXBvbHlnb24iOiJQb2x5Z29uIiwibGFuZ3VhZ2UtY29tbW9uLWRlYnVnLWxvZy1rZXlzIjoiVG8gdmlldyB0aGUgbG9nIG9uIGEgZGVza3RvcCBtYWNoaW5lLCBwcmVzcyBDdHJsICsgU2hpZnQgKyB+LiBPbiBhIG1vYmlsZSBkZXZpY2UsIHByZXNzIGFuZCBob2xkIHRoZSB0b29sYmFyLiIsImxhbmd1YWdlLWNvbW1vbi12aWV3LWxvZyI6IlZpZXcgTG9nIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1hY3RpdmF0ZS1jb250YWluZXJzLWZvci13b3JrZmxvdyI6IkFjdGl2YXRlcyBhbnkgd29ya2Zsb3cgY29udGFpbmVyIHZpZXdzIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIHdvcmtmbG93LiIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tc2V0LWVkaXQtbG9nIjoiU2V0cyB0aGUgZWRpdCBsb2csIHBhc3NpbmcgaXQgaW50byBhIGNhbGxiYWNrLiBJZiBhbiBlcnJvciBvY2N1cnMsIHRoZSBlcnJvciBpcyBwYXNzZWQgaW50byB0aGUgY2FsbGJhY2suIiwibGFuZ3VhZ2UtdG9vbGJhci1uYXZpZ2F0aW9uLWluaXRpYWwtZXh0ZW50IjoiSW5pdGlhbCBWaWV3IiwibGFuZ3VhZ2UtY29tbW9uLXNob3ciOiJTaG93IiwibGFuZ3VhZ2UtY29tbW9uLWV4dHJhY3QtZGF0YSI6IkV4dHJhY3QgRGF0YSIsImxhbmd1YWdlLXJlc3VsdHMtdG9nZ2xlLWxpc3QtdmlldyI6IlN3aXRjaCB0byBMaXN0IiwibGFuZ3VhZ2UtdGFiLXNjcm9sbC1wcmV2IjoiUHJldmlvdXMgTGF5ZXIiLCJsYW5ndWFnZS1jb21tb24tcmVzdWx0cy1pbnRlcnNlY3QtY29uZmlybWF0aW9uIjoiJ3swfScgaW50ZXJzZWN0ZWQgd2l0aCB7MX0iLCJsYW5ndWFnZS10b29sYmFyLW1hcmt1cC1wb2x5bGluZSI6IkxpbmUiLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLXNob3ctbWFwLWVsZW1lbnQiOiJEaXNwbGF5cyBhbiBlbGVtZW50IGFuY2hvcmVkIHRvIGEgc3BlY2lmaWMgcG9pbnQgb24gdGhlIG1hcC4iLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLXJlY2VudGVyLW1hcC1vbi1uZXh0LW1hcC1yZXNpemUiOiJSZWNlbnRlcnMgdGhlIG1hcCB0byBpdHMgZXhpc3RpbmcgcG9zaXRpb24gdGhlIG5leHQgdGltZSB0aGUgbWFwIGlzIHJlc2l6ZWQuIiwibGFuZ3VhZ2UtdG9vbGJhci1tYXJrdXAtdGV4dC1kZXNjIjoiQ2xpY2sgYSBsb2NhdGlvbiB3aGVyZSB5b3Ugd2FudCB0byBhZGQgdGV4dCBvbiB0aGUgbWFwLiIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tY3JlYXRlLWF0dGFjaG1lbnQiOiJDcmVhdGVzIGEgZmVhdHVyZSBhdHRhY2htZW50LiIsImxhbmd1YWdlLXRvb2xiYXItZ3JvdXAtdGFza3MiOiJUYXNrcyIsImxhbmd1YWdlLXRvb2xiYXItYnVmZmVyaW5nLWFsdC1kaXNhYmxlIjoiRGlzYWJsZSBidWZmZXJpbmcgZm9yIGFjdGl2ZSB0b29sIiwibGFuZ3VhZ2UtbWVudS1wb3dlcmVkLWJ5LWdlb2NvcnRleCI6IlBvd2VyZWQgYnkgR2VvY29ydGV4IiwibGFuZ3VhZ2Utb2ZmbGluZS1wcm9ncmVzcy1iYXNlbWFwZG93bmxvYWQtZmFpbGVkIjoiQmFzZW1hcCAnezB9JyBmYWlsZWQgdG8gZG93bmxvYWQ6IHsxfSIsImxhbmd1YWdlLW1vbnRocy0xMSI6IkRlY2VtYmVyIiwibGFuZ3VhZ2UtbW9udGhzLTEwIjoiTm92ZW1iZXIiLCJsYW5ndWFnZS1sYXllcmxpc3QtZXhwYW5kIjoiQ29sbGFwc2Ugb3IgZXhwYW5kIHswfSBsYXllciBncm91cCIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tY3JlYXRlLWZlYXR1cmUiOiJDcmVhdGVzIGEgbmV3IGZlYXR1cmUuIiwibGFuZ3VhZ2UtY29tbW9uLXJlc3VsdHMtcmVtb3ZlZC1jb25maXJtYXRpb24iOiJ7MH0gcmVzdWx0KHMpIHJlbW92ZWQgZnJvbSAnezF9JyIsImxhbmd1YWdlLXRvb2xiYXItdGFiLWZpbGUiOiJGaWxlIiwibGFuZ3VhZ2UtY29vcmRpbmF0ZXMteSI6IlkiLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLWNyZWF0ZS1yZWxhdGVkLXJlY29yZCI6IkNyZWF0ZXMgYSByZWxhdGVkIHRhYmxlIHJlY29yZC4iLCJsYW5ndWFnZS10b29sYmFyLWVkaXRpbmctZWRpdCI6IkVkaXQiLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLXB1bHNlLXN0YXR1cyI6IlJlc2V0cyB0aGUgdGltZXIgb2YgdGhlIHN0YXR1cyB2aWV3TW9kZWwuIiwibGFuZ3VhZ2UtY29vcmRpbmF0ZXMteCI6IlgiLCJsYW5ndWFnZS1tZW51LXN3aXRjaC10by1sZWdlbmQiOiJTaG93IExlZ2VuZCIsImxhbmd1YWdlLW1lbnUtY29tYmluZS1yZXN1bHRzLXVuaW9uIjoiQWRkIHRvIHJlc3VsdHMiLCJsYW5ndWFnZS10b29sYmFyLW1hcmt1cC1wYWxldHRlLXNtYWxsLWRlbGV0ZSI6IkRlbGV0ZSIsImxhbmd1YWdlLXRvb2xiYXItZ3JvdXAtaG9tZSI6IkJhc2ljIFRvb2xzIiwibGFuZ3VhZ2UtdG9vbGJhci1hbmFseXNpcy1sb2NhdGlvbi1pbmZvIjoiTG9jYXRpb24gSW5mbyIsImxhbmd1YWdlLWNvbW1vbi1uby1yZXN1bHRzLWRlc2MiOiJJdGVtcyBhcHBlYXIgYWZ0ZXIgeW91IHBlcmZvcm0gYSB2YWxpZCBzZWFyY2ggb3Igb3RoZXIgdGFzayB0aGF0IHJldHVybnMgcmVzdWx0cy4iLCJsYW5ndWFnZS1tZW51LWdsb2JhbC1zYXZlLWRlc2MiOiJTYXZlIHRoZSBzdGF0ZSBvZiB5b3VyIHZpZXdlciBpbiBhIHByb2plY3QiLCJsYW5ndWFnZS1jb21tb24tZWRpdGluZyI6IkVkaXRpbmciLCJsYW5ndWFnZS1jb21tb24tcmVmcmVzaCI6IlJlZnJlc2giLCJsYW5ndWFnZS10b29sYmFyLW1hcmt1cC1wb2x5Z29uIjoiUG9seWdvbiIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tZGVzdHJveS12aWV3IjoiRGVzdHJveXMgYSB2aWV3LCB3aXBpbmcgb3V0IGl0cyBiaW5kaW5nIGFuZCBET00gc3Vic3RydWN0dXJlcy4iLCJsYW5ndWFnZS1jb21tb24tb2siOiJPSyIsImxhbmd1YWdlLXRvb2xiYXItaWRlbnRpZnktcG9seWdvbi1kZXNjIjoiVG8gbGVhcm4gd2hhdFx1MjAxOXMgdGhlcmUsIGRyYXcgYSBzaGFwZSBvbiB0aGUgbWFwLiBEb3VibGUtY2xpY2svdGFwIHRvIGZpbmlzaC4iLCJsYW5ndWFnZS1tZW51LW1hcC1jb250ZXh0LW1lbnUtdGl0bGUiOiJQb2ludCBPcHRpb25zIiwibGFuZ3VhZ2Utc3RhdGVzLWZlYXR1cmUtZWRpdGluZy1zdGF0ZS1wb2ludC1ncmFwaGljLWRlc2NyaXB0aW9uIjoiVGhlIGNyZWF0ZSBhIGZlYXR1cmUgdG9vbCBpcyBjdXJyZW50bHkgZWRpdGluZyBhIHBvaW50LWJhc2VkIGdyYXBoaWMuIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1oaWRlLW1hcC1lbGVtZW50IjoiUmVtb3ZlcyBhbiBlbGVtZW50IHByZXZpb3VzbHkgYW5jaG9yZWQgdG8gdGhlIG1hcCB1c2luZyBTaG93TWFwRWxlbWVudC4iLCJsYW5ndWFnZS1tZW51LXJ1bi1hLXdvcmtmbG93IjoiUGVyZm9ybSBhIHRhc2siLCJsYW5ndWFnZS10b29sYmFyLW5vdC1hdmFpbGFibGUiOiJUb29sYmFyIGlzIG5vdCBhdmFpbGFibGUiLCJsYW5ndWFnZS1zeW1ib2xvZ3ktc2V0dGluZ3MtZmlsbC1zdHlsZS1kaWFnb25hbC1jcm9zcyI6IkRpYWdvbmFsIENyb3NzIiwibGFuZ3VhZ2UtZ3JhbnQtZWRpdG9yLXJlbW92ZS1idXR0b24tdGl0bGUiOiJSZW1vdmUgdGhlIHVzZXIgb3IgZ3JvdXAiLCJsYW5ndWFnZS10b29sYmFyLW1hcmt1cC10ZXh0LXRvb2x0aXAiOiJBZGQgeW91ciBvd24gdGV4dCB0byB0aGUgbWFwIiwibGFuZ3VhZ2UtZXh0cmFjdC1kYXRhLWRlc2NyaXB0aW9uIjoiRXh0cmFjdCBmZWF0dXJlIGRhdGEgZnJvbSB0aGUgbWFwLiIsImxhbmd1YWdlLWNvbW1vbi12YWxpZGF0aW9uLXN5bWJvbCI6IioiLCJsYW5ndWFnZS1yZXN1bHRzLXNvcnQiOiJTb3J0IFJlc3VsdHMiLCJsYW5ndWFnZS1yZXN1bHRzLXBhZ2UtbmV4dCI6Ik5leHQgcGFnZSIsImxhbmd1YWdlLXRvb2xiYXItdGFza3MtZXhwb3J0LW1hcCI6IkV4cG9ydCIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tZ2V0LWZlYXR1cmUtZGV0YWlscy1wcm92aWRlcnMiOiJDcmVhdGVzIHZpZXcgZm9yIGFsbCBjb25maWd1cmVkIGZlYXR1cmUgZGV0YWlscyBwcm92aWRlcnMgYW5kIGVtYmVkcyB0aGVtIGludG8gZmVhdHVyZSBkZXRhaWxzIGRpYWxvZy4iLCJsYW5ndWFnZS1jb21tb24tZmVhdHVyZS1sYXllci1kZXRhaWxzLWRlc2MiOiJNYW5hZ2UgY2FjaGluZyBvZiBhIGZlYXR1cmUgbGF5ZXIgZm9yIG9mZmxpbmUgdXNlLiIsImxhbmd1YWdlLXRvb2xiYXItaWRlbnRpZnktcG9pbnQtdG9vbHRpcCI6IkZpbmQgb3V0IGFib3V0IGEgbG9jYXRpb24gb24gdGhlIG1hcCIsImxhbmd1YWdlLW9mZmxpbmUtcHJvZ3Jlc3Mta2lsb2J5dGVzLXBlci1zZWNvbmQiOiJ7MH0ga0IvcyIsImxhbmd1YWdlLWNvbnRlbnQtcG9saWN5LXByb21wdC11cmktdGl0bGUiOiJQb3RlbnRpYWxseSBVbnRydXN0ZWQgQ29udGVudCBFbmNvdW50ZXJlZCIsImxhbmd1YWdlLW1lbnUtcHJvamVjdC1kZWxldGUtcHJvamVjdC1kZXNjIjoiRGVsZXRlIHRoZSBjdXJyZW50IHByb2plY3QiLCJsYW5ndWFnZS1tZW51LW1hcC1sYXllcnMtZGVzYyI6IkFsdGVyIHZpc2liaWxpdHkgb2YgbWFwIGxheWVycywgcGVyZm9ybSBsYXllciBhY3Rpb25zLCBhbmQgdmlldyB0aGUgbGVnZW5kLiIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tcmVtb3ZlLWZlYXR1cmUtc2V0LWNvbGxlY3Rpb24iOiJSZW1vdmVzIHRoZSBzcGVjaWZpZWQgY29sbGVjdGlvbiBmcm9tIHRoZSBmZWF0dXJlIHNldCBtYW5hZ2VyLiIsImxhbmd1YWdlLXRvb2xiYXItZWRpdGluZy1jcmVhdGUtbmV3LWZlYXR1cmUiOiJDcmVhdGUgTmV3IEZlYXR1cmUiLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLWFkZC1zdGF0dXMiOiJBZGRzIGEgc3RhdHVzIGluZGljYXRvciB0byB0aGUgc2NyZWVuLiIsImxhbmd1YWdlLXRvb2xiYXItdG9nZ2xlLWJ1ZmZlci1vbi1uYW1lIjoiQnVmZmVyIE9wdGlvbnMiLCJsYW5ndWFnZS1tZW51LWFjY2Vzc2liaWxpdHktcGFuZWwiOiJWaWV3IHRoZSBhY2Nlc3NpYmlsaXR5IHBhbmVsIiwibGFuZ3VhZ2UtdG9vbGJhci1ncm91cC1kcmF3IjoiRHJhdyIsImxhbmd1YWdlLW1lbnUtb2ZmbGluZS1tYXAtZWRpdG9yLWdlb21ldHJ5LWFjdGlvbnMtZnJlZWhhbmRwb2x5Z29uIjoiRnJlZWhhbmQgUG9seWdvbiIsImxhbmd1YWdlLWNvbW1vbi1zaGFyZSI6IlNoYXJlIiwibGFuZ3VhZ2UtdG9vbGJhci1pZGVudGlmeS1wb2ludCI6IlBvaW50IiwibGFuZ3VhZ2UtdG9vbGJhci1tYXJrdXAtZHJhd2luZy1lZGl0LXRvb2xzIjoiRWRpdCIsImxhbmd1YWdlLXdlYm1hcC1sYXllci1uYW1lLXBvbHlsaW5lIjoiTGluZXMiLCJsYW5ndWFnZS1wYWdlLW5leHQiOiJOZXh0IHBhZ2UiLCJsYW5ndWFnZS1tZW51LWxpc3Qtb2ZmbGluZS1tYXBzLWFjdGlvbnMtcmVmcmVzaCI6IlJlZnJlc2giLCJsYW5ndWFnZS10b29sYmFyLW1hcmt1cC1mcmVlaGFuZC1wb2x5Z29uIjoiRnJlZWhhbmQgU2hhcGUiLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLWRlbGV0ZS1yZWxhdGVkLXJlY29yZCI6IkRlbGV0ZXMgYSByZWxhdGVkIHRhYmxlIHJlY29yZC4iLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLW9wZW4tZGF0YS1mcmFtZSI6Ik9wZW5zIHRoZSBEYXRhUmVnaW9uLCBpZiBwcmVzZW50IGluIHRoZSBjdXJyZW50IHNoZWxsLiIsImxhbmd1YWdlLXByb2plY3QtZXJyb3Itd3JpdGUiOiJUaGUgcHJvamVjdCBjb3VsZCBub3QgYmUgc2F2ZWQuIFJlZmVyIHRvIHRoZSBsb2cgZm9yIG1vcmUgZGV0YWlscy4iLCJsYW5ndWFnZS1tZW51LXJlc3VsdHMtcmVtb3ZlLWZlYXR1cmUtZGVzYyI6IlJlbW92ZSB0aGlzIGZlYXR1cmUgZnJvbSB0aGUgY3VycmVudCBzZXQgb2YgcmVzdWx0cyIsImxhbmd1YWdlLWNvbW1vbi13ZWxjb21lIjoiSG9tZSIsImxhbmd1YWdlLWNvbW1vbi1sb2dpbiI6IkxvZyBJbiIsImxhbmd1YWdlLXRvb2xiYXItdGl0bGUiOiJUb29sYmFyIiwibGFuZ3VhZ2UtbWVudS1tYXAtY29udGV4dC1tZW51LXRpdGxlLWRlc2MiOiJPcHRpb25zIHJlbGF0ZWQgdG8gYSBnaXZlbiBwb2ludCBvbiB0aGUgbWFwLiIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tem9vbS10by1pbml0aWFsLWV4dGVudCI6Ilpvb21zIHRvIHRoZSBpbml0aWFsIGV4dGVudCBvZiB0aGUgY3VycmVudCBTaXRlLiIsImxhbmd1YWdlLW1lbnUtaWRlbnRpZnkiOiJGaW5kIGRhdGEgb24gdGhlIG1hcCIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tY2xlYXItYWN0aXZlLXRvb2wiOiJDbGVhcnMgdGhlIGFjdGl2ZSB0b29sLiIsImxhbmd1YWdlLW1lbnUtcHJvamVjdC1lZGl0LXByb2plY3QtZGVzYyI6IkVkaXQgdGhlIGN1cnJlbnQgcHJvamVjdCIsImxhbmd1YWdlLXN0YXRlcy1lZGl0aW5nLXN0YXRlLWRlc2NyaXB0aW9uIjoiQSBkcmF3aW5nIGlzIGFjdGl2ZWx5IGJlaW5nIGVkaXRlZC4iLCJsYW5ndWFnZS1tYXBzZXJ2aWNlLWFjdGlvbnMtdG9vbHRpcCI6IkNsaWNrIHRvIHNlZSBhY3Rpb25zIGF2YWlsYWJsZSBmb3IgbWFwIHNlcnZpY2UgezB9IiwibGFuZ3VhZ2UtbWVudS1sYWJlbC1vcHRpb25zLWRlc2MiOiJUb2dnbGUgYW5kIGN1c3RvbWl6ZSB0aGUgbGF5ZXIncyBsYWJlbHMuIiwibGFuZ3VhZ2UtbWVudS1ib29rbWFyay1hZGQiOiJCb29rbWFyayBjdXJyZW50IG1hcCBleHRlbnQiLCJsYW5ndWFnZS1tZW51LXByb2plY3RzLWFjdGlvbnMtZGVzYyI6IlByb2plY3RzIEFjdGlvbnMiLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLXN0YXJ0LWVkaXRpbmctZWRpdC1sb2ctZW50cnkiOiJDcmVhdGVzIGEgYXZpZXcgdG8gY2hhbmdlIGFuIGV4aXN0aW5nIGVkaXQuIiwibGFuZ3VhZ2UtbWVudS16b29tLWluIjoiWm9vbSBpbiIsImxhbmd1YWdlLXRvb2xiYXItYXJjZ2lzLXZpZXctbXktY29udGVudCI6IlZpZXcgTXkgQ29udGVudCIsImxhbmd1YWdlLXRvb2xiYXItbmF2aWdhdGlvbi16b29tLWluLWRlc2MiOiJDbGljayBvciB0YXAsIHRoZW4gZHJhZyBhcmVhIG9mIGludGVyZXN0IG9uIHRoZSBtYXAuIE1hcCB3aWxsIHpvb20gdG8gdGhhdCBsb2NhdGlvbi4iLCJsYW5ndWFnZS1tZW51LW5vLWl0ZW1zIjoiTm8gbWVudSBvcHRpb25zLiIsImxhbmd1YWdlLXRvb2xiYXItaG9tZS1zdWIiOiJIb21lIiwibGFuZ3VhZ2UtbWVudS1vZmZsaW5lLW1hcC1lZGl0b3ItZ2VvbWV0cnktYWN0aW9ucy1kZXNjIjoiR2VvbWV0cnkgQWN0aW9ucyIsImxhbmd1YWdlLXRvb2xiYXItbWFya3VwLWRlbGV0ZSI6IkVyYXNlIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1yZWdpc3Rlci1zZWFyY2gtcHJvdmlkZXIiOiJSZWdpc3RlcnMgYSBzZWFyY2ggcHJvdmlkZXIgaWYgbm90IGFscmVhZHkgcmVnaXN0ZXJlZC4iLCJsYW5ndWFnZS1jb21tb24tc2F2ZSI6IlNhdmUiLCJsYW5ndWFnZS10b29sYmFyLXRhc2tzLWxheWVyLWNhdGFsb2ciOiJMYXllciBDYXRhbG9nIiwibGFuZ3VhZ2UtcmVzdWx0cy1kaXNwbGF5aW5nIjoiRGlzcGxheWluZyIsImxhbmd1YWdlLW9mZmxpbmUtcHJvZ3Jlc3MtYmFzZW1hcGRvd25sb2FkLWRvd25sb2FkaW5nIjoiezB9IC0gezF9IG9mIHsyfSAoezN9JSkgZG93bmxvYWRlZC4gezR9LiIsImxhbmd1YWdlLWdyYW50LWVkaXRvci1hZGQtYnV0dG9uLXRpdGxlIjoiQWRkIHRoZSB1c2VyIG9yIGdyb3VwIiwibGFuZ3VhZ2UtbWVudS16b29tLXRvLWxheWVyIjoiWm9vbSB0byBmdWxsIGV4dGVudCIsImxhbmd1YWdlLXN5bWJvbG9neS1zZXR0aW5ncy1saW5lLXN0eWxlLXNob3J0ZG90IjoiU2hvcnQtZG90IiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi16b29tLXRvLWVzcmktZmVhdHVyZS1zZXQiOiJab29tcyB0byB0aGUgZXh0ZW50IG9mIGFsbCB0aGUgZmVhdHVyZXMgaW4gdGhlIGZlYXR1cmUgc2V0LiIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tY2xvc2UtZGF0YS1mcmFtZSI6IkNsb3NlcyB0aGUgRGF0YVJlZ2lvbiwgaWYgaXQgaXMgcHJlc2VudCBpbiB0aGUgY3VycmVudCBzaGVsbC4iLCJsYW5ndWFnZS1tZW51LXJ1bi1yZXBvcnQtZGVzYyI6IlJ1biBhIFJlcG9ydCBvbiB0aGUgc2VsZWN0ZWQgcmVzdWx0cyIsImxhbmd1YWdlLXRvb2xiYXItZ3JvdXAtbmF0aXZlIjoiTmF0aXZlIiwibGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLW1hcmtlci1zdHlsZS1jaXJjbGUiOiJDaXJjbGUiLCJsYW5ndWFnZS10b29sYmFyLWVkaXRpbmctbWFuYWdlLW9mZmxpbmUtZGF0YS10b29sdGlwIjoiU2VsZWN0LCBzeW5jLCBhbmQgY2xlYXIgb2ZmbGluZSBkYXRhIiwibGFuZ3VhZ2UtY29vcmRpbmF0ZXMtc2Vjb25kcyI6IlwiIiwibGFuZ3VhZ2UtdG9vbGJhci10YXNrcy1hZGQtbGF5ZXJzIjoiQWRkIExheWVycyIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tc2hvdy1yZXN1bHRzLWxpc3QiOiJEaXNwbGF5cyB0aGUgbGlzdCBvZiBmZWF0dXJlcyBpbiB0aGUgZ2l2ZW4gZmVhdHVyZSBzZXQgY29sbGVjdGlvbiBhcyBhIGxpc3QuIiwibGFuZ3VhZ2UtY29tbW9uLWNhbmNlbCI6IkNhbmNlbCIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tc2V0LWFjdGl2ZS1oaWdobGlnaHQtbGF5ZXIiOiJTZXRzIHRoZSBsYXllciB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZSBhcyBhY3RpdmUsIGlmIHRoZXJlIGlzIG9uZS4iLCJsYW5ndWFnZS1tZW51LXpvb20tdG8tdmlzaWJsZS1zY2FsZS1kZXNjIjoiWm9vbSB0aGUgbWFwIHRvIGEgc2NhbGUgd2hlcmUgdGhlIGxheWVyIGlzIHZpc2libGUuIiwibGFuZ3VhZ2UtdG9vbGJhci10b29sYmFyIjoiVG9vbGJhciIsImxhbmd1YWdlLXRvb2xiYXItaWRlbnRpZnktcG9seWxpbmUtZGVzYyI6IlRvIGxlYXJuIHdoYXRcdTIwMTlzIHRoZXJlLCBkcmF3IGEgbGluZSBvZiBpbnRlcmVzdCBhbG9uZyB0aGUgbWFwLiBEb3VibGUtY2xpY2svdGFwIHRvIGZpbmlzaC4iLCJsYW5ndWFnZS1tZW51LXNhdmUtcmVzdWx0cyI6IlNhdmUgUmVzdWx0cyIsImxhbmd1YWdlLXN0YXRlcy1lZGl0aW5nLWFjdGl2ZS1zdGF0ZS1kZXNjcmlwdGlvbiI6IlRoZSBmZWF0dXJlIGVkaXRvciBpcyBjdXJyZW50bHkgYWN0aXZlLiIsImxhbmd1YWdlLXRvb2xiYXItZmluZC1kYXRhIjoiRmluZCBEYXRhIiwibGFuZ3VhZ2Utd2VibWFwLWZpZWxkLW5hbWUtdmlzaWJsZSI6IlZpc2libGUiLCJsYW5ndWFnZS1jb21tb24tc2hvdy1kZXRhaWxzLWRlc2NyaXB0aW9uIjoiU2VlIGFkZGl0aW9uYWwgZGV0YWlscyBmb3IgdGhpcyBmZWF0dXJlLiIsImxhbmd1YWdlLXN5bWJvbG9neS1zZXR0aW5ncy1maWxsLXN0eWxlLWZvcndhcmQtZGlhZ29uYWwiOiJGb3J3YXJkIERpYWdvbmFsIiwibGFuZ3VhZ2UtdG9vbGJhci1tYXJrdXAtZXhwb3J0IjoiRXhwb3J0IERyYXdpbmdzIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1mZWF0dXJlLWxheWVyLWNhY2hlLWRhdGEiOiJDYWNoZXMgdGhlIGRhdGEgZm9yIGEgZ2l2ZW4gbWFwIHNlcnZpY2UgVVJMLiIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tYWxsb3ctaGlkZS1mZWF0dXJlLWxheWVyLW1vZGFsLW1lc3NhZ2UiOiJTaG93IHRoZSBjbG9zZSBidXR0b24gb24gdGhlIE1vZGFsTWVzc2FnZVZpZXcgYWxsb3dpbmcgdGhlIHVzZXIgdG8gY2xvc2UgaXQuIiwibGFuZ3VhZ2UtdG9vbGJhci1tYXJrdXAtZGVsZXRlLWRlc2MiOiJDbGljayBvciB0YXAgdG8gaW1tZWRpYXRlbHkgYW5kIHBlcm1hbmVudGx5IGRlbGV0ZSBhIGRyYXdpbmcuIFRoaXMgY2Fubm90IGJlIHVuZG9uZS4iLCJsYW5ndWFnZS1tZW51LW1lbnVzLWRlc2NyaXB0aW9uIjoiSSBXYW50IFRvLi4uIE1lbnVzIiwibGFuZ3VhZ2UtbWVudS1saXN0LW9mZmxpbmUtbWFwcy1hY3Rpb25zLXJlZnJlc2gtZGVzYyI6IlJlZnJlc2ggdGhlIGxpc3Qgb2Ygb2ZmbGluZSBtYXBzLiIsImxhbmd1YWdlLXRvb2xiYXItZWRpdGluZy1jcmVhdGUtbmV3LWZlYXR1cmUtZ2VvbG9jYXRpb24tdG9vbHRpcCI6IkNyZWF0ZSBhIHBvaW50LWJhc2VkIGZlYXR1cmUgdXNpbmcgZ2VvbG9jYXRpb24iLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLWdldC1lZGl0LWxvZyI6IkdldHMgdGhlIGVkaXQgbG9nLCBwYXNzaW5nIGl0IGludG8gYSBjYWxsYmFjay4gSWYgYW4gZXJyb3Igb2NjdXJzLCB0aGUgZXJyb3IgaXMgcGFzc2VkIGludG8gdGhlIGNhbGxiYWNrLiIsImxhbmd1YWdlLWV4dHJhY3QtZGF0YSI6IkV4dHJhY3QgZGF0YSIsImxhbmd1YWdlLXdlYm1hcC1sYXllci1uYW1lLXBvaW50IjoiUG9pbnRzIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1jbGVhci1tYXJrdXAiOiJQcm9tcHRzIHRoZSB1c2VyIGZvciBjb25maXJtYXRpb24sIGFuZCBpZiBhcHByb3ZlZCwgY2xlYXJzIGFsbCBvZiB0aGUgbWFya3VwIGZyb20gdGhlIG1hcmt1cCBsYXllci4iLCJsYW5ndWFnZS10b29sYmFyLWNoYXJ0aW5nLXNob3ctY2hhcnRzLXRvb2x0aXAiOiJMYXVuY2ggdGhlIGNoYXJ0aW5nIHZpZXciLCJsYW5ndWFnZS1ncmFudC1lZGl0b3Itc2VhcmNoLXRpdGxlIjoiVHlwZSB5b3VyIHNlYXJjaCB0ZXJtcyIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24taGlnaGxpZ2h0LWZlYXR1cmUtZGVmYXVsdCI6IkhpZ2hsaWdodHMgdGhlIGZlYXR1cmUgaW4gdGhlIGRlZmF1bHQgaGlnaGxpZ2h0IGxheWVyLiIsImxhbmd1YWdlLWNvbW1vbi1zaG93LWRldGFpbHMiOiJTZWUgRGV0YWlscyIsImxhbmd1YWdlLXRvb2xiYXItZ3JvdXAtZ2xvYmFsLXRhc2tzIjoiR2xvYmFsIFRhc2tzIiwibGFuZ3VhZ2UtbWVudS1zaG93LWxvZy1kZXNjIjoiRGlzcGxheSB0aGUgdmlld2VyJ3MgbG9nLCBpbmNsdWRpbmcgZGlhZ25vc3RpYyBlcnJvcnMgYW5kIHRoZSB2ZXJzaW9uIG51bWJlci4iLCJsYW5ndWFnZS10b29sYmFyLWVkaXRpbmctY3JlYXRlLW5ldy1mZWF0dXJlLXRvb2x0aXAiOiJDcmVhdGUgYSBuZXcgZmVhdHVyZSBvbiB0aGUgbWFwIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1zaG93LWZlYXR1cmUtdGVtcGxhdGUtcGlja2VyIjoiU2hvd3MgdGhlIGZlYXR1cmUgdGVtcGxhdGUgcGlja2VyIHVzZWQgdG8gY3JlYXRlIG5ldyBmZWF0dXJlcy4gSWYgYSBsYXllciBpcyBzdXBwbGllZCwgc2hvd3MgdGhlIHRlbXBsYXRlcyBmb3IgdGhlIGxheWVyLiIsImxhbmd1YWdlLW1lbnUtcGxvdC1jb29yZGluYXRlIjoiUGxvdCBhIENvb3JkaW5hdGUiLCJsYW5ndWFnZS1zeW1ib2xvZ3ktc2V0dGluZ3MtdGl0bGUiOiJTeW1ib2xvZ3kgU2V0dGluZ3MiLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLWRlbGV0ZS1hdHRhY2htZW50IjoiRGVsZXRlcyBhIGZlYXR1cmUgYXR0YWNobWVudC4iLCJsYW5ndWFnZS1vZmZsaW5lLXByb2dyZXNzLWRvd25sb2FkaW5nc2l0ZSI6IkRvd25sb2FkaW5nIHNpdGUgcmVzb3VyY2VzLiIsImxhbmd1YWdlLWNvbW1vbi1yZXN1bHRzLWFkZGVkLWNvbmZpcm1hdGlvbiI6InswfSByZXN1bHQocykgYWRkZWQgdG8gJ3sxfSciLCJsYW5ndWFnZS1jb29yZGluYXRlcy1sYXRpdHVkZS1hYmJyZXYiOiJMYXQiLCJsYW5ndWFnZS1zdGF0ZXMtdHJhbnNpZW50LWFjdGl2ZS1kZXNjcmlwdGlvbiI6IkF0IGxlYXN0IG9uZSB0cmFuc2llbnQgdG9vbGJhciBpcyBjdXJyZW50bHkgb3Blbi4iLCJsYW5ndWFnZS1ncmFudC1lZGl0b3ItYWRkLWJ1dHRvbi10ZXh0IjoiQWRkIiwibGFuZ3VhZ2UtcmVzdWx0cy1leHBvcnQtdG8tc3RhdHVzLW1lc3NhZ2UiOiJFeHBvcnRpbmcgdG8gXCIuezB9XCIiLCJsYW5ndWFnZS1zeW1ib2xvZ3ktc2V0dGluZ3MtbWFya2VyLXN0eWxlLWNyb3NzIjoiQ3Jvc3MiLCJsYW5ndWFnZS1tZW51LWhvbWUtcGFuZWwtZGVzYyI6IlZpZXcgaW5mb3JtYXRpb24gYWJvdXQgdGhpcyBhcHBsaWNhdGlvbi4iLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLWFsZXJ0IjoiRGlzcGxheXMgYW4gYWxlcnQuIiwibGFuZ3VhZ2UtY29tbW9uLWZlYXR1cmUtZWRpdGluZy1kZXNjIjoiRWRpdCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgZmVhdHVyZSBhbmQgc2F2ZSB0aGVtLiIsImxhbmd1YWdlLW1lbnUtcG93ZXJlZC1ieS1nZW9jb3J0ZXgtZGVzYyI6IlBvd2VyZWQgYnkgR2VvY29ydGV4IiwibGFuZ3VhZ2UtbWVudS1hY2Nlc3NpYmlsaXR5LXBhbmVsLWRlc2MiOiJWaWV3IGluZm9ybWF0aW9uIGFib3V0IHRoZSBhY2Nlc3NpYmlsaXR5IG9mIHRoaXMgYXBwbGljYXRpb24uIiwibGFuZ3VhZ2UtcmVzdWx0cy1wYWdlLWZpcnN0IjoiRmlyc3QgcGFnZSIsImxhbmd1YWdlLW1lbnUtem9vbS1pbml0aWFsLWV4dGVudCI6IlJldHVybiB0byBpbml0aWFsIG1hcCBleHRlbnQiLCJsYW5ndWFnZS10b29sYmFyLWlkZW50aWZ5LWZyZWVoYW5kLXBvbHlnb24tZGVzYyI6IkRyYXcgYSBmcmVlaGFuZCBzaGFwZSBvbiB0aGUgbWFwIHRvIHNlZSB3aGF0J3MgdGhlcmUiLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLWRlbGV0ZS1mcm9tLWVkaXQtbG9nIjoiUmVtb3ZlcyB0aGUgZ2l2ZW4gZW50cnkgZnJvbSB0aGUgZWRpdCBsb2csIHRoZW4gc2V0cyB0aGUgZWRpdCBsb2cuIiwibGFuZ3VhZ2UtbGF5ZXJsaXN0LWJhc2UtbWFwcy1mb2xkZXItdGl0bGUiOiJCYXNlbWFwcyIsImxhbmd1YWdlLW9mZmxpbmUtcHJvZ3Jlc3MtYmFzZW1hcGV4cG9ydC1jb25uZWN0aW5nIjoiezB9IGNvbm5lY3RpbmcgdG8gZ2VuZXJhdGUuLi4iLCJsYW5ndWFnZS1tZW51LXN3aXRjaC10by1sZWdlbmQtZGVzYyI6IkRpc3BsYXkgdGhlIGxlZ2VuZCBmb3IgdmlzaWJsZSBsYXllcnMiLCJsYW5ndWFnZS10b29sYmFyLWdyb3VwLW9mZmxpbmUtbWFuYWdlbWVudCI6Ik9mZmxpbmUgTWFuYWdlbWVudCIsImxhbmd1YWdlLWNvbW1vbi1lZGl0IjoiRWRpdCIsImxhbmd1YWdlLWNvbW1vbi1mZWF0dXJlLXN5bmMtc2V0dGluZ3MiOiJNYW5hZ2UgU3luYyBTZXR0aW5ncyIsImxhbmd1YWdlLW1lbnUtc2V0dGluZ3MtZGVzY3JpcHRpb24iOiJNb2JpbGUgU2V0dGluZ3MiLCJsYW5ndWFnZS1zdGF0ZXMtZWRpdC1zdGF0ZS1kZXNjcmlwdGlvbiI6IlRoZSB0b29sIHRvIHNlbGVjdCBhbiBpdGVtIGZvciBlZGl0aW5nIGlzIGN1cnJlbnRseSBhY3RpdmUuIiwibGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLXN0YXJ0Y29sb3IiOiJTdGFydCBDb2xvciIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tcnVuLXdvcmtmbG93LWJ5LWlkIjoiUnVucyBhIHdvcmtmbG93LiIsImxhbmd1YWdlLW1lbnUtcHJvamVjdC1zaGFyZS1wcm9qZWN0LWRlc2MiOiJTaGFyZSB0aGUgY3VycmVudCBwcm9qZWN0IiwibGFuZ3VhZ2UtbGF5ZXJsaXN0LXRvZ2dsZSI6IlRvZ2dsZSB7MH0gbGF5ZXIgdmlzaWJpbGl0eS4iLCJsYW5ndWFnZS1tZW51LWdsb2JhbC1vcGVuIjoiT3BlbiIsImxhbmd1YWdlLW1lbnUtZXhwb3J0LXJlc3VsdHMtdG8tY3N2LWRlc2MiOiJFeHBvcnQgcmVzdWx0cyB0byBDU1YiLCJsYW5ndWFnZS1jb21tb24tZmVhdHVyZS1zeW5jLXNldHRpbmdzLWRlc2MiOiJEaXNwbGF5cyBhIGxpc3Qgb2YgZmVhdHVyZSBsYXllcnMgdG8gY2hvb3NlIGZyb20uIiwibGFuZ3VhZ2UtdG9vbGJhci10YWItdGFza3MiOiJUYXNrcyIsImxhbmd1YWdlLXRvb2xiYXItaG9tZS10b29sdGlwIjoiT3BlbiB0aGUgSG9tZSBQYW5lbCIsImxhbmd1YWdlLW1lbnUtZGVzY3JpcHRpb24iOiJRdWljayBhY2Nlc3MgdG8gY29tbW9uIHRhc2tzIiwibGFuZ3VhZ2UtbWVudS16b29tIjoiWm9vbSB0byBGZWF0dXJlIiwibGFuZ3VhZ2UtdG9vbGJhci1tYXJrdXAtcG9seWdvbi1kZXNjLWtleWJvYXJkIjoiVXNlIGFycm93cyB0byBtb3ZlIHRoZSBwb2ludC4gSGl0IEVOVEVSIHRvIHBsb3QgYW5kIGJlZ2luIG1vdmluZyB0aGUgbmV4dCBwb2ludC4gSGl0IEVOVEVSIHR3aWNlIHRvIGZpbmlzaC4iLCJsYW5ndWFnZS10b29sYmFyLW1hcmt1cC1yZWN0YW5nbGUtZGVzYyI6IkNsaWNrIGFuZCBkcmFnIHRvIGRyYXcgYSByZWN0YW5nbGUgb24gdGhlIG1hcC4iLCJsYW5ndWFnZS1sYXllci1hY3Rpb25zIjoiUGVyZm9ybSBhbiBhY3Rpb24gb24gezB9IiwibGFuZ3VhZ2UtcHJvamVjdC1lcnJvci1vd25lciI6IllvdSBkbyBub3Qgb3duIHRoaXMgcHJvamVjdC4iLCJsYW5ndWFnZS1jb21tb24tY2xlYXIiOiJDbGVhciIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tZmVhdHVyZS1sYXllci1tb2R1bGUtc3RhcnQtc3luYyI6IlN0YXJ0cyBzeW5jaHJvbml6ZXMgdGhlIGZlYXR1cmUgZWRpdHMgdG8gdGhlIHNlcnZlci4iLCJsYW5ndWFnZS1tZW51LWhvbWUtcGFuZWwiOiJWaWV3IHRoZSBob21lIHBhbmVsIiwibGFuZ3VhZ2UtY29tbW9uLWZlYXR1cmUtZWRpdGluZyI6IkZlYXR1cmUgQXR0cmlidXRlcyIsImxhbmd1YWdlLXRvb2xiYXItbmF2aWdhdGlvbi1wYW4iOiJQYW4iLCJsYW5ndWFnZS10b29sYmFyLW1hcmt1cC1lZGl0LWRlc2Mtc2hvcnRjdXRzIjoiVXNlIGFycm93cyB0byBtb3ZlLCBSIHRvIHJvdGF0ZSwgUyB0byBzY2FsZSwgViB0byBzZWxlY3QgdmVydGV4LiBDb21iaW5lIHdpdGggQUxUIGZvciBmaW5lciBjb250cm9sLiBDb21iaW5lIHdpdGggU0hJRlQgdG8gcmV2ZXJzZS4iLCJsYW5ndWFnZS1tb250aHMtMiI6Ik1hcmNoIiwibGFuZ3VhZ2UtbW9udGhzLTEiOiJGZWJydWFyeSIsImxhbmd1YWdlLW1vbnRocy00IjoiTWF5IiwibGFuZ3VhZ2Utb2ZmbGluZS1lcnJvcnMtbm90bmF0aXZlaW5pdGlhbGl6ZWQiOiJUaGlzIG9wZXJhdGlvbiBjYW4gb25seSBiZSBwZXJmb3JtZWQgaW4gdGhlIG5hdGl2ZSBjbGllbnQuIiwibGFuZ3VhZ2UtbW9udGhzLTMiOiJBcHJpbCIsImxhbmd1YWdlLW1lbnUtb2ZmbGluZS1tYXAtZWRpdG9yLWdlb21ldHJ5LWFjdGlvbnMtY2lyY2xlIjoiQ2lyY2xlIiwibGFuZ3VhZ2Utc21hcnQtcGFuZWwtbWVudSI6IlBhbmVsIEFjdGlvbnMgTWVudS4gQ2xpY2sgdG8gb3Blbi9jbG9zZS4iLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLXNob3ctbWFwIjoiQWN0aXZhdGVzIG1hcCB2aWV3LiIsImxhbmd1YWdlLW1vbnRocy0wIjoiSmFudWFyeSIsImxhbmd1YWdlLXRvb2xiYXItbmF2aWdhdGlvbi16b29tLW91dC10b29sdGlwIjoiRHJhdyBhbiBhcmVhIG9mIGludGVyZXN0IG9uIHRoZSBtYXAgYW5kIHpvb20gb3V0LCBrZWVwaW5nIHRoZSBhcmVhIGNlbnRlcmVkIiwibGFuZ3VhZ2UtdG9vbGJhci1tYXJrdXAtcG9pbnQtZGVzYyI6IkNsaWNrIG9yIHRhcCBhIG1hcCBsb2NhdGlvbiB0byBhZGQgYSBwb2ludC4iLCJsYW5ndWFnZS10b29sYmFyLXNuYXBwaW5nLWFsdC1kaXNhYmxlIjoiRGlzYWJsZSBzbmFwcGluZyBmb3IgYWN0aXZlIHRvb2wiLCJsYW5ndWFnZS10b29sYmFyLW1hcmt1cC1wYWxldHRlLXNtYWxsLWNoYW5nZS1zdHlsZSI6IlN0eWxlcyIsImxhbmd1YWdlLW1vbnRocy05IjoiT2N0b2JlciIsImxhbmd1YWdlLXRvb2xiYXItbmF2aWdhdGlvbi1uZXh0LWV4dGVudC10b29sdGlwIjoiWm9vbSB0byB0aGUgbmV4dCBleHRlbnQiLCJsYW5ndWFnZS1tb250aHMtNiI6Ikp1bHkiLCJsYW5ndWFnZS1tb250aHMtNSI6Ikp1bmUiLCJsYW5ndWFnZS1tZW51LXN3aXRjaC10by1sYXllcmxpc3QiOiJTaG93IExheWVyIExpc3QiLCJsYW5ndWFnZS1wYWdlLXByZXYiOiJQcmV2aW91cyBwYWdlIiwibGFuZ3VhZ2UtbW9udGhzLTgiOiJTZXB0ZW1iZXIiLCJsYW5ndWFnZS1tb250aHMtNyI6IkF1Z3VzdCIsImxhbmd1YWdlLW1lbnUtZXhwb3J0LXJlc3VsdHMtdG8tc2hwLWRlc2MiOiJFeHBvcnQgcmVzdWx0cyB0byBTaGFwZWZpbGUiLCJsYW5ndWFnZS1tZW51LWlkZW50aWZ5LXBvaW50LWRlc2MiOiJEcmF3IGEgcG9pbnQgb24gdGhlIG1hcCB0byB2aWV3IGluZm9ybWF0aW9uIGF0IHRoYXQgcG9pbnQgb24gdGhlIG1hcC4iLCJsYW5ndWFnZS1zbWFydC1wYW5lbC1yZXNpemUiOiJEcmFnIHRvIHJlc2l6ZSB0aGUgcGFuZWwiLCJsYW5ndWFnZS1zeW1ib2xvZ3ktc2V0dGluZ3MtbWFya2VyLXN0eWxlLXNxdWFyZSI6IlNxdWFyZSIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24taW52b2tlLW1hcC10aXAiOiJFeGVjdXRlcyBhbiBJZGVudGlmeSBvcGVyYXRpb24gb24gdGhlIGdpdmVuIGdlb21ldHJ5IGFuZCBcIk1hcFRpcFwiIGFzIGl0cyBzb3VyY2UgdGFnLiIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tY2xvc2UtZmVhdHVyZS1zZXQtY29sbGVjdGlvbiI6IkNsb3NlcyB0aGUgZmVhdHVyZSBzZXQgY29sbGVjdGlvbi4iLCJsYW5ndWFnZS1tZW51LWJyb3dzZS1zYXZlZC1yZXN1bHRzLWRlc2MiOiJDaG9vc2UgZnJvbSBhIGxpc3Qgb2Ygc2F2ZWQgcmVzdWx0cyB0byB2aWV3IHRoZW0iLCJsYW5ndWFnZS1zeW1ib2xvZ3ktc2V0dGluZ3MtZW5kY29sb3IiOiJFbmQgQ29sb3IiLCJsYW5ndWFnZS10b29sYmFyLW1hcmt1cC1wb2x5bGluZS1kZXNjLWtleWJvYXJkIjoiVXNlIGFycm93cyB0byBtb3ZlIHRoZSBwb2ludC4gSGl0IEVOVEVSIHRvIHBsb3QgYW5kIGJlZ2luIG1vdmluZyB0aGUgbmV4dCBwb2ludC4gSGl0IEVOVEVSIHR3aWNlIHRvIGZpbmlzaC4iLCJsYW5ndWFnZS11aS10YWJsZS1zb3J0ZWQtYXNjZW5kaW5nIjoiQ29sdW1uIGhlYWRlci4gezB9IC0gU29ydGVkIGFzY2VuZGluZy4iLCJsYW5ndWFnZS1tZW51LWVudGVyLW9ubGluZSI6IkdvIHRvIG9ubGluZSBtb2RlIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1zZWFyY2giOiJQZXJmb3JtcyBhIHNlYXJjaCBvbiBhbGwgYWN0aXZlIHByb3ZpZGVycy4iLCJsYW5ndWFnZS1tZW51LWVkaXQtZmVhdHVyZS1kZXNjcmlwdGlvbiI6IkVkaXQgdGhlIGRldGFpbHMgYWJvdXQgdGhpcyBmZWF0dXJlLiIsImxhbmd1YWdlLW1lbnUtaWRlbnRpZnktZnJlZWhhbmQiOiJJZGVudGlmeSBieSBmcmVlaGFuZCBzaGFwZSIsImxhbmd1YWdlLXByb2plY3Qtc2lnbi1pbiI6IlNpZ24gaW4iLCJsYW5ndWFnZS10b29sYmFyLW5hdmlnYXRpb24tem9vbS1vdXQtZGVzYyI6IkRyYWcgYSByZWN0YW5nbGUgb24gdGhlIG1hcCB0byB6b29tIG91dCB3aGlsZSBrZWVwaW5nIHRoYXQgYXJlYSBjZW50ZXJlZCIsImxhbmd1YWdlLXRvb2xiYXItbmF0aXZlLXNob3dvZmZsaW5lbWFwcy10b29sdGlwIjoiT3BlbiB0aGUgbGlzdCBvZiBvZmZsaW5lIG1hcHMiLCJsYW5ndWFnZS1tZW51LWlkZW50aWZ5LWJ1ZmZlcmVkLWZlYXR1cmUtc2V0LWNvbGxlY3Rpb24iOiJTaG93IEJ1ZmZlciBPcHRpb25zIiwibGFuZ3VhZ2UtdG9vbGJhci1ncm91cC1wbG90Y29vcmRpbmF0ZXMiOiJDb29yZGluYXRlcyIsImxhbmd1YWdlLXRvb2xiYXItbmF2aWdhdGlvbi16b29tLW91dCI6Ilpvb20gT3V0IiwibGFuZ3VhZ2UtdG9vbGJhci1zbmFwcGluZy1hbHQtZW5hYmxlIjoiRW5hYmxlIHNuYXBwaW5nIGZvciBhY3RpdmUgdG9vbCIsImxhbmd1YWdlLW9mZmxpbmUtcHJvZ3Jlc3MtdW5yZWdpc3RlcmluZ3JlcGxpY2EiOiJVbnJlZ2lzdGVyaW5nIHJlcGxpY2EuIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1jbGVhci1oaWdobGlnaHRzIjoiUmVtb3ZlcyB0aGUgaGlnaGxpZ2h0cyBmcm9tIHRoZSBhY3RpdmUgaGlnaGxpZ2h0IGxheWVyLiIsImxhbmd1YWdlLWhvdXJzLWFiYnIiOiJIIiwibGFuZ3VhZ2UtbWVudS1yZW1vdmUtdXNlci1hZGRlZC1tYXBzZXJ2aWNlIjoiUmVtb3ZlIHNlcnZpY2UiLCJsYW5ndWFnZS10b29sYmFyLW5hdmlnYXRpb24tcHJldmlvdXMtZXh0ZW50LXRvb2x0aXAiOiJab29tIHRvIHRoZSBwcmV2aW91cyBleHRlbnQiLCJsYW5ndWFnZS10b29sYmFyLW1hcmt1cC1kZWxldGUtZGVzYy1rZXlib2FyZCI6IlVzZSBhcnJvd3MgdG8gbW92ZSB0aGUgcG9pbnQuIEhpdCBFTlRFUiB0byBpbW1lZGlhdGVseSBhbmQgcGVybWFuZW50bHkgZGVsZXRlIGEgZHJhd2luZy4gVGhpcyBjYW5ub3QgYmUgdW5kb25lLiIsImxhbmd1YWdlLXRvb2xiYXItc2VsZWN0LWxheWVycy10b2dnbGUtb24tbmFtZSI6IkZpbHRlciBMYXllcnMiLCJsYW5ndWFnZS10b29sYmFyLWlkZW50aWZ5LXJlY3RhbmdsZSI6IlJlY3RhbmdsZSIsImxhbmd1YWdlLXRvb2xiYXItc25hcHBpbmctc2VsZWN0LWxheWVycy10b29sdGlwIjoiQ2hhbmdlIHdoaWNoIGxheWVycyBhcmUgc25hcHBhYmxlIiwibGFuZ3VhZ2Utb2ZmbGluZS1lcnJvcnMtbm90Zm91bmQiOiJPZmZsaW5lIHByb2ZpbGUgbm90IGZvdW5kLiIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tb3Blbi13ZWItcGFnZSI6Ik9wZW5zIGEgd2ViIHBhZ2UgaW4gYW5vdGhlciB0YWIvd2luZG93LiIsImxhbmd1YWdlLXJlc3VsdHMtcGFnZS1wcmV2IjoiUHJldmlvdXMgcGFnZSIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tY2xvc2UtbW9kYWwtcmVnaW9uIjoiQ2xvc2VzIHRoZSBNb2RhbFdpbmRvd1JlZ2lvbi4iLCJsYW5ndWFnZS10b29sYmFyLW5hdmlnYXRpb24taG9tZS1zdWIiOiJIb21lIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1jYW5jZWwtc2VhcmNoIjoiQ2FuY2VsIHRoZSBzZWFyY2ggb24gYWxsIHByb3ZpZGVycy4iLCJsYW5ndWFnZS1vZmZsaW5lLWVycm9ycy1jYW5jZWxyZWplY3RlZCI6IkNhbm5vdCBjYW5jZWwgcmlnaHQgbm93LiIsImxhbmd1YWdlLWNvbW1vbi13b3JrZmxvdyI6IldvcmtmbG93IiwibGFuZ3VhZ2UtbWVudS1kb25lIjoiRG9uZSIsImxhbmd1YWdlLW1lbnUtZWRpdC1mZWF0dXJlIjoiRWRpdCB0aGlzIEZlYXR1cmUiLCJsYW5ndWFnZS10b29sYmFyLW1hcmt1cC1wb2ludC10b29sdGlwIjoiQWRkIGEgcG9pbnQgdG8gdGhlIG1hcCIsImxhbmd1YWdlLXRvb2xiYXItM3JkLXBhcnR5LW1hcHMtc2hvdy1tYXBzIjoiTGlua2VkIE1hcHMiLCJsYW5ndWFnZS1sYXllcmxpc3Qtbm90LXZpc2libGUtYXQtZXh0ZW50IjoiQ3VycmVudGx5IG5vdCB3aXRoaW4gdmlzaWJsZSBzY2FsZS4iLCJsYW5ndWFnZS1zeW1ib2xvZ3ktc2V0dGluZ3MtbGluZS1zdHlsZS1zb2xpZCI6IlNvbGlkIiwibGFuZ3VhZ2UtbWVudS16b29tLWRlc2NyaXB0aW9uIjoiWm9vbSB0byB0aGlzIGZlYXR1cmUgb24gdGhlIG1hcCIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tZ2xvYmFsLXNlYXJjaCI6IlBlcmZvcm1zIGEgc2VhcmNoIG9uIGFsbCBhY3RpdmUgcHJvdmlkZXJzLiIsImxhbmd1YWdlLW1lbnUtc2hvdy1sb2ciOiJTaG93IExvZyIsImxhbmd1YWdlLWNvb3JkaW5hdGVzLW1pbnV0ZXMiOiInIiwibGFuZ3VhZ2UtdG9vbGJhci1ncm91cC10aW1lLXNsaWRlciI6IlRpbWUgU2xpZGVyIiwibGFuZ3VhZ2UtdG9vbGJhci1zZWxlY3QtbGF5ZXJzLXRvZ2dsZS10b29sdGlwIjoiRmlsdGVyIGxheWVycyBmb3IgSWRlbnRpZnkgcmVzdWx0cyIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tc2V0LWhpZ2hsaWdodC1ib3JkZXItY29sb3IiOiJTZXRzIHRoZSBib3JkZXIgY29sb3IgdXNlZCBmb3IgbmV3IGhpZ2hsaWdodHMsIHNwZWNpZmllZCBpbiA2IG9yIDggZGlnaXQgaGV4IGluIFJHQiBvciBBUkdCIGZvcm0uIiwibGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLWZpbGwtc3R5bGUtaG9yaXpvbnRhbCI6Ikhvcml6b250YWwiLCJsYW5ndWFnZS1tZW51LW1hcC1sYXllcnMiOiJDaGFuZ2UgdmlzaWJsZSBtYXAgbGF5ZXJzIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1oaWdobGlnaHQtZXNyaS1mZWF0dXJlLXNldCI6IkhpZ2hsaWdodHMgYWxsIG9mIHRoZSBmZWF0dXJlcyBpbiB0aGUgc3BlY2lmaWVkIGZlYXR1cmUgc2V0IGluIHRoZSBhY3RpdmUgaGlnaGxpZ2h0IGxheWVyLiIsImxhbmd1YWdlLWdyYW50LWVkaXRvci1tb25pa2VyLXR5cGUtdXNlciI6IkluZGl2aWR1YWxzIiwibGFuZ3VhZ2UtdG9vbGJhci1jaGFydGluZy1zaG93LWNoYXJ0cyI6IlZpZXcgQ2hhcnRzIiwibGFuZ3VhZ2UtdG9vbGJhci1tYXJrdXAtcG9seWxpbmUtZGVzYyI6IkNsaWNrIG9yIHRhcCBsb2NhdGlvbnMgYWxvbmcgdGhlIG1hcCB0byBjcmVhdGUgYSBsaW5lLiBEb3VibGUgY2xpY2svdGFwIHRvIGZpbmlzaC4iLCJsYW5ndWFnZS10b29sYmFyLXRhc2tzLWlkZW50aWZ5IjoiSWRlbnRpZnkiLCJsYW5ndWFnZS1tZW51LWNvbWJpbmUtcmVzdWx0cy1zdWJ0cmFjdC1kZXNjIjoiUmVtb3ZlIGEgc2F2ZWQgc2V0IG9mIHJlc3VsdHMgZnJvbSB5b3VyIGN1cnJlbnQgbGlzdCBvZiByZXN1bHRzIiwibGFuZ3VhZ2UtbWVudS1pZGVudGlmeS1yZWN0YW5nbGUtZGVzYyI6IkRyYXcgYSByZWN0YW5nbGUgdG8gdmlldyBpbmZvcm1hdGlvbiBhYm91dCB0aGF0IGFyZWEuIiwibGFuZ3VhZ2UtdG9vbGJhci1pZGVudGlmeS1yZWN0YW5nbGUtZGVzYyI6IlRvIGxlYXJuIHdoYXRcdTIwMTlzIHRoZXJlLCBjbGljayBvciB0YXAgYW5kIGRyYWcgdG8gZHJhdyBhIHJlY3RhbmdsZSBvbiB0aGUgbWFwLiIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tZGVhY3RpdmF0ZS1jb250YWluZXJzLWZvci13b3JrZmxvdyI6IkRlYWN0aXZhdGVzIGFueSB3b3JrZmxvdyB2aWV3cyBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiB3b3JrZmxvdy4iLCJsYW5ndWFnZS1wcm9qZWN0LWVycm9yLWRlbGV0ZSI6IlRoZSBwcm9qZWN0IGNvdWxkIG5vdCBiZSBkZWxldGVkLiBSZWZlciB0byB0aGUgbG9nIGZvciBtb3JlIGRldGFpbHMuIiwibGFuZ3VhZ2Utc21hcnQtcGFuZWwtYmFjayI6IkdvIEJhY2sgaW4gUGFuZWwiLCJsYW5ndWFnZS1tZW51LWxpc3Qtb2ZmbGluZS1tYXBzLWFjdGlvbnMtZGVzYyI6Ik9mZmxpbmUgUHJvZmlsZSBBY3Rpb25zIiwibGFuZ3VhZ2UtcHJvamVjdC1lcnJvci1zaWduLWluLXJlcXVpcmVkIjoiVGhpcyBwcm9qZWN0IHJlcXVpcmVzIHlvdSB0byBzaWduIGluLiBQbGVhc2Ugc2lnbiBpbiB0byBvcGVuIHRoZSBwcm9qZWN0LiIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tc2hvdy1tYXAtdGlwIjoiQ3JlYXRlcyBhIE1hcCBUaXAgVmlldyBhbmQgZGlzcGxheXMgdGhlIGZlYXR1cmUgaW4gaXQuIiwibGFuZ3VhZ2UtdG9vbGJhci1tYXJrdXAtY2xlYXItdG9vbHRpcCI6IkNsZWFyIGFsbCBkcmF3aW5ncyBmcm9tIHRoZSBtYXAiLCJsYW5ndWFnZS1zdGF0ZXMtYnVmZmVyaW5nLWRlc2NyaXB0aW9uIjoiQnVmZmVyaW5nIGlzIGVuYWJsZWQgZm9yIHRoZSBjdXJyZW50IHRvb2wuIiwibGFuZ3VhZ2UtY29tbW9uLWZlYXR1cmUtb2ZmbGluZS10b29scyI6Ik1hbmFnZSBPZmZsaW5lIERhdGEiLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLWRlYWN0aXZhdGUtdmlldyI6IkRlYWN0aXZhdGVzIGEgdmlldy4iLCJsYW5ndWFnZS1zeW1ib2xvZ3ktc2V0dGluZ3MtcGljay1hdHRyaWJ1dGUiOiJQaWNrIGFuIGF0dHJpYnV0ZSB0byBzeW1ib2xpemU6IiwibGFuZ3VhZ2UtbWVudS1yZW1vdmUtdXNlci1hZGRlZC1sYXllci1kZXNjIjoiUmVtb3ZlIHRoaXMgdXNlciBhZGRlZCBsYXllciBmcm9tIHRoZSBtYXAuIiwibGFuZ3VhZ2UtdG9vbGJhci1maW5kLWRhdGEtdG9vbHMiOiJGaW5kIERhdGEgVG9vbHMiLCJsYW5ndWFnZS1tZW51LWdsb2JhbC1zYXZlLWFzLWRlc2MiOiJTYXZlIHRoZSBzdGF0ZSBvZiB5b3VyIHZpZXdlciBpbiBhIG5ldyBwcm9qZWN0IiwibGFuZ3VhZ2UtbWVudS1leHBvcnQtcmVzdWx0cy10by1zaHAiOiJFeHBvcnQgdG8gU2hhcGVmaWxlIiwibGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLWxpbmUtc3R5bGUtbG9uZ2Rhc2giOiJMb25nLWRhc2giLCJsYW5ndWFnZS1zZWFyY2gtd29ybGQtcGxhY2UtbmFtZXMiOiJXb3JsZCBQbGFjZSBOYW1lcyIsImxhbmd1YWdlLWNvbW1vbi1ub3QtYXZhaWxhYmxlLW9mZmxpbmUiOiJUaGlzIGZ1bmN0aW9uIGlzIG5vdCBhdmFpbGFibGUgd2hlbiBvZmZsaW5lLiIsImxhbmd1YWdlLXJlc3VsdHMiOiJSZXN1bHRzIiwibGFuZ3VhZ2UtdG9vbGJhci1hbmFseXNpcy1tZWFzdXJlbWVudC10b29scyI6Ik1lYXN1cmUiLCJsYW5ndWFnZS10b29sYmFyLW5hdmlnYXRpb24taG9tZS10b29sdGlwIjoiUmV0dXJucyB0byBpbnRyb2R1Y3RvcnkgcGFnZSIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tc2V0LWFjdGl2ZS10b29sIjoiU2V0cyB0aGUgYWN0aXZlIHRvb2wuIiwibGFuZ3VhZ2UtbWVudS1leHBvcnQtcmVzdWx0cy10by14bHN4IjoiRXhwb3J0IHRvIFhMU1giLCJsYW5ndWFnZS1tZW51LW9mZmxpbmUtbWFwLWVkaXRvci1nZW9tZXRyeS1hY3Rpb25zLXJlY3RhbmdsZSI6IlJlY3RhbmdsZSIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tc2hvdy1sYXllci1saXN0IjoiQWN0aXZhdGVzIHRoZSBMYXllckxpc3QgVmlldy4iLCJsYW5ndWFnZS1vZmZsaW5lLXByb2dyZXNzLWJ5dGVzIjoiezB9IGJ5dGVzIiwibGFuZ3VhZ2UtdG9vbGJhci1zaG93LWxheWVybGlzdCI6IkxheWVyIExpc3QiLCJsYW5ndWFnZS1ncmFudC1lZGl0b3ItZ2xvYmFsLWdyYW50LW5hbWUtcHVibGljIjoiRXZlcnlvbmUgKHNpZ24taW4gbm90IHJlcXVpcmVkKSIsImxhbmd1YWdlLW1lbnUtZHJhdy1wb2ludC1kZXNjIjoiRHJhdyBhIHBvaW50IG9uIHRoZSBtYXAuIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi11cGRhdGUtZmVhdHVyZS1sYXllci1tb2RhbC1tZXNzYWdlIjoiVXBkYXRlIHRoZSB2aXNpYmxlIE1vZGVsTWVzc2FnZVZpZXcgdG8gYWxzbyBpbmNsdWRlIHRoZSBnaXZlbiBtZXNzYWdlLiIsImxhbmd1YWdlLXBhZ2Utb2YiOiJvZiIsImxhbmd1YWdlLXJlc3VsdHMtdG9nZ2xlLXRhYmxlLXZpZXctZGVzYyI6IlZpZXcgcmVzdWx0cyBpbiB0YWJsZSBmb3JtYXQiLCJsYW5ndWFnZS1jb21tb24tZmVhdHVyZS1lZGl0bG9nIjoiVmlldyBFZGl0IExvZyIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tdGFrZS1hcHBsaWNhdGlvbi1vZmZsaW5lIjoiUHV0cyB0aGUgYXBwbGljYXRpb24gaW4gYW4gb2ZmbGluZSBzdGF0ZS4iLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLXN0YXJ0LWVkaXRpbmctZmVhdHVyZSI6IkJlZ2lucyBlZGl0aW5nIGFuIGV4aXN0aW5nIGZlYXR1cmUuIiwibGFuZ3VhZ2UtbWVudS1jb21iaW5lLXJlc3VsdHMtaW50ZXJzZWN0IjoiTWF0Y2ggaW50ZXJzZWN0aW5nIHJlc3VsdHMiLCJsYW5ndWFnZS1tZW51LWRlZmF1bHQtdGl0bGUiOiJPcHRpb25zIiwibGFuZ3VhZ2UtbWVudS1yZXN1bHRzLWxpc3QtYWN0aW9ucy1kZXNjIjoiUmVzdWx0cyBMaXN0IEFjdGlvbnMiLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLXpvb20tdG8tZXh0ZW50IjoiWm9vbXMgdG8gdGhlIGdpdmVuIGV4dGVudC4iLCJsYW5ndWFnZS1wYWdlLXBhZ2UiOiJQYWdlIiwibGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLW1hcmtlci1zaXplLXN1ZmZpeCI6InB4IiwibGFuZ3VhZ2Utb2ZmbGluZS1wcm9ncmVzcy1iYXNlbWFwZXhwb3J0LWNvbXBsZXRlZCI6InswfSBnZW5lcmF0ZWQgYW5kIGRvd25sb2FkZWQuIiwibGFuZ3VhZ2UtY29tbW9uLW5vLXJlc3VsdHMtc2hvcnQiOiJObyByZXN1bHRzIiwibGFuZ3VhZ2UtdG9vbGJhci1tZW51LWdsb2JhbC1zYXZlLXNhdmUtYXMiOiJTYXZlL1NhdmUgYXMiLCJsYW5ndWFnZS1wYWdlLWxhc3QiOiJMYXN0IHBhZ2UiLCJsYW5ndWFnZS1tZW51LW9mZmxpbmUtbWFwLWVkaXRvci1nZW9tZXRyeS1hY3Rpb25zLWVsbGlwc2UiOiJFbGxpcHNlIiwibGFuZ3VhZ2UtdG9vbGJhci1tYXJrdXAtZWRpdC1kZXNjLXNob3J0Y3V0cy16b29tIjoiVXNlIGFycm93cyB0byBtb3ZlLCBTIHRvIHNjYWxlLiBDb21iaW5lIHdpdGggQUxUIGZvciBmaW5lciBjb250cm9sLiBDb21iaW5lIHdpdGggU0hJRlQgdG8gcmV2ZXJzZS4iLCJsYW5ndWFnZS10b29sYmFyLWlkZW50aWZ5LXJlY3RhbmdsZS10b29sdGlwIjoiRmluZCBvdXQgYWJvdXQgYW4gYXJlYSBvbiB0aGUgbWFwIGRlZmluZWQgYnkgYSByZWN0YW5nbGUiLCJsYW5ndWFnZS1jb21tb24taGlkZSI6IkhpZGUiLCJsYW5ndWFnZS10b29sYmFyLXRhYi1uYXZpZ2F0aW9uIjoiTmF2aWdhdGlvbiIsImxhbmd1YWdlLXN5bWJvbG9neS1zZXR0aW5ncy1hdHRyaWJ1dGUtc2VsZWN0IjoiUGxlYXNlIENob29zZS4uLiIsImxhbmd1YWdlLWNvbW1vbi1sYXllci1kYXRhIjoiTGF5ZXIgRGF0YSIsImxhbmd1YWdlLXN5bWJvbG9neS1zZXR0aW5ncy1ub2RhdGEtdGl0bGUiOiJObyBEYXRhIiwibGFuZ3VhZ2UtbWVudS1sYXRpdHVkZS1nZW9ncmFwaGljcyI6IkxhdGl0dWRlIEdlb2dyYXBoaWNzIEdyb3VwIEx0ZC4iLCJsYW5ndWFnZS10b29sYmFyLXRhc2tzLWxheWVyLWNhdGFsb2ctdG9vbHRpcCI6IkFkZCBsYXllcnMgdG8gdGhlIG1hcCBmcm9tIGEgbGF5ZXIgY2F0YWxvZyIsImxhbmd1YWdlLXRhYi1zY3JvbGwtbmV4dCI6Ik5leHQgTGF5ZXIiLCJsYW5ndWFnZS1sYXllci1hY3Rpb25zLXRpdGxlIjoiTGF5ZXIgQWN0aW9ucyIsImxhbmd1YWdlLXRvb2xiYXItbWFya3VwLWVkaXQtem9vbW91dC10b29sIjoiWm9vbU91dFRvb2wiLCJsYW5ndWFnZS1jb21tb24tbG9hZCI6IkxvYWQiLCJsYW5ndWFnZS1jb21tb24tcmVzdWx0cyI6IlJlc3VsdHMiLCJsYW5ndWFnZS1tZW51LWJyb3dzZS1zYXZlZC1yZXN1bHRzIjoiT3BlbiBTYXZlZCBSZXN1bHRzIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1nZXQtcmVsYXRlZC1mZWF0dXJlIjoiR2V0cyBmZWF0dXJlcyByZWxhdGVkIHRvIHRoZSBmZWF0dXJlLiIsImxhbmd1YWdlLXRvb2xiYXItbWFya3VwLWZyZWVoYW5kIjoiRnJlZWhhbmQiLCJsYW5ndWFnZS1tZW51LW1hcHRpcC1hY3Rpb25zIjoiQWN0aW9ucyIsImxhbmd1YWdlLXRvb2xiYXItbWFya3VwLWV4cG9ydC10b29sdGlwIjoiRXhwb3J0IGRyYXdpbmdzIHRvIHNoYXBlZmlsZSIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tcHJvamVjdCI6IkNhbGxzIGEgZ2VvbWV0cnkgc2VydmljZSB0byBwcm9qZWN0IGdlb21ldHJpZXMgYmV0d2VlbiBkaWZmZXJlbnQgY29vcmRpbmF0ZSBzeXN0ZW1zLiIsImxhbmd1YWdlLXRvb2xiYXItZ3JvdXAtdGltZXNsaWRlciI6IlRpbWUgU2xpZGVyIiwibGFuZ3VhZ2UtbWVudS1vZmZsaW5lLW1hcC1lZGl0b3ItZ2VvbWV0cnktYWN0aW9ucy1wb2x5Z29uIjoiUG9seWdvbiIsImxhbmd1YWdlLXJlc3VsdHMtcGFnZS1sYXN0IjoiTGFzdCBwYWdlIiwibGFuZ3VhZ2UtcmVzdWx0cy10b3RhbCI6IlRvdGFsIiwibGFuZ3VhZ2UtY29tbW9uLWJhY2siOiJCYWNrIiwibGFuZ3VhZ2UtY29tbW9uLXJlc3VsdHMtc3VidHJhY3QtY29uZmlybWF0aW9uIjoiezF9IHN1YnRyYWN0ZWQgZnJvbSAnezB9JyIsImxhbmd1YWdlLXRvb2xiYXItYXJjZ2lzLWV4cG9ydC13ZWItbWFwLXRvb2x0aXAiOiJTYXZlIHRoZSBjdXJyZW50IG1hcCB0byBBcmNHSVMiLCJsYW5ndWFnZS1tZW51LXNhdmUtcmVzdWx0cy1kZXNjIjoiU2F2ZSB0aGUgbGlzdCBvZiByZXN1bHRzIGZvciBmdXR1cmUgdXNlIiwibGFuZ3VhZ2UtbWVudS1lbnRlci1vbmxpbmUtZGVzYyI6IkdvIHRvIG9ubGluZSBtb2RlIGFuZCB2aWV3IGxpdmUgbWFwIGRhdGEgZnJvbSB0aGUgd2ViLiIsImxhbmd1YWdlLWNvbW1hbmQtZGVzY3JpcHRpb24tcHJvbXB0IjoiRGlzcGxheXMgYSBwcm9tcHQuIiwibGFuZ3VhZ2UtY29tbW9uLW5vLXJlc3VsdHMiOiJObyByZXN1bHRzIHRvIGRpc3BsYXkiLCJsYW5ndWFnZS1vZmZsaW5lLXByb2dyZXNzLWJhc2VtYXBleHBvcnQtY2FuY2VsZWQiOiJ7MH0gY2FuY2VsZWQuIiwibGFuZ3VhZ2UtbWVudS1vZmZsaW5lLW1hcC1lZGl0b3ItZ2VvbWV0cnktYWN0aW9ucy1jaXJjbGUtZGVzYyI6IkRyYXcgYSBjaXJjbGUgZm9yIHRoZSBhcmVhIG9mIGludGVyZXN0IGdlb21ldHJ5LiIsImxhbmd1YWdlLXRvb2xiYXItbWFya3VwLXBhbGV0dGUtc21hbGwtY2xlYXItYWxsIjoiQ2xlYXIgQWxsIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1jcmVhdGUtaGlnaGxpZ2h0LWxheWVyIjoiQ3JlYXRlcyBhIG5ldyBoaWdobGlnaHQgbGF5ZXIgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuIiwibGFuZ3VhZ2UtY29tbW9uLWxvYWRpbmciOiJMb2FkaW5nLi4uIiwibGFuZ3VhZ2UtbWVudS12aXN1YWxpemF0aW9uLWRlc2MiOiJDcmVhdGUgYW5kIHZpZXcgY3VzdG9tIGxheWVyIHZpc3VhbGl6YXRpb25zIHN1Y2ggYXMgaGVhdCBtYXBzLCBjbHVzdGVyaW5nLCBhbmQgbGF5ZXIgc3R5bGVzLiIsImxhbmd1YWdlLW1lbnUtaWRlbnRpZnktcmVjdGFuZ2xlIjoiSWRlbnRpZnkgYnkgcmVjdGFuZ2xlIiwibGFuZ3VhZ2Utc3ltYm9sb2d5LXNldHRpbmdzLWZpbGwtc3R5bGUtc29saWQiOiJTb2xpZCIsImxhbmd1YWdlLXN5bWJvbG9neS1zZXR0aW5ncy1maWxsLXN0eWxlIjoiRmlsbCBTdHlsZSIsImxhbmd1YWdlLXRvb2xiYXItYm9va21hcmstb3BlbiI6Ik9wZW4gdGhlIGJvb2ttYXJrcyB2aWV3IiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi1wYW4tdG8tcG9pbnQiOiJQYW5zIHRvIGEgcG9pbnQgb3Igb3RoZXIgdHlwZSBvZiBHZW9tZXRyeS4iLCJsYW5ndWFnZS10b29sYmFyLW1hcmt1cC1lbGxpcHNlIjoiRWxsaXBzZSIsImxhbmd1YWdlLXRvb2xiYXItdGFiLWFuYWx5c2lzIjoiQW5hbHlzaXMiLCJsYW5ndWFnZS1zeW1ib2xvZ3ktc2V0dGluZ3MtbGluZS1zdHlsZS1kYXNoIjoiRGFzaCIsImxhbmd1YWdlLXNtYXJ0LXBhbmVsLWNsb3NlIjoiQ2xvc2UgUGFuZWwiLCJsYW5ndWFnZS1jb21tYW5kLWRlc2NyaXB0aW9uLWZlYXR1cmUtbGF5ZXItY2xlYXItZGF0YSI6IkNsZWFycyB0aGUgZGF0YSBmb3IgYSBnaXZlbiBtYXAgc2VydmljZSBVUkwuIiwibGFuZ3VhZ2UtdG9vbGJhci1idWZmZXJpbmctZGlzYWJsZSI6IkRpc2FibGUgYnVmZmVyaW5nIiwibGFuZ3VhZ2UtY29tbWFuZC1kZXNjcmlwdGlvbi11cGRhdGUtcmVsYXRlZC1yZWNvcmQiOiJVcGRhdGVzIGEgcmVsYXRlZCB0YWJsZSByZWNvcmQuIiwibGFuZ3VhZ2UtdG9vbGJhci1ib29rbWFyayI6IkJvb2ttYXJrcyIsImxhbmd1YWdlLWZyYW1ld29yay11aS12aWV3LWNvbnRhaW5lci12aWV3LWJhY2siOiJHbyBCYWNrIHswfSJ9");

geocortex.framework.notifyLibraryDownload("Mapping.Infrastructure");
//# sourceMappingURL=mapping.infrastructure_ts_out.js.map
