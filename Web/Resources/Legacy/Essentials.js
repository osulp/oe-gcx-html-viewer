/*
	
	Copyright (c) 2016, Latitude Geographics Group Ltd.
	All rights reserved.
	       
	Redistribution is not permitted. 
	
	Use in binary form, without modification, is permitted provided that neither 
	the name of the organization nor the names of its contributors may be used 
	to endorse or promote products derived from this software without specific 
	prior written permission.
	       
	THIS SOFTWARE IS PROVIDED BY COPYRIGHT HOLDER ''AS IS'' AND ANY
	EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	DISCLAIMED. IN NO EVENT SHALL LATITUDE GEOGRAPHICS GROUP LTD. BE LIABLE FOR ANY
	DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


/* Begin Script: _JavaScriptAPI/Essentials/essentials_ts_out.js ------------------------- */ 
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
        * Base class for objects that are typically initialized from a REST endpoint, e.g. a {@link Site}, or a {@link MapService}.
        *
        * Provides methods, events and properties common to objects commonly initialized in an asynchronous fashion.
        * This is the sequence of an asynchronous initialization:
        * 1. The class is instantiated.
        * 2. The initialize method is called by something looking to initialize the resource.
        * 3. The subclass asynchronously calls a REST endpoint.
        * 4. Once the asynchronous call has completed, sets the {@link isInitialized} property to true.
        * 5. If the asynchronous call returned an error, sets the {@link initializationFailure} property to the exception and fires the {@link onInitializationFailed} event.
        * 6. The object fires the {@link onInitialized} event, regardless of whether there were errors or not.
        */
        var AsyncInitializable = (function () {
            /**
             * Initializes a new instance of the {@link geocortex.essentials.AsyncInitializable} class.
             * @param url The remote endpoint to initialize against, typically a REST endpoint serving JSON responses.
             */
            function AsyncInitializable(url) {
                /** The exception that occurred if the object could not be initialized. */
                this.initializationFailure = null;
                /** Whether or not the object was successfully initialized. */
                this.isInitialized = false;
                /**
                 * Occurs when initialization of this object fails.
                 * @event
                 */
                this.onInitializationFailed = null;
                /**
                 * Occurs when initialization succeeds with a response from the REST endpoint. Depending on the API,
                 * this response may actually be an error message served as a correct HTTP response.
                 * @event
                 */
                this.onInitialized = null;
                /** @private */
                this._initializing = false;
                this.url = url;
                this._initializedHandler = dojo.hitch(this, this._initializedHandler);
                this._initializationFailedHandler = dojo.hitch(this, this._initializationFailedHandler);
                this._restLoadHandler = dojo.hitch(this, this._restLoadHandler);
                this._restErrorHandler = dojo.hitch(this, this._restErrorHandler);
            }
            /**
             * Initializes the {@link geocortex.essentials.AsyncInitializable}.
             * This is an asynchronous method, you may subscribe to the {@link onInitialized}
             * and {@link onInitializationFailed} events for completion information.
             */
            AsyncInitializable.prototype.initialize = function (obj) {
                // If it is already initialized or is initializing, then exit.
                if (this.isInitialized || this._initializing) {
                    return;
                }
                var deepInitialize = obj !== undefined && obj !== null;
                if (!deepInitialize) {
                    if (!this.url) {
                        throw new Error("Unable to initialize AsyncInitializable without a valid URL.");
                    }
                    // Indicate that the initialization is happening
                    this._initializing = true;
                    geocortex.request({
                        url: this.url,
                        content: {
                            f: "json"
                        },
                        load: dojo.hitch(this, this._restLoadHandler, deepInitialize),
                        error: this._restErrorHandler,
                        callbackParamName: "CallBack"
                    });
                }
                else {
                    // An object was supplied to the initialize method, so
                    // we are dealing with a deep initialization where
                    // we already have everything we need from the server.
                    this._restLoadHandler(true, obj);
                }
            };
            AsyncInitializable.prototype.doWhenInitialized = function (scope, callback) {
                if (arguments.length === 1) {
                    callback = scope;
                    scope = this;
                }
                if (this.isInitialized) {
                    callback.call(scope, this);
                }
                else {
                    var connection = dojo.connect(this, "onInitialized", this, function () {
                        dojo.disconnect(connection);
                        callback.apply(scope, arguments);
                    });
                }
            };
            /** @private */
            AsyncInitializable.prototype._configureObject = function (results, deepInitialize) {
                // Override in subclasses to initialize object with results 
            };
            /** @private */
            AsyncInitializable.prototype._initializationFailedHandler = function (err) {
                this.initializationFailure = err;
                if (this.onInitializationFailed) {
                    this.onInitializationFailed(err);
                }
            };
            /** @private */
            AsyncInitializable.prototype._initializedHandler = function (sender) {
                this.isInitialized = true;
                if (this.onInitialized) {
                    this.onInitialized(sender);
                }
                this._initializing = false;
            };
            /** @private */
            AsyncInitializable.prototype._restErrorHandler = function (error) {
                this._initializationFailedHandler(error);
                this._initializedHandler(this);
            };
            /** @private */
            AsyncInitializable.prototype._restLoadHandler = function (deepInitialize, result) {
                this._configureObject(result, deepInitialize);
                this._initializedHandler(this);
            };
            return AsyncInitializable;
        }());
        essentials.AsyncInitializable = AsyncInitializable;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../../_Definitions/arcgis-js-api.d.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var utilities;
        (function (utilities) {
            /**
             * Represents a URI that has been decomposed for manipulation so that it can be reformulated.
             * @private
             */
            var DecomposedUri = (function () {
                /**
                 * Initializes a new instance of the {@link DecomposedUri} class.
                 * @param uri The URI to consume.
                 */
                function DecomposedUri(uri) {
                    this.originalUri = uri;
                    // Scheme, host, path
                    this.schemeHostAndPath = uri.match(/[^?|^#]*/)[0];
                    // Query
                    var queryMatches = uri.match(/\?([^#]*)/);
                    this.query = {};
                    if (queryMatches && queryMatches.length > 1) {
                        this.query = dojo.queryToObject(queryMatches[1]);
                    }
                    // Fragment
                    this.fragment = dojo.queryToObject(uri.indexOf("#") >= 0 ? uri.substring(uri.indexOf("#") + 1, uri.length) : "");
                }
                /**
                 * Recomposes back into a URI.
                 */
                DecomposedUri.prototype.recompose = function () {
                    var result = this.schemeHostAndPath;
                    if (this.query && this.anyProperties(this.query)) {
                        result += "?" + dojo.objectToQuery(this.query);
                    }
                    if (this.fragment && this.anyProperties(this.fragment)) {
                        result += "#" + dojo.objectToQuery(this.fragment);
                    }
                    return result;
                };
                /**
                * @private
                */
                DecomposedUri.prototype.anyProperties = function (object) {
                    for (var x in object) {
                        return true;
                    }
                    return false;
                };
                /**
                 * Gets the server host for a given URI.
                 */
                DecomposedUri.getHost = function (uri) {
                    if (!uri) {
                        return null;
                    }
                    var matches = uri.match(/^http[s]?:\/\/([^\/]*)/);
                    if (matches.length > 1) {
                        return matches[1];
                    }
                    return null;
                };
                /**
                 * Appends to the path of a url (while preserving the query string, hash, etc).
                 * @param url The url.
                 * @param pathPart The path to append onto the url.
                 */
                DecomposedUri.appendToPath = function (url, pathPart) {
                    var decomposed = new DecomposedUri(url);
                    decomposed.schemeHostAndPath += pathPart;
                    return decomposed.recompose();
                };
                /**
                 * Removes the specified query parameters from a url.
                 * @param url The url.
                 * @param parameters The parameters (keys) to remove from the url.
                 */
                DecomposedUri.removeQueryParameters = function (url) {
                    var parameters = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        parameters[_i - 1] = arguments[_i];
                    }
                    var decomposed = new DecomposedUri(url);
                    for (var _a = 0, parameters_1 = parameters; _a < parameters_1.length; _a++) {
                        var key = parameters_1[_a];
                        delete decomposed.query[key];
                    }
                    return decomposed.recompose();
                };
                return DecomposedUri;
            }());
            utilities.DecomposedUri = DecomposedUri;
        })(utilities = essentials.utilities || (essentials.utilities = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var utilities;
        (function (utilities) {
            /**
             * Static utility methods for strings and common operations involving strings.
             */
            var StringUtilities = (function () {
                function StringUtilities() {
                }
                /**
                 * Determines if one string ends with another string.
                 * @param str The string to check a suffix against.
                 * @param suffix The string suffix to check.
                 */
                StringUtilities.endsWith = function (str, suffix) {
                    return str.indexOf(suffix, str.length - suffix.length) !== -1;
                };
                /**
                 * Replaces a specific set of {@link Layer} tokens with layer values, given a token and the {@link Layer}.
                 * @param match The string that represents the token to replace.
                 * @param layer The {@link Layer} to use when substituting a value.
                 */
                StringUtilities.replaceLayerTokens = function (match, layer) {
                    if (layer) {
                        switch (match.toLowerCase()) {
                            case "layerid":
                                return layer.id;
                            case "layername":
                                return layer.name;
                            case "layerdisplayname":
                                return layer.displayName;
                            case "layerdescription":
                                return layer.description;
                        }
                    }
                    return "";
                };
                /**
                 * Replaces a specific set of {@link MapService} tokens with map service values, given a token and the {@link MapService}.
                 * @param match The string that represents the token to replace.
                 * @param mapService The {@link MapService} to use when substituting a value.
                 */
                StringUtilities.replaceMapServicetokens = function (match, mapService) {
                    if (mapService) {
                        switch (match.toLowerCase()) {
                            case "mapserviceid":
                                return mapService.id;
                            case "mapservicedisplayname":
                                return mapService.displayName;
                            case "mapserviceurl":
                                return mapService.url;
                            case "mapservicetoken":
                                return mapService.serviceToken;
                        }
                    }
                    return "";
                };
                /**
                 * Rest configuration object date strings are converted to the form "/Date(<ms since epoch time>)/" - even when the rest
                 * endpoint returns an ISO formatted date. This  will parse the string and convert it to a date object.
                 * @param restDateString The date string formatted as "/Date(<ms since epoch time>)/"
                 * @return A Date object created by parsing the given string or null on error.
                 */
                StringUtilities.getDateFromRestDateString = function (restDateString) {
                    restDateString = restDateString.trim();
                    var result = null;
                    var rgx = /^\/Date\(-?\d+\)\/$/;
                    if (!restDateString || !rgx.test(restDateString)) {
                        return null;
                    }
                    var epochMs = restDateString.substring(restDateString.indexOf("(") + 1, restDateString.indexOf(")"));
                    return isNaN(epochMs) ? null : new Date(parseInt(epochMs, 10));
                };
                return StringUtilities;
            }());
            utilities.StringUtilities = StringUtilities;
            if (typeof String.prototype.endsWith !== "function") {
                String.prototype.endsWith = function (suffix) {
                    return StringUtilities.endsWith(this, suffix);
                };
            }
        })(utilities = essentials.utilities || (essentials.utilities = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Stores a token and other ancillary information about the token and the user it was generated for.
         */
        var TokenResult = (function () {
            function TokenResult() {
            }
            return TokenResult;
        }());
        essentials.TokenResult = TokenResult;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="TokenResult.ts" />
/// <reference path="../../../../_Definitions/arcgis-js-api.d.ts" />
/// <reference path="utilities/DecomposedUri.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * A lightweight OAuth2Client helper.
         */
        var OAuth2Client = (function () {
            function OAuth2Client() {
            }
            /**
             * Gets token details from the URL, that have been specified in the OAuth2 implicit grant form.
             * The parameters should be in the URL fragement, with names: access_token, username, and expires_in. */
            OAuth2Client.getTokenFromImplicitGrant = function () {
                var uri = window.location.href;
                if (uri.indexOf("#") > 0) {
                    var hash = uri.substring(uri.indexOf("#") + 1, uri.length);
                    var hashObject = dojo.queryToObject(hash);
                    if (!hashObject.access_token) {
                        return null;
                    }
                    var result = new essentials.TokenResult();
                    result.token = hashObject.access_token;
                    result.userName = hashObject.username;
                    var expirationSeconds = parseInt(hashObject.expires_in);
                    if (expirationSeconds) {
                        result.expiresOn = new Date(new Date().getTime() + (expirationSeconds * 1000));
                    }
                    return result;
                }
                return null;
            };
            /**
             * Gets the error parameter from the URL fragement indicating there was a problem with the login. */
            OAuth2Client.getErrorFromImplicitGrant = function () {
                var uri = window.location.href;
                if (uri.indexOf("#") > 0) {
                    var hash = uri.substring(uri.indexOf("#") + 1, uri.length);
                    var hashObject = dojo.queryToObject(hash);
                    if (hashObject.error) {
                        var error = new OAuth2Error();
                        error.code = hashObject.error;
                        error.description = hashObject.error_description;
                        return error;
                    }
                }
                return null;
            };
            /**
             * Determines whether or not a token has been supplied using an implicit grant. In other words,
             * whether or not there is an access_token parameter in the fragment (hash) of the document URL.
             * @returns whether or not an access_token is present in the fragment (hash) of the document URL.
             */
            OAuth2Client.applicationHasImplicitGrant = function () {
                return OAuth2Client.hasFragmentParameter("access_token");
            };
            /**
             * Determines whether or not an error has been supplied using an implicit grant. In other words,
             * whether or not there is an error parameter in the fragment (hash) of the document URL.
             * @returns whether or not an error is present in the fragment (hash) of the document URL.
             */
            OAuth2Client.applicationHasImplicitGrantError = function () {
                return OAuth2Client.hasFragmentParameter("error");
            };
            /** @private */
            OAuth2Client.hasFragmentParameter = function (paramName) {
                var uri = window.location.href;
                if (uri.indexOf("#") < 0) {
                    return false;
                }
                var uri = window.location.href;
                var hash = uri.substring(uri.indexOf("#") + 1, uri.length);
                var hashObject = dojo.queryToObject(hash);
                return !!hashObject[paramName];
            };
            /**
             * Redirects to the logon page, using the implicit grant style that is recommended for HTML/JavaScript web applications.
             * @param logonUrl The URL of the OAuth2 logon page.
             * @param clientId The client ID to use for logging in. That should represent *this* application.
             */
            OAuth2Client.redirectToLogOnPage = function (logonUrl, clientId) {
                var redirectUri = new essentials.utilities.DecomposedUri(window.location.href);
                OAuth2Client.removeImplicitGrantParams(redirectUri);
                var navigateUri = logonUrl
                    + "?client_id=" + encodeURIComponent(clientId)
                    + "&response_type=token"
                    + "&redirect_uri=" + encodeURIComponent(redirectUri.recompose())
                    + "&expiration=20160";
                window.location.href = navigateUri;
            };
            /**
             * Removes all implicit grant parameters from the URL and updates the URL hash in the browser
             * so that it doesn't contain those parameters.
             */
            OAuth2Client.removeImplicitGrantParamsAndUpdateUrlHash = function () {
                var hostPageUri = new essentials.utilities.DecomposedUri(window.location.href);
                OAuth2Client.removeImplicitGrantParams(hostPageUri);
                window.location.hash = dojo.objectToQuery(hostPageUri.fragment);
            };
            OAuth2Client.removeImplicitGrantParams = function (uri) {
                delete uri.fragment.access_token;
                delete uri.fragment.username;
                delete uri.fragment.expires_in;
                delete uri.fragment.error;
                delete uri.fragment.error_description;
                return uri;
            };
            return OAuth2Client;
        }());
        essentials.OAuth2Client = OAuth2Client;
        /**
         * Represents an OAuth 2 error. See http://tools.ietf.org/html/rfc6749 for more information on OAuth
         * and OAuth errors.
         */
        var OAuth2Error = (function () {
            function OAuth2Error() {
            }
            /** The error code that results if the user denies the authorization. */
            OAuth2Error.ACCESS_DENIED_ERROR_CODE = "access_denied";
            return OAuth2Error;
        }());
        essentials.OAuth2Error = OAuth2Error;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/arcgis-js-api.d.ts" />
/// <reference path="utilities/DecomposedUri.ts" />
/// <reference path="utilities/StringUtilities.ts" />
/// <reference path="TokenResult.ts" />
/// <reference path="OAuth2Client.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * The ArcGisPortalSecurityContext contains the necessary information to be able to authenticate with [ArcGIS Online](https://www.arcgis.com/),
         * to initiate the authentication (perform a redirect to their OAuth login page), and to register a token with the {@link esri.IdentityManager}
         * so that map service requests will use the supplied token from [ArcGIS Online](https://www.arcgis.com/).
         * All of these actions are performed through the {@link initiate} method.
         */
        var ArcGisPortalSecurityContext = (function () {
            /**
             * Initializes a new instance of the {@link ArcGisPortalSecurityContext} class.
             * @param baseUrl The base URL of the ArcGIS Portal instance represented by this instance of the {@link ArcGisPortalSecurityContext}.
             * @param domains The collection of domains that the token result should be applied to.
             * @param clientId The ID of the client application.
             */
            function ArcGisPortalSecurityContext(baseUrl, domains, clientId) {
                this.baseUrl = baseUrl;
                this.domains = domains;
                this.clientId = clientId;
            }
            /**
             * Ensures that we have a token available from an OAuth2 log on. Will redirect to the login page if a token has not yet been supplied in the URL.
             */
            ArcGisPortalSecurityContext.prototype.initiate = function () {
                if (!this.tokenResult) {
                    this.tokenResult = essentials.OAuth2Client.getTokenFromImplicitGrant();
                }
                if (!this.tokenResult) {
                    this.error = essentials.OAuth2Client.getErrorFromImplicitGrant();
                    if (!this.error) {
                        essentials.OAuth2Client.redirectToLogOnPage(this.getLogOnUrl(), this.clientId);
                    }
                    essentials.OAuth2Client.removeImplicitGrantParamsAndUpdateUrlHash();
                    return false;
                }
                essentials.OAuth2Client.removeImplicitGrantParamsAndUpdateUrlHash();
                return true;
            };
            /**
             * Gets the URL of the OAuth2 login page (base url + oauth2/authorize).
             */
            ArcGisPortalSecurityContext.prototype.getLogOnUrl = function () {
                return this.baseUrl + "oauth2/authorize";
            };
            /**
             * Gets an ArcGIS Portal token for the service located at the specified URI, or null if a Portal token is not assigned to this service.
             * @param serviceUri The portal service URI.
             */
            ArcGisPortalSecurityContext.prototype.getToken = function (serviceUri) {
                if (!this.tokenResult || !serviceUri) {
                    return null;
                }
                if (this.appliesTo(serviceUri)) {
                    return this.tokenResult.token;
                }
                return null;
            };
            /**
             * Determines if the portal security represented by this instance should be applied to a particular service, located at the specified URI.
             * @param serviceURi The service to check.
             */
            ArcGisPortalSecurityContext.prototype.appliesTo = function (serviceUri) {
                var serviceHost = essentials.utilities.DecomposedUri.getHost(serviceUri);
                for (var i = 0; i < this.domains.length; i++) {
                    if (essentials.utilities.StringUtilities.endsWith(serviceHost, this.domains[i])) {
                        return true;
                    }
                }
                return false;
            };
            return ArcGisPortalSecurityContext;
        }());
        essentials.ArcGisPortalSecurityContext = ArcGisPortalSecurityContext;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents a base map.
         * A base map is one or more map services that acts as a reference for the map.
         */
        var BaseMap = (function () {
            function BaseMap(essentialsMap) {
                /** The display name. */
                this.displayName = null;
                /** The Essentials map that this base map belongs to. */
                this.essentialsMap = null;
                /**
                 * The collection of {@link Extension} objects associated with the base map.
                 * Extensions can be defined by the administrator on the server.
                 */
                this.extensions = [];
                /** The ID of the {@link BaseMap} */
                this.id = null;
                /** URI to an icon representation of this map service, for display in client applications. */
                this.iconUri = null;
                /** Optional URI to a map service supporting the exportTiles operation to represent this basemap as a TPK. */
                this.exportTilesMapServiceUri = null;
                /** The properties of the {@link BaseMap}, as defined by the administrator on the server. */
                this.properties = {};
                /** The collection of services that belong to this basemap. */
                this.services = [];
                if (!essentialsMap) {
                    throw new Error("Essentials map is required for a basemap.");
                }
                this.essentialsMap = essentialsMap;
            }
            return BaseMap;
        }());
        essentials.BaseMap = BaseMap;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents an individual map service within a base map.
         */
        var BaseMapService = (function () {
            /** Reserved for future use, such as per-basemap opacity settings. */
            function BaseMapService(mapService) {
                /** The map service. */
                this.mapService = null;
                if (!mapService) {
                    throw new Error("Map service is required for a basemap service.");
                }
                this.mapService = mapService;
            }
            return BaseMapService;
        }());
        essentials.BaseMapService = BaseMapService;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/**
 * Note: References to ValidationResult.ts, FormItemResult.ts, and ValidationItem.ts were causing circular references here.
 * Interestingly, this issue was only triggered when the workflow handlers are compiled as TypeScript. -jscharf
 */
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            var AbstractFormItem = (function () {
                /**
                 * Initializes a new instance of the {@link FormItem} class.
                 * @param xmlNode Xml node containing the form item definition.
                 * @param formDefinition The form definition that this form item belongs to.
                 */
                function AbstractFormItem(xmlNode, formDefinition) {
                    /** The value indicating whether this item is required. */
                    this.isRequired = new Observable(false);
                    /** The value indicating whether this item is valid. */
                    this.isValid = new Observable(true);
                    /** The value indicating whether this item is visible or not.*/
                    this.isVisible = new Observable(true);
                    /** The name of the argument that will be used to store the result of this item. */
                    this.argumentName = null;
                    /** Gets the collection of {@link validation.ValidationItem} objects that belong to this {@link FormItem}.
                     * @type ValidationItem[]
                     */
                    this.validationItems = [];
                    this.formDefinition = formDefinition || null;
                    this["attached_indicatorClass"] = new Observable("");
                    this["attached_showIndicator"] = new Observable("");
                    if (xmlNode) {
                        this.toolTip = new Observable(geocortex.forms.getElementText(xmlNode, "ToolTip"));
                        this.itemID = new Observable(geocortex.forms.getElementText(xmlNode, "ItemID"));
                        this.argumentName = new Observable(geocortex.forms.getElementText(xmlNode, "ArgumentName"));
                        var isVisibleText = geocortex.forms.getElementText(xmlNode, "IsVisible");
                        if (isVisibleText) {
                            this.isVisible.set(geocortex.forms._parseBoolean(isVisibleText));
                        }
                        var validationItems = geocortex.forms.getElement(xmlNode, "ValidationItems");
                        if (validationItems != null) {
                            // Add all the validation items
                            for (var i = 0; i < validationItems.childNodes.length; i++) {
                                var validationItem = geocortex.forms.items._processValidationItem(validationItems.childNodes[i]);
                                // can't hold a reference to RequiredValidationItem until circular references with inheritance are properly resolved
                                // see: https://typescript.codeplex.com/workitem/913
                                if (validationItem instanceof geocortex.forms.items.validation.RequiredValidationItem) {
                                    this.isRequired.set(true);
                                }
                                if (validationItem != null) {
                                    this.validationItems.push(validationItem);
                                }
                            }
                        }
                    }
                    else {
                        this.toolTip = new Observable("");
                        this.itemID = new Observable(null);
                        this.argumentName = new Observable(null);
                    }
                }
                /**
                 * Gets the result of the form item.
                 * @return {{@link geocortex.forms.items.FormItemResult}[]}
                 */
                AbstractFormItem.prototype.getResult = function () {
                    // A true abstract class wouldn't need to declare this
                    return null;
                };
                /**
                 * Raises the FormItemResultChangedEvent.
                 */
                AbstractFormItem.prototype._notifyResultChanged = function () {
                    dojo.publish("FormItemResultChangedEvent", [this]);
                };
                /**
                 * Refreshes the user interface of the form item.
                 */
                AbstractFormItem.prototype.refresh = function () {
                    // Do nothing in the base class
                    // The method implementation will be provided by the parent ContainerFormItem
                };
                /**
                 * Validates the form item.
                 * Returns a collection of invalid items.
                 * @return {{@link geocortex.forms.items.validation.ValidationResult}[]}
                 */
                AbstractFormItem.prototype.validate = function () {
                    var result = [];
                    this.isValid.set(true);
                    // Check if there are validation items for this form item
                    if (this.validationItems != null) {
                        // Loop through the item
                        for (var i = 0; i < this.validationItems.length; i++) {
                            var itemResult = this.getResult();
                            if (itemResult != null) {
                                itemResult = itemResult.value;
                            }
                            var validationResult = this.validationItems[i].validate(itemResult);
                            // Only return the invalid items
                            if (!validationResult.isValid) {
                                this.isValid.set(false);
                                result.push(validationResult);
                            }
                        }
                    }
                    return result;
                };
                /**
                 * @private Renders the form item.
                 */
                AbstractFormItem.prototype._render = function () {
                    return document.createTextNode(this.itemID.get());
                };
                /**
                 * @private
                 */
                AbstractFormItem.prototype._destroy = function () {
                    // A true abstract class wouldn't need to declare this
                };
                return AbstractFormItem;
            }());
            items.AbstractFormItem = AbstractFormItem;
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="FormItem.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            var LabelFormItem = (function (_super) {
                __extends(LabelFormItem, _super);
                /**
                 * Initializes a new instance of the {@link geocortex.forms.items.LabelFormItem} class.
                 * @param xmlNode Xml node containing the form item definition.
                 * @param formDefinition The form definition that this form item belongs to.
                 */
                function LabelFormItem(xmlNode, formDefinition) {
                    _super.call(this, xmlNode, formDefinition);
                    this.formItemType = "LabelFormItem";
                    if (xmlNode) {
                        this.text = new Observable(geocortex.forms.getElementText(xmlNode, "Text"));
                        this.labelForItemID = new Observable(geocortex.forms.getElementText(xmlNode, "LabelForItemID"));
                    }
                    else {
                        this.text = new Observable(null);
                        this.labelForItemID = new Observable(null);
                    }
                }
                /**
                 * @private Renders the form item.
                 */
                LabelFormItem.prototype._render = function () {
                    return geocortex.forms.renderFormItem(this);
                };
                return LabelFormItem;
            }(items.AbstractFormItem));
            items.LabelFormItem = LabelFormItem;
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="FormItem.ts" />
/// <reference path="LabelFormItem.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            function initLabelContainer(lc, xmlNode, formDefinition) {
                if (xmlNode) {
                    lc.label = new items.LabelFormItem(geocortex.forms.getElement(xmlNode, "Label"));
                    // Add tooltip to the label if not present
                    if (lc.label.toolTip.get() == "" && lc.toolTip != null) {
                        lc.label.toolTip.set(lc.toolTip.get());
                    }
                }
                else {
                    lc.label = new geocortex.forms.items.LabelFormItem(null);
                }
            }
            items.initLabelContainer = initLabelContainer;
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            var FormItemResult = (function () {
                /**
                 * Initializes a new instance of the {@link geocortex.forms.items.FormItemResult} class.
                 * @param argumentName Name of the argument for this result.
                 * @param value Value for this result.
                 * @param wasSet Indicates whether the value was set due to user interaction.
                 */
                function FormItemResult(argumentName, value, wasSet) {
                    /**
                     * Indicate if the result is a list of items (not a single item).
                     * @type Boolean
                     */
                    this.isList = false;
                    this.argumentName = argumentName;
                    this.value = value;
                    this.wasSet = wasSet || false;
                }
                return FormItemResult;
            }());
            items.FormItemResult = FormItemResult;
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../../_Definitions/framework.d.ts" />
/// <reference path="LabelContainer.ts" />
/// <reference path="FormItemResult.ts" />
/// <reference path="FormItem.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            var TextBoxFormItem = (function (_super) {
                __extends(TextBoxFormItem, _super);
                /**
                 * Initializes a new instance of the {@link geocortex.forms.items.TextBoxFormItem} class.
                 * @param xmlNode Xml node containing the form item definition.
                 * @param formDefinition The form definition that this form item belongs to.
                 */
                function TextBoxFormItem(xmlNode, formDefinition) {
                    var _this = this;
                    _super.call(this, xmlNode, formDefinition);
                    this.formItemType = "TextBoxFormItem";
                    if (xmlNode) {
                        var defaultText = geocortex.forms.getElementText(xmlNode, "DefaultText");
                        this.defaultText = new Observable(defaultText);
                        this.text = new Observable(defaultText);
                        this.inputScope = new Observable(geocortex.forms.getElementText(xmlNode, "InputScope"));
                        this.textboxWidth = new Observable(parseInt(geocortex.forms.getElementText(xmlNode, "TextboxWidth")));
                        this.readOnly = new Observable(geocortex.forms._parseBoolean(geocortex.forms.getElementText(xmlNode, "ReadOnly")));
                    }
                    else {
                        this.defaultText = new Observable("");
                        this.text = new Observable("");
                        this.inputScope = new Observable("Default");
                        this.textboxWidth = new Observable(NaN);
                        this.readOnly = new Observable(false);
                    }
                    items.initLabelContainer(this, xmlNode, formDefinition);
                    this.text.bind(null, function (result) { return _this._notifyResultChanged(); });
                }
                /**
                 * Gets the result of the form item.
                 * @return {{@link geocortex.forms.items.FormItemResult}[]}
                 */
                TextBoxFormItem.prototype.getResult = function () {
                    return new items.FormItemResult(this.argumentName.get(), this.text.get());
                };
                /**
                 * @private Renders the form item.
                 */
                TextBoxFormItem.prototype._render = function () {
                    return geocortex.forms.renderFormItem(this);
                };
                return TextBoxFormItem;
            }(items.AbstractFormItem));
            items.TextBoxFormItem = TextBoxFormItem;
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../../_Definitions/framework.d.ts" />
/// <reference path="TextBoxFormItem.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            var TextAreaFormItem = (function (_super) {
                __extends(TextAreaFormItem, _super);
                /**
                 * Initializes a new instance of the {@link geocortex.forms.items.TextAreaFormItem} class.
                 * @param xmlNode Xml node containing the form item definition.
                 * @param formDefinition The form definition that this form item belongs to.
                 */
                function TextAreaFormItem(xmlNode, formDefinition) {
                    _super.call(this, xmlNode, formDefinition);
                    this.formItemType = "TextAreaFormItem";
                    if (xmlNode) {
                        this.textboxHeight = new Observable(parseInt(geocortex.forms.getElementText(xmlNode, "TextboxHeight")));
                    }
                    else {
                        this.textboxHeight = new Observable(1);
                    }
                }
                return TextAreaFormItem;
            }(items.TextBoxFormItem));
            items.TextAreaFormItem = TextAreaFormItem;
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="AsyncInitializable.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Client representation of an extension object, as configured by an administrator.
         */
        var Extension = (function () {
            /**
             * Initializes a new instance of the {@link geocortex.essentials.Extension} class.
             * @param className Name of the class.
             * @param instance The extension object instance.
             */
            function Extension(className, instance) {
                this.className = className;
                this.instance = instance;
            }
            return Extension;
        }());
        essentials.Extension = Extension;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/arcgis-js-api.d.ts" />
/// <reference path="../../../../_Definitions/dojo.d.ts" />
/** @private */
var geocortex;
(function (geocortex) {
    var optimizer;
    (function (optimizer) {
        var EventRelay = (function () {
            /**
             * Initializes a new instance of the {@link geocortex.optimizer.EventRelay} class.
             * @param map ESRI map object whose events will be logged.
             * @param siteId Name to use to uniquely identify the site generating the log events.
             * @param endpointUrl Alternate URL for the optimizer rest logging endpoint.  Must
             * include the f=json url parameter.
             * @param userName The username of the local user
             */
            function EventRelay(map, siteId, endpointUrl, userName) {
                var _this = this;
                /**
                 * @private - Timer used to delay posting the log messages. The
                 * timer is reset every time that the map extent changes so that
                 * we build up a queue of messages to send when the user stops
                 * panning/zooming the map.
                 */
                this._timer = null;
                // Initialize local variables
                this._siteId = "";
                this._endpointUrl = "";
                this.userName = "";
                this._extentConnect = null;
                this._numConsecutiveFailures = 0;
                this._enabled = true;
                this._sessionId = "";
                this._previousScale = -1;
                this._firstExtentLogged = false;
                this._map = map;
                if (siteId) {
                    this._siteId = siteId;
                }
                if (endpointUrl) {
                    this._endpointUrl = endpointUrl;
                }
                else {
                    this._endpointUrl = window.location.protocol + "//" + window.location.host + "/Geocortex/Optimizer/Rest/DataRelay/LogData.ashx?f=json";
                }
                if (userName) {
                    this.userName = userName;
                }
                this._pendingEvents = new Array();
                this._timer = new geocortex.framework.utils.TimeDelayedAction(3000, this._flushQueue, this);
                var extentChangeContent = {};
                extentChangeContent.extent = this._map.extent;
                // Hook up to the map extent change event, ensuring that the map has been loaded
                if (map.loaded) {
                    // log initial extent
                    this._logExtentChange(extentChangeContent);
                    // hook up for subsequent extent changes
                    this._extentConnect = map.on("extent-change", dojo.hitch(this, "_logExtentChange"));
                }
                else {
                    map.on("load", function () {
                        // log initial extent
                        _this._logExtentChange(extentChangeContent);
                        // hook up for subsequent extent changes
                        _this._extentConnect = map.on("extent-change", dojo.hitch(_this, "_logExtentChange"));
                    });
                }
                // Assign a new sessionId, using a hash of the current time concatenated with the user agent string (user agent string
                // used to further decrease chance of collision)
                this._sessionId = this._crc32(new Date().getTime() + "" + navigator.userAgent);
            }
            /**
             * Logs a change of map extent to the Optimizer Rest endpoint.
             * This is the method hooked into the onExtentChange event of
             * the esri.Map object.  If the map scale has changed as well,
             * a call will be made from this method to log a scale change
             * event with Optimizer.
             * @param args Object containing the following extent arguments :- "extent": The new extent of the map; "delta" The change
             * in the x and y values from the previous extent (passed by esri.Map event); "levelChange": When using ArcGIS Server tiled
             * map services, the value is true when the user zooms to a new level; "lod": Level of Detail associated with the current
             * map extent, only if the map uses tiled service(s).
             */
            EventRelay.prototype._logExtentChange = function (args) {
                if (this._enabled) {
                    var content;
                    content = {};
                    // Populate our data with the extent supplied by the event
                    content.data = [{
                            "name": "ArcGISExtents",
                            "columns": {}
                        }];
                    content.data[0].columns = [
                        {
                            "type": "tinyint",
                            "name": "InitialExtent",
                            "key": "InitialExtent"
                        },
                        {
                            "type": "real",
                            "name": "XMinNew",
                            "key": "XMinNew"
                        },
                        {
                            "type": "real",
                            "name": "YMinNew",
                            "key": "YMinNew"
                        },
                        {
                            "type": "real",
                            "name": "XMaxNew",
                            "key": "XMaxNew"
                        },
                        {
                            "type": "real",
                            "name": "YMaxNew",
                            "key": "YMaxNew"
                        }
                    ];
                    content.data[0].rows = [{
                            "InitialExtent": (this._firstExtentLogged ? 0 : 1),
                            "XMinNew": args.extent.xmin,
                            "YMinNew": args.extent.ymin,
                            "XMaxNew": args.extent.xmax,
                            "YMaxNew": args.extent.ymax
                        }];
                    this._queueData(content);
                    // Register that the first extent has been logged, which means
                    // that InitialExtent will be false for subsequent log entries
                    // during the same session
                    this._firstExtentLogged = true;
                    // Determine if the scale needs to be changed
                    if (args.lod) {
                        if (args.levelChange && this._previousScale > -1) {
                            this._logScaleChange(this._previousScale, args.lod.scale);
                        }
                        this._previousScale = args.lod.scale;
                    }
                    else {
                        var scale = this._map.getScale(); // No tiled services
                        if (scale !== null) {
                            // Log only if there has been a scale change, and then only if this is not
                            // the first request of the session
                            if (this._previousScale != scale && this._previousScale > -1) {
                                this._logScaleChange(this._previousScale, scale);
                            }
                            this._previousScale = scale;
                        }
                    }
                }
            };
            /**
             * Logs a scale change event to the Optimizer Rest endpoint
             * @param oldScale The previous scale value of the map
             * @param newScale The new (current) scale value of the map
             */
            EventRelay.prototype._logScaleChange = function (oldScale, newScale) {
                if (this._enabled) {
                    var content = {};
                    // Populate our data with the extent supplied by the event
                    content.data = [{
                            "name": "ArcGISScale",
                            "columns": []
                        }];
                    content.data[0].columns = [
                        {
                            "type": "float",
                            "name": "ScaleOld",
                            "key": "ScaleOld"
                        },
                        {
                            "type": "float",
                            "name": "ScaleNew",
                            "key": "ScaleNew"
                        }
                    ];
                    content.data[0].rows = [{
                            "ScaleOld": oldScale,
                            "ScaleNew": newScale
                        }];
                    this._queueData(content);
                }
            };
            /**
             * Logs a tool usage event to the Optimizer Rest endpoint
             * @param toolName Name of the tool used
             * @param toolData Specifics of the tool usage
             */
            EventRelay.prototype.logToolUsage = function (toolName, toolData) {
                if (this._enabled) {
                    var content = {};
                    content.data = [{
                            "name": "ArcGISTool",
                            "columns": []
                        }];
                    content.data[0].columns = [
                        {
                            "type": "ustr",
                            "name": "Tool",
                            "key": "Tool"
                        },
                        {
                            "type": "ustr",
                            "name": "ToolData",
                            "key": "ToolData"
                        }
                    ];
                    content.data[0].rows = [{
                            "Tool": toolName,
                            "ToolData": toolData
                        }];
                    this._queueData(content);
                }
            };
            /**
            * Adds the log event to the queue, which will be run when a
            * specified amount of time passes after a map extent change.
            * This function will mix in values common to all log events to
            * the content before queueing.
            */
            EventRelay.prototype._queueData = function (content) {
                // Add all of the common stuff to the data
                content.platform = "js";
                content.data[0].columns.push({
                    "type": "now",
                    "name": "SampleTime",
                    "key": "SampleTime"
                }, {
                    "type": "origin",
                    "name": "UserAddress",
                    "key": "UserAddress"
                }, {
                    "type": "ustr",
                    "name": "SiteId",
                    "key": "SiteId"
                }, {
                    "type": "ustr",
                    "name": "UserAgent",
                    "key": "UserAgent"
                }, {
                    "type": "ustr",
                    "name": "UserName",
                    "key": "UserName"
                }, {
                    "type": "ustr",
                    "name": "LayerList",
                    "key": "LayerList"
                }, {
                    "type": "int",
                    "name": "SessionId",
                    "key": "SessionId"
                }, {
                    "type": "ustr",
                    "name": "ClientType",
                    "key": "ClientType"
                }, {
                    "type": "host",
                    "name": "MachineName",
                    "key": "MachineName"
                });
                dojo.mixin(content.data[0].rows[0], {
                    "SiteId": this._siteId,
                    "UserAgent": navigator.userAgent,
                    "UserName": this.userName,
                    "LayerList": this._getCurrentLayerList(),
                    "SessionId": this._sessionId,
                    "ClientType": "JavaScript"
                });
                this._pendingEvents.push(content);
                this._timer.reset();
            };
            /*
             * Posts all queued Optimizer log messages to the REST endpoint.
             */
            EventRelay.prototype._flushQueue = function () {
                this._timer.stop();
                while (this._pendingEvents.length > 0) {
                    var pendingEvent = this._pendingEvents.shift();
                    this._logData(pendingEvent);
                }
            };
            /**
             * Logs the supplied content to the Optimizer rest endpoint.
             * @param content Content to post to the REST endpoint
             */
            EventRelay.prototype._logData = function (content) {
                try {
                    dojo.xhrPost({
                        "url": this._endpointUrl,
                        "postData": JSON.stringify(content),
                        "timeout": 10000,
                        "load": dojo.hitch(this, this._handleLogSuccessResponse),
                        "error": dojo.hitch(this, this._handleLogErrorResponse)
                    });
                }
                catch (err) {
                    console.log(err.message);
                    this._incrementFailures();
                }
            };
            /**
             * @private
             * Handler for a successful log response from the Optimizer Rest
             * endpoint. Will reset the failure counter.
             * @param logResult The response supplied by the async request
             */
            EventRelay.prototype._handleLogSuccessResponse = function (logResult) {
                this._numConsecutiveFailures = 0;
            };
            /**
             * Handler for an unsuccessful (error) log response from the Optimizer
             * Rest endpoint.  Will increment the failure counter.
             * @param errorMessage Reason for the failure
             */
            EventRelay.prototype._handleLogErrorResponse = function (errorMessage) {
                console.log(errorMessage);
                this._incrementFailures();
            };
            /**
             * Increments the failure counter, and disables this relay if the
             * failure count is greater than 2.
             */
            EventRelay.prototype._incrementFailures = function () {
                // After three failures, disable the logger
                this._numConsecutiveFailures++;
                if (this._numConsecutiveFailures > 2) {
                    dojo.disconnect(this._extentConnect);
                    this._enabled = false;
                }
            };
            /**
             * Gets the list of currently visible layers in the map.  Dynamic services
             * will use the name from the LayerInfo, as will tiled AGS layers.  Bing
             * maps will use the format "Bing: <mapType>", such as "Bing: aerial".  Image
             * layers will use the format "Image: <layerUrl>".  Each layer is separated
             * by "\t" (backslash-tab), to identify to the Rest endpoint to replace the
             * character sequence with an actual tab character for inclusion into the
             * Optimizer database.
             */
            EventRelay.prototype._getCurrentLayerList = function () {
                var layerNames = "";
                var layerIds = this._map.layerIds;
                for (var ix = 0; ix < layerIds.length; ix++) {
                    var layerId = layerIds[ix];
                    var layer = this._map.getLayer(layerId);
                    // Check if the service layer is available and visible
                    if ((layer != null) && layer.visible && layer.visibleAtMapScale) {
                        var iix;
                        if (layer instanceof esri.layers.ArcGISDynamicMapServiceLayer) {
                            // Get all the visible ids
                            var dynamicLayer = layer;
                            for (iix = 0; iix < dynamicLayer.visibleLayers.length; iix++) {
                                if (dynamicLayer.visibleLayers[iix] == null || dynamicLayer.visibleLayers[iix] == -1) {
                                    continue;
                                }
                                layerNames += dynamicLayer.layerInfos.filter(function (layer) { return layer.id == dynamicLayer.visibleLayers[iix]; })[0].name + "\\t";
                            }
                        }
                        else if (layer instanceof esri.virtualearth.VETiledLayer) {
                            // Bing maps do not have child layers, so just use the
                            // style of the Bing layer (will be either aerial,
                            // aerial with labels, or road)
                            var bingLayer = layer;
                            layerNames += "Bing:" + bingLayer.mapStyle + "\\t";
                        }
                        else if (layer instanceof esri.layers.ArcGISImageServiceLayer) {
                            // Really, the only thing we have that can uniquely id
                            // this layer is the URL...
                            layerNames += "Image:" + layer.url + "\\t";
                        }
                        else if (layer instanceof esri.layers.ArcGISTiledMapServiceLayer) {
                            // Just get all the ids of the configured layers
                            var tiledLayer = layer;
                            for (iix = 0; iix < tiledLayer.layerInfos.length; iix++) {
                                if (tiledLayer.layerInfos[iix] == null) {
                                    continue;
                                }
                                layerNames += tiledLayer.layerInfos[iix].name + "\\t";
                            }
                        }
                    }
                }
                // Remove the trailing separator characters if the layer list is not empty
                if (layerNames.length > 3) {
                    layerNames = layerNames.substring(0, layerNames.length - 2);
                }
                return layerNames;
            };
            /**
             * Javascript crc32 implementation from www.webtoolkit.info
             * @param str String for which to generate a hash
             */
            EventRelay.prototype._crc32 = function (str) {
                str = str.replace(/\r\n/g, "\n");
                var utftext = "";
                // Utf8Encode
                for (var n = 0; n < str.length; n++) {
                    var c = str.charCodeAt(n);
                    if (c < 128) {
                        utftext += String.fromCharCode(c);
                    }
                    else {
                        if ((c > 127) && (c < 2048)) {
                            utftext += String.fromCharCode((c >> 6) | 192);
                            utftext += String.fromCharCode((c & 63) | 128);
                        }
                        else {
                            utftext += String.fromCharCode((c >> 12) | 224);
                            utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                            utftext += String.fromCharCode((c & 63) | 128);
                        }
                    }
                }
                str = utftext;
                var table = "00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D";
                var crc = 0;
                var x;
                var y;
                crc = crc ^ (-1);
                for (var i = 0, iTop = str.length; i < iTop; i++) {
                    y = (crc ^ str.charCodeAt(i)) & 255;
                    x = "0x" + table.substr(y * 9, 8);
                    crc = (crc >>> 8) ^ x;
                }
                crc = crc ^ (-1);
                return crc.toString();
            };
            return EventRelay;
        }());
        optimizer.EventRelay = EventRelay;
    })(optimizer = geocortex.optimizer || (geocortex.optimizer = {}));
})(geocortex || (geocortex = {}));
/// <reference path="essentials/AsyncInitializable.ts" />
/// <reference path="forms/items/TextAreaFormItem.ts" />
/// <reference path="forms/items/TextBoxFormItem.ts" />
/// <reference path="essentials/Extension.ts" />
/// <reference path="essentials/RestHelperHttpService.ts" />
/// <reference path="../../../_Definitions/dojo.d.ts" />
/// <reference path="essentials/Extension.ts" />
/// <reference path="../../../_Definitions/arcgis-js-api.d.ts" />
/// <reference path="optimizer/EventRelay.ts" />
var geocortex;
(function (geocortex) {
    ;
    /** @private */
    geocortex.config = {
        /** @private */
        baseUrl: "http://localhost/",
        io: {
            errorHandler: function (err, io) {
                dojo.publish("geocortex.Error", [err]);
            },
            postLength: 2000,
            timeout: 60000
        },
        REST_version: "3.0",
        authenticationDialogId: null
    };
    /**
     * Helper function that resolves a {@link dojo.Deferred}.
     * @private
     * @param def The {@link dojo.Deferred} to resolve.
     * @param result The result to invoke the deferred's resolve callback with.
     */
    function deferredResolve(def, result) {
        if (def && (def.fired == -1)) {
            def.resolve(result);
        }
    }
    geocortex.deferredResolve = deferredResolve;
    /**
     * Helper function that rejects a {@link dojo.Deferred}.
     * @private
     * @param def The {@link dojo.Deferred} to reject.
     * @param result The result to invoke the deferred's reject callback with.
     */
    function deferredReject(def, result) {
        if (def && (def.fired == -1)) {
            def.reject(result);
        }
    }
    geocortex.deferredReject = deferredReject;
    /**
     * Encodes an object in a format that is ready for serialization as URL parameters or a POST body.
     * @param objectToEncode The object to encode for serialization.
     */
    function encodeJson(objectToEncode) {
        var jsonObject = encodeJsonInternal(objectToEncode);
        var toReturn = {};
        for (var i in jsonObject) {
            if (dojo.isArray(jsonObject[i]) || typeof (jsonObject[i]) === "object") {
                toReturn[i] = JSON.stringify(jsonObject[i]);
            }
            else {
                toReturn[i] = jsonObject[i];
            }
        }
        return toReturn;
    }
    geocortex.encodeJson = encodeJson;
    /** @private */
    function encodeJsonInternal(objectToEncode) {
        var member, type;
        var jsonObject = Array.isArray(objectToEncode) ? [] : {};
        // GVH-3594 Need to properly handle arrays of primitive types
        type = typeof (objectToEncode);
        if (objectToEncode !== null && (type === "number" || type === "boolean" || type === "string")) {
            return objectToEncode;
        }
        if (typeof (objectToEncode.toJson) === "function") {
            jsonObject = objectToEncode.toJson();
        }
        for (var i in objectToEncode) {
            if (i == "declaredClass" || i.indexOf("_inherited") > -1 || jsonObject[i] !== undefined) {
                continue;
            }
            member = objectToEncode[i];
            type = typeof (member);
            if (member !== null && member !== undefined && type !== "function") {
                if (Array.isArray(member)) {
                    jsonObject[i] = [];
                    for (var p = 0, pl = member.length; p < pl; p++) {
                        jsonObject[i][p] = encodeJsonInternal(member[p]);
                    }
                }
                else {
                    if (type === "object") {
                        if (typeof (member.toJson) === "function") {
                            jsonObject[i] = member.toJson();
                        }
                        else {
                            jsonObject[i] = encodeJsonInternal(member);
                        }
                    }
                    else {
                        jsonObject[i] = member;
                    }
                }
            }
        }
        return jsonObject;
    }
    /**
     * A wrapper around `dojo.io.script.get` and `dojo.xhrPost`.
     * It will determine which one to use depending on the amount of data being sent.
     * @param request The request object.
     * @param options The request options.
     */
    function request(request, options) {
        if (!options) {
            options = {};
        }
        if (!options.gcx) {
            options.gcx = {};
        }
        if (options.gcx.preventCache === undefined) {
            // Default behaviour is to revert to previous behaviour for backwards compatibility
            request.preventCache = true;
        }
        else if (!options.gcx.preventCache) {
            request.preventCache = false;
        }
        else {
            request.preventCache = true;
        }
        request.timeout = request.timeout || geocortex.config.io.timeout;
        request.handleAs = request.handleAs || "json";
        // Determine whether a proxy url is set and if one is required (e.g. for cross domain posts).
        var requiresProxy = geocortex.requiresProxy(request);
        var hasProxy = geocortex.hasProxy();
        if (requiresProxy && !hasProxy) {
            var e = new Error("Cross-domain or large requests require a proxy.");
            if (dojo.isFunction(request.error)) {
                request.error(e);
            }
            var def = new dojo.Deferred();
            def.errback(e);
            return def;
        }
        delete request.gcx;
        options.useProxy = requiresProxy;
        // Unless otherwise specified, don't use the new (Esri 3.3+) IdentityManager facility to authenticate against
        // Geocortex resources.
        if (!options.hasOwnProperty("disableIdentityLookup")) {
            options.disableIdentityLookup = true;
        }
        var srv = new geocortex.essentials.RestHelperHTTPService(request, options);
        return srv.send();
    }
    geocortex.request = request;
    /**
     * Detects whether or not a proxy URL has been configured on the global ArcGIS JSAPI configuration object.
     */
    function hasProxy() {
        var has = false;
        try {
            has = esri._getProxyUrl();
        }
        catch (e) {
        }
        return has;
    }
    geocortex.hasProxy = hasProxy;
    /**
     * Detects whether a request requires the viewer proxy. This will return true if the request length is greater than the
     * configured GET size limit, or if the request is to a different domain.
     * @param request The desired request.
     */
    function requiresProxy(request) {
        var req = false;
        try {
            // If cors is supported, and the server is flagged as supporting cors, then we don't need the proxy
            if (require.has("esri-cors")) {
                var urlComponents = geocortex.essentials.utilities.UrlUtilities.getUrlComponents(request.url);
                if (esri.config.defaults.io.corsEnabledServers.indexOf(urlComponents.host) >= 0) {
                    return false;
                }
            }
            // Compute the overall length of the request.
            var len = request.url.length;
            if (request.content) {
                len += dojo.objectToQuery(request.content).length;
            }
            // Get the location and a Url object for the request URL
            var _url = new dojo._Url(request.url);
            var loc = window.location;
            // Check to see if this should be a post.
            var isPost = len > geocortex.config.io.postLength;
            // Compare the domains. If no protocol, port, and hostname is present, we will consider the URL relative.
            if (!_url.scheme && !_url.host && !_url.port) {
                return false;
            }
            // GMAF's proxy can't do SSL.  It's never a good idea to force the proxy in that case.
            if (/\bGeocortexApp\b/.test(navigator.userAgent) && _url.scheme === "https") {
                return false;
            }
            var isXDomain = !(loc.protocol + "//" + loc.hostname + (loc.port ? ":" + loc.port : "") === _url.scheme + "://" + _url.host + (_url.port ? ":" + _url.port : ""));
            req = isPost && isXDomain;
        }
        catch (e) {
        }
        return req;
    }
    geocortex.requiresProxy = requiresProxy;
    /**
     * Creates a query object from a URL, creating object properties for any URL parameters found in the URL.
     * @param url The url to convert.
     */
    function urlToQueryObject(url) {
        var i = url.indexOf("?");
        if (i === -1) {
            return null;
        }
        else {
            return dojo.queryToObject(url.substring(i + 1));
        }
    }
    geocortex.urlToQueryObject = urlToQueryObject;
    /** @private */
    function _getExtensions(extensions) {
        var results = [];
        if (!extensions) {
            return results;
        }
        results.length = extensions.length;
        for (var i = 0; i < extensions.length; i++) {
            results[i] = new geocortex.essentials.Extension(extensions[i].className, extensions[i].instance);
        }
        return results;
    }
    geocortex._getExtensions = _getExtensions;
    /** @private */
    function _getProperties(properties) {
        var results = {};
        if (!properties) {
            return results;
        }
        for (var i = 0; i < properties.length; i++) {
            results[properties[i].name] = properties[i].value;
        }
        return results;
    }
    geocortex._getProperties = _getProperties;
})(geocortex || (geocortex = {}));
// Shim for lack of support of `now` in ES3 (IE8/Android 2.3)
/** @private */
Date.now || (Date.now = function () { return +new Date; });
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Carries materials related to a successful authentication against a {@link Site} and manages a queue
         * of requests that are pending authentication. */
        var AuthenticationControlBlock = (function () {
            function AuthenticationControlBlock() {
                /** The message returned from the security server. */
                this.messageFromServer = null;
                /** The password used to obtain the current token. */
                this.password = null;
                /** List of REST requests waiting for a token. */
                this.pendingCalls = [];
                /** The Url to the token service, as returned by the 401. */
                this.tokenService = null;
                /**
                 * The base url of the token server - for example, if the token url is
                 * http://host/rest/site/sitename/authenticate the base url will be http://host/rest/site/sitename.
                 */
                this.tokenRootUri = null;
                /**
                 * The base url of the original request that triggered a call to the token server. It allows
                 * to set up token servers outside of the base TokenRootUri - for example, if the token url is
                 * http://host/rest/site/sitename/authenticate the target base url could be http://host/rest/proxy/proxyname.
                 */
                this.targetRootUri = null;
                /** The token in question. */
                this.token = null;
                /** The username used to obtain the current token. */
                this.username = null;
            }
            return AuthenticationControlBlock;
        }());
        essentials.AuthenticationControlBlock = AuthenticationControlBlock;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="AuthenticationControlBlock.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents a collection of {@link AuthenticationControlBlock} objects, each of which represents a
         * token login by the user to a specific Essentials {@link Site} endpoint.
        */
        var AuthenticationControlBlockStore = (function () {
            function AuthenticationControlBlockStore() {
                this._authenticationControlBlocks = [];
            }
            /**
             * Adds a control block to the collection.
             * @param controlBlock The {@link AuthenticationControlBlock} control block to be added.
             */
            AuthenticationControlBlockStore.prototype.add = function (controlBlock) {
                if (this.find(controlBlock.tokenRootUri) === null) {
                    this._authenticationControlBlocks.push(controlBlock);
                }
            };
            /**
             * Removes a control block by reference.
             * @param controlBlock The {@link geocortex.essentials.AuthenticationControlBlock} to be removed.
             * @return whether a control block was removed
             */
            AuthenticationControlBlockStore.prototype.remove = function (controlBlock) {
                for (var i = 0; i < this._authenticationControlBlocks.length; i++) {
                    if (this._authenticationControlBlocks[i] === controlBlock) {
                        this._authenticationControlBlocks.splice(i, 1);
                        return true;
                    }
                }
                return false;
            };
            /**
             * Finds a token associated with the given url. A match is found if the
             * base url of the token (or the target root url) is a prefix of url.
             * @param {String} url The url to look for.
             * @return {{@link geocortex.essentials.AuthenticationControlBlock}}
             */
            AuthenticationControlBlockStore.prototype.find = function (url) {
                for (var i = 0; i < this._authenticationControlBlocks.length; i++) {
                    var controlBlock = this._authenticationControlBlocks[i];
                    var tokenRoot = controlBlock.tokenRootUri;
                    var targetRoot = controlBlock.targetRootUri;
                    if (url.toLowerCase().indexOf(tokenRoot.toLowerCase()) === 0 || url.toLowerCase().indexOf(targetRoot.toLowerCase()) === 0) {
                        return controlBlock;
                    }
                }
                return null;
            };
            /**
             * Removes an authentication control block.
             * @param {Number} Index of the controlblock to remove.
             */
            AuthenticationControlBlockStore.prototype.removeAt = function (index) {
                this._authenticationControlBlocks.splice(index, 1);
            };
            return AuthenticationControlBlockStore;
        }());
        essentials.AuthenticationControlBlockStore = AuthenticationControlBlockStore;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../essentials.ts" />
/// <reference path="../../../../_Definitions/arcgis-js-api.d.ts" />
/// <reference path="AuthenticationControlBlockStore.ts" />
/// <reference path="TokenResult.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Provides a means of wrapping any request that is made to an external URL, for the purposes of
         * handling automatic token retrieval when an endpoint is secured.
         */
        var RestHelperHTTPService = (function () {
            /**
             * Initializes a new instance of the {@link geocortex.essentials.RestHelperHTTPService} class.
             * @param request An optional request object to associate with this helper.
             */
            function RestHelperHTTPService(request, options) {
                /** The request object to be supplied to the esri request function. */
                this.requestObject = null;
                /** The options object to be supplied to the esri request function. */
                this.optionsObject = null;
                /** The handle delegate passed along with the original request object. */
                this._handle = null;
                /** The error delegate passed along with the original request object. */
                this._error = null;
                /**
                 * The deferred object which will be invoked when the request has been processed
                 * successfully, or when it fails. If authentication is required for the Essentials
                 * site resource being requested, this deferred will wait until the token has been
                 * requested and the resource has been requested again with the token before resolving.
                 * @private
                 */
                this._deferred = new dojo.Deferred();
                if (request !== undefined) {
                    this.requestObject = request;
                    if (dojo.isFunction(this.requestObject.error)) {
                        this._error = this.requestObject.error;
                        this.requestObject.error = null;
                    }
                    if (dojo.isFunction(this.requestObject.handle)) {
                        this._handle = this.requestObject.handle;
                    }
                    this.requestObject.handle = dojo.hitch(this, this._handleProxy);
                }
                if (options !== undefined) {
                    this.optionsObject = options;
                }
            }
            /**
             * Returns the token for a scope URI.
             * @param uri The URI to return the token for.
             */
            RestHelperHTTPService.getTokenForScope = function (uri) {
                // Initialize our lazies.
                var anchor = this._anchorScratch || (this._anchorScratch = document.createElement("a"));
                var cleaner = this._pathCleaner || (this._pathCleaner = /\/+/g);
                // Gather the details about the URI.
                anchor.href = uri;
                var uriHost = anchor.hostname.toLowerCase();
                var uriPath = ("/" + anchor.pathname + "/").replace(cleaner, "/").toLowerCase();
                // Iterate over the object until nothing left; ie, the last scope wins out.
                // This is a pure object which is ok for using for-in syntax.
                var result = void 0;
                var tokenScopes = this.tokenScopes;
                for (var scope in tokenScopes) {
                    // Gather the details about the scope so that we can compare.
                    anchor.href = scope;
                    var scopeHost = anchor.hostname.toLowerCase();
                    var scopePath = ("/" + anchor.pathname + "/").replace(cleaner, "/").toLowerCase();
                    // Compare by host and by path prefix.
                    if (uriHost === scopeHost && uriPath.startsWith(scopePath)) {
                        var token = tokenScopes[scope];
                        if (typeof token === "string") {
                            result = token;
                        }
                        else if (token === true) {
                            result = this.token;
                        }
                        else {
                            result = void 0;
                        }
                    }
                }
                return result;
            };
            /**
             * Sets the default Essentials token for all requests satisfying the default scope.
             * @param token The default token to set.
             * @param scope The URI scope for which the token applies.
             */
            RestHelperHTTPService.setDefaultToken = function (token, scope) {
                if (typeof token === "string") {
                    this.token = token;
                    this.tokenScopes[scope] = true;
                }
            };
            /**
             * Returns the {@link AuthenticationControlBlockStore} that contains pending {@link AuthenticationControlBlock} objects. */
            RestHelperHTTPService.getAuthenticationControlBlockStore = function () {
                return RestHelperHTTPService._controlBlocks;
            };
            /**
             * The delegate that will be attached to the request object before being
             * passed off to the esri.request method.  Using a proxy handler will allow
             * us to catch and deal with any 401 unauthorized requests, giving us a
             * chance to automatically collect a token and re-issue the request.
             * The reason we need to proxy the handle delegate is:
             * The handle delegate gets called automatically by dojo in success and in
             * failure conditions.  Success conditions are fine, since we want to invoke
             * the original handle delegate anyhow.  In error conditions, we do not want
             * to invoke the original handle delegate because the error may be due to a
             * 401 unauthorized response from the Essentials site - something this class
             * is meant to deal with.  In that case, telling the caller that an error occurred
             * by invoking the error handler is incorrect - we must wait until the token is
             * retrieved and the request is made again.
             * The reason we cannot simply invoke the handle delegate inside the _requestErrback
             * method (like is done for the error delegate) is due to the ioargs that must
             * be passed to the handle delegate.  The deferred error delegate does not get
             * passed an ioargs parameter - it is something that is only packaged and passed
             * explicitly to a handle delegate.  Thus, we have our own handle proxy that we
             * can call in all cases *except* those where a 401 error occurs.
             * @private
             */
            RestHelperHTTPService.prototype._handleProxy = function (dataOrError, ioargs) {
                if (this._isUnauthorizedResponse(dataOrError) === false) {
                    if (dojo.isFunction(this._handle)) {
                        console.log("Invoking original handle delegate");
                        this._handle(dataOrError, ioargs);
                    }
                }
            };
            /**
             * Handler for the request object sent to the esri.request function.  Upon being called,
             * this method will resolve the deferred object returned from this object's send method.
             * @private
             */
            RestHelperHTTPService.prototype._requestCallback = function (data) {
                this._deferred.resolve(data);
            };
            /**
             * Error handler for the request sent to the esri.request function.  If the error occurred
             * due to a 401 unauthenticated error from an Essentials REST endpoint, a request will be made
             * to get a token and then the request will be made again.  If the error occurred for a
             * different reason, the deferred object will be rejected, and the original error delegate
             * supplied in the request object will be invoked (if it exists).
             * @private
             */
            RestHelperHTTPService.prototype._requestErrback = function (error) {
                if (this._isUnauthorizedResponse(error)) {
                    this._handleUnauthenticated(error);
                }
                else {
                    if (dojo.isFunction(this._error)) {
                        this._error(error);
                    }
                    this._deferred.reject(error);
                }
            };
            /**
             * Will return true if the supplied error object represents a 401 JSON response that
             * indicates that the request was for a secured Essentials endpoint and did not include
             * a valid token for authorization.
             * @private
             */
            RestHelperHTTPService.prototype._isUnauthorizedResponse = function (error) {
                if (error && error.code === 401) {
                    return true;
                }
                return false;
            };
            /**
             * Called to handle the case where a response has been received from an Essentials REST
             * endpoint indicating that the request requires authentication.  This method will kick
             * off a call to the authentication endpoint to retrieve a token based on credentials
             * gathered from the user, and will re-issue the original request but this time will
             * supply the token it recieved from the Site endpoint.
             * @private
             */
            RestHelperHTTPService.prototype._handleUnauthenticated = function (error) {
                console.log("Handling unauthenticated response from server");
                // If we get a 401, part of that response is supposed to be the URL to the token service
                if (error && error.tokenService) {
                    // Verify that a proxy page is configured since the request for a token will
                    // need to be posted, and an obscure error will result if no proxy page is set.
                    if (geocortex.hasProxy() === false) {
                        console.log("Cannot authenticate user - no proxy page configured");
                        var proxyError = new Error("No proxy page is configured - a proxy page is required to access secured Sites");
                        throw proxyError;
                    }
                    var url = this.requestObject.url;
                    var tokenServiceUrl = error.tokenService;
                    var controlBlock = geocortex.essentials.RestHelperHTTPService._controlBlocks.find(this.requestObject.url);
                    if ((controlBlock === null) || ((controlBlock.token !== null) && (controlBlock.token !== ""))) {
                        console.log("New token required for call to secured site");
                        var urlObj = new dojo._Url(url);
                        tokenServiceUrl = urlObj.scheme +
                            "://" +
                            urlObj.host +
                            ((urlObj.port && urlObj.port !== "80") ? ":" + urlObj.port : "") +
                            tokenServiceUrl;
                        // Create a control block - first request to token service
                        if (!controlBlock) {
                            controlBlock = new geocortex.essentials.AuthenticationControlBlock();
                        }
                        // Need to show the 401 message to the user. Usually, it is 
                        // "This service requires authorization" or similar
                        controlBlock.messageFromServer = error.message;
                        // No token, go get one
                        if (controlBlock.token === null) {
                            controlBlock.tokenService = tokenServiceUrl;
                            controlBlock.tokenRootUri = tokenServiceUrl.substring(0, tokenServiceUrl.lastIndexOf(("/")));
                            controlBlock.targetRootUri = url.substring(0, url.lastIndexOf(("/")));
                            controlBlock.pendingCalls.push(this);
                            geocortex.essentials.RestHelperHTTPService._controlBlocks.add(controlBlock);
                            var dfd = this._gatherCredentials();
                            dfd.then(dojo.hitch(this, function (credentials) {
                                controlBlock.username = credentials.username;
                                controlBlock.password = credentials.password;
                                this._requestToken(controlBlock);
                            }));
                        }
                        else {
                            // Token must be expired. Re-get token
                            controlBlock.token = null;
                            controlBlock.pendingCalls = []; // TODO jfletcher: What is the impact of this?  Do we want to keep these pending calls?
                            controlBlock.pendingCalls.push(this);
                            this._requestToken(controlBlock);
                        }
                    }
                    else {
                        // Queue the call if it doesn't already exist
                        var found = false;
                        for (var i = 0; i < controlBlock.pendingCalls.length; i++) {
                            if (controlBlock.pendingCalls[i] === this) {
                                found = true;
                                break;
                            }
                        }
                        if (found === false) {
                            controlBlock.pendingCalls.push(this);
                        }
                    }
                }
                else {
                    // Response was a JSON 401, but no token service was included.  Forward the error, as
                    // it is not something that the API is able to handle.
                    if (dojo.isFunction(this._error)) {
                        this._error(error);
                    }
                    this._deferred.reject(error);
                }
            };
            /**
             * Displays an authentication dialog to the user to gather the credentials which will be used
             * to request a token from the Essentials site's authorization endpoint.
             * The authentication dialog will be constructed from scratch using a dijit.Dialog, which will
             * have the look and feel of the current dojo stylesheet in use.  Note that for best results,
             * the stylesheet "document.css" inside the relevant dojo style directory should be included in
             * the page.
             * If an alternate authentication dialog is required, the ID of the div containing the alternate
             * dialog should be specified in the geocortex.config.authenticationDialogId property.  The dialog
             * must be a dijit.Dialog, it must have a submit button with id of <divId>_ok, it must have a
             * standard button with id of <divId>_cancel, and it must have two text inputs named username and
             * password, respectively.
             * @returns {dojo.Deferred} the deferred promise that will be called back when the user clicks
             * the OK or cancelled buttons
             */
            RestHelperHTTPService.prototype._gatherCredentials = function (forwardedDeferred) {
                var deferred;
                if (forwardedDeferred === undefined) {
                    deferred = new dojo.Deferred();
                }
                else {
                    deferred = forwardedDeferred;
                }
                if (!dijit.Dialog || !dijit.form || !dijit.form.TextBox || !dijit.form.Button) {
                    console.log("Dynamically retrieving authentication dialog requirements");
                    dojo["require"]("dijit.Dialog");
                    dojo["require"]("dijit.form.TextBox");
                    dojo["require"]("dijit.form.Button");
                    dojo.addOnLoad(dojo.hitch(this, function () {
                        console.log("Retrieved authentication dialog requirements, now re-invoking _gatherCredentials");
                        this._gatherCredentials(deferred);
                    }));
                }
                else {
                    var controlBlock = geocortex.essentials.RestHelperHTTPService._controlBlocks.find(this.requestObject.url);
                    var dlgId = geocortex.config.authenticationDialogId;
                    var authDialog;
                    if (dlgId) {
                        console.log("Retrieving existing authentication dialog by id '" + dlgId + "'");
                        authDialog = dijit.byId(dlgId);
                    }
                    else {
                        dlgId = geocortex.config.authenticationDialogId = "geocortex_authenticationDialog_default";
                    }
                    if (!authDialog || !(authDialog instanceof dijit.Dialog)) {
                        authDialog = new dijit.Dialog({
                            title: "Authentication Required",
                            id: dlgId,
                            content: this._createAuthDialogContent()
                        });
                    }
                    $(dojo.byId(dlgId + "_message")).text(controlBlock.messageFromServer || "");
                    var okButton = dijit.byId(dlgId + "_ok");
                    var cancelButton = dijit.byId(dlgId + "_cancel");
                    var handleOkClick, handleCancelClick, handleCancelDialog;
                    handleOkClick = dojo.connect(okButton, "onClick", function () {
                        dojo.forEach([handleOkClick, handleCancelClick, handleCancelDialog], dojo.disconnect);
                        var data = authDialog.attr("value");
                        deferred.resolve({ username: data.username, password: data.password });
                    });
                    handleCancelClick = dojo.connect(cancelButton, "onClick", function () {
                        dojo.forEach([handleOkClick, handleCancelClick, handleCancelDialog], dojo.disconnect);
                        authDialog.hide();
                        deferred.cancel();
                    });
                    handleCancelDialog = dojo.connect(authDialog, "onCancel", function () {
                        dojo.forEach([handleOkClick, handleCancelClick, handleCancelDialog], dojo.disconnect);
                        deferred.cancel();
                    });
                    authDialog.show();
                }
                return deferred;
            };
            /**
             * Constructs a dialog used to gather the username and password from the user.
             * @returns {Object} div DOM object representing the dijit.Dialog.
             * @private
             */
            RestHelperHTTPService.prototype._createAuthDialogContent = function () {
                var dlgId = geocortex.config.authenticationDialogId;
                var userInput = new dijit.form.TextBox({ name: "username", id: "gcx_auth_username" });
                var passwordInput = new dijit.form.TextBox({ type: "password", name: "password", id: "gcx_auth_password" });
                var okButton = new dijit.form.Button({
                    label: "OK",
                    type: "submit",
                    id: dlgId + "_ok"
                });
                var cancelButton = new dijit.form.Button({
                    label: "Cancel",
                    type: "button",
                    id: dlgId + "_cancel"
                });
                var authContainer = dojo.create("div");
                dojo.create("div", { id: dlgId + "_message" }, authContainer);
                var authTable = dojo.create("table", null, authContainer);
                var userInputRow = dojo.create("tr", null, authTable);
                var passInputRow = dojo.create("tr", null, authTable);
                var actionButtonRow = dojo.create("tr", null, authTable);
                dojo.place("<td><label for='gcx_auth_username'>Username: </label></td>", userInputRow);
                dojo.place("<td><label for='gcx_auth_password'>Password: </label></td>", passInputRow);
                var userInputCell = dojo.create("td", null, userInputRow);
                var passInputCell = dojo.create("td", null, passInputRow);
                var actionButtonCell = dojo.create("td", { colspan: "2", align: "center" }, actionButtonRow);
                var actionButtonDiv = dojo.create("div", { id: dlgId + "_actionbuttoncontainer" }, actionButtonCell);
                userInput.placeAt(userInputCell);
                passwordInput.placeAt(passInputCell);
                okButton.placeAt(actionButtonDiv);
                cancelButton.placeAt(actionButtonDiv);
                return authContainer;
            };
            /**
             * Requests an authentication token from the Essentials site endpoint, using the username
             * and password supplied in the controlBlock.
             * @private
             */
            RestHelperHTTPService.prototype._requestToken = function (controlBlock) {
                console.log("Requesting token for site access");
                var def = esri.request({
                    "url": controlBlock.tokenService,
                    "content": {
                        "username": controlBlock.username,
                        "password": controlBlock.password,
                        "lifespan": "20",
                        "f": "json"
                    },
                    "timeout": geocortex.config.io.timeout,
                    "handleAs": "json"
                }, {
                    "usePost": true,
                    "disableIdentityLookup": true
                });
                def.then(dojo.hitch(this, this._onTokenRequestCompleted), dojo.hitch(this, this._onTokenRequestFault));
            };
            /**
             * Handler invoked when there was an error retrieving the credentials from the Essentials site REST
             * endpoint.  The error can either be another 401, indicating invalid credentials supplied, or it
             * could be a separate transport or server error (among others).  Another 401 is handled by just gathering
             * the credentials again from the user.
             * @private
             */
            RestHelperHTTPService.prototype._onTokenRequestFault = function (e) {
                console.log("Token request fault");
                if (this._isUnauthorizedResponse(e)) {
                    console.log("Unauthorized response - will gather credentials again");
                    // Username and password are likely incorrect, display authentication dialog again
                    // with an updated message from the server.
                    var controlBlock = geocortex.essentials.RestHelperHTTPService._controlBlocks.find(this.requestObject.url);
                    controlBlock.messageFromServer = e.message;
                    this._gatherCredentials().then(dojo.hitch(this, function (credentials) {
                        console.log("Invoked delegate for gathering credentials");
                        controlBlock.username = credentials.username;
                        controlBlock.password = credentials.password;
                        this._requestToken(controlBlock);
                    }));
                }
                else {
                    // The token request failed likely due to a server error.
                    if (dojo.isFunction(this._error)) {
                        this._error(e);
                    }
                    this._deferred.errback(e);
                }
            };
            /**
             * Handler invoked when a token request is successfully responded to by the Essentials site REST
             * endpoint.  When this occurs, any calls that have been waiting pending authentication are
             * sent.
             * @private
             */
            RestHelperHTTPService.prototype._onTokenRequestCompleted = function (data) {
                console.log("Token request completed");
                var controlBlock = geocortex.essentials.RestHelperHTTPService._controlBlocks.find(this.requestObject.url);
                if (data && (data.token)) {
                    controlBlock.token = data.token;
                    console.log("Received token '" + data.token + "' for user '" + controlBlock.username + "'");
                    console.log("Publishing dojo event 'geocortex_authenticationSucceeded'");
                    dojo.publish("geocortex_authenticationSucceeded", [{ username: controlBlock.username, token: controlBlock.token }]);
                    for (var i = controlBlock.pendingCalls.length - 1; i >= 0; i--) {
                        var pendingCall = controlBlock.pendingCalls[i];
                        controlBlock.pendingCalls.pop();
                        console.log("Re-issuing pending call with new token to url '" + pendingCall.requestObject.url + "'");
                        pendingCall.send();
                    }
                }
                else {
                    geocortex.essentials.RestHelperHTTPService._controlBlocks.remove(controlBlock);
                }
            };
            /**
             * Override send so that we can append tokens as needed.
             * @private
             */
            RestHelperHTTPService.prototype.send = function () {
                // <jscharf> This looks totally broken...
                if (this.requestObject !== null) {
                    // Find the control block associated with this url
                    var controlBlock = geocortex.essentials.RestHelperHTTPService._controlBlocks.find(this.requestObject.url);
                    if ((controlBlock !== null) && (controlBlock.token !== null)) {
                        if (!this.requestObject.content) {
                            this.requestObject.content = {};
                        }
                        // Essentials won't read tokens from POST bodies so we need to ensure that the token is always in the query string.
                        if (this.requestObject.url.indexOf("token=") === -1) {
                            this.requestObject.url = this._appendParameter(this.requestObject.url, "token", controlBlock.token);
                        }
                    }
                }
                else {
                    // If we have no block or no token, make sure there is no outdated "token" parameter in the query string.
                    if (this.requestObject.url.indexOf("token=") !== -1) {
                        this.requestObject.url = this.requestObject.url.replace("token=", "oldtkn=");
                    }
                }
                // Append ArcGIS Portal token
                if (RestHelperHTTPService.arcGisPortalToken) {
                    this.requestObject.content["arcGisPortalToken"] = RestHelperHTTPService.arcGisPortalToken.token;
                }
                // Ge the token, it is always a string or undefined.
                var authToken = RestHelperHTTPService.getTokenForScope(this.requestObject.url);
                if (authToken !== void 0) {
                    this.requestObject.content["token"] = authToken;
                }
                esri.request(this.requestObject, this.optionsObject).then(dojo.hitch(this, this._requestCallback), dojo.hitch(this, this._requestErrback));
                return this._deferred.promise;
            };
            RestHelperHTTPService.prototype._appendParameter = function (url, paramName, paramValue) {
                var result = url;
                if (url.indexOf("?") > 0) {
                    result += "&";
                }
                else {
                    result += "?";
                }
                result += encodeURIComponent(paramName) + "=" + encodeURIComponent(paramValue);
                return result;
            };
            RestHelperHTTPService._controlBlocks = new geocortex.essentials.AuthenticationControlBlockStore();
            /**
             * Custom token scopes to apply.
             */
            RestHelperHTTPService.tokenScopes = {};
            return RestHelperHTTPService;
        }());
        essentials.RestHelperHTTPService = RestHelperHTTPService;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/arcgis-js-api.d.ts" />
/**
 * Utility methods for working with geometries.
 */
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var GeometryUtilities;
        (function (GeometryUtilities) {
            /**
             * Compares two spatial references for equality.
             * @param ref1 The first SpatialReference.
             * @param ref2 The second SpatialReference.
             * @param ignoreNulls Whether or not a null spatial reference passed in should equate to equal to the other.
             */
            function spatialRefsAreEqual(ref1, ref2, ignoreNulls) {
                if (ref1 == null || ref2 == null) {
                    return ignoreNulls;
                }
                // Web Mercator has a bunch of different WKIDs.
                if (ref1.isWebMercator && ref2.isWebMercator) {
                    if (ref1.isWebMercator() && ref2.isWebMercator()) {
                        return true;
                    }
                }
                // NOTE: Doesn't take into account two equivalent spatial references, one defined by WKID and the other by equivalent WKT.
                if (ref1.wkid !== ref2.wkid) {
                    return false;
                }
                if (ref1.wkid > 0) {
                    return true;
                }
                else {
                    // Compare WKT with a simple string comparison.
                    return (ref1.wkt.toLowerCase() == ref2.wkt.toLowerCase());
                }
            }
            GeometryUtilities.spatialRefsAreEqual = spatialRefsAreEqual;
            /**
             * Compares two envelopes for spatial equality.
             * @param env1 Envelope A.
             * @param env2 Envelope B.
             */
            function envelopesAreEqual(envelope1, envelope2) {
                if (envelope1 == null || envelope2 == null) {
                    return (envelope1 == null && envelope2 == null);
                }
                return spatialRefsAreEqual(envelope1.spatialReference, envelope2.spatialReference) &&
                    envelope1.xmin == envelope2.xmin &&
                    envelope1.ymin == envelope2.ymin &&
                    envelope1.xmax == envelope2.xmax &&
                    envelope1.ymax == envelope2.ymax;
            }
            GeometryUtilities.envelopesAreEqual = envelopesAreEqual;
            /**
             * Builds a bounding extent, given an array of geometries.
             * @param geometries The collection of geometries for which to build the bounding extent.
             */
            function getExtent(geometries) {
                if (geometries.length) {
                    var extent = new esri.geometry.Extent(Number.MAX_VALUE, Number.MAX_VALUE, Number.MIN_VALUE, Number.MIN_VALUE, geometries[0].spatialReference);
                }
                for (var geometryIndex = 0; geometryIndex < geometries.length; ++geometryIndex) {
                    var envelope = geometries[geometryIndex].getExtent();
                    extent.xmin = Math.min(envelope.xmin, extent.xmin);
                    extent.ymin = Math.min(envelope.ymin, extent.ymin);
                    extent.xmax = Math.min(envelope.xmax, extent.xmax);
                    extent.xmax = Math.min(envelope.ymax, extent.ymax);
                }
                return extent;
            }
            GeometryUtilities.getExtent = getExtent;
            /**
             * Creates a polygon representing the given extent.
             * @param envelope The envelope to turn into a polygon.
             */
            function envelopeToPolygon(envelope) {
                var poly = new esri.geometry.Polygon(envelope.spatialReference);
                poly.addRing([[envelope.xmin, envelope.ymin],
                    [envelope.xmin, envelope.ymax],
                    [envelope.xmax, envelope.ymax],
                    [envelope.xmax, envelope.ymin],
                    [envelope.xmin, envelope.ymin]]);
                return poly;
            }
            GeometryUtilities.envelopeToPolygon = envelopeToPolygon;
            /**
             * Checks a given geometry for validity.
             * @param geometry The geometry to check.
             */
            function isValidGeometry(geometry) {
                // Not a polygon? return true.
                if (geometry.type != "polygon") {
                    return true;
                }
                var poly = geometry;
                // Clockwise by default.
                if (poly.rings.length == 0 || poly.rings.length < 3) {
                    return true;
                }
                if (isConvex(poly)) {
                    var a = poly.rings[0][0];
                    var b = poly.rings[0][1];
                    // Wrap around the poly.
                    var points = poly.rings[0].slice(2, poly.rings[0].length);
                    points.push(a);
                    for (var pointIndex = 0; pointIndex < points.length; ++pointIndex) {
                        var point = points[pointIndex];
                        if (crossProductArray(a, point, b) > 0) {
                            return true;
                        }
                        a = b;
                        b = point;
                    }
                    return false;
                }
                else {
                    // If the polygon is concave, we can just check the sign of the area to determine winding order.
                    var area = 0;
                    for (var ringIndex = 0; ringIndex < poly.rings.length; ++ringIndex) {
                        var ring = poly.rings[ringIndex];
                        var j = 0;
                        for (var pointIndex = 0; pointIndex < ring.length; ++pointIndex) {
                            j = (pointIndex + 1) % ring.length;
                            area += ring[pointIndex][0] * -ring[j][1];
                            area -= -ring[pointIndex][1] * ring[j][0];
                        }
                    }
                    return (area > 0);
                }
            }
            GeometryUtilities.isValidGeometry = isValidGeometry;
            /**
             * Checks if a polygon is self intersecting
             * @param esri.geometry.Polygon
             */
            function isSelfIntersectingPolygon(poly) {
                if (esri.geometry.polygonSelfIntersecting) {
                    return esri.geometry.polygonSelfIntersecting(poly); // 3.7
                }
                else if (poly.isSelfIntersecting) {
                    return poly.isSelfIntersecting(poly); // 3.8
                }
                throw new Error("No self intersection method found");
            }
            GeometryUtilities.isSelfIntersectingPolygon = isSelfIntersectingPolygon;
            /**
             * Checks whether or not a polygon is convex.
             * @param geometry The geometry to check.
             */
            function isConvex(poly) {
                var a = poly.rings[0][0];
                var b = poly.rings[0][1];
                var positive = null;
                var isConvex = true;
                // Wrap around the poly.
                var points = poly.rings[0].slice(2, poly.rings[0].length);
                points.push(a);
                for (var pointIndex = 0; pointIndex < points.length; ++pointIndex) {
                    var point = points[pointIndex];
                    var crossProd = this.crossProduct(point, a, b);
                    // Note that neither condition is met when positive === null.
                    if ((crossProd > 0 && positive === true) || (crossProd < 0 && positive === false)) {
                        return false;
                    }
                    positive = crossProd > 0;
                    a = b;
                    b = point;
                }
                return isConvex;
            }
            GeometryUtilities.isConvex = isConvex;
            /**
             * Checks whether or not a point lies in an Envelope.
             * @param point The point to check.
             * @param envelope The envelope to check.
             */
            function pointInEnvelope(point, envelope) {
                if (!this.spatialRefsAreEqual(point.spatialReference, envelope.spatialReference, true)) {
                    throw new Error("Mismatched spatial references.");
                }
                if (point.x < envelope.xmin || point.x > envelope.xmax) {
                    return false;
                }
                if (point.y < envelope.ymin || point.y > envelope.ymax) {
                    return false;
                }
                return true;
            }
            GeometryUtilities.pointInEnvelope = pointInEnvelope;
            /**
             * Returns an envelope representing the result of clipping a given envelope against another given envelope.
             * @param envelopeToClip The envelope to clip.
             * @param clipAgainst The envelope to clip against.
             */
            function clipEnvelope(envelopeToClip, clipAgainst) {
                if (!this.spatialRefsAreEqual(envelopeToClip.spatialReference, clipAgainst.spatialReference, true)) {
                    throw new Error("Mismatched spatial references.");
                }
                var envelope = new esri.geometry.Extent(envelopeToClip.xmin, envelopeToClip.ymin, envelopeToClip.xmax, envelopeToClip.ymax, envelopeToClip.spatialReference);
                var clamp = function (val, min, max) {
                    return (val < min) ? min :
                        (val > max) ? max : val;
                };
                envelope.xmin = clamp(envelopeToClip.xmin, clipAgainst.xmin, clipAgainst.xmax);
                envelope.xmin = clamp(envelopeToClip.ymin, clipAgainst.ymin, clipAgainst.ymax);
                envelope.xmin = clamp(envelopeToClip.xmax, clipAgainst.xmin, clipAgainst.xmax);
                envelope.xmin = clamp(envelopeToClip.ymax, clipAgainst.ymin, clipAgainst.ymax);
                return envelope;
            }
            GeometryUtilities.clipEnvelope = clipEnvelope;
            /**
             * Returns an extent that represents the provided envelope scaled by the given amounts on each axis.
             * @param envelope The envelope to scale.
             * @param scaleX The amount to scale on the X axis.
             * @param scaleY The amount to scale on the Y axis.
             */
            function scaleEnvelope(envelope, scaleX, scaleY) {
                return new esri.geometry.Extent(envelope.xmin * scaleX, envelope.ymin * scaleY, envelope.xmax * scaleX, envelope.ymax * scaleY, envelope.spatialReference);
            }
            GeometryUtilities.scaleEnvelope = scaleEnvelope;
            /**
             * Returns an extent that represents the provided envelope, whose width and height have
             * been scaled by the given amount, and whose center has position is unchanged.
             * @param envelope The envelope to scale.
             * @param scaleFactor The amount to scale by.
             */
            function scaleEnvelopeWithoutTranslation(envelope, scaleFactor) {
                if (envelope == null) {
                    return null;
                }
                var center = envelope.getCenter();
                return new esri.geometry.Extent(center.x - (envelope.getWidth() * (scaleFactor / 2.0)), center.y - (envelope.getHeight() * (scaleFactor / 2.0)), center.x + (envelope.getWidth() * (scaleFactor / 2.0)), center.y + (envelope.getHeight() * (scaleFactor / 2.0)), envelope.spatialReference);
            }
            GeometryUtilities.scaleEnvelopeWithoutTranslation = scaleEnvelopeWithoutTranslation;
            /**
             * Computes the Cartesian distance between two points.
             * @param point1 The first point.
             * @param point2 The second point.
             */
            function computeDistance(point1, point2) {
                var a = (point2.x - point1.x);
                var b = (point2.y - point1.y);
                return Math.sqrt((a * a) + (b * b));
            }
            GeometryUtilities.computeDistance = computeDistance;
            /**
             * Returns an extent that represents the provided envelope scaled by the given amounts on each axis.
             * @param envelope The envelope to translate.
             * @param translateX The amount to translate on the X axis.
             * @param translateY The amount to translate on the Y axis.
             */
            function translateEnvelope(envelope, translateX, translateY) {
                return new esri.geometry.Extent(envelope.xmin + translateX, envelope.ymin + translateY, envelope.xmax + translateX, envelope.ymax + translateY, envelope.spatialReference);
            }
            GeometryUtilities.translateEnvelope = translateEnvelope;
            /**
             * Calculates the length of a vector.
             * @param vector The vector to calculate length for.
             */
            function length(vector) {
                return Math.sqrt((vector.x * vector.x) + (vector.y * vector.y));
            }
            GeometryUtilities.length = length;
            /**
             * Returns a normalized vector.
             * @param vector The vector to normalize.
             */
            function normalize(vector) {
                var length = this.length(vector);
                return new esri.geometry.Point(vector.x / length, vector.y / length);
            }
            GeometryUtilities.normalize = normalize;
            /**
             * Calculates the angle (in Radians) between two vectors.
             * @param a The first vector.
             * @param b The second vector.
             */
            function angle(a, b) {
                if (!this.spatialRefsAreEqual(a.spatialReference, b.spatialReference, true)) {
                    throw new Error("Mismatched spatial references");
                }
                return Math.acos(this.dotProduct(a, b) / Math.sqrt(this.dotProduct(a, a) * this.dotProduct(b, b)));
            }
            GeometryUtilities.angle = angle;
            /**
             * Calculates the 2D cross product of two vectors.
             * @param a The first vector.
             * @param b The second vector.
             * @param origin The origin by which these vectors relate.
             */
            function crossProduct(a, b, origin) {
                if (!this.spatialRefsAreEqual(a.spatialReference, b.spatialReference, true)) {
                    throw new Error("Mismatched spatial references");
                }
                if (!origin) {
                    origin = new esri.geometry.Point(0, 0);
                }
                return ((a.x - origin.x) * (b.y - origin.y)) - ((a.y - origin.y) * (b.x - origin.x));
            }
            GeometryUtilities.crossProduct = crossProduct;
            /**
             * Calculates the 2D cross product of two vectors.
             * @param a The first vector.
             * @param b The second vector.
             * @param origin The origin by which these vectors relate.
             */
            function crossProductArray(a, b, origin) {
                if (!origin) {
                    origin = [0, 0];
                }
                return ((a[0] - origin[0]) * (b[1] - origin[1])) - ((a[1] - origin[1]) * (b[0] - origin[0]));
            }
            GeometryUtilities.crossProductArray = crossProductArray;
            /**
             * Calculates the dot product of two vectors.
             * @param a The first vector.
             * @param b The second vector.
             */
            function dotProduct(a, b) {
                if (!this.spatialRefsAreEqual(a.spatialReference, b.spatialReference, true)) {
                    throw new Error("Mismatched spatial references");
                }
                return (a.x * b.x) + (a.y * b.y);
            }
            GeometryUtilities.dotProduct = dotProduct;
            /**
             * Calculates the approximate midpoint of a collection of points.
             * @param points The array of points.
             */
            function polygonMidpoint(points) {
                if (points.length == 0) {
                    throw new Error("Expected at least one point in polygonMidPoint.");
                }
                var xAverage = 0;
                var yAverage = 0;
                for (var pointIndex = 0; pointIndex < points.length; ++pointIndex) {
                    var point = points[pointIndex];
                    xAverage += point.x;
                    yAverage += point.y;
                }
                xAverage /= points.length;
                yAverage /= points.length;
                return new esri.geometry.Point(xAverage, yAverage, points[0].spatialReference);
            }
            GeometryUtilities.polygonMidpoint = polygonMidpoint;
        })(GeometryUtilities = essentials.GeometryUtilities || (essentials.GeometryUtilities = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/arcgis-js-api.d.ts" />
/// <reference path="GeometryUtilities.ts" />
/// <reference path="Layer.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents a map service defined in a {@link Map}.
         * A {@link MapService} is related to an Esri map service layer. It contains a reference to that Esri service in the {@link serviceLayer} property.
         */
        var MapService = (function (_super) {
            __extends(MapService, _super);
            /**
             * Initializes a new instance of the {@link MapService} class.
             * @param url The URL to the REST endpoint of the {@link MapService}.
             */
            function MapService(url) {
                _super.call(this, url);
                /**
                 * The parameters supplied for creation of a Bing map through the connection string
                 * This object will be null for any {@link MapService} which is not a Bing map.
                 */
                this.bingProperties = null;
                /** The base map group that this service belongs to, if applicable. */
                this.baseMapGroup = null;
                /** The initial opacity defined in the {@link Site}. */
                this.configuredOpacity = 1;
                /**
                 * The initial visibility defined in the {@link Site}. This will be
                 * True if the default is to have the map service visible, false otherwise. */
                this.configuredVisible = false;
                /** The attribution information for the layer. */
                this.copyright = null;
                /** The URL, when available, where the layer's attribution data is stored. */
                this.attributionDataUrl = null;
                /** If the current map service has attribution data or not */
                this.hasAttributionData = false;
                /** The default data provider (e.g. "Oracle", "SqlServer") for all layers in this map service. */
                this.dataProvider = null;
                /** Description of the map service.  */
                this.description = null;
                /** The default format string used for formatting date values originating from this map service. */
                this.defaultDateFormat = null;
                /** The default format string used for formatting numeric values originating from this map service. */
                this.defaultNumberFormat = null;
                /** Whether or not to disable caching of the MapService on the client. */
                this.disableClientCaching = false;
                /** The display name of the {@link MapService}. */
                this.displayName = null;
                /**
                 * The drawing behavior of this map service. One of:
                 *  - MapService - the map service is rendered on the server
                 *  - FeatureLayer - the map service is rendered on the client
                 */
                this.drawingBehavior = null;
                /** The {@link Map} that the {@link MapService} belongs to. */
                this.essentialsMap = null;
                /** Any extensions of the {@link MapService}, as defined by the administrator on the server. */
                this.extensions = [];
                /** The failure action, which describes how the end user application should deal with a failed service. */
                this.failureAction = geocortex.essentials.FailureAction.WARN;
                /** The timeout (in seconds) before this mapService will be deemed to have failed */
                this.failureTimeout = null;
                /** Boolean indicating whether the map service has timed out yet. This does not, in itself indicate an error. Subsequent resolution is possible. */
                this.failureTimeoutThresholdExceeded = false;
                /** function invoked when the failure timeout threshold is exceeded */
                this.onFailureTimeoutThresholdExceeded = function () { };
                /** Used to indicate what the MapService is capable of and is currently doing regarding clustering */
                this.featureClustering = null;
                /** The URL of the geometry service.*/
                this.geometryServiceUrl = null;
                /** Indicates whether this instance has layer catalog. */
                this.hasLayerCatalog = false;
                /** URI to an icon representation of this map service, for display in client applications. */
                this.iconUri = null;
                /** The ID of the {@link MapService}. */
                this.id = null;
                /** The catalog id */
                this.catalogId = null;
                /** The original URL of the Essentials map service REST endpoint. */
                this.originalUrl = null;
                /** Format in which images will be drawn. */
                this.imageFormat = null;
                /**
                 * Gets the error that occurred during initialization of the service layer, or null if there were no errors during initialization. */
                this.initializationFailure = null;
                /** Whether or not to include this map service in the layer lists of client applications. */
                this.includeInLayerList = true;
                /** Whether or not the map service will be expanded by default when shown in a layer list. */
                this.isExpanded = true;
                /** Indicates whether or not the service layer (Esri's native layer) has been loaded. */
                this.isServiceLayerLoaded = false;
                /** Indicates whether or not a mapService was created by a user at runtime **/
                this.isUserCreated = false;
                /** The collection of {@link Layer} objects. */
                this.layers = [];
                /** The collection of table objects. */
                this.tables = [];
                /**
                 * A view of the layers which is filtered to only include the active layers in the application. This will change,
                 * when, for example, a layer theme is applied. If no filter (layer theme) has been applied, then this collection
                 * will be the same as the 'layers' collection
                 */
                this.layersFilteredView = [];
                /** The logical function of the {@link MapService}, either Base or Operational. */
                this.mapServiceFunction = null;
                /**  The type of {@link MapService}. */
                this.mapServiceType = null;
                /**
                 * The URL used to retrieve a map image.  Maybe a templated URL, as in the case of WMTS using RESTful encoding.
                 * May also be used to define the url that should used for WMS GetMap requests.*/
                this.mapUrl = null;
                /**
                 * A maximum scale value that overrides the map service's defined maximum scale.
                 */
                this.maxScale = null;
                /**
                 * A minimum scale value that overrides the map service's defined minimum scale.
                 */
                this.minScale = null;
                /** The opacity of the map service. */
                this.opacity = 1.0;
                /**
                 * A value between 0 and 1 inclusive that is used to filter the opacity of the map service.
                 * The map service's opacity will be combined with the filter to produce the final opacity
                 * seen by the end user.
                 */
                this.opacityFilter = 1.0;
                /**
                 * The runtime spatial reference to use that is compatible with the map's spatial reference.
                 * For now this is just used for WMS. */
                this.operationalSpatialReference = null;
                /**
                 * Observable indicating whether this map service is in the active theme or not.
                 */
                this.inActiveTheme = true;
                /**
                 * A collection containing the layer theme settings for this map service.
                 */
                this.layerThemeSettings = [];
                /** A collection of LayerHyperlinks associated with this map service. */
                this.layerHyperlinks = [];
                /**  The properties of the {@link MapService}, as defined by the administrator on the server. */
                this.properties = {};
                /** The proxy URL for this service. */
                this.proxyUrl = null;
                /** The request encoding for a WMTS service. Can be KVP or RESTful. */
                this.requestEncoding = null;
                /** Indicates whether the map service is searchable through *Instant Search*. */
                this.instantSearch = false;
                /** The map server version for the service host. */
                this.serverVersion = null;
                /** The Esri map service Layer object. */
                this.serviceLayer = null;
                /** The security token that must be provided when requesting the service from ArcGIS Server. */
                this.serviceToken = null;
                /** The URL of the map service published by ArcGIS Server. */
                this.serviceUrl = null;
                /** The short display name for the map service. */
                this.shortDisplayName = null;
                /** The set of subdomains to use in a WebTiledLayer tile request. */
                this.subDomains = [];
                /** Whether or not the map service supports dynamic layers. */
                this.supportsDynamicLayers = false;
                /**
                 * The name of the tile matrix set to use for the WMTS layer, if this map service represents a WMTS service.
                 * If this service does not represent a WMTS service, this property should be null. */
                this.tileMatrixSet = null;
                /**
                 * An object in the same form as provided by Esri's REST API, and that is used  as a property for certain classes such as
                 * {@link esri.layers.WMTSLayer.tileInfo}. */
                this.tileInfo = null;
                /** The URL used to retrieve tile images in the case of a RESTful WMTS service, which may be a URL template. */
                this.tileRestUrl = null;
                /** Boolean indicating whether this map service is time aware or not */
                this.isTimeAware = false;
                /** The time information for this map service - if it is time aware. */
                this.timeInfo = null;
                /** The IANA ID of the time zone in which the data in this layer's fields are current. */
                this.timeZoneId = null;
                /**
                 * Gets or sets the interval period (in seconds) for updating the specified map service.
                 * It must be set to null, 0 or a value > 10 seconds. */
                this.updateInterval = null;
                /** The heap map settings for this map service. */
                this.heatMap = null;
                /** Whether or not this mapService can be identified in the client application. */
                this.identifiable = false;
                /** Whether or not the mosaic dataset values for this mapService should be included in idenitfy results or not. */
                this.includeMosaicDatasetValues = false;
                /** Whether or not the catalog items for this mapService should be included in idenitfy results or not. */
                this.includeCatalogItems = false;
                /** In certain cases, we need to route all requests through a primary proxy. This flag indicates that this layer requires that behaviour. */
                this._needsProxy = false;
                /** The LayerVisibilityChange event manager. */
                this.layerVisibilityEventManager = null;
                this._updateIntervalId = null;
                this._delayedRefreshToken = null;
                this._layersInfoPromise = null;
                this._styleUrl = null;
                this._restStartTimeOverrideString = null;
                this._restEndTimeOverrideString = null;
                /**
                 * Caches the value for getFeatureLayer().
                 */
                this._featureLayerPromise = null;
                /** Whether or not the map service is initially visible. */
                this._initiallyVisible = false;
                this.originalUrl = url;
                if (this.url) {
                    this.url = essentials.utilities.UrlUtilities.simplify(url);
                }
                this.setInActiveTheme(true); // All map services are in the default active theme (i.e. where all layers are available)
            }
            /**
             * @private
             * Gets metadata about all layers and tables from the map server's REST endpoint. This is an internal function used
             * by Layer.getFeatureLayer().
             */
            MapService.prototype._getLayersInfo = function () {
                var _this = this;
                if (!this._layersInfoPromise) {
                    this._layersInfoPromise = new Promise(function (resolve, reject) {
                        _this.doWhenInitialized(function (ms) {
                            if (_this.serviceUrl.endsWith("/MapServer")) {
                                // Fetch information about all layers and tables from the service's endpoint.
                                var url = _this.serviceUrl + "/Layers";
                                var request = {
                                    url: url,
                                    content: {
                                        f: "json"
                                    },
                                    load: function (results) { resolve(results); },
                                    error: function (e) { reject(e); },
                                    callbackParamName: "CallBack",
                                    preventCache: false
                                };
                                var options = {
                                    gcx: {
                                        preventCache: false
                                    }
                                };
                                // Check if a secure token needs to be added to the url
                                // No need to call encodeURIComponent; it is done for us in dojo.xhr which is what Esri uses for AJAX calls
                                if (_this.serviceToken !== null) {
                                    //url = url + ((url.indexOf("?") > -1) ? "&token=" : "?token=") + encodeURIComponent(this.serviceToken);
                                    request.content.token = _this.serviceToken;
                                }
                                esri.request(request, options);
                            }
                            else {
                                // Not an ArcGIS map service.
                                resolve(null);
                            }
                        });
                    });
                }
                return this._layersInfoPromise;
            };
            /**
             * Gets the IDs of the visible layers which were configured by the REST manager in an array.
             *
             * Note: If a layer is  configured visible but is in fact not visible because its parent is not configured visible, that layer will not
             * be included in the returned list of visible layers.
             */
            MapService.prototype.getConfiguredVisibleLayers = function () {
                return this._getVisibleLayersOfType("configuredVisible");
            };
            /**
             * Gets the IDs of the layers which are visible by default in the Esri service layer. Note: If a layer is
             * visible by default but is in fact not visible because its parent is not visible by default, that layer will not
             * be included in the returned list of visible layers.
             */
            MapService.prototype.getDefaultVisibleLayers = function () {
                return this._getVisibleLayersOfType("defaultVisibility");
            };
            /**
            * Gets the IDs of the currently visible layers in an array. Note: If a layer is currently set visible but is in fact not
            * visible because its parent is not visible, that layer will not be included in the returned list of visible layers.
            */
            MapService.prototype.getVisibleLayers = function () {
                return this._getVisibleLayersOfType("_visible");
            };
            /** @private
             * Note: The visibility type:
             * "configuredVisible": returns original configured visible group layers as per the rest manager config.
             * "defaultVisibility": returns original visible group layers as per the esri service layer default visibility.
             * "_visible"         : returns visible group layers as per current visibility
             */
            MapService.prototype._getVisibleLayersOfType = function (visibilityType) {
                var visibleLayerIDList = [];
                var counter = 0;
                // Loop through the layers to find the visible ones
                for (var i = 0; i < this.layers.length; i++) {
                    var layer = this.layers[i];
                    if (layer[visibilityType]) {
                        // does this have no parent??
                        if (layer.parentLayerId === null) {
                            if (layer.subLayerIds === null || layer.subLayerIds.length === 0) {
                                // process this non group layer
                                visibleLayerIDList[counter++] = layer.id;
                            }
                            else {
                                // process this group layer and add all its ancestors recursively
                                // Notice that in case of a group layer, the parent layer is not added to the array passed in to esri as this would
                                // switch on all layers in the group without regard to their independent visibilities.
                                counter = this._getVisibleGroupLayersOfType(visibilityType, layer, visibleLayerIDList, counter);
                            }
                        }
                        else {
                        }
                    }
                }
                return visibleLayerIDList;
            };
            /**
             * Gets whether the {@link MapService} is currently visible. */
            MapService.prototype.isVisible = function () {
                var visible = false;
                if (this.serviceLayer && typeof this.serviceLayer.visible === "boolean") {
                    visible = this.serviceLayer.visible;
                }
                return visible;
            };
            /**
             * Gets whether or not this map service is Tiled (i.e. instance of esri.layers.TiledMapServiceLayer).
             * @return {Boolean} true if this map service is tiled; false otherwise
             */
            MapService.prototype.isTiled = function () {
                if (this.serviceLayer) {
                    return this.serviceLayer instanceof esri.layers.TiledMapServiceLayer;
                }
                return false;
            };
            /**
             * Sets the visibility of the {@link MapService}.
             * @param visible The visibility to be set (true: visible, false: hidden).
             */
            MapService.prototype.setVisibility = function (visible) {
                if (this.serviceLayer !== null) {
                    //GVH-4660: Due to changes in Essentials, sub layers for the mapService that does not support layer visibility are always synced to the visibility of the mapService
                    //itself. We need to do the same here so we maintain a consistent state. Else, services that start off as invisible always have essentials layers that are set to invisible
                    //though we can, in reality toggle the map service visibility from here.
                    if (!this.supportsLayerVisibility() && this.layers.length) {
                        for (var x = 0; x < this.layers.length; x++) {
                            var layer = this.layers[x];
                            //Remember: we dont want to actually setVisibility on the layer (this fires visibility events) - we simply ensure that the isVisible() function returns the correct result.
                            layer && (layer._visible = visible);
                        }
                    }
                    if (visible) {
                        this.serviceLayer.show();
                    }
                    else {
                        this.serviceLayer.hide();
                    }
                }
            };
            /**
             * Sets the opacity of the {@link MapService}.
             * @param opacity The opacity to be set, between 0.0 and 1.0 inclusive.
             */
            MapService.prototype.setOpacity = function (opacity) {
                if (opacity == null || isNaN(opacity)) {
                    opacity = 1.0;
                }
                opacity = Math.min(1, Math.max(0, opacity));
                this.opacity = opacity;
                if (this.serviceLayer && this.serviceLayer.setOpacity) {
                    this.serviceLayer.setOpacity(opacity * this.opacityFilter);
                }
            };
            /**
             * Sets the opacity filter of the {@link MapService}.
             * @param filter The opacity filter to be set, between 0.0 and 1.0 inclusive.
             */
            MapService.prototype.setOpacityFilter = function (filter) {
                if (isNaN(filter)) {
                    filter = 1.0;
                }
                filter = Math.min(1, Math.max(0, filter));
                this.opacityFilter = filter;
                if (this.serviceLayer && this.serviceLayer.setOpacity) {
                    this.serviceLayer.setOpacity(filter * this.opacity);
                }
            };
            /**
             * Sets the inActiveTheme property of the {@link MapService}. Raises the "MapServiceInActiveThemeChangedEvent" event.
             * @param value The value to set.
             */
            MapService.prototype.setInActiveTheme = function (value) {
                this.inActiveTheme = value;
                dojo.publish("MapServiceInActiveThemeChangedEvent", this);
            };
            /**
             * Gets the access token for the map service, if there is one, by looking in a number of places. */
            MapService.prototype.findServiceToken = function () {
                if (this.serviceToken) {
                    return this.serviceToken;
                }
                if (!this.essentialsMap || !this.essentialsMap.site || !this.essentialsMap.site.arcGisPortalSecurityContext) {
                    return null;
                }
                var portalSecurity = this.essentialsMap.site.arcGisPortalSecurityContext;
                var token = portalSecurity.getToken(this.serviceUrl);
                return token;
            };
            /**
             * @private
             * Find the item by Id in the specified collection.
             * @param id The id of the item to find.
             * @param collection The collection to search.
             */
            MapService.prototype._findById = function (id, collection) {
                for (var i = 0; i < collection.length; i++) {
                    var layer = collection[i];
                    // GVH-9737: We need a "==" comparison here. We dont care if the layer names are strings or numbers and it'll break functionality if you change this to a "===".
                    if (layer.id == id) {
                        return layer;
                    }
                }
                return null;
            };
            /**
             * @private
             * Find the item by name in the specified collection.
             * @param name The name of the item to find.
             * @param collection The collection to search.
             */
            MapService.prototype._findByName = function (name, collection) {
                for (var i = 0; i < collection.length; i++) {
                    var layer = collection[i];
                    // GVH-9737: We need a "==" comparison here. We dont care if the layer names are strings or numbers and it'll break functionality if you change this to a "===".
                    if (layer.name == name || layer.displayName == name) {
                        return layer;
                    }
                }
                return null;
            };
            /**
             * Find the {@link Layer} matching the specified name.
             * @param layerName The name of the {@link Layer} to find.
             */
            MapService.prototype.findLayerByName = function (layerName) {
                return this._findByName(layerName, this.layers);
            };
            /**
             * Find the Layer matching the specified Id.
             * @param layerId The Id of the Layer to find.
             */
            MapService.prototype.findLayerById = function (layerId) {
                return this._findById(layerId, this.layers);
            };
            /**
             * Find the Table matching the specified name.
             * @param tableName The name of the Table to find.
             */
            MapService.prototype.findTableByName = function (tableName) {
                return this._findByName(tableName, this.tables);
            };
            /**
             * Find the Table matching the specified Id.
             * @param tableId The Id of the Table to find.
             */
            MapService.prototype.findTableById = function (tableId) {
                return this._findById(tableId, this.tables);
            };
            /**
             * Find the Layer or Table matching the specified name.
             * If the specified name matches both a Layer and Table, the Layer will be returned.
             * @param name The name of the Layer or Table to find.
             */
            MapService.prototype.findLayerOrTableByName = function (name) {
                var result = this.findLayerByName(name);
                if (!result) {
                    result = this.findTableByName(name);
                }
                return result;
            };
            /**
             * Find the Layer or Table matching the specified Id.
             * If the specified Id matches both a Layer and Table, the Layer will be returned.
             * @param id The Id of the Layer or Table to find.
             */
            MapService.prototype.findLayerOrTableById = function (id) {
                var result = this.findLayerById(id);
                if (!result) {
                    result = this.findTableById(id);
                }
                return result;
            };
            /**
             * Refreshes the map service by making a new request to the server.
             * @param refreshTimeoutMs An optional parameter which if specified, will cause the map refresh to occur after the specified timeout. Any previous refresh timeouts
             * will be cancelled when a new refresh timeout is set - ensuring that only one request goes out within the speicfied threshold. If undefined, the map refreshes immediately.
             * @param disableClientCaching An optional parameter which, if set will disable client caching on the service layer (if supported) prior to refreshing it. Defaults to false.
             */
            MapService.prototype.refresh = function (refreshTimeoutMs, disableClientCaching) {
                var _this = this;
                var serviceLayer = this.serviceLayer;
                if (!serviceLayer || (typeof serviceLayer.refresh !== "function")) {
                    return;
                }
                var executeRefresh = function () {
                    _this._delayedRefreshToken = null;
                    if (disableClientCaching === true && typeof (serviceLayer.setDisableClientCaching) === "function") {
                        // Temporarily disable client caching if this service layer supports it
                        var disableClientCaching = serviceLayer.disableClientCaching;
                        serviceLayer.setDisableClientCaching(true);
                        serviceLayer.refresh();
                        serviceLayer.setDisableClientCaching(disableClientCaching);
                    }
                    else {
                        serviceLayer.refresh();
                    }
                };
                if (this._delayedRefreshToken) {
                    clearTimeout(this._delayedRefreshToken);
                }
                if (typeof refreshTimeoutMs !== "number") {
                    executeRefresh();
                }
                else {
                    this._delayedRefreshToken = setTimeout(executeRefresh, refreshTimeoutMs);
                }
            };
            /**
             * Refreshes the layersFilteredView collection.
             */
            MapService.prototype.refreshFilteredCollections = function () {
                var _this = this;
                this.layersFilteredView.length = 0;
                dojo.forEach(this.layers, function (lyr) { return _this._addToFilteredView(lyr); });
            };
            /** @private */
            MapService.prototype._configureLayers = function (layerResults, deepInitialize) {
                var thisMapService = this;
                for (var i = 0; layerResults && i < layerResults.length; i++) {
                    this.layers[i] = new geocortex.essentials.Layer(this.url + "/layers/" + layerResults[i].id);
                    this.layers[i].mapService = this;
                    this.layers[i]._configureObject(layerResults[i], deepInitialize);
                }
                // Creates the service layer
                this._createServiceLayer();
                if (this.minScale) {
                    this.serviceLayer.setMinScale(this.minScale);
                }
                if (this.maxScale) {
                    this.serviceLayer.setMaxScale(this.maxScale);
                }
                if (this.disableClientCaching && this.serviceLayer && this.serviceLayer.setDisableClientCaching) {
                    this.serviceLayer.setDisableClientCaching(true);
                }
            };
            /** @private - Note - this method needs to be called after the service layer has loaded. */
            MapService.prototype._configureTimeInfo = function () {
                if (!this.serviceLayer) {
                    throw new Error("_configureTimeInfo: The esri service layer must be created before attempting to populate time information.");
                }
                var tInfo = this.serviceLayer.timeInfo;
                if (!tInfo) {
                    this.isTimeAware = false;
                    return;
                }
                this.isTimeAware = true;
                this.timeInfo = MapService.getGcxTimeInfo(tInfo, this._restStartTimeOverrideString, this._restEndTimeOverrideString);
            };
            /** Internal static function. Used by Layers as well */
            MapService.getGcxTimeInfo = function (timeInfo, restStartTimeOverrideString, restEndTimeOverrideString) {
                var origStartTimeMs = null;
                var origEndTimeMs = null;
                if (timeInfo) {
                    origStartTimeMs = timeInfo.timeExtent && timeInfo.timeExtent.startTime instanceof Date ? timeInfo.timeExtent.startTime.valueOf() : parseInt(timeInfo.timeExtent[0], 10);
                    origEndTimeMs = timeInfo.timeExtent && timeInfo.timeExtent.endTime instanceof Date ? timeInfo.timeExtent.endTime.valueOf() : parseInt(timeInfo.timeExtent[1], 10);
                }
                if (((!origStartTimeMs || isNaN(origStartTimeMs)) && !restStartTimeOverrideString) || ((!origEndTimeMs || isNaN(origEndTimeMs)) && !restEndTimeOverrideString)) {
                    return null;
                }
                var startTime = restStartTimeOverrideString ? essentials.utilities.StringUtilities.getDateFromRestDateString(restStartTimeOverrideString) : new Date(origStartTimeMs);
                var endTime = restEndTimeOverrideString ? essentials.utilities.StringUtilities.getDateFromRestDateString(restEndTimeOverrideString) : new Date(origEndTimeMs);
                var result = {};
                result.timeExtent = {
                    startTime: startTime,
                    endTime: endTime
                };
                if (timeInfo) {
                    timeInfo.startTimeField && (result.startTimeField = timeInfo.startTimeField);
                    timeInfo.endTimeField && (result.endTimeField = timeInfo.endTimeField);
                    timeInfo.trackIdField && (result.trackIdField = timeInfo.trackIdField);
                    if (timeInfo.timeReference) {
                        result.timeReference = {};
                        timeInfo.timeReference.respectsDaylightSaving != undefined && (result.timeReference.respectsDaylightSavings = timeInfo.timeReference.respectsDaylightSaving);
                        timeInfo.timeReference.timeZone != undefined && (result.timeReference.timeZone = timeInfo.timeReference.timeZone);
                    }
                    if (timeInfo.exportOptions) {
                        result.exportOptions = {};
                        timeInfo.exportOptions.timeDataCumulative != undefined && (result.exportOptions.timeDataCumulative = timeInfo.exportOptions.timeDataCumulative);
                        timeInfo.exportOptions.timeOffset != undefined && (result.exportOptions.timeOffset = timeInfo.exportOptions.timeOffset);
                        timeInfo.exportOptions.timeOffsetUnits != undefined && (result.exportOptions.timeOffsetUnits = timeInfo.exportOptions.timeOffsetUnits);
                        timeInfo.exportOptions.useTime != undefined && (result.exportOptions.useTime = timeInfo.exportOptions.useTime);
                    }
                }
                return result;
            };
            /** @private */
            MapService.prototype._configureTables = function (tableResults, deepInitialize) {
                var thisMapService = this;
                for (var i = 0; tableResults && i < tableResults.length; i++) {
                    this.tables[i] = new geocortex.essentials.Layer(this.url + "/tables/" + tableResults[i].id);
                    this.tables[i].mapService = this;
                    this.tables[i]._configureObject(tableResults[i], deepInitialize);
                }
            };
            /** @private */
            MapService.prototype._createFrom = function (obj) {
                // NOTE: If you modify this code, you'll probably also need to modify toJson() as well.
                var _this = this;
                this.id = obj.id;
                this.serviceUrl = obj.serviceUrl;
                this.mapServiceType = obj.serviceType;
                this.mapServiceFunction = obj.serviceFunction;
                this.displayName = obj.displayName || obj.name;
                this.shortDisplayName = obj.shortDisplayName;
                this.baseMapGroup = obj.baseMapGroup;
                this.baseMapGroupIndex = obj.baseMapGroupIndex;
                this.baseMapGroupIsMutuallyExclusive = obj.baseMapGroupIsMutuallyExclusive;
                this.description = obj.description;
                this.copyright = obj.copyright;
                this.attributionDataUrl = obj.attributionDataUrl;
                this.hasAttributionData = obj.hasAttributionData;
                this.configuredVisible = !!obj.visible;
                this._initiallyVisible = this.configuredVisible;
                this.disableClientCaching = !!obj.disableClientCaching;
                this.instantSearch = !!obj.instantSearch;
                this.configuredOpacity = obj.opacity;
                this.opacity = this.configuredOpacity;
                this.imageFormat = obj.format;
                this.isExpanded = obj.isExpanded;
                this.serverVersion = obj.serverVersion;
                this.failureAction = obj.failureAction;
                this.failureTimeout = obj.failureTimeout;
                this.tileMatrixSet = obj.tileMatrixSet;
                this.requestEncoding = obj.requestEncoding;
                this.operationalSpatialReference = obj.operationalSpatialReference;
                this.dataProvider = obj.dataProvider;
                this.minScale = obj.minScale;
                this.maxScale = obj.maxScale;
                this.identifiable = !!obj.identifiable;
                this.includeCatalogItems = !!obj.includeCatalogItems;
                this.includeMosaicDatasetValues = !!obj.includeMosaicDatasetValues;
                this.defaultDateFormat = obj.defaultDateFormat;
                this.defaultNumberFormat = obj.defaultNumberFormat;
                this.timeZoneId = obj.timeZoneId;
                if (obj.tileInfo) {
                    this.tileInfo = dojo.clone(obj.tileInfo);
                    if (this.tileInfo.spatialReference) {
                        if (this.tileInfo.spatialReference.wkid) {
                            this.tileInfo.spatialReference = new esri.SpatialReference(this.tileInfo.spatialReference.wkid);
                        }
                        else {
                            this.tileInfo.spatialReference = new esri.SpatialReference(this.tileInfo.spatialReference.wkt);
                        }
                    }
                }
                this.supportsDynamicLayers = false;
                this.includeInLayerList = obj.includeInLayerList;
                this.drawingBehavior = obj.drawingBehavior || geocortex.essentials.DrawingBehavior.FEATURE_LAYER;
                if (obj.layerOptions) {
                    var gcxLayer = new geocortex.essentials.Layer();
                    gcxLayer.mapService = this;
                    gcxLayer._createFrom(obj.layerOptions);
                    this.layers.push(gcxLayer);
                }
                if (obj.hasOwnProperty("layerHyperlinks")) {
                    obj.layerHyperlinks.forEach(function (link) {
                        _this.layerHyperlinks.push(new geocortex.essentials.LayerHyperlink(link, _this));
                    });
                }
                if (obj.featureClustering) {
                    this.featureClustering = {
                        enabled: obj.featureClustering.enabled,
                        userCanToggle: obj.featureClustering.userCanToggle,
                        radius: obj.featureClustering.radius,
                        maximumFeatures: obj.featureClustering.clusterSize,
                        backgroundColor: obj.featureClustering.backgroundColor,
                        labelColor: obj.featureClustering.labelColor
                    };
                }
                if (obj.featureHeatMap) {
                    this.heatMap = {
                        enabled: obj.featureHeatMap.enabled,
                        userCanToggle: obj.featureHeatMap.userCanToggle,
                        respectScaleRange: obj.featureHeatMap.respectScaleRange,
                        gradient: (obj.featureHeatMap.gradient || []).slice(),
                        offset: (obj.featureHeatMap.offset || []).slice(),
                        intensity: obj.featureHeatMap.intensity,
                        field: obj.featureHeatMap.field,
                        defaultRenderer: obj.featureHeatMap.defaultRenderer ? esri.renderer.fromJson(obj.featureHeatMap.defaultRenderer) : null,
                        defaultMinScale: obj.featureHeatMap.defaultMinScale,
                        defaultMaxScale: obj.featureHeatMap.defaultMaxScale,
                        includeInLegend: obj.featureHeatMap.includeInLegend
                    };
                }
                if (obj.properties) {
                    this.catalogId = geocortex._getProperties(obj["properties"]).layerCatalogLookupId;
                }
                this.isInitialized = true;
            };
            /**
             * Populates the map service from a dynamic object which represents a map service.
             * @param serviceDefinition An object which represents the map service.
             */
            MapService.prototype.createFromDefinition = function (serviceDefinition) {
                this._createFrom(serviceDefinition);
            };
            /**
            * Exports the state of the map service as a JSON object. This can be used to recreate the
            * layer again via createFromDefinition().
            */
            MapService.prototype.toJson = function () {
                var json = {
                    id: this.id,
                    url: this.url,
                    serviceUrl: this.serviceUrl,
                    serviceType: this.mapServiceType,
                    serviceFunction: this.mapServiceFunction,
                    displayName: this.displayName,
                    shortDisplayName: this.shortDisplayName,
                    baseMapGroup: this.baseMapGroup,
                    baseMapGroupIndex: this.baseMapGroupIndex,
                    baseMapGroupIsMutuallyExclusive: this.baseMapGroupIsMutuallyExclusive,
                    description: this.description,
                    copyright: this.copyright,
                    attributionDataUrl: this.attributionDataUrl,
                    hasAttributionData: this.hasAttributionData,
                    visible: this.isVisible(),
                    disableClientCaching: this.disableClientCaching,
                    opacity: this.opacity,
                    instantSearch: this.instantSearch,
                    format: this.imageFormat,
                    isExpanded: this.isExpanded,
                    serverVersion: this.serverVersion,
                    failureAction: this.failureAction,
                    failureTimeout: this.failureTimeout,
                    tileMatrixSet: this.tileMatrixSet,
                    requestEncoding: this.requestEncoding,
                    operationalSpatialReference: this.operationalSpatialReference,
                    dataProvider: this.dataProvider,
                    minScale: this.minScale,
                    maxScale: this.maxScale,
                    identifiable: this.identifiable,
                    includeCatalogItems: this.includeCatalogItems,
                    includeMosaicDatasetValues: this.includeMosaicDatasetValues,
                    defaultDateFormat: this.defaultDateFormat,
                    defaultNumberFormat: this.defaultNumberFormat,
                    tileInfo: this.tileInfo ? this.tileInfo.toJson() : undefined,
                    includeInLayerList: this.includeInLayerList,
                    drawingBehavior: this.drawingBehavior,
                    layerOptions: this.layers.map(function (layer) { return layer.toJson(); }),
                    catalogId: this.catalogId
                };
                if (this.featureClustering) {
                    json["featureClustering"] = dojo.clone(this.featureClustering);
                }
                ;
                if (this.heatMap) {
                    json["featureHeatMap"] = dojo.clone(this.heatMap);
                    if (json["featureHeatMap"].defaultRenderer instanceof esri.renderer.Renderer) {
                        json["featureHeatMap"].defaultRenderer = json["featureHeatMap"].defaultRenderer.toJson();
                    }
                }
                ;
                return json;
            };
            /** @private */
            MapService.prototype._configureObject = function (obj, deepInitialize) {
                var _this = this;
                if (obj === undefined || obj.id === undefined || obj.displayName === undefined || obj.serviceType === undefined || obj.connectionString === undefined) {
                    throw new Error("Incorrect map service object returned from initialization");
                }
                this.id = obj.id;
                this.mapServiceType = obj.serviceType;
                this.mapServiceFunction = obj.serviceFunction === undefined ? this.mapServiceFunction : obj.serviceFunction;
                this.displayName = obj.displayName;
                this.shortDisplayName = obj.shortDisplayName;
                this.baseMapGroup = obj.baseMapGroup;
                this.baseMapGroupIndex = obj.baseMapGroupIndex;
                this.baseMapGroupIsMutuallyExclusive = obj.baseMapGroupIsMutuallyExclusive;
                this.description = obj.description === undefined ? this.description : obj.description;
                this.copyright = obj.copyright;
                this.attributionDataUrl = obj.attributionDataUrl;
                this.hasAttributionData = obj.hasAttributionData;
                this.configuredVisible = !!obj.visible;
                this.disableClientCaching = !!obj.disableClientCaching;
                this.instantSearch = !!obj.instantSearch;
                this.configuredOpacity = obj.opacity === undefined || obj.opacity === null ? this.configuredOpacity : obj.opacity;
                this.opacity = this.configuredOpacity;
                this.imageFormat = obj.format === undefined ? this.imageFormat : obj.format;
                if (obj.updateInterval !== undefined) {
                    var intervalInSecond = obj.updateInterval;
                    if (intervalInSecond && intervalInSecond < 10 && intervalInSecond !== 0) {
                        intervalInSecond = 10;
                    }
                    this.updateInterval = intervalInSecond;
                    this._resetUpdateTimer();
                }
                this.isExpanded = obj.isExpanded === undefined ? this.isExpanded : obj.isExpanded;
                this.serverVersion = obj.serverVersion;
                this.failureAction = obj.failureAction;
                this.failureTimeout = obj.failureTimeout;
                this.tileMatrixSet = obj.tileMatrixSet;
                this.requestEncoding = obj.requestEncoding;
                this.operationalSpatialReference = obj.operationalSpatialReference;
                this.dataProvider = obj.dataProvider;
                this.minScale = obj.minScale;
                this.maxScale = obj.maxScale;
                this.identifiable = !!obj.identifiable;
                this.includeCatalogItems = !!obj.includeCatalogItems;
                this.includeMosaicDatasetValues = !!obj.includeMosaicDatasetValues;
                this.defaultDateFormat = obj.defaultDateFormat;
                this.defaultNumberFormat = obj.defaultNumberFormat;
                this.timeZoneId = obj.timeZoneId;
                this._restStartTimeOverrideString = obj.startTime || null;
                this._restEndTimeOverrideString = obj.endTime || null;
                if (obj.tileInfo) {
                    this.tileInfo = dojo.clone(obj.tileInfo);
                    if (this.tileInfo.spatialReference) {
                        if (this.tileInfo.spatialReference.wkid) {
                            this.tileInfo.spatialReference = new esri.SpatialReference(this.tileInfo.spatialReference.wkid);
                        }
                        else {
                            this.tileInfo.spatialReference = new esri.SpatialReference(this.tileInfo.spatialReference.wkt);
                        }
                    }
                }
                if (typeof obj.includeInLayerList === "boolean") {
                    this.includeInLayerList = obj.includeInLayerList;
                }
                if (this.essentialsMap.layerThemesInfo.startupThemeId != null && this.includeInLayerList) {
                    // The initial visibility will be based on visibilty in the startup theme (below).
                    this._initiallyVisible = false;
                }
                else {
                    this._initiallyVisible = obj.initiallyVisible === undefined ? !!obj.visible : !!obj.initiallyVisible;
                }
                if (obj.themeSettings && obj.themeSettings.length) {
                    for (var x = 0; x < obj.themeSettings.length; x++) {
                        var themeSetting = obj.themeSettings[x];
                        var layerTheme = this.essentialsMap.layerThemesInfo.getTheme(themeSetting.themeID);
                        if (layerTheme) {
                            var isVisible = (themeSetting.visible == undefined) ? this.configuredVisible : themeSetting.visible;
                            this.layerThemeSettings.push(new essentials.LayerThemeSetting(layerTheme, isVisible));
                            if (layerTheme.id === this.essentialsMap.layerThemesInfo.startupThemeId && this.includeInLayerList) {
                                this._initiallyVisible = themeSetting.initiallyVisible === undefined ? isVisible : themeSetting.initiallyVisible;
                            }
                        }
                    }
                }
                this.supportsDynamicLayers = obj.supportsDynamicLayers === undefined ? this.supportsDynamicLayers : obj.supportsDynamicLayers;
                this.hasLayerCatalog = obj.hasLayerCatalog === undefined ? this.hasLayerCatalog : obj.hasLayerCatalog;
                if (obj.iconUri) {
                    var site = null;
                    if (this.essentialsMap) {
                        site = this.essentialsMap.site;
                    }
                    this.iconUri = geocortex.essentials.RestHelper.processClientSideTokens(site, obj.iconUri);
                }
                if (obj.featureClustering) {
                    this.featureClustering = {
                        enabled: obj.featureClustering.enabled,
                        userCanToggle: obj.featureClustering.userCanToggle,
                        radius: obj.featureClustering.radius,
                        maximumFeatures: obj.featureClustering.clusterSize,
                        backgroundColor: obj.featureClustering.backgroundColor,
                        labelColor: obj.featureClustering.labelColor
                    };
                }
                // Define heat map settings after configuration is complete
                if (obj.featureHeatMap) {
                    this.heatMap = obj.featureHeatMap;
                }
                this.drawingBehavior = obj.drawingBehavior === undefined ? this.drawingBehavior : obj.drawingBehavior;
                this._processConnectionString(obj.connectionString, obj);
                this._processProxyInfo(obj.proxyInfo);
                this._configureLayers(obj.layers, deepInitialize);
                this._configureTables(obj.tables, deepInitialize);
                if (obj.hasOwnProperty("layerHyperlinks")) {
                    obj.layerHyperlinks.forEach(function (link) {
                        _this.layerHyperlinks.push(new geocortex.essentials.LayerHyperlink(link, _this));
                    });
                }
                if (deepInitialize) {
                    this.isInitialized = true;
                }
                this.properties = geocortex._getProperties(obj.properties);
                this.extensions = geocortex._getExtensions(obj.extensions);
                this.setOpacity(this.configuredOpacity);
            };
            /** @private */
            MapService.prototype._updateServiceToken = function (token) {
                this.serviceToken = token;
                if (this.serviceLayer && this.serviceLayer._url) {
                    var _url = this.serviceLayer._url; // _url is private, this is definitely not safe
                    if (_url.query) {
                        _url.query.token = token;
                        var queryString = dojo.objectToQuery(_url.query);
                        this.serviceLayer.url = _url.path + ((queryString) ? ("?" + queryString) : "");
                    }
                }
                dojo.publish("ServiceTokenRefreshed", { serviceUrl: this.serviceUrl, token: token });
            };
            /**
            * @private
            * Extracts definition expression from dynamic definition of a layer and adds it to layer definitions.
            * @param layer The *Layer* to extract definition expression from.
            * @param serviceLayer The *ServiceLayer* to add the definition to.
            */
            MapService.prototype._addDefinitionExpression = function (layer, serviceLayer) {
                if (!layer) {
                    throw new Error("Expecting a layer");
                }
                // Get service layer if we don't have one passed in
                serviceLayer = serviceLayer || this.serviceLayer;
                if (serviceLayer instanceof esri.layers.ArcGISDynamicMapServiceLayer) {
                    // pass in null value so the layers original definition exp will be fetched
                    var definitionExpression = layer.getDefinitionExpression(null);
                    if (definitionExpression) {
                        var id = parseInt(layer.id);
                        var defs = serviceLayer.layerDefinitions || [];
                        if (id) {
                            defs[id] = definitionExpression;
                            serviceLayer.setLayerDefinitions(defs);
                        }
                        else {
                            throw new Error("Failed to add definition expression for " + layer.displayName);
                        }
                    }
                }
            };
            /** @private */
            MapService.prototype._removeDefinitionExpression = function (layer, serviceLayer) {
                if (!layer) {
                    return;
                }
                // Get service layer if we don't have one passed in
                serviceLayer = serviceLayer || this.serviceLayer;
                if (!serviceLayer) {
                    return;
                }
                if (serviceLayer instanceof esri.layers.ArcGISDynamicMapServiceLayer) {
                    var id = parseInt(layer.id);
                    if (id && serviceLayer.layerDefinitions) {
                        var defs = serviceLayer.layerDefinitions;
                        if (defs[id]) {
                            defs.splice(id, 1);
                            serviceLayer.setLayerDefinitions(defs);
                        }
                    }
                }
            };
            /** @private */
            MapService.prototype._createServiceLayer = function () {
                var _this = this;
                // If the map service is initialized, that means that service layers have been created, so we don't want to "re-create" them when
                // the layer is fully initialized. This cannot happen in deepInitialization.
                if (this.serviceLayer != null) {
                    return;
                }
                var url = this.serviceUrl;
                // Check if a secure token needs to be added to the url
                if (this.serviceToken !== null) {
                    url = url + ((url.indexOf("?") > -1) ? "&token=" : "?token=") + encodeURIComponent(this.serviceToken);
                }
                // Only create a service layer if the drawing behavior is that of a map service
                if (this.drawingBehavior !== "MapService") {
                    return;
                }
                var resourceInfo;
                switch (this.mapServiceType) {
                    case geocortex.essentials.MapServiceType.DYNAMIC:
                        // See GE-2806 and GVH-2007. If we're loading against a 3.12 instance of Essentials, we need to use our own proxy as it will strip
                        // out JSONP callback params to work around GE-2806.
                        if (this._needsProxy) {
                            esri.config.defaults.io.alwaysUseProxy = true;
                        }
                        var dynamicMapServiceLayer = new esri.layers.ArcGISDynamicMapServiceLayer(url, {
                            "id": this.id
                        });
                        this._applyAttributionUrl(dynamicMapServiceLayer);
                        var mapServiceVisibleLayers = this.getVisibleLayers();
                        if (mapServiceVisibleLayers.length === 0) {
                            if ((dynamicMapServiceLayer).setVisibleLayers) {
                                if (this.layers.length === 0) {
                                    // In cases where we have no layers attached to a dynamic map service, setting to -1 disables the service permanently
                                    // For such cases, we need to setVisibleLayers to the empty mapServiceVisibleLayers array.
                                    (dynamicMapServiceLayer).setVisibleLayers(mapServiceVisibleLayers, false);
                                }
                                else {
                                    // In cases where we have layers attached to a dynamic map service but no configured visible layers, we need to set to -1
                                    // to disable the layers. For such cases, setting to the empty mapServiceVisibleLayers array will end up showing all layers.
                                    (dynamicMapServiceLayer).setVisibleLayers(["-1"], false);
                                }
                            }
                        }
                        else {
                            if ((dynamicMapServiceLayer).setVisibleLayers) {
                                (dynamicMapServiceLayer).setVisibleLayers(mapServiceVisibleLayers, false);
                            }
                        }
                        // Set the definition expressions on the service layer
                        for (var i = 0; i < this.layers.length; i++) {
                            this._addDefinitionExpression(this.layers[i], dynamicMapServiceLayer);
                        }
                        // GVH-2740 - Binding Esri's setVisibleLayers method call so that the "LayerVisibilityChange" event is automatically thrown
                        // Note: this aspect binding should only be set after visibility is  configured as otherwise, passing in "-1" programmatically to Esri's
                        // setVisibleLayers method will set visibilities of all essentials sub-layers to false, causing us to lose sublayer
                        // visibility state configured in the rest manager.
                        this.layerVisibilityEventManager = new essentials.LayerVisibilityEventManager(this, dynamicMapServiceLayer);
                        dynamicMapServiceLayer.setImageFormat(this._getAgsDynamicImageFormat(this.imageFormat));
                        dojo.connect(dynamicMapServiceLayer, "onError", this, this._layerLoadErrorHandler);
                        dojo.connect(dynamicMapServiceLayer, "onLoad", this, function () {
                            this._handleServiceLayerLoaded(dynamicMapServiceLayer);
                            this._handleDynamicLayers(dynamicMapServiceLayer);
                        });
                        if (this._initiallyVisible) {
                            dynamicMapServiceLayer.show();
                        }
                        else {
                            dynamicMapServiceLayer.hide();
                        }
                        this.serviceLayer = dynamicMapServiceLayer;
                        break;
                    case geocortex.essentials.MapServiceType.TILED:
                        var tiledMapServiceLayer = new esri.layers.ArcGISTiledMapServiceLayer(url, {
                            "id": this.id
                        });
                        this._applyAttributionUrl(tiledMapServiceLayer);
                        dojo.connect(tiledMapServiceLayer, "onError", dojo.hitch(this, this._layerLoadErrorHandler));
                        dojo.connect(tiledMapServiceLayer, "onLoad", dojo.hitch(this, this._handleServiceLayerLoaded));
                        if (this._initiallyVisible) {
                            tiledMapServiceLayer.show();
                        }
                        else {
                            tiledMapServiceLayer.hide();
                        }
                        this.serviceLayer = tiledMapServiceLayer;
                        break;
                    case geocortex.essentials.MapServiceType.IMAGE:
                        var imageServiceLayer = null;
                        if (this._hasTileLevels()) {
                            imageServiceLayer = new esri.layers.ArcGISTiledMapServiceLayer(url, {
                                "id": this.id
                            });
                        }
                        else {
                            imageServiceLayer = new esri.layers.ArcGISImageServiceLayer(url, {
                                "id": this.id
                            });
                            imageServiceLayer.setImageFormat(this._getAgsImageServiceImageFormat(this.imageFormat));
                        }
                        this._applyAttributionUrl(imageServiceLayer);
                        dojo.connect(imageServiceLayer, "onError", this, this._layerLoadErrorHandler);
                        dojo.connect(imageServiceLayer, "onLoad", dojo.hitch(this, this._handleServiceLayerLoaded));
                        if (this._initiallyVisible) {
                            imageServiceLayer.show();
                        }
                        else {
                            imageServiceLayer.hide();
                        }
                        this.serviceLayer = imageServiceLayer;
                        break;
                    case geocortex.essentials.MapServiceType.BING:
                        var bingServiceLayer = new esri.virtualearth.VETiledLayer(this.bingProperties);
                        dojo.connect(bingServiceLayer, "onError", this, this._layerLoadErrorHandler);
                        dojo.connect(bingServiceLayer, "onLoad", dojo.hitch(this, this._handleServiceLayerLoaded));
                        if (this._initiallyVisible) {
                            bingServiceLayer.show();
                        }
                        else {
                            bingServiceLayer.hide();
                        }
                        this.serviceLayer = bingServiceLayer;
                        break;
                    case geocortex.essentials.MapServiceType.WMS:
                        // Make sure the page has imported the WMS package (it's not included with the main Esri API script)
                        if (!dojo.isObject(esri.layers.WMSLayer)) {
                            throw new Error("This Javascript application must // dojo.require the esri.layers.wms package in order to use a site with a WMS service.");
                        }
                        // Replace Esri implementation of WMS getImageUrl with our own
                        this._extendWms();
                        // Operate under two different modes: either download the capabilities or skip them.
                        // The Esri JavaScript WMS implementation is a tad buggy, and slow when downloading capabilities.
                        // It's better to skip the capabilities, but we can only do this for newer versions of Essentials which include
                        // the WMS layer name (published as the "nativeID").
                        var skipCapabilities = false;
                        for (var i = 0; i < this.layers.length; i++) {
                            if (this.layers[i].wmsLayerName) {
                                skipCapabilities = true;
                                break;
                            }
                        }
                        var wmsServiceLayer;
                        if (skipCapabilities) {
                            resourceInfo = {
                                extent: this.essentialsMap.initialExtent,
                                layerInfos: this._constructWmsLayerInfos(),
                                version: this.serverVersion
                            };
                            wmsServiceLayer = new esri.layers.WMSLayer(url, {
                                resourceInfo: resourceInfo,
                                visibleLayers: this._getWmsVisibleLayers()
                            });
                            if (this.operationalSpatialReference != null) {
                                var wkid = parseInt(this.operationalSpatialReference.replace(/^.*:/, ""));
                                // In Essentials, on the server we've determined which spatial reference to use for image requests
                                // This line will force the service to use this particular spatial reference
                                wmsServiceLayer.spatialReferences.push(wkid);
                                wmsServiceLayer.preferredSpatialReference = wkid;
                            }
                            dojo.connect(wmsServiceLayer, "onLoad", dojo.hitch(this, this._handleServiceLayerLoaded));
                        }
                        else {
                            wmsServiceLayer = new esri.layers.WMSLayer(url);
                            dojo.connect(wmsServiceLayer, "onLoad", dojo.hitch(this, this._finishWmsLayerConfiguration));
                        }
                        // If the timeInfo is not set for the service layer, set it now. Failure to do this will result in the layer not refreshing when the map's time extent is changed.
                        // Note that Essentials will always supply an override string for time aware WMS services since we don't have any trivial way to get at it client side.
                        if (this._restStartTimeOverrideString && this._restEndTimeOverrideString && !wmsServiceLayer.timeInfo) {
                            var gcxTimeInfo = MapService.getGcxTimeInfo(null, this._restStartTimeOverrideString, this._restEndTimeOverrideString);
                            if (gcxTimeInfo) {
                                var esriTimeInfo = {
                                    "timeExtent": new esri.TimeExtent(gcxTimeInfo.timeExtent.startTime, gcxTimeInfo.timeExtent.endTime)
                                };
                                wmsServiceLayer.timeInfo = esriTimeInfo;
                            }
                        }
                        wmsServiceLayer.id = this.id;
                        this._applyAttributionUrl(wmsServiceLayer);
                        // GVH-2740 - Binding esri's setVisibleLayers method call so that the "LayerVisibilityChange" event 
                        // is automatically thrown when sublayer visibility is changed.
                        this.layerVisibilityEventManager = new essentials.LayerVisibilityEventManager(this, wmsServiceLayer);
                        wmsServiceLayer.setImageFormat(this._getEsriWmsImageFormat());
                        wmsServiceLayer.__gcxWmsImageFormat = this.imageFormat; // Esri mucks with the image format - let's store the real deal for later
                        dojo.connect(wmsServiceLayer, "onError", this, this._layerLoadErrorHandler);
                        if (this._initiallyVisible) {
                            wmsServiceLayer.show();
                        }
                        else {
                            wmsServiceLayer.hide();
                        }
                        this.serviceLayer = wmsServiceLayer;
                        // Send a request to the server so that authentication can occur in Chrome for password protected resources.
                        // Should simply fail in offline mode - which is OK because WMS layers are not supported in offline.
                        // TODO: Right now there are a bunch of 401s returned in the initial request for resources - possible fix?
                        try {
                            require(["dojo/request"], function (request) {
                                request(_this._prefixProxy(url), {
                                    headers: {
                                        "X-Requested-With": null
                                    },
                                    withCredentials: true
                                }).then(function (success) {
                                    // This should never happen, but let's refresh anyways.
                                    wmsServiceLayer.refresh();
                                }, function (error) {
                                    // Will always error, as we're not actually expecting a valid response.
                                    wmsServiceLayer.refresh();
                                });
                            });
                        }
                        catch (error) {
                            console.log("Error in initializing WMS layer: " + error);
                        }
                        break;
                    case geocortex.essentials.MapServiceType.WMTS:
                        // Make sure the page has imported the WMTS package (it's not included with the main Esri API script)
                        if (!dojo.isObject(esri.layers.WMTSLayer)) {
                            throw new Error("This JavaScript application must // dojo.require the esri.layers.wmts package in order to use a site with WMTS service.");
                        }
                        // We need to have at least one WMTS layer
                        if (this.layers.length == 0) {
                            throw new Error("You must include at least one layer in your WMTS. Service " + this.displayName + " has 0 layers.");
                        }
                        // Workaround for GVH-10330. 
                        // Esri's 3.15 API used to do the conversion below when initializing WMTS layers. 
                        // In 3.16 this logic was moved and now only runs when the initializing from the WMTS capabilities document. 
                        // Since we provide the constructor with a fully populated tileInfo object the correction no longer gets applied.
                        // Performing the conversion manually here allows WMTS services work as intended.
                        if (this.tileInfo && this.tileInfo.dpi) {
                            this.tileInfo.lods.forEach(function (lod) { return lod.scale = 96 * (lod.scale / _this.tileInfo.dpi); });
                        }
                        // Specify all necessary information about the layer so that we can skip GetCapabilities (avoid proxy, improve speed and reliability)
                        var fullExtent = geocortex.essentials.GeometryUtilities.scaleEnvelopeWithoutTranslation(this.layers[0].fullExtent, 1.1);
                        if (fullExtent == null) {
                            fullExtent = geocortex.essentials.GeometryUtilities.scaleEnvelopeWithoutTranslation(this.essentialsMap.fullExtent, 1.1);
                        }
                        var layerInfo = new esri.layers.WMTSLayerInfo({
                            tileInfo: this.tileInfo,
                            // Need to expand the full extent a little bit or the Esri API will clip the layer
                            fullExtent: fullExtent,
                            initialExtent: fullExtent,
                            identifier: this.layers.length > 0 ? this.layers[0].name : null,
                            tileMatrixSet: this.tileMatrixSet,
                            format: this._getEsriOgcImageFormat(),
                            style: this.layers[0].styleName ? this.layers[0].styleName : "" //GVH-8249
                        });
                        // Specifying a resourceInfo allows us to skip the capabilities
                        resourceInfo = {
                            version: this.serverVersion,
                            layerInfos: [layerInfo],
                            getTileUrl: this._prefixProxy(this.mapUrl) // For some reason we need to explicitly define the proxy url.  It doesn't get picked up from esri.config.defaults.io.proxyUrl.
                        };
                        var options = {
                            serviceMode: "KVP",
                            resourceInfo: resourceInfo,
                            layerInfo: layerInfo
                        };
                        var wmtsServiceLayer = new esri.layers.WMTSLayer(url, options);
                        wmtsServiceLayer.id = this.id;
                        this._applyAttributionUrl(wmtsServiceLayer);
                        // GE-2409 - make sure we properly handle arbitrary parameters - Esri's WMTS improperly places an extra question mark onto the URL, so remove it
                        if (wmtsServiceLayer._url) {
                            var questionMarkCount = 0;
                            var targetQuestionMarkCount = geocortex.hasProxy() ? 2 : 1;
                            wmtsServiceLayer._url = wmtsServiceLayer._url.replace(/\?/g, function (match) {
                                questionMarkCount++;
                                return questionMarkCount <= targetQuestionMarkCount ? "?" : "";
                            });
                        }
                        dojo.connect(wmtsServiceLayer, "onError", this, this._layerLoadErrorHandler);
                        dojo.connect(wmtsServiceLayer, "onLoad", dojo.hitch(this, this._handleServiceLayerLoaded));
                        if (this._initiallyVisible) {
                            wmtsServiceLayer.show();
                        }
                        else {
                            wmtsServiceLayer.hide();
                        }
                        this.serviceLayer = wmtsServiceLayer;
                        break;
                    case geocortex.essentials.MapServiceType.WEBTILED:
                        // Replace tokens that look like {token} with ${token} (with a dollar sign in front)
                        var templateUrl = url.replace(/([^$])({[^}]*})/g, function (match, p1, p2) { return p1 + "$" + p2; });
                        var wtlOptions = {
                            copyright: this.copyright,
                            id: this.id,
                            subDomains: null
                        };
                        if (templateUrl.indexOf("${subDomain}") >= 0) {
                            wtlOptions.subDomains = this.subDomains;
                        }
                        var wtl = new esri.layers.WebTiledLayer(templateUrl, wtlOptions);
                        wtl.id = this.id;
                        this._applyAttributionUrl(wtl);
                        if (this._initiallyVisible) {
                            wtl.show();
                        }
                        else {
                            wtl.hide();
                        }
                        dojo.connect(wtl, "onError", this, this._layerLoadErrorHandler);
                        dojo.connect(wtl, "onLoad", dojo.hitch(this, this._handleServiceLayerLoaded));
                        this.serviceLayer = wtl;
                        break;
                    case geocortex.essentials.MapServiceType.VECTORTILE:
                        // A vector tile layer can be initialized from a standard AGS VectorTileServer URL or a style URL
                        var vtlUrl = url;
                        if (this._styleUrl) {
                            vtlUrl = this._styleUrl;
                            if (this.essentialsMap && this.essentialsMap.site) {
                                var styleToken = this.essentialsMap.site.getTokenFromPrincipal(this._styleUrl, this.mapServiceType);
                                if (styleToken) {
                                    // Append the token to the style URL
                                    vtlUrl = this._styleUrl + "?token=" + styleToken;
                                }
                            }
                        }
                        // We need to use require here because the Esri API does not provide the esri.layers.VectorTileLayer legacy definition for this type.
                        // This is only possible because esri.js created by the Dependency Combiner includes this module.
                        require(["esri/layers/VectorTileLayer"], function (VectorTileLayer) {
                            var vtl = new VectorTileLayer(vtlUrl);
                            vtl.id = _this.id;
                            // If the browser does not support vector tile layers the constructor will assign a load error immediately.
                            // Since our event subscriptions haven't been attached yet we need to check for and handle the error immediately.
                            if (vtl.loadError) {
                                _this._layerLoadErrorHandler(vtl.loadError);
                            }
                            if (_this._initiallyVisible) {
                                vtl.show();
                            }
                            else {
                                vtl.hide();
                            }
                            dojo.connect(vtl, "onError", _this, _this._layerLoadErrorHandler);
                            dojo.connect(vtl, "onLoad", dojo.hitch(_this, _this._handleServiceLayerLoaded));
                            _this._applyAttributionUrl(vtl);
                            _this.serviceLayer = vtl;
                        });
                        break;
                }
                this.initiateServiceFailureTimer();
            };
            MapService.prototype.initiateServiceFailureTimer = function () {
                var _this = this;
                if (!this.failureTimeout || isNaN(this.failureTimeout)) {
                    return;
                }
                setTimeout(function () {
                    if ((!_this.serviceLayer || (_this.serviceLayer && !_this.serviceLayer.loaded)) && !_this.initializationFailure) {
                        _this.failureTimeoutThresholdExceeded = true;
                        _this.onFailureTimeoutThresholdExceeded();
                    }
                }, this.failureTimeout * 1000);
            };
            MapService.prototype._applyAttributionUrl = function (lyr) {
                if (this.attributionDataUrl && this.attributionDataUrl !== "") {
                    lyr.attributionDataUrl = this.attributionDataUrl;
                    lyr.hasAttributionData = true;
                }
                else if (this.hasAttributionData) {
                    lyr.attributionDataUrl = this.url + "/attribution";
                    lyr.hasAttributionData = true;
                    var token = essentials.RestHelperHTTPService.getTokenForScope(lyr.attributionDataUrl);
                    if (token) {
                        lyr.attributionDataUrl += "?token=" + token;
                    }
                }
            };
            MapService.prototype._prefixProxy = function (url) {
                return this.proxyUrl ? this.proxyUrl + "?" + url : url;
            };
            MapService.prototype._constructWmsLayerInfos = function () {
                // Not necessary to recurse - layerInfos is a flat data structure
                var layerInfos = [];
                for (var i = 0; i < this.layers.length; i++) {
                    var gcxLayer = this.layers[i];
                    if (gcxLayer.wmsLayerName != null) {
                        var layerInfo = new esri.layers.WMSLayerInfo({
                            name: gcxLayer.wmsLayerName,
                            title: gcxLayer.name
                        });
                        // GE-3949 - styleName isn't in the API (Esri doesn't support it), but it is used by our code later on, so that we do support style names
                        layerInfo.styleName = gcxLayer.styleName;
                        layerInfos.push(layerInfo);
                    }
                }
                return layerInfos;
            };
            MapService.prototype._getWmsVisibleLayers = function () {
                var visibleLayers = [];
                for (var i = 0; i < this.layers.length; i++) {
                    var gcxLayer = this.layers[i];
                    // The layer must be visible, have visible ancestors, have a layer name, and no sublayers (only draw leaf layers)
                    if (gcxLayer.isVisible() && gcxLayer.areAllAncestorsVisible() && gcxLayer.wmsLayerName != null && gcxLayer.subLayerIds.length == 0) {
                        visibleLayers.push(gcxLayer.wmsLayerName);
                    }
                }
                return visibleLayers;
            };
            MapService.prototype._applyWmsLayerVisibility = function () {
                var visibleLayers = this._getWmsVisibleLayers();
                this.serviceLayer.setVisibleLayers(visibleLayers);
            };
            MapService.prototype._getEsriWmsImageFormat = function () {
                // The Esri WMS layer doesn't support "jpeg" - need to use "jpg" instead
                var format = this._getEsriOgcImageFormat();
                if (format == "jpeg") {
                    format = "jpg";
                }
                return format;
            };
            MapService.prototype._getEsriOgcImageFormat = function () {
                // The Esri WMS and WMTS layers add "image/" to the beginning of the image format, so we need to strip this off
                if (this.imageFormat != null) {
                    return this.imageFormat.replace(/^image\//, "");
                }
                return null;
            };
            /** @private */
            MapService.prototype._findWMSLayerName = function (wmsLayers, wmsTitle) {
                for (var i in wmsLayers) {
                    var wmsLayer = wmsLayers[i];
                    if (wmsLayer.title === wmsTitle) {
                        return wmsLayer.name;
                    }
                    if (wmsLayer.subLayers !== null && wmsLayer.subLayers.length > 0) {
                        var wmsName = this._findWMSLayerName(wmsLayer.subLayers, wmsTitle);
                        if (wmsName !== null) {
                            return wmsName;
                        }
                    }
                }
                return null;
            };
            /** @private */
            MapService.prototype._finishWmsLayerConfiguration = function (wmsLayer) {
                var visibleLayerNames = [];
                var counter = 0;
                var wmsName;
                // The list of visible layers for the WMS map service cannot be assembled until the WMS
                // map service's capabilities have been retrieved because the Essentials layers only
                // store the titles of the WMS layers, but the list visible layers must contain their
                // names.
                // This is for old versions of Essentials only.  Newer versions publish the "nativeID"
                // which is the WMS layer name.
                for (var i = 0; i < this.layers.length; i++) {
                    var layer = this.layers[i];
                    if (layer.configuredVisible && (layer.subLayerIds === null || layer.subLayerIds.length === 0)) {
                        if (layer.parentLayerId !== null) {
                            var parentLayer = this.findLayerById(layer.parentLayerId);
                            if (parentLayer.configuredVisible) {
                                wmsName = this._getWMSLayerNameFromTitle(layer.name);
                                layer.wmsLayerName = wmsName;
                                if (wmsName !== null && wmsName !== "") {
                                    visibleLayerNames[counter] = wmsName;
                                    counter++;
                                }
                            }
                        }
                        else {
                            wmsName = this._getWMSLayerNameFromTitle(layer.name);
                            layer.wmsLayerName = wmsName;
                            if (wmsName !== null && wmsName !== "") {
                                visibleLayerNames[counter] = wmsName;
                                counter++;
                            }
                        }
                    }
                }
                this.serviceLayer.setVisibleLayers(visibleLayerNames);
                // Handle the service layer loaded event
                this._handleServiceLayerLoaded(wmsLayer);
            };
            /** @private */
            MapService.prototype._handleServiceLayerLoaded = function (layer) {
                // We need to load the time information for the layer after it's loaded.
                this._configureTimeInfo();
                // Indicate that the service layer has been loaded
                this.isServiceLayerLoaded = true;
                if (this.essentialsMap &&
                    this.essentialsMap.site &&
                    dojo.isFunction(this.essentialsMap.site.onLayerLoad)) {
                    this.essentialsMap.site.onLayerLoad(layer);
                }
            };
            /** Converts the map service to use to dynamic layers. This will only have an effect if the map service supports dynamic layers. */
            MapService.prototype.convertToDynamicLayers = function () {
                var dynamicLayer = this.serviceLayer;
                if (dynamicLayer && dynamicLayer instanceof esri.layers.ArcGISDynamicMapServiceLayer) {
                    if (!dynamicLayer.dynamicLayerInfos) {
                        dynamicLayer.setDynamicLayerInfos(this._createDynamicLayerInfos(dynamicLayer));
                    }
                    if (!dynamicLayer.layerDrawingOptions) {
                        dynamicLayer.layerDrawingOptions = [];
                    }
                }
            };
            /** @private */
            MapService.prototype._layerLoadErrorHandler = function (error) {
                // Hack: Unfortunately, Esri bubbles a tile load error up as a layer error. 
                // It's not really a layer load error though, so let's just ignore those types of errors.
                // Unfortunately the only way to detect these errors is by inspecting the error message.
                if (error && error.message && error.message.indexOf("Unable to load tile") == 0) {
                    return;
                }
                this.initializationFailure = error;
                // Make sure we have access to the site.
                if (this.essentialsMap && this.essentialsMap.site) {
                    // Check if an load error event handler has been provided
                    if (dojo.isFunction(this.essentialsMap.site.onLayerLoadError)) {
                        this._layerLoadErrorHandler = this.essentialsMap.site.onLayerLoadError;
                    }
                }
            };
            /**
            * Removes a *Layer* from the the map service.
            * Also manipulates the Esri Layer and removes appropriate layer info and drawing options for the layer.
            * Currently supports dynamic layers only.
            * @param layer A layer to remove from the map service
            */
            MapService.prototype.remove = function (layer) {
                if (!layer) {
                    throw new Error("Expecting a layer.");
                }
                var sl = this.serviceLayer;
                if (layer.isDynamic && this.serviceLayer instanceof esri.layers.ArcGISDynamicMapServiceLayer && this.serviceLayer) {
                    this.convertToDynamicLayers();
                    var id = parseInt(layer.id, 10);
                    // remove the layer from this map service
                    var removeLayer = this.findLayerById(layer.id);
                    if (removeLayer != null) {
                        var index = this.layers.indexOf(removeLayer);
                        if (index > -1) {
                            removeLayer.setInActiveTheme(false);
                            this.layers.splice(index, 1);
                            dojo.publish("CatalogLayerRemovedEvent", removeLayer);
                        }
                    }
                    var visibleLayerIds = this.getVisibleLayers();
                    if (id != null) {
                        var dynamicLayerInfoArray = [];
                        if (sl.dynamicLayerInfos) {
                            dynamicLayerInfoArray = dojo.clone(this.serviceLayer.dynamicLayerInfos);
                        }
                        // Get any existing LayerDrawingOptions
                        var layerDrawingOptionsArray = [];
                        if (sl.layerDrawingOptions) {
                            layerDrawingOptionsArray = this.serviceLayer.layerDrawingOptions;
                        }
                        if (layer.isDynamic) {
                            // get the corresponding dynamicLayerInfo to remove.
                            var dynamicLayerInfo = null;
                            for (var i = 0; i < dynamicLayerInfoArray.length; i++) {
                                if (dynamicLayerInfoArray[i].id === id) {
                                    dynamicLayerInfo = dynamicLayerInfoArray[i];
                                    break;
                                }
                            }
                            if (dynamicLayerInfo) {
                                var index = dynamicLayerInfoArray.indexOf(dynamicLayerInfo);
                                if (index > -1) {
                                    dynamicLayerInfoArray.splice(index, 1);
                                    sl.setDynamicLayerInfos(dynamicLayerInfoArray, true);
                                }
                            } //throw something here since we need to find the layer to remove
                            var newLayerDrawingOptions = [];
                            for (var key in layerDrawingOptionsArray) {
                                if (layerDrawingOptionsArray.hasOwnProperty(key) && key !== layer.id) {
                                    newLayerDrawingOptions[key] = dojo.clone(layerDrawingOptionsArray[key]);
                                }
                            }
                            this._removeDefinitionExpression(layer, sl);
                            //don't need to pass in service layer, we have it and need it at this point
                            sl.setLayerDrawingOptions(newLayerDrawingOptions);
                        }
                        if (visibleLayerIds.indexOf(layer.id) > -1) {
                            visibleLayerIds.splice(visibleLayerIds.indexOf(layer.id), 1);
                        }
                        this._syncLayerVisibilities(visibleLayerIds);
                    }
                    else {
                        throw "Could not convert Layer ID '" + layer.id + "' into an integer!";
                    }
                }
                else {
                    throw "MapService - remove() - Unsupported Layer Type.";
                }
            };
            /**
            * Adds a *Layer* to the map service.
            * Also manipulates the Esri Layer and adds appropriate layer info and drawing options for dynamic layers.
            * Currently supports dynamic layers only.
            * @param layer A *Layer* to add to the map service
            */
            MapService.prototype.add = function (layer) {
                if (!layer) {
                    throw new Error("Expecting a layer");
                }
                var sl = this.serviceLayer;
                if (layer.isDynamic && sl instanceof esri.layers.ArcGISDynamicMapServiceLayer) {
                    this.convertToDynamicLayers();
                    var visibleLayerIds = this.getVisibleLayers();
                    layer.mapService = this;
                    this.layers.push(layer);
                    dojo.publish("CatalogLayerAddedEvent", layer);
                    // Get any existing DynamicLayerInfos
                    var dynamicLayerInfoArray = [];
                    if (sl.dynamicLayerInfos) {
                        dynamicLayerInfoArray = sl.dynamicLayerInfos;
                    }
                    // Get any existing LayerDrawingOptions
                    var layerDrawingOptionsArray = [];
                    if (sl.layerDrawingOptions) {
                        //layerDrawingOptionsArray = dojo.clone((<any>this.serviceLayer).layerDrawingOptions);
                        layerDrawingOptionsArray = sl.layerDrawingOptions;
                    }
                    var dynamicLayerInfo;
                    var layerDrawingOptions;
                    var id = parseInt(layer.id, 10);
                    if (id != null) {
                        // Create a DynamicLayerInfo and insert it into the appropriate position of the collection
                        dynamicLayerInfo = layer._createDynamicLayerInfo();
                        if (!dynamicLayerInfo.name) {
                            // If the Esri code has not given it a name, we'll give it our layers
                            dynamicLayerInfo.name = layer.displayName;
                        }
                        if (dynamicLayerInfo != null) {
                            dynamicLayerInfoArray.push(dynamicLayerInfo);
                        }
                        // Create a LayerDrawingOptions object and insert it into the appropriate position of the array
                        layerDrawingOptions = layer.getLayerDrawingOptions();
                        if (layerDrawingOptions != null) {
                            layerDrawingOptionsArray[id] = layerDrawingOptions;
                        }
                        // Replace the ArcGISDynamicMapServiceLayer's layerDrawingOptions and dynamicLayerInfos array properties
                        if (layerDrawingOptionsArray.length > 0) {
                            sl.setLayerDrawingOptions(layerDrawingOptionsArray, true);
                        }
                        this._addDefinitionExpression(layer, sl);
                        sl.setDynamicLayerInfos(dynamicLayerInfoArray);
                        visibleLayerIds.push(layer.id);
                        this._syncLayerVisibilities(visibleLayerIds);
                    }
                    else {
                        throw "Could not convert Layer ID '" + layer.id + "' into an integer!";
                    }
                }
                else {
                    throw "MapService - add() - Unsupported layer type..";
                }
            };
            /**
             * Gets a layers DynamicLayerInfo from the ServiceLayer by the layer's id.
             * Works only when the underlying ServiceLayer is of esri.layers.ArcGISDynamicMapServiceLayer type.
             * @param layerId The layer id.
             * @returns A DynamicLayerInfo or null if not found.
             */
            MapService.prototype.getDynamicLayerInfoById = function (layerId) {
                var dynamicInfo = null;
                if (this.serviceLayer instanceof esri.layers.ArcGISDynamicMapServiceLayer) {
                    var id = parseInt(layerId, 10);
                    if (!isNaN(id)) {
                        var dynamicLayerInfos = this.serviceLayer.dynamicLayerInfos;
                        if (dynamicLayerInfos) {
                            for (var i = 0; i < dynamicLayerInfos.length; i++) {
                                if (dynamicLayerInfos[i].id === id) {
                                    dynamicInfo = dynamicLayerInfos[i];
                                }
                            }
                        }
                    }
                }
                return dynamicInfo;
            };
            /** @private */
            MapService.prototype._syncLayerVisibilities = function (visibleLayerIds) {
                for (var i = 0; i < this.layers.length; i++) {
                    if (visibleLayerIds.indexOf(this.layers[i].id) > -1) {
                        this.layers[i].visibleStateForRefresh = geocortex.essentials.RefreshVisibility.SHOW;
                    }
                    else {
                        this.layers[i].visibleStateForRefresh = geocortex.essentials.RefreshVisibility.HIDE;
                    }
                }
                if (visibleLayerIds.length == 0) {
                    // no visible layers so shove in a -1
                    visibleLayerIds.push("-1");
                }
                this.serviceLayer.setVisibleLayers(visibleLayerIds);
            };
            /** @private */
            MapService.prototype._handleDynamicLayers = function (dynamicMapServiceLayer) {
                var _this = this;
                if (this.supportsDynamicLayers) {
                    var containsDynamicLayer = dojo.some(this.layers, function (layer) { return layer.isDynamic; });
                    var drawIndexIsSet = dojo.some(this.layers, function (layer) { return layer.drawIndex != null; });
                    var showLabelsIsSet = dojo.some(this.layers, function (layer) { return layer.canToggleLabels && !layer.showLabels; });
                    // If the MapService contains even a single dynamic layer, a drawIndex or showLabels has been set, or has a layer catalog (we need to convert all normal layers to dynamic)...
                    if (containsDynamicLayer || drawIndexIsSet || showLabelsIsSet || this.hasLayerCatalog) {
                        // The following fixes an issue specific to using dynamic layers where if the Spatial Reference is set via WKT, the Initial Extent of the Map will be way off because
                        // the Viewer gets confused about the Spatial Reference.  Note we can't set the Initial Extent in Map.js because of defect: CORE-23.
                        var map = this.essentialsMap.getMap();
                        if (map) {
                            // If the Map's Spatial Reference is null or is set to something non-meaningful...
                            if (!map.spatialReference ||
                                ((!map.spatialReference.wkid || map.spatialReference.wkid <= 0) &&
                                    (!map.spatialReference.wkt || !map.spatialReference.wkt.trim()))) {
                                // If the ArcGISDynamicMapServiceLayer's Spatial Reference is set via WKT...
                                if (dynamicMapServiceLayer.spatialReference != null &&
                                    dynamicMapServiceLayer.spatialReference.wkt && dynamicMapServiceLayer.spatialReference.wkt.trim()) {
                                    // Fix the Map's Spatial Reference (since any WKT from Essentials server can't be trusted)
                                    map.spatialReference = dynamicMapServiceLayer.spatialReference;
                                }
                            }
                            // If the Map Extent's Spatial Reference is null or is set to something non-meaningful...
                            if (map.extent &&
                                (!map.extent.spatialReference ||
                                    ((!map.extent.spatialReference.wkid || map.extent.spatialReference.wkid <= 0) &&
                                        (!map.extent.spatialReference.wkt || !map.extent.spatialReference.wkt.trim())))) {
                                // If the ArcGISDynamicMapServiceLayer's Spatial Reference is set via WKT...
                                if (dynamicMapServiceLayer.spatialReference != null &&
                                    dynamicMapServiceLayer.spatialReference.wkt && dynamicMapServiceLayer.spatialReference.wkt.trim()) {
                                    // Clone the Map's Extent but fix the Spatial Reference (since any WKT from Essentials server can't be trusted)
                                    var initialExtent = new esri.geometry.Extent(map.extent);
                                    initialExtent.spatialReference = dynamicMapServiceLayer.spatialReference;
                                    //replacing map.extent = initialExtent; with new extent manager call
                                    this.essentialsMap.extentManager.setExtentWithPriority(initialExtent, 2);
                                }
                            }
                        }
                        // Get any existing DynamicLayerInfos
                        var dynamicLayerInfoArray = this._createDynamicLayerInfos(dynamicMapServiceLayer);
                        // Get any existing LayerDrawingOptions
                        var layerDrawingOptionsArray = [];
                        if (dynamicMapServiceLayer.layerDrawingOptions) {
                            layerDrawingOptionsArray = dojo.mixin([], dynamicMapServiceLayer.layerDrawingOptions);
                        }
                        // If a ShowLabels has been set, go through and modify the LayerDrawingOptions 
                        if (showLabelsIsSet) {
                            dojo.forEach(this.layers, function (layer, i) {
                                if (layer.canToggleLabels) {
                                    // Grab the previously defined LayerDrawingOptions if there is one.
                                    var drawingOptions = layer.getLayerDrawingOptions();
                                    // If not, just make a new one that we can use.
                                    if (drawingOptions == null) {
                                        drawingOptions = new esri.layers.LayerDrawingOptions();
                                        var id = parseInt(layer.id, 10);
                                        layerDrawingOptionsArray[id] = drawingOptions;
                                    }
                                    // Add it to the collection of LayerDrawingOptions
                                    drawingOptions.showLabels = layer.showLabels;
                                }
                            });
                        }
                        // Cycle through each of the MapService's Layers and for each dynamic layer...
                        dojo.forEach(this.layers, function (layer, i) {
                            if (layer.isDynamic) {
                                var dynamicLayerInfo;
                                var layerDrawingOptions;
                                var id = parseInt(layer.id, 10);
                                if (id) {
                                    // Create a DynamicLayerInfo and insert it into the appropriate position of the collection
                                    dynamicLayerInfo = layer._createDynamicLayerInfo();
                                    if (!dynamicLayerInfo.name) {
                                        // If the Esri code has not given it a name, we'll give it our layers
                                        dynamicLayerInfo.name = layer.name;
                                    }
                                    if (dynamicLayerInfo) {
                                        dynamicLayerInfoArray.splice(i, 0, dynamicLayerInfo);
                                    }
                                    // Create a LayerDrawingOptions object and insert it into the appropriate position of the array
                                    layerDrawingOptions = layer.getLayerDrawingOptions();
                                    if (layerDrawingOptions) {
                                        layerDrawingOptionsArray[id] = layerDrawingOptions;
                                        if (layer.showLabels != null) {
                                            layerDrawingOptions.showLabels = layer.showLabels;
                                        }
                                    }
                                }
                                else {
                                    throw "Could not convert Layer ID '" + layer.id + "' into an integer!";
                                }
                            }
                        });
                        // If a DrawIndex has been set, reorder the layers appropriately
                        if (drawIndexIsSet) {
                            // Create a temporary array of DynamicLayerInfos
                            var reorderedDynamicLayerInfos = dojo.clone(dynamicLayerInfoArray);
                            // Get the list of dynamic layers with DrawIndex set, sorted by DrawIndex
                            var indexedDynamicLayers = [];
                            dojo.forEach(this.layers, function (layer, i) {
                                if (layer != null && layer.drawIndex != null) {
                                    indexedDynamicLayers.push(layer);
                                }
                            });
                            indexedDynamicLayers.sort(function (a, b) { return a.drawIndex - b.drawIndex; });
                            // Reorder the corresponding DynamicLayerInfos appropriately, leaving unindexed layers at the top in the original order
                            dojo.forEach(indexedDynamicLayers, function (layer, i) {
                                var dli = null;
                                var idx = null;
                                for (var n = 0; n < reorderedDynamicLayerInfos.length; n++) {
                                    var dl = reorderedDynamicLayerInfos[n];
                                    if (dl.id.toString() == layer.id) {
                                        dli = dl;
                                        idx = n;
                                        break;
                                    }
                                }
                                ;
                                if (dli != null && idx != null) {
                                    reorderedDynamicLayerInfos.splice(idx, 1);
                                    reorderedDynamicLayerInfos.push(dli);
                                }
                            });
                            // Replace the dynamicLayerInfoArray with the new order
                            dynamicLayerInfoArray = [];
                            dojo.forEach(reorderedDynamicLayerInfos, function (dl, i) {
                                dynamicLayerInfoArray.push(dl);
                            });
                        }
                        // Need to wait for the Dynamic Map Service Layer to 'settle' before setting the dynamic layer options/layer drawing options or else an
                        // error gets triggered by the extent manager since the change comes during a map extent change on site initialization.
                        // There is still a 'request canceled' error triggered in the console, but it seems to have no effect.
                        setTimeout(function () {
                            var originalLayers = dynamicMapServiceLayer.visibleLayers;
                            // Replace the ArcGISDynamicMapServiceLayer's layerDrawingOptions and dynamicLayerInfos array properties
                            if (layerDrawingOptionsArray.length > 0) {
                                dynamicMapServiceLayer.setLayerDrawingOptions(layerDrawingOptionsArray, true);
                            }
                            if (dynamicLayerInfoArray.length > 0) {
                                dynamicMapServiceLayer.setDynamicLayerInfos(dynamicLayerInfoArray, true);
                            }
                            // Fix the visible layers (because the setDynamicLayerInfos() method automatically makes all dynamic layers visible - this is possibly an Esri bug)
                            var visibleLayers = _this.getVisibleLayers();
                            // Note: We're simply resetting the esri map service to its original visibility here because all layers have erroneously been turned on. This is an internal operation and
                            // we don't want the LayerVisibilityEventManager to fire any events, because if it did, our gcx layers would mirror esri's internal layer state i.e. it would change group layer visibility
                            // to 'off' if all of the group layers children are off (GVH-6122). We'll attach the special "InternallyChangedLayer" property to the 'visibleLayers' array so the LayerVisibilityEventManager
                            // knows that it's not to be treated like a regular programmatic visibility change. We'll set it to an empty object so no events are fired.
                            visibleLayers["InternallyChangedLayer"] = {};
                            if (visibleLayers.length > 0) {
                                dynamicMapServiceLayer.setVisibleLayers(visibleLayers);
                            }
                            else {
                                // When dynamic map service is added with 0 layers (when a layer catalog is used for example) we need to send the visible layers with -1
                                // per Esri's specs or else a default layer will show
                                visibleLayers.push("-1");
                                dynamicMapServiceLayer.setVisibleLayers(visibleLayers);
                            }
                        }, 0);
                    }
                }
            };
            /** @private */
            MapService.prototype._createDynamicLayerInfos = function (dynamicMapServiceLayer, includeOnlyEssentialsLayers) {
                if (includeOnlyEssentialsLayers == undefined) {
                    includeOnlyEssentialsLayers = true;
                }
                var dynamicLayerInfoArray = null;
                if (dynamicMapServiceLayer != null) {
                    // Get any existing DynamicLayerInfos
                    dynamicLayerInfoArray = dynamicMapServiceLayer.createDynamicLayerInfosFromLayerInfos();
                    if (includeOnlyEssentialsLayers) {
                        // Discard any layers we're not interested in (since createDynamicLayerInfosFromLayerInfos() generates DynamicLayerInfos for every layer)
                        for (var i = dynamicLayerInfoArray.length - 1; i >= 0; i--) {
                            var layer = this.findLayerById(dynamicLayerInfoArray[i].id.toString());
                            // Exclude if it's not a layer we're interested in or if it's layer that has its own dynamic definition (which we'll use later to create a DynamicLayerInfo)
                            if (layer == null || layer.isDynamic) {
                                dynamicLayerInfoArray.splice(i, 1);
                            }
                        }
                    }
                }
                return dynamicLayerInfoArray;
            };
            /** @private */
            MapService.prototype._getAgsDynamicImageFormat = function (imgFormat) {
                if (typeof imgFormat == "undefined" || imgFormat === null || imgFormat.length < 1) {
                    return "png8";
                }
                var lowerCaseImgFormat = imgFormat.toLowerCase();
                switch (lowerCaseImgFormat) {
                    case "png":
                    case "png8":
                    case "png24":
                    case "png32":
                    case "jpeg":
                    case "jpg":
                    case "gif":
                    case "bmp":
                    case "svg":
                    case "svgz":
                    case "emf":
                    case "ps":
                    case "pdf":
                        // This is one of the supported AGS dynamic map service formats
                        // See http://resources.arcgis.com/en/help/arcgis-rest-api/index.html#/Export_Map/02r3000000v7000000/
                        return lowerCaseImgFormat;
                    default:
                        // The requested image format is not supported - use the default
                        return "png8";
                }
            };
            /** @private */
            MapService.prototype._getAgsImageServiceImageFormat = function (imgFormat) {
                if (typeof imgFormat == "undefined" || imgFormat === null || imgFormat.length < 1) {
                    return null;
                }
                var lowerCaseImgFormat = imgFormat.toLowerCase();
                switch (lowerCaseImgFormat) {
                    case "jpgpng": // Added at AGS 10.0 - returns a JPG if there are no transparent pixels in the requested extent; otherwise, it returns a PNG
                    case "png":
                    case "png8":
                    case "png24":
                    case "png32": // Added at AGS 10.2
                    case "jpeg":
                    case "jpg":
                    case "gif":
                    case "bmp":
                    case "tiff":
                        // This is one of the supported AGS image service formats
                        // See http://resources.arcgis.com/en/help/arcgis-rest-api/#/Export_Image/02r3000000wm000000/
                        return lowerCaseImgFormat;
                    default:
                        // The requested image format is not supported - use the default
                        return null;
                }
            };
            /** @private
             * Note: The visibility type:
             * "configuredVisible": returns original configured visible group layers as per the rest manager config.
             * "defaultVisibility": returns original visible group layers as per the esri service layer default visibility.
             * "_visible"         : returns visible group layers as per current visibility
             */
            MapService.prototype._getVisibleGroupLayersOfType = function (visibilityType, parentLayer, results, count) {
                if (parentLayer[visibilityType]) {
                    for (var ix = 0; ix < parentLayer.subLayerIds.length; ix++) {
                        var layer = this.findLayerById(parentLayer.subLayerIds[ix]);
                        if (layer[visibilityType]) {
                            if (layer.subLayerIds !== null && layer.subLayerIds.length > 0) {
                                count = this._getVisibleGroupLayersOfType(visibilityType, layer, results, count);
                            }
                            else if (dojo.indexOf(results, layer.id) < 0) {
                                results[count] = layer.id;
                                count++;
                            }
                        }
                    }
                }
                return count;
            };
            /** @private */
            MapService.prototype._getWMSLayerNameFromTitle = function (wmsTitle) {
                if (this.serviceLayer instanceof esri.layers.WMSLayer) {
                    return this._findWMSLayerName(this.serviceLayer.layerInfos, wmsTitle);
                }
                return null;
            };
            MapService.prototype._getPrincipalResult = function (f) {
                if (!this.essentialsMap) {
                    return undefined;
                }
                if (!this.essentialsMap.site) {
                    return undefined;
                }
                if (!this.essentialsMap.site.principal) {
                    return undefined;
                }
                return f(this.essentialsMap.site.principal);
            };
            MapService.prototype._processConnectionString = function (connectionString, obj) {
                var extractValue = geocortex.essentials.ServiceHelper.extractConnectionStringValue;
                if (this.mapServiceType == geocortex.essentials.MapServiceType.BING) {
                    this.bingProperties = {};
                    var prop;
                    prop = extractValue(connectionString, "mapStyle");
                    if (prop && prop.length > 0) {
                        this.bingProperties.mapStyle = prop;
                    }
                    prop = extractValue(connectionString, "culture");
                    if (prop && prop.length > 0) {
                        this.bingProperties.culture = prop;
                    }
                    prop = extractValue(connectionString, "key");
                    if (prop && prop.length > 0) {
                        this.bingProperties.bingMapsKey = prop;
                    }
                }
                else {
                    // Check if we have the url
                    var extractedUrl = extractValue(connectionString, "url");
                    if (extractedUrl.length > 0) {
                        this.serviceUrl = extractedUrl.replace(/%3d/g, "=").replace(/%3D/g, "=");
                    }
                    else if (((this.mapServiceType === geocortex.essentials.MapServiceType.DYNAMIC || this.mapServiceType === geocortex.essentials.MapServiceType.TILED) && this.essentialsMap.site.getEssentialsVersion() >= 3.912) ||
                        ((this.mapServiceType === geocortex.essentials.MapServiceType.FEATURE || this.mapServiceType === geocortex.essentials.MapServiceType.IMAGE || this.mapServiceType === geocortex.essentials.MapServiceType.VECTORTILE) && this.essentialsMap.site.getEssentialsVersion() >= 4.01)) {
                        // A connection string that does not include a URL indicates that we are using the layer security proxy.
                        // Proxy endpoints are relative to the REST endpoint of the Essentials map service.
                        // We added support for map services at 3.12 and feature and image services at 4.1.
                        if (this.essentialsMap.site.getEssentialsVersion() < 4.03) {
                            // Legacy location of the endpoint prior to 4.3
                            this.serviceUrl = this.url + "/MapServer";
                        }
                        else {
                            // As of 4.3 we have new locations for the proxy. As of 4.5 we have an even newer location.
                            var georestPrefix = this.essentialsMap.site.getEssentialsVersion() < 4.05 ? "/GeoREST" : "/rest/services/x";
                            if (this.mapServiceType === geocortex.essentials.MapServiceType.FEATURE) {
                                // FeatureLayer endpoints contain the layer id
                                if (obj && obj.layers && obj.layers.length > 0 && obj.layers[0]) {
                                    this.serviceUrl = this.url + georestPrefix + "/FeatureServer/" + obj.layers[0].id;
                                }
                                else {
                                    throw new Error("Unable to configure FeatureLayer connection string. No child layer is specified.");
                                }
                            }
                            else if (this.mapServiceType === geocortex.essentials.MapServiceType.IMAGE) {
                                this.serviceUrl = this.url + georestPrefix + "/ImageServer";
                            }
                            else if (this.mapServiceType === geocortex.essentials.MapServiceType.VECTORTILE) {
                                this.serviceUrl = this.url + georestPrefix + "/VectorTileServer";
                            }
                            else {
                                this.serviceUrl = this.url + georestPrefix + "/MapServer";
                            }
                        }
                        if (this._getPrincipalResult(function (x) { return x.isAuthenticated; })) {
                            this.serviceToken = this._getPrincipalResult(function (x) { return x.tokens.site; });
                        }
                        // GE-2806 / GVH-2007
                        // Floating point equality comparisons are risky, so we'll use the string version for this specific version comparison.
                        if (this.essentialsMap.site.currentVersion === "3.912") {
                            this._needsProxy = true;
                        }
                    }
                    // Check if we have the geometry service url
                    // NOTE: The only way this is ever going to work is if a custom "geometryServiceUrl" property is added to the service connection string.
                    // Geocortex Essentials does not publish that property at all.
                    var geometryServiceUrl = extractValue(connectionString, "geometryServiceUrl");
                    if (geometryServiceUrl.length > 0) {
                        this.geometryServiceUrl = geometryServiceUrl;
                    }
                    // Get the optional styleUrl of vector tile layers
                    if (this.mapServiceType === geocortex.essentials.MapServiceType.VECTORTILE) {
                        this._styleUrl = extractValue(connectionString, "styleUrl");
                    }
                    // Get the token from our principal.
                    if (this.essentialsMap && this.essentialsMap.site && !this.serviceToken) {
                        this.serviceToken = this.essentialsMap.site.getTokenFromPrincipal(this.serviceUrl, this.mapServiceType);
                    }
                    // Check if we have the token
                    var extractedToken = extractValue(connectionString, "token");
                    var portalAuth = this.essentialsMap && this.essentialsMap.site ? this.essentialsMap.site.arcGisPortalSecurityContext : null;
                    if (extractedToken.length > 0) {
                        this.serviceToken = extractedToken;
                    }
                    else if (portalAuth && portalAuth.appliesTo(this.serviceUrl) && portalAuth.tokenResult) {
                        this.serviceToken = portalAuth.tokenResult.token;
                    }
                    else {
                        // Find the control block associated with this map service's ServiceUrl. A URL is of the form
                        // http://[host]/../../../authenticate
                        // Find URLs up to http://[host]/../../../                      
                        // If that control block is found, attach the associated token to the map service
                        if (this.serviceUrl != null) {
                            var blockStore = geocortex.essentials.RestHelperHTTPService.getAuthenticationControlBlockStore();
                            var controlBlock = blockStore.find(this.serviceUrl);
                            if (controlBlock && controlBlock.token != null) {
                                this.serviceToken = controlBlock.token;
                            }
                        }
                    }
                    // Check if we have a proxy url
                    var extractedProxyUrl = extractValue(connectionString, "proxy");
                    if (extractedProxyUrl.length > 0) {
                        this.proxyUrl = extractedProxyUrl;
                        // For some reason, addProxyRule is on the root esri object, missing from the official typing and "urlUtils" (where it's supposed to be)
                        // doesn't always load (despite being required). See GVH-4349.
                        esri.addProxyRule({
                            urlPrefix: this.serviceUrl,
                            proxyUrl: extractedProxyUrl
                        });
                        // AGO basemaps actually have two URLs - services.arcgisonline.com and server.arcgisonline.com.
                        if (this.serviceUrl.indexOf("services.arcgis") > -1) {
                            esri.addProxyRule({
                                urlPrefix: this.serviceUrl.replace("services.arcgis", "server.arcgis"),
                                proxyUrl: extractedProxyUrl
                            });
                        }
                    }
                    // Check if we have a map url (for WMS and WMTS in KVP mode - we don't support the tileRestUrl because we don't support WMTS in RESTful mode in JavaScript)
                    var extractedMapUrl = extractValue(connectionString, "mapUrl");
                    if (extractedMapUrl.length > 0) {
                        this.mapUrl = extractedMapUrl.replace(/%3d/g, "=").replace(/%3D/g, "=");
                    }
                    // Check if we have a tile REST url (for WMS and WMTS in RESTfult mode).
                    var extractedTileRestUrl = extractValue(connectionString, "tileRestUrl");
                    if (extractedTileRestUrl.length > 0) {
                        this.tileRestUrl = extractedTileRestUrl.replace(/%3d/g, "=").replace(/%3D/g, "=");
                    }
                    // Check if we have subDomains (for web tiled layer)
                    var subDomains = extractValue(connectionString, "subDomains");
                    if (subDomains) {
                        this.subDomains = subDomains.split(",");
                    }
                }
            };
            /** @private */
            MapService.prototype._isLocalProxyInfo = function (proxyInfo) {
                if (!proxyInfo) {
                    return false;
                }
                if (proxyInfo.type != "local-reverse-proxy") {
                    return false;
                }
                if (!proxyInfo.address) {
                    return false;
                }
                return true;
            };
            MapService.prototype._processProxyInfo = function (proxyInfo) {
                if (this._isLocalProxyInfo(proxyInfo)) {
                    // We have a local reverse proxy available, so lets try and use it-
                    // We have to compute the url for it relative to the application's root though.
                    var address = this.url + "/../../../../../" + proxyInfo.address;
                    var parts = address.split("/");
                    for (var i = parts.indexOf(".."); i > 0; i = parts.indexOf("..")) {
                        parts.splice(i - 1, 2);
                    }
                    // We have a "proper" URL again, so use it.
                    this.serviceUrl = parts.join("/");
                }
            };
            /**
             * Returns whether or not this service supports layer visibility. */
            MapService.prototype.supportsLayerVisibility = function () {
                switch (this.mapServiceType) {
                    case geocortex.essentials.MapServiceType.FEATURE:
                    case geocortex.essentials.MapServiceType.GEORSS:
                    case geocortex.essentials.MapServiceType.KML:
                    case geocortex.essentials.MapServiceType.BING:
                    case geocortex.essentials.MapServiceType.TILED:
                    case geocortex.essentials.MapServiceType.WMTS:
                    case geocortex.essentials.MapServiceType.IMAGE:
                    case geocortex.essentials.MapServiceType.WEBTILED:
                        return false;
                    case geocortex.essentials.MapServiceType.DYNAMIC:
                        return this.serviceLayer !== null && !!this.serviceLayer.visibleLayers;
                }
                return true; // Will return true for last type - WMS
            };
            /** @private */
            MapService.prototype._setVisibility = function (layerID, visible, doNotRefresh) {
                var targetLayer = { mapServiceId: this.id, layerId: layerID, visibility: visible };
                // Determines which  Esri layer type to create for this MapService
                if (doNotRefresh === undefined) {
                    doNotRefresh = false;
                }
                var counter, ix, layer;
                switch (this.mapServiceType) {
                    case geocortex.essentials.MapServiceType.DYNAMIC:
                        // Make sure the service layer is available
                        if (this.serviceLayer !== null) {
                            var visibleLayers = this.serviceLayer.visibleLayers;
                            if (!visibleLayers) {
                                // A feature layer has no concept of visible layers for example.
                                if (visible) {
                                    // Calling serviceLayer.show() or hide() will esri's visibility-change event for 
                                    // the map service. We will also fire the LayerVisibilityChange manually for the layer itself
                                    this.serviceLayer.show();
                                }
                                else {
                                    this.serviceLayer.hide();
                                }
                                // We need to publish the "LayerVisibilityChange" event manually here since esri's setLayerVisibilit
                                // y function was not called. The code below publishes an 'array within an array' on purpose
                                // since dojo seems to strip off the outer array if there's just one object/element in the array!
                                dojo.publish("LayerVisibilityChange", [new Array(targetLayer)]);
                                break;
                            }
                            var newVisibleLayers = this.getVisibleLayers();
                            // Add the special 'InternallyChangedLayer' property to the newVisibleLayers array object so that the 
                            // LayerVisibilityEventManager knows that esri's setVisibleLayers has been called internally via the layers setVisibility
                            // method and not programmatically. Note: The event manager will intercept all esri setVisibleLayer calls.
                            // IMPORTANT: Removing this property will cause the layer list to lose all visibility state information between calls
                            newVisibleLayers["InternallyChangedLayer"] = targetLayer;
                            // If no layers are visible, pass in "-1" as per esri's API specs
                            if (newVisibleLayers.length === 0) {
                                newVisibleLayers.push("-1");
                            }
                            if (this.serviceLayer.setVisibleLayers) {
                                this.serviceLayer.setVisibleLayers(newVisibleLayers, doNotRefresh);
                            }
                        }
                        break;
                    case geocortex.essentials.MapServiceType.WMS:
                        // Make sure the service layer is available
                        if (this.serviceLayer !== null) {
                            var newVisibleWmsLayers = [];
                            // Add the special 'InternallyChangedLayer' property to the newVisibleWmsLayers array object so that the 
                            // LayerVisibilityEventManager knows that esri's setVisibleLayers has been called internally 
                            // and not programmatically. Note: The event manager will intercept all esri setVisibleLayer calls.
                            newVisibleWmsLayers["InternallyChangedLayer"] = targetLayer;
                            counter = 0;
                            // We need to make sure that the ordering in Layers is preserved in the 
                            // list of visible layers because the WMS server will draw the layers in
                            // the order in which they occur in the list of visible layers.
                            for (ix = 0; ix < this.layers.length; ix++) {
                                layer = this.layers[ix];
                                if (layer.isVisible() &&
                                    (layer.subLayerIds === null || layer.subLayerIds.length === 0) &&
                                    layer.areAllAncestorsVisible()) {
                                    var wmsName = layer.wmsLayerName;
                                    // WMS layers whose names are empty strings shouldn't be added to the list
                                    // of visible layers.
                                    if (wmsName !== null && wmsName !== "") {
                                        newVisibleWmsLayers[counter] = wmsName;
                                        counter++;
                                    }
                                }
                            }
                            if (doNotRefresh) {
                                this.serviceLayer.visibleLayers = newVisibleWmsLayers.slice(0);
                                // We need to publish the "LayerVisibilityChange" event manually here since esri's setLayerVisibilit
                                // y function was not called. The code below publishes an 'array within an array' on purpose
                                // since dojo seems to strip off the outer array if there's just one object/element in the array!
                                dojo.publish("LayerVisibilityChange", [new Array(targetLayer)]);
                            }
                            else {
                                this.serviceLayer.setVisibleLayers(newVisibleWmsLayers);
                            }
                        }
                        break;
                    case geocortex.essentials.MapServiceType.FEATURE:
                    case geocortex.essentials.MapServiceType.GEORSS:
                    case geocortex.essentials.MapServiceType.KML:
                    case geocortex.essentials.MapServiceType.BING:
                    case geocortex.essentials.MapServiceType.TILED:
                    case geocortex.essentials.MapServiceType.WMTS:
                    case geocortex.essentials.MapServiceType.IMAGE:
                    case geocortex.essentials.MapServiceType.WEBTILED:
                        if (this.serviceLayer !== null) {
                            // Though the mapService for these layers does not support individual layer visibilities, we support setting visibilities via a sub layer
                            // if the service has exactly one it's sub layer (e.g. feature layers). Set the service layer to visible in case of feature layers.
                            if (this.layers.length === 1) {
                                if (visible) {
                                    this.serviceLayer.show();
                                }
                                else {
                                    this.serviceLayer.hide();
                                }
                                // We need to publish the "LayerVisibilityChange" event manually here since esri's setLayerVisibilit
                                // y function was not called. The code below publishes an 'array within an array' on purpose
                                // since dojo seems to strip off the outer array if there's just one object/element in the array!
                                dojo.publish("LayerVisibilityChange", [new Array(targetLayer)]);
                            }
                            else {
                                throw new Error("Visibility of individual layers cannot be set for this Map Service: {0}".format(this.displayName));
                            }
                        }
                        break;
                    default:
                        throw new Error("Cannot set layer visibility. Unknown MapService type.");
                }
            };
            MapService.prototype._extendWms = function () {
                // The purpose of this is to replace Esri'S implementation of getImageUrl for WMS so that we can support the STYLES parameter
                // GVH-11526: This also now serves to set the time parameter for outgoing image requests.
                if (!geocortex.essentials.MapService._wmsExtended) {
                    var originalFunction = esri.layers.WMSLayer._meta.hidden.getImageUrl;
                    var blankMapMatcher = /.*images\/pixel.png$/;
                    esri.layers.WMSLayer.extend({
                        getImageUrl: function (param, width, height, callback) {
                            // We need to remap the original URL. To do so, we need to call the original method and
                            // get it to call our dummy callback.
                            var _this = this;
                            function surrogateCallback(originalUrl) {
                                if (blankMapMatcher.test(originalUrl)) {
                                    // This is a placeholder pixel for an empty image and needs no modification
                                    callback(originalUrl);
                                    return;
                                }
                                // Construct a lookup table for looking up layer info based on layer name
                                var lookup = {};
                                for (var i = 0; i < _this.layerInfos.length; i++) {
                                    lookup[_this.layerInfos[i].name] = _this.layerInfos[i].styleName;
                                }
                                // Get the WMS style names
                                var styles = [];
                                for (i = 0; i < _this.visibleLayers.length; i++) {
                                    styles.push(lookup[_this.visibleLayers[i]]);
                                }
                                var styleNames = styles.join(",");
                                // Replace STYLES parameter
                                var query = originalUrl.substring(originalUrl.lastIndexOf("?") + 1, originalUrl.length);
                                var queryObject = dojo.queryToObject(query);
                                queryObject.STYLES = styleNames;
                                // Replace spatial reference with the preferred value
                                if (_this.preferredSpatialReference) {
                                    var crsParameterName = queryObject.CRS ? "CRS" : "SRS";
                                    queryObject[crsParameterName] = "EPSG:" + _this.preferredSpatialReference;
                                }
                                // Replace image format with the real deal
                                if (_this.__gcxWmsImageFormat) {
                                    queryObject["FORMAT"] = _this.__gcxWmsImageFormat;
                                }
                                // Set the time parameter based on the current time extent of the map.
                                var map = _this.getMap();
                                var startTime = map && map.timeExtent ? map.timeExtent.startTime : _this.timeInfo && _this.timeInfo.timeExtent && _this.timeInfo.timeExtent.startTime;
                                var endTime = map && map.timeExtent ? map.timeExtent.endTime : _this.timeInfo && _this.timeInfo.timeExtent && _this.timeInfo.timeExtent.endTime;
                                if (startTime && endTime) {
                                    var isoStartTimeString = new Date(startTime.getTime() - (startTime.getTimezoneOffset() * 60 * 1000)).toISOString();
                                    var isoEndTimeString = new Date(endTime.getTime() - (endTime.getTimezoneOffset() * 60 * 1000)).toISOString();
                                    queryObject["TIME"] = isoStartTimeString + "/" + isoEndTimeString;
                                }
                                // Convert back to URL
                                var newUrl = originalUrl.substring(0, originalUrl.lastIndexOf("?") + 1) + dojo.objectToQuery(queryObject);
                                callback(newUrl);
                            }
                            ;
                            originalFunction.apply(this, [param, width, height, surrogateCallback]);
                        }
                    });
                    geocortex.essentials.MapService._wmsExtended = true;
                }
            };
            /** @private */
            MapService.prototype._hasTileLevels = function () {
                if (!this.tileInfo) {
                    return false;
                }
                if (!this.tileInfo.lods) {
                    return false;
                }
                if (this.tileInfo.lods.length > 0) {
                    return true;
                }
                return false;
            };
            /**
             * Adds the layers specified by the layer catalog details to the map service.
             * @param details The details.
             * @returns A list of the layers that were added.
             */
            MapService.prototype.applyCatalogLayersChange = function (details) {
                var _this = this;
                var modified = false;
                var layers = [];
                // map service details must be for this map service
                if (this.id != details.mapServiceId) {
                    return;
                }
                // Get Geocortex layers for each of the entries. Make sure to first check for their existence in the map service already.
                for (var i = 0; i < details.entries.length; i++) {
                    var entry = details.entries[i];
                    var layer = this.findLayerById(entry.id);
                    if (!layer) {
                        layer = new geocortex.essentials.Layer(this.url + " / layers /" + details.entries[i].id);
                        // a visibility hack? - the new layers need to have a configuredVisible
                        // attribute of true in order to be shown when the layer list refreshes
                        details.entries[i].visible = true;
                        layer.createFromDefinition(details.entries[i]);
                        layer.isUserCreated = true;
                        layer.includeInLayerList = true;
                        layer.setInActiveTheme(true);
                    }
                    layers.push(layer);
                }
                // Find the layers that we need to remove.
                // These will be layers that are in the map service, are user created, but not in the input details.
                var removeLayers = this.layers.filter(function (layer) {
                    return layer.isUserCreated && layers.indexOf(layer) < 0;
                });
                // Loop through all of the layers in the details, and check to see if they are in the map service already.
                // If they aren't we need to add them.
                var addLayers = layers.filter(function (layer) {
                    return _this.layers.indexOf(layer) < 0;
                });
                removeLayers.forEach(function (layer) {
                    _this.remove(layer);
                    modified = true;
                });
                addLayers.forEach(function (layer) {
                    _this.add(layer);
                    modified = true;
                });
                if (modified) {
                    // we only need to call this if the catalog layers changed on the map service
                    dojo.publish("MapServiceLayersChangedWithResultEvent", { mapService: this, newItems: [].concat(addLayers), oldItems: [].concat(removeLayers) });
                    dojo.publish("CatalogLayersChangedEvent", this);
                    return addLayers;
                }
                return [];
            };
            MapService.prototype.getLayerThemeSettings = function (layerThemeOrId) {
                for (var x = 0; x < this.layerThemeSettings.length; x++) {
                    var layerThemeSetting = this.layerThemeSettings[x];
                    if ((layerThemeSetting.theme === layerThemeOrId) || (layerThemeSetting.theme.id === layerThemeOrId)) {
                        return layerThemeSetting;
                    }
                }
                return null;
            };
            /**
             * Gets the feature layer associated with this service. Only applicable for single-layer service types such as
             * feature layers and image services. For other types of services, use getFeatureLayer() on individual layers.
             */
            MapService.prototype.getFeatureLayer = function () {
                var _this = this;
                if (this._featureLayerPromise) {
                    return this._featureLayerPromise;
                }
                var featureLayer;
                if (this.serviceLayer instanceof esri.layers.FeatureLayer) {
                    // For a feature layer service, the service layer is already what we need.
                    featureLayer = this.serviceLayer;
                }
                else if (this.mapServiceType === essentials.MapServiceType.IMAGE) {
                    // Try to load from the image service endpoint.
                    var url = this.serviceUrl;
                    if (this.serviceToken !== null) {
                        url = url + ((url.indexOf("?") > -1) ? "&token=" : "?token=") + encodeURIComponent(this.serviceToken);
                    }
                    featureLayer = new esri.layers.FeatureLayer(url);
                }
                else {
                    return Promise.resolve(null);
                }
                if (!featureLayer.loaded) {
                    this._featureLayerPromise = new Promise(function (resolve, reject) {
                        var loadHandle = featureLayer.on("load", function () {
                            loadHandle.remove();
                            errorHandle.remove();
                            resolve(featureLayer);
                        });
                        var errorHandle = featureLayer.on("error", function (error) {
                            loadHandle.remove();
                            errorHandle.remove();
                            _this._featureLayerPromise = null;
                            reject(error);
                        });
                    });
                }
                else {
                    this._featureLayerPromise = Promise.resolve(featureLayer);
                }
                return this._featureLayerPromise;
            };
            /** If the current layer is a dynamic map service layer and the interval is reasonable, then refresh the map service periodically */
            MapService.prototype._resetUpdateTimer = function () {
                if (this.updateInterval != undefined && this.updateInterval != 0) {
                    if (this._updateIntervalId != undefined) {
                        window.clearInterval(this._updateIntervalId);
                    }
                    var that = this;
                    this._updateIntervalId = setInterval(function () {
                        that._onUpdateIntervalTick();
                    }, this.updateInterval * 1000);
                }
                else {
                    window.clearInterval(this._updateIntervalId);
                    this._updateIntervalId = null;
                }
            };
            /** When the timer goes off, refresh the map service */
            MapService.prototype._onUpdateIntervalTick = function () {
                if (this.serviceLayer && this.serviceLayer.refresh) {
                    var that = this;
                    if (that.serviceLayer.setDisableClientCaching) {
                        // Temporarily disable client caching if this layer supports it
                        that.serviceLayer.setDisableClientCaching(true);
                        that.serviceLayer.refresh();
                        that.serviceLayer.setDisableClientCaching(that.disableClientCaching);
                    }
                    else {
                        that.serviceLayer.refresh();
                    }
                }
            };
            MapService.prototype._addToFilteredView = function (layer) {
                if (layer && this._layerThemeLayerFilter(layer)) {
                    this.layersFilteredView.push(layer);
                }
            };
            /**
             * @private: The filter used for filtering each layer in a given mapService based on layer theme settings
             */
            MapService.prototype._layerThemeLayerFilter = function (layer) {
                return layer.mapService.essentialsMap.layerThemesInfo.layerThemesConfigured ? layer.inActiveTheme : true;
            };
            /**
             * @private
             * Gets the default geometry service url from the site configuration. Returns null if none found.
             */
            MapService.prototype._getDefaultGeometryServiceUrl = function () {
                var site = this.essentialsMap ? this.essentialsMap.site : null;
                var serviceUrl = site && site.geometryEndpoints && site.geometryEndpoints.length > 0 ? site.geometryEndpoints[0].geometryServiceUrl : null;
                return serviceUrl;
            };
            /**
             * @private
             * Gets the default geometry service security token. Returns null if none found.
             */
            MapService.prototype._getDefaultGeometryServiceToken = function () {
                var site = this.essentialsMap ? this.essentialsMap.site : null;
                return site && site.geometryEndpoints && site.geometryEndpoints.length > 0 ? site.geometryEndpoints[0].geometryServiceToken : null;
            };
            MapService._wmsExtended = false;
            return MapService;
        }(essentials.AsyncInitializable));
        essentials.MapService = MapService;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/arcgis-js-api.d.ts" />
/// <reference path="MapService.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents an ArcGIS feature layer. The properties in this class represent the configuration served from the Essentials REST API.
         */
        var FeatureLayerService = (function (_super) {
            __extends(FeatureLayerService, _super);
            /**
             * Initializes a new instance of the {@link FeatureLayerService} class.
             * @param url The URL of the service.
             */
            function FeatureLayerService(url) {
                _super.call(this, url);
                /** The color that regular graphics are drawn with for this service. Represented by an array of RGB values, in that order, each in 0-255 .*/
                this.color = [255, 0, 0];
                /** The color that selected graphics are drawn with for this service. Represented by an array of RGB values, in that order, each in 0-255. */
                this.selectionColor = [0, 255, 255];
                /**
                 * Whether or not to disable caching of the FeatureLayerService on the client.
                 * @note not used currently in esri JS API, so ignored.
                 * @deprecated 2.0
                 */
                this.disableClientCaching = false;
                /**
                 * The size of the client cache
                 * Note not used currently in esri JS API, so ignored.
                 * @deprecated 2.0
                 */
                this.onDemandCacheSize = 1000;
                /** The outFields configuration parameter */
                this.outFields = "";
                /**
                 * Represents an esri.layers.FeatureLayer MODE type. One of:
                 * - esri.layers.FeatureLayer.MODE_SNAPSHOT
                 * - esri.layers.FeatureLayer.MODE_ONDEMAND
                 * - esri.layers.FeatureLayer.MODE_SELECTION
                 */
                this.queryMode = esri.layers.FeatureLayer.MODE_ONDEMAND;
                /**
                 * The size of the virtual tiles used in on-demand mode
                 * @note This option is only valid in on-demand mode and must be a square.
                 */
                this.tileHeight = null;
                /**
                 * The size of the virtual tiles used in on-demand mode
                 * @note This option is only valid in on-demand mode and must be a square.
                 */
                this.tileWidth = null;
                /** The {@link esri.layers.FeatureLayer} WHERE clause expression. */
                this.where = null;
                /** Whether or not the {@link FeatureLayerService} is editable and supports feature updates. */
                this.canUpdate = null;
                /** Whether or not the {@link FeatureLayerService} is editable and supports feature additions. */
                this.canAdd = null;
                /** Whether or not the {@link FeatureLayerService} is editable and supports feature deletions. */
                this.canDelete = null;
                /** Whether or not the {@link FeatureLayerService} is editable.*/
                this.canEdit = null;
                /** Whether or not the {@link geocortex.essentials.FeatureLayerService} can add attachments to features. */
                this.canAddAttachments = null;
                /** Whether or not the features geometry can be edited and moved on the map. */
                this.moveEnabled = null;
                /** Whether the features geometry can rotated or not. */
                this.rotateEnabled = null;
                /** Are the vertices of the geometry of the features in this feature layer are editable. */
                this.editVerticesEnabled = null;
                /** Can the geometry of the features in this feature layer can be scaled. */
                this.scaleEnabled = null;
                /** The renderer as defined by the Site. */
                this.renderer = null;
                /** @private */
                this._colorSet = false;
                /** @private */
                this._initialFeatureCollection = null;
                /** @private */
                this._serviceLayer = null;
                this.serviceUrl = url;
            }
            /**
             * Gets an empty feature collection that can be used when creating new FeatureLayer from a feature collection.
             * It contains the layer definition of this Feature Layer but no actual features.
             * @return {featureCollectionObject} An empty Feature Collection object.
             */
            FeatureLayerService.prototype.getEmptyFeatureCollection = function () {
                return JSON.parse(this._initialFeatureCollection);
            };
            /**
             * Restore the FeatureLayer (service layer) that was created from the Site configuration.
             */
            FeatureLayerService.prototype.restoreFeatureLayer = function () {
                // The private _mode variable can be null (an Esri bug) after a layer has been removed from the map, so we need to fix that
                if (!this._serviceLayer._mode) {
                    switch (this._serviceLayer.mode) {
                        case esri.layers.FeatureLayer.MODE_SNAPSHOT:
                            this._serviceLayer._mode = new esri.layers._SnapshotMode(this._serviceLayer);
                            break;
                        case esri.layers.FeatureLayer.MODE_ONDEMAND:
                            this._serviceLayer._mode = new esri.layers._OnDemandMode(this._serviceLayer);
                            break;
                        case esri.layers.FeatureLayer.MODE_SELECTION:
                            this._serviceLayer._mode = new esri.layers._SelectionMode(this._serviceLayer);
                            break;
                    }
                }
                this.replaceFeatureLayer(this._serviceLayer, true, true, true);
                // At 3.1, ESRI changed something and the layers that have been added to the map don't have their event
                // handlers attached properly. By calling resume, the handlers get re-attached correctly. GVH-1343
                this.serviceLayer.resume();
                // The first time coming from offline, layers in snapshot mode will think they already have
                // all their graphics, but they don't.
                if (this.serviceLayer.mode === esri.layers.FeatureLayer.MODE_SNAPSHOT && this.serviceLayer.graphics.length === 0) {
                    this.serviceLayer.refresh();
                }
            };
            /**
             * Replace the FeatureLayer (service layer) currently associated with this FeatureLayerService with a new one.
             * @param featureLayer The layer to use for the replacement.
             * @param maintainVisibility Indicate that we should maintain the same visibility setting for the new feature layer as the one being replaced.
             * @param maintainOpacity Indicate that we should maintain the same opacity setting for the new feature layer as the one being replaced.
             * @param maintainRenderer Indicate that we should maintain the same renderer for the new feature layer as the one being replaced.
             */
            FeatureLayerService.prototype.replaceFeatureLayer = function (featureLayer, maintainVisibility, maintainOpacity, maintainRenderer) {
                var replacedLayer = this.serviceLayer;
                if (!featureLayer) {
                    throw new Error("featureLayer cannot be null in order to replace the feature layer.");
                }
                var map = this._getEsriMap();
                if (!map) {
                    throw new Error("Unable to get access to the Esri map object to perform the Feature Layer replace.");
                }
                if (!this.serviceLayer) {
                    throw new Error("ServiceLayer not present. Can't replace the the FeatureLayer");
                }
                // Check if the visibility of the new feature layer should match the visibility of the existing one.
                if (maintainVisibility) {
                    featureLayer.visible = replacedLayer.visible;
                    // If we want to maintain visibility, we need to respect the layers scale ranges
                    featureLayer.setMaxScale(replacedLayer.maxScale);
                    featureLayer.setMinScale(replacedLayer.minScale);
                }
                // Check if the opacity of the new feature layer should match the opacity of the existing one.
                if (maintainOpacity) {
                    featureLayer.opacity = replacedLayer.opacity;
                }
                // Check if the opacity of the new feature layer should match the renderer of the existing one.
                if (maintainRenderer) {
                    featureLayer.setRenderer(replacedLayer.renderer);
                }
                // Find the current position of the Feature Layer
                var pos = dojo.indexOf(map.graphicsLayerIds, replacedLayer.id);
                // Update the service layer to the new one
                this.serviceLayer = featureLayer;
                // Let's suspend the layer that is about to be replaced
                // At 3.1, ESRI changed something and the layers that have been added to the map don't have their event
                // handlers attached properly. So it's important to suspend a layer when removing from the map, 
                // so that if it is re-added to the map later, the events can be fixed with resume. GVH-1343
                replacedLayer.suspend();
                // Remove exiting layer from the map
                map.removeLayer(replacedLayer);
                map.addLayer(featureLayer, pos);
                // If the layer is not the online one, then clear the features from it
                if (!replacedLayer.url) {
                    this._cleanUpLayer(replacedLayer);
                }
            };
            /** @private */
            FeatureLayerService.prototype._cleanUpLayer = function (layer) {
                layer.clear();
                if (layer._essentialsMetadata) {
                    var eventHandlers = layer._essentialsMetadata.eventHandlers;
                    var i = 0;
                    // Disconnect all the event handlers that have been registered with the layer
                    for (i = 0; i < eventHandlers.length; i++) {
                        dojo.disconnect(eventHandlers[i]);
                    }
                }
            };
            /**
             * Returns a count of the number of features that satisfy the input query.
             * Valid only for layers published using ArcGIS Server 10 SP1 or greater.
             * Layers published with earlier versions of ArcGIS Server return an error to the error callback.
             *
             * The query object has the following restrictions to avoid conflicts between layer and map properties:
             *  - outFields specified by the query object are overridden by the outFields specified in the FeatureLayer constructor.
             *  - The returnGeometry value specified by the query object is ignored and true is used.
             *  - The outSpatialReference set by the query object is ignored and the map's spatial reference is used.
             *
             * @param query The input query.
             * @param callbackResults The success callback to invoke when the query has completed successfully.
             * @param callbackErrors An error callback to invoke when an error occurs.
             */
            FeatureLayerService.prototype.queryCount = function (query, callbackResults, callbackErrors) {
                if (this.isServiceLayerLoaded && this.serviceLayer) {
                    function queryCountCallback(results) {
                        if (callbackResults) {
                            callbackResults(results);
                        }
                    }
                    ;
                    function queryCountErrorCallback(error) {
                        if (callbackErrors) {
                            callbackErrors(error);
                        }
                    }
                    ;
                    // Call the feature layer build in query mechanism
                    this.serviceLayer.queryCount(query, queryCountCallback, queryCountErrorCallback);
                }
            };
            /**
             * Queries features from the feature layer. Layer definition and time definition are honored.
             * Whenever possible the feature layer will perform the query on the client.
             *
             * The query object has the following restrictions to avoid conflicts between layer and map properties:
             *  - outFields specified by the query object are overridden by the outFields specified in the FeatureLayer constructor.
             *  - The returnGeometry value specified by the query object is ignored and true is used.
             *  - The outSpatialReference set by the query object is ignored and the map's spatial reference is used.
             *
             * @param query The input query.
             * @param callbackResults The success callback to invoke when the query has completed successfully.
             * @param callbackErrors An error callback to invoke when an error occurs.
             */
            FeatureLayerService.prototype.queryFeatures = function (query, callbackResults, callbackErrors) {
                if (this.isServiceLayerLoaded && this.serviceLayer) {
                    return this.serviceLayer.queryFeatures(query, callbackResults, callbackErrors);
                }
                else {
                    var error = new Error("Esri layer has not finished loading");
                    if (callbackErrors) {
                        callbackErrors(error);
                        return null;
                    }
                    else {
                        var def = new dojo.Deferred();
                        def.reject(error);
                        return def;
                    }
                }
            };
            /**
             * Queries for OBJECTIDs. There is no limit on the number of OBJECTIDs that are returned from the server.
             * Like queryFeatures this operation will perform queries on the client whenever possible.
             * Valid only for layers published using ArcGIS Server 10 SP1 or greater.
             *
              * The query object has the following restrictions to avoid conflicts between layer and map properties:
             *  - outFields specified by the query object are overridden by the outFields specified in the FeatureLayer constructor.
             *  - The returnGeometry value specified by the query object is ignored and true is used.
             *  - The outSpatialReference set by the query object is ignored and the map's spatial reference is used.
             *
             * @param query The input query.
             * @param callbackResults The success callback to invoke when the query has completed successfully.
             * @param callbackErrors An error callback to invoke when an error occurs.
             */
            FeatureLayerService.prototype.queryIds = function (query, callbackResults, callbackErrors) {
                if (this.isServiceLayerLoaded && this.serviceLayer) {
                    return this.serviceLayer.queryIds(query, callbackResults, callbackErrors);
                }
                else if (callbackErrors) {
                    var error = new Error("Esri layer has not finished loading");
                    callbackErrors(error);
                    var def = new dojo.Deferred();
                    def.reject(error);
                    return def;
                }
            };
            /**
             * Queries related features or records from another layer or table.
             * @param query The input query.
             * @param callbackResults The success callback to invoke when the query has completed successfully.
             * @param callbackErrors An error callback to invoke when an error occurs.
             */
            FeatureLayerService.prototype.queryRelatedFeatures = function (query, callbackResults, callbackErrors) {
                if (this.isServiceLayerLoaded && this.serviceLayer) {
                    return this.serviceLayer.queryRelatedFeatures(query, callbackResults, callbackErrors);
                }
                else if (callbackErrors) {
                    var error = new Error("Esri layer has not finished loading");
                    callbackErrors(error);
                    var def = new dojo.Deferred();
                    def.reject(error);
                    return def;
                }
            };
            /** @private */
            FeatureLayerService.prototype._getEsriMap = function () {
                var map = null;
                if ((this.essentialsMap !== null) && (this.essentialsMap.site !== null)) {
                    map = this.essentialsMap.site.getMap();
                }
                return map;
            };
            /** @private */
            FeatureLayerService.prototype._configureObject = function (obj, deepInitialize) {
                if (obj === undefined || obj.outFields === undefined || obj.queryMode === undefined || obj.where === undefined) {
                    throw new Error("Incorrect map service object returned from initialization");
                }
                this.disableClientCaching = !!obj.disableClientCaching;
                this.onDemandCacheSize = obj.onDemandCacheSize === undefined || obj.onDemandCacheSize === null ? this.onDemandCacheSize : obj.onDemandCacheSize;
                // Configure the additional properties of the feature layer service
                if (!obj.outFields) {
                    obj.outFields = "*";
                }
                this.outFields = obj.outFields;
                this.where = obj.where;
                if (obj.queryMode === undefined) {
                    this.queryMode = esri.layers.FeatureLayer.MODE_ONDEMAND;
                }
                else {
                    switch (obj.queryMode) {
                        case "Selection":
                        case "SelectionOnly":
                            this.queryMode = esri.layers.FeatureLayer.MODE_SELECTION;
                            break;
                        case "Snapshot":
                            this.queryMode = esri.layers.FeatureLayer.MODE_SNAPSHOT;
                            break;
                        default:
                            this.queryMode = esri.layers.FeatureLayer.MODE_ONDEMAND;
                    }
                }
                if (obj.tileHeight) {
                    this.tileHeight = obj.tileHeight;
                }
                if (obj.tileWidth) {
                    this.tileWidth = obj.tileWidth;
                }
                if (obj.selectionColor) {
                    this.selectionColor = obj.selectionColor;
                }
                if (obj.color) {
                    this.color = obj.color;
                    this._colorSet = true;
                    // Essentials provides the color's alpha value as a number between 0 and 255 (inclusive),
                    // but the constructor for dojo.Color expects a number between 0 and 1 (inclusive).
                    if (this.color.length > 3) {
                        this.color[3] = this.color[3] / 255;
                    }
                }
                // Initialize the feature geometry editing properties for this feature layer.
                // By default, keep these values true as these properties are only supported in Essentials 3.16 +
                this.editVerticesEnabled = obj.hasOwnProperty("editVerticesEnabled") ? obj.editVerticesEnabled : true;
                this.moveEnabled = obj.hasOwnProperty("moveEnabled") ? obj.moveEnabled : true;
                this.scaleEnabled = obj.hasOwnProperty("scaleEnabled") ? obj.scaleEnabled : true;
                this.rotateEnabled = obj.hasOwnProperty("rotateEnabled") ? obj.rotateEnabled : true;
                // Renderer
                if (obj.renderer) {
                    try {
                        this.renderer = esri.renderer.fromJson(obj.renderer);
                    }
                    catch (error) {
                    }
                }
                _super.prototype._configureObject.call(this, obj, deepInitialize);
            };
            /** @private */
            FeatureLayerService.prototype._updateServiceToken = function (token) {
                _super.prototype._updateServiceToken.call(this, token);
                if (this.serviceLayer) {
                    var _task = this.serviceLayer._task; // _task is private, this is definitely not safe
                    if (_task && _task._url && _task._url.query) {
                        _task._url.query.token = token;
                    }
                }
            };
            /** @private */
            FeatureLayerService.prototype._createServiceLayer = function () {
                _super.prototype._createServiceLayer.call(this);
                // Check if a secure token needs to be added to the url
                var url = this.serviceUrl;
                if (this.serviceToken !== null) {
                    url = url + "?token=" + encodeURIComponent(this.serviceToken);
                }
                var initArgs = {};
                initArgs.id = this.id;
                initArgs.opacity = this.configuredOpacity;
                initArgs.visible = this._computeInitServiceLayerVisibility();
                if (this.outFields && this.outFields.length > 0) {
                    initArgs.outFields = this.outFields.split(",");
                }
                if (this.queryMode !== null) {
                    initArgs.mode = this.queryMode;
                }
                if (this.tileHeight !== null && this.tileWidth !== null &&
                    this.queryMode == esri.layers.FeatureLayer.MODE_ONDEMAND) {
                    initArgs.tileHeight = this.tileHeight;
                    initArgs.tileWidth = this.tileWidth;
                }
                this.serviceLayer = new esri.layers.FeatureLayer(url, initArgs);
                this.serviceLayer.setRenderer(this.renderer);
                if (this.attributionDataUrl && this.attributionDataUrl !== "") {
                    this.serviceLayer.attributionDataUrl = this.attributionDataUrl;
                    this.serviceLayer.hasAttributionData = true;
                }
                else if (this.hasAttributionData) {
                    this.serviceLayer.attributionDataUrl = this.url + "/Attribution";
                    this.serviceLayer.hasAttributionData = true;
                }
                // Save a copy of the service layer as configured by the site
                this._serviceLayer = this.serviceLayer;
                if (this.where) {
                    this.serviceLayer.setDefinitionExpression(this.where);
                }
                dojo.connect(this.serviceLayer, "onError", this, this._layerLoadErrorHandler);
                // See GVH-2287.
                if (this.serviceLayer.loaded) {
                    this._handleLayerLoadEvent(this.serviceLayer);
                }
                else {
                    dojo.connect(this.serviceLayer, "onLoad", dojo.hitch(this, this._handleLayerLoadEvent));
                }
                _super.prototype.initiateServiceFailureTimer.call(this);
            };
            /**
             * GVH-6928: Computes the initial visibility to apply to the service layer we're creating. A feature service will always be set to visible as per recent changes to Essentials to support
             * the new configurable layer list. Its the single feature layer within the feature service that will determine the visibility of the created service layer.
             */
            FeatureLayerService.prototype._computeInitServiceLayerVisibility = function () {
                var initServiceLayerVisibility = this._initiallyVisible;
                if (initServiceLayerVisibility && this.layers && this.layers.length === 1) {
                    initServiceLayerVisibility = this.layers[0].isVisible();
                }
                return initServiceLayerVisibility;
            };
            /**
             * Handles a layer onLoad event - whether or not this was satisfied from the IE cache. See GVH-2287.
             * @private
             */
            FeatureLayerService.prototype._handleLayerLoadEvent = function (layer) {
                if (this.serviceLayer.version < 10 || this._colorSet) {
                    var symbol = null;
                    if (this.serviceLayer.geometryType == "esriGeometryPoint") {
                        symbol = new esri.symbol.SimpleMarkerSymbol(esri.symbol.SimpleMarkerSymbol.STYLE_CIRCLE, 15, null, new esri.Color(this.selectionColor));
                        var markerSymbol = new esri.symbol.SimpleMarkerSymbol(esri.symbol.SimpleMarkerSymbol.STYLE_CIRCLE, 15, null, new esri.Color(this.color));
                        var markerRenderer = new esri.renderer.SimpleRenderer(markerSymbol);
                        this.serviceLayer.setRenderer(markerRenderer);
                    }
                    else if (this.serviceLayer.geometryType == "esriGeometryPolyline") {
                        symbol = new esri.symbol.SimpleLineSymbol(esri.symbol.SimpleLineSymbol.STYLE_SOLID, new esri.Color(this.selectionColor), 1);
                        var lineSymbol = new esri.symbol.SimpleLineSymbol(esri.symbol.SimpleLineSymbol.STYLE_SOLID, new esri.Color(this.color), 1);
                        var lineRenderer = new esri.renderer.SimpleRenderer(lineSymbol);
                        this.serviceLayer.setRenderer(lineRenderer);
                    }
                    else if (this.serviceLayer.geometryType == "esriGeometryPolygon") {
                        symbol = new esri.symbol.SimpleFillSymbol(esri.symbol.SimpleFillSymbol.STYLE_SOLID, new esri.symbol.SimpleLineSymbol(esri.symbol.SimpleLineSymbol.STYLE_SOLID, new esri.Color([0, 0, 0]), 1), new esri.Color(this.selectionColor));
                        var fillSymbol = new esri.symbol.SimpleFillSymbol(esri.symbol.SimpleFillSymbol.STYLE_SOLID, new esri.symbol.SimpleLineSymbol(esri.symbol.SimpleLineSymbol.STYLE_SOLID, new esri.Color([0, 0, 0]), 1), new esri.Color(this.color));
                        var fillRenderer = new esri.renderer.SimpleRenderer(fillSymbol);
                        this.serviceLayer.setRenderer(fillRenderer);
                    }
                    this.serviceLayer.setSelectionSymbol(symbol);
                }
                var capabilities = this.serviceLayer.getEditCapabilities();
                this.canUpdate = capabilities.canUpdate;
                this.canAdd = capabilities.canCreate;
                this.canDelete = capabilities.canDelete;
                this.canEdit = this.serviceLayer.isEditable();
                // Initialize canAddAttachments to false by default
                this.canAddAttachments = false;
                // GVH-10903 we don't support adding attachments in ArcGIS Server 10.0, version check added in place of checking "uploads" flag
                if (this.serviceLayer.capabilities) {
                    this.canAddAttachments = (this.serviceLayer.version && this.serviceLayer.version >= 10.1) && this.serviceLayer.hasAttachments && this.canEdit;
                }
                // Get the initial FeatureCollection object before any actual feature is requested
                this._initialFeatureCollection = JSON.stringify(this.serviceLayer.toJson());
                this._handleServiceLayerLoaded(layer);
            };
            /**
             * Indicates whether the feature layer has relationships in which it is the origin.
             * This will always be false for layer coming from a server prior to 10.1.
             */
            FeatureLayerService.prototype.hasOriginRelationships = function () {
                if (this.serviceLayer && this.serviceLayer.version >= 10.1 && this.serviceLayer.relationships && this.serviceLayer.relationships.length > 0) {
                    for (var i = 0; i < this.serviceLayer.relationships.length; i++) {
                        if (this.serviceLayer.relationships[i].role === "esriRelRoleOrigin") {
                            return true;
                        }
                    }
                    return false;
                }
                else {
                    // Not 10.1 or no relationships
                    return false;
                }
            };
            /**
             * Returns a Feature Layer pointing to the table referenced in the specified relationship.
             * @param relationshipId The id of the relationship.
             * @param callbackResults The success callback to invoke if the request completes successfully.
             * @param callbackErrors An error callback to invoke when an error occurs.
             */
            FeatureLayerService.prototype.getRelatedFeatureLayer = function (relationshipId, callbackResults, callbackErrors) {
                var def = new dojo.Deferred();
                var layerLoaded = function (result) {
                    geocortex.deferredResolve(def, result);
                    if (typeof (callbackResults) == "function") {
                        callbackResults(result);
                    }
                };
                var layerError = function (error) {
                    if (def && (def.fired == -1)) {
                        def.resolve(error);
                    }
                    if (typeof (callbackErrors) == "function") {
                        callbackErrors(error);
                    }
                };
                if (this.serviceLayer.version < 10.1) {
                    var error = new Error("getRelatedFeatureLayer is only available for feature layer from ArcGIS 10.1 or greater.");
                    if (def && (def.fired == -1)) {
                        def.resolve(error);
                    }
                    if (typeof (callbackErrors) == "function") {
                        callbackErrors(error);
                    }
                    return def;
                }
                var relation = this._getEsriRelation(relationshipId);
                // If the relation was not found, trigger an error
                if (!relation) {
                    var error = new Error("Relation not found: " + relationshipId);
                    if (def) {
                        def.reject(error);
                    }
                    if (typeof (callbackErrors) == "function") {
                        callbackErrors(error);
                    }
                    return def;
                }
                // The url to the relationship is the same as this feature layer's service layer url except for the layer id at the end of the url
                var url = this.serviceUrl.substring(0, this.serviceUrl.lastIndexOf("/") + 1) + relation.relatedTableId;
                if (this.serviceToken) {
                    url += url.indexOf("?") > -1
                        ? "&token="
                        : "?token=";
                    url += encodeURIComponent(this.serviceToken);
                }
                if (esri.getProxyRule(url) === undefined && this.proxyUrl !== null) {
                    esri.addProxyRule({
                        urlPrefix: url,
                        proxyUrl: this.proxyUrl
                    });
                }
                var layer = new esri.layers.FeatureLayer(url, {
                    mode: esri.layers.FeatureLayer.MODE_SELECTION,
                    outFields: ["*"]
                });
                dojo.connect(layer, "onLoad", dojo.hitch(this, layerLoaded));
                dojo.connect(layer, "onError", dojo.hitch(this, layerError));
                return def;
            };
            /**
             * @private
             * Returns an Esri Relationship objects, given a relationship ID.
             */
            FeatureLayerService.prototype._getEsriRelation = function (relationshipId) {
                if (typeof (relationshipId) == "string") {
                    relationshipId = parseInt(relationshipId); // Need a parseInt, see GE-2247
                }
                if (this.serviceLayer.relationships) {
                    for (var i = 0; i < this.serviceLayer.relationships.length; i++) {
                        if (this.serviceLayer.relationships[i].id == relationshipId) {
                            return this.serviceLayer.relationships[i];
                        }
                    }
                }
                return null;
            };
            /** @private */
            FeatureLayerService.prototype._getRelation = function (relationshipId) {
                // A feature layer service should have one layer
                if (this.layers && this.layers.length > 0) {
                    return this.layers[0]._getRelation(relationshipId);
                }
                return null;
            };
            return FeatureLayerService;
        }(essentials.MapService));
        essentials.FeatureLayerService = FeatureLayerService;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/dojo.d.ts" />
var geocortex;
(function (geocortex) {
    var workflow;
    (function (workflow) {
        var ArgumentInfo = (function () {
            function ArgumentInfo(name, typeName, isRequired, value) {
                /**
                 * The runtime type name of the {@link geocortex.workflow.ArgumentInfo}.
                 * @type String
                 */
                this.runtimeTypeName = null;
                this.name = name || null;
                this.typeName = typeName || null;
                this.isRequired = !!isRequired;
                this.value = value || null;
            }
            /** @private */
            ArgumentInfo.prototype._configureObject = function (restObject) {
                if (typeof (restObject.name) == "undefined" ||
                    typeof (restObject.typeName) == "undefined") {
                    throw new Error("Incorrect argument info object returned from initialization");
                }
                this.name = restObject.name;
                this.typeName = restObject.typeName;
                this.isRequired = restObject.isRequired;
                this.value = restObject.value;
                this.runtimeTypeName = restObject.runtimeTypeName;
            };
            /** @private */
            ArgumentInfo.prototype._internalClone = function () {
                var argument = new ArgumentInfo(this.name, this.typeName, this.isRequired, dojo.clone(this.value));
                argument.runtimeTypeName = dojo.clone(this.runtimeTypeName);
                return argument;
            };
            return ArgumentInfo;
        }());
        workflow.ArgumentInfo = ArgumentInfo;
    })(workflow = geocortex.workflow || (geocortex.workflow = {}));
})(geocortex || (geocortex = {}));
/// <reference path="ArgumentInfo.ts" />
var geocortex;
(function (geocortex) {
    var workflow;
    (function (workflow) {
        var ExternalActivityInfo = (function () {
            function ExternalActivityInfo(id, displayName, typeName, instanceId, externalId, syncToken, isComplete, inputs, outputs) {
                /**
                 * Indicates whether the activity should be debugged.
                 * @type Boolean
                 */
                this.debug = false;
                this.id = id || null;
                this.displayName = displayName || null;
                this.typeName = typeName || null;
                this.instanceId = instanceId || null;
                this.externalId = externalId || null;
                this.syncToken = syncToken || null;
                this.isComplete = isComplete || false;
                this.isAborted = false;
                this.inputs = inputs || [];
                this.outputs = outputs || [];
            }
            /** @private */
            ExternalActivityInfo.prototype._configureObject = function (restObject) {
                if (typeof (restObject.id) == "undefined" ||
                    typeof (restObject.displayName) == "undefined" ||
                    typeof (restObject.typeName) == "undefined" ||
                    typeof (restObject.instanceId) == "undefined") {
                    throw new Error("Incorrect external activity info object returned from initialization");
                }
                // Assign all the data
                this.id = restObject.id;
                this.displayName = restObject.displayName;
                this.typeName = restObject.typeName;
                this.instanceId = restObject.instanceId;
                this.externalId = restObject.externalId;
                this.syncToken = restObject.syncToken;
                this.isComplete = restObject.isComplete;
                if (restObject.debug) {
                    this.debug = restObject.debug;
                }
                this.inputs = [];
                this.outputs = [];
                var i;
                if (restObject.inputs) {
                    // Loop through the argument objects
                    for (i = 0; i < restObject.inputs.length; i++) {
                        var argumentObject = restObject.inputs[i];
                        var argument = new geocortex.workflow.ArgumentInfo();
                        argument._configureObject(argumentObject);
                        // Add the argument info to the array
                        this.inputs[i] = argument;
                    }
                }
                if (restObject.outputs) {
                    // Loop through the argument objects
                    for (i = 0; i < restObject.outputs.length; i++) {
                        var argumentObject = restObject.outputs[i];
                        var argument = new geocortex.workflow.ArgumentInfo();
                        argument._configureObject(argumentObject);
                        // Add the argument info to the array
                        this.outputs[i] = argument;
                    }
                }
            };
            return ExternalActivityInfo;
        }());
        workflow.ExternalActivityInfo = ExternalActivityInfo;
    })(workflow = geocortex.workflow || (geocortex.workflow = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../workflow/ExternalActivityInfo.ts" />
/// <reference path="../workflow/ArgumentInfo.ts" />
/// <reference path="Site.ts" />
/// <reference path="AsyncInitializable.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents a GIS workflow reference by a {@link Site}.
         */
        var Workflow = (function (_super) {
            __extends(Workflow, _super);
            /**
             * Initializes a new instance of the {@link Workflow} class.
             * @param url The URL to the REST endpoint of the {@link Workflow}.
             */
            function Workflow(url) {
                _super.call(this, url);
                /** The display name of the {@link Workflow}.  */
                this.displayName = null;
                /** The last error of the Workflow. */
                this.error = null;
                /** The extensions of the Workflow, as defined by an administrator. */
                this.extensions = [];
                /** The externalActivities of the {@link Workflow}. */
                this.externalActivities = {};
                /** The ID of the {@link Workflow}. */
                this.id = null;
                /**
                 * The properties of the Workflow, as defined by an administrator. */
                this.properties = {};
                /** The {@link Site} that the {@link Workflow} belongs to. */
                this.site = null;
                /** @private */
                this._inputs = [];
                /** @private */
                this._outputs = [];
            }
            /**
             * Return an array of ArgumentInfo that represents the inputs that can be populated with values and provided to the startWorkflow method of
             * {@link workflow.WorkflowControllerProxy}.
             */
            Workflow.prototype.getInputs = function () {
                return this._cloneArgumentInfoCollection(this._inputs);
            };
            /**
             * Return an array of {@link workflow.ArgumentInfo} that represents the
             * metadata about the outputs that will be returned when the workflow has completed. It does
             * not contain actual running values. The real outputs will be provided by the workflowComplete
             * method of any class implementing the {@link workflow.ActivityDispatcher}
             * interface such as the {@link workflow.SimpleActivityDispatcher}.
             */
            Workflow.prototype.getOutputsMetadata = function () {
                return this._cloneArgumentInfoCollection(this._outputs);
            };
            /** @private */
            Workflow.prototype._cloneArgumentInfoCollection = function (collection) {
                var result = null;
                if (collection !== null) {
                    result = [];
                    for (var i = 0; i < collection.length; i++) {
                        result.push(collection[i]._internalClone());
                    }
                }
                return result;
            };
            /** @private */
            Workflow.prototype._configureObject = function (restObject, deepInitialize) {
                if (restObject.id === undefined || restObject.displayName === undefined) {
                    throw new Error("Incorrect workflow object returned from initialization");
                }
                var argumentObject, argument;
                // Assign all the data
                this.id = restObject.id;
                this.displayName = restObject.displayName;
                this.runOnStartup = !!restObject.runOnStartup;
                this.error = restObject.error;
                this._inputs = [];
                this._outputs = [];
                this.externalActivities = [];
                // Loop through the input argument objects
                if (restObject.inputs) {
                    for (var i = 0; i < restObject.inputs.length; i++) {
                        argumentObject = restObject.inputs[i];
                        argument = new geocortex.workflow.ArgumentInfo();
                        argument._configureObject(argumentObject);
                        // Add the argument info to the array
                        this._inputs[i] = argument;
                    }
                }
                // Loop through the output argument objects
                if (restObject.outputs) {
                    for (i = 0; i < restObject.outputs.length; i++) {
                        argumentObject = restObject.outputs[i];
                        argument = new geocortex.workflow.ArgumentInfo();
                        argument._configureObject(argumentObject);
                        // Add the argument info to the array
                        this._outputs[i] = argument;
                    }
                }
                // Loop through the external activity objects
                if (restObject.externalActivities) {
                    for (i = 0; i < restObject.externalActivities.length; i++) {
                        var activityObject = restObject.externalActivities[i];
                        var activity = new geocortex.workflow.ExternalActivityInfo();
                        activity._configureObject(activityObject);
                        // Add the activity info to the array
                        this.externalActivities[i] = activity;
                    }
                }
                // add the properties
                this.properties = geocortex._getProperties(restObject.properties);
                // add the extensions
                this.extensions = geocortex._getExtensions(restObject.extensions);
            };
            return Workflow;
        }(essentials.AsyncInitializable));
        essentials.Workflow = Workflow;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../essentials.ts" />
/// <reference path="RestHelper.ts" />
/// <reference path="Site.ts" />
/// <reference path="Extension.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents a Web Map, as referenced by a {@link Site}.
         */
        var WebMapReference = (function (_super) {
            __extends(WebMapReference, _super);
            /**
             * Initializes a new instance of the {@link WebMapReference} class.
             * @param url The URL to the REST endpoint of the {@link WebMapReference}.
             */
            function WebMapReference(url) {
                _super.call(this, url);
                /** The display name of the {@link WebMapReference}. */
                this.displayName = null;
                /** The ID of the {@link WebMapReference}.*/
                this.id = null;
                /** @private */
                this._isLoading = false;
                /** @private */
                this._onLoadingComplete = null;
                /** @private */
                this._onLoadingError = null;
                /** @private */
                this._layerTypes = null;
                /** @private */
                this._arcgisSharingRegularExpressions = [
                    new RegExp("(https?://.*?/)home/item.html\\?id=(\\w*)"),
                    new RegExp("(https?://.*?/)home\/webmap\/viewer.html\\?webmap=(\\w*)"),
                    new RegExp("(https?://.*?/)explorer/\\?open=(\\w*)"),
                    new RegExp("(https?://.*?/sharing)/content/items/(\\w*)/data"),
                    new RegExp("(https?://.*?/sharing)/content/items/(\\w*)")
                ];
                /** The {@link Site} that the {@link WebMapReference} belongs to. */
                this.site = null;
            }
            /**
             Gets whether the {@link DataLink} is currently performing data linking. */
            WebMapReference.prototype.isLoading = function () {
                return this._isLoading;
            };
            /** @private */
            WebMapReference.prototype._getUrlPortions = function (url) {
                var result = {
                    id: null,
                    path: null
                };
                for (var i = 0; i < this._arcgisSharingRegularExpressions.length; ++i) {
                    var pattern = this._arcgisSharingRegularExpressions[i];
                    var item = url.match(pattern);
                    if (item && item.length > 0) {
                        result.id = item[2];
                        result.path = item[1];
                        break;
                    }
                }
                return result;
            };
            /** @private */
            WebMapReference.prototype._loadWebMap = function (urlPortions, webMapObjectUrl, progressing) {
                var _this = this;
                if (!urlPortions || !urlPortions.path) {
                    var errorMessage = "Web map with address " + webMapObjectUrl + " cannot be loaded.";
                    // Get the web map id from the url
                    var urlObject = esri.urlToObject(webMapObjectUrl);
                    urlObject.query = urlObject.query || {};
                    if (!urlObject.query || !(urlObject.query.webmap || urlObject.query.id)) {
                        this._onLoadingError(new Error(errorMessage));
                        progressing.resolve(false);
                    }
                    else {
                        var webMapId = urlObject.query.webmap || urlObject.query.id;
                        var getItem;
                        if (esri.arcgis && esri.arcgis.utils) {
                            getItem = esri.arcgis.utils.getItem; // 3.7 & 3.9
                        }
                        else if (esri.arcgis.getItem) {
                            getItem = esri.arcgis.getItem; // 3.8
                        }
                        if (getItem) {
                            getItem(webMapId).then(function (response) {
                                if (response) {
                                    this._processItemData(response.itemData);
                                }
                                else {
                                    this._onLoadingError(new Error(errorMessage));
                                }
                                progressing.resolve(false);
                            });
                        }
                    }
                }
                else {
                    if (!esri.arcgis || !esri.arcgis.Portal) {
                        return;
                    }
                    var portal = new esri.arcgis.Portal(urlPortions.path);
                    portal.on("ready", function (agsPortal) {
                        if (!agsPortal) {
                            return;
                        }
                        var params = {
                            q: "id:" + urlPortions.id
                        };
                        agsPortal.queryItems(params)
                            .then(function (resultItem) {
                            if (!resultItem) {
                                return;
                            }
                            var result = resultItem.results[0];
                            var request = esri.request({
                                url: result.itemDataUrl
                            });
                            request.then(function (itemData) {
                                _this._processItemData(itemData);
                                progressing.resolve(false);
                            });
                        });
                    });
                }
            };
            /**
             * Loads a Web Map using a feature set containing the attributes required during the operation. This is an asynchronous method; you may provide delegates for completion or error information.
             * @param webMapObject The web map object.
             * @param loadComplete The delegate that will be called when the operation has completed, even if an error occurs. This delegate expects one argument: an Object containing the result.
             * @param loadError The delegate that will be called if an error occurs during the operation. This delegate expects two arguments: a reference to the WebMapReference instance, and an Error.
             */
            WebMapReference.prototype._initializeWebMap = function (webMapObject, site, loadComplete, loadError) {
                var self = this;
                // Check if we're already loading the web map.
                if (this.isLoading()) {
                    if (loadError) {
                        loadError(new Error("Currently loading web map."));
                    }
                    return;
                }
                this._isLoading = true;
                var progressing = new dojo.Deferred();
                this._onLoadingComplete = dojo.hitch(this, loadComplete);
                this._onLoadingError = dojo.hitch(this, loadError);
                this._layerTypes = this.site.webMapsInfo.layerTypes;
                var urlPortions = this._getUrlPortions(webMapObject.url);
                this._loadWebMap(urlPortions, webMapObject.url, progressing);
                progressing.then(function (progress) {
                    self._isLoading = progress;
                });
            };
            /** @private */
            WebMapReference.prototype._processItemData = function (itemData) {
                if (itemData) {
                    var operationalLayers = itemData.operationalLayers;
                    if (operationalLayers) {
                        this._processLayerCollection(operationalLayers, "Operational");
                    }
                    var baseLayers = itemData.baseMap.baseMapLayers;
                    if (baseLayers) {
                        this._processLayerCollection(baseLayers, "Base");
                    }
                }
            };
            /** @private */
            WebMapReference.prototype._processLayerCollection = function (layerCollection, serviceFunction) {
                var _this = this;
                if (!layerCollection) {
                    return;
                }
                var serviceLayers = [];
                for (var i = 0; i < layerCollection.length; ++i) {
                    var layer = layerCollection[i];
                    if (this._layerTypes) {
                        // If the layer type is supported in site we won't add it here.
                        if ((!layer.type && this._layerTypes.indexOf("Null") >= 0) ||
                            (layer.type && this._layerTypes.indexOf(layer.type) >= 0)) {
                            continue;
                        }
                    }
                    var dfr = this._addLayerToMap(layer);
                    serviceLayers.push(dfr);
                }
                var deferredList = new dojo.DeferredList(serviceLayers);
                deferredList.then(function (results) {
                    if (results) {
                        var layers = [];
                        for (var i = 0; i < results.length; ++i) {
                            var resultLayers = results[i][1];
                            if (!resultLayers) {
                                continue;
                            }
                            if (resultLayers.length > 0) {
                                layers = layers.concat(resultLayers);
                            }
                            else {
                                layers.push(resultLayers);
                            }
                        }
                        if (layers.length > 0) {
                            _this.site.essentialsMap.addServiceLayers(layers, serviceFunction);
                        }
                    }
                }, function (error) {
                    _this._onLoadingError(new Error("There was an error loading a layer: " + error));
                });
            };
            /** @private */
            WebMapReference.prototype._addLayerToMap = function (layer) {
                var self = this;
                // If you are enhancing this function to define new Web map types, make sure that you resolve all the layers you are creating.
                // If you leave a layer type unresolved, none of the layers will be processed and that is the nature of dojo.DeferredList.
                // dojo.DeferredList will be obsolete in future dojo releases and will be replaced with dojo.promise.all.
                var serviceLayers = new dojo.Deferred();
                var webMapLayer = null;
                var esriMap = this.site.getMap();
                switch (layer.type) {
                    case "CSV":
                        var frameUrl = new dojo._Url(window.location.href);
                        var csvUrl = new dojo._Url(layer.url);
                        if (frameUrl.host !== csvUrl.host || frameUrl.port !== csvUrl.port || frameUrl.scheme !== csvUrl.scheme) {
                            layer.url = esri.config.defaults.io.proxyUrl + layer.url;
                        }
                        // TODO: There is a limit (1000 features) which is enforced by ESRI's web map viewers. We should probably need to have something configured for that.                        
                        var featureLayer = geocortex.essentials.utilities.LayerUtilities.createFeatureLayerFromCsv(layer, null);
                        featureLayer.then(function (csvLayer) {
                            if (csvLayer && csvLayer.setVisibility) {
                                csvLayer.setVisibility(layer.visibility);
                            }
                            serviceLayers.resolve(csvLayer);
                        }, function (err) {
                            serviceLayers.reject(err);
                        });
                        break;
                    case "GeoRSS":
                        var geoRssService = new essentials.GeoRssLayerService(layer.url);
                        geoRssService.essentialsMap = this.site.essentialsMap;
                        var configObject = {
                            displayName: layer.title,
                            serviceType: geocortex.essentials.MapServiceType.GEORSS,
                            connectionString: "url=" + layer.url,
                            feedImageUri: layer.pointSymbol ? layer.pointSymbol.url : null,
                            opacity: layer.opacity,
                            id: layer.id || geocortex.framework.utils.alphaNumericToken(),
                            visible: layer.visibility
                        };
                        geoRssService._configureObject(configObject);
                        serviceLayers.resolve(geoRssService);
                        break;
                    case "WebTiledLayer":
                        if (!layer.wmtsInfo) {
                            if (esri.layers && esri.layers.WebTiledLayer) {
                                var layerOptions = {
                                    "id": layer.id,
                                    "subDomains": layer.subDomains,
                                    "copyright": layer.copyright
                                };
                                webMapLayer = new esri.layers.WebTiledLayer(layer.templateUrl, layerOptions);
                                if (layer.title) {
                                    webMapLayer.name = layer.title;
                                }
                            }
                        }
                        serviceLayers.resolve(webMapLayer);
                        break;
                    case "WMS":
                        serviceLayers.resolve(null);
                        break;
                    default:
                        var nullTypeLayers = null;
                        if (layer.url) {
                        }
                        else {
                            // All the layers that are added as a file to web map will be processed here.
                            if (layer.featureCollection) {
                                nullTypeLayers = this._addFeatureCollectionToMap(layer.featureCollection);
                            }
                        }
                        serviceLayers.resolve(nullTypeLayers);
                        break;
                }
                return serviceLayers.promise;
            };
            /** @private */
            WebMapReference.prototype._addFeatureCollectionToMap = function (featureCollection) {
                var self = this;
                var esriMap = this.site.getMap();
                var serviceLayers = [];
                dojo.forEach(featureCollection.layers, function (layer) {
                    var featureLayer = new esri.layers.FeatureLayer(layer, {
                        "outSR": esriMap.spatialReference
                    });
                    featureLayer.layerId = geocortex.framework.utils.alphaNumericToken();
                    serviceLayers.push(featureLayer);
                });
                return serviceLayers;
            };
            /** @private */
            WebMapReference.prototype._loadingRestComplete = function (result) {
                this._isLoading = false;
                if (!result && this._onLoadingError) {
                    this._onLoadingError(new Error("No results"));
                }
                if (result.error && this._onLoadingError) {
                    this._onLoadingError(result.error);
                }
                if (this._onLoadingComplete) {
                    this._onLoadingComplete(result.results);
                }
            };
            /** @private */
            WebMapReference.prototype._loadingRestError = function (er) {
                this._isLoading = false;
                if (this._onLoadingError) {
                    this._onLoadingError(er);
                }
            };
            /**
             * Configures the web map reference.
             * @param obj The web map reference object.
             * @private
             */
            WebMapReference.prototype._configureObject = function (obj, deepInitialize) {
                if (obj === undefined || obj.id === undefined) {
                    throw new Error("Incorrect Web Map reference object returned from initialization");
                }
                // Assign all the data
                this.displayName = obj.displayName;
                this.id = obj.id;
                if (deepInitialize) {
                    this.isInitialized = true;
                }
                this._initializeWebMap(obj, this.site, function (s) { }, function (e) {
                    throw e;
                });
            };
            return WebMapReference;
        }(essentials.AsyncInitializable));
        essentials.WebMapReference = WebMapReference;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * A simple descriptor representing a {@link MapGrid}.
         * A {@link MapGrid} is a series of vertical and horizontal lines with coordinate labels overlayed on top of a map, so that you can interpolate
         * coordinates for a particular point.
         */
        var MapGrid = (function () {
            function MapGrid() {
            }
            return MapGrid;
        }());
        essentials.MapGrid = MapGrid;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * An object that represents a unit of distance.
         */
        var DistanceUnit = (function () {
            /**
             * Initializes a new instance of the {@link DistanceUnit} class.
             * @param name The display name of the {@link DistanceUnit}.
             * @param type A string constant representing the official unit type. See {@link DistanceUnitType} for a list of supported units.
             */
            function DistanceUnit(name, type) {
                this.name = name;
                this.type = type;
            }
            return DistanceUnit;
        }());
        essentials.DistanceUnit = DistanceUnit;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/**
 * Contains a number of distance unit values.
 */
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var DistanceUnitType;
        (function (DistanceUnitType) {
            DistanceUnitType.OTHER = "Other";
            DistanceUnitType.INCHES = "Inches";
            DistanceUnitType.FEET = "Feet";
            DistanceUnitType.US_SURVEY_FEET = "USSurveyFeet";
            DistanceUnitType.YARDS = "Yards";
            DistanceUnitType.MILES = "Miles";
            DistanceUnitType.NAUTICAL_MILES = "NauticalMiles";
            DistanceUnitType.MILLIMETERS = "Millimeters";
            DistanceUnitType.CENTIMETERS = "Centimeters";
            DistanceUnitType.DECIMETERS = "Decimeters";
            DistanceUnitType.METERS = "Meters";
            DistanceUnitType.KILOMETERS = "Kilometers";
            DistanceUnitType.DEGREES = "Degrees";
            DistanceUnitType.RADIANS = "Radians";
            DistanceUnitType.GRADS = "Grads";
        })(DistanceUnitType = essentials.DistanceUnitType || (essentials.DistanceUnitType = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/arcgis-js-api.d.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var _ExtentChangeType;
        (function (_ExtentChangeType) {
            _ExtentChangeType[_ExtentChangeType["NONE"] = -1] = "NONE";
            _ExtentChangeType[_ExtentChangeType["RESIZE"] = 0] = "RESIZE";
            _ExtentChangeType[_ExtentChangeType["REPOSITION"] = 1] = "REPOSITION";
            _ExtentChangeType[_ExtentChangeType["EXTENT_CHANGE"] = 2] = "EXTENT_CHANGE";
        })(_ExtentChangeType || (_ExtentChangeType = {}));
        /**
         * ExtentManager arbitrates potentially conflicting {@link esri.Map}  navigation events. For example, a {@link Workflow} run on application start up may
         * attempt to zoom the map to a particular location while a custom module attempts to navigate to another.
         *
         * In order to classify and prioritize competing map navigation requests, the {@link ExtentManager} offers an arbitrary system of navigation
         * priorities. These are known as 'extent changes' and each carries a priority value based on the nature of the change (i.e. how 'important' it is).
         *
         * @docs-hide-from-nav
         * @private
         */
        var ExtentManager = (function () {
            /**
             * Initializes a new instance of the {@link ExtentManager} class.
             * @param map The map that this {@link ExtentManager} arbitrates.
             * @param fitToExtent Whether or not to force tiled maps to show up completely in the given map extent
             */
            function ExtentManager(map, fitToExtent) {
                this._map = null;
                this._currentExtentChangePriority = -1;
                this._queuedExtentChangePriority = -1;
                this._queuedExtentChange = [];
                this._extentChangeInProgress = false;
                this._fitTiledMapsToExtent = false;
                this._newLayers = [];
                this._initialExtent = null;
                this.currentExtentChangeHandle = null;
                this._firstMapResizeExecuted = false;
                this._map = map;
                this._fitTiledMapsToExtent = !!fitToExtent;
                // If the fitTiledMapsToExtent parameter is switched on, log a console message so people are aware of this fact.
                if (this._fitTiledMapsToExtent) {
                    console.log("The fitTiledMapsToExtent parameter is active. When true, for maps that contain tiled map service layers, you are guaranteed to have the input extent shown completely on the map.");
                }
                this._map.on("resize", dojo.hitch(this, this._onResize));
                this._map.on("reposition", dojo.hitch(this, this._onReposition));
            }
            // Problems caused by CORE-23, which affects GVH-3186, GVH-3798, GVH-2416 and GVH-4243 among others, necessiated shifting the setting of the initial extent out of the constructor
            // so we can manually set it after switching all applicable spatial references to ArcGIS spatial references (instead of Essentials spatial references) when a service uses a wkt and not a wkid.
            ExtentManager.prototype.setInitialExtent = function (initialExtent) {
                var _this = this;
                if (this._map && this._map.loaded) {
                    this._setInitialExtentImpl(initialExtent);
                }
                else {
                    this._map.on("load", function () { return _this._setInitialExtentImpl(initialExtent); });
                }
            };
            ExtentManager.prototype._setInitialExtentImpl = function (initialExtent) {
                this._initialExtent = initialExtent;
                var panDuration = esri.config.defaults.map.panDuration;
                esri.config.defaults.map.panDuration = 0;
                this._map.reposition();
                this._map.setExtent(initialExtent, this._fitTiledMapsToExtent);
                esri.config.defaults.map.panDuration = panDuration;
                // GVH-2344: Some applications don't resize the map and are blocked from changing 
                // the extent, unless we update this value after the maps loaded.
                this._firstMapResizeExecuted = true;
            };
            ExtentManager.prototype._onResize = function (extent, width, height) {
                if (!this._firstMapResizeExecuted) {
                    this._firstMapResizeExecuted = true;
                    this.firstResize();
                    return;
                }
                this._handleNextExtentChange();
            };
            ExtentManager.prototype._onReposition = function (x, y) {
                this._handleNextExtentChange();
            };
            ExtentManager.prototype._onExtentChange = function () {
                if (!this._extentChangeInProgress) {
                    return;
                }
                this._currentExtentChangePriority = -1;
                this._extentChangeInProgress = false;
                this._handleNextExtentChange();
            };
            /**
             * Registers the given layer with the extent manager so that it can wait until the layer has sucessfully loaded to change the extent.
             * @param layer The layer to register.
             */
            ExtentManager.prototype.registerLayer = function (layer) {
                if (!this._hasLoaded()) {
                    this._newLayers.push(layer);
                }
            };
            /**
             * Signals that the map has loaded, the initial extent is set after resizing the map appropriately and the extent manager is now allowed to arbitrate future extent changes.
             */
            ExtentManager.prototype.firstResize = function () {
                var extentTestFactor = 1.75; // Tested empirically. Same as Essentials manager preview map. (GVH-3895)
                // GVH-3834: If the actual map extent is way off from the expected initial extent, log a message to the console telling users that the fitTiledMapsToExtent parameter may need to be
                // activated for the initial extent to be properly displayed.
                if (this._initialExtent && this._map.extent && !this._fitTiledMapsToExtent && !this._map.extent.expand(extentTestFactor).contains(this._initialExtent)) {
                    console.log("The 'fitTiledMapsToExtent' parameter may need to be set to true in configuration for the initial extent to be shown completely on the map.");
                }
                this._handleNextExtentChange();
            };
            /** @private */
            ExtentManager.prototype._handleNextExtentChange = function () {
                if (!this._hasLoaded()) {
                    return;
                }
                if (this._queuedExtentChange[_ExtentChangeType.RESIZE] !== null && typeof this._queuedExtentChange[_ExtentChangeType.RESIZE] !== "undefined") {
                    var resizeFunction = this._queuedExtentChange[_ExtentChangeType.RESIZE];
                    this._queuedExtentChange[_ExtentChangeType.RESIZE] = null;
                    resizeFunction(this._map);
                }
                else if (this._queuedExtentChange[_ExtentChangeType.REPOSITION] !== null && typeof this._queuedExtentChange[_ExtentChangeType.REPOSITION] !== "undefined") {
                    var repositionFunction = this._queuedExtentChange[_ExtentChangeType.REPOSITION];
                    this._queuedExtentChange[_ExtentChangeType.REPOSITION] = null;
                    repositionFunction(this._map);
                }
                else if (this._queuedExtentChange[_ExtentChangeType.EXTENT_CHANGE] !== null && typeof this._queuedExtentChange[_ExtentChangeType.EXTENT_CHANGE] !== "undefined") {
                    this._extentChangeInProgress = true;
                    this._currentExtentChangePriority = this._queuedExtentChangePriority;
                    this._queuedExtentChangePriority = -1;
                    var extentChangeFunction = this._queuedExtentChange[_ExtentChangeType.EXTENT_CHANGE];
                    this._queuedExtentChange[_ExtentChangeType.EXTENT_CHANGE] = null;
                    extentChangeFunction(this._map);
                }
            };
            /**
             * Invokes the given function if there are no other extent changes in progress.
             * If there are other extent changes in progress, the priority of this extent change must be
             * greater than or equal to the priority of the current extent change for it to take effect.
             *
             * This methods allows for extent changes to be scheduled, but to not interfere with more "important" ones.
             *
             * @param extentChangeFunction The function to be executed if there are no higher priorities. This function most likely attempts to change the map extent.
             * @param priority The priority to be applied to this operation
             */
            ExtentManager.prototype.changeExtentWithPriority = function (extentChangeFunction, priority) {
                var _this = this;
                var _priority = typeof priority !== "undefined" ? priority : 5;
                var wrappedExtentChangeFunction = function (map) {
                    if (_this.currentExtentChangeHandle !== null) {
                        _this.currentExtentChangeHandle.cancel();
                    }
                    _this.currentExtentChangeHandle = extentChangeFunction(map);
                    _this.currentExtentChangeHandle.then(dojo.hitch(_this, _this._onExtentChange), dojo.hitch(_this, _this._onExtentChange));
                };
                if (!this._isExtentChangeBlocked()) {
                    if (_priority < this._currentExtentChangePriority) {
                        return;
                    }
                    this._currentExtentChangePriority = _priority;
                    this._extentChangeInProgress = true;
                    wrappedExtentChangeFunction(this._map);
                }
                else {
                    if (_priority < this._queuedExtentChangePriority) {
                        return;
                    }
                    this._queuedExtentChangePriority = _priority;
                    this._queuedExtentChange[_ExtentChangeType.EXTENT_CHANGE] = wrappedExtentChangeFunction;
                }
            };
            /**
             * Changes the map to the given extent if there are no other higher priority extent changes in progress.
             * If there are other extent changes in progress, the priority of this extent change must be
             * greater than or equal to the priority of the current extent change for it to take effect.
             * @param extent The extent to change to.
             * @param priority The priority to be applied to this operation
             */
            ExtentManager.prototype.setExtentWithPriority = function (extent, priority) {
                var _that = this;
                this.changeExtentWithPriority(function (map) {
                    return map.setExtent(extent, _that._fitTiledMapsToExtent);
                }, priority);
            };
            /**
             * Centers the map to the given point if there are no other higher priority extent changes in progress.
             * If there are other extent changes in progress, the priority of this extent change must be
             * greater than or equal to the priority of the current extent change for it to take effect.
             * @param center The point to center at.
             * @param priority The priority to be applied to this operation
             */
            ExtentManager.prototype.centerAtWithPriority = function (center, priority) {
                this.changeExtentWithPriority(function (map) {
                    // Optimization: Don't pan if we're not going to move by at least one pixel.
                    // Otherwise, the map gets refreshed for nothing.
                    var currentCenter = map.extent.getCenter();
                    var pixelWidth = map.extent.getWidth() / map.width;
                    var pixelHeight = map.extent.getHeight() / map.height;
                    if (Math.abs(currentCenter.x - center.x) >= pixelWidth || Math.abs(currentCenter.y - center.y) >= pixelHeight) {
                        return map.centerAt(center);
                    }
                    else {
                        var def = new dojo.Deferred();
                        def.resolve();
                        return def;
                    }
                }, priority);
            };
            /**
             * Zooms the map to the given scale if there are no other extent changes in progress.
             * If there are other extent changes in progress, the priority of this extent change must be
             * greater than or equal to the priority of the current extent change for it to take effect.
             * @param scale The scale to zoom to.
             * @param priority The priority to be applied to this operation
             */
            ExtentManager.prototype.setScaleWithPriority = function (scale, priority) {
                this.changeExtentWithPriority(function (map) {
                    // Optimization: Don't call setScale() unless the scale actually differs from the current one.
                    // Otherwise, the map gets refreshed for nothing.
                    if (scale !== map.getScale()) {
                        return map.setScale(scale);
                    }
                    else {
                        var def = new dojo.Deferred();
                        def.resolve();
                        return def;
                    }
                }, priority);
            };
            /**
             * Resizes the map if there are no other extent changes in progress, as the resize operation may interface with the extent change.
             * If there are other extent changes in progress, the resize will wait for the current
             * extent change to finish and prevent all other extent changes until the resize is finished.
             * @param width The desired width of the map control.
             * @param width The desired height of the map control.
             * @param immediate Whether or not to resize immediately.
             */
            ExtentManager.prototype.blockForResize = function (width, height, immediate) {
                if (width == this._map.width && height == this._map.height) {
                    return;
                }
                if (!this._isResizeBlocked()) {
                    // Related to GVH-6020: The positional state of the map can be corrupted by layout changes happening at bad times (e.g. during layer loading).
                    // Resetting that position aids in the fix(es) for 6020.
                    this._map.position.update(0, 0);
                    this._map.resize(immediate);
                }
                else {
                    this._queuedExtentChange[_ExtentChangeType.RESIZE] = function (map) {
                        map.position.update(0, 0);
                        map.resize(immediate);
                    };
                }
            };
            /**
             * Repositions the map within the div if there are no other extent changes in progress.
             * If there are other extent changes in progress, the reposition will wait for the current
             * extent change to finish and prevent all other extent changes until the reposition is finished.
             */
            ExtentManager.prototype.blockForReposition = function () {
                // Note: Esri's `resize()` itself calls `reposition` internally, so we'll use that instead.
                if (!this._isRepositionBlocked()) {
                    // Related to GVH-6020: The positional state of the map can be corrupted by layout changes happening at bad times (e.g. during layer loading).
                    // Resetting that position aids in the fix(es) for 6020.
                    this._map.position.update(0, 0);
                    this._map.resize();
                }
                else {
                    this._queuedExtentChange[_ExtentChangeType.REPOSITION] = function (map) {
                        map.position.update(0, 0);
                        map.resize();
                    };
                }
            };
            ExtentManager.prototype._isExtentChangeBlocked = function () {
                return this._queuedExtentChange[_ExtentChangeType.REPOSITION] != null || this._queuedExtentChange[_ExtentChangeType.RESIZE] != null || !this._hasLoaded();
            };
            ExtentManager.prototype._isRepositionBlocked = function () {
                return this._extentChangeInProgress || !this._hasLoaded();
            };
            ExtentManager.prototype._isResizeBlocked = function () {
                return this._isRepositionBlocked();
            };
            ExtentManager.prototype._hasLoaded = function () {
                return (this._map && this._map.loaded) && this._firstMapResizeExecuted;
            };
            return ExtentManager;
        }());
        essentials.ExtentManager = ExtentManager;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="AsyncInitializable.ts" />
/// <reference path="DistanceUnit.ts" />
/// <reference path="Site.ts" />
/// <reference path="ExtentManager.ts" />
/// <reference path="MapService.ts" />
/// <reference path="../../../../_Definitions/arcgis-js-api.d.ts" />
/// <reference path="../../../../_Definitions/LayerTheme.Rest.d.ts" />
/// <reference path="../../../../_Definitions/BaseMap.Rest.d.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /*
         * Represents a map defined in a {@link Site}.
         */
        var Map = (function (_super) {
            __extends(Map, _super);
            /**
             * Initializes a new instance of the {@link Map} class.
             * @param url The URL to the REST endpoint of the {@link Map}.
             */
            function Map(url) {
                _super.call(this, url);
                /** The collection of {@link BaseMap}s for the map. */
                this.baseMaps = [];
                /** The esri.geometry.Extent which represents the full extent of the {@link Map}. */
                this.fullExtent = null;
                /** The esri.geometry.Extent which represents the initial extent of the {@link Map}. */
                this.initialExtent = null;
                /**
                 * Configuration parameter which controls whether to fit tiled maps to extent. When true, for maps that contain tiled map service layers,
                 * you are guaranteed to have the input extent shown completely on the map. The default value is false.
                 */
                this.fitTiledMapsToExtent = false;
                /** The collection of {@link geocortex.essentials.MapService} object. */
                this.mapServices = [];
                /**
                 * A view of the map services which are filtered to only include the active services in the application. This will change when, for example,
                 * a layer theme is applied. If no filter (layer theme) is applied, then this collection will be the same as the mapServices collection.
                 **/
                this.mapServicesFilteredView = [];
                /**
                 * The LayerThemesInfo for layer theme's which can be applied to this Map
                 */
                this.layerThemesInfo = null;
                /** The primary {@link MapService} of the {@link Map}. */
                this.primaryMapService = null;
                /** The collection of supported export formats for the {@link Map}. */
                this.supportedExportFormats = ["BMP", "JPEG", "PNG", "TIFF", "GeoTIFF", "PDF"];
                /** The {@link ExportMapImageOptions} which outline the options for exporting the map image. */
                this.exportMapImageOptions = null;
                /** The {@link DistanceUnit} that is used by this map. This will be null for the overview map. */
                this.units = null;
                /** Whether esri service layers have yet been added to the {@link esri.Map} object */
                this.serviceLayersAdded = false;
                /** The {@link ExtentManager} that manages all extent changes for the esri map. */
                this.extentManager = null;
                /** The spatial reference of the map. This should match the spatial reference of the Esri map */
                this.spatialReference = null;
                /**
                 * A boolean that manages whether or not the initial extent should be set when all map services have been added
                 * to the esri map or wait until another process manually calls setInitialExtent on the {@link ExtentManager}.
                 */
                this.setExtentOnLoad = true;
                /** The esri.Map of the {@link Map}.*/
                this._esriMap = null;
                /** @private */
                this._onExportComplete = null;
                /** @private */
                this._onExportError = null;
                this.originalUrl = url;
                this.url = essentials.utilities.UrlUtilities.simplify(url);
                this.layerThemesInfo = new geocortex.essentials.LayerThemesInfo(this);
            }
            /**
             * Returns the underlying {@link esri.Map}. */
            Map.prototype.getMap = function () {
                return this._esriMap;
            };
            /**
             * Returns a flattened list of all the layers as defined by the {@link Site}.
             */
            Map.prototype.allLayers = function () {
                var results = [];
                for (var i = 0; i < this.mapServices.length; i++) {
                    var mapService = this.mapServices[i];
                    for (var j = 0; j < mapService.layers.length; j++) {
                        results.push(mapService.layers[j]);
                    }
                }
                return results;
            };
            /**
             * Returns a flattened list of all the tables as defined by the {@link Site}.
             */
            Map.prototype.allTables = function () {
                var results = [];
                for (var i = 0; i < this.mapServices.length; i++) {
                    var mapService = this.mapServices[i];
                    for (var j = 0; j < mapService.tables.length; j++) {
                        results.push(mapService.tables[j]);
                    }
                }
                return results;
            };
            /**
             * Returns a flattened list of all the layers and tables as defined by the {@link Site}.
             */
            Map.prototype.allLayersAndTables = function () {
                var results = [];
                results = this.allLayers();
                results = this.allTables().reduce(function (coll, item) {
                    coll.push(item);
                    return coll;
                }, results);
                return results;
            };
            /**
             * Returns a flattened list of all the layers contained in the filtered mapService collection. (Filtered by Layer Theme settings)
             */
            Map.prototype.filteredLayers = function () {
                var results = [];
                for (var i = 0; i < this.mapServices.length; i++) {
                    var mapService = this.mapServices[i];
                    if (this._layerThemeMapServiceFilter(mapService)) {
                        results = results.concat(mapService.layers);
                    }
                }
                return results;
            };
            /**
             * Loads all the ServiceLayer objects into the ESRI layers collection.
             * This function is called automatically as part of the {@link Site} initialization process. */
            Map.prototype.loadServiceLayersInMap = function (map) {
                if (!map) {
                    throw new Error("Must supply a map");
                }
                this._esriMap = map;
                this.fitTiledMapsToExtent = !!map["_fitTiledMapsToExtent"]; // GVH-3834
                this.extentManager = new essentials.ExtentManager(map, this.fitTiledMapsToExtent);
                // Loop through the map service and ensure each service layer is loaded
                for (var i = 0; i < this.mapServices.length; i++) {
                    var mapService = this.mapServices[i];
                    var sl = mapService.serviceLayer;
                    // Make sure the mapService is initialized and has a service Layer
                    if (sl) {
                        this.extentManager.registerLayer(sl);
                        if (sl.loaded || mapService.failureTimeoutThresholdExceeded) {
                            this._layerLoadedUpdate(map);
                            // Fix dynamic layers not appearing in REST Manager (GE-3069)
                            mapService._handleServiceLayerLoaded(sl);
                            mapService._handleDynamicLayers(sl);
                        }
                        else {
                            dojo.connect(mapService, "onFailureTimeoutThresholdExceeded", dojo.hitch(this, this._layerLoadedUpdate, map));
                            dojo.connect(sl, "onLoad", dojo.hitch(this, this._layerLoadedUpdate, map));
                            dojo.connect(sl, "onError", dojo.hitch(this, this._layerLoadedUpdate, map));
                        }
                    }
                }
            };
            /**
             * Calculates the current scale of the map and returns it. This method just delegates to
             * esri.geometry.getScale(), passing it values that corresponding to the current state of the map. */
            Map.prototype.calculateScale = function () {
                return esri.geometry.getScale(this.site.getMap());
            };
            /** @private */
            Map.prototype._addServiceLayers = function (esriMap) {
                // Add the layers to the map in reverse order - first listed map on top
                for (var i = this.mapServices.length - 1; i >= 0; i--) {
                    esriMap.addLayer(this.mapServices[i].serviceLayer);
                }
                if (this.setExtentOnLoad && this.initialExtent) {
                    this.extentManager.setInitialExtent(this.initialExtent);
                }
                // Check if site is defined
                if (this.site !== null && dojo.isObject(this.site)) {
                    this.site.serviceLayersLoaded = true;
                    if (dojo.isFunction(this.site.onServiceLayersLoaded)) {
                        // Call the service layers loaded event
                        this.site.onServiceLayersLoaded(this.site);
                    }
                }
            };
            /**
             * Creates a MapService for every service layer provided and adds them to Essentials map.
             * @param serviceLayers An array of service layers.
             * @param serviceFunction The logical function of the {@link MapService}, either Base or Operational
             */
            Map.prototype.addServiceLayers = function (serviceLayers, serviceFunction) {
                var _this = this;
                var self = this;
                if (!serviceLayers && !serviceLayers.length) {
                    return;
                }
                var mapServices = [];
                var addMapServiceByType = function (layer) {
                    var mapService = null;
                    var includeInLayerList = false;
                    var mapServiceType = geocortex.essentials.MapServiceType.FEATURE;
                    layer.opacity = layer.opacity || 1;
                    switch (layer.type) {
                        case "Feature Layer":
                            mapService = new geocortex.essentials.FeatureLayerService(layer.url);
                            break;
                        default:
                            switch (layer.declaredClass) {
                                case "esri.layers.WebTiledLayer":
                                    mapService = new geocortex.essentials.MapService(layer.tileServers[0]);
                                    mapServiceType = geocortex.essentials.MapServiceType.WEBTILED;
                                    includeInLayerList = true;
                                    break;
                                default:
                                    break;
                            }
                            break;
                    }
                    if (!mapService) {
                        return;
                    }
                    mapService.serviceLayer = layer;
                    mapService.essentialsMap = self;
                    var layerId = layer.layerId || geocortex.framework.utils.alphaNumericToken();
                    var serviceOptions = {
                        id: layerId,
                        isExpanded: true,
                        includeInLayerList: includeInLayerList,
                        serviceFunction: serviceFunction,
                        serviceType: mapServiceType,
                        layerOptions: null
                    };
                    serviceOptions.layerOptions = {
                        id: layerId,
                        name: layer.name,
                        description: layer.description,
                        displayField: layer.displayField,
                        includeInLayerList: true,
                        identifiable: true,
                        fullExtent: layer.fullExtent,
                        primaryKeyField: layer.objectIdField,
                        visible: layer.visible
                    };
                    mapService._createFrom(serviceOptions);
                    mapServices.push(mapService);
                    // Associate the feature with the popup on click
                    dojo.connect(layer, "onClick", function (args) {
                        dojo.publish("FeatureClickedEvent", dojo.mixin(args, {
                            layer: mapService.layers[0],
                            useFeaturePresenter: true
                        }));
                    });
                };
                for (var i = 0; i < serviceLayers.length; ++i) {
                    var serviceLayer = serviceLayers[i];
                    if (serviceLayer instanceof essentials.GeoRssLayerService) {
                        mapServices.push(serviceLayer);
                        continue;
                    }
                    if (serviceLayer.getFeatureLayers) {
                        var geoRssLayer = serviceLayer;
                        var layers = geoRssLayer.getFeatureLayers();
                        if (layers && layers.length > 0) {
                            // The GeoRSS layers may contain one feature layer for each geometry type.
                            dojo.forEach(layers, function (layer) {
                                layer.name = layer.name || geoRssLayer.name;
                                addMapServiceByType(layer);
                            });
                            continue;
                        }
                    }
                    addMapServiceByType(serviceLayer);
                }
                this.mapServices = this.mapServices.concat(mapServices);
                dojo.forEach(mapServices, function (ms) { return _this._addToFilteredView(ms); });
                this._addServiceLayers(this.getMap());
                dojo.forEach(mapServices, function (ms) {
                    dojo.publish("MapServiceAddedEvent", ms);
                });
            };
            /**
             * Removes the MapService representing the service layer provided, from the Essentials MapServices array. Note: This will not remove it from the map.
             * @param serviceLayer The esri service layer, whose corresponding mapService we want to remove
             */
            Map.prototype.removeServiceLayer = function (serviceLayer) {
                if (serviceLayer && this.mapServices.length) {
                    for (var i = 0; i < this.mapServices.length; i++) {
                        var ms = this.mapServices[i];
                        if (ms && ms.serviceLayer && (ms.serviceLayer === serviceLayer)) {
                            this.mapServices.splice(i, 1);
                            dojo.publish("MapServiceRemovedEvent", ms);
                            break;
                        }
                    }
                }
            };
            /**
             * Integrate a Geocortex map service into the viewer and onto the map.
             * @param mapService The Geocortex map service, containing a service layer and Geocortex layers, to be integrated onto the map and into the viewer. Must be of type {@link essentials.FeatureLayerService} or {@link essentials.KmlService}.
             */
            Map.prototype.addMapService = function (mapService) {
                // Grabbing references to the esri map and the site object.
                var esriMap = this.getMap();
                var site = this.site;
                // Acknowledging that the map service is user-added.
                mapService.isUserCreated = true;
                mapService.includeInLayerList = !(mapService instanceof essentials.FeatureLayerService);
                mapService.opacity = 1;
                // Configuring the Geocortex layers.
                for (var _i = 0, _a = mapService.layers; _i < _a.length; _i++) {
                    var gcxLayer = _a[_i];
                    gcxLayer.isUserCreated = true;
                    gcxLayer.includeInLayerList = true;
                    gcxLayer.includeInLegend = true;
                    gcxLayer.site = site;
                    gcxLayer.configuredVisible = true;
                    // GVH-11209 Can't Add ArcGIS Server Tiled Map Services With More Than One Layer
                    // Setting individual layer visibility for tiled services causes errors if service has more than 1 layer
                    // There's no point in setting layer visibility when not supported
                    if (mapService.supportsLayerVisibility()) {
                        gcxLayer.setVisibility(true);
                    }
                    else {
                        // Remember: we dont want to actually setVisibility on the layer (fires visibility events) - we simply ensure that the isVisible() function returns the correct result.
                        gcxLayer._visible = true;
                    }
                }
                // Placing the map service onto the map.
                mapService.essentialsMap = this;
                this.mapServices.push(mapService);
                esriMap.addLayer(mapService.serviceLayer);
                dojo.publish("MapServiceAddedEvent", mapService);
                // Making the map service visible. This must be called after the MapServiceAddedEvent is published in order to work.
                mapService.setVisibility(true);
            };
            /**
             * Removes a map service from both the Essentials map and the Esri map.
             * @param mapService The map service to be removed.
             */
            Map.prototype.removeMapService = function (mapService) {
                if (!mapService) {
                    return;
                }
                var i = this.mapServices.indexOf(mapService);
                if (i >= 0) {
                    this.mapServices.splice(i, 1);
                    dojo.publish("MapServiceRemovedEvent", mapService);
                }
                if (this._esriMap && mapService.serviceLayer) {
                    this._esriMap.removeLayer(mapService.serviceLayer);
                }
            };
            /** @private */
            Map.prototype._configureMapServices = function (mapServiceResults, deepInitialize) {
                for (var i = 0; mapServiceResults && i < mapServiceResults.length; i++) {
                    var srv = mapServiceResults[i];
                    var serviceUrl = this.originalUrl + "/mapservices/" + srv.id;
                    if (srv.drawingBehavior == geocortex.essentials.DrawingBehavior.FEATURE_LAYER) {
                        if (!dojo.isObject(esri.layers.FeatureLayer)) {
                            throw new Error("This Javascript application must // dojo.require the esri.layers.FeatureLayer package in order to use a site with feature layers");
                        }
                        this.mapServices[i] = new geocortex.essentials.FeatureLayerService(serviceUrl);
                    }
                    else if (srv.drawingBehavior == geocortex.essentials.DrawingBehavior.GEORSS_LAYER) {
                        if (!dojo.isObject(esri.layers.GraphicsLayer)) {
                            throw new Error("This Javascript application must // dojo.require the esri.layers.GraphicsLayer package in order to use a site with GeoRSS layers");
                        }
                        // holding a reference to GeoRssLayerService creates a circular reference, which isn't properly resolved yet
                        // see: https://typescript.codeplex.com/workitem/913
                        this.mapServices[i] = new geocortex.essentials.GeoRssLayerService(serviceUrl);
                    }
                    else if (srv.drawingBehavior == geocortex.essentials.DrawingBehavior.KML_SERVICE) {
                        if (!dojo.isObject(esri.layers.KMLLayer)) {
                            throw new Error("This Javascript application must // dojo.require the esri.layers.KMLLayer package in order to use a site with KML layers");
                        }
                        // holding a reference to KmlService creates a circular reference, which isn't properly resolved yet
                        // see: https://typescript.codeplex.com/workitem/913
                        this.mapServices[i] = new geocortex.essentials.KmlService(serviceUrl);
                    }
                    else {
                        this.mapServices[i] = new geocortex.essentials.MapService(serviceUrl);
                    }
                    this.mapServices[i].essentialsMap = this;
                    this.mapServices[i].initialize(srv);
                    dojo.publish("ServiceLayerInitializedEvent", this.mapServices[i].serviceLayer);
                    this._addToFilteredView(this.mapServices[i]);
                }
            };
            /** @private */
            Map.prototype._configureObject = function (obj, deepInitialize) {
                if (obj === undefined || obj.mapServices === undefined) {
                    throw new Error("Incorrect map object returned from initialization");
                }
                if (obj.initialExtent) {
                    this.initialExtent = new esri.geometry.Extent(obj.initialExtent);
                }
                if (obj.fullExtent) {
                    this.fullExtent = new esri.geometry.Extent(obj.fullExtent);
                }
                if (obj.units) {
                    this.units = new geocortex.essentials.DistanceUnit(obj.units.name, obj.units.type);
                }
                if (obj.exportOptions) {
                    this.exportMapImageOptions = new geocortex.essentials.ExportMapImageOptions(obj.exportOptions.allowIncludeGeoreferenceData, obj.exportOptions.defaultOutputFormat);
                }
                if (obj.layerThemes && ((obj.layerThemes.items && obj.layerThemes.items.length) || obj.layerThemes.allowDefault)) {
                    this._configureLayerThemesInfo(obj.layerThemes);
                }
                this._configureMapServices(obj.mapServices, deepInitialize);
                if (dojo.isArray(obj.baseMaps)) {
                    this._configureBaseMaps(obj.baseMaps);
                }
                if (deepInitialize) {
                    this.isInitialized = true;
                }
                this.primaryMapService = this.findMapServiceById(obj.primaryMapServiceID);
            };
            /**
             * Find the {@link MapService} matching the specified ID.
             * @param mapServiceId The ID of the MapService to find.
             */
            Map.prototype.findMapServiceById = function (mapServiceId) {
                for (var i = 0; i < this.mapServices.length; i++) {
                    if (this.mapServices[i].id == mapServiceId) {
                        return this.mapServices[i];
                    }
                }
                return null;
            };
            /**
             * Sets one {@link Layer} as the exclusively visible layer.
             * @param layer The layer to make the only visible layer.
             */
            Map.prototype.setFeatureLayerExclusivelyVisible = function (layer) {
                var mapServices = this.site.getFeatureServices();
                for (var i = 0; i < mapServices.length; i++) {
                    var currentMapService = mapServices[i];
                    currentMapService.setVisibility(currentMapService.serviceLayer.id === layer.id);
                }
            };
            /**
             * Exports the {@link Map} using. This is an asynchronous method, you may provide delegates for completion or error information.
             * @param exportParameters The export parameters.
             * @param exportComplete The delegate that will be called when the export has completed
             * (even if an error occurs). This delegate expects one argument: a String representing the URL of the exported file.
             * @param exportError The delegate that will be called if an error occurs. This delegate expects an Error as argument.
             */
            Map.prototype.exportMap = function (exportParameters, exportComplete, exportError) {
                var _this = this;
                // Store the delegates for the end of the synchronous request method
                this._onExportComplete = exportComplete;
                this._onExportError = exportError;
                // Export using the ExportContext
                var webMapBuilder = new geocortex.essentials.exportMap.ExportMapTask(this);
                var webMapParams = new geocortex.essentials.exportMap.ExportMapParameters();
                webMapParams.reportParameters = exportParameters;
                webMapBuilder.generateMapImageUrl(webMapParams)
                    .then(function (result) { return _this._exportRestComplete(result); }, function (e) { return _this._exportRestError(e); });
            };
            /**
             * Searches the {@link Map} for the layer corresponding to the input esri FeatureLayer.
             * @param layer The {@link esri.layers.FeatureLayer} whose Geocortex layer we want to find.
             */
            Map.prototype.findLayerFromMatchingEsriFeatureLayer = function (layer) {
                if (!layer) {
                    return;
                }
                // Geocortex Essentials Security causes problems here as URLs for proxied sites won't match up.
                // (ex. "../sites/ParkTrees/map/mapservices/2/GeoREST/FeatureServer/1" vs "../sites/ParkTrees/map/mapservices/1/GeoREST/FeatureServer/2"
                // The second may point to the first endpoint and vice-versa. Relationships between layers become obscured - layers will still be proxied
                // to correctly, but there will be a large number of url variants if we just change the last digit.
                for (var i = 0; i < this.mapServices.length; i++) {
                    var mapService = this.mapServices[i];
                    if (mapService.serviceLayer instanceof esri.layers.FeatureLayer) {
                        var serviceLayer = mapService.serviceLayer;
                        if (serviceLayer.layerId == layer.layerId && serviceLayer.name == layer.name) {
                            if (mapService.layers.length > 0) {
                                return mapService.layers[0];
                            }
                        }
                    }
                }
                /*
                 * Takes in a mapService that is to be compared to a url in order to find a match.
                 * It checks the URL and MapService to see if it is a token-based site, and if it is then it
                 * returns the MapService URL with the token attached.
                 * NOTE: This function expression also exists in a private method of the same name (prefixed by an underscore)
                 * in RelatedFeaturesViewModelBase.ts, as it is used in an overload method in RelatedFeaturesViewModel.
                 * @param mapService: The MapService that is to be compared with the url.
                 * @param urlToBeCompared: A URL that is to be compared with mapService.serviceUrl
                 */
                var getProperMapServiceUrlForComparison = function (mapService, urlToBeCompared) {
                    var mapServiceUrl = mapService.serviceUrl;
                    // Check to see if we're dealing with a token or not.
                    if (mapService.serviceToken && urlToBeCompared.search(/token=.[^&]*/g) > 0) {
                        mapServiceUrl += "?token=" + mapService.serviceToken;
                    }
                    return mapServiceUrl;
                };
                // If the above method of finding the gcxLayer fails, then resort to the old way of looking via url.
                var url = layer.url.match(/.[^?]*/g)[0];
                for (var i = 0; i < this.mapServices.length; i++) {
                    var mapService = this.mapServices[i];
                    var mapServiceUrl = getProperMapServiceUrlForComparison(mapService, url);
                    if (mapServiceUrl === url) {
                        if (mapService.layers.length > 0) {
                            return mapService.layers[0];
                        }
                    }
                }
                // If we haven't found anything, we may be dealing with a MapServer.
                // It stores its layers differently.
                // First things first, let's regex off the layer # from the URL into a variable.
                // This will be used to match the mapservice and to find the appropriate layer within it.
                var regexNumber = new RegExp("\[^\/]*.$");
                var layerId = Number(url.match(regexNumber));
                // Now that we've extracted the number, get rid of the number along with the preceding /
                var regex = new RegExp("\/[^\/]*.$");
                var changedUrl = url.replace(regex, "");
                for (var i = 0; i < this.mapServices.length; i++) {
                    var mapService = this.mapServices[i];
                    var mapServiceUrl = getProperMapServiceUrlForComparison(mapService, changedUrl);
                    if (mapServiceUrl === changedUrl) {
                        // Try to find a layer or table with the same id
                        var lyr = mapService.findLayerOrTableById(layerId.toString());
                        if (lyr) {
                            return lyr;
                        }
                        // Do it the old way. This looks incorrect.
                        if (mapService.layers.length >= layerId) {
                            return mapService.layers[layerId];
                        }
                    }
                }
                return null;
            };
            /** @private */
            Map.prototype._exportRestComplete = function (results) {
                var ex = null;
                if (!results) {
                    ex = new Error("No results");
                }
                else {
                    if (results.error) {
                        ex = results.error;
                    }
                }
                if (ex && this._onExportComplete) {
                    this._onExportError(ex);
                }
                if (results && this._onExportComplete) {
                    this._onExportComplete(results);
                }
            };
            /** @private */
            Map.prototype._exportRestError = function (error) {
                if (this._onExportError) {
                    this._onExportError(error);
                }
            };
            /** @private */
            Map.prototype._layerLoadedUpdate = function (esriMap) {
                if (this.serviceLayersAdded) {
                    return;
                }
                for (var i = 0; i < this.mapServices.length; i++) {
                    var ms = this.mapServices[i];
                    var sl = ms.serviceLayer;
                    if (!ms.initializationFailure && ms.failureTimeoutThresholdExceeded) {
                        ms.initializationFailure = new Error("Map Service - {0}: Failure timeout threshold exceeded.".format(ms.id));
                    }
                    if (!sl.loaded && !ms.initializationFailure && !ms.failureTimeoutThresholdExceeded) {
                        return;
                    }
                }
                this.serviceLayersAdded = true;
                //CORE-23: WKT from Site does not match text found in AGS Map. We must thus ensure that we always use the map's wkt and not the one returned by essentials. Also affects
                // GVH-3186, GVH-3798, GVH-2416 and GVH-4243
                this.spatialReference = this.primaryMapService.serviceLayer["spatialReference"];
                if (this.spatialReference && this.spatialReference.wkt) {
                    this._switchSpatialReferenceGlobally(this.spatialReference);
                }
                if (!this._esriMap.spatialReference) {
                    this._esriMap.spatialReference = this.spatialReference || this.initialExtent.spatialReference || this.fullExtent.spatialReference;
                }
                // GVH-4208: We need to assign an extent to the map before we add the service layers because otherwise, if there's a single feature layer in the site, it will throw a 
                // type error since a feature layer assumes existence of an extent on the map.
                if (!this._esriMap.extent && this.initialExtent) {
                    this._esriMap.setExtent(new esri.geometry.Extent(this.initialExtent.toJson()));
                }
                this._addServiceLayers(esriMap);
            };
            /**
             * Applies layer catlog changes to the map.
             * @param detailsResults The details object which was returned from the Layer Catalog endpoint.
             */
            Map.prototype.applyCatalogLayersChange = function (detailsResults) {
                if (!detailsResults) {
                    return;
                }
                this._applyCatalogChangesToDynamicLayers(detailsResults);
                this._applyCatalogChangesToWmsLayers(detailsResults);
            };
            Map.prototype.applyStartupTheme = function () {
                // Apply startup layer theme or the first theme (may be the default theme) configured
                if (this.layerThemesInfo.layerThemesConfigured) {
                    this.layerThemesInfo.applyTheme(this.layerThemesInfo.startupThemeId || this.layerThemesInfo.themes[0].id);
                }
            };
            /**
             * Refreshes the mapServicesFilteredView collection and the layersFilteredView collection for each of the map services and constituent layers
             */
            Map.prototype.refreshFilteredCollections = function () {
                var _this = this;
                this.mapServicesFilteredView.length = 0;
                dojo.forEach(this.mapServices, function (ms) { return _this._addToFilteredView(ms); });
                for (var x = 0; x < this.mapServices.length; x++) {
                    this.mapServices[x].refreshFilteredCollections();
                }
            };
            /**
             * @private
             * CORE-23: WKT from Site does not match text found in AGS Map. We must thus ensure that we always use the map's wkt and not the one returned by essentials. Also affects
             * GVH-3186, GVH-3798, GVH-2416 and GVH-4243. This method will switch all spatial references in the site, map and elsewhere in the application to ensure compatibility throughout.
             **/
            Map.prototype._switchSpatialReferenceGlobally = function (newSpatialReference) {
                if (this.initialExtent) {
                    this.initialExtent = new esri.geometry.Extent(this.initialExtent.xmin, this.initialExtent.ymin, this.initialExtent.xmax, this.initialExtent.ymax, newSpatialReference);
                }
                if (this.fullExtent) {
                    this.fullExtent = new esri.geometry.Extent(this.fullExtent.xmin, this.fullExtent.ymin, this.fullExtent.xmax, this.fullExtent.ymax, newSpatialReference);
                }
                if (this.site.hasNamedExtents && this.site.namedExtents && this.site.namedExtents.length) {
                    for (var x = 0; x < this.site.namedExtents.length; x++) {
                        var namedExtent = this.site.namedExtents[x];
                        namedExtent.extent = new esri.geometry.Extent(namedExtent.extent.xmin, namedExtent.extent.ymin, namedExtent.extent.xmax, namedExtent.extent.ymax, newSpatialReference);
                    }
                }
                this._esriMap.spatialReference = newSpatialReference;
            };
            /** @private */
            Map.prototype._applyCatalogChangesToWmsLayers = function (detailsResults) {
                // placeholder - this is currently done in the layer catalog but should be done here once GVH supports wms layer adding/removal
            };
            /** @private */
            Map.prototype._applyCatalogChangesToDynamicLayers = function (detailsResults) {
                var mapServiceId = detailsResults.mapServiceId;
                var dynamicLayers = [];
                var details = new geocortex.essentials.catalog.LayerCatalogDetail();
                details.mapServiceId = mapServiceId;
                // only supports dynamic layers
                for (var i = 0; i < detailsResults.entries.length; i++) {
                    if (detailsResults.entries[i].isDynamic) {
                        dynamicLayers.push(detailsResults.entries[i]);
                    }
                }
                details.entries = dynamicLayers;
                var mapService = this.findMapServiceById(mapServiceId);
                if (mapService) {
                    mapService.applyCatalogLayersChange(details);
                }
            };
            /**
             * @private: Configure the LayerThemesInfo object from the rest response (if applicable).
             */
            Map.prototype._configureLayerThemesInfo = function (restLayerThemesInfo) {
                var _this = this;
                if (!restLayerThemesInfo) {
                    throw new Error("RestLayerThemesInfo object not defined. Cannot configure layer themes.");
                }
                this.layerThemesInfo.layerThemesConfigured = true;
                this.layerThemesInfo.allowDefault = (restLayerThemesInfo.allowDefault != undefined) ? restLayerThemesInfo.allowDefault : true;
                this.layerThemesInfo.startupThemeId = restLayerThemesInfo.startupThemeID;
                // Add the default theme if required
                if (this.layerThemesInfo.allowDefault) {
                    this.layerThemesInfo.themes.push(new essentials.LayerTheme(this.layerThemesInfo, null /* null signifies default theme */, restLayerThemesInfo.defaultThemeDisplayName || ""));
                }
                // Add the configured themes
                if (restLayerThemesInfo.items && restLayerThemesInfo.items.length) {
                    dojo.forEach(restLayerThemesInfo.items, function (restLayerTheme) {
                        _this.layerThemesInfo.themes.push(new essentials.LayerTheme(_this.layerThemesInfo, restLayerTheme));
                    });
                }
            };
            Map.prototype._addToFilteredView = function (mapService) {
                if (mapService && this._layerThemeMapServiceFilter(mapService)) {
                    this.mapServicesFilteredView.push(mapService);
                }
            };
            /**
             * @private: The filter used for filtering each service based on layer theme settings
             */
            Map.prototype._layerThemeMapServiceFilter = function (mapService) {
                return mapService.essentialsMap.layerThemesInfo.layerThemesConfigured ? mapService.inActiveTheme : true;
            };
            /** @private */
            Map.prototype._configureBaseMaps = function (restBaseMaps) {
                var _this = this;
                restBaseMaps.forEach(function (restBaseMap) {
                    var baseMap = new essentials.BaseMap(_this);
                    baseMap.displayName = restBaseMap.displayName;
                    baseMap.id = restBaseMap.id;
                    if (restBaseMap.iconUri) {
                        baseMap.iconUri = geocortex.essentials.RestHelper.processClientSideTokens(_this.site, restBaseMap.iconUri);
                    }
                    if (restBaseMap.exportTilesMapServiceUri) {
                        baseMap.exportTilesMapServiceUri = geocortex.essentials.RestHelper.processClientSideTokens(_this.site, restBaseMap.exportTilesMapServiceUri);
                    }
                    baseMap.properties = geocortex._getProperties(restBaseMap.properties);
                    baseMap.extensions = geocortex._getExtensions(restBaseMap.extensions);
                    if (dojo.isArray(restBaseMap.mapServices)) {
                        restBaseMap.mapServices.forEach(function (ms) {
                            var mapService = _this.findMapServiceById(ms.id);
                            if (mapService) {
                                baseMap.services.push(new essentials.BaseMapService(mapService));
                            }
                        });
                    }
                    _this.baseMaps.push(baseMap);
                });
            };
            return Map;
        }(essentials.AsyncInitializable));
        essentials.Map = Map;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents a configured scale in a {@link Report}.
         */
        var Scale = (function () {
            /**
             * Initializes a new instance of the {@link geocortex.essentials.Scale} class.
             * @param displayName The display name of the {@link geocortex.essentials.Scale}.
             * @param scale The scale.
             */
            function Scale(displayName, scale) {
                this.displayName = displayName;
                this.scale = scale;
            }
            return Scale;
        }());
        essentials.Scale = Scale;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Describes a resolution used in the generation of a {@link geocortex.essentials.Report}.
         */
        var Resolution = (function () {
            /**
             * Initializes a new instance of the {@link Resolution} class.
             * @param displayName The display name of the {@link Resolution}.
             * @param dpi The resolution in dots per inch.
             */
            function Resolution(displayName, dpi) {
                if (displayName !== undefined) {
                    this.displayName = displayName;
                }
                if (dpi !== undefined) {
                    this.dpi = dpi;
                }
            }
            return Resolution;
        }());
        essentials.Resolution = Resolution;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents a text field used in a {@link Report}.
         */
        var TextField = (function () {
            /**
             * Initializes a new instance of the {@link geocortex.essentials.TextField} class.
             * @param id The ID of the text field.
             * @param name The name of the text field.
             * @param value The value of the text field.
             * @param multiline Indicates whether the text field is a multiline field.
             */
            function TextField(id, displayName, value, multiline) {
                this.id = id;
                this.displayName = displayName;
                this.value = value;
                this.multiline = multiline;
            }
            return TextField;
        }());
        essentials.TextField = TextField;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="MapGrid.ts" />
/// <reference path="Map.ts" />
/// <reference path="Scale.ts" />
/// <reference path="Resolution.ts" />
/// <reference path="TextField.ts" />
/// <reference path="../../../../_Definitions/arcgis-js-api.d.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * A class to hold parameters that will be used by the {@link Report} and
         * {@link PrintTemplate} classes to produce their output.
         */
        var ReportParameters = (function () {
            function ReportParameters() {
                /** The extent to use. */
                this.customExtent = null;
                /** The type of extent that will be used for the map image in the report. */
                this.extentType = "currentExtent";
                /** The list of fields that are defined for the report. */
                this.fields = [];
                /** The map grid to include in the report. */
                this.grid = null;
                /** The image hight in pixels. */
                this.imageHeight = null;
                /** The image width in pixels. */
                this.imageWidth = null;
                /** The email address to which to send a notification upon print completion. */
                this.notificationEmailAddress = null;
                /** The format for the report output. */
                this.outputFormat = null;
                /** Array of feature ID strings on which to run the report. */
                this.featureIds = null;
                /** The resolution that will be used to create the report. */
                this.resolution = null;
                /** The scale that will be used for the map image in the report. */
                this.scale = null;
            }
            /**
             * Given an {@link esri.Map} and a {@link essentials.Map}, turns the {@link ReportParameters} into a JSON object
             * ready for serialization.
             */
            ReportParameters.prototype.toJson = function (esriMap, essentialsMap) {
                if (!esriMap || !essentialsMap) {
                    throw new Error("Reporting parameter creation is missing a main map.");
                }
                var jn = {}, bbox, jsonSR;
                var printScale = (this.scale && (this.scale.scale != undefined) && !isNaN(parseFloat(this.scale.scale))) ? parseFloat(this.scale.scale) : esriMap.getScale();
                // Check if the scale should be specified and if yes, set it
                if (this.scale && (this.scale.scale != undefined)) {
                    jn.scale = this.scale.scale;
                }
                // Predefine an index for iteration, since it is used several times.
                var i;
                // Check which type of extent should be used
                if ((this.extentType == geocortex.essentials.ReportParameters.CURRENT_EXTENT) && (esriMap !== null)) {
                    bbox = esriMap.extent;
                }
                else if ((this.extentType == geocortex.essentials.ReportParameters.FULL_EXTENT) && (essentialsMap !== null)) {
                    bbox = essentialsMap.fullExtent;
                }
                else if ((this.extentType == geocortex.essentials.ReportParameters.INITIAL_EXTENT) && (essentialsMap !== null)) {
                    bbox = essentialsMap.initialExtent;
                }
                else if ((this.extentType == geocortex.essentials.ReportParameters.CUSTOM_EXTENT) && (this.customExtent !== null)) {
                    bbox = this.customExtent;
                }
                // Check if the bounding box should be specified
                if (bbox) {
                    // Set bbox SR
                    if (bbox.spatialReference) {
                        // Let the SR properly encode its spatial reference
                        jsonSR = bbox.spatialReference.toJson();
                        if (jsonSR) {
                            if (jsonSR.wkid && jsonSR.wkid > 0) {
                                jn.bboxSR = jsonSR.wkid;
                            }
                            else if (jsonSR.wkt) {
                                jn.bboxSR = jsonSR.wkt;
                            }
                        }
                    }
                    jn.bbox = bbox.xmin + "," + bbox.ymin + "," + bbox.xmax + "," + bbox.ymax;
                }
                // Set output SR if necessary
                if (this.targetSpatialReference) {
                    // Let the SR properly encode its spatial reference
                    jsonSR = this.targetSpatialReference.toJson();
                    if (jsonSR) {
                        if (jsonSR.wkid && jsonSR.wkid > 0) {
                            jn.targetSR = jsonSR.wkid;
                        }
                        else if (jsonSR.wkt) {
                            jn.targetSR = jsonSR.wkt;
                        }
                    }
                }
                if (this.notificationEmailAddress) {
                    jn.emailAddress = this.notificationEmailAddress;
                }
                if (this.imageHeight && this.imageHeight > 0) {
                    jn.imageHeight = this.imageHeight;
                }
                if (this.imageWidth && this.imageWidth > 0) {
                    jn.imageWidth = this.imageWidth;
                }
                // Set time extent if necessary
                if (esriMap.timeExtent) {
                    jn.time = "";
                    if (esriMap.timeExtent.startTime) {
                        jn.time += esriMap.timeExtent.startTime.getTime(); // <jeffg> I'm not sure that this works
                    }
                    else {
                        jn.time += "null";
                    }
                    jn.time += ",";
                    if (esriMap.timeExtent.endTime) {
                        jn.time += esriMap.timeExtent.endTime.getTime();
                    }
                    else {
                        jn.time += "null";
                    }
                }
                var printFeatureLayerOptionsCollection = [];
                // If we have the essentials map available, try to determine which layers should be shown.
                if (essentialsMap !== null) {
                    var prepString = "";
                    var opacity = "";
                    var layerDefinitions = "";
                    // Loop through all the services in the map
                    for (i = 0; i < essentialsMap.mapServices.length; i++) {
                        var service = essentialsMap.mapServices[i];
                        var layerIDs = "";
                        var serviceLayer = service.serviceLayer;
                        var serviceLayerDefs;
                        var serviceLayerDefsString = "";
                        // Check if the service layer is available and if it is visible
                        if (serviceLayer) {
                            if (serviceLayer.visible === true) {
                                // Prep the opacity parameter
                                opacity += (opacity === "" ? "" : ";") + service.id + ":" + serviceLayer.opacity;
                            }
                            // Check if it's a dynamic map service layer
                            if (service.mapServiceType === geocortex.essentials.MapServiceType.DYNAMIC) {
                                // Note that the layer definitions block is included regardless of the visibility
                                // of the map service due to the fact that it can be used by layer template
                                // reporting as well as map template reporting.  There is no requirement that
                                // a layer template report must operate on a layer/service that is visible.
                                serviceLayerDefs = serviceLayer.layerDefinitions;
                                var layerDefCount = 0;
                                for (var lyrId in serviceLayerDefs) {
                                    if (layerDefCount > 0) {
                                        serviceLayerDefsString += ",";
                                    }
                                    serviceLayerDefsString += "\"" + lyrId + "\":\"" + serviceLayerDefs[lyrId].replace(/\\/g, "\\\\").replace(/"/g, "\\\"") + "\"";
                                    layerDefCount++;
                                }
                                // Add the service's layer definitions string to the running total, if there
                                // are any client-side layer definitions which have been configured.
                                if (layerDefCount > 0) {
                                    if (layerDefinitions.length > 1) {
                                        layerDefinitions += ",";
                                    }
                                    layerDefinitions += "\"" + service.id + "\":{";
                                    layerDefinitions += serviceLayerDefsString;
                                    layerDefinitions += "}";
                                }
                                if (serviceLayer.visible === true && serviceLayer.isVisibleAtScale(printScale) === true) {
                                    if (serviceLayer instanceof esri.layers.ArcGISDynamicMapServiceLayer) {
                                        var dynamicServiceLayer = serviceLayer;
                                        if (dynamicServiceLayer.visibleLayers && dynamicServiceLayer.visibleLayers.toString() !== "-1") {
                                            layerIDs = dynamicServiceLayer.visibleLayers.toString();
                                        }
                                    }
                                    else {
                                        if (!service.layers || service.layers.length === 0) {
                                            layerIDs = "*";
                                        }
                                        else {
                                            if (service.layers && service.layers.length > 0) {
                                                // Just get all the ids of the visible layers
                                                for (var j = 0; j < service.layers.length; j++) {
                                                    var layer = service.layers[j];
                                                    if (layer.isVisible() && layer.areAllAncestorsVisible()) {
                                                        layerIDs += ((layerIDs.length === 0) ? "" : ",") + layer.id;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else if (serviceLayer.visible === true && serviceLayer.isVisibleAtScale(printScale) === true) {
                                if (!service.layers || service.layers.length === 0) {
                                    layerIDs = "*";
                                }
                                else {
                                    if (service.layers && service.layers.length > 0) {
                                        // Just get all the ids of the visible layers
                                        for (var j = 0; j < service.layers.length; j++) {
                                            var layer = service.layers[j];
                                            if (layer.isVisible() && layer.areAllAncestorsVisible()) {
                                                layerIDs += ((layerIDs.length === 0) ? "" : ",") + layer.id;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        var serviceLayerId = service.id;
                        if (layerIDs.length === 0) {
                            // If there are no layers visible then we use the hide:* syntax
                            serviceLayerId += "(hide:*)";
                        }
                        else {
                            // Show the desired layers
                            serviceLayerId += "(show:" + layerIDs + ")";
                        }
                        prepString += (prepString.length === 0 ? "" : ";") + serviceLayerId;
                        // Prepare FeatureLayer options
                        if (service instanceof geocortex.essentials.FeatureLayerService) {
                            var printFeatureLayerOptions = {};
                            printFeatureLayerOptions.id = service.id;
                            var selectionSymbol = serviceLayer.getSelectionSymbol();
                            if (selectionSymbol && selectionSymbol.color) {
                                var colorArray = selectionSymbol.color.toRgba();
                                printFeatureLayerOptions.selectionColor = {
                                    r: colorArray[0],
                                    g: colorArray[1],
                                    b: colorArray[2],
                                    a: colorArray[3]
                                };
                            }
                            printFeatureLayerOptions.mode = service.queryMode;
                            var where = serviceLayer.getDefinitionExpression();
                            if (where) {
                                printFeatureLayerOptions.where = where;
                            }
                            if (serviceLayer.renderer) {
                                printFeatureLayerOptions.renderer = serviceLayer.renderer.toJson();
                            }
                            printFeatureLayerOptions.selectedFeatures = [];
                            var selectedFeatures = serviceLayer.getSelectedFeatures();
                            if (selectedFeatures && selectedFeatures.length > 0) {
                                var objIdField = serviceLayer.objectIdField;
                                if (objIdField) {
                                    for (var k = 0; k < selectedFeatures.length; k++) {
                                        var graphic = selectedFeatures[k];
                                        if (graphic.attributes) {
                                            var objId = graphic.attributes[objIdField];
                                            if (objId) {
                                                printFeatureLayerOptions.selectedFeatures.push(objId);
                                            }
                                        }
                                    }
                                }
                            }
                            printFeatureLayerOptionsCollection.push(printFeatureLayerOptions);
                        }
                    }
                    if (layerDefinitions.length > 0) {
                        layerDefinitions = "{" + layerDefinitions + "}";
                        jn.layerDefinitions = layerDefinitions;
                    }
                    // Check if we have anything for the layers parameter
                    if (prepString.length > 0) {
                        jn.layers = prepString;
                    }
                    // Check if we have any opacity specified
                    if (opacity.length > 0) {
                        jn.opacity = opacity;
                    }
                }
                if (printFeatureLayerOptionsCollection.length > 0) {
                    jn.featureLayerOptions = printFeatureLayerOptionsCollection;
                }
                // Check if the output format should be specified
                if (this.outputFormat) {
                    jn.outputFormat = this.outputFormat;
                }
                if (this.featureIds) {
                    jn.featureIds = this.featureIds;
                }
                // Check if the dpi has been specified
                if (this.resolution) {
                    jn.dpi = this.resolution.dpi;
                }
                if (this.mapGraphicsLayers) {
                    jn.graphics = this.mapGraphicsLayers.layers;
                    jn.symbols = this.mapGraphicsLayers.symbols;
                }
                if (this.includeData) {
                    jn.of = jn.of ? jn.of + ",includeData" : "includeData";
                }
                if (this.includeGeoreferenceData) {
                    jn.georef = this.includeGeoreferenceData;
                }
                if (this.useTransparentBackground) {
                    jn.useTransparentBackground = this.useTransparentBackground;
                }
                // Add each field 
                for (var fieldIx = 0; fieldIx < this.fields.length; fieldIx++) {
                    var f = this.fields[fieldIx];
                    jn[f.id] = f.value;
                }
                // Check if a grid has been specified
                if (this.grid) {
                    jn.grid = this.grid.id;
                }
                return jn;
            };
            /**
             * Extracts the geometries and symbols from the map graphics layers.
             * @param esriMap The {@link esri.Map} that contains the graphics layers.
             */
            ReportParameters.prototype.populateMapGraphicsLayers = function (esriMap) {
                this.mapGraphicsLayers = { layers: [], symbols: [] };
                this._extractGraphicInformation(esriMap.graphics, this.mapGraphicsLayers.layers, this.mapGraphicsLayers.symbols);
                for (var ix = 0; ix < esriMap.graphicsLayerIds.length; ix++) {
                    var layer = esriMap.getLayer(esriMap.graphicsLayerIds[ix]);
                    // Check for layer.url here is because there might be some client-side feature layers 
                    // that are added to the map(this senario is common when you have Web map references in your site).
                    if (layer.visible && !(layer instanceof esri.layers.FeatureLayer && layer.url)) {
                        this._extractGraphicInformation(layer, this.mapGraphicsLayers.layers, this.mapGraphicsLayers.symbols);
                    }
                }
            };
            ReportParameters.prototype._extractGraphicInformation = function (layer, layers, symbols) {
                for (var graphicIx = 0; graphicIx < layer.graphics.length; graphicIx++) {
                    var graphic = layer.graphics[graphicIx];
                    if (graphic.visible) {
                        // Make a temporary placeholder for the geometry so we can aggregate any symbols.
                        // The properties on this object will be symbolID and geometry.  The symbolID will
                        // correspond to the id of a symbol object in the symbols array supplied as a
                        // parameter.
                        var temp = {};
                        var tempSymbol = null;
                        if (graphic.symbol) {
                            tempSymbol = graphic.symbol;
                        }
                        else {
                            if (layer.renderer && layer.renderer.getSymbol) {
                                tempSymbol = layer.renderer.getSymbol(graphic);
                                graphic.symbol = tempSymbol;
                            }
                        }
                        if (!tempSymbol) {
                            continue;
                        }
                        symbols.push(tempSymbol);
                        // Checking existing symbols to see if current symbol has already been added
                        for (var j = 0; j < (symbols.length - 1); j++) {
                            if (symbols[j] == tempSymbol) {
                                temp.symbolID = symbols[j].id;
                                tempSymbol.id = temp.symbolID;
                                symbols.pop();
                                break;
                            }
                        }
                        if (temp.symbolID == undefined) {
                            var lastSymbolIndex = symbols.length - 1;
                            if (symbols[lastSymbolIndex] instanceof esri.symbol.TextSymbol) {
                                symbols[lastSymbolIndex] = geocortex.essentials.utilities.PrintUtilities.adjustTextSymbol(graphic, layer.id);
                            }
                            else if (symbols[lastSymbolIndex] instanceof esri.symbol.PictureMarkerSymbol) {
                                symbols[lastSymbolIndex] = geocortex.essentials.utilities.PrintUtilities.adjustPictureMarkerSymbol(graphic);
                            }
                            temp.symbolID = (symbols.length - 1).toString();
                            symbols[temp.symbolID].id = temp.symbolID;
                        }
                        temp.geometry = graphic.geometry;
                        // this will hold the collection of geometries and the opacity which will be added to the layer
                        layers.push({ elements: [temp], opacity: layer.opacity });
                    }
                }
            };
            /**
             * String constant representing the current extent of the map.
             * @private
             */
            ReportParameters.CURRENT_EXTENT = "currentExtent";
            /**
             * String constant representing a custom extent.
             * @private
             */
            ReportParameters.CUSTOM_EXTENT = "customExtent";
            /**
             * String constant representing the full extent of the map.
             * @private
             */
            ReportParameters.FULL_EXTENT = "fullExtent";
            /**
             * String constant representing the initial extent.
             * @private
             */
            ReportParameters.INITIAL_EXTENT = "initialExtent";
            return ReportParameters;
        }());
        essentials.ReportParameters = ReportParameters;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="MapGrid.ts" />
/// <reference path="../essentials.ts" />
/// <reference path="RestHelper.ts" />
/// <reference path="ReportParameters.ts" />
/// <reference path="TextField.ts" />
/// <reference path="Resolution.ts" />
/// <reference path="Scale.ts" />
/// <reference path="Site.ts" />
/// <reference path="Extension.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var PrintTemplate = (function (_super) {
            __extends(PrintTemplate, _super);
            /**
             * Initializes a new instance of the {@link PrintTemplate} class.
             * @param url The URL to the REST endpoint of the {@link PrintTemplate}.
             */
            function PrintTemplate(url) {
                _super.call(this, url);
                /** The description of the {@link PrintTemplate}. */
                this.description = null;
                /** The display name of the {@link PrintTemplate}. */
                this.displayName = null;
                /** The extensions of the {@link PrintTemplate}, as defined by an administrator. */
                this.extensions = [];
                /** The ID of the {@link PrintTemplate}. */
                this.id = null;
                /** The visibility of the {@link PrintTemplate}.*/
                this.visible = null;
                /** The maximum resolution at which this template can be printed. */
                this.maximumResolution = 300;
                /** The properties of the {@link PrintTemplate}, defined by the administrator on the server. */
                this.properties = null;
                /** The {@link Site} that the {@link PrintTemplate} belongs to. */
                this.site = null;
                /** The collection of supported {@link geocortex.essentials.Scale}s for the {@link PrintTemplate}. */
                this.supportedMapScales = [];
                /** The collection of supported output formats for the {@link PrintTemplate}. */
                this.supportedOutputFormats = [];
                /** The collection of supported {@link Resolution} settings for the {@link PrintTemplate}. */
                this.supportedResolutions = [];
                /** Whether or not this print template supports asynchronous execution providing an email to the user upon completion. */
                this.supportsEmailNotification = false;
                /** The collection of {@link TextField} for the {@link PrintTemplate}. */
                this.textFields = [];
                /** The map grids (for example, graticules) that are available for the print template. */
                this.grids = [];
                /** The type of report. One of {@link ReportType}. (currently only supporting `MAP_TEMPLATE_REPORT`). */
                this.type = geocortex.essentials.ReportType.MAP_TEMPLATE_REPORT;
                /** Whether or not this print template is default. */
                this.isDefault = false;
                /** Default map scale for this print template. */
                this.defaultMapScale = null;
                /** Default map scale name for this print template. */
                this.defaultMapScaleName = null;
                /** Default resolution for this print template. */
                this.defaultResolution = null;
                /** Default grid for this print template. */
                this.defaultGrid = null;
                /** Default output format for this print template. */
                this.defaultOutputFormat = null;
                /** @private */
                this._printing = false;
                /** @private */
                this._onPrintComplete = null;
                /** @private */
                this._onPrintError = null;
                this.extensions = [];
                this.properties = [];
                this.supportedMapScales = [];
                this.supportedOutputFormats = [];
                this.supportedResolutions = [];
                this.textFields = [];
            }
            /**
             * Gets whether the {@link PrintTemplate} is currently being printed.
             * @return {Boolean} True if a print operation is currently being performed, false otherwise.
             */
            PrintTemplate.prototype.isPrinting = function () {
                return this._printing;
            };
            /**
             * Prints the template using {@link ReportParameters}. This is an asynchronous
             * method, you may provide delegates for completion or error information.
             * @param printParameters The print parameters.
             * @param printComplete The delegate that will be called when the print has completed
             * (even if an error occurs). This delegate expects one argument: a string representing the URL of the prepared report.
             * @param  printError The delegate that will be called if an error occurs. This delegate expects two arguments: a reference to the PrintTemplate instance, and an Error.
             */
            PrintTemplate.prototype.print = function (printParameters, printComplete, printError) {
                var _this = this;
                // If it's already printing, return an error then retrun
                if (this.isPrinting()) {
                    if (printError) {
                        printError(new Error("Template already printing"));
                    }
                    return;
                }
                // Store the delegates for the end of the synchronous web method
                this._onPrintComplete = printComplete;
                this._onPrintError = printError;
                // Indicate that the printing is happening
                this._printing = true;
                // Print with the ExportContext
                var webMapParams = new geocortex.essentials.exportMap.ExportMapParameters();
                webMapParams.reportParameters = printParameters;
                var webMapBuilder = new geocortex.essentials.exportMap.ExportMapTask(this);
                webMapBuilder.generateMapImageUrl(webMapParams)
                    .then(function (result) { return _this._printRestComplete(result); }, function (e) { return _this._printRestError(e); });
            };
            PrintTemplate.prototype._configureObject = function (obj, deepInitialize) {
                if (obj === undefined || obj.id === undefined || obj.displayName === undefined) {
                    throw new Error("Incorrect print template object returned from initialization");
                }
                // Assign all the data
                this.description = obj.description === undefined ? this.description : obj.description;
                this.displayName = obj.displayName;
                this.id = obj.id;
                this.visible = obj.visible === undefined ? true : obj.visible;
                this.mainMapWidth = obj.mainMapWidth;
                this.mainMapHeight = obj.mainMapHeight;
                this.maximumResolution = obj.maximumResolution === undefined ? this.maximumResolution : obj.maximumResolution;
                this.supportedMapScales = obj.supportedScales === undefined ? this.supportedMapScales : obj.supportedScales;
                this.supportedOutputFormats = obj.supportedOutputFormats === undefined ? this.supportedOutputFormats : obj.supportedOutputFormats;
                this.supportedResolutions = obj.supportedResolutions === undefined ? this.supportedResolutions : obj.supportedResolutions;
                this.supportsEmailNotification = !!obj.supportsEmailNotification;
                this.textFields = obj.textFields === undefined ? this.textFields : obj.textFields;
                this.grids = obj.grids === undefined ? this.grids : obj.grids;
                if (deepInitialize) {
                    this.isInitialized = true;
                }
                this.properties = geocortex._getProperties(obj.properties);
                this.extensions = geocortex._getExtensions(obj.extensions);
                // GVH-2752: Support Print Template default configuration options 
                this.isDefault = obj.isDefault === undefined ? this.isDefault : obj.isDefault;
                this.defaultMapScaleName = obj.defaultMapScale === undefined ? null : obj.defaultMapScale;
                if (this.defaultMapScaleName) {
                    for (var i = 0; i < this.supportedMapScales.length; i++) {
                        if (this.defaultMapScaleName === this.supportedMapScales[i].displayName) {
                            this.defaultMapScale = this.supportedMapScales[i];
                        }
                    }
                }
                var defaultResolutionName = obj.defaultResolution === undefined ? null : obj.defaultResolution;
                if (defaultResolutionName) {
                    for (var i = 0; i < this.supportedResolutions.length; i++) {
                        if (defaultResolutionName === this.supportedResolutions[i].displayName) {
                            this.defaultResolution = this.supportedResolutions[i];
                        }
                    }
                }
                var defaultGridName = obj.defaultGrid === undefined ? null : obj.defaultGrid;
                if (defaultGridName) {
                    for (var i = 0; i < this.grids.length; i++) {
                        if (defaultGridName === this.grids[i].displayName) {
                            this.defaultGrid = this.grids[i];
                        }
                    }
                }
                this.defaultOutputFormat = obj.defaultOutputFormat === undefined ? this.defaultOutputFormat : obj.defaultOutputFormat;
            };
            /** @private */
            PrintTemplate.prototype._printRestComplete = function (results) {
                this._printing = false;
                var ex = null;
                if (!results) {
                    ex = new Error("Unexpected Error"); // very descriptive
                }
                else if (results.error) {
                    ex = results.error;
                }
                if (ex) {
                    if (this._onPrintError) {
                        this._onPrintError(ex);
                    }
                }
                else {
                    if (this._onPrintComplete) {
                        this._onPrintComplete(results);
                    }
                }
            };
            /** @private */
            PrintTemplate.prototype._printRestError = function (error) {
                this._printing = false;
                if (this._onPrintError) {
                    this._onPrintError(error);
                }
            };
            return PrintTemplate;
        }(essentials.AsyncInitializable));
        essentials.PrintTemplate = PrintTemplate;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="Site.ts" />
/// <reference path="../../../../_Definitions/arcgis-js-api.d.ts" />
/// <reference path="AsyncInitializable.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents a Named Extent defined by a {@link Site}.
         * Named Extents are geographical regions of interest that are defined for a {@link Site}.
         */
        var NamedExtent = (function (_super) {
            __extends(NamedExtent, _super);
            /**
             * Initializes a new instance of the {@link NamedExtent} class.
             * @param url The URL to the REST endpoint of the {@link NamedExtent}.
             */
            function NamedExtent(url) {
                _super.call(this, url);
                /** The display name of the {@link NamedExtent}. */
                this.displayName = null;
                /** The extensions of the {@link NamedExtent}, as defined by an administrator. */
                this.extensions = [];
                /** The extent of the {@link NamedExtent}. */
                this.extent = null;
                /** The ID of the {@link NamedExtent}.*/
                this.id = null;
                /** The properties of the {@link NamedExtent}, as defined by an administrator. */
                this.properties = {};
                /** The {@link Site} that the {@link NamedExtent} belongs to. */
                this.site = null;
            }
            /**
             * Zooms and pans the map to the extent defined in the {@link NamedExtent}. */
            NamedExtent.prototype.navigateTo = function () {
                if (this.site) {
                    var map = this.site.essentialsMap;
                    if (map) {
                        //replacing map.setExtent(this.extent); with the new extent manager call
                        map.extentManager.setExtentWithPriority(this.extent, 10);
                    }
                }
            };
            /** @private */
            NamedExtent.prototype._configureObject = function (obj, deepInitialize) {
                if (obj === undefined || obj.id === undefined || obj.displayName == undefined || obj.extent === undefined) {
                    throw new Error("Incorrect named extent object returned from initialization");
                }
                // Assign all the data
                this.id = obj.id;
                this.displayName = obj.displayName;
                this.extent = new esri.geometry.Extent(obj.extent);
                // add the properties
                this.properties = geocortex._getProperties(obj.properties);
                // add the extensions
                this.extensions = geocortex._getExtensions(obj.extensions);
            };
            return NamedExtent;
        }(essentials.AsyncInitializable));
        essentials.NamedExtent = NamedExtent;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="Site.ts" />
/// <reference path="AsyncInitializable.ts" />
/// <reference path="../essentials.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var GeoprocessingEndpoint = (function (_super) {
            __extends(GeoprocessingEndpoint, _super);
            /**
             * Creates a new instance of the {@link GeoprocessingEndpoint} class.
             * @param url The URL to the REST endpoint of the {@link GeoprocessingEndpoint}.
             */
            function GeoprocessingEndpoint(url) {
                _super.call(this, url);
                /** The display name of the {@link GeoprocessingEndpoint}. */
                this.displayName = null;
                /** The extensions of the {@link GeoprocessingEndpoint}, as defined by an administrator. */
                this.extensions = [];
                /** The ID of the {@link GeoprocessingEndpoint}. */
                this.id = null;
                /** The properties of the {@link GeoprocessingEndpoint}, as defined by an administrator. */
                this.properties = {};
                /** The type of {@link GeoprocessingEndpoint}, one of the {@link GeoprocessingEndpointType}s */
                this.geoprocessorType = null;
                /** The URL of the geoprocessor service published by ArcGIS Server. */
                this.geoprocessorUrl = null;
                /** The {@link Site} that the {@link GeoprocessingEndpoint} belongs to. */
                this.site = null;
            }
            /** @private */
            GeoprocessingEndpoint.prototype._configureObject = function (results) {
                if (results.id === undefined ||
                    results.displayName === undefined ||
                    results.connectionString === undefined) {
                    throw new Error("Incorrect geoprocessing endpoint object returned from initialization");
                }
                this.id = results.id;
                this.displayName = results.displayName;
                this.geoprocessorType = results.geoprocessorType || results.serviceType;
                this._processConnectionString(results.connectionString);
                this.properties = geocortex._getProperties(results.properties);
                this.extensions = geocortex._getExtensions(results.extensions);
            };
            /** @private */
            GeoprocessingEndpoint.prototype._processConnectionString = function (connectionString) {
                var extractValue = geocortex.essentials.ServiceHelper.extractConnectionStringValue;
                if (this.geoprocessorType === geocortex.essentials.GeoprocessingEndpointType.ARCGIS_GEOPROCESSOR) {
                    // Check if we have the url
                    var extractedUrl = extractValue(connectionString, "url");
                    if (extractedUrl && extractedUrl.length > 0) {
                        this.geoprocessorUrl = extractedUrl;
                    }
                }
                else {
                    throw new Error("Unknown geoprocessor type '" + this.geoprocessorType + "'");
                }
            };
            return GeoprocessingEndpoint;
        }(essentials.AsyncInitializable));
        essentials.GeoprocessingEndpoint = GeoprocessingEndpoint;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/** @private */
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var GeoprocessingEndpointType;
        (function (GeoprocessingEndpointType) {
            GeoprocessingEndpointType.ARCGIS_GEOPROCESSOR = "ArcGisGeoprocessor";
        })(GeoprocessingEndpointType = essentials.GeoprocessingEndpointType || (essentials.GeoprocessingEndpointType = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="Site.ts" />
/// <reference path="AsyncInitializable.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents a geometry service endpoint defined by a {@link geocortex.essentials.Site}.
         */
        var GeometryEndpoint = (function (_super) {
            __extends(GeometryEndpoint, _super);
            /**
             * Initializes a new instance of the {@link GeometryEndpoint} class.
             * @param url The URL to the REST endpoint of the {@link GeometryEndpoint}.
             */
            function GeometryEndpoint(url) {
                _super.call(this, url);
                /** The display name of the configured {@link GeometryEndpoint}. */
                this.displayName = null;
                /** The extensions of the {@link GeometryEndpoint}, as defined by the administrator on the server. */
                this.extensions = [];
                /** The ID of the {@link GeometryEndpoint}. */
                this.id = null;
                /** * The properties of the {@link geocortex.essentials.GeometryEndpoint}, as defined by the administrator on the server. */
                this.properties = {};
                /** The type of {@link geocortex.essentials.GeometryEndpoint}, one of the {@link GeometryEndpointType}s. */
                this.geometryServiceType = null;
                /** The URL of the geometry service published by ArcGIS Server. */
                this.geometryServiceUrl = null;
                /** The security token that must be provided when requesting the service from ArcGIS Server. */
                this.geometryServiceToken = null;
                /** The {@link Site} that the {@link GeometryEndpoint} belongs to. */
                this.site = null;
            }
            /** @private */
            GeometryEndpoint.prototype._configureObject = function (results) {
                if (results.id === undefined ||
                    results.displayName === undefined ||
                    results.connectionString === undefined) {
                    throw new Error("Incorrect geometry endpoint object returned from initialization");
                }
                // Assign all the data
                this.id = results.id;
                this.displayName = results.displayName;
                this.geometryServiceType = results.serviceType;
                this._processConnectionString(results.connectionString);
                // add the properties
                this.properties = geocortex._getProperties(results.properties);
                // add the extensions
                this.extensions = geocortex._getExtensions(results.extensions);
            };
            /** @private */
            GeometryEndpoint.prototype._processConnectionString = function (connectionString) {
                var extractValue = geocortex.essentials.ServiceHelper.extractConnectionStringValue;
                if (this.geometryServiceType === geocortex.essentials.GeometryEndpointType.ARCGIS_GEOMETRY) {
                    // Check if we have the url
                    var extractedUrl = extractValue(connectionString, "url");
                    if (extractedUrl && extractedUrl.length > 0) {
                        // <jeffg> This line referred to geometryUrl (not geometryServiceUrl) before the TS port
                        this.geometryServiceUrl = extractedUrl;
                    }
                    this.geometryServiceToken = extractValue(connectionString, "token");
                }
                else {
                    console.error("Unknown geometry service type '" + this.geometryServiceType + "'");
                }
            };
            return GeometryEndpoint;
        }(essentials.AsyncInitializable));
        essentials.GeometryEndpoint = GeometryEndpoint;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var GeometryEndpointType;
        (function (GeometryEndpointType) {
            GeometryEndpointType.ARCGIS_GEOMETRY = "ArcGisGeometry";
        })(GeometryEndpointType = essentials.GeometryEndpointType || (essentials.GeometryEndpointType = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /** @docs-hide-from-nav */
        var ServiceHelper = (function () {
            function ServiceHelper() {
            }
            /**
             * Retrieves the value of the supplied key from the supplied connection
             * string parameter.  The connection string is assumed to be in
             * key=value format, with key-value pairs separated by semicolons
             *
             * @param params The full connection string containing the key the caller
             * is looking to find the value for.
             * @param key The key for the value being searched.
             * @returns {String} the string value corresponding to the supplied key;
             * or an empty string if no such key is found in the supplied params.
             */
            ServiceHelper.extractConnectionStringValue = function (params, key) {
                if (params.length > 0) {
                    var pairValue = params.match("(^|;)[\s]*" + key + "=([^;]*)");
                    if (pairValue !== null) {
                        return pairValue[2];
                    }
                    else {
                        return "";
                    }
                }
                return "";
            };
            return ServiceHelper;
        }());
        essentials.ServiceHelper = ServiceHelper;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="ServiceHelper.ts" />
/// <reference path="Site.ts" />
/// <reference path="AsyncInitializable.ts" />
/// <reference path="../essentials.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var GeocodingEndpoint = (function (_super) {
            __extends(GeocodingEndpoint, _super);
            /**
             * Creates a new instance of the {@link GeocodingEndpoint} class.
             * @param url The URL to the REST endpoint of the {@link GeocodingEndpoint}.
             */
            function GeocodingEndpoint(url) {
                _super.call(this, url);
                /**
                 * The parameters supplied for creation of a Bing geocoder through the connection string.
                 * This object will be null for any GeocodingEndpoint
                 * which is not a Bing geocoder.
                 */
                this.bingProperties = null;
                /** The display name of the {@link GeocodingEndpoint}. */
                this.displayName = null;
                /** The extensions of the {@link GeocodingEndpoint}. The extensions are defined by the administrator on the server. */
                this.extensions = [];
                /** The ID used to reference the {@link GeocodingEndpoint}. */
                this.id = null;
                /** The properties of the {@link GeocodingEndpoint}. The properties are defined by the administrator on the server. */
                this.properties = {};
                /** The type of {@link GeocodingEndpoint}, representing by a value from {@link GeocodingEndpointType}. */
                this.geocoderType = null;
                /**
                 * The URL of the geocoder service published by ArcGIS Server, if the {@link geocoderType} of this GeocodingEndpoint is 'ArcGisGeocoder'.
                 * If this is a Bing geocoder, this value will be null.
                 */
                this.geocoderUrl = null;
                /**
                 * The security token that must be provided when requesting the service from ArcGIS Server, if the {@link geocoderType} of
                 * this GeocodingEndpoint is 'ArcGisGeocoder'. If this is a Bing geocoder, this value will be null.
                 */
                this.geocoderToken = null;
                /** Whether or not this particular geocoder should be invoked when a user performs a global search operation. */
                this.includeInGlobalSearch = false;
                /** Icon Uri for this geocoding service. */
                this.iconUri = null;
                /** Whether this geocoding endpoint is the default endpoint for reverse geocode operations. */
                this.isDefaultReverseGeocoder = false;
                /** The {@link Site} that the {@link GeocodingEndpoint} belongs to. */
                this.site = null;
                /** The geocoding endpoint parameters of {@link GeocodingEndpoint}. */
                this.parameters = [];
                /** The global search key of {@link GeocodingEndpoint}. */
                this.globalSearchKey = null;
                /** Whether or not this particular geocoder is the default for batch geocoding. */
                this.isDefaultBatchGeocoder = false;
            }
            /** @private */
            GeocodingEndpoint.prototype._configureObject = function (results) {
                // Make sure we have the required properties for a geocoder
                if (!(results.hasOwnProperty("id") &&
                    results.hasOwnProperty("displayName") &&
                    results.hasOwnProperty("serviceType") &&
                    results.hasOwnProperty("connectionString") &&
                    results.hasOwnProperty("globalSearchKey") &&
                    results.hasOwnProperty("parameters"))) {
                    throw new Error("Incorrect geocoding endpoint object returned from initialization");
                }
                this.id = results.id;
                this.displayName = results.displayName;
                this.iconUri = results.iconUri;
                this.geocoderType = results.serviceType;
                this.includeInGlobalSearch = results.includeInGlobalSearch;
                this.isDefaultReverseGeocoder = results.isDefaultReverseGeocoder;
                this.globalSearchKey = results.globalSearchKey;
                this.isDefaultBatchGeocoder = results.isDefaultBatchGeocoder;
                this._processConnectionString(results.connectionString);
                this.properties = geocortex._getProperties(results.properties);
                this.extensions = geocortex._getExtensions(results.extensions);
                this.parameters = results.parameters;
            };
            /** @private */
            GeocodingEndpoint.prototype._processConnectionString = function (connectionString) {
                var extractValue = geocortex.essentials.ServiceHelper.extractConnectionStringValue;
                if (this.geocoderType === geocortex.essentials.GeocodingEndpointType.BING_GEOCODER) {
                    this.bingProperties = {};
                    var prop = extractValue(connectionString, "key");
                    if (prop && prop.length > 0) {
                        this.bingProperties.bingMapsKey = prop;
                    }
                    prop = extractValue(connectionString, "culture");
                    if (prop && prop.length > 0) {
                        this.bingProperties.culture = prop;
                    }
                }
                else if (this.geocoderType === geocortex.essentials.GeocodingEndpointType.ARCGIS_GEOCODER) {
                    // Check if we have the url
                    var extractedUrl = extractValue(connectionString, "url");
                    if (extractedUrl && extractedUrl.length > 0) {
                        this.geocoderUrl = extractedUrl;
                    }
                    this.geocoderToken = extractValue(connectionString, "token");
                }
                else {
                    console.error("Unknown geocoder type '" + this.geocoderType + "'");
                }
            };
            return GeocodingEndpoint;
        }(essentials.AsyncInitializable));
        essentials.GeocodingEndpoint = GeocodingEndpoint;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var GeocodingEndpointType;
        (function (GeocodingEndpointType) {
            GeocodingEndpointType.ARCGIS_GEOCODER = "ArcGisGeocoder";
            GeocodingEndpointType.BING_GEOCODER = "BingGeocoder";
        })(GeocodingEndpointType = essentials.GeocodingEndpointType || (essentials.GeocodingEndpointType = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="StringUtilities.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var utilities;
        (function (utilities) {
            /**
             * Utility methods for comparing resource IDs.
             * @private
             */
            var SiteResourceIdComparer = (function () {
                function SiteResourceIdComparer() {
                }
                /**
                 * Determines if one string is equal to another string.
                 * @param resourceId The resource ID to compare.
                 * @param match The string to compare for a possible match.
                 */
                SiteResourceIdComparer.equals = function (resourceId, match) {
                    if (resourceId && match) {
                        // Added last "||" statement because tiled map services have a layer.id of "layer0", or "layer1", instead of "0", or "1" that dynamic services have
                        if (resourceId === match || utilities.StringUtilities.endsWith(resourceId, this.separator + match)) {
                            return true;
                        }
                    }
                    return false;
                };
                /**
                 * Looks up the matching ID in the resources array and returns the found item.
                 * @param resourceArray The resource array to check for `match`. Elements in the array must have an `id` property.
                 * @param match the string value to check the resource array for.
                 */
                SiteResourceIdComparer.lookUp = function (resourceArray, match) {
                    if (resourceArray && match) {
                        var i = 0;
                        var resource = null;
                        for (i = 0; i < resourceArray.length; ++i) {
                            resource = resourceArray[i];
                            if (resource.id === match) {
                                return resource;
                            }
                        }
                        for (i = 0; i < resourceArray.length; ++i) {
                            resource = resourceArray[i];
                            if (utilities.StringUtilities.endsWith(resource.id, this.separator + match)) {
                                return resource;
                            }
                        }
                    }
                    return null;
                };
                SiteResourceIdComparer.separator = "-";
                return SiteResourceIdComparer;
            }());
            utilities.SiteResourceIdComparer = SiteResourceIdComparer;
        })(utilities = essentials.utilities || (essentials.utilities = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="Principal.ts" />
/// <reference path="Site.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /** Internal helper class used to assist in security related actions. */
        var SecurityHelper = (function () {
            function SecurityHelper() {
                this.finished = false;
                this.id = new Date().valueOf().toString();
                this.scripts = [];
            }
            SecurityHelper.getCurrent = function () {
                var current = window.security;
                return current && !current.finished ? current : null;
            };
            SecurityHelper.beginRefresh = function (site) {
                if (SecurityHelper.getCurrent() != null) {
                    return false;
                }
                var helper = new SecurityHelper();
                helper.site = site;
                if (!helper.getExpirationNoticeUrl()) {
                    return false;
                }
                if (!helper.getRefreshUrl()) {
                    return false;
                }
                window.security = helper;
                helper.openFrame();
                return true;
            };
            SecurityHelper.cancel = function () {
                var current = SecurityHelper.getCurrent();
                return current && current.finish();
            };
            /**
             * This refresh method uses the system browser which is assumed to not be the
             * current browser.
             */
            SecurityHelper.prototype.openSystemBrowser = function () {
                var _this = this;
                var refreshUrl = this.getRefreshUrl() + "&app=" + this.site.signInRedirectUri + "&token_type=fragment";
                // On GMAF iOS we need a special form to tell Cordova to open the system browser.
                // When GMAF iOS removes Cordova this can go away.
                var refreshTarget = /GeocortexApp\.iOS/.test(navigator.userAgent) ? "_system" : "_blank";
                var onPopState = function () {
                    var hash = location.hash;
                    if (hash.length > 0 && hash.startsWith("#gcx-")) {
                        if (window.removeEventListener) {
                            window.removeEventListener("popstate", onPopState, false);
                        }
                        else if (window.detachEvent) {
                            // For IE 8 compatibility.
                            window.detachEvent("onpopstate", onPopState);
                        }
                        var token = hash.substring(5);
                        _this.sendRequest(_this.site.url + "?f=json&callback=security.updateSitePrincipal&token=" + token);
                    }
                };
                // IE 8 doesn't support addEventListener, use attachEvent instead
                if (window.addEventListener) {
                    window.addEventListener("popstate", onPopState, false);
                }
                else if (window.attachEvent) {
                    // For IE 8 compatibility.
                    window.attachEvent("onpopstate", onPopState);
                }
                window.open(refreshUrl, refreshTarget);
            };
            /**
             * This is the preferred refresh method.  If this fails we won't hear back from the frame
             * and will decide to open the popup.
             */
            SecurityHelper.prototype.openFrame = function () {
                var _this = this;
                this.frame = document.createElement("iframe");
                this.frame.name = "SignInHelper";
                this.frame.style.display = "none";
                document.body.appendChild(this.frame);
                // GE-4447 D3 Remark below to avoid the iframe from doing the refresh.
                var isGmaf = /\bGeocortexApp\b/.test(navigator.userAgent);
                if (isGmaf) {
                    // frame.src works well in GMAF. Using window.open() in GMAF for iOS causes the system browser to open (GMAF-1021)
                    this.frame.src = "SignInHelper.html";
                }
                else {
                    // Window.open() is the way we've always done it, so I'm leaving it this
                    // way for browsers to avoid mucking anything up. - Jeff S. 
                    window.open("SignInHelper.html", "SignInHelper");
                    window.setTimeout(function () { return _this.openPopup(); }, 15000);
                }
            };
            /**
             * This is the second choice refresh method.
             */
            SecurityHelper.prototype.openPopup = function () {
                if (this.finished) {
                    return;
                }
                this.sendRequest(this.getExpirationNoticeUrl() + "?f=json&part=_html&callback=security.showContent");
                // GE-4447 D3 Remark below to avoid the popup from occurring automatically.
                window.open("SignInHelper.html", "_blank");
            };
            SecurityHelper.prototype.getExpirationNoticeUrl = function () {
                if (!this.site.principal) {
                    return null;
                }
                if (!this.site.principal.urls) {
                    return null;
                }
                return this.site.principal.urls.expirationNotice;
            };
            SecurityHelper.prototype.getRefreshUrl = function () {
                if (!this.site.principal) {
                    return null;
                }
                if (!this.site.principal.urls) {
                    return null;
                }
                return this.site.principal.urls.refresh;
            };
            SecurityHelper.prototype.sendRequest = function (url) {
                if (this.finished) {
                    return;
                }
                // This is using JSON-P style, do not change to use xhr. The browser must be the one
                // to actually initiate this request as it runs in the context of the user which is
                // important for "federated sign-in" techniques.
                //
                // I'm wielding a pitch fork as I write this comment. -Garth Pickell
                var script = document.createElement("script");
                script.style.display = "none";
                document.body.appendChild(script);
                this.scripts.push(script);
                script.type = "text/javascript";
                script.src = url + "&rid=" + this.id;
            };
            SecurityHelper.prototype.showContent = function (response) {
                if (this.finished) {
                    return false;
                }
                if (response.rid != this.id) {
                    return false;
                }
                if (this.dialog && this.dialog.parentNode) {
                    this.dialog.parentNode.removeChild(this.dialog);
                }
                this.dialog = document.createElement("div");
                this.dialog.innerHTML = response.content;
                document.body.appendChild(this.dialog);
                return true;
            };
            /**
             * Called from the SignInHelper, both before and after token refresh.  If there's a token in the hash
             * then refresh has happened, otherwise refresh must start.
             * @param hash
             * @param href
             * @returns The URL to redirect to if redirect should happen.
             */
            SecurityHelper.prototype.handleSignIn = function (hash, href) {
                if (this.finished) {
                    return null;
                }
                if (hash.length > 0 && hash.startsWith("#gcx-")) {
                    var token = hash.substring(5);
                    this.sendRequest(this.site.url + "?f=json&callback=security.updateSitePrincipal&token=" + token);
                }
                else {
                    var appParam = "";
                    if (this.site.principal.urls.referrer == null) {
                        appParam = "&app=" + encodeURIComponent(href);
                    }
                    return this.getRefreshUrl() + appParam + "&token_type=fragment";
                }
                return null;
            };
            SecurityHelper.prototype.finish = function () {
                if (this.finished) {
                    return false;
                }
                this.finished = true;
                while (this.scripts.length > 0) {
                    var script = this.scripts.pop();
                    script.parentNode.removeChild(script);
                }
                if (this.dialog && this.dialog.parentNode) {
                    this.dialog.parentNode.removeChild(this.dialog);
                }
                if (this.frame && this.frame.parentNode) {
                    this.frame.parentNode.removeChild(this.frame);
                }
                return true;
            };
            SecurityHelper.prototype.updateSitePrincipal = function (rawSite) {
                if (this.finished) {
                    return false;
                }
                if (rawSite.rid != this.id) {
                    return false;
                }
                this.finish();
                this.site.updatePrincipal(rawSite.principal);
                console.log("Updated Principal (Refresh Successful)");
                return true;
            };
            /**
             * Always returns false.
             * @deprecated Sign in used to be performed in the system browser for GMAF.
             * As of GMAF 2.0.1, sign in is done within GMAF, and so this method just returns false now.
             */
            SecurityHelper.prototype.useSystemBrowser = function () {
                return false;
            };
            return SecurityHelper;
        }());
        essentials.SecurityHelper = SecurityHelper;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="RestHelperHTTPService.ts" />
/// <reference path="../essentials.ts" />
/// <reference path="FeatureLayerService.ts" />
/// <reference path="../../../../_Definitions/arcgis-js-api.d.ts" />
/// <reference path="../../../../_Definitions/LayerList.Rest.d.ts" />
/// <reference path="Workflow.ts" />
/// <reference path="WebMapReference.ts" />
/// <reference path="PrintTemplate.ts" />
/// <reference path="NamedExtent.ts" />
/// <reference path="AsyncInitializable.ts" />
/// <reference path="GeoprocessingEndpoint.ts" />
/// <reference path="GeometryEndpoint.ts" />
/// <reference path="GeocodingEndpoint.ts" />
/// <reference path="Extension.ts" />
/// <reference path="Map.ts" />
/// <reference path="ArcGisPortalSecurityContext.ts" />
/// <reference path="utilities/SiteResourceIdComparer.ts" />
/// <reference path="Principal.ts" />
/// <reference path="SecurityHelper.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents a Geocortex Essentials {@link Site} that is configured on the server and accessed via a REST endpoint.
         * You must call the {@link initialize} method on the {@link Site} before using it.
         * To determine if the {@link Site} has already been initialized, check the {@link AsyncInitializable.isInitialized} property.
         * The {@link Site} is initialized asynchronously, so you must attach an event handler to determine when the initialization has finished.
         * You can also attach a handler to the event that will report initialization errors.
         */
        var Site = (function (_super) {
            __extends(Site, _super);
            /**
             * Initializes a new instance of the {@link Site} class.
             * @param url URL to a Geocortex Essentials {@link Site} endpoint.
             * @param map The {@link esri.Map} object with which this {@link Site} will be associated.
             */
            function Site(url, map) {
                _super.call(this, url);
                /** The current version of the Geocortex Essentials serving the {@link Site}. */
                this.currentVersion = null;
                /**
                 * The default data provider (e.g. "Oracle", "SqlServer", etc.) for all map services and layers in this site.
                 * Individual map services and layers may have overridden this default.
                 */
                this.dataProvider = null;
                /**
                 * Whether or not to initialize this site with a complete representation of the
                 * {@link Site} in REST (deep initialization).  If false, the different components of
                 * the {@link Site} such as the map will be initialized with a separate HTTP call after
                 * the {@link Site} has been retrieved.
                 */
                this.deepInitialize = false;
                /** The display name of the {@link Site}. */
                this.displayName = null;
                /** The Document Store of the Essentials instance. */
                this.documentStore = new essentials.documents.DocumentStore();
                /** The interval period (in seconds) for updating the secured map services tokens. */
                this.updateInterval = null;
                /** The Essentials {@link Map} defined in the {@link Site}. */
                this.essentialsMap = null;
                /** The extensions of the {@link Site}, as defined by the administrator on the server. */
                this.extensions = [];
                /** The {@link GeocodingEndpoint}s defined in the {@link Site}.*/
                this.geocodingEndpoints = [];
                /** The {@link GeometryEndpoint}s defined in the {@link Site}. */
                this.geometryEndpoints = [];
                /** The {@link GeoprocessingEndpoint}s defined in the {@link Site}. */
                this.geoprocessingEndpoints = [];
                /** The configurable layer list rest endpoint defined in the {@link Site}. */
                this.layerListRestEndpoint = null;
                /** Whether the {@link Site} contains any geocoding endpoints. */
                this.hasGeocodingEndpoints = false;
                /** Whether the {@link Site} contains any geometry endpoints. */
                this.hasGeometryEndpoints = false;
                /** Whether the {@link Site} contains any geoprocessing endpoints. */
                this.hasGeoprocessingEndpoints = false;
                /** Whether the {@link Site} contains a collection of {@link NamedExtent} objects. */
                this.hasNamedExtents = false;
                /** Whether the {@link Site} contains a north arrow configuration. */
                this.hasNorthArrow = false;
                /** Whether the {@link Site} contains time slider information */
                this.hasTimeSliders = false;
                /** Whether the {@link Site} contains an overview map. */
                this.hasOverviewMap = false;
                /** Whether the {@link Site} contains a collection of {@link PrintTemplate} objects. */
                this.hasPrintTemplates = false;
                /** Whether the {@link Site} has any configured viewers. */
                this.hasViewers = false;
                /** Whether the {@link Site} has a virtual directory defined. */
                this.hasVirtualDirectory = false;
                /** Whether the {@link Site} contains a collection of {@link Workflow} objects. */
                this.hasWorkflows = false;
                /** Whether the {@link Site} contains a collection of {@link SearchTable} objects. */
                this.hasSearchTables = false;
                /** Whether the {@link Site} contains a collection of {@link WebMapReference} objects. */
                this.hasWebMaps = false;
                /** The ID of the {@link Site}. */
                this.id = null;
                /** Collection of {@link NamedExtent} objects associated with the {@link Site}. */
                this.namedExtents = [];
                /** The overview {@link Map} defined in the {@link Site}. */
                this.overviewMap = null;
                /** Collection of {@link PrintTemplate} objects associated with the {@link Site}. */
                this.printTemplates = [];
                /** The properties of the {@link Site}, as defined by the administrator on the server.*/
                this.properties = {};
                /** Collection of {@link TimeSliderProfile} objects associated with the {@link Site} */
                this.timeSliders = [];
                /** The trusted urls of the {@link Site}, as defined by the administrator on the server.*/
                this.trustedUrls = [];
                /** Collection of {@link LayerCatalog} objects associated with the {@link Site}. */
                this.layerCatalogs = [];
                /** A boolean indicating that the esri service layers have been loaded in the map */
                this.serviceLayersLoaded = false;
                /** The URL to a Geocortex Essentials {@link Site}'s REST endpoint. */
                this.url = null;
                /**
                 * Collection of {@link Workflow} objects associated with the {@link Site}. */
                this.workflows = [];
                /** Collection of {@link SearchTable} objects associated with the {@link Site}.
                  Note: To use Search Tables with a version of Essentials prior to 4.5, you must use "deep initialization" with the site. GVH does this always. */
                this.searchTables = [];
                /**  The IANA ID of the time zone in which this site's field data are current. */
                this.timeZoneId = null;
                /** The IANA ID of the time zone in which this site's field data should be displayed. */
                this.displayTimeZoneId = null;
                /**
                 * The object that represents information about web maps and
                 * the collection of {@link WebMapReference} objects associated with the {@link Site}.
                 */
                this.webMapsInfo = { layerTypes: null, webMaps: [] };
                /**
                 * An optional configuration preprocessor - a function to process the configuration in place before parsing and loading.
                 * After initialization, this is nulled out.
                 */
                this.configPreprocessor = null;
                /** Occurs when an Esri {@link esri.layers.Layer} has loaded. */
                this.onLayerLoad = null;
                /** Occurs when a there is a problem loading an Esri layer. */
                this.onLayerLoadError = null;
                /** Occurs when the service layers have been loaded in the map. */
                this.onServiceLayersLoaded = function () { };
                /** Occurs when a federated sign in is initiated. */
                this.onSignIn = null;
                /** Occurs when sing out is initiated. */
                this.onSignOut = null;
                /** Occurs when the user cancels the sign in process. */
                this.onUserSignInCancelled = null;
                this.principal = {
                    isAuthenticated: false,
                    label: null,
                    identities: [],
                    policy: {},
                    urls: {},
                    tokens: {
                        arcgis: {},
                        geocortex: {},
                        site: null
                    }
                };
                this._geocodingEndpointsInitialized = false;
                this._geometryEndpointsInitialized = false;
                this._geoprocessingEndpointsInitialized = false;
                this._kmlServiceInitialized = false;
                this._mapInitialized = false;
                this._namedExtentsInitialized = false;
                this._overviewMapInitialized = false;
                this._printTemplatesInitialized = false;
                this._workflowsInitialized = false;
                this._searchTablesInitialized = false;
                this._timeSlidersInitialized = false;
                this._webMapsInitialized = false;
                this._initializedHandlerCalled = false;
                this._signInEnabled = false;
                this._signOutEnabled = false;
                /** @private - Handle to the setInterval code for updating tokens. In case we ever wanted to clearInterval. */
                this._tokenIntervalHandle = null;
                /** @private - A deferred that is stored while update tokens that can be returned if another call to update tokens is
                before the first call asyncrhonously completes. */
                this._serviceTokenRefresh = null;
                /** @private - Specifies if service tokens are currently stale because an update failed. This can happen while offline.
                When connectivity is restored, a call to updateServiceTokensIfStale() can be made to try again. */
                this._serviceTokensStale = false;
                this.originalUrl = url;
                this.url = essentials.utilities.UrlUtilities.simplify(url);
                this._esriMap = map;
            }
            /**
             * Initializes the {@link Site}.
             * This is an asynchronous method; for completion information, subscribe to the
             * {@link AsyncInitializable.onInitialized} and {@link AsyncInitializable.onInitializationFailed} events.
             *
             *     // Create a new empty ESRI map object
             *     var map = new esri.Map("map");
             *
             *     // Create a new Site object, supplying a URL to the REST endpoint
             *     // of an existing Essentials site, and the map object just created
             *     var essentialsSite = new geocortex.essentials.Site("http://sampleserver1.geocortex.com/geocortex/essentials/rest/sites/CharlotteArcGISOnline", map);
             *
             *     // Hook up events for when the initialization of the site completes,
             *     // and if it fails to initialize
             *     dojo.connect(essentialsSite, "onInitialized", site_Initialized);
             *     dojo.connect(essentialsSite, "onInitializationFailed", site_InitializationFailed);
             *
             *     // Initialize the site, which will load all configured layers into the ESRI map object
             *     essentialsSite.initialize();
             */
            Site.prototype.initialize = function () {
                var _this = this;
                this._detectAndConfigureCors().then(function () {
                    _this._initialize();
                });
            };
            /**
             * Find the {@link Site} resource matching the specified ID.
             * @param resources The array of resources to look up.
             * @param resourceId The ID of the resource to find.
             */
            Site.prototype.getResourceById = function (resources, resourceId) {
                return geocortex.essentials.utilities.SiteResourceIdComparer.lookUp(resources, resourceId);
            };
            /**
             * Find the {@link Workflow} matching the specified ID.
             * @param workflowId The ID of the {@link Workflow} to find.
             */
            Site.prototype.findWorkflowById = function (workflowId) {
                // used to also be findWorkflowById
                return this.getResourceById(this.workflows, workflowId);
            };
            /**
             * Find the {@link PrintTemplate} matching the specified ID.
             * @param templateId The ID of the print template to find.
             */
            Site.prototype.findPrintTemplateById = function (templateId) {
                // used to also be findPrintTemplateById
                return this.getResourceById(this.printTemplates, templateId);
            };
            /**
             * Get all the {@link FeatureLayerService} objects defined in the site. */
            Site.prototype.getFeatureServices = function () {
                var results = [];
                if (!this.essentialsMap) {
                    return results;
                }
                for (var i = 0; i < this.essentialsMap.mapServices.length; i++) {
                    var mapService = this.essentialsMap.mapServices[i];
                    if (mapService instanceof geocortex.essentials.FeatureLayerService) {
                        results.push(mapService);
                    }
                }
                return results;
            };
            /**
             * Gets the Esri {@link esri.Map} control.
             */
            Site.prototype.getMap = function () {
                return this._esriMap;
            };
            Site.prototype.getEssentialsVersion = function () {
                var version = 3.0;
                if (this.currentVersion) {
                    var versionSegments = this.currentVersion.split(".");
                    if (versionSegments.length >= 2) {
                        var majorMinorVersionString = versionSegments[0] + "." + versionSegments[1];
                        version = parseFloat(majorMinorVersionString);
                    }
                }
                return version;
            };
            Site.prototype.getDefaultBatchGeocoder = function () {
                var defaultBatchGeocoder = geocortex.framework.utils.ArrayUtils.firstOrDefault(this.geocodingEndpoints, function (x) { return x.isDefaultBatchGeocoder; });
                if (!defaultBatchGeocoder && this.geocodingEndpoints.length > 0) {
                    defaultBatchGeocoder = this.geocodingEndpoints[0];
                }
                return defaultBatchGeocoder;
            };
            /**
             * Performs a search query operation.
             * This is an asynchronous method, you may provide delegates for completion or error information.
             * @param queryParams The parameters for the search query.
             * @param searchBegin The delegate that will be called when the operation has started.
             * @param searchComplete The delegate that will be called when the operation has completed, even if an error occurs.
             * @param searchError The delegate that will be called if an error occurs during the operation.
             */
            Site.prototype.search = function (queryParams, searchBegin, searchComplete, searchError) {
                var _this = this;
                if (searchBegin) {
                    searchBegin(queryParams);
                }
                try {
                    var searchUrl = this.url + "/search";
                    var urlParams = {};
                    if (queryParams && queryParams.toJson) {
                        urlParams = queryParams.toJson(this.getMap(), this.essentialsMap);
                    }
                    var content = geocortex.encodeJson(dojo.mixin({ f: "json" }, urlParams));
                }
                catch (e2) {
                    if (searchError) {
                        searchError(e2);
                    }
                    return;
                }
                var onComplete = function (restResponse) {
                    // Get ready to output results
                    var results = new essentials.SearchResults();
                    results.queryParams = queryParams;
                    if (!restResponse) {
                        results.error = new Error("Unexpected Error"); // very descriptive
                    }
                    else {
                        // Parse the server json response into JSAPI objects
                        _this._parseSearchResponse(results, restResponse);
                    }
                    // Invoke the error delegate if there were errors
                    if (results.error && searchError) {
                        searchError(results.error);
                    }
                    // The search complete delegate should be called when the operation has completed, even if an error occurs.
                    if (searchComplete) {
                        searchComplete(results);
                    }
                };
                var onError = function (error) {
                    if (searchError) {
                        searchError(error);
                    }
                };
                // GVH-3420 Only issue a search request when there are searchable map services.
                if (content.hasOwnProperty("layers") && content.layers) {
                    geocortex.request({
                        url: searchUrl,
                        content: content,
                        load: onComplete,
                        error: onError,
                        callbackParamName: "CallBack"
                    });
                }
            };
            /** @private */
            Site.prototype._parseSearchResponse = function (searchResults, jsonObject) {
                if (!jsonObject) {
                    throw new Error("_parseSearchResponse: required jsonObject argument was not supplied.");
                }
                // Check for error as part of the json response
                if (jsonObject.hasOwnProperty("error") && jsonObject.error && jsonObject.error.message) {
                    searchResults.error = new Error(jsonObject.error.message);
                }
                else if (jsonObject.hasOwnProperty("ResponseStatus") && jsonObject.ResponseStatus && jsonObject.ResponseStatus.ErrorCode) {
                    searchResults.error = new Error(jsonObject.ResponseStatus.Message);
                    searchResults.error.name = jsonObject.ResponseStatus.ErrorCode;
                }
                else if (jsonObject.hasOwnProperty("features")) {
                    // Check that we have results
                    var featureSetContainer = this._createFeatureSets(jsonObject.features, searchResults.queryParams.returnHighlights);
                    // Add feature sets to results collection
                    for (var p in featureSetContainer) {
                        if (!featureSetContainer.hasOwnProperty(p)) {
                            continue;
                        }
                        searchResults.results.push(featureSetContainer[p]);
                    }
                }
            };
            /**
             * Create the feature sets coming from Geocortex search endpoint.
             * @private
             */
            Site.prototype._createFeatureSets = function (jsonArray, includeHighlights) {
                var featureSetContainer = {};
                for (var j = 0; j < jsonArray.length; j++) {
                    var jsonFeature = jsonArray[j];
                    // GE-4017 Instant Search results should contain Essentials MapServiceId and LayerId values
                    var mapServiceId = jsonFeature.hasOwnProperty("mapServiceId") ? jsonFeature.mapServiceId : null;
                    var layerId = jsonFeature.hasOwnProperty("layerId") ? jsonFeature.layerId : null;
                    // Determine its layer
                    var mapService = this.essentialsMap.findMapServiceById(mapServiceId);
                    var gcxLayer = mapService ? mapService.findLayerOrTableById(layerId) : null;
                    // Results must be associated with a Geocortex layer
                    if (gcxLayer) {
                        // Hydrate a feature
                        var feature = this._createFeature(jsonFeature, gcxLayer, includeHighlights);
                        // Create a new feature set if needed
                        if (!featureSetContainer.hasOwnProperty(gcxLayer.url)) {
                            featureSetContainer[gcxLayer.url] = new essentials.SearchResultSet({ "layer": gcxLayer });
                        }
                        // Add the feature to its feature set
                        featureSetContainer[gcxLayer.url].features.push(feature);
                    }
                }
                return featureSetContainer;
            };
            /**
             * Create a result feature coming from Geocortex search endpoint.
             * @private
             */
            Site.prototype._createFeature = function (jsonFeature, layer, includeHighlights) {
                if (!jsonFeature) {
                    throw new Error("_createSearchFeature: required jsonFeature argument was not supplied.");
                }
                // Hydrate a graphic
                var graphic = this._jObjectToGraphic(jsonFeature);
                // Create the Geocortex search result feature
                var feature = new essentials.SearchResultFeature(graphic, layer);
                // Add its highlights (if available)
                if (includeHighlights) {
                    this._assignHighlights(feature, jsonFeature);
                }
                return feature;
            };
            /** @private */
            Site.prototype._jObjectToGraphic = function (jobject) {
                if (!jobject) {
                    throw new Error("_jObjectToGraphic: required jobject argument was not supplied.");
                }
                // Load in its geometry
                var esriGeom = null;
                if (jobject.hasOwnProperty("geometry") && jobject.geometry) {
                    esriGeom = esri.geometry.fromJson(jobject.geometry);
                    // The default value for the spatialReference is coming from Esri, even when we don't give it a spatial reference.
                    if (esriGeom && esriGeom.spatialReference && !jobject.geometry.spatialReference) {
                        // Geocortex Search indexes all features in Geographic coord system (4326).
                        // Unless an out spatial ref has already been specified, make sure to set it to 4326
                        esriGeom.spatialReference = new esri.SpatialReference(4326);
                    }
                }
                // Load up its attributes
                var attributes = {};
                if (jobject.hasOwnProperty("attributes") && jobject.attributes) {
                    attributes = JSON.parse(JSON.stringify(jobject.attributes));
                }
                return new esri.Graphic(esriGeom, null, attributes, null);
            };
            /** @private */
            Site.prototype._assignHighlights = function (feature, jobject) {
                if (!feature) {
                    throw new Error("_assignHighlights: required feature argument was not supplied.");
                }
                if (!jobject) {
                    throw new Error("_assignHighlights: required jobject argument was not supplied.");
                }
                // Load up the highlights (if available)
                var highlights = {};
                if (jobject.hasOwnProperty("highlights") && jobject.highlights) {
                    highlights = JSON.parse(JSON.stringify(jobject.highlights));
                }
                feature.highlights = highlights;
            };
            /** @private */
            Site.prototype._initAsyncCollection = function (results, urlPath, memberCollection, objectType) {
                if (results && memberCollection && objectType) {
                    for (var i = 0; results && i < results.length; i++) {
                        memberCollection[i] = new objectType(this.url + "/" + urlPath + "/" + results[i].id);
                        memberCollection[i].site = this;
                        memberCollection[i]._configureObject(results[i]);
                        if (this.deepInitialize === true && objectType !== geocortex.essentials.Workflow) {
                            memberCollection[i].isInitialized = true;
                        }
                    }
                }
                this._siteInitializeUpdate();
            };
            /** @private */
            Site.prototype._initAsyncCollectionErrorHandler = function (setInitializedDelegate, error) {
                // Indicate that the collection has finished initialization (albeit with an error)
                setInitializedDelegate();
                this._initializationFailedHandler(error);
                this._siteInitializeUpdate();
            };
            /** @private */
            Site.prototype._initGeocodingEndpointsHandler = function (results) {
                this._geocodingEndpointsInitialized = true;
                if (results) {
                    this._initAsyncCollection(results.geocodingEndpoints, "geocoding", this.geocodingEndpoints, geocortex.essentials.GeocodingEndpoint);
                }
            };
            /** @private */
            Site.prototype._initGeometryEndpointsHandler = function (results) {
                this._geometryEndpointsInitialized = true;
                if (results) {
                    this._initAsyncCollection(results.geometryEndpoints, "geometry", this.geometryEndpoints, geocortex.essentials.GeometryEndpoint);
                }
            };
            /** @private */
            Site.prototype._initKmlEndpointHandler = function (result) {
                this._kmlServiceInitialized = true;
                if (result && result.connectionString) {
                    // Extract the URL from the connection string
                    var url = geocortex.essentials.ServiceHelper.extractConnectionStringValue(result.connectionString, "url");
                    if (url) {
                        esri.config.defaults.kmlService = url;
                    }
                }
            };
            /**
             * Gets the layer catalog asynchronously.
             * @param catalogParams The application.
             * @param loadBegin The callback to run when loading begins.
             * @param loadComplete The callback to run when loading completes.
             * @param loadError The callback to run when loading errors.
             */
            Site.prototype.getLayerCatalog = function (catalogParams, loadBegin, loadComplete, loadError) {
                var url = this.url + "/catalog/layercatalog/getcatalog";
                loadBegin();
                var onComplete = function (restResponse) {
                    loadComplete(restResponse);
                };
                geocortex.request({
                    url: url,
                    content: {
                        "f": "json"
                    },
                    load: onComplete,
                    error: loadError,
                    callbackParamName: "CallBack"
                });
            };
            /**
             * Gets the layer catalog details asynchronously.
             * @param catalogParams The application.
             * @param loadBegin The callback to run when loading begins.
             * @param loadComplete The callback to run when loading completes.
             * @param loadError The callback to run when loading errors.
             */
            Site.prototype.getLayerCatalogDetails = function (catalogParams, loadBegin, loadComplete, loadError) {
                var url = this.url + "/catalog/layercatalog/getcatalogdetails";
                var content = {};
                content.ids = catalogParams.ids.join();
                content.f = "json";
                loadBegin();
                var onComplete = function (restResponse) {
                    loadComplete(restResponse);
                };
                geocortex.request({
                    url: url,
                    content: content,
                    load: onComplete,
                    error: loadError,
                    callbackParamName: "CallBack"
                });
            };
            /**
             * Gets the offline basemaps asynchronously.
             * @param catalogParams The application.
             * @param loadComplete The callback to run when loading completes.
             * @param loadError The callback to run when loading errors.
             */
            Site.prototype.getOfflineBasemaps = function (loadComplete, loadError) {
                if (loadError === void 0) { loadError = function () { }; }
                var url = this.url + "/offlinebasemaps";
                if (typeof loadComplete != "function") {
                    throw new Error("loadComplete must be a function.");
                }
                geocortex.request({
                    url: url,
                    content: {
                        "f": "json"
                    },
                    load: function (result) {
                        if (result.error) {
                            loadError(new Error(result.error.message));
                        }
                        else if (result.basemaps) {
                            loadComplete(result.basemaps);
                        }
                        else {
                            loadError(new Error("Unexpected result: " + JSON.stringify(result)));
                        }
                    },
                    error: loadError,
                    callbackParamName: "CallBack"
                });
            };
            /** @private */
            Site.prototype._initGeoprocessingEndpointsHandler = function (results) {
                this._geoprocessingEndpointsInitialized = true;
                if (results) {
                    this._initAsyncCollection(results.geoprocessingEndpoints, "geoprocessing", this.geoprocessingEndpoints, geocortex.essentials.GeoprocessingEndpoint);
                }
            };
            /**
              * Responsible for scraping the token supplied by a sign-in response.
              * @private
              */
            Site._getTokenFromFragment = function () {
                var href = window.location.href;
                var offset = href.indexOf("#gcx-");
                if (offset >= 0) {
                    var token = href.substring(offset + 5);
                    window.location.replace("#");
                    return token;
                }
                return null;
            };
            /**
             * Appends a query parameter to a URL.
             * @private
             * @param url An existing URL.
             * @param param One or more "name=value" parameter(s) to add to the URL.
             * @return The original URL with the given query parameters added.
             */
            Site._addQueryParameter = function (url, param) {
                var urlParts = url.split("#", 2);
                url = urlParts[0];
                var fragment = urlParts.length > 1 ? urlParts[1] : "";
                return url + (url.indexOf("?") > -1 ? "&" : "?") + param + fragment;
            };
            /**
             * Determines whether the current user is able to sign in.
             */
            Site.prototype.canSignIn = function () {
                return this._signInEnabled
                    && !!this.principal
                    && !!this.principal.urls.signIn
                    && !this.principal.isAuthenticated
                    && !!this.principal.policy
                    && this.principal.policy.issuers.length > 0;
            };
            /**
             * Initiates a federated sign in.
             * @private
             * @param principal An optional argument that will take the {@link Principal} to sign in with explicitly.
             * @param url An optional sign-in URL to use, otherwise the principal's default URL will be used.
             */
            Site.prototype._signIn = function (principal, url) {
                if (!principal) {
                    principal = this.principal;
                }
                if (!url) {
                    url = principal.urls.signIn;
                }
                if (principal.policy === undefined) {
                    principal.policy = {};
                }
                var hints = principal.policy.hints;
                if (hints) {
                    url = Site._addQueryParameter(url, hints);
                }
                url = Site._addQueryParameter(url, "token_type=fragment");
                if (this.signInRedirectUri && url.indexOf("app=") < 0) {
                    url = Site._addQueryParameter(url, "app=" + encodeURIComponent(this.signInRedirectUri));
                }
                else if (!principal.urls.referrer && url.indexOf("app=") < 0) {
                    url = Site._addQueryParameter(url, "app=" + encodeURIComponent(window.location.toString()));
                }
                if (this.onSignIn) {
                    this.onSignIn({ url: url });
                }
                if (window.addEventListener) {
                    window.addEventListener("popstate", function () {
                        // Now that we've tried to sign in, if the location changes to include the token then we should
                        // reload to reinitialize using that token.
                        if (location.hash.startsWith("#gcx-")) {
                            location.reload();
                        }
                    }, false);
                }
                window.location.assign(url);
            };
            /**
             * Initiates a federated sign in.
             * @param url An optional sign-in URL to use, otherwise the principal's default URL will be used.
             */
            Site.prototype.signIn = function (url) {
                this._signIn(this.principal, url);
            };
            /**
             * Determines whether the current user is able to sign out.
             */
            Site.prototype.canSignOut = function () {
                return this._signOutEnabled
                    && !!this.principal
                    && this.principal.isAuthenticated
                    && !!this.principal.urls.signOut;
            };
            /**
             * Initiates a single sign out. NOTE: This will invalidate the security session for all applications
             * using the REST API. In other words, sign out for every application that signed in using our REST API.
             */
            Site.prototype.signOut = function () {
                if (this.onSignOut) {
                    this.onSignOut();
                }
                var url = this.principal.urls.signOut;
                if (this.signOutRedirectUri) {
                    url = Site._addQueryParameter(url, "app=" + encodeURIComponent(this.signOutRedirectUri));
                }
                else if (this._signOutRedirectUrl) {
                    url = Site._addQueryParameter(url, "app=" + encodeURIComponent(this._signOutRedirectUrl));
                }
                window.location.assign(url);
            };
            /**
              * Allows resources to find the token for a given resource pertaining to the current user.
              * @param url The url of the resource that is being accessed.
              * @param serviceType The type of the resource being accessed.
              * @returns Returns the appropriate token for the given type.
              */
            Site.prototype.getTokenFromPrincipal = function (url, type) {
                // Lets select the right token group.
                // There should be a better way to figure out if the service is an "ArcGIS service".
                var tokens = null;
                if (type === essentials.MapServiceType.DYNAMIC) {
                    tokens = this.principal.tokens.arcgis;
                }
                else if (type === essentials.MapServiceType.FEATURE) {
                    tokens = this.principal.tokens.arcgis;
                }
                else if (type === essentials.MapServiceType.IMAGE) {
                    tokens = this.principal.tokens.arcgis;
                }
                else if (type === essentials.MapServiceType.TILED) {
                    tokens = this.principal.tokens.arcgis;
                }
                else if (type === essentials.MapServiceType.WEBTILED) {
                    tokens = this.principal.tokens.arcgis;
                }
                else if (type === essentials.MapServiceType.VECTORTILE) {
                    tokens = this.principal.tokens.arcgis;
                }
                else if (type === esri.IdentityManagerBase) {
                    tokens = this.principal.tokens.arcgis;
                }
                else if (type === geocortex.essentials.Site) {
                    tokens = (_a = {},
                        _a[this.url] = this.principal.tokens.site,
                        _a
                    );
                }
                // If we do not know, just bail.
                if (!tokens) {
                    return null;
                }
                // For case insensitive matching.
                url = url.toLowerCase();
                // Get an anchor so that we can use the browser's parsing semantics for our purposes.
                var location = document.createElement("a");
                location.href = url.toLowerCase();
                // We will need to use the location later on, so squirrel things away.
                var protocol = location.protocol;
                var hostname = location.hostname;
                var port = location.port;
                url = location.href;
                // Now the fun part, the realm can be a domain suffix, scheme-less URL, or a full URL.
                // We have to find the realm that matches the given URL.
                for (var key in tokens) {
                    var realm = key.toLowerCase();
                    if (hostname == realm) {
                        // We matched the hostname explicitly, so use the token.
                        return tokens[key];
                    }
                    if (hostname.endsWith("." + realm)) {
                        // We matched the hostname implicitly, so use the token.
                        return tokens[key];
                    }
                    try {
                        location.href = protocol + "://" + realm;
                        location.port = port;
                        if (url.startsWith(location.href)) {
                            // We matched the scheme-less url, so use the token.
                            return tokens[key];
                        }
                    }
                    catch (e) {
                    }
                    try {
                        location.href = realm;
                        if (url.startsWith(location.href)) {
                            // We matched the url, so use the token.
                            return tokens[key];
                        }
                    }
                    catch (e) {
                    }
                }
                return null;
                var _a;
            };
            Site.prototype._updateDefaultToken = function (token) {
                if (typeof token === "string") {
                    var url = this.url;
                    var tailIndex = Math.max(url.indexOf("?"), url.indexOf("#"));
                    if (tailIndex >= 0) {
                        url = url.substr(0, tailIndex);
                    }
                    // Strip ending /s.
                    url = /^(.*?)\/*$/.exec(url)[1];
                    essentials.RestHelperHTTPService.setDefaultToken(token, url + "/../../");
                }
            };
            /**
             * Detects if CORS is both necessary (Essentials is on a different origin than the host page) and enabled.
             * If so, the corsEnabledServers are updated to include the Essentials server host.
             * @return A deferred that is resolved when the detection is complete. The deferred is never rejected.
             * @private
             */
            Site.prototype._detectAndConfigureCors = function () {
                var promise = new dojo.Deferred();
                if (window["geocortexDisableEssentialsCorsDetection"]) {
                    // CORS detection is disabled. Just return the resolved promise.
                    promise.resolve();
                    return promise;
                }
                var siteUrlComponents = essentials.utilities.UrlUtilities.getUrlComponents(this.url);
                var hostPageComponents = essentials.utilities.UrlUtilities.getUrlComponents(window.location.href);
                if (siteUrlComponents.origin === hostPageComponents.origin) {
                    // CORS not necessary
                    promise.resolve();
                    return promise;
                }
                // Detect CORS - this detection relies on the /info rest resource which will exist in Essentials 4.5 and beyond
                // Note that this detection will fail even if CORS is enabled on Essentials 4.4 or below because the info resource
                // does not exist. That's OK. esri.request will fall back to using JSONP and the proxy.
                var match = /(.*\/+)sites\/+[^\/]*\/?$/i.exec(this.url) || [];
                var essentialsRestBase = match[1];
                if (!essentialsRestBase) {
                    // Regex failed - unit test perhaps, or some other scenario?
                    promise.resolve();
                }
                else {
                    var infoUrl = essentialsRestBase + "info?f=json";
                    dojo.xhrGet({
                        url: infoUrl
                    }).then(function (result) {
                        // CORS enabled - add the Essentials server to the list of cors enabled servers for esri.request
                        esri.config.defaults.io.corsEnabledServers.push(siteUrlComponents.host); // host property includes the port if non-default - this is what we want
                        promise.resolve();
                    }, function (error) {
                        // CORS not enabled
                        promise.resolve();
                    });
                }
                return promise;
            };
            /**
             * Initializes the {@link Site} from the server.
             * {@link Site} needs to override the base initialize because it needs to initialize from more than one rest endpoint.</p>
             * @private
             */
            Site.prototype._initialize = function () {
                var _this = this;
                // If it is already initialized or is _initializing, then exit
                if (this.isInitialized || this._initializing) {
                    return;
                }
                // Get the token from the fragment, and scope it to the root of the REST API.
                var token = Site._getTokenFromFragment();
                this._updateDefaultToken(token);
                // Listen for address changes that gives us the token.
                if (!token) {
                    var onPopState = function () {
                        // Only take the first change and only if we're still initializing.
                        if (window.removeEventListener) {
                            window.removeEventListener("popstate", onPopState, false);
                        }
                        else if (window.detachEvent) {
                            // For IE 8 compatibility.
                            window.detachEvent("onpopstate", onPopState);
                        }
                        if (!_this.isInitialized && _this._initializing) {
                            var token = Site._getTokenFromFragment();
                            if (token) {
                                // We got a token.  Retry site initialization.
                                _this._updateDefaultToken(token);
                                geocortex.request({
                                    url: _this.url,
                                    content: {
                                        "f": "json",
                                        "deep": _this.deepInitialize
                                    },
                                    load: dojo.hitch(_this, _this._verifySiteDependencies),
                                    error: dojo.hitch(_this, _this._initSiteErrorHandler),
                                    callbackParamName: "CallBack"
                                });
                            }
                        }
                    };
                    // IE 8 doesn't support addEventListener, use attachEvent instead
                    if (window.addEventListener) {
                        window.addEventListener("popstate", onPopState, false);
                    }
                    else if (window.attachEvent) {
                        // For IE 8 compatibility.
                        window.attachEvent("onpopstate", onPopState);
                    }
                }
                // Reset the flag so the initialized handler does get called
                this._initializedHandlerCalled = false;
                // Indicate that the initialization is happening
                this._initializing = true;
                geocortex.request({
                    url: this.url,
                    content: {
                        "f": "json",
                        "deep": this.deepInitialize
                    },
                    load: dojo.hitch(this, this._verifySiteDependencies),
                    error: dojo.hitch(this, this._initSiteErrorHandler),
                    callbackParamName: "CallBack"
                });
            };
            /** @private */
            Site.prototype._initMapHandler = function (sender) {
                this._mapInitialized = true;
                // Make sure we have the map object
                if (sender !== null) {
                    if (sender.site !== null) {
                        sender.loadServiceLayersInMap(sender.site.getMap());
                    }
                }
                this._siteInitializeUpdate();
            };
            /** @private */
            Site.prototype._initMapErrorHandler = function (error) {
                this._mapInitialized = true;
                this._initializationFailedHandler(error);
                this._siteInitializeUpdate();
            };
            /** @private */
            Site.prototype._initNamedExtentsHandler = function (results) {
                this._namedExtentsInitialized = true;
                if (results) {
                    this._initAsyncCollection(results.namedExtents, "namedextents", this.namedExtents, geocortex.essentials.NamedExtent);
                }
            };
            Site.prototype._initTimeSlidersHandler = function (results) {
                this._timeSlidersInitialized = true;
                if (results) {
                    this._initAsyncCollection(results.timeSliders, "timesliders", this.timeSliders, geocortex.essentials.TimeSliderProfile);
                }
            };
            /** @private */
            Site.prototype._initOverviewMapHandler = function () {
                this._overviewMapInitialized = true;
                this._siteInitializeUpdate();
            };
            /** @private */
            Site.prototype._initOverviewMapErrorHandler = function (error) {
                this._overviewMapInitialized = true;
                this._initializationFailedHandler(error);
                this._siteInitializeUpdate();
            };
            /** @private */
            Site.prototype._initPrintTemplatesHandler = function (results) {
                var _this = this;
                var completedAjaxRequests = 0;
                this._printTemplatesInitialized = true;
                // Sometimes the result being passed in is the site object. If so, then we do not need to pull
                // from the endpoint(s) below.
                if (results.printTemplates.length > 0) {
                    if (results.printTemplates[0].visible != null) {
                        this._initAsyncCollection(results.printTemplates, "printtemplates", this.printTemplates, geocortex.essentials.PrintTemplate);
                        return;
                    }
                }
                // Populate the individual templates with the values stored at REST endpoint.
                // GVH-4063 - invidiual print template information was not being pulled from REST endpoint.
                results.printTemplates.forEach(function (x) {
                    geocortex.request({
                        url: _this.url + "/printtemplates/" + x.id,
                        content: {
                            f: "json"
                        },
                        load: function (value) {
                            completedAjaxRequests++;
                            results.printTemplates.forEach(function (current) {
                                if (current.id === value.id) {
                                    // For now only the visible value is of importance - maybe a more fleshed out function
                                    // to pull in all relevant information in the future?
                                    current.visible = value.visible;
                                }
                            });
                            // Only initialize the collection once all ajax requests have completed.
                            if (completedAjaxRequests === results.printTemplates.length) {
                                _this._initAsyncCollection(results.printTemplates, "printtemplates", _this.printTemplates, geocortex.essentials.PrintTemplate);
                            }
                        },
                        callbackParamName: "CallBack"
                    });
                });
            };
            /**
             * Refreshes the services tokens if they're currently stale. Otherwise returns a
             * resolved deferred.
             */
            Site.prototype.updateServiceTokensIfStale = function () {
                if (!this._serviceTokensStale) {
                    var resolved = new dojo.Deferred();
                    resolved.resolve();
                    return resolved;
                }
                return this._getUpdatedServiceTokens();
            };
            /**
             * Updates the service tokens for each of the token secured map services.
             * @private
             */
            Site.prototype._getUpdatedServiceTokens = function () {
                // If update is not required, then the updateInterval will be set to 0
                if (this.updateInterval === 0) {
                    var resolved = new dojo.Deferred();
                    resolved.resolve();
                    return resolved;
                }
                // If already in progress, just return the deferred
                if (this._serviceTokenRefresh) {
                    return this._serviceTokenRefresh;
                }
                this._serviceTokenRefresh = new dojo.Deferred();
                geocortex.request({
                    url: this.url + "/update",
                    content: {
                        f: "json"
                    },
                    load: dojo.hitch(this, this._processServiceTokensHandler),
                    error: dojo.hitch(this, this._processServiceTokensErrorHandler),
                    callbackParamName: "CallBack"
                });
                return this._serviceTokenRefresh;
            };
            /** @private */
            Site.prototype._processServiceTokensHandler = function (results) {
                var _this = this;
                if (results && results.mapServiceTokens) {
                    this._updateServiceTokens(this.essentialsMap, results.mapServiceTokens);
                }
                if (results && results.overviewMapServiceTokens) {
                    this._updateServiceTokens(this.overviewMap, results.overviewMapServiceTokens);
                }
                // Update tokens for geocoding endpoints.
                if (results.geocodingServiceTokens) {
                    results.geocodingServiceTokens.forEach(function (token) {
                        var endpoint = _this.geocodingEndpoints.filter(function (x) { return x.id === token.id; })[0];
                        if (endpoint) {
                            endpoint.geocoderToken = token.token;
                            dojo.publish("ServiceTokenRefreshed", { serviceUrl: endpoint.geocoderUrl, token: token.token });
                        }
                    });
                }
                // Update tokens for geometry endpoints.
                if (results.geometryServiceTokens) {
                    results.geometryServiceTokens.forEach(function (token) {
                        var endpoint = _this.geometryEndpoints.filter(function (x) { return x.id === token.id; })[0];
                        if (endpoint) {
                            endpoint.geometryServiceToken = token.token;
                            dojo.publish("ServiceTokenRefreshed", { serviceUrl: endpoint.geometryServiceUrl, token: token.token });
                        }
                    });
                }
                this._serviceTokenRefresh.resolve();
                this._serviceTokenRefresh = null;
                this._serviceTokensStale = false;
            };
            /** @private */
            Site.prototype._processServiceTokensErrorHandler = function (error) {
                this._serviceTokenRefresh.reject(error);
                this._serviceTokenRefresh = null;
                this._serviceTokensStale = true; // Because token refresh failed, the tokens are now potentially expired
                dojo.publish("ServiceTokenRefreshError", { error: error });
                throw error;
            };
            /** @private */
            Site.prototype._updateServiceTokens = function (map, tokens) {
                if (map && tokens) {
                    for (var i = 0; tokens && i < tokens.length; i++) {
                        var service = map.findMapServiceById(tokens[i].id);
                        if (service) {
                            service._updateServiceToken(tokens[i].token);
                        }
                    }
                }
            };
            /** @private */
            Site.prototype._updateServiceTokensFromPrincipal = function (map) {
                if (!map || !map.mapServices) {
                    return;
                }
                for (var i = 0; i < map.mapServices.length; i++) {
                    var service = map.mapServices[i];
                    if (service && service.serviceUrl) {
                        var token = this.getTokenFromPrincipal(service.serviceUrl, esri.IdentityManagerBase);
                        if (token) {
                            service._updateServiceToken(token);
                        }
                    }
                }
            };
            /** @private */
            Site.prototype._refreshPrincipal = function () {
                var _this = this;
                var args = {
                    site: this,
                    handled: false,
                    resumeRefresh: function () { return essentials.SecurityHelper.beginRefresh(_this); },
                    suspendRefresh: function () { return essentials.SecurityHelper.cancel(); }
                };
                dojo.publish("geocortex_sessionExpiring", args);
                if (!args.handled) {
                    args.resumeRefresh();
                }
            };
            /** @private */
            Site.prototype._refreshPrincipalAt = function (expiry, gracePeriod) {
                var _this = this;
                if (!expiry) {
                    return false;
                }
                var expiryDate = new Date(expiry).valueOf();
                // ECMAScript 5
                if (isNaN(expiryDate)) {
                    console.log("_refreshPrincipalAt: Date parse failed, most likely due to ECMAScript 5 support only. Using alternate method.");
                    expiryDate = Date.parse(expiry);
                    console.log("_refreshPrincipalAt: Parsed '" + expiry + "' as raw value '" + expiryDate.toString() + "'.");
                }
                // Compute amount of time from now to expiry, and then shave off some more (- gracePeriod).
                var ttl = expiryDate - new Date().valueOf() - gracePeriod;
                ttl = Math.max(10000, ttl);
                // Begin the timer.
                window.setTimeout(function () { return _this._refreshPrincipal(); }, ttl);
                return true;
            };
            /**
             * Updates the principal in the site with the given principal.
             * @param principal The principal to update the site with.
             */
            Site.prototype.updatePrincipal = function (principal) {
                this.principal = principal;
                this._refreshPrincipalAt(principal.expiry, 300000);
                this._updateDefaultToken(this.principal.tokens.site);
                // HACK
                // GVH-5172
                if (this.principal.tokens && this.principal.tokens.arcgis) {
                    this._updateServiceTokensFromPrincipal(this.essentialsMap);
                    this._updateServiceTokensFromPrincipal(this.overviewMap);
                }
            };
            /** @private */
            Site.prototype._getCredential = function (url, options) {
                var token = this.getTokenFromPrincipal(url, esri.IdentityManagerBase);
                var promise = new dojo.Deferred();
                if (token) {
                    var cred = new esri.Credential();
                    cred.token = token;
                    cred.server = this._getCredentialServer(url);
                    promise.resolve(cred);
                }
                else {
                    promise.reject(new Error("No token available for service {0}".format(url)));
                }
                return promise;
            };
            /**
             * Get the server as it should be formatter for the esri.Credential object.
             * @param url
             */
            Site.prototype._getCredentialServer = function (url) {
                var b = url.toLowerCase();
                var endIndex = b.indexOf("/rest/services");
                if (endIndex === -1) {
                    endIndex = b.indexOf("/sharing");
                }
                if (endIndex === -1 && "/" === b.substr(-1)) {
                    endIndex = b.length - 1;
                }
                return endIndex > -1 ? url.substring(0, endIndex) : url;
            };
            /** @private */
            Site.prototype._hookGetCredential = function () {
                var _this = this;
                var site = this;
                var newMethod = function (url, options) {
                    try {
                        return _this._getCredential(url, options);
                    }
                    catch (exception) {
                        console.log("Error getting site credential: " + exception);
                        var rejected = new dojo.Deferred();
                        rejected.reject(exception);
                        return rejected;
                    }
                };
                esri.IdentityManagerBase.prototype.getCredential = newMethod;
            };
            /** @private */
            Site.prototype._initSiteHandler = function (results) {
                var _this = this;
                this._hookGetCredential();
                // Verify that the results exist.
                if (!results) {
                    throw new Error("Incorrect site object returned from initialization");
                }
                if (this.configPreprocessor) {
                    this.configPreprocessor(results);
                    this.configPreprocessor = null;
                }
                // GE-7861 Add trusted urls.
                if (results.contentPolicy) {
                    if (geocortex.framework.utils.isNullOrUndefined(results.contentPolicy.trustedUrls)) {
                        this.trustedUrls = [];
                    }
                    else {
                        this.trustedUrls = results.contentPolicy.trustedUrls;
                    }
                }
                if (results.layerCatalogs) {
                    if (results.layerCatalogs.length == 0) {
                        this.layerCatalogs = [];
                    }
                    else {
                        for (var index = 0; index < results.layerCatalogs.length; index++) {
                            this.layerCatalogs[index] = new geocortex.essentials.LayerCatalog(results.layerCatalogs[index].siteId);
                        }
                    }
                }
                // Check if we need to authenticate with ArcGIS Portal
                if (results.principal) {
                    var principal = results.principal;
                    if (principal.policy === undefined) {
                        principal.policy = {};
                    }
                    if (principal.policy.authenticate && !principal.isAuthenticated) {
                        this._signIn(principal);
                        return;
                    }
                    this.principal = principal;
                    if (principal.isAuthenticated) {
                        // Raise the old event...
                        dojo.publish("geocortex_authenticationSucceeded", [{ username: principal.label, token: principal.tokens.site }]);
                    }
                    // GE-4447 D1 Change the value to something really large to get fairly quick refresh (10 seconds).
                    this._refreshPrincipalAt(this.principal.expiry, 300000);
                }
                else if (results.arcGisPortalAuthentication && results.arcGisPortalAuthentication.clientID) {
                    var portalAuth = results.arcGisPortalAuthentication;
                    this.arcGisPortalSecurityContext = new essentials.ArcGisPortalSecurityContext(portalAuth.url, portalAuth.domains, portalAuth.clientID);
                    // Perform token association or redirect
                    if (!this.arcGisPortalSecurityContext.initiate()) {
                        if (this.arcGisPortalSecurityContext.error) {
                            if (this.arcGisPortalSecurityContext.error.code == essentials.OAuth2Error.ACCESS_DENIED_ERROR_CODE) {
                                if (this.onUserSignInCancelled) {
                                    this.onUserSignInCancelled({
                                        tryAgainAction: dojo.hitch(this, function () {
                                            essentials.OAuth2Client.redirectToLogOnPage(this.arcGisPortalSecurityContext.getLogOnUrl(), this.arcGisPortalSecurityContext.clientId);
                                        })
                                    });
                                }
                            }
                            else {
                                var error = new Error();
                                error.name = this.arcGisPortalSecurityContext.error.code;
                                error.message = this.arcGisPortalSecurityContext.error.description;
                                this._initializationFailedHandler(error);
                            }
                        }
                        return;
                    }
                    essentials.RestHelperHTTPService.arcGisPortalToken = this.arcGisPortalSecurityContext.tokenResult;
                }
                this.hasGeocodingEndpoints = !!results.hasGeocodingEndpoints;
                this.hasGeometryEndpoints = !!results.hasGeometryEndpoints;
                this.hasGeoprocessingEndpoints = !!results.hasGeoprocessingEndpoints;
                this.hasNamedExtents = !!results.hasNamedExtents;
                this.hasNorthArrow = !!results.hasNorthArrow;
                this.hasTimeSliders = !!results.hasTimeSliders;
                this.hasOverviewMap = !!results.hasOverviewMap;
                this.hasPrintTemplates = !!results.hasPrintTemplates;
                this.hasViewers = !!results.hasViewers;
                this.hasVirtualDirectory = !!results.hasVirtualDirectory;
                this.hasWorkflows = !!results.hasWorkflows;
                this.hasSearchTables = !!results.hasSearchTables;
                this.hasWebMaps = !!results.hasWebMaps;
                this.dataProvider = results.dataProvider;
                this.displayName = results.displayName;
                this.id = results.id;
                this._signInEnabled = !!results.signInEnabled;
                this._signOutEnabled = !!results.signOutEnabled;
                this._signOutRedirectUrl = results.signOutRedirectUrl;
                this.timeZoneId = results.timeZoneId;
                this.displayTimeZoneId = results.displayTimeZoneId;
                // If currentVersion is not present, we're dealing with 3.0
                if (results.currentVersion === undefined) {
                    this.currentVersion = "3.0";
                }
                else {
                    this.currentVersion = results.currentVersion;
                }
                if (results.hasOwnProperty("updateInterval")) {
                    this.updateInterval = parseInt(results.updateInterval);
                    if (isNaN(this.updateInterval)) {
                        this.updateInterval = 0;
                    }
                }
                else {
                    this.updateInterval = 0;
                }
                // Auto-refresh the Site token, if the Site is secured via token.
                var blockStore = geocortex.essentials.RestHelperHTTPService.getAuthenticationControlBlockStore();
                var controlBlock = blockStore.find(this.url);
                if (controlBlock) {
                    // Auto-refresh every (X - 2) minutes, where X is the token duration.
                    setInterval(function () {
                        var helper = new geocortex.essentials.RestHelperHTTPService();
                        helper._requestToken(controlBlock);
                    }, Math.max(60 * 1000, (geocortex.essentials.RestHelper.tokenDurationMinutes * 60 * 1000) - (2 * 60 * 1000)));
                }
                // Set up automatic refresh interval to grab updated tokens, with a minimum interval of 60 seconds.
                if (this.updateInterval > 0) {
                    // Set the update interval code
                    this._tokenIntervalHandle = setInterval(function () {
                        _this._getUpdatedServiceTokens();
                    }, Math.max(60, this.updateInterval * 1000));
                }
                // add the properties
                this.properties = geocortex._getProperties(results.properties);
                // add the extensions
                this.extensions = geocortex._getExtensions(results.extensions);
                this.essentialsMap = new geocortex.essentials.Map(this.originalUrl + "/map");
                this.essentialsMap.site = this;
                dojo.connect(this.essentialsMap, "onInitialized", dojo.hitch(this, this._initMapHandler));
                dojo.connect(this.essentialsMap, "onInitializationFailed", dojo.hitch(this, this._initMapErrorHandler));
                if (this.hasOverviewMap) {
                    this.overviewMap = new geocortex.essentials.Map(this.originalUrl + "/overviewmap");
                    this.overviewMap.site = this;
                    dojo.connect(this.overviewMap, "onInitialized", dojo.hitch(this, this._initOverviewMapHandler));
                    dojo.connect(this.overviewMap, "onInitializationFailed", dojo.hitch(this, this._initOverviewMapErrorHandler));
                }
                // If we have the layer list endpoint defined, populate it.
                if (results.map && results.map.layerList) {
                    this.layerListRestEndpoint = results.map.layerList;
                }
                // We need to finish the initialization (we didn't get deep initialization or we're not 3.3 or above)
                if (!this.deepInitialize || (this.getEssentialsVersion() < 3.3) || results.map === undefined) {
                    this.essentialsMap.initialize();
                    if (this.hasOverviewMap) {
                        this.overviewMap.initialize();
                    }
                    else {
                        // No overview map
                        this._overviewMapInitialized = true;
                    }
                    // Check if there are is a KML service endpoints
                    // NOTE: there is a known race condition when doing lazy initialization with a KML service 
                    // endpoint. The map initialization has already started when we make our request to the 
                    // KML service endpoint. If the map is able to initialize and create an instance of a KML
                    // layer and initialize it before we get the response back from the KML service endpoint 
                    // the KML layer will use the default KML service rather than the site defined one.
                    // To avoid this we would need to defer the map initialization until after the KML service
                    // is initialized. It is not worth the effort/risk to refactor this. KML layers are 
                    // not very common, overriding the KML service is rare. Non-deep site initialization is 
                    // very rare and only happens in custom applications where esri.config.defaults.kmlService
                    // could be set by the custom application.
                    if (results.hasKmlServiceEndpoint) {
                        // Get the KML service endpoint
                        geocortex.request({
                            url: this.url + "/kmlService",
                            content: {
                                f: "json"
                            },
                            load: dojo.hitch(this, this._initKmlEndpointHandler),
                            error: dojo.hitch(this, this._initAsyncCollectionErrorHandler, dojo.hitch(this, function () {
                                this._kmlServiceInitialized = true;
                            })),
                            callbackParamName: "CallBack"
                        });
                    }
                    else {
                        this._kmlServiceInitialized = true;
                    }
                    // Check if there are geocoding endpoints
                    if (this.hasGeocodingEndpoints) {
                        // Get the geocoding endpoints
                        geocortex.request({
                            url: this.url + "/geocoding",
                            content: {
                                f: "json"
                            },
                            load: dojo.hitch(this, this._initGeocodingEndpointsHandler),
                            error: dojo.hitch(this, this._initAsyncCollectionErrorHandler, dojo.hitch(this, function () {
                                this._geocodingEndpointsInitialized = true;
                            })),
                            callbackParamName: "CallBack"
                        });
                    }
                    else {
                        // No geocoding endpoints
                        this._geocodingEndpointsInitialized = true;
                    }
                    // Check if there are geometry endpoints
                    if (this.hasGeometryEndpoints) {
                        // Get the geometry endpoints
                        geocortex.request({
                            url: this.url + "/geometry",
                            content: {
                                f: "json"
                            },
                            load: dojo.hitch(this, this._initGeometryEndpointsHandler),
                            error: dojo.hitch(this, this._initAsyncCollectionErrorHandler, dojo.hitch(this, function () {
                                this._geometryEndpointsInitialized = true;
                            })),
                            callbackParamName: "CallBack"
                        });
                    }
                    else {
                        // No geometry endpoints
                        this._geometryEndpointsInitialized = true;
                    }
                    // Check if there are geoprocessing endpoints
                    if (this.hasGeoprocessingEndpoints) {
                        // Get the geoprocessing endpoints
                        geocortex.request({
                            url: this.url + "/geoprocessing",
                            content: {
                                f: "json"
                            },
                            load: dojo.hitch(this, this._initGeoprocessingEndpointsHandler),
                            error: dojo.hitch(this, this._initAsyncCollectionErrorHandler, dojo.hitch(this, function () {
                                this._geoprocessingEndpointsInitialized = true;
                            })),
                            callbackParamName: "CallBack"
                        });
                    }
                    else {
                        // No geoprocessing endpoints
                        this._geoprocessingEndpointsInitialized = true;
                    }
                    // Check if there are named extents
                    if (this.hasNamedExtents) {
                        // Get the named extents
                        geocortex.request({
                            url: this.url + "/namedextents",
                            content: {
                                f: "json"
                            },
                            load: dojo.hitch(this, this._initNamedExtentsHandler),
                            error: dojo.hitch(this, this._initAsyncCollectionErrorHandler, dojo.hitch(this, function () {
                                this._namedExtentsInitialized = true;
                            })),
                            callbackParamName: "CallBack"
                        });
                    }
                    else {
                        // No named extents
                        this._namedExtentsInitialized = true;
                    }
                    // Check if there are print templates
                    if (this.hasPrintTemplates) {
                        // Get the print templates
                        geocortex.request({
                            url: this.url + "/printtemplates",
                            content: {
                                f: "json"
                            },
                            load: dojo.hitch(this, this._initPrintTemplatesHandler),
                            error: dojo.hitch(this, this._initAsyncCollectionErrorHandler, dojo.hitch(this, function () {
                                this._printTemplatesInitialized = true;
                            })),
                            callbackParamName: "CallBack"
                        });
                    }
                    else {
                        // No print templates
                        this._printTemplatesInitialized = true;
                    }
                    // Check if there are search tables
                    if (this.hasSearchTables) {
                        // Get the search tables
                        geocortex.request({
                            url: this.url + "/searchtables",
                            content: {
                                f: "json"
                            },
                            load: dojo.hitch(this, this._initSearchTablesHandler),
                            error: dojo.hitch(this, this._initAsyncCollectionErrorHandler, dojo.hitch(this, function () {
                                this._searchTablesInitialized = true;
                            })),
                            callbackParamName: "CallBack"
                        });
                    }
                    else {
                        // No search tables
                        this._searchTablesInitialized = true;
                    }
                    // Check if time slider profiles are defined
                    if (this.hasTimeSliders) {
                        // Get the time slider profiles
                        geocortex.request({
                            url: this.url + "/timesliders",
                            content: {
                                f: "json"
                            },
                            load: dojo.hitch(this, this._initTimeSlidersHandler),
                            error: dojo.hitch(this, this._initAsyncCollectionErrorHandler, dojo.hitch(this, function () {
                                this._timeSlidersInitialized = true;
                            })),
                            callbackParamName: "CallBack"
                        });
                    }
                    else {
                        // No time sliders.
                        this._timeSlidersInitialized = true;
                    }
                    // Check if there are workflows
                    if (this.hasWorkflows) {
                        // Get the workflows
                        geocortex.request({
                            url: this.url + "/workflows",
                            content: {
                                f: "json"
                            },
                            load: dojo.hitch(this, this._initWorkflowsHandler),
                            error: dojo.hitch(this, this._initAsyncCollectionErrorHandler, dojo.hitch(this, function () {
                                this._workflowsInitialized = true;
                            })),
                            callbackParamName: "CallBack"
                        });
                    }
                    else {
                        // No workflows
                        this._workflowsInitialized = true;
                    }
                    // Check if there are web maps
                    if (this.hasWebMaps) {
                        // Get the web maps
                        geocortex.request({
                            url: this.url + "/webmaps",
                            content: {
                                f: "json"
                            },
                            load: dojo.hitch(this, this._initWebMapHandler),
                            error: dojo.hitch(this, this._initAsyncCollectionErrorHandler, dojo.hitch(this, function () {
                                this._webMapsInitialized = true;
                            })),
                            callbackParamName: "CallBack"
                        });
                    }
                    else {
                        // No web maps
                        this._webMapsInitialized = true;
                    }
                }
                else {
                    this._initGeocodingEndpointsHandler(results);
                    this._initGeometryEndpointsHandler(results);
                    this._initGeoprocessingEndpointsHandler(results);
                    this._initTimeSlidersHandler(results);
                    this._initKmlEndpointHandler(results.kmlServiceEndpoint);
                    this.essentialsMap.initialize(results.map);
                    this._initNamedExtentsHandler(results);
                    if (results.overviewMap) {
                        this.overviewMap.initialize(results.overviewMap);
                    }
                    else {
                        this._overviewMapInitialized = true;
                        this._siteInitializeUpdate();
                    }
                    this._initPrintTemplatesHandler(results);
                    this._initWorkflowsHandler(results);
                    this._initSearchTablesHandler(results);
                    this._initWebMapHandler(results);
                }
                // Initialize the Document Store.
                this.documentStore.initialize(this);
                // Check if the site initialize is done
                this._siteInitializeUpdate();
            };
            /** @private */
            Site.prototype._initSiteErrorHandler = function (error) {
                var errorUntyped = error;
                var principal = errorUntyped.principal;
                if (principal && !principal.isAuthenticated && errorUntyped.code == 403) {
                    // If we have a principal, and we are not authenticated, but we got an "access denied"
                    // error, we should redirect to the sign in url.
                    this._signIn(principal);
                    return;
                }
                else if (principal && principal.isAuthenticated && errorUntyped.code == 403) {
                    // If the user is authenticated yet they receive a 403, it's because they're not allowed access to the site.
                    // If they're not allowed access to the site we must save the principal information so the user lacking
                    // authentication is still capable of signing out.
                    if (!!principal.urls.signOut) {
                        this._signOutEnabled = true;
                        this.principal = principal;
                    }
                }
                // There was an error getting the site info
                // skip the rest of the initialization
                this._geocodingEndpointsInitialized = true;
                this._geometryEndpointsInitialized = true;
                this._geoprocessingEndpointsInitialized = true;
                this._kmlServiceInitialized = true;
                this._namedExtentsInitialized = true;
                this._printTemplatesInitialized = true;
                this._workflowsInitialized = true;
                this._searchTablesInitialized = true;
                this._timeSlidersInitialized = true;
                this._initializationFailedHandler(error);
                this._siteInitializeUpdate();
            };
            /** @private */
            Site.prototype._initWorkflowsHandler = function (results) {
                this._workflowsInitialized = true;
                if (results) {
                    this._initAsyncCollection(results.workflows, "workflows", this.workflows, geocortex.essentials.Workflow);
                }
            };
            /** @private */
            Site.prototype._initSearchTablesHandler = function (results) {
                this._searchTablesInitialized = true;
                if (results) {
                    this._initAsyncCollection(results.searchTables, "searchTables", this.searchTables, geocortex.essentials.SearchTable);
                }
            };
            /** @private */
            Site.prototype._initWebMapHandler = function (results) {
                this._webMapsInitialized = true;
                if (results && results.webMapsInfo) {
                    this.webMapsInfo.layerTypes = results.webMapsInfo.layerTypes;
                    this._initAsyncCollection(results.webMapsInfo.webMaps, "webmaps", this.webMapsInfo.webMaps, geocortex.essentials.WebMapReference);
                }
            };
            /** @private */
            Site.prototype._siteInitializeUpdate = function () {
                // Check if all the steps of the site initialization have completed
                if (this._geocodingEndpointsInitialized &&
                    this._geometryEndpointsInitialized &&
                    this._geoprocessingEndpointsInitialized &&
                    this._kmlServiceInitialized &&
                    this._mapInitialized &&
                    this._namedExtentsInitialized &&
                    this._overviewMapInitialized &&
                    this._printTemplatesInitialized &&
                    this._workflowsInitialized &&
                    this._searchTablesInitialized &&
                    this._timeSlidersInitialized &&
                    this._webMapsInitialized) {
                    // Ensure the initialized handler is only called once per initialization
                    if (!this._initializedHandlerCalled) {
                        this._initializedHandlerCalled = true;
                        this._initializedHandler(this);
                    }
                }
            };
            /** @private */
            Site.prototype._verifySiteDependencies = function (results) {
                if (results && results.hasFeatureLayers) {
                    // dojo.require("esri.layers.FeatureLayer");
                    dojo.addOnLoad(dojo.hitch(this, function () {
                        this._initSiteHandler(results);
                    }));
                }
                else {
                    this._initSiteHandler(results);
                }
            };
            return Site;
        }(essentials.AsyncInitializable));
        essentials.Site = Site;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/arcgis-js-api.d.ts" />
/// <reference path="Site.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Helper class for dealing with REST data around layrs and layer definitions.
         */
        var RestHelper = (function () {
            function RestHelper() {
            }
            /**
             * Replaces client side tokens in the supplied input string with their correct values.
             * Client side tokens replaced are:
             * - SiteRestUrl
             * - VirtualDirectoryUrl
             * - RestVirtualDirectoryUrl
             * - HostUri
             * - RestToken
             *
             * @param site the current {@link Site} for which tokens are to be replaced.
             * @param input The input string with tokens.
             */
            RestHelper.processClientSideTokens = function (site, input) {
                var result = "";
                if (input !== "") {
                    var siteUrl = "";
                    if (site && site.url) {
                        siteUrl = site.url;
                    }
                    result = RestHelper._replaceToken("SiteRestUrl", input, siteUrl);
                    result = RestHelper._replaceToken("VirtualDirectoryUrl", result, siteUrl + "/virtualdirectory");
                    var hostUri = window.location.href.substring(0, window.location.href.lastIndexOf("/"));
                    result = RestHelper._replaceToken("HostUri", result, hostUri);
                    var restUrl = siteUrl.substring(0, siteUrl.lastIndexOf("/sites/"));
                    var restVirtualDirectoryUrl = restUrl + "/virtualdirectory";
                    result = RestHelper._replaceToken("RestVirtualDirectoryUrl", result, restVirtualDirectoryUrl);
                    var legalToken = essentials.RestHelperHTTPService.token;
                    result = RestHelper._replaceToken("RestToken", result, legalToken);
                }
                return result;
            };
            /**
             * Validates a Dynamic Layer Definition, ensuring all relevant required fields are supplied.
             * @param json A JSON string containing the Dynamic Layer Definition.
             */
            RestHelper.validateDynamicDefinition = function (json) {
                if (!json || !json.trim()) {
                    throw new Error("The JSON string cannot be null, empty nor merely whitespace!");
                }
                var dynamicDefinitionJson = RestHelper.getJsonObjectFromJsonString(json);
                if (dynamicDefinitionJson) {
                    // Ensure the source is included
                    if (dynamicDefinitionJson.source == null) {
                        throw "The source is required!";
                    }
                    // Ensure the type is included
                    if (dynamicDefinitionJson.source.type == null) {
                        throw "The type is required!";
                    }
                    if (dynamicDefinitionJson.source.type == "mapLayer") {
                        // Ensure mapLayerId is included for the mapLayer type
                        if (dynamicDefinitionJson.source.mapLayerId == null) {
                            throw "The mapLayerId is required for the mapLayer type!";
                        }
                    }
                    else if (dynamicDefinitionJson.source.type == "dataLayer") {
                        // Ensure dataSource is included fro the dataLayer type
                        if (dynamicDefinitionJson.source.dataSource == null) {
                            throw "The dataSource is required for the dataLayer type!";
                        }
                    }
                    else {
                        // Unsupported type!
                        throw "The type '" + dynamicDefinitionJson.source.type.toString() + "' is not supported!";
                    }
                }
            };
            /**
             * Converts a JSON string into a JSON object.
             * @param json A JSON string containing the Dynamic Definition.
             * @returns The JSON object created.
             */
            RestHelper.getJsonObjectFromJsonString = function (json) {
                var dynamicDefinitionJson;
                dynamicDefinitionJson = JSON.parse(json);
                return dynamicDefinitionJson;
            };
            /**
             * Creates a layer source from a JSON object.
             * @param The source as a JSON object.
             * @returns Either an {esri.layers.LayerMapSource} or {esri.layers.LayerDataSource}.
             */
            RestHelper.getLayerSourceFromJsonObject = function (sourceJson) {
                if (sourceJson.type == "mapLayer") {
                    // If the type is mapLayer...
                    var layerMapSource = new esri.layers.LayerMapSource(sourceJson);
                    return layerMapSource;
                }
                else {
                    // The type must be a dataLayer (since we've already validated it)...
                    var layerDataSource = new esri.layers.LayerDataSource();
                    // Determine the type of dataSource
                    switch (sourceJson.dataSource.type) {
                        case "table":
                            layerDataSource.dataSource = new esri.layers.TableDataSource(sourceJson.dataSource);
                            break;
                        case "queryTable":
                            layerDataSource.dataSource = new esri.layers.QueryDataSource(sourceJson.dataSource);
                            break;
                        case "raster":
                            layerDataSource.dataSource = new esri.layers.RasterDataSource(sourceJson.dataSource);
                            break;
                        case "joinTable":
                            layerDataSource.dataSource = new esri.layers.JoinDataSource(sourceJson.dataSource);
                            break;
                        default:
                            throw "The type '" + sourceJson.type.toString() + "' not supported!";
                    }
                    return layerDataSource;
                }
            };
            /**
             * Create a DynamicLayerInfo from a dynamic definition in JSON format.
             * @param json A JSON string containing the dynamic definition.
             * @param id The ID to use if not specified in the dynamic definition.
             * @returns {esri.layers.DynamicLayerInfo} The DynamicLayerInfo created.
             */
            RestHelper.getDynamicLayerInfoFromJson = function (json, id) {
                var dynamicLayerInfo;
                // Validate the Dynamic Definition JSON string
                RestHelper.validateDynamicDefinition(json);
                // Convert Dynamic Definition JSON string into JSON object
                var dynamicDefinitionJson = RestHelper.getJsonObjectFromJsonString(json);
                if (dynamicDefinitionJson) {
                    // Create the DynamicLayerInfo
                    dynamicLayerInfo = new esri.layers.DynamicLayerInfo();
                    if (dynamicDefinitionJson.id) {
                        // Use the Dynamic Definition's id since it exists
                        dynamicLayerInfo.id = dynamicDefinitionJson.id;
                    }
                    else {
                        if (id != null) {
                            // Use the fallback ID since it was not specified in the Dynamic Definition
                            dynamicLayerInfo.id = parseInt(id, 10);
                        }
                        else {
                            throw ("The Layer's ID is missing or invalid!");
                        }
                    }
                    // Set the layer source
                    dynamicLayerInfo.source = this.getLayerSourceFromJsonObject(dynamicDefinitionJson.source);
                    if (dynamicDefinitionJson.minScale != null) {
                        // Set the DynamicLayerInfo's minScale since it exists
                        dynamicLayerInfo.minScale = dynamicDefinitionJson.minScale;
                    }
                    if (dynamicLayerInfo.minScale <= 0) {
                        // If the minScale is zero, change it to infinity
                        dynamicLayerInfo.minScale = Infinity;
                    }
                    if (dynamicDefinitionJson.maxScale != null) {
                        // Set the DynamicLayerInfo's maxScale since it exists
                        dynamicLayerInfo.maxScale = dynamicDefinitionJson.maxScale;
                    }
                }
                return dynamicLayerInfo;
            };
            /**
            * Create a string from a dynamic definition in JSON format.
            * @param {String} json A JSON string containing the dynamic definition.
            * @returns {String} The definition expression (where clause).
            */
            RestHelper.getDynamicExpressionFromJson = function (json) {
                var defExp;
                // Validate the Dynamic Definition JSON string
                RestHelper.validateDynamicDefinition(json);
                var dynamicDefinitionJson = RestHelper.getJsonObjectFromJsonString(json);
                if (dynamicDefinitionJson && dynamicDefinitionJson.definitionExpression) {
                    defExp = dynamicDefinitionJson.definitionExpression;
                }
                return defExp;
            };
            /**
             * Create a LayerDrawingOptions object from a dynamic definition in JSON format.
             * @param json A JSON string containing the dynamic definition.
             */
            RestHelper.getLayerDrawingOptionsFromJson = function (json) {
                var layerDrawingOptions;
                // Validate the Dynamic Definition JSON string
                RestHelper.validateDynamicDefinition(json);
                // Convert Dynamic Definition JSON string into JSON object
                var dynamicDefinitionJson = RestHelper.getJsonObjectFromJsonString(json);
                var layerDrawingOptionsJson;
                if (dynamicDefinitionJson && dynamicDefinitionJson.drawingInfo) {
                    // Get a JSON object that specifically represents the LayerDrawingOptions
                    layerDrawingOptionsJson = dojo.clone(dynamicDefinitionJson.drawingInfo);
                    // Create the LayerDrawingOptions
                    layerDrawingOptions = new esri.layers.LayerDrawingOptions();
                    // Determine the type of Renderer and set it
                    switch (layerDrawingOptionsJson.renderer.type) {
                        case "simple":
                            layerDrawingOptions.renderer = new esri.renderer.SimpleRenderer(layerDrawingOptionsJson.renderer);
                            break;
                        case "uniqueValue":
                            layerDrawingOptions.renderer = new esri.renderer.UniqueValueRenderer(layerDrawingOptionsJson.renderer);
                            break;
                        case "classBreaks":
                            layerDrawingOptions.renderer = new esri.renderer.ClassBreaksRenderer(layerDrawingOptionsJson.renderer);
                            break;
                        default:
                            throw "The type '" + layerDrawingOptionsJson.renderer.type.toString() + "' not supported!";
                    }
                    // detect if the layerDrawingOptions has labeling info.
                    if (layerDrawingOptionsJson.labelingInfo && layerDrawingOptionsJson.labelingInfo instanceof Array) {
                        var labelingInfo = layerDrawingOptionsJson.labelingInfo;
                        // show the labels if the showLabels value is undefined
                        // if it is true or false, it most likely has been explicitly set
                        // if left undefined the labels will not show
                        if (layerDrawingOptionsJson.showLabels === undefined) {
                            layerDrawingOptionsJson.showLabels = true;
                        }
                        for (var i = 0; i < labelingInfo.length; i++) {
                            var labelClass = new esri.layers.LabelClass(labelingInfo[i]);
                            // make sure an array of LabelClasses exist
                            if (!layerDrawingOptions.labelingInfo) {
                                layerDrawingOptions.labelingInfo = [];
                            }
                            layerDrawingOptions.labelingInfo.push(labelClass);
                        }
                    }
                    // Set the transparency, scale symbols and show labels properties
                    layerDrawingOptions.transparency = layerDrawingOptionsJson.transparency;
                    layerDrawingOptions.scaleSymbols = layerDrawingOptionsJson.scaleSymbols;
                    layerDrawingOptions.showLabels = layerDrawingOptionsJson.showLabels;
                }
                return layerDrawingOptions;
            };
            /** @private */
            RestHelper._replaceToken = function (token, input, replacementValue) {
                if (!input) {
                    return input;
                }
                return input.replace("{" + token + "}", replacementValue);
            };
            /** @private */
            RestHelper._createRestParametersFromQuery = function (query) {
                var queryParam = {};
                if (query) {
                    queryParam = query.toJson();
                    // we must translate the Spatial Relationship to .Net constants
                    queryParam.spatialRel = RestHelper._convertSpatialRelationshipToDotnet(queryParam.spatialRel);
                }
                return queryParam;
            };
            /** @private */
            RestHelper._convertSpatialRelationshipToDotnet = function (rel) {
                switch (rel) {
                    case esri.tasks.Query.SPATIAL_REL_CONTAINS:
                        return "esriSpatialRelContains";
                    case esri.tasks.Query.SPATIAL_REL_CROSSES:
                        return "esriSpatialRelCrosses";
                    case esri.tasks.Query.SPATIAL_REL_ENVELOPEINTERSECTS:
                        return "esriSpatialRelEnvelopeIntersects";
                    case esri.tasks.Query.SPATIAL_REL_INDEXINTERSECTS:
                        return "esriSpatialRelIndexIntersects";
                    case esri.tasks.Query.SPATIAL_REL_INTERSECTS:
                        return "esriSpatialRelIntersects";
                    case esri.tasks.Query.SPATIAL_REL_OVERLAPS:
                        return "esriSpatialRelOverlaps";
                    case esri.tasks.Query.SPATIAL_REL_RELATION:
                        return "esriSpatialRelRelation";
                    case esri.tasks.Query.SPATIAL_REL_TOUCHES:
                        return "esriSpatialRelTouches";
                    case esri.tasks.Query.SPATIAL_REL_WITHIN:
                        return "esriSpatialRelWithin";
                }
                throw new Error("Unknown rel: " + rel);
            };
            /** @private */
            RestHelper._convertSpatialRelationshipFromDotnetIndex = function (rel) {
                switch (rel) {
                    case 1:
                        return esri.tasks.Query.SPATIAL_REL_CONTAINS;
                    case 2:
                        return esri.tasks.Query.SPATIAL_REL_CROSSES;
                    case 3:
                        return esri.tasks.Query.SPATIAL_REL_ENVELOPEINTERSECTS;
                    case 4:
                        return esri.tasks.Query.SPATIAL_REL_INDEXINTERSECTS;
                    case 0:
                        return esri.tasks.Query.SPATIAL_REL_INTERSECTS;
                    case 5:
                        return esri.tasks.Query.SPATIAL_REL_OVERLAPS;
                    case 8:
                        return esri.tasks.Query.SPATIAL_REL_RELATION;
                    case 6:
                        return esri.tasks.Query.SPATIAL_REL_TOUCHES;
                    case 7:
                        return esri.tasks.Query.SPATIAL_REL_WITHIN;
                }
                throw new Error("Unknown rel: " + rel);
            };
            RestHelper.tokenDurationMinutes = 20;
            return RestHelper;
        }());
        essentials.RestHelper = RestHelper;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="RestHelper.ts" />
/// <reference path="Layer.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents a FeatureHyperlink configured on a layer by an Administrator.
         */
        var FeatureHyperlink = (function () {
            /**
             * Initializes a new instance of the {@link geocortex.essentials.FeatureHyperlink} class.
             * @param featureHyperlinkInfo Associative array of properties to use to populate the members of this object.
             * @param layer The layer that this FeatureHyperlink is associated with.
             */
            function FeatureHyperlink(featureHyperlinkInfo, layer) {
                this.encodeUriReplacementValues = featureHyperlinkInfo.encodeUriReplacementValues;
                this.target = featureHyperlinkInfo.target;
                this.text = featureHyperlinkInfo.text;
                this.toolTip = featureHyperlinkInfo.toolTip;
                var site = null;
                if (layer && (layer.mapService) && (layer.mapService.essentialsMap)) {
                    site = layer.mapService.essentialsMap.site;
                }
                this.uri = geocortex.essentials.RestHelper.processClientSideTokens(site, featureHyperlinkInfo.uri);
                this.iconUri = geocortex.essentials.RestHelper.processClientSideTokens(site, featureHyperlinkInfo.iconUri);
                this.layer = layer;
            }
            return FeatureHyperlink;
        }());
        essentials.FeatureHyperlink = FeatureHyperlink;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../essentials.ts" />
/// <reference path="RestHelper.ts" />
/// <reference path="AsyncInitializable.ts" />
/// <reference path="ReportParameters.ts" />
/// <reference path="Layer.ts" />
/// <reference path="Scale.ts" />
/// <reference path="Resolution.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents a {@link Report} for a specific {@link Layer}.
         * A report displays information about some of the features of a specific {@link Layer}.
         * In order to generate a report, a query must be provided that indicates which features to include in the report.
         * Report generation requires a report template created by the Geocortex Report Designer and stored on the server.
         */
        var Report = (function (_super) {
            __extends(Report, _super);
            /**
             * Initializes a new instance of the {@link Report} class.
             * @param url The URL to the REST endpoint of the {@link Report}.
             */
            function Report(url) {
                _super.call(this, url);
                /** The description of the {@link Report}. */
                this.description = null;
                /** The display name of the {@link Report}. */
                this.displayName = null;
                /** The extensions of the {@link PrintTemplate}, as defined by an administrator. */
                this.extensions = [];
                /** The ID of the {@link Report}.*/
                this.id = null;
                /** The visibility of the {@link Report}. */
                this.visible = false;
                /** The {@link Layer} that the {@link Report} belongs to. */
                this.layer = null;
                /** The properties of the {@link PrintTemplate}, as defined by an administrator. */
                this.properties = {};
                /** The collection of supported {@link Scale}s for the {@link Report}. */
                this.supportedMapScales = [];
                /** The collection of supported output formats for the {@link Report}. */
                this.supportedOutputFormats = [];
                /** The collection of supported {@link Resolution}s for the {@link Report}. */
                this.supportedResolutions = [];
                /** The collection of {@link TextField} objects for the {@link Report}. */
                this.textFields = [];
                /** @private */
                this._running = false;
                /** @private */
                this._onRunReportComplete = null;
                /** @private */
                this._onRunReportError = null;
            }
            /**
             * Whether the {@link Report} is currently running (being generated). */
            Report.prototype.isRunning = function () {
                return this._running;
            };
            /**
             * Runs the report using a {@link esri.tasks.Query} and the {@link ReportParameters}.
             * This is an asynchronous method, you may provide delegates for completion or error information.
             * @param query The {@link esri.tasks.Query} to use to select features from the {@link Layer} to report on.
             * @param reportParameters The report parameters.
             * @param runReportComplete The delegate that will be called when the report has finished running
             * (even if an error occurs). This delegate expects one argument: a String representing the URL of the prepared report.
             * @param runReportError The delegate that will be called if an error occurs. This delegate expects two arguments: a reference to the Report instance, and an Error.
             */
            Report.prototype.run = function (query, reportParameters, runReportComplete, runReportError) {
                var _this = this;
                // If it's already printing, return an error then retrun
                if (this.isRunning()) {
                    if (runReportError) {
                        var error = new Error("Report already running");
                        error.name = "ReportAlreadyRunning";
                        runReportError(error);
                    }
                    return;
                }
                // Indicate that the run is happening
                this._running = true;
                try {
                    // Store the delegates for the end of the synchronous webclient method
                    this._onRunReportComplete = runReportComplete;
                    this._onRunReportError = runReportError;
                    var webMapBuilder = new essentials.exportMap.ExportMapTask(this);
                    var webMapParams = new essentials.exportMap.ExportMapParameters();
                    webMapParams.reportParameters = reportParameters;
                    // the data which the report will be generated from
                    if (query) {
                        webMapParams.queryParameters = geocortex.essentials.RestHelper._createRestParametersFromQuery(query);
                    }
                    webMapBuilder.generateMapImageUrl(webMapParams).then(function (result) { return _this._runRestComplete(result); }, function (error) { return _this._runRestError(error); });
                }
                catch (error) {
                    this._running = false;
                    if (this._onRunReportError) {
                        this._onRunReportError(error);
                    }
                    else {
                        throw error;
                    }
                }
            };
            /** @private */
            Report.prototype._configureObject = function (results, deepInitialize) {
                if (results.id === undefined || results.displayName === undefined) {
                    throw new Error("Incorrect report object returned from initialization");
                }
                // Assign all the data
                this.id = results.id;
                this.visible = results.visible === undefined ? true : results.visible;
                this.supportedOutputFormats = results.supportedOutputFormats;
                this.supportedResolutions = results.supportedResolutions;
                this.supportedMapScales = results.supportedScales;
                this.textFields = results.textFields;
                this.description = results.description;
                this.displayName = results.displayName;
                if (deepInitialize) {
                    this.isInitialized = true;
                }
                // add the properties
                this.properties = geocortex._getProperties(results.properties);
                // add the extensions
                this.extensions = geocortex._getExtensions(results.extensions);
            };
            /** @private */
            Report.prototype._runRestComplete = function (results) {
                this._running = false;
                var ex = null;
                if (!results) {
                    // TODO: i18n
                    ex = new Error("No results");
                }
                else {
                    if (results.error) {
                        ex = results.error;
                    }
                }
                if (ex && this._onRunReportError) {
                    this._onRunReportError(ex);
                }
                if (results && this._onRunReportComplete) {
                    this._onRunReportComplete(results);
                }
            };
            /** @private */
            Report.prototype._runRestError = function (error) {
                this._running = false;
                if (this._onRunReportError) {
                    this._onRunReportError(error);
                }
            };
            return Report;
        }(essentials.AsyncInitializable));
        essentials.Report = Report;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/**
 * Contains string constants that represent a type of {@link Report}.
 */
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var ReportType;
        (function (ReportType) {
            ReportType.LAYER_TEMPLATE_REPORT = "Layer Template Report";
            ReportType.MAP_TEMPLATE_REPORT = "Map Template Report";
        })(ReportType = essentials.ReportType || (essentials.ReportType = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents the basic layer type of a {@link Layer}.
         */
        var LayerType = (function () {
            function LayerType() {
            }
            LayerType.UNKNOWN = 0;
            LayerType.FEATURE_LAYER = 1;
            LayerType.RASTER_LAYER = 2;
            LayerType.GROUP_LAYER = 3;
            LayerType.GEO_RSS_LAYER = 4;
            LayerType.TABLE_LAYER = 5;
            return LayerType;
        }());
        essentials.LayerType = LayerType;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var EsriFieldTypes = (function () {
            function EsriFieldTypes() {
            }
            EsriFieldTypes.esriFieldTypeSmallInteger = "esriFieldTypeSmallInteger";
            EsriFieldTypes.esriFieldTypeInteger = "esriFieldTypeInteger";
            EsriFieldTypes.esriFieldTypeSingle = "esriFieldTypeSingle";
            EsriFieldTypes.esriFieldTypeDouble = "esriFieldTypeDouble";
            EsriFieldTypes.esriFieldTypeString = "esriFieldTypeString";
            EsriFieldTypes.esriFieldTypeDate = "esriFieldTypeDate";
            EsriFieldTypes.esriFieldTypeOID = "esriFieldTypeOID";
            EsriFieldTypes.esriFieldTypeGeometry = "esriFieldTypeGeometry";
            EsriFieldTypes.esriFieldTypeBlob = "esriFieldTypeBlob";
            EsriFieldTypes.esriFieldTypeRaster = "esriFieldTypeRaster";
            EsriFieldTypes.esriFieldTypeGUID = "esriFieldTypeGUID";
            EsriFieldTypes.esriFieldTypeGlobalID = "esriFieldTypeGlobalID";
            EsriFieldTypes.esriFieldTypeXML = "esriFieldTypeXML";
            return EsriFieldTypes;
        }());
        essentials.EsriFieldTypes = EsriFieldTypes;
        var EssentialsFieldTypes = (function () {
            function EssentialsFieldTypes() {
            }
            EssentialsFieldTypes.essentialsFieldTypeSmallInteger = "Int16";
            EssentialsFieldTypes.essentialsFieldTypeInteger = "Int32";
            EssentialsFieldTypes.essentialsFieldTypeSingle = "Single";
            EssentialsFieldTypes.essentialsFieldTypeDouble = "Double";
            EssentialsFieldTypes.essentialsFieldTypeString = "String";
            EssentialsFieldTypes.essentialsFieldTypeDate = "DateTime";
            EssentialsFieldTypes.essentialsFieldTypeGUID = "Guid";
            EssentialsFieldTypes.essentialsFieldTypeObject = "Object";
            return EssentialsFieldTypes;
        }());
        essentials.EssentialsFieldTypes = EssentialsFieldTypes;
        /**
         * Represents an attribute of a spatial layer, as configured by Essentials.
         */
        var Field = (function () {
            /**
             * Initializes a new instance of the {@link Field} class.
             * @param field A {@link Field}like object to clone.
             */
            function Field(fieldInfo) {
                /** The {@link Layer} that this field belongs to. */
                this.layer = null;
                if (!fieldInfo || !fieldInfo.layer) {
                    throw new Error("Layer is required.");
                }
                this.layer = fieldInfo.layer;
                this.alias = fieldInfo.alias;
                this.dataType = fieldInfo.dataType;
                this.displayName = fieldInfo.displayName;
                this.focusField = !!fieldInfo.focusField;
                this.hyperlinkLabel = fieldInfo.hyperlinkLabel;
                this.name = fieldInfo.name;
                this.searchable = !!fieldInfo.searchable;
                this.visible = !!fieldInfo.visible;
                this.format = fieldInfo.format;
            }
            /**
             * Exports the state of the field as a JSON object. This can be used to recreate the
             * field again via the constructor.
             */
            Field.prototype.toJson = function () {
                return {
                    alias: this.alias,
                    dataType: this.dataType,
                    displayName: this.displayName,
                    focusField: this.focusField,
                    hyperlinkLabel: this.hyperlinkLabel,
                    name: this.name,
                    searchable: this.searchable,
                    visible: this.visible,
                    format: this.format
                };
            };
            /**
             * Converts an ESRI field type to a Geocortex Essentials type which is a .NET type name.
             * @returns esriFieldType Name of the system type that corresponds to ESRI field type.
             * @param esriFieldType Name of the ESRI field type to convert.
             */
            Field.convertFromEsriType = function (esriFieldType) {
                // If the field type is falsy or is not started with "esriFieldType" we don't convert it.
                if (!esriFieldType || esriFieldType.indexOf("esriFieldType") !== 0) {
                    return esriFieldType;
                }
                switch (esriFieldType) {
                    case EsriFieldTypes.esriFieldTypeGeometry:
                    case EsriFieldTypes.esriFieldTypeBlob:
                    case EsriFieldTypes.esriFieldTypeRaster:
                        return EssentialsFieldTypes.essentialsFieldTypeObject;
                    case EsriFieldTypes.esriFieldTypeDate:
                        return EssentialsFieldTypes.essentialsFieldTypeDate;
                    case EsriFieldTypes.esriFieldTypeDouble:
                        return EssentialsFieldTypes.essentialsFieldTypeDouble;
                    case EsriFieldTypes.esriFieldTypeGlobalID:
                        return EssentialsFieldTypes.essentialsFieldTypeGUID;
                    case EsriFieldTypes.esriFieldTypeInteger:
                    case EsriFieldTypes.esriFieldTypeOID:
                        return EssentialsFieldTypes.essentialsFieldTypeInteger;
                    case EsriFieldTypes.esriFieldTypeSingle:
                        return EssentialsFieldTypes.essentialsFieldTypeSingle;
                    case EsriFieldTypes.esriFieldTypeSmallInteger:
                        return EssentialsFieldTypes.essentialsFieldTypeSmallInteger;
                    case EsriFieldTypes.esriFieldTypeGUID:
                    case EsriFieldTypes.esriFieldTypeString:
                    case EsriFieldTypes.esriFieldTypeXML:
                    default:
                        return EssentialsFieldTypes.essentialsFieldTypeString;
                }
            };
            /**
             * Converts a Geocortex Essentials field type (which is a .NET type name) to an esri field type.
             * @returns Name of the esri field type that corresponds to the Essentials type.
             * @param geocortexType Name of the Geocortex Essentials field type to convert.
             */
            Field.convertToEsriFieldType = function (geocortexType) {
                // Note that there is a loss of information here, since the relationship is not one to one.
                switch (geocortexType) {
                    case essentials.EssentialsFieldTypes.essentialsFieldTypeObject:
                        return EsriFieldTypes.esriFieldTypeBlob;
                    case essentials.EssentialsFieldTypes.essentialsFieldTypeDate:
                        return EsriFieldTypes.esriFieldTypeDate;
                    case essentials.EssentialsFieldTypes.essentialsFieldTypeDouble:
                        return EsriFieldTypes.esriFieldTypeDouble;
                    case essentials.EssentialsFieldTypes.essentialsFieldTypeGUID:
                        return EsriFieldTypes.esriFieldTypeGlobalID;
                    case essentials.EssentialsFieldTypes.essentialsFieldTypeInteger:
                        return EsriFieldTypes.esriFieldTypeInteger;
                    case essentials.EssentialsFieldTypes.essentialsFieldTypeSingle:
                        return EsriFieldTypes.esriFieldTypeSingle;
                    case essentials.EssentialsFieldTypes.essentialsFieldTypeSmallInteger:
                        return EsriFieldTypes.esriFieldTypeSmallInteger;
                    case essentials.EssentialsFieldTypes.essentialsFieldTypeString:
                        return EsriFieldTypes.esriFieldTypeString;
                    default:
                        return EsriFieldTypes.esriFieldTypeString;
                }
            };
            return Field;
        }());
        essentials.Field = Field;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="RestHelper.ts" />
/// <reference path="Layer.ts" />
// A representation of a layer hyperlink of a layer.
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Client representation of a layer hyperlink object attached to a layer.
         */
        var LayerHyperlink = (function () {
            /**
             * Initializes a new instance of the {@link LayerHyperlink} class.
             * @param layerHyperlinkInfo Values used to populate the members of this object.
             * @param layer The layer which owns this {@link LayerHyperlink}.
             */
            function LayerHyperlink(layerHyperlinkInfo, layerOrMapService) {
                this.encodeUriReplacementValues = layerHyperlinkInfo.encodeUriReplacementValues;
                this.target = layerHyperlinkInfo.target;
                this.text = layerHyperlinkInfo.text;
                this.toolTip = layerHyperlinkInfo.toolTip;
                var site = null;
                if (layerOrMapService instanceof essentials.Layer) {
                    this.layer = layerOrMapService;
                    if (this.layer.mapService) {
                        this.mapService = this.layer.mapService;
                    }
                }
                else if (layerOrMapService instanceof essentials.MapService) {
                    this.mapService = layerOrMapService;
                }
                if (this.mapService && (this.mapService.essentialsMap)) {
                    site = this.mapService.essentialsMap.site;
                }
                // Silverlight replaces all tokens when the hyperlink is built. GVH only replaces client-side tokens here;
                // we replace layer-specific tokens 'just in time' in the LayerHyperlinkViewModel.
                this.uri = geocortex.essentials.RestHelper.processClientSideTokens(site, layerHyperlinkInfo.uri);
                this.iconUri = geocortex.essentials.RestHelper.processClientSideTokens(site, layerHyperlinkInfo.iconUri);
            }
            /**
             * Exports the state of the hyperlink as a JSON object. This can be used to recreate the
             * hyperlink again via the constructor.
             */
            LayerHyperlink.prototype.toJson = function () {
                return {
                    encodeUriReplacementValues: this.encodeUriReplacementValues,
                    iconUri: this.iconUri,
                    target: this.target,
                    text: this.text,
                    toolTip: this.toolTip,
                    uri: this.uri
                };
            };
            return LayerHyperlink;
        }());
        essentials.LayerHyperlink = LayerHyperlink;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="RestHelper.ts" />
/// <reference path="FeatureHyperlink.ts" />
/// <reference path="Report.ts" />
/// <reference path="MapService.ts" />
/// <reference path="LayerType.ts" />
/// <reference path="Extension.ts" />
/// <reference path="Field.ts" />
/// <reference path="DataLink.ts" />
/// <reference path="AsyncInitializable.ts" />
/// <reference path="utilities/SiteResourceIdComparer.ts" />
/// <reference path="LayerHyperlink.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents a layer configured in a {@link MapService}.
         * A Geocortex layer should not be confused with an _ArcGISDynamicMapServiceLayer_ or an _ArcGISTiledMapServiceLayer_. It is more akin to the esri.layers.LayerInfo class.
         * The layer provides additional configuration beyond what is defined in an ArcGIS server map service sub layer.
         * For example, the layer might have reports and datalinks defined. Also, the layer's configuration overrides the default visibility of the layer.
         * In order for sub-layers to appear on the map, they must be explicitly defined in the layer collection of the {@link MapService}.
         */
        var Layer = (function (_super) {
            __extends(Layer, _super);
            /**
             * Initializes a new instance of the {@link Layer} class.
             * @param url The URL to the REST endpoint of the {@link Layer}.
             */
            function Layer(url) {
                _super.call(this, url);
                /** Whether or not this layer should allow the end user to configure custom symbolization */
                this.allowSymbolization = false;
                /** Whether or not the layer supports toggling labels. */
                this.canToggleLabels = false;
                /** Array of charts associated with this layer*/
                this.charts = [];
                /** The layer's initial visibility, defined in the site.  This will be true if the layer  was configured to be visible by default, false otherwise. */
                this.configuredVisible = false;
                /** Gets the collection of {@link DataLink} objects that belongs to the {@link Layer}. */
                this.dataLinks = [];
                /** The name of the underlying data provider for the layer, e.g. "SqlServer" or "Oracle". */
                this.dataProvider = null;
                /** Whether or not the layer is visible by default in the service. */
                this.defaultVisibility = false;
                /** The field to use as the primary representative of the layer in reports. */
                this.displayField = null;
                /** The alias to use for the layer in client applications. */
                this.displayName = null;
                /** The default format string used for formatting date values originating from this layer. */
                this.defaultDateFormat = null;
                /** The default format string used for formatting numeric values originating from this layer. */
                this.defaultNumberFormat = null;
                /** The description to use for the layer in client applications. */
                this.description = null;
                /** The layer's draw index that determines its drawing order (only applies to dynamic map services). */
                this.drawIndex = null;
                /** The dynamic definition of the {@link Layer}. */
                this.dynamicDefinition = null;
                /** The extensions of the Layer, as defined by an administrator.*/
                this.extensions = [];
                /** The border color used when highlighting a feature from this layer. */
                this.featureBorderColor = null;
                /** The width of the border for a feature from this layer. */
                this.featureBorderWidth = null;
                /** The format for a description of a feature from this layer. */
                this.featureDescription = null;
                /** The fill color used when highlighting a feature from this layer, represented as an array of RGB values in the range of 0-255. */
                this.featureFillColor = null;
                /** Array of feature hyperlinks associated with this layer*/
                this.featureHyperlinks = [];
                /** The format for a label of a feature. */
                this.featureLabel = null;
                /** The format for a long description of a feature. */
                this.featureLongDescription = null;
                /**
                 * Shape type of the layer. One of:
                 *  - None
                 *  - Point
                 *  - Multipoint
                 *  - Polygon
                 *  - Line
                 */
                this.featureType = "None";
                /**
                 * Zoom factor to use to expand the extent by when zooming to a feature.  For example,
                 * if this value is set to 3, then the extent will be expanded by a factor of 3 when zooming to that feature.
                 * This property is not applicable to point layers since points do not have an extent to expand.
                 */
                this.featureZoomFactor = null;
                /**
                 * Scale to which the map should zoom when a standard viewer "zoom to feature" concept is invoked, from a list of results or otherwise.  This value should
                 * be respected by implementing clients and viewers. If no value has been configured in the Essentials site for this, it will remain null.
                 */
                this.featureZoomScale = null;
                /** Array of fields associated with this layer. */
                this.fields = [];
                /** The full extent of the layer. */
                this.fullExtent = null;
                /** Whether the {@link Layer} has attachments associated with it. */
                this.hasAttachments = false;
                /** Whether the {@link Layer} contains a collection of {@link DataLink} objects. This information is available even if the {@link Layer} has not been initialized. */
                this.hasDataLinks = false;
                /**
                 * Whether the {@link Layer} contains a collection of {@link Report} objects.
                 * This information is available even if the {@link Layer} has not been initialized.
                 */
                this.hasReports = false;
                /** URI to an icon representing this layer in the client application. */
                this.iconUri = null;
                /** The ID of the {@link Layer}. */
                this.id = null;
                /** Whether or not this layer can be identified in the client application. */
                this.identifiable = false;
                /** Whether or not this layer can be identified in the client application at scales it's not visible at. */
                this.identifiableAtAllScales = false;
                /** Whether or not to include this layer in the a layer list. */
                this.includeInLayerList = true;
                /** Whether or not to include this layer in the legend. */
                this.includeInLegend = true;
                /** Whether the {@link Layer} is dynamic. */
                this.isDynamic = false;
                /** Whether or not the layer will be expanded by default when shown in a layer list.  Only applies to group layers. */
                this.isExpanded = false;
                /** If the layer was added from the catalog. **/
                this.isUserCreated = false;
                /** The catalog id */
                this.catalogId = null;
                /** An array of hyperlinks associated with this layer. */
                this.layerHyperlinks = [];
                /** The URL of the image for the layer legend. */
                this.legendUrl = null;
                /** The map service that the {@link Layer} belongs to. */
                this.mapService = null;
                /** The layer's maximum scale. */
                this.maxScale = 0;
                /** The layer's minimum scale. */
                this.minScale = 0;
                /** The name of the {@link Layer}. */
                this.name = null;
                /** Gets the ID of the parent {@link Layer}. */
                this.parentLayerId = null;
                /** Field to use as the layer's primary key. */
                this.primaryKeyField = null;
                /** The properties of the {@link Layer}, as defined by the administrator on the server. */
                this.properties = {};
                /** A flag indicating whether the layer is queryable or not. */
                this.queryable = false;
                /** Array of relationships associated with this layer. */
                this.relationships = [];
                /** The collection of {@link Report} objects that belongs to the {@link Layer}. */
                this.reports = [];
                /**  Indicates if the layer is searchable. */
                this.searchable = false;
                /**
                 * The display preference for feature hyperlinks. One of:
                 *    - "ShowAll"
                 *    - "DisableBrokenLinks"
                 *    - "HideBrokenLinks"
                 */
                this.showFeatureHyperlinks = "ShowAll";
                /** Whether this layer should show its labels. */
                this.showLabels = true;
                /** Whether the client application is to show map tips for this layer. */
                this.showMapTips = false;
                /** Whether the layer can be snapped. */
                this.snappable = false;
                /** Whether the layer is enabled for snapping by default. */
                this.snappingEnabled = false;
                /** Indicates whether or not this layer supports the Identify task/endpoint. This is not the same as identifiable which is affected by user preference. */
                this.supportsIdentify = false;
                /** Indicates whether or not this layer supports the Query task/endpoint. This is not the same as queryable which is affected by user preference. */
                this.supportsQuery = false;
                /** The style name, for WMS requests. */
                this.styleName = null;
                /** A list of predefined renderers that can be applied to this layer */
                this.styles = [];
                /** Gets the IDs of all {@link Layer} objects that are sub-layers (children) of this {@link Layer}. The value is only set when the layer is a group layer. */
                this.subLayerIds = [];
                /** The IANA ID of the time zone in which the data in this layer's fields are current. */
                this.timeZoneId = null;
                /** The type of the layer, such as feature layer, raster layer, group layer, etc. Represented as a numerical value, defined by {@link LayerType}. */
                this.type = geocortex.essentials.LayerType.UNKNOWN;
                /** A flag used when changing map services and preserving user visibility settings. */
                this.visibleStateForRefresh = geocortex.essentials.RefreshVisibility.DEFAULT;
                /**
                 * The name of the WMS layer. This is the actual layer name from the capabilities, unlike
                 * the name property of this Layer which is actually the title in the capabilities.
                 */
                this.wmsLayerName = null;
                /**
                 * An observable indicating whether this layer is participating in the currently configured layer theme or not
                 */
                this.inActiveTheme = true;
                /**
                 * A collection containing the layer theme settings for this layer.
                 */
                this.layerThemeSettings = [];
                /**
                 * Whether the {@link Layer} is currently visible or not.
                 * @private
                 */
                this._visible = false;
                /**
                 * Caches the value for getFeatureLayer().
                 */
                this._featureLayerPromise = null;
                this._timeInfo = null;
                this._gcxTimeInfo = null;
                this.setInActiveTheme(true); // All layers are active in the default theme - i.e. when all layers are available
            }
            /** Gets the feature layer associated with this layer. Not supported for all layers types, in which case the value will be null. */
            Layer.prototype.getFeatureLayer = function () {
                var _this = this;
                if (!this._featureLayerPromise) {
                    if (this.mapService.serviceUrl && this.mapService.serviceUrl.endsWith("/MapServer")) {
                        // For a map service, load all layers at once any time that we need feature layer info for one of its layers.
                        this._featureLayerPromise = new Promise(function (resolve, reject) {
                            _this.mapService._getLayersInfo().then(function (layersInfo) {
                                var featureLayer = null;
                                if (layersInfo && layersInfo.layers) {
                                    // Find the matching layer info.
                                    layersInfo.layers.forEach(function (layerJson) {
                                        if (_this.id === layerJson.id.toString()) {
                                            featureLayer = new esri.layers.FeatureLayer({ layerDefinition: layerJson });
                                            return;
                                        }
                                    });
                                    // It may be a table, as a table is simply a FeatureLayer without spatial information.
                                    if (!featureLayer && layersInfo.tables) {
                                        layersInfo.tables.forEach(function (tableJson) {
                                            if (_this.id === tableJson.id.toString()) {
                                                featureLayer = new esri.layers.FeatureLayer({ layerDefinition: tableJson });
                                                return;
                                            }
                                        });
                                    }
                                    if (featureLayer) {
                                        // If we have a feature layer here, we can return it.
                                        resolve(featureLayer);
                                        return;
                                    }
                                    // Check if we are working with a dynamic layer.
                                    if (_this.isDynamic) {
                                        if (_this.mapService && _this.mapService.serviceLayer instanceof esri.layers.ArcGISDynamicMapServiceLayer) {
                                            var ms = _this.mapService.serviceLayer;
                                            if (ms.dynamicLayerInfos) {
                                                var foundSource = null;
                                                // Attempt to find the layer source.
                                                for (var key in ms.dynamicLayerInfos) {
                                                    if (ms.dynamicLayerInfos.hasOwnProperty(key)) {
                                                        if (ms.dynamicLayerInfos[key].id == parseInt(_this.id)) {
                                                            foundSource = ms.dynamicLayerInfos[key].source;
                                                            break;
                                                        }
                                                    }
                                                }
                                                if (foundSource) {
                                                    // Generate a FeatureLayer with the dynamic source so we can get information from it.
                                                    var baseServiceUrl = _this.mapService.serviceUrl + "/dynamicLayer";
                                                    var serviceUrl = _this.mapService.serviceToken ? baseServiceUrl + "?token=" + _this.mapService.serviceToken : baseServiceUrl;
                                                    featureLayer = new esri.layers.FeatureLayer(serviceUrl, { source: foundSource });
                                                    var loadHandle = featureLayer.on("load", function (args) {
                                                        loadHandle.remove();
                                                        errorHandle.remove();
                                                        resolve(featureLayer);
                                                    });
                                                    var errorHandle = featureLayer.on("error", function (esriError) {
                                                        loadHandle.remove();
                                                        errorHandle.remove();
                                                        var message = esriError.error && esriError.error.message ? esriError.error.message : "Could not determine underlying error.";
                                                        reject(new Error("Could not create a Feature Layer from the given dynamic layer source. Reason: {0}".format(message)));
                                                    });
                                                }
                                                else {
                                                    reject(new Error("Could not find LayerSource for the given dynamic layer."));
                                                }
                                            }
                                        }
                                    }
                                }
                            });
                        });
                    }
                    else {
                        var featureLayer;
                        if (this.mapService.serviceLayer instanceof esri.layers.FeatureLayer) {
                            // For a feature layer service, the service layer is already what we need.
                            featureLayer = this.mapService.serviceLayer;
                        }
                        else {
                            // Try to load from the layer endpoint (WMS).
                            featureLayer = new esri.layers.FeatureLayer(this.getLayerUrl());
                        }
                        if (!featureLayer.loaded) {
                            this._featureLayerPromise = new Promise(function (resolve, reject) {
                                var loadHandle = featureLayer.on("load", function () {
                                    loadHandle.remove();
                                    errorHandle.remove();
                                    if (!!_this.wmsLayerName) {
                                        // The feature layer is returned with non-existant types for the fields when we're working with WMS.
                                        // This is probably a stupid way to do this, as we're not even working with feature layers, but it works.
                                        var gcxFields = _this.fields;
                                        for (var i = featureLayer.fields.length - 1; i >= 0; i--) {
                                            var currentFeatureLayerField = featureLayer.fields[i];
                                            // Don't want to display the 'gml:id' field, it will break on querying.
                                            if (currentFeatureLayerField.name === "gml:id") {
                                                featureLayer.fields.splice(i, 1);
                                            }
                                            currentFeatureLayerField.type = essentials.Field.convertToEsriFieldType(gcxFields[i].dataType);
                                        }
                                    }
                                    resolve(featureLayer);
                                });
                                var errorHandle = featureLayer.on("error", function (error) {
                                    loadHandle.remove();
                                    errorHandle.remove();
                                    reject(error);
                                });
                            });
                        }
                        else {
                            this._featureLayerPromise = Promise.resolve(featureLayer);
                        }
                    }
                }
                return this._featureLayerPromise;
            };
            /**
             * Returns a Feature Layer for a given relationship ID.
             * @param relationshipId The id of the relationship.
             * @param callbackResults A callback to invoke upon success.
             * @param callbackErrors A callback to invoke if an error is encountered.
             */
            Layer.prototype.getRelatedFeatureLayer = function (relationshipId, callbackResults, callbackErrors) {
                var def = new dojo.Deferred();
                var layerLoaded = function (result) {
                    geocortex.deferredResolve(def, result);
                    if (typeof (callbackResults) == "function") {
                        callbackResults(result);
                    }
                };
                var layerError = function (error) {
                    if (def && (def.fired == -1)) {
                        def.resolve(error);
                    }
                    if (typeof (callbackErrors) == "function") {
                        callbackErrors(error);
                    }
                };
                var relation = this._getRelation(relationshipId);
                // If the relation was not found, trigger an error
                if (!relation) {
                    var error = new Error("Relation not found: " + relationshipId);
                    if (def && (def.fired == -1)) {
                        def.resolve(error);
                    }
                    if (typeof (callbackErrors) == "function") {
                        callbackErrors(error);
                    }
                    return def;
                }
                var layerUrl = this.getLayerUrl();
                // The url to the relationship is the same as this layer's url except for the layer id at the end of the url
                var url = layerUrl.substring(0, layerUrl.lastIndexOf("/") + 1) + relation.relatedTableId;
                if (this.mapService && this.mapService.serviceToken) {
                    url += url.indexOf("?") > -1
                        ? "&token="
                        : "?token=";
                    url += encodeURIComponent(this.mapService.serviceToken);
                }
                if (esri.getProxyRule(url) === undefined && this.mapService.proxyUrl !== null) {
                    esri.addProxyRule({
                        urlPrefix: url,
                        proxyUrl: this.mapService.proxyUrl
                    });
                }
                var layer = new esri.layers.FeatureLayer(url, {
                    mode: esri.layers.FeatureLayer.MODE_SELECTION,
                    outFields: ["*"]
                });
                if (layer.loaded) {
                    layerLoaded(layer);
                }
                else {
                    dojo.connect(layer, "onLoad", dojo.hitch(this, layerLoaded));
                }
                dojo.connect(layer, "onError", dojo.hitch(this, layerError));
                return def;
            };
            /**
             * Gets a value representing whether or not all of this layer's ancestors are currently visible in the map. */
            Layer.prototype.areAllAncestorsVisible = function () {
                var parentLayer = this.mapService.findLayerById(this.parentLayerId);
                while (parentLayer !== null && parentLayer !== undefined) {
                    if (!parentLayer.isVisible()) {
                        return false;
                    }
                    parentLayer = this.mapService.findLayerById(parentLayer.parentLayerId);
                }
                return true;
            };
            /**
             * Gets the URL to the actual Esri layer. */
            Layer.prototype.getLayerUrl = function () {
                if (this.mapService && this.mapService.serviceUrl) {
                    // If it's a feature layer, we don't need to append the layer ID
                    if (this.mapService.drawingBehavior === "FeatureLayer") {
                        return this.mapService.serviceUrl;
                    }
                    else if (this.mapService.mapServiceType === "WMS") {
                        // Since Essentials communicates with WMS servers, we should target Essentials' endpoint.
                        var essentialsUrl = this.mapService.url + "/layers/" + this.id;
                        var token = essentials.RestHelperHTTPService.getTokenForScope(this.mapService.url);
                        if (token) {
                            essentialsUrl += essentialsUrl.indexOf("?") > -1 ? "&token=" : "?token=";
                            essentialsUrl += encodeURIComponent(token);
                        }
                        return essentialsUrl;
                    }
                    else {
                        // This is a regular map service, we need to append the layer ID at the end
                        return this.mapService.serviceUrl + "/" + this.id;
                    }
                }
                else {
                    return null;
                }
            };
            /**
             * Given a field name, returns the field object by that name.
             * @param name of the field to return
             */
            Layer.prototype.getFieldByName = function (name) {
                // Need this method to run in O(1) (constant) time, so it can be used inside another loop - don't want any of that O(n^2) stuff going on
                // Build up a lookup of field names to fields
                if (this.fields && this.fields.length > 0) {
                    if (!this._fieldLookup) {
                        this._fieldLookup = {};
                        for (var i = 0; i < this.fields.length; i++) {
                            var f = this.fields[i];
                            this._fieldLookup[f.name] = f;
                        }
                    }
                    return this._fieldLookup[name];
                }
                else {
                    return null;
                }
            };
            /**
             * Returns whether or not the layer is currently visible in the map. */
            Layer.prototype.isVisible = function () {
                return this._visible;
            };
            /**
             * Sets the visibility of the {@link Layer}. If the {@link Layer} is part of a tiled (or image) service, then the whole {@link MapService} visibility is set.
             * @param visible The visibility value to set.
             */
            Layer.prototype.setVisibility = function (value, doNotRefresh) {
                if (this.mapService) {
                    switch (this.mapService.mapServiceType) {
                        case geocortex.essentials.MapServiceType.DYNAMIC:
                        case geocortex.essentials.MapServiceType.FEATURE:
                        case geocortex.essentials.MapServiceType.WMS:
                        case geocortex.essentials.MapServiceType.WMTS:
                        case geocortex.essentials.MapServiceType.GEORSS:
                        case geocortex.essentials.MapServiceType.KML:
                        case geocortex.essentials.MapServiceType.TILED:
                            // Is it a dynamic or WMS map service layer
                            this._visible = value;
                            break;
                        default:
                            // TODO: We suspect the reason visibility is set to true has something to do with cached layers. Subject to further investigation.   
                            this._visible = true;
                            break;
                    }
                    this.mapService._setVisibility(this.id, this._visible, doNotRefresh);
                }
            };
            /**
             * Sets the inActiveTheme property of the {@link Layer}. Raises the "LayerInActiveThemeChangedEvent" event.
             * @param value The value to set.
             */
            Layer.prototype.setInActiveTheme = function (value) {
                this.inActiveTheme = value;
                dojo.publish("LayerInActiveThemeChangedEvent", this);
            };
            /**
             * Find the Report matching the specified report ID.
             * @param reportId The Id of the Report to find.
             */
            Layer.prototype.findReportById = function (reportId) {
                return geocortex.essentials.utilities.SiteResourceIdComparer.lookUp(this.reports, reportId);
            };
            /**
             * Determines if the specified scale is within this layer's min and max scale.
             * If a value is not provided for this parameter, then the map's current scale value will be used.
             * @param scale The scale value to test if it is between this layer's min and max scale.
             */
            Layer.prototype.withinScaleRange = function (scale) {
                if ((this.maxScale == 0 && this.minScale == Infinity)
                    || (isNaN(this.maxScale) && isNaN(this.minScale))) {
                    return true;
                }
                if (scale == null) {
                    scale = this.mapService.essentialsMap.calculateScale();
                }
                return this.maxScale < scale && scale < this.minScale;
            };
            /** @private */
            Layer.prototype._configureDataLinks = function (dataLinkResults, deepInitialize, site) {
                for (var i = 0; dataLinkResults && i < dataLinkResults.length; i++) {
                    var datalink = this.dataLinks[i] = new geocortex.essentials.DataLink(this.url + "/datalinks/" + dataLinkResults[i].id);
                    datalink.layer = this;
                    // _configureObject is private, so this is poor form
                    datalink._configureObject(dataLinkResults[i], deepInitialize);
                }
            };
            /** @private */
            Layer.prototype._idIsUnique = function (id) {
                if (this.mapService && id) {
                    var layerIds = [];
                    dojo.forEach(this.mapService.layers, function (layer) {
                        layerIds.push(layer.id);
                    });
                    if (layerIds.indexOf(id) < 0) {
                        // id is unique
                        return true;
                    }
                }
                return false;
            };
            /** @private */
            Layer.prototype._getUniqueId = function () {
                if (this.mapService) {
                    var layerIds = [];
                    dojo.forEach(this.mapService.layers, function (layer) {
                        layerIds.push(layer.id);
                    });
                    if (layerIds.length > 0) {
                        var highest = Math.max.apply(null, layerIds);
                        highest++;
                        return highest.toString();
                    }
                }
                return "0";
            };
            /**
             * Populates the *Layer* from a dynamic object which represents a layer.
             * @param layerDefinition An object which represents the Layer.
             */
            Layer.prototype.createFromDefinition = function (layerDefinition) {
                this._createFrom(layerDefinition);
            };
            /** @private */
            Layer.prototype._createFrom = function (results) {
                // NOTE: If you modify this code, you'll probably also need to modify toJson() as well.
                this.defaultVisibility = results.defaultVisibility;
                this.configuredVisible = results.visible;
                this.displayName = results.displayName || results.name;
                this.description = results.description;
                this.featureDescription = results.featureDescription;
                if (results.hasOwnProperty("featureLongDescription")) {
                    this.featureLongDescription = results.featureLongDescription;
                }
                else {
                    this.featureLongDescription = results.featureDescription;
                }
                this.featureLabel = results.featureLabel;
                this.featureType = results.featureType;
                this.featureZoomScale = results.featureZoomScale;
                this.featureZoomFactor = results.featureZoomFactor;
                this.hasDataLinks = results.hasDataLinks;
                this.hasReports = results.hasReports;
                this.hasAttachments = results.hasAttachments;
                if (results.hasOwnProperty("id")) {
                    this.id = results.id;
                }
                else {
                    this.id = this._getUniqueId();
                }
                this.name = results.name;
                this.wmsLayerName = results.nativeID;
                this.parentLayerId = results.parentLayerId;
                this.subLayerIds = results.subLayerIds;
                this._visible = results.visible;
                this.styleName = results.styleName;
                this.legendUrl = results.legendUrl;
                this.isDynamic = results.isDynamic;
                this.dynamicDefinition = results.dynamicDefinition;
                this.dataProvider = results.dataProvider;
                this.defaultDateFormat = results.defaultDateFormat;
                this.defaultNumberFormat = results.defaultNumberFormat;
                this.timeZoneId = results.timeZoneId;
                // GVH-7733 Need to call the proper constructor (the one that takes a json object) 
                // or else the map extent is set incorrectly once the site is initialized
                if (results.fullExtent) {
                    this.fullExtent = new esri.geometry.Extent(results.fullExtent);
                }
                if (results.hasOwnProperty("drawIndex")) {
                    this.drawIndex = results.drawIndex;
                }
                if (results.hasOwnProperty("identifiable")) {
                    this.identifiable = results.identifiable;
                }
                if (results.hasOwnProperty("includeInLayerList")) {
                    this.includeInLayerList = results.includeInLayerList;
                }
                if (results.hasOwnProperty("includeInLegend")) {
                    this.includeInLegend = results.includeInLegend;
                }
                if (results.hasOwnProperty("featureBorderColor")) {
                    this.featureBorderColor = results.featureBorderColor;
                    if (this.featureBorderColor && this.featureBorderColor.length >= 4 && this.featureBorderColor[3] >= 1.0) {
                        // Essentials gives alpha in 0-255 but standard is 0-1.0
                        this.featureBorderColor[3] /= 255;
                    }
                }
                if (results.hasOwnProperty("featureBorderWidth")) {
                    this.featureBorderWidth = results.featureBorderWidth;
                }
                if (results.hasOwnProperty("featureFillColor")) {
                    this.featureFillColor = results.featureFillColor;
                    if (this.featureFillColor && this.featureFillColor.length >= 4 && this.featureFillColor[3] >= 1.0) {
                        // Essentials gives alpha in 0-255 but standard is 0-1.0
                        this.featureFillColor[3] /= 255;
                    }
                }
                // Essentials sends zero for Infinity, so if minScale is zero it should be Infinity
                if (results.hasOwnProperty("minScale") && !isNaN(results.minScale) && results.minScale != 0) {
                    this.minScale = results.minScale;
                }
                else {
                    this.minScale = Infinity;
                }
                if (results.hasOwnProperty("maxScale") && !isNaN(results.maxScale)) {
                    this.maxScale = results.maxScale;
                }
                else {
                    this.maxScale = 0;
                }
                // If the map service has more restrictive minScale and/or maxScale settings defined, then they overrides the layer's settings.
                if (this.mapService && this.mapService.minScale != null && !isNaN(this.mapService.minScale)) {
                    this.minScale = Math.min(this.minScale, this.mapService.minScale);
                }
                if (this.mapService && this.mapService.maxScale != null && !isNaN(this.mapService.maxScale)) {
                    this.maxScale = Math.max(this.maxScale, this.mapService.maxScale);
                }
                if (results.hasOwnProperty("queryable")) {
                    this.queryable = results.queryable;
                }
                if (results.hasOwnProperty("searchable")) {
                    this.searchable = results.searchable;
                }
                if (results.hasOwnProperty("snappable")) {
                    this.snappable = results.snappable;
                }
                if (results.hasOwnProperty("snappingEnabled")) {
                    this.snappingEnabled = results.snappingEnabled;
                }
                if (results.hasOwnProperty("showFeatureHyperlinks")) {
                    this.showFeatureHyperlinks = results.showFeatureHyperlinks;
                }
                if (results.hasOwnProperty("canToggleLabels")) {
                    this.canToggleLabels = results.canToggleLabels;
                }
                if (results.hasOwnProperty("showLabels")) {
                    this.showLabels = results.showLabels;
                }
                if (results.hasOwnProperty("showMapTips")) {
                    this.showMapTips = results.showMapTips;
                }
                if (results.hasOwnProperty("supportsIdentify")) {
                    this.supportsIdentify = results.supportsIdentify;
                }
                if (results.hasOwnProperty("supportsQuery")) {
                    this.supportsQuery = results.supportsQuery;
                }
                if (results.hasOwnProperty("layerHyperlinks")) {
                    for (i = 0; i < results.layerHyperlinks.length; i++) {
                        this.layerHyperlinks[i] = new geocortex.essentials.LayerHyperlink(results.layerHyperlinks[i], this);
                    }
                }
                if (results.type !== undefined) {
                    this.type = this._layerTypeStringToEssentialsLayerType(results.type);
                }
                if (results.fields) {
                    for (var i = 0; i < results.fields.length; i++) {
                        var field = results.fields[i];
                        var fieldInfo = {
                            layer: this,
                            dataType: geocortex.essentials.Field.convertFromEsriType(field.type || field.dataType),
                            alias: field.alias,
                            displayName: field.displayName || field.alias || field.name,
                            name: field.name,
                            searchable: true,
                            visible: true,
                            focusField: false,
                            hyperlinkLabel: null,
                            format: field.format
                        };
                        if (field.hasOwnProperty("searchable")) {
                            fieldInfo.searchable = field.searchable;
                        }
                        if (field.hasOwnProperty("visible")) {
                            fieldInfo.visible = field.visible;
                        }
                        this.fields[i] = new geocortex.essentials.Field(fieldInfo);
                    }
                }
                this.primaryKeyField = this.getFieldByName(results.primaryKeyField);
                this.displayField = this.getFieldByName(results.displayField);
                if (results.properties) {
                    this.catalogId = geocortex._getProperties(results["properties"]).layerCatalogLookupId;
                }
                this.isInitialized = true;
            };
            /** @private */
            Layer.prototype._configureObject = function (results, deepInitialize) {
                if (results === undefined || results.name === undefined || results.id === undefined || results.hasDataLinks === undefined) {
                    throw new Error("Incorrect layer object returned from initialization");
                }
                this.allowSymbolization = results.allowSymbolization;
                this.defaultVisibility = results.defaultVisibility;
                this.configuredVisible = results.visible;
                this.displayName = results.displayName;
                this.description = results.description;
                this.featureDescription = results.featureDescription;
                if (results.hasOwnProperty("featureLongDescription")) {
                    this.featureLongDescription = results.featureLongDescription;
                }
                else {
                    this.featureLongDescription = results.featureDescription;
                }
                this.featureLabel = results.featureLabel;
                this.featureType = results.featureType === undefined ? this.featureType : results.featureType;
                this.featureZoomScale = results.featureZoomScale === undefined ? this.featureZoomScale : results.featureZoomScale;
                this.featureZoomFactor = results.featureZoomFactor === undefined ? this.featureZoomFactor : results.featureZoomFactor;
                this.hasDataLinks = results.hasDataLinks;
                this.hasReports = results.hasReports;
                this.hasAttachments = results.hasAttachments;
                this.id = results.id;
                this.name = results.name;
                this.wmsLayerName = results.nativeID;
                this.parentLayerId = results.parentLayerId;
                this.subLayerIds = results.subLayerIds;
                this.styleName = results.styleName;
                this.legendUrl = results.legendUrl;
                this.isDynamic = results.isDynamic === undefined ? this.isDynamic : results.isDynamic;
                this.dynamicDefinition = results.dynamicDefinition;
                this.dataProvider = results.dataProvider;
                this.defaultDateFormat = results.defaultDateFormat;
                this.defaultNumberFormat = results.defaultNumberFormat;
                this.timeZoneId = results.timeZoneId;
                this._timeInfo = results.timeInfo ? results.timeInfo : null;
                // GVH-7733 Need to call the proper constructor (the one that takes a json object) 
                // or else the map extent is set incorrectly once the site is initialized
                if (results.fullExtent) {
                    this.fullExtent = new esri.geometry.Extent(results.fullExtent);
                }
                var site = null;
                if ((this.mapService) && (this.mapService.essentialsMap)) {
                    site = this.mapService.essentialsMap.site;
                }
                this.iconUri = geocortex.essentials.RestHelper.processClientSideTokens(site, results.iconUri);
                if (results.hasOwnProperty("includeInLayerList")) {
                    this.includeInLayerList = results.includeInLayerList;
                }
                if (this.mapService.essentialsMap.layerThemesInfo.startupThemeId != null && this.includeInLayerList) {
                    // The initial visibility will be based on visibilty in the startup theme (below).
                    this._visible = false;
                }
                else {
                    this._visible = results.initiallyVisible === undefined ? !!results.visible : !!results.initiallyVisible;
                }
                if (results.themeSettings && results.themeSettings.length) {
                    for (var x = 0; x < results.themeSettings.length; x++) {
                        var themeSetting = results.themeSettings[x];
                        var layerTheme = this.mapService.essentialsMap.layerThemesInfo.getTheme(themeSetting.themeID);
                        if (layerTheme) {
                            var isVisible = (themeSetting.visible == undefined) ? this.configuredVisible : themeSetting.visible;
                            this.layerThemeSettings.push(new essentials.LayerThemeSetting(layerTheme, isVisible));
                            if (layerTheme.id === this.mapService.essentialsMap.layerThemesInfo.startupThemeId && this.includeInLayerList) {
                                this._visible = themeSetting.initiallyVisible === undefined ? isVisible : themeSetting.initiallyVisible;
                            }
                        }
                    }
                }
                if (results.hasOwnProperty("drawIndex")) {
                    this.drawIndex = results.drawIndex;
                }
                if (results.hasOwnProperty("featureBorderColor")) {
                    this.featureBorderColor = results.featureBorderColor;
                    if (this.featureBorderColor && this.featureBorderColor.length >= 4 && this.featureBorderColor[3] >= 1.0) {
                        // Essentials gives alpha in 0-255 but standard is 0-1.0
                        this.featureBorderColor[3] /= 255;
                    }
                }
                if (results.hasOwnProperty("featureBorderWidth")) {
                    this.featureBorderWidth = results.featureBorderWidth;
                }
                if (results.hasOwnProperty("featureFillColor")) {
                    this.featureFillColor = results.featureFillColor;
                    if (this.featureFillColor && this.featureFillColor.length >= 4 && this.featureFillColor[3] >= 1.0) {
                        // Essentials gives alpha in 0-255 but standard is 0-1.0
                        this.featureFillColor[3] /= 255;
                    }
                }
                if (results.hasOwnProperty("identifiable")) {
                    this.identifiable = results.identifiable;
                }
                if (results.hasOwnProperty("includeInLegend")) {
                    this.includeInLegend = results.includeInLegend;
                }
                // Essentials sends zero for Infinity, so if minScale is zero it should be Infinity
                if (results.hasOwnProperty("minScale") && !isNaN(results.minScale) && results.minScale != 0) {
                    this.minScale = results.minScale;
                }
                else {
                    this.minScale = Infinity;
                }
                if (results.hasOwnProperty("maxScale") && !isNaN(results.maxScale)) {
                    this.maxScale = results.maxScale;
                }
                else {
                    this.maxScale = 0;
                }
                // If the map service has more restrictive minScale and/or maxScale settings defined, then they overrides the layer's settings.
                if (this.mapService && this.mapService.minScale != null && !isNaN(this.mapService.minScale)) {
                    this.minScale = Math.min(this.minScale, this.mapService.minScale);
                }
                if (this.mapService && this.mapService.maxScale != null && !isNaN(this.mapService.maxScale)) {
                    this.maxScale = Math.max(this.maxScale, this.mapService.maxScale);
                }
                if (results.hasOwnProperty("queryable")) {
                    this.queryable = results.queryable;
                }
                if (results.hasOwnProperty("searchable")) {
                    this.searchable = results.searchable;
                }
                if (results.hasOwnProperty("showFeatureHyperlinks")) {
                    this.showFeatureHyperlinks = results.showFeatureHyperlinks;
                }
                if (results.hasOwnProperty("canToggleLabels")) {
                    this.canToggleLabels = results.canToggleLabels;
                }
                if (results.hasOwnProperty("showLabels")) {
                    this.showLabels = results.showLabels;
                }
                if (results.hasOwnProperty("showMapTips")) {
                    this.showMapTips = results.showMapTips;
                }
                if (results.hasOwnProperty("snappable")) {
                    this.snappable = results.snappable;
                }
                if (results.hasOwnProperty("snappingEnabled")) {
                    this.snappingEnabled = results.snappingEnabled;
                }
                if (results.hasOwnProperty("supportsIdentify")) {
                    this.supportsIdentify = results.supportsIdentify;
                }
                if (results.hasOwnProperty("supportsQuery")) {
                    this.supportsQuery = results.supportsQuery;
                }
                if (results.type !== undefined) {
                    this.type = this._layerTypeStringToEssentialsLayerType(results.type);
                }
                if ((this.type == geocortex.essentials.LayerType.GROUP_LAYER) && results.hasOwnProperty("isExpanded")) {
                    this.isExpanded = results.isExpanded;
                }
                var i;
                // featureHyperlinks will be null for Essentials prior to 3.3
                if (results.featureHyperlinks) {
                    for (i = 0; i < results.featureHyperlinks.length; i++) {
                        this.featureHyperlinks[i] = new geocortex.essentials.FeatureHyperlink(results.featureHyperlinks[i], this);
                    }
                }
                if (results.fields) {
                    for (i = 0; i < results.fields.length; i++) {
                        results.fields[i].layer = this;
                        this.fields[i] = new geocortex.essentials.Field(results.fields[i]);
                    }
                }
                if (results.relationships) {
                    for (i = 0; i < results.relationships.length; i++) {
                        // There is no displayName property on a esri.layers.Relationship. There is a name property. Copy the Essentials displayName into the name.
                        if (results.relationships[i].displayName) {
                            results.relationships[i].name = results.relationships[i].displayName;
                        }
                        // This is a fix to the fact that Essentials returns those are string when they should be int (GE-2247)
                        results.relationships[i].id = parseInt(results.relationships[i].id);
                        results.relationships[i].relatedTableId = parseInt(results.relationships[i].relatedTableId);
                        this.relationships.push(results.relationships[i]);
                    }
                }
                if (results.hasOwnProperty("layerHyperlinks")) {
                    for (i = 0; i < results.layerHyperlinks.length; i++) {
                        this.layerHyperlinks[i] = new geocortex.essentials.LayerHyperlink(results.layerHyperlinks[i], this);
                    }
                }
                // GVH-4178 Charting is an optional component so we need to make sure it is loaded before we instantiate any of its classes
                if (results.hasOwnProperty("charts") && geocortex.charting && dojo.isObject(geocortex.charting.configuration.ChartDefinition)) {
                    for (i = 0; i < results.charts.length; i++) {
                        this.charts.push(new geocortex.essentials.LayerChart(results.charts[i], this));
                    }
                }
                // Populate layer styles array
                if (results.styles && results.styles.length) {
                    for (i = 0; i < results.styles.length; i++) {
                        var style = results.styles[i];
                        var rendererJson = style.definition;
                        if (rendererJson) {
                            this.styles.push(new essentials.LayerStyle(rendererJson, style.displayName, style.id));
                        }
                    }
                }
                this.primaryKeyField = this.getFieldByName(results.primaryKeyField);
                this.displayField = this.getFieldByName(results.displayField);
                this._configureDataLinks(results.dataLinks, deepInitialize, site);
                this._configureReports(results.reports, deepInitialize);
                if (deepInitialize) {
                    this.isInitialized = true;
                }
                // add the properties
                this.properties = geocortex._getProperties(results.properties);
                // add the extensions
                this.extensions = geocortex._getExtensions(results.extensions);
            };
            /**
             * Exports the state of the layer as a JSON object. This can be used to recreate the
             * layer again via createFromDefinition().
             */
            Layer.prototype.toJson = function () {
                return {
                    id: this.id,
                    name: this.name,
                    url: this.url,
                    defaultVisibility: this.defaultVisibility,
                    visible: this.configuredVisible,
                    displayName: this.displayName,
                    description: this.description,
                    featureDescription: this.featureDescription,
                    featureLongDescription: this.featureLongDescription,
                    featureLabel: this.featureLabel,
                    featureType: this.featureType,
                    featureZoomScale: this.featureZoomScale,
                    featureZoomFactor: this.featureZoomFactor,
                    hasDataLinks: this.hasDataLinks,
                    hasReports: this.hasReports,
                    hasAttachments: this.hasAttachments,
                    nativeID: this.wmsLayerName,
                    parentLayerId: this.parentLayerId,
                    subLayerIds: (this.subLayerIds || []).slice(),
                    styleName: this.styleName,
                    legendUrl: this.legendUrl,
                    isDynamic: this.isDynamic,
                    dynamicDefinition: this.dynamicDefinition,
                    dataProvider: this.dataProvider,
                    defaultDateFormat: this.defaultDateFormat,
                    defaultNumberFormat: this.defaultNumberFormat,
                    fullExtent: this.fullExtent ? this.fullExtent.toJson() : undefined,
                    drawIndex: this.drawIndex,
                    identifiable: this.identifiable,
                    includeInLayerList: this.includeInLayerList,
                    includeInLegend: this.includeInLegend,
                    featureBorderColor: this.featureBorderColor,
                    featureBorderWidth: this.featureBorderWidth,
                    featureFillColor: this.featureFillColor,
                    minScale: this.minScale === Infinity ? 0 : this.minScale,
                    maxScale: this.maxScale,
                    queryable: this.queryable,
                    searchable: this.searchable,
                    snappable: this.snappable,
                    snappingEnabled: this.snappingEnabled,
                    showFeatureHyperlinks: this.showFeatureHyperlinks,
                    canToggleLabels: this.canToggleLabels,
                    showLabels: this.showLabels,
                    showMapTips: this.showMapTips,
                    supportsIdentify: this.supportsIdentify,
                    supportsQuery: this.supportsQuery,
                    layerHyperlinks: this.layerHyperlinks.map(function (link) { return link.toJson(); }),
                    type: this._essentialsLayerTypeToLayerTypeString(this.type),
                    fields: this.fields.map(function (field) { return field.toJson(); }),
                    primaryKeyField: this.primaryKeyField ? this.primaryKeyField.name : undefined,
                    displayField: this.displayField ? this.displayField.name : undefined,
                    catalogId: this.catalogId ? this.catalogId : undefined
                };
            };
            /** @private */
            Layer.prototype._configureReports = function (reportResults, deepInitialize) {
                for (var i = 0; reportResults && i < reportResults.length; i++) {
                    this.reports[i] = new geocortex.essentials.Report(this.url + "/reports/" + reportResults[i].id);
                    this.reports[i].layer = this;
                    // attach a site reference on the report
                    if (this.mapService && this.mapService.essentialsMap && this.mapService.essentialsMap.site) {
                        this.reports[i].site = this.mapService.essentialsMap.site;
                    }
                    this.reports[i]._configureObject(reportResults[i], deepInitialize);
                }
            };
            /** Retrieve the layer time info if available. This method needs to be called after the service layers have loaded. */
            Layer.prototype.getLayerTimeInfo = function () {
                var _this = this;
                if (!this.mapService || !this.mapService.isTimeAware) {
                    return null;
                }
                if (this._gcxTimeInfo) {
                    return this._gcxTimeInfo;
                }
                var setTimeInfo = function (timeInfoRestObject) {
                    if (timeInfoRestObject) {
                        _this._timeInfo = timeInfoRestObject;
                        _this._gcxTimeInfo = essentials.MapService.getGcxTimeInfo(_this._timeInfo);
                        return _this._gcxTimeInfo;
                    }
                };
                var requestLayerTimeInfo = function () {
                    if (!_this.mapService.serviceLayer || !_this.mapService.serviceLayer.url) {
                        return;
                    }
                    // We'll unfortunately have to issue a new request in order to retrieve the layer's time information. This is not accessible from the esri's service layer object.
                    var layerUrl = _this.mapService.serviceLayer.url + "/" + _this.id;
                    geocortex.request({
                        url: layerUrl,
                        content: {
                            f: "json"
                        },
                        load: function (results) { return setTimeInfo(results.timeInfo); },
                        error: function (err) {
                            console.log("Error loading layer time information. " + err.message ? err.message : "");
                        },
                        callbackParamName: "CallBack"
                    });
                };
                if (this._timeInfo) {
                    setTimeInfo(this._timeInfo);
                }
                else {
                    requestLayerTimeInfo();
                }
            };
            /**
             * Determine what the Esri OBJECTID field name is for the feature in the layer. */
            Layer.prototype.getObjectIdFieldName = function () {
                var fieldName = null;
                // If we have a layer, let's get it from there
                if (this.primaryKeyField) {
                    fieldName = this.primaryKeyField.name;
                }
                return fieldName;
            };
            /** @private */
            Layer.prototype._layerTypeStringToEssentialsLayerType = function (layerType) {
                if (layerType == "FeatureLayer" || layerType == "DynamicFeatureLayer") {
                    return geocortex.essentials.LayerType.FEATURE_LAYER;
                }
                if (layerType == "GroupLayer" || layerType == "AnnotationLayer") {
                    return geocortex.essentials.LayerType.GROUP_LAYER;
                }
                if (layerType == "RasterLayer") {
                    return geocortex.essentials.LayerType.RASTER_LAYER;
                }
                if (layerType == "GeoRssLayer") {
                    return geocortex.essentials.LayerType.GEO_RSS_LAYER;
                }
                if (layerType == "TableLayer") {
                    return geocortex.essentials.LayerType.TABLE_LAYER;
                }
                return geocortex.essentials.LayerType.UNKNOWN;
            };
            /** @private */
            Layer.prototype._essentialsLayerTypeToLayerTypeString = function (layerType) {
                switch (layerType) {
                    case geocortex.essentials.LayerType.FEATURE_LAYER:
                        return "FeatureLayer";
                    case geocortex.essentials.LayerType.GROUP_LAYER:
                        return "GroupLayer";
                    case geocortex.essentials.LayerType.RASTER_LAYER:
                        return "RasterLayer";
                    case geocortex.essentials.LayerType.GEO_RSS_LAYER:
                        return "GeoRssLayer";
                    default:
                        return "Unknown";
                }
            };
            /** @private */
            Layer.prototype._getRelation = function (relationshipId) {
                if (typeof (relationshipId) == "string") {
                    relationshipId = parseInt(relationshipId); // Need a parseInt, see GE-2247
                }
                for (var i = 0; i < this.relationships.length; i++) {
                    if (this.relationships[i].id == relationshipId) {
                        return this.relationships[i];
                    }
                }
                return null;
            };
            /**
           * Returns a string representing the layers definition expression.
           * Uses a service layer if passed in to find the most up to date definition expression.
           * If no service layer, get the definition expression for the layers dynamic definition json.
           * A service layer would be useless here if you were initializing these layers for the first time. (ie. it is not added yet.)
           * @param serviceLayer Service layer.
           * @return The definition expression.
           */
            Layer.prototype.getDefinitionExpression = function (serviceLayer) {
                var result = null;
                var id = parseInt(this.id);
                // Check if we have a service layer argument.
                if (serviceLayer) {
                    if (serviceLayer instanceof esri.layers.ArcGISDynamicMapServiceLayer) {
                        var defs = serviceLayer.layerDefinitions;
                        if (defs && defs[id]) {
                            result = defs[id];
                        }
                    }
                    else if ((serviceLayer instanceof esri.layers.FeatureLayer)) {
                        var featureDef = serviceLayer.getDefinitionExpression();
                        if (featureDef) {
                            result = featureDef;
                        }
                    }
                }
                // If we did not find a definition in the service layer or did not have a service layer, go and get it from the dynamic definition json.
                if (!result) {
                    if (this.dynamicDefinition) {
                        result = geocortex.essentials.RestHelper.getDynamicExpressionFromJson(this.dynamicDefinition);
                    }
                }
                return result;
            };
            /** @private */
            Layer.prototype._createDynamicLayerInfo = function () {
                var dynamicLayerInfo = null;
                if (this.isDynamic) {
                    dynamicLayerInfo = geocortex.essentials.RestHelper.getDynamicLayerInfoFromJson(this.dynamicDefinition, this.id);
                    if (this.minScale < Infinity) {
                        dynamicLayerInfo.minScale = this.minScale;
                    }
                    if (this.maxScale > 0) {
                        dynamicLayerInfo.maxScale = this.maxScale;
                    }
                }
                return dynamicLayerInfo;
            };
            /**
             * Gets the layers drawing options from the dynamicDefinition.
             * @returns The *LayerDrawingOptions* for the layer or null.
             */
            Layer.prototype.getLayerDrawingOptions = function () {
                var layerDrawingOptions = null;
                if (this.isDynamic) {
                    layerDrawingOptions = geocortex.essentials.RestHelper.getLayerDrawingOptionsFromJson(this.dynamicDefinition);
                }
                return layerDrawingOptions;
            };
            Layer.prototype.getLayerThemeSettings = function (layerThemeOrId) {
                for (var x = 0; x < this.layerThemeSettings.length; x++) {
                    var layerThemeSetting = this.layerThemeSettings[x];
                    if ((layerThemeSetting.theme === layerThemeOrId) || (layerThemeSetting.theme.id === layerThemeOrId)) {
                        return layerThemeSetting;
                    }
                }
                return null;
            };
            /**
             * Accessor method for the LayerVisibilityEventManager class in MapService.ts to sync layer visibility with
             * programmatic layer visibility changed made using esri's setLayerVisibility method.
             * @private
             */
            Layer.prototype._syncProgramaticallyChangedLayerVisibility = function (visible) {
                this._visible = visible;
            };
            return Layer;
        }(essentials.AsyncInitializable));
        essentials.Layer = Layer;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents a parameter in a {@link geocortex.essentials.DataLink} relationship to an external data source.
         */
        var DataLinkParameter = (function () {
            function DataLinkParameter() {
                /** The name of the feature field of the {@link DataLinkParameter}. */
                this.featureField = null;
                /** The ID of the {@link geocortex.essentials.DataLinkParameter}. */
                this.id = null;
                /** The name of the {@link geocortex.essentials.DataLinkParameter}. */
                this.name = null;
                /** The type of the {@link geocortex.essentials.DataLinkParameter}. */
                this.type = null;
            }
            return DataLinkParameter;
        }());
        essentials.DataLinkParameter = DataLinkParameter;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="Layer.ts" />
/// <reference path="DataLinkParameter.ts" />
/// <reference path="AsyncInitializable.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents a DataLink as defined by a {@link geocortex.essentials.Layer}.
         * A data link is a data relation between spatial attributes and tabular data from a foreign data source, such as a SQL database or a spreadsheet.
         * {@link DataLink}s allow data from external data sources to be pulled into web mapping applications.
         */
        var DataLink = (function (_super) {
            __extends(DataLink, _super);
            /**
             * Initializes a new instance of the {@link geocortex.essentials.DataLink} class.
             * @param The URL to a DataLink endpoint.
             */
            function DataLink(url) {
                _super.call(this, url);
                /** The display name. */
                this.displayName = null;
                /**
                 * The collection of {@link geocortex.essentials.Extension}s associated with the data link.
                 * Extensions can be defined by the administrator on the server.
                 */
                this.extensions = [];
                /** The ID of the {@link DataLink} */
                this.id = null;
                /** The visibility of the {@link DataLink}. */
                this.visible = null;
                /**
                 * Indicates whether the data fetched by the datalink represents a one to one relationship with the feature.
                 */
                this.isOneToOne = false;
                /** The {@link Layer} that this {@link DataLink} belongs to. */
                this.layer = null;
                /** The parameters of the data link. */
                this.parameters = [];
                /** The collection of search tables for the data link. */
                this.searches = [];
                /**
                 * Arbitrary properties associated with this {@link DataLink}.
                 * The properties are defined by the administrator on the server.
                 */
                this.properties = {};
                /** The number of outstanding requests to fetch data links. */
                this._numDataLinkingRequests = 0;
            }
            /**
             * Gets whether the {@link geocortex.essentials.DataLink} is currently performing data linking.
             * @return {boolean} True if datalinking is currently being performed, false otherwise.
             */
            DataLink.prototype.isDataLinking = function () {
                return !!this._numDataLinkingRequests;
            };
            /**
             * Performs the data linking operation using set of feature attributes required during the operation. This is an asynchronous method; you may provide delegates for completion or error information.
             * @param featureSetParameters An esri.tasks.FeatureSet that contains the attributes defined in the parameters. The method uses only the required attributes and ignores any other attributes in the feature set.
             * @param dataLinkingComplete The delegate that will be called when the operation has completed, even if an error occurs. This delegate expects one argument: an Object containing the result.
             * @param dataLinkingError The delegate that will be called if an error occurs during the operation. This delegate expects two arguments: a reference to the DataLink instance, and an Error.
             */
            DataLink.prototype.performDataLinking = function (featureSetParameters, dataLinkingComplete, dataLinkingError) {
                var _this = this;
                var executeErrorCallback = function (msg) {
                    if (dataLinkingError) {
                        dataLinkingError(new Error(msg));
                    }
                    return;
                };
                if (!featureSetParameters && this.parameters.length > 0) {
                    executeErrorCallback("No FeatureSetParameters provided");
                }
                var dataLinkUrl = this.url + "/link";
                var fields = null;
                for (var paramIndex = 0; paramIndex < this.parameters.length; paramIndex++) {
                    var param = this.parameters[paramIndex];
                    var valueList = "";
                    for (var featIndex = 0; featIndex < featureSetParameters.features.length; featIndex++) {
                        var graphic = featureSetParameters.features[featIndex];
                        var fieldValue = graphic.attributes[param.featureField];
                        if (!fieldValue) {
                            // the attributes did not contain the feature field. Perhaps the FeatureSet contains 
                            // aliased attributes. Use the layer's fields to lookup the alias.
                            if (this.layer && this.layer.fields) {
                                // find a field who's name matches the featureField we're looking for. We only require one, so once you find one, go on.
                                var field;
                                for (var fieldIndex = 0; fieldIndex < this.layer.fields.length; fieldIndex++) {
                                    var aField = this.layer.fields[fieldIndex];
                                    if (aField.name === param.featureField) {
                                        field = aField;
                                        break;
                                    }
                                }
                                // Check if we actually have a field that matches the parameter we're looking for
                                if (field) {
                                    // Check if the field has an alias or displayName, and if so, use that to try to get the attribute from the feature
                                    var fieldAlias;
                                    if (field.alias && field.alias in graphic.attributes) {
                                        fieldAlias = field.alias;
                                    }
                                    else if (field.displayName && field.displayName in graphic.attributes) {
                                        fieldAlias = field.displayName;
                                    }
                                    // Use the field alias to get the attribute
                                    if (fieldAlias && fieldAlias in graphic.attributes) {
                                        fieldValue == graphic.attributes[fieldAlias];
                                    }
                                }
                            }
                        }
                        // If we actually have a field value, add it to the list of items to resolve, else pass in an empty string
                        valueList += (valueList.length === 0 ? "" : ",") + (fieldValue ? this._prepParamValue(fieldValue) : " ");
                    }
                    // If we actually have values to resolve, add them to field parameters
                    if (valueList && valueList.length > 0) {
                        fields = (fields === null) ? {} : fields;
                        fields[param.id] = valueList;
                    }
                }
                if (fields) {
                    // Convert the fields to a json object to include with our request
                    var content = geocortex.encodeJson(dojo.mixin({
                        f: "json"
                    }, fields));
                    this._numDataLinkingRequests++;
                    var onComplete = function (result) {
                        _this._numDataLinkingRequests--;
                        if (!result && dataLinkingError) {
                            dataLinkingError(new Error("No results"));
                        }
                        if (result.error && dataLinkingError) {
                            dataLinkingError(result.error);
                        }
                        if (dataLinkingComplete) {
                            dataLinkingComplete(_this._parseConvertDates(result.results));
                        }
                    };
                    var onError = function (er) {
                        _this._numDataLinkingRequests--;
                        if (dataLinkingError) {
                            dataLinkingError(er);
                        }
                    };
                    geocortex.request({
                        url: dataLinkUrl,
                        content: content,
                        load: onComplete,
                        error: onError,
                        callbackParamName: "CallBack"
                    });
                }
                else {
                    executeErrorCallback("Missing Feature Fields.");
                }
            };
            /** @private */
            DataLink.prototype._configureObject = function (results, deepInitialize) {
                if (results === undefined || results.displayName === undefined || results.parameters === undefined) {
                    throw new Error("Incorrect data link object returned from initialization");
                }
                this.displayName = results.displayName;
                this.id = results.id;
                this.visible = results.visible === undefined ? true : results.visible;
                this.isOneToOne = !!results.isOneToOne;
                this.parameters = results.parameters;
                this.searches = results.searches;
                // Attach the datalink to every DataLinkSearch
                if (this.searches) {
                    for (var i = 0, il = this.searches.length; i < il; i++) {
                        this.searches[i].dataLink = this;
                    }
                }
                if (deepInitialize) {
                    this.isInitialized = true;
                }
                this.properties = geocortex._getProperties(results.properties);
                this.extensions = geocortex._getExtensions(results.extensions);
            };
            DataLink.prototype._parseConvertDates = function (jsonObject) {
                for (var key in jsonObject) {
                    if (jsonObject.hasOwnProperty(key)) {
                        var value = jsonObject[key];
                        // Check if the value is "/Date(" and if it is, then convert it to a Date instance.
                        if (typeof value === "string") {
                            if (value.length > 6 && value.substring(0, 6) === "/Date(") {
                                value = parseInt(value.substring(6));
                                var aDate = new Date(value);
                                jsonObject[key] = aDate;
                            }
                        }
                        else if (typeof value === "object") {
                            // If it wasn't a string, but it is an object, perform a recursive descent on it
                            jsonObject[key] = this._parseConvertDates(value);
                        }
                    }
                }
                return jsonObject;
            };
            /** @private */
            DataLink.prototype._prepParamValue = function (param) {
                var result = "";
                if (typeof param === "number") {
                    result = param.toString();
                }
                else if (typeof param === "string") {
                    result = param.replace(/,/g, "\\,");
                }
                return result;
            };
            return DataLink;
        }(essentials.AsyncInitializable));
        essentials.DataLink = DataLink;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="DataLink.ts" />
/// <reference path="AsyncInitializable.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var documents;
        (function (documents) {
            /**
             * String constants that represent the various fields of a {@link Document}.
             * @private
             */
            var DocumentField;
            (function (DocumentField) {
                DocumentField.AUTHOR_DESCRIPTION = "author.description";
                DocumentField.AUTHOR_ISSUER_TITLE = "author.issuerTitle";
                DocumentField.AUTHOR_TITLE = "author.title";
                DocumentField.DESCRIPTION = "description";
                DocumentField.EDITOR_DESCRIPTION = "editor.description";
                DocumentField.EDITOR_ISSUER_TITLE = "editor.issuerTitle";
                DocumentField.EDITOR_TITLE = "editor.title";
                DocumentField.FILE_TYPE = "fileType";
                DocumentField.GRANT_TOKEN = "grants.token";
                DocumentField.ISSUER_TITLE = "issuerTitle";
                DocumentField.TAGS = "tags";
                DocumentField.TIME_CREATION = "timeOfCreation";
                DocumentField.TIME_LAST_ACCESS = "timeOfLastAccess";
                DocumentField.TIME_LAST_MODIFICATION = "timeOfLastModification";
                DocumentField.TITLE = "title";
            })(DocumentField = documents.DocumentField || (documents.DocumentField = {}));
            /**
             * String constants that represent the content types of a {@link Document}.
             * @private
             */
            var ContentType;
            (function (ContentType) {
                ContentType.BLOB = "application/octet-stream";
                ContentType.JSON = "application/json";
                ContentType.TEXT = "text/plain";
                ContentType.XML = "application/xml";
            })(ContentType = documents.ContentType || (documents.ContentType = {}));
            /**
             * String constants that represent the formats of the {@link Document} content.
             * @private
             */
            var DocumentFormat;
            (function (DocumentFormat) {
                DocumentFormat.BLOB = "blob";
                DocumentFormat.JSON = "json";
                DocumentFormat.TEXT = "text";
                DocumentFormat.XML = "xml";
            })(DocumentFormat = documents.DocumentFormat || (documents.DocumentFormat = {}));
            /**
             * String constants that represent the grant kinds of a {@link Document}.
             * @private
             */
            var GrantKind;
            (function (GrantKind) {
                GrantKind.FROZEN = "frozen";
                GrantKind.OWNER = "owner";
                GrantKind.READER = "reader";
                GrantKind.WRITER = "writer";
                GrantKind.READER_LINK = "readerLink";
                GrantKind.WRITER_LINK = "writerLink";
                GrantKind.GLOBAL_CREATE = "global_create";
                GrantKind.GLOBAL_READER = "global_reader";
                GrantKind.GLOBAL_WRITER = "global_writer";
            })(GrantKind = documents.GrantKind || (documents.GrantKind = {}));
            /**
             * String constants that represent the global grant IDs of a {@link Document}.
             * @private
             */
            var GrantID;
            (function (GrantID) {
                /** The identifier for a grant that identifies any user. */
                GrantID.PUBLIC = "public";
                /** The identifier for a grant that identifies any authenticated user. */
                GrantID.USER = "user";
            })(GrantID = documents.GrantID || (documents.GrantID = {}));
            /**
             * String constants that represent the moniker kinds of a {@link Document}.
             * @private
             */
            var MonikerKind;
            (function (MonikerKind) {
                MonikerKind.LINK = "link";
                MonikerKind.ROLE = "role";
                MonikerKind.USER = "user";
                MonikerKind.POLICY = "policy";
            })(MonikerKind = documents.MonikerKind || (documents.MonikerKind = {}));
            /**
             * String constants that represent the filter methods for a {@link Document}.
             * @private
             */
            var FilterMethod;
            (function (FilterMethod) {
                FilterMethod.RANGES = "ranges";
                FilterMethod.SPATIAL_DISJOINT = "spatialDisjoint";
                FilterMethod.SPATIAL_INTERSECTS = "spatialIntersects";
                FilterMethod.SPATIAL_WITHIN = "spatialWithin";
                FilterMethod.MATCHES = "matches";
                FilterMethod.VALUES = "values";
            })(FilterMethod = documents.FilterMethod || (documents.FilterMethod = {}));
            /**
             * String constants that represent the filter types for a {@link Document}.
             * @private
             */
            var FilterType;
            (function (FilterType) {
                FilterType.REQUIRE = "require";
                FilterType.EXCLUDE = "exclude";
                FilterType.INCLUDE = "include";
            })(FilterType = documents.FilterType || (documents.FilterType = {}));
        })(documents = essentials.documents || (essentials.documents = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../../_Definitions/Documents.Rest.d.ts" />
/** @private */
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var documents;
        (function (documents) {
            var DOCUMENT_STORE_PATH = "/../../documents";
            var REQUIRED_ESSENTIALS_VERSION = 4.05;
            var SELF_PATH = "/self";
            var SORT_EXACT_VALUE = "{0}_exact";
            documents.LINK_QUERY_STRING_KEY = "link";
            /**
             * Interface to the Geocortex Essentials Document Store. Allows full create, read,
             * update, delete operations on documents that persist between sessions.
             * Not supported on versions of Essentials before 4.5. Check the ```supported```
             * member after the Site is initialized.
             * @private
             */
            var DocumentStore = (function () {
                function DocumentStore() {
                    this._initializeDeferred = new dojo.Deferred();
                    /**
                     * Indicates whether the Document Store is supported on this version of Essentials.
                     * This can only be true once the Document Store is initialized.
                     */
                    this.supported = false;
                    /**
                     * Whether or not the document store is successfully initialized.
                     */
                    this.isInitialized = false;
                    /**
                     * The monikers returned by the document store self endpoint.
                     * This will be available once the Document Store is initialized.
                     */
                    this.self = [];
                    /**
                     * The monikers that represent the current user.
                     * This will be available once the Document Store is initialized.
                     */
                    this.userMonikers = [];
                    /**
                     * The monikers that represent the document store policy.
                     * This will only be available once the Document Store is initialized.
                     */
                    this.policyMonikers = [];
                    /**
                     * A filter for searching documents owned by the current user.
                     */
                    this.userFilter = {};
                }
                /**
                 * Initialize the Document Store.
                 * @param site the Site to initialize with.
                 */
                DocumentStore.prototype.initialize = function (site) {
                    this._site = site;
                    var originalUrlWithoutFinalSlash = /^(.*?)(\/*)$/.exec(site.originalUrl)[1];
                    this._rootUrl = essentials.utilities.UrlUtilities.simplify(originalUrlWithoutFinalSlash + DOCUMENT_STORE_PATH);
                    this.supported = site.getEssentialsVersion() >= REQUIRED_ESSENTIALS_VERSION;
                    return this.onInitializeAttempt();
                };
                /**
                 * A thenable for when the document store is initialized.  This will resolve when/if the document
                 * store initializes or rejects if the document store can not be supported.  While being offline
                 * prevents the document store from initializing this will remain pending.
                 */
                DocumentStore.prototype.onInitialized = function () {
                    return this._initializeDeferred.promise;
                };
                /**
                 * A thenable for a document store initialization attempt.  This is different from onInitialized()
                 * in that it will reject for a single attempt failure.  This call *may* itself trigger an attempt.
                 */
                DocumentStore.prototype.onInitializeAttempt = function () {
                    var _this = this;
                    if (this._initializeAttemptThenable) {
                        // Attempt in progress or permanently settled.
                        return this._initializeAttemptThenable;
                    }
                    if (!this.supported) {
                        var error = new Error("The Document Store is not supported in the current version of Essentials.");
                        this._initializeDeferred.reject(error);
                        return this._initializeAttemptThenable = new dojo.Deferred().reject(error);
                    }
                    // If the document store is supported, hit the self endpoint so we get the current user.
                    return this._initializeAttemptThenable = geocortex.request({
                        url: this._rootUrl + SELF_PATH,
                        content: {
                            // When both a proxy and preventCache are used the preventCache parameter is incorrectly added like:
                            // "proxy.ashx?http://localhost:46666/documents/self&dojo.preventCache=1454440253153". Adding a garbage
                            // parameter to the request fixes this. f=json has no effect on the request, but it appears normal.
                            f: "json"
                        },
                        handleAs: "json"
                    }, {
                        usePost: false
                    })
                        .then(DocumentStore._processError)
                        .then(function (result) {
                        _this._processSelf(result);
                        // Do this last in case there's an error in _processSelf.
                        _this.isInitialized = true;
                        _this._initializeDeferred.resolve();
                    })
                        .then(null, function (error) {
                        // This is after _processSelf in case there's an error there.
                        // Forget the attempt so we can try again later.
                        _this._initializeAttemptThenable = null;
                        // Pass the error along to anyone listening.
                        throw error;
                    });
                };
                /**
                 * Get the root url.
                 */
                DocumentStore.prototype.getRootUrl = function () {
                    this._verifySupported();
                    return this._rootUrl + "/";
                };
                /**
                 * Whether or not the current user can create content.
                 */
                DocumentStore.prototype.canCreate = function () {
                    return this.userMonikers.length > 0;
                };
                /**
                 * Whether or not the document store has a policy matching the predicate.
                 * @param predicate The predicate to match against some policy grant.
                 * @return Whether or not the policy grant exists.
                 */
                DocumentStore.prototype.hasPolicyGrant = function (predicate) {
                    return this.policyMonikers.some(function (moniker) { return moniker.grants.some(predicate); });
                };
                /**
                 * Add a Document to the Document Store.
                 * @param doc The Document to add.
                 * @return A Thenable of the Document that was added to the store, after it was processed.
                 */
                DocumentStore.prototype.add = function (doc) {
                    var _this = this;
                    var documentContent = {
                        document: dojo.mixin({}, doc)
                    };
                    // The writeDocument endpoint accepts document content as either a text 
                    // or json property of the request. Remove it from the document object so 
                    // it's not sent twice.
                    if (doc.content !== undefined) {
                        documentContent.json = doc.content;
                        delete documentContent.document.content;
                    }
                    var writeDocumentRequest = documents.BatchRequestBuilder.writeDocument(documentContent);
                    return this.perform(writeDocumentRequest, true)
                        .then(function (result) { return result.document; })
                        .then(function (doc) { return _this._processDocument(doc); });
                };
                /**
                 * Add a Document to the Document Store from the given form data.
                 * @param formData The form data specifying the Document fields.
                 * @return A Thenable of the Document that was added to the store, after it was processed.
                 */
                DocumentStore.prototype.addFromFormData = function (formData) {
                    //this._verifyInitialized();
                    throw new Error("Not implemented.");
                };
                /**
                 * Add a Document to the Document Store from the given form.
                 * @param formData The form specifying the Document fields.
                 * @return A Thenable of the Document that was added to the store, after it was processed.
                 */
                DocumentStore.prototype.addFromForm = function (form) {
                    //this._verifyInitialized();
                    throw new Error("Not implemented.");
                };
                /**
                 * Get the Document from the Document Store with the given ID.
                 * @param id The ID of the Document to get.
                 * @param includeContent Whether or not to retrieve the document content.
                 * @param format The format of the document content.
                 * @return A Thenable of the Document with the given ID.
                 */
                DocumentStore.prototype.getById = function (id, includeContent, format) {
                    var _this = this;
                    if (includeContent === void 0) { includeContent = false; }
                    if (format === void 0) { format = documents.DocumentFormat.JSON; }
                    this._verifyDocId(id);
                    // If the content is required, use the readDocument endpoint
                    // which returns the document metadata and content
                    if (includeContent) {
                        var readDocumentRequest = documents.BatchRequestBuilder.readDocument(id, format);
                        return this.perform(readDocumentRequest)
                            .then(function (result) { return DocumentStore._processReadDocumentResponse(result, format); })
                            .then(function (doc) { return _this._processDocument(doc); });
                    }
                    // Fallback to the peekDocument endpoint which returns only metadata
                    var peekDocumentRequest = documents.BatchRequestBuilder.peekDocument(id);
                    return this.perform(peekDocumentRequest)
                        .then(function (result) { return result.document; })
                        .then(function (doc) { return _this._processDocument(doc); });
                };
                /**
                 * Get the URL raw content can be found at for the Document, or for the given Document ID
                 * assuming that document exists. If the mime-type of the Document is an image
                 * this can be used as the ```src``` of an ```img``` tag.
                 * @param id The ID of the Document.
                 * @return A URL.
                 */
                DocumentStore.prototype.getContentUrl = function (docOrId) {
                    throw new Error("Not implemented.");
                };
                /**
                 * Update the Document in the Document Store with the given ID to have
                 * the given values. Only values present in the values object are updated.
                 * @param id The ID of the Document to update.
                 * @param values The values to update.
                 * @return A Thenable of the Document with its updated values.
                 */
                DocumentStore.prototype.updateById = function (id, values) {
                    var _this = this;
                    this._verifyDocId(id);
                    // When updating, if we don't specify the timeOfLastModification property,
                    // the server will not update the modification time
                    if (!values.timeOfLastModification) {
                        values.timeOfLastModification = null;
                    }
                    // GVH-9384 When updating, we need to clear the editor, because the server only
                    // tracks modifications to the content. By clearling the editor on all updates,
                    // the editor will represent the last person to change either the metadata or content
                    if (!values.editor) {
                        values.editor = null;
                    }
                    var updates = [];
                    for (var prop in values) {
                        if (values.hasOwnProperty(prop)) {
                            updates.push(prop);
                        }
                    }
                    if (values.content !== undefined) {
                        var documentContent = {
                            json: values.content
                        };
                        delete values.content;
                        documentContent.document = dojo.mixin({ id: id, updates: updates }, values);
                        var writeDocumentRequest = documents.BatchRequestBuilder.writeDocument(documentContent);
                        return this.perform(writeDocumentRequest, true)
                            .then(function (result) { return result.document; })
                            .then(function (doc) { return _this._processDocument(doc); });
                    }
                    else {
                        var document_1 = dojo.mixin({ id: id, updates: updates }, values);
                        var updateDocumentRequest = documents.BatchRequestBuilder.updateDocument(document_1);
                        return this.perform(updateDocumentRequest, true)
                            .then(function (result) { return result.document; })
                            .then(function (doc) { return _this._processDocument(doc); });
                    }
                };
                /**
                 * Delete the Document from the Document Store with the given ID.
                 * @param id The ID of the Document to delete.
                 * @return A Thenable of the Document that was deleted.
                 */
                DocumentStore.prototype.deleteById = function (id) {
                    var _this = this;
                    this._verifyDocId(id);
                    var deleteDocumentRequest = documents.BatchRequestBuilder.deleteDocument(id);
                    return this.perform(deleteDocumentRequest, true)
                        .then(function (result) { return result.document; })
                        .then(function (doc) { return _this._processDocument(doc); });
                };
                /**
                 * Search the Document Store and get all matching Documents. Only Documents
                 * the user has permission to access will be returned.
                 * @param queryParams The parameters of the search.
                 * @return A Thenable of the search result containing the documents.
                 */
                DocumentStore.prototype.query = function (queryParams) {
                    var _this = this;
                    var query = dojo.mixin({}, queryParams);
                    // Sorting on 'matches' type fields can give strange results unless we append '_exact' to the field name
                    if (query.sort) {
                        query.sort.forEach(function (sortValue, index, array) {
                            if (DocumentStore.matchesFilterFields.some(function (matchesField) { return matchesField === sortValue; })) {
                                array[index] = SORT_EXACT_VALUE.format(sortValue);
                            }
                        });
                    }
                    if (query.sortDescending) {
                        query.sortDescending.forEach(function (sortValue, index, array) {
                            if (DocumentStore.matchesFilterFields.some(function (matchesField) { return matchesField === sortValue; })) {
                                array[index] = SORT_EXACT_VALUE.format(sortValue);
                            }
                        });
                    }
                    var searchDocumentsRequest = documents.BatchRequestBuilder.searchDocuments(query);
                    return this.perform(searchDocumentsRequest)
                        .then(function (result) {
                        if (Array.isArray(result.matchingDocuments.results)) {
                            result.matchingDocuments.results.forEach(function (x) { return _this._processDocument(x.entity); });
                        }
                        return result.matchingDocuments;
                    });
                };
                /**
                 * Perform a request to the document store.
                 * @param request The request to perform.
                 * @param usePost Whether or not to use POST for the request.
                 * @return A Thenable of the batch request response.
                 */
                DocumentStore.prototype.perform = function (request, usePost) {
                    var _this = this;
                    if (usePost === void 0) { usePost = false; }
                    if (!request.action) {
                        throw new Error("The Document Store batch request does not contain an action");
                    }
                    var action = request.action;
                    if (action !== "perform") {
                        delete request.action;
                    }
                    if (this._guestLink) {
                        request.link = this._guestLink;
                    }
                    // GVH-9722: This ensures that error responses will be returned in the proper format.
                    request["f"] = "json";
                    return this.onInitializeAttempt()
                        .then(function () { return _this._verifySupported(); })
                        .then(function () { return geocortex.request({
                        url: _this._rootUrl + "/" + action,
                        content: geocortex.encodeJson(request),
                        handleAs: "json"
                    }, {
                        usePost: usePost
                    }); })
                        .then(DocumentStore._processError);
                };
                /**
                 * Tries to verify whether or not the document is owned by the current user. If the document
                 * does not contain sufficient meta data, this will return true.
                 * @param doc The document to check ownership of.
                 * @return Whether or not the current user owns the document.
                 */
                DocumentStore.prototype.isOwner = function (doc) {
                    if (!doc || !doc.access) {
                        return true;
                    }
                    // If the user has change access, they own that document as they can change the meta data
                    return doc.access.change;
                };
                /**
                 * Verifies whether or not the document is read only for the current user. If the document
                 * does not contain the access property, this returns false.
                 * @param doc The document to check read only status for.
                 * @return Whether or not the document is read only for the current user.
                 */
                DocumentStore.prototype.isReadOnly = function (doc) {
                    if (!doc || !doc.access) {
                        return false;
                    }
                    return !!doc.access.view && !doc.access.edit && !doc.access.change;
                };
                /**
                 * Tries to verify whether or not the document has been updated to be shared publicly. If the
                 * document does not contain sufficient meta data, this will return false.
                 * @param doc The document to check whether it has been shared publicly.
                 * @return Whether or not the document has been shared publicly.
                 */
                DocumentStore.prototype.isPublic = function (doc) {
                    if (!doc || !doc.id || !doc.grants) {
                        return false;
                    }
                    return doc.grants
                        .some(function (grant) { return grant.globalId === documents.GrantID.PUBLIC && (grant.revoke === false || grant.assert === true); });
                };
                /**
                 * Sets the guest link used on requests to the document store.
                 * @param guestLink The guest link.
                 */
                DocumentStore.prototype.setGuestLink = function (guestLink) {
                    this._guestLink = guestLink;
                };
                /**
                 * Process the ajax result and throw the Error if it is an error.
                 * @param result
                 * @return {}
                 */
                DocumentStore._processError = function (result) {
                    if (result.error) {
                        throw result.error;
                    }
                    return result;
                };
                /**
                 * Process the Core Document so that dates are Date objects (and
                 * anything else to keep the Document consistent).
                 * @param doc The Core Document to process.
                 * @return The same Document.
                 */
                DocumentStore.prototype._processDocument = function (doc) {
                    // The server will return any time related properties as a number. Convert them to date format
                    if (doc.timeOfCreation) {
                        doc.timeOfCreation = new Date(doc.timeOfCreation);
                    }
                    if (doc.timeOfLastAccess) {
                        doc.timeOfLastAccess = new Date(doc.timeOfLastAccess);
                    }
                    if (doc.timeOfLastModification) {
                        doc.timeOfLastModification = new Date(doc.timeOfLastModification);
                    }
                    if (doc.timeOfDeletion) {
                        doc.timeOfDeletion = new Date(doc.timeOfDeletion);
                    }
                    if (doc.timeOfExpiration) {
                        doc.timeOfExpiration = new Date(doc.timeOfExpiration);
                    }
                    if (doc.access && !doc.access.monikerIds) {
                        // monikerIds is not set by the server in GE 4.5.  see: GE-7849
                        // When GE 4.5 support is dropped this shim can be removed.
                        doc.access.monikerIds = this.userMonikers.map(function (m) { return m.id; });
                    }
                    return doc;
                };
                /**
                 * Process the Read Document Result so we can extract and attach the document content.
                 * @param result The Read Document Result to process.
                 * @param format The format that the content is in.
                 * @return The resulting Document.
                 */
                DocumentStore._processReadDocumentResponse = function (result, format) {
                    var document = result.content.document;
                    document.content = result.content[format];
                    return document;
                };
                /**
                 * Process the Self Result on initialization, so we can setup the policy and user if avilable.
                 * @param result The Self Result to process.
                 */
                DocumentStore.prototype._processSelf = function (result) {
                    this.self = result.monikers;
                    this.userMonikers = result.monikers.filter(function (x) { return x.kind === documents.MonikerKind.USER; });
                    this.policyMonikers = result.monikers.filter(function (x) { return x.kind === documents.MonikerKind.POLICY; });
                    // If we have any user monikers, update the user filter
                    if (this.userMonikers.length > 0) {
                        var userFilterRange = this.userMonikers.map(function (moniker) {
                            return {
                                "string": "{0}|{1}".format(documents.GrantKind.OWNER, moniker.globalId)
                            };
                        });
                        this.userFilter = {
                            field: documents.DocumentField.GRANT_TOKEN,
                            method: documents.FilterMethod.VALUES,
                            range: userFilterRange
                        };
                    }
                };
                /**
                 * Verify that the Document ID is valid, throwing an exception if it isn't.
                 * @param id The Document ID.
                 */
                DocumentStore.prototype._verifyDocId = function (id) {
                    if (!id) {
                        throw new Error("The Document ID must be set.");
                    }
                    if (/[/?#\s]/.test(id)) {
                        throw new Error("The Document ID '{0}' contains illegal characters.".format(id));
                    }
                };
                /**
                 * Verify that the Document Store is supported, throwing an exception if it isn't.
                 */
                DocumentStore.prototype._verifySupported = function () {
                    if (!this.supported) {
                        throw new Error("The Document Store is not supported in the current version of Essentials.");
                    }
                };
                /**
                 * These fields can be filtered using the 'matches' filter type as they are full text fields
                 */
                DocumentStore.matchesFilterFields = [
                    documents.DocumentField.TITLE,
                    documents.DocumentField.DESCRIPTION,
                    documents.DocumentField.ISSUER_TITLE,
                    documents.DocumentField.AUTHOR_TITLE,
                    documents.DocumentField.AUTHOR_DESCRIPTION,
                    documents.DocumentField.AUTHOR_ISSUER_TITLE,
                    documents.DocumentField.EDITOR_TITLE,
                    documents.DocumentField.EDITOR_DESCRIPTION,
                    documents.DocumentField.EDITOR_ISSUER_TITLE
                ];
                return DocumentStore;
            }());
            documents.DocumentStore = DocumentStore;
        })(documents = essentials.documents || (essentials.documents = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../../_Definitions/Documents.Rest.d.ts" />
/**
 * Builds batch requests for the document store REST endpoints.
 * @private
 */
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var documents;
        (function (documents) {
            var BatchRequestBuilder;
            (function (BatchRequestBuilder) {
                function cloneDocument(id, document, createOnly) {
                    return { action: "cloneDocument", id: id, document: document, createOnly: createOnly };
                }
                BatchRequestBuilder.cloneDocument = cloneDocument;
                function createDocument(document, streamId) {
                    return { action: "createDocument", document: document, streamId: streamId };
                }
                BatchRequestBuilder.createDocument = createDocument;
                function createMoniker(moniker, createOnly) {
                    return { action: "createMoniker", moniker: moniker, createOnly: createOnly };
                }
                BatchRequestBuilder.createMoniker = createMoniker;
                function deleteDocument(id) {
                    return { action: "deleteDocument", id: id };
                }
                BatchRequestBuilder.deleteDocument = deleteDocument;
                function deleteMoniker(id) {
                    return { action: "deleteMoniker", id: id };
                }
                BatchRequestBuilder.deleteMoniker = deleteMoniker;
                function describe(streamId) {
                    return { action: "describe", streamId: streamId };
                }
                BatchRequestBuilder.describe = describe;
                function generateLinks(count) {
                    return { action: "generateLinks", count: count };
                }
                BatchRequestBuilder.generateLinks = generateLinks;
                function modifyDocument(document, streamId) {
                    return { action: "modifyDocument", document: document, streamId: streamId };
                }
                BatchRequestBuilder.modifyDocument = modifyDocument;
                function openDocument(id, streamId, startPosition) {
                    return { action: "openDocument", id: id, streamId: streamId, startPosition: startPosition };
                }
                BatchRequestBuilder.openDocument = openDocument;
                function peekDocument(id, throwIfMissing) {
                    if (throwIfMissing === void 0) { throwIfMissing = false; }
                    return { action: "peekDocument", id: id, throwIfMissing: throwIfMissing };
                }
                BatchRequestBuilder.peekDocument = peekDocument;
                function peekDocumentAccess(id) {
                    return { action: "peekDocumentAccess", id: id };
                }
                BatchRequestBuilder.peekDocumentAccess = peekDocumentAccess;
                function peekMoniker(id, throwIfMissing) {
                    return { action: "peekMoniker", id: id, throwIfMissing: throwIfMissing };
                }
                BatchRequestBuilder.peekMoniker = peekMoniker;
                function peekMonikerAccess(id) {
                    return { action: "peekMonikerAccess", id: id };
                }
                BatchRequestBuilder.peekMonikerAccess = peekMonikerAccess;
                function previewDocument(id, streamId) {
                    return { action: "previewDocument", id: id, streamId: streamId };
                }
                BatchRequestBuilder.previewDocument = previewDocument;
                function previewMoniker(id, streamId) {
                    return { action: "previewMoniker", id: id, streamId: streamId };
                }
                BatchRequestBuilder.previewMoniker = previewMoniker;
                function readDocument(id, format) {
                    return { action: "readDocument", id: id, format: format };
                }
                BatchRequestBuilder.readDocument = readDocument;
                function restoreDocument(globalId) {
                    return { action: "restoreDocument", globalId: globalId };
                }
                BatchRequestBuilder.restoreDocument = restoreDocument;
                function restoreMoniker(globalId) {
                    return { action: "restoreMoniker", globalId: globalId };
                }
                BatchRequestBuilder.restoreMoniker = restoreMoniker;
                function resumeDocument(globalId, streamId) {
                    return { action: "resumeDocument", globalId: globalId, streamId: streamId };
                }
                BatchRequestBuilder.resumeDocument = resumeDocument;
                function scrub(scrubOptions) {
                    return { action: "scrub", scrubOptions: scrubOptions };
                }
                BatchRequestBuilder.scrub = scrub;
                function searchDocuments(documentQuery) {
                    return { action: "searchDocuments", documentQuery: documentQuery };
                }
                BatchRequestBuilder.searchDocuments = searchDocuments;
                function searchMonikers(monikerQuery) {
                    return { action: "searchMonikers", monikerQuery: monikerQuery };
                }
                BatchRequestBuilder.searchMonikers = searchMonikers;
                function searchRoles(searchClause) {
                    return { action: "searchRoles", searchClause: searchClause };
                }
                BatchRequestBuilder.searchRoles = searchRoles;
                function searchUsers(searchClause) {
                    return { action: "searchUsers", searchClause: searchClause };
                }
                BatchRequestBuilder.searchUsers = searchUsers;
                function self() {
                    return { action: "self" };
                }
                BatchRequestBuilder.self = self;
                function touchDocument(id, modify, throwIfMissing) {
                    return { action: "touchDocument", id: id, modify: modify, throwIfMissing: throwIfMissing };
                }
                BatchRequestBuilder.touchDocument = touchDocument;
                function updateDocument(document) {
                    return { action: "updateDocument", document: document };
                }
                BatchRequestBuilder.updateDocument = updateDocument;
                function updateMoniker(moniker) {
                    return { action: "updateMoniker", moniker: moniker };
                }
                BatchRequestBuilder.updateMoniker = updateMoniker;
                function writeDocument(content) {
                    return { action: "writeDocument", content: content };
                }
                BatchRequestBuilder.writeDocument = writeDocument;
            })(BatchRequestBuilder = documents.BatchRequestBuilder || (documents.BatchRequestBuilder = {}));
        })(documents = essentials.documents || (essentials.documents = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * An object that represents the options for exporting the map image.
         */
        var ExportMapImageOptions = (function () {
            /**
             * Initializes a new instance of the {@link ExportMapImageOptions} class.
             * @param defaultOutputFormat The default output format of the generated map image.
             * @param allowIncludeGeoreferenceData Indicates whether including georeference data in the export is allowed.
             */
            function ExportMapImageOptions(allowIncludeGeoreferenceData, defaultOutputFormat) {
                if (defaultOutputFormat === void 0) { defaultOutputFormat = "Png"; }
                this.defaultOutputFormat = defaultOutputFormat;
                this.allowIncludeGeoreferenceData = allowIncludeGeoreferenceData;
            }
            return ExportMapImageOptions;
        }());
        essentials.ExportMapImageOptions = ExportMapImageOptions;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/**
* Environment Type for Bing services.
* @private
*/
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var exportMap;
        (function (exportMap) {
            var BingEnvironment;
            (function (BingEnvironment) {
                /** Represents the production environment. */
                BingEnvironment.PRODUCTION = "Production";
            })(BingEnvironment = exportMap.BingEnvironment || (exportMap.BingEnvironment = {}));
        })(exportMap = essentials.exportMap || (essentials.exportMap = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         *  Represents a 'style' that can be applied to a resymbolizable layer.
         *  Contains a renderer represented as a JSON string, a display name and id,
         *  and a flag to determine whether the style is currently being applied or not.
         *  Calling the 'getRenderer' function will convert the string to a renderer ready to apply to the layer.
         */
        var LayerStyle = (function () {
            function LayerStyle(rendererJson, displayName, id, enabled) {
                if (enabled === void 0) { enabled = false; }
                this.rendererJson = rendererJson;
                this.displayName = displayName;
                this.id = id;
                this.enabled = enabled;
            }
            // In the future this could be expanded to handle other types of renderers, say for WMS layers
            LayerStyle.prototype.getRenderer = function () {
                var renderer = esri.renderer.fromJson(JSON.parse(this.rendererJson));
                if (!(renderer instanceof esri.renderer.Renderer)) {
                    console.error("Layer Style: '{0}'. Could not create a valid renderer from the stored JSON string: '{1}'".format(this.displayName, this.rendererJson));
                }
                return renderer;
            };
            // Use this to set the renderer for the layer style. Can use a JSON string or a renderer object.
            LayerStyle.prototype.setRenderer = function (renderer) {
                if (renderer instanceof esri.renderer.Renderer) {
                    this.rendererJson = JSON.stringify(renderer.toJson());
                }
                else {
                    if (esri.renderer.fromJson(JSON.parse(renderer)) instanceof esri.renderer.Renderer) {
                        this.rendererJson = renderer;
                    }
                    else {
                        console.error("Layer Style: '{0}'. Supplied JSON string could not be used to create a valid renderer: '{1}'".format(this.displayName, renderer));
                    }
                }
            };
            // Returns true if this is a simple renderer, false if otherwise
            LayerStyle.prototype.isSimple = function () {
                var jsonRenderer = JSON.parse(this.rendererJson);
                if (jsonRenderer.type === "simple") {
                    return true;
                }
                return false;
            };
            return LayerStyle;
        }());
        essentials.LayerStyle = LayerStyle;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents a Layer Catalog defined in a {@link Site}.
         */
        var LayerCatalog = (function () {
            /**
             * Initializes a new instance of the {@link LayerCatalog} class.
             * @param siteId The site id of the {@link LayerCatalog}.
             */
            function LayerCatalog(siteId) {
                this.siteId = siteId;
            }
            return LayerCatalog;
        }());
        essentials.LayerCatalog = LayerCatalog;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="Site.ts" />
/// <reference path="AsyncInitializable.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents a Search Table defined by a {@link Site}.
         */
        var SearchTable = (function (_super) {
            __extends(SearchTable, _super);
            /**
             * Initializes a new instance of the {@link SearchTable} class.
             * @param url The URL to the REST endpoint of the {@link SearchTable}.
             */
            function SearchTable(url) {
                _super.call(this, url);
                /** The display name of the {@link SearchTable}. */
                this.displayName = null;
                /** The parameters of the {@link SearchTable}, as defined by an administrator. */
                this.parameters = [];
                /** The ID of the {@link SearchTable}.*/
                this.id = null;
                /** The {@link Site} that the {@link SearchTable} belongs to. */
                this.site = null;
                /** The format for a description of a feature. */
                this.featureDescription = null;
                /** The format for a label of a feature. */
                this.featureLabel = null;
                /** The format for a long description of a feature. */
                this.featureLongDescription = null;
                /** URI to an icon representing this search table. */
                this.iconUri = null;
                /** Indicates if the search table should participate in Global Search. */
                this.includeInGlobalSearch = false;
                /** @private */
                this._searching = false;
                /** @private */
                this._onSearchingComplete = null;
                /** @private */
                this._onSearchingError = null;
            }
            /** @private */
            SearchTable.prototype._configureObject = function (obj, deepInitialize) {
                if (obj === undefined || obj.id === undefined || obj.displayName == undefined) {
                    throw new Error("Incorrect search table object returned from initialization");
                }
                // Assign all the data
                this.id = obj.id;
                this.displayName = obj.displayName;
                this.parameters = obj.parameters;
                this.featureDescription = obj.featureDescription;
                this.featureLabel = obj.featureLabel;
                this.featureLongDescription = obj.featureLongDescription;
                this.iconUri = geocortex.essentials.RestHelper.processClientSideTokens(this.site, obj.iconUri);
                this.includeInGlobalSearch = obj.includeInGlobalSearch;
            };
            /**
             * Gets whether the {@link geocortex.essentials.SearchTable} is currently performing a search.
             * @return {boolean} True if searchTable is currently being performed, false otherwise.
             */
            SearchTable.prototype.isSearching = function () {
                return this._searching;
            };
            /**
             * The task exercises the SearchTables/Search operation seen on site for the Essentials 3.8 or greater.
             * @param searchParameters Contains an object in which key/value represent the parameters for the search.
             * @param searchComplete The delegate that will be called when the operation has completed, even if an error occurs. This delegate expects one argument: an Object containing the result.
             * @param searchError The delegate that will be called if an error occurs during the operation. This delegate expects two arguments: a reference to the SearchTable instance, and an Error.
             */
            SearchTable.prototype.performSearch = function (searchParameters, searchComplete, searchError) {
                var _this = this;
                var executeErrorCallback = function (msg) {
                    _this._searching = false;
                    if (searchError) {
                        searchError(new Error(msg));
                    }
                    return;
                };
                if (!searchParameters) {
                    executeErrorCallback("No searchParameters provided");
                }
                // Check if we're already doing data linking
                if (this.isSearching()) {
                    executeErrorCallback("Currently performing a search");
                }
                this._searching = true;
                this._onSearchingComplete = dojo.hitch(this, searchComplete);
                this._onSearchingError = dojo.hitch(this, searchError);
                var searchTableUrl = this.url + "/search";
                var params = "";
                for (var key in searchParameters) {
                    if (searchParameters.hasOwnProperty(key)) {
                        params += ((params) ? "&" : "") + key + "=" + searchParameters[key];
                    }
                }
                searchTableUrl += "?" + params;
                geocortex.request({
                    url: searchTableUrl,
                    content: { f: "json" },
                    handleAs: "json",
                    load: dojo.hitch(this, this._searchRestComplete),
                    error: dojo.hitch(this, this._searchRestError),
                    callbackParamName: "CallBack"
                });
            };
            /** @private */
            SearchTable.prototype._searchRestComplete = function (result) {
                this._searching = false;
                if (!result && this._onSearchingError) {
                    this._onSearchingError(new Error("No results"));
                }
                if (result.error && this._onSearchingError) {
                    this._onSearchingError(result.error);
                }
                if (this._onSearchingComplete) {
                    this._onSearchingComplete(new esri.tasks.FeatureSet(result));
                }
            };
            /** @private */
            SearchTable.prototype._searchRestError = function (er) {
                this._searching = false;
                if (this._onSearchingError) {
                    this._onSearchingError(er);
                }
            };
            return SearchTable;
        }(essentials.AsyncInitializable));
        essentials.SearchTable = SearchTable;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents a parameter in a {@link geocortex.essentials.SearchTable}.
         */
        var SearchTableParameter = (function () {
            function SearchTableParameter() {
                /** The name of the {@link geocortex.essentials.SearchTableParameter}. */
                this.name = null;
                /** The type of the {@link geocortex.essentials.SearchTableParameter}. */
                this.type = null;
            }
            return SearchTableParameter;
        }());
        essentials.SearchTableParameter = SearchTableParameter;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents the modes of operation for a {@TimeSliderProfile}
         */
        (function (TimeSliderMode) {
            TimeSliderMode[TimeSliderMode["Extent"] = 0] = "Extent";
            TimeSliderMode[TimeSliderMode["Cumulative"] = 1] = "Cumulative";
            TimeSliderMode[TimeSliderMode["Instant"] = 2] = "Instant";
        })(essentials.TimeSliderMode || (essentials.TimeSliderMode = {}));
        var TimeSliderMode = essentials.TimeSliderMode;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/TimeSlider.Rest.d.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents settings for a time slider profile displayed in the time slider when there are time aware map services in the map.
         */
        var TimeSliderProfile = (function (_super) {
            __extends(TimeSliderProfile, _super);
            /**
             * Initializes a new instance of the {@link TimeSliderProfile} class.
             * @param url The URL to the REST endpoint of the {@link PrintTemplate}.
             */
            function TimeSliderProfile(url) {
                _super.call(this, url);
            }
            TimeSliderProfile.prototype._configureObject = function (results, deepInitialize) {
                this.id = results.id;
                this.displayName = results.displayName;
                this.description = results.description;
                this.mode = essentials.TimeSliderMode[results.mode];
                this.displayFormat = results.displayFormat;
                this.timeExtent = {
                    startTime: essentials.utilities.StringUtilities.getDateFromRestDateString(results.startTime),
                    endTime: essentials.utilities.StringUtilities.getDateFromRestDateString(results.endTime)
                };
                this.initialTimeExtent = {
                    startTime: essentials.utilities.StringUtilities.getDateFromRestDateString(results.initialStartTime),
                    endTime: essentials.utilities.StringUtilities.getDateFromRestDateString(results.initialEndTime)
                };
                this.timeInterval = results.timeInterval;
                this.timeIntervalUnit = essentials.EssentialsTimeUnits[results.timeIntervalUnit];
                this.snapToTimeIntervals = results.snapToTimeIntervals;
                this.properties = geocortex._getProperties(results.properties);
                this.extensions = geocortex._getExtensions(results.extensions);
            };
            return TimeSliderProfile;
        }(essentials.AsyncInitializable));
        essentials.TimeSliderProfile = TimeSliderProfile;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Different time measurement units.
         */
        var TimeUnits = (function () {
            function TimeUnits() {
            }
            /** 	Indicates a value measured in centuries. */
            TimeUnits.UNIT_CENTURIES = "esriTimeUnitsCenturies";
            /** 	Indicates a value measured in days. */
            TimeUnits.UNIT_DAYS = "esriTimeUnitsDays";
            /** 	Indicates a value measured in decades. */
            TimeUnits.UNIT_DECADES = "esriTimeUnitsDecades";
            /** 	Indicates a value measured in hours. */
            TimeUnits.UNIT_HOURS = "esriTimeUnitsHours";
            /** 	Indicates a value measured in milliseconds. */
            TimeUnits.UNIT_MILLISECONDS = "esriTimeUnitsMilliseconds";
            /** 	Indicates a value measured in minutes. */
            TimeUnits.UNIT_MINUTES = "esriTimeUnitsMinutes";
            /** 	Indicates a value measured in months. */
            TimeUnits.UNIT_MONTHS = "esriTimeUnitsMonths";
            /** 	Indicates a value measured in seconds. */
            TimeUnits.UNIT_SECONDS = "esriTimeUnitsSeconds";
            /** 	Indicates a value measured in weeks. */
            TimeUnits.UNIT_WEEKS = "esriTimeUnitsWeeks";
            /** 	Indicates a value measured in years. */
            TimeUnits.UNIT_YEARS = "esriTimeUnitsYears";
            /** 	Indicates a value measured in unknown units. */
            TimeUnits.UNIT_UNKNOWN = "esriTimeUnitsUnknown";
            return TimeUnits;
        }());
        essentials.TimeUnits = TimeUnits;
        /**
         * Essentials Time Unit constant to TimeUnit constant mapping.
         */
        var EssentialsTimeUnits = (function () {
            function EssentialsTimeUnits() {
            }
            EssentialsTimeUnits.Century = TimeUnits.UNIT_CENTURIES;
            EssentialsTimeUnits.Day = TimeUnits.UNIT_DAYS;
            EssentialsTimeUnits.Decade = TimeUnits.UNIT_DECADES;
            EssentialsTimeUnits.Hour = TimeUnits.UNIT_HOURS;
            EssentialsTimeUnits.MilliSecond = TimeUnits.UNIT_MILLISECONDS;
            EssentialsTimeUnits.Minute = TimeUnits.UNIT_MINUTES;
            EssentialsTimeUnits.Month = TimeUnits.UNIT_MONTHS;
            EssentialsTimeUnits.Second = TimeUnits.UNIT_SECONDS;
            EssentialsTimeUnits.Week = TimeUnits.UNIT_WEEKS;
            EssentialsTimeUnits.Year = TimeUnits.UNIT_YEARS;
            return EssentialsTimeUnits;
        }());
        essentials.EssentialsTimeUnits = EssentialsTimeUnits;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../../_Definitions/ServiceDiscovery.Rest.d.ts" />
/// <reference path="../../../../../_Definitions/ServiceDiscovery.Rest.d.ts" />
/// <reference path="../FeatureLayerService.ts" />
/// <reference path="../MapService.ts" />
/// <reference path="ResultItem.ts" />
/// <reference path="ServiceDiscoveryProvider.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var serviceDiscovery;
        (function (serviceDiscovery) {
            var SERVICE_DISCOVERY_PATH = "/../../../connections";
            var REQUIRED_ESSENTIALS_VERSION = 4.05;
            /**
             * Interface to the Geocortex Essentials Service Discovery. Allows searching for matching services against the Service Discovery REST endpoints.
             *  - Not supported on versions of Essentials prior to 4.5. Check the `supported` member after the class is initialized.
             *  - Requires an initialized Site to work.
             *  - Sets `rootUrl` to "{SITE_URL}/../../../connections".
             */
            var SiteServiceDiscoveryProvider = (function () {
                function SiteServiceDiscoveryProvider() {
                    this.initialized = false;
                    this.supported = false;
                }
                /**
                 * TODO Document
                 * @param site
                 */
                SiteServiceDiscoveryProvider.prototype.initialize = function (site) {
                    this._site = site;
                    this._rootUrl = essentials.utilities.UrlUtilities.resolveUrl(site.url, SERVICE_DISCOVERY_PATH, true);
                    // Signal that initialization has completed
                    this.supported = site.getEssentialsVersion() >= REQUIRED_ESSENTIALS_VERSION;
                    this.initialized = true;
                };
                /**
                 * TODO Document
                 */
                SiteServiceDiscoveryProvider.prototype.getRootUrl = function () {
                    return this._rootUrl;
                };
                /**
                 * TODO Document
                 * @param term
                 */
                SiteServiceDiscoveryProvider.prototype.suggestHints = function (term) {
                    var request = {
                        f: "json",
                        term: term
                    };
                    return this.sendRequest("suggest", request)
                        .then(function (response) { return response.hints; });
                };
                /**
                 * TODO Document
                 * @param term
                 * @param options
                 */
                SiteServiceDiscoveryProvider.prototype.findServices = function (term, options) {
                    var _this = this;
                    var request = {
                        f: "json",
                        term: term,
                        whitelistOnly: true
                    };
                    if (options) {
                        request = dojo.mixin(request, options);
                    }
                    return this.sendRequest("find", request)
                        .then(function (response) {
                        if (Array.isArray(response.results)) {
                            response.results.forEach(function (x) { return _this._processItem(x); });
                        }
                        return response.results;
                    });
                };
                /**
                 * TODO Document
                 * @param item
                 */
                SiteServiceDiscoveryProvider.prototype.expandService = function (item) {
                    var _this = this;
                    var connectionId = this._getConnectionId(item);
                    var request = {
                        f: "json",
                        providerName: item.serviceProviderName,
                        url: item.url
                    };
                    return this.sendRequest(connectionId + "/expand", request)
                        .then(function (x) { return _this._processItem(x); });
                };
                /**
                 * TODO Document
                 * @param item
                 * @param sr
                 */
                SiteServiceDiscoveryProvider.prototype.realizeMapService = function (item, sr) {
                    var _this = this;
                    var connectionId = this._getConnectionId(item);
                    var request = {
                        f: "json",
                        providerName: item.serviceProviderName,
                        url: item.url,
                        sr: sr,
                        itemId: item.id || "null"
                    };
                    return this.sendRequest(connectionId + "/realize", request)
                        .then(function (result) { return _this._processMapService(result, item); });
                };
                SiteServiceDiscoveryProvider.prototype.sendRequest = function (url, request) {
                    var _this = this;
                    var ready = geocortex.framework.SimplePromise.resolve(null);
                    return ready.then(function () { return _this._verifyInitialized(); })
                        .then(function () { return _this._verifySupported(); })
                        .then(function () {
                        // This ensures that error responses will be returned in the proper format.
                        request["f"] = request["f"] || "json";
                        return geocortex.request({
                            url: essentials.utilities.UrlUtilities.resolveUrl(_this._rootUrl, url),
                            content: geocortex.encodeJson(request),
                            handleAs: "json"
                        });
                    })
                        .then(this._processError);
                };
                SiteServiceDiscoveryProvider.prototype._getConnectionId = function (item) {
                    var id = item.connection && item.connection.id != null ? item.connection.id : "none";
                    return id;
                };
                /**
                  * Processes the ajax result, throwing an exception if it is an error response.
                  * @param result The ajax response.
                  */
                SiteServiceDiscoveryProvider.prototype._processError = function (result) {
                    if (result && result.error) {
                        throw result.error;
                    }
                    return result;
                };
                SiteServiceDiscoveryProvider.prototype._processItem = function (item) {
                    if (!item.thumbnailUrl) {
                        var connectionId = this._getConnectionId(item);
                        var previewUrl = connectionId + "/preview?f=json&providerName=" + item.serviceProviderName + "&url=" + item.url;
                        item.thumbnailUrl = essentials.utilities.UrlUtilities.resolveUrl(this._rootUrl, previewUrl);
                    }
                    if (item.children) {
                        for (var _i = 0, _a = item.children; _i < _a.length; _i++) {
                            var child = _a[_i];
                            this._processItem(child);
                        }
                    }
                    return item;
                };
                SiteServiceDiscoveryProvider.prototype._processMapService = function (result, item) {
                    var site = this._site;
                    var essentialsMap = site.essentialsMap;
                    var serviceUrl = item.url;
                    var mapService;
                    if (result.drawingBehavior === geocortex.essentials.DrawingBehavior.FEATURE_LAYER) {
                        if (!dojo.isObject(esri.layers.FeatureLayer)) {
                            throw new Error("This Javascript application must // dojo.require the esri.layers.FeatureLayer package in order to use a site with feature layers");
                        }
                        mapService = new essentials.FeatureLayerService(serviceUrl);
                    }
                    else if (result.drawingBehavior === geocortex.essentials.DrawingBehavior.GEORSS_LAYER) {
                        if (!dojo.isObject(esri.layers.GraphicsLayer)) {
                            throw new Error("This Javascript application must // dojo.require the esri.layers.GraphicsLayer package in order to use a site with GeoRSS layers");
                        }
                        // holding a reference to GeoRssLayerService creates a circular reference, which isn't properly resolved yet
                        // see: https://typescript.codeplex.com/workitem/913
                        mapService = new geocortex.essentials.GeoRssLayerService(serviceUrl);
                    }
                    else if (result.drawingBehavior === geocortex.essentials.DrawingBehavior.KML_SERVICE) {
                        if (!dojo.isObject(esri.layers.KMLLayer)) {
                            throw new Error("This Javascript application must // dojo.require the esri.layers.KMLLayer package in order to use a site with KML layers");
                        }
                        // holding a reference to KmlService creates a circular reference, which isn't properly resolved yet
                        // see: https://typescript.codeplex.com/workitem/913
                        mapService = new geocortex.essentials.KmlService(serviceUrl);
                    }
                    else {
                        mapService = new essentials.MapService(serviceUrl);
                    }
                    // Configuring the Geocortex map service
                    mapService.essentialsMap = essentialsMap;
                    mapService.initialize(result);
                    // Configuring the Geocortex layers.
                    for (var _i = 0, _a = mapService.layers; _i < _a.length; _i++) {
                        var gcxLayer = _a[_i];
                        gcxLayer.isUserCreated = true;
                        gcxLayer.includeInLayerList = true;
                        gcxLayer.includeInLegend = true;
                        gcxLayer.site = site;
                        gcxLayer.configuredVisible = true;
                        // GVH-11209 Can't Add ArcGIS Server Tiled Map Services With More Than One Layer
                        // Setting individual layer visibility for tiled services causes errors if service has more than 1 layer
                        // There's no point in setting layer visibility when not supported
                        if (mapService.supportsLayerVisibility()) {
                            gcxLayer.setVisibility(true);
                        }
                        else {
                            // Remember: we dont want to actually setVisibility on the layer (fires visibility events) - we simply ensure that the isVisible() function returns the correct result.
                            gcxLayer._visible = true;
                        }
                        // GVH-11183 Skip group layers. They do not support identify or search.
                        var isGroupLayer = gcxLayer.subLayerIds && gcxLayer.subLayerIds.length > 0;
                        if (isGroupLayer) {
                            gcxLayer.supportsIdentify = gcxLayer.supportsQuery = gcxLayer.identifiable = gcxLayer.queryable = false;
                        }
                        else {
                            gcxLayer.identifiable = gcxLayer.supportsIdentify;
                            gcxLayer.queryable = gcxLayer.supportsQuery;
                            gcxLayer.searchable = true;
                            gcxLayer.showMapTips = true;
                            // GVH-11501 Configure snapping for appropriate layer types
                            var esriServiceLayer = mapService.serviceLayer;
                            var canSnap = esriServiceLayer instanceof esri.layers.GraphicsLayer || esriServiceLayer instanceof esri.layers.ArcGISDynamicMapServiceLayer;
                            gcxLayer.snappable = canSnap;
                            gcxLayer.snappingEnabled = canSnap;
                        }
                    }
                    return mapService;
                };
                /**
                 * Verify that Service Discovery is supported, throwing an exception if it isn't.
                 */
                SiteServiceDiscoveryProvider.prototype._verifySupported = function () {
                    if (!this.supported) {
                        throw new Error("Service Discovery is not supported in the current version of Geocortex Essentials.");
                    }
                };
                /**
                 * Verify that this class is initialized, throwing an exception if it isn't.
                 */
                SiteServiceDiscoveryProvider.prototype._verifyInitialized = function () {
                    if (!this.initialized) {
                        throw new Error("The Service Discovery client is not initialized yet.");
                    }
                };
                return SiteServiceDiscoveryProvider;
            }());
            serviceDiscovery.SiteServiceDiscoveryProvider = SiteServiceDiscoveryProvider;
        })(serviceDiscovery = essentials.serviceDiscovery || (essentials.serviceDiscovery = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/**
* @private
* String constants that represent constants used by Esri's Web Map builder.
*/
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var exportMap;
        (function (exportMap) {
            var ExportMapTypes;
            (function (ExportMapTypes) {
                ExportMapTypes.WEBTILED = "WebTiledLayer";
                ExportMapTypes.BINGAERIAL = "BingMapsAerial";
                ExportMapTypes.BINGAERIALLABELS = "BingMapsAerialWithLabels";
                ExportMapTypes.BINGROADS = "BingMapsRoad";
                ExportMapTypes.BINGHYBRID = "BingMapsHybrid";
            })(ExportMapTypes = exportMap.ExportMapTypes || (exportMap.ExportMapTypes = {}));
        })(exportMap = essentials.exportMap || (essentials.exportMap = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../../_Definitions/modernizr.d.ts"/>
/// <reference path="../../../../../_Definitions/bluebird.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var exportMap;
        (function (exportMap) {
            /**
             * Used for exporting a printable representation of the current state of an {@link esri.Map}.
             * @private
             */
            var ExportMapTask = (function () {
                /**
                 * Creates an instance of a {@link ExportMapTask}.
                 * @param resource A resource which the Essentials ExportContext print will use. Can be of type {@link Map}, {@link PrintTemplate} or {@link Report}.
                 */
                function ExportMapTask(resource) {
                    /**
                     * A resource which the Essentials ExportContext print will use. Can be of type {@link Map}, {@link PrintTemplate} or {@link Report}.
                     */
                    this.resource = null;
                    this._esriMap = null;
                    this._essentialsRestUrl = null;
                    this._site = null;
                    // Ids of layers which should never be printed
                    // The snapping layer names are set in SnappingModule and EsriSnappingProvider
                    this._internalLayerIdsToRemove = ["snapping_graphics", "snapping_helper_graphics"];
                    this._populateFromResource(resource);
                    // the process needs an esri.Map and Essentials REST URL
                    // the Site is optional (AWAB consideration)
                    if (!this._esriMap || !this._essentialsRestUrl) {
                        throw new Error("Unable to create ExportMapTask from the resource.");
                    }
                }
                /**
                 * Infers an {@link ersi.Map}, Essentials REST URL and Essentials Site needed to run the ExportContext operation.
                 * @param resource A resource which the Essentials {@link ExportContext} print will use.
                 */
                ExportMapTask.prototype._populateFromResource = function (resource) {
                    if (resource instanceof essentials.Map) {
                        this._esriMap = resource.getMap();
                        this._essentialsRestUrl = resource.url + "/export";
                        this._site = resource.site;
                    }
                    else if (resource instanceof essentials.PrintTemplate) {
                        this._esriMap = resource.site.getMap();
                        this._essentialsRestUrl = resource.url + "/print";
                        this._site = resource.site;
                    }
                    else if (resource instanceof essentials.Report) {
                        this._esriMap = resource.site.getMap();
                        this._essentialsRestUrl = resource.url + "/run";
                        this._site = resource.site;
                    }
                };
                /**
                 * Generates a link to a map image with the given parameters and generated by Essentials.
                 * @param buildParameters The {@link ExportMapParameters} which will be used when creating the printed map.
                 */
                ExportMapTask.prototype.generateMapImageUrl = function (buildParameters) {
                    var _this = this;
                    var promise = new dojo.Deferred();
                    this._marshalContent(buildParameters)
                        .then(function (requestContent) {
                        var request = {
                            url: _this._essentialsRestUrl,
                            content: requestContent,
                            load: promise.resolve,
                            error: promise.reject,
                            callbackParamName: "CallBack"
                        };
                        geocortex.request(request);
                    });
                    return promise;
                };
                /**
                 * Gets a printing definition for an esri Map.
                 * @param printingTask The {@link PrintTask}. This will be used to generate the raw {@link ExportContext} object.
                 * @param map A {@link esri.Map} which will have a printing definition generated for.
                 * @param scale The scale for printing.
                 * @return An {@link ExportContext} object representing the map's printing state.
                 */
                ExportMapTask.prototype._getWebMap = function (printingTask, map, scale) {
                    // private esri API call. This does most of the heavy lifting
                    // GVH-9178 We also need to give correct scale while generating webMap.
                    var printTemplate = new esri.tasks.PrintTemplate();
                    printTemplate.outScale = scale;
                    // GVH-11091: ESRI will refuse to create legend swatches for any layer with opacity = 1 and which has a symbol with colors of differing opacity. 
                    // Setting the opacity temporarily to 0.999 works around this issue without affecting the output.
                    var alteredLayers = [];
                    for (var _i = 0, _a = map.graphicsLayerIds; _i < _a.length; _i++) {
                        var layerId = _a[_i];
                        var layer = map.getLayer(layerId);
                        if (layer.opacity === 1) {
                            layer.setOpacity(0.999);
                            alteredLayers.push(layer);
                        }
                    }
                    try {
                        var webMapResponse = printingTask._getPrintDefinition(map, printTemplate);
                        return webMapResponse;
                    }
                    finally {
                        // Restore the original opacity of the layers.
                        for (var _b = 0, alteredLayers_1 = alteredLayers; _b < alteredLayers_1.length; _b++) {
                            var layer = alteredLayers_1[_b];
                            layer.setOpacity(1);
                        }
                    }
                };
                /**
                 * Gets a printing definition for an {@link esri.Map}.
                 * @param scale The scale for printing.
                 * @return An {@link ExportContext} object representing the map's printing state.
                 */
                ExportMapTask.prototype._getPrintingObjectForEssentials = function (scale) {
                    var promise = new dojo.Deferred();
                    // rig up an Esri Print Task so we can get a map definition from it
                    // we are using a dummy url here, no request is actually made
                    var printTask = new esri.tasks.PrintTask("http://3275ec4b-ad36-465e-97e9-a20acaae8d53/", { async: false });
                    var mapDefinition = null;
                    try {
                        mapDefinition = this._getWebMap(printTask, this._esriMap, scale);
                    }
                    catch (error) {
                        promise.reject(new Error("Could not create ExportContext definition. {0} Verify that subroutines have not changed.".format(error && error.message ? error.message : "Unable to determine cause.")));
                    }
                    if (!mapDefinition) {
                        promise.reject(new Error("ExportContext definition was empty"));
                    }
                    else {
                        // modify the ExportContext as required
                        this._removeInternalLayers(mapDefinition);
                        this._handleFeatureLayers(mapDefinition);
                        this._handleDynamicLayerDefs(mapDefinition);
                        this._cleanOutVisibility(mapDefinition);
                        this._handleWebTiledLayers(mapDefinition);
                        this._handleLayersAttribution(mapDefinition, this._esriMap);
                        this._handleHeatmapRenderer(mapDefinition, this._esriMap);
                        this._handleClusters(mapDefinition, this._esriMap);
                        this._adjustMeasurementsMarkup(mapDefinition);
                        this._adjustPlotCoordinatesMarkup(mapDefinition);
                        this._removeAttributes(mapDefinition);
                        this._adjustText(mapDefinition);
                        this._setServiceVisibilities(mapDefinition);
                        // GVH-8876
                        this._adjustPlotCoordinatesMarkupOrder(mapDefinition);
                        // Run this function last. Contains crucial id manipulation/magic 
                        // which could potentially interfere with other logic if run sooner.
                        this._finalizePrintingContext(mapDefinition);
                        this._convertSymbolsToBase64(mapDefinition)
                            .then(function (ExportContext) { return promise.resolve(ExportContext); }, function (error) { return promise.reject(new Error("Converting symbols to base64 failed: {0}".format(error && error.message ? error.message : "Unable to determine cause"))); });
                    }
                    return promise;
                };
                /**
                 * Removes any layers from the printing context which are not to be printed. Ie: Snapping layers
                 * @param exportContext The {@link ExportContext} which will be modified.
                 */
                ExportMapTask.prototype._removeInternalLayers = function (exportContext) {
                    for (var i = exportContext.operationalLayers.length - 1; i >= 0; i--) {
                        var id = exportContext.operationalLayers[i].id;
                        if (!id) {
                            continue;
                        }
                        if (this._internalLayerIdsToRemove.indexOf(id) > -1) {
                            exportContext.operationalLayers.splice(i, 1);
                        }
                    }
                };
                /**
                 * Converts picture marker symbols from relative urls into encoded data or absolute urls.
                 * @param exportContext The {@link ExportContext} which will be modified.
                 */
                ExportMapTask.prototype._convertSymbolsToBase64 = function (exportContext) {
                    var promise = new dojo.Deferred();
                    var pictureSymbols = [];
                    var base64SymbolCache = {};
                    // get all picture marker symbols
                    for (var i = 0; i < exportContext.operationalLayers.length; i++) {
                        var operationalLayer = exportContext.operationalLayers[i];
                        if (!operationalLayer.featureCollection || !operationalLayer.featureCollection.layers) {
                            continue;
                        }
                        for (var j = 0; j < operationalLayer.featureCollection.layers.length; j++) {
                            var layer = operationalLayer.featureCollection.layers[j];
                            if (!layer.featureSet || !layer.featureSet.features) {
                                continue;
                            }
                            for (var k = 0; k < layer.featureSet.features.length; k++) {
                                var feature = layer.featureSet.features[k];
                                if (!feature || !feature.symbol || feature.symbol.type !== "esriPMS") {
                                    continue;
                                }
                                var symbol = feature.symbol;
                                if (symbol.url) {
                                    pictureSymbols.push(symbol);
                                }
                            }
                        }
                    }
                    // check for canvas support (IE8 will lack canvas support)
                    if (!Modernizr || !Modernizr.canvas) {
                        // IE8: no canvas, so we get absolute URL
                        for (var i = 0; i < pictureSymbols.length; i++) {
                            var url = pictureSymbols[i].url;
                            if (url) {
                                pictureSymbols[i].url = essentials.utilities.UrlUtilities.simplify(url);
                            }
                        }
                        promise.resolve(exportContext);
                    }
                    else {
                        // collect all the promises to settle later
                        var promises = [];
                        // get all unique urls
                        for (var i = 0; i < pictureSymbols.length; i++) {
                            var url = pictureSymbols[i].url;
                            if (!url) {
                                continue;
                            }
                            if (!base64SymbolCache.hasOwnProperty(url) && !pictureSymbols[i].imageData) {
                                // either url or data will have a value - we will prefer data over absolute url
                                base64SymbolCache[url] = { "url": null, "data": null };
                                var imagepromise = essentials.utilities.PrintUtilities.getImageAsBase64(url);
                                promises.push(imagepromise);
                            }
                        }
                        // get base64 image data
                        essentials.utilities.PromiseUtilities //indent
                            .settle(promises)
                            .then(function (results) {
                            results
                                .forEach(function (result) {
                                // successful base64 conversions
                                if (result.isFulfilled()) {
                                    var encodeResult = result.value();
                                    if (encodeResult && encodeResult.url && encodeResult.data) {
                                        // fill in cache with data for url key
                                        base64SymbolCache[encodeResult.url] = {
                                            "data": encodeResult.data
                                        };
                                    }
                                }
                                else {
                                    // these are the failed promises
                                    var reason = result.reason();
                                    if (reason && reason.url) {
                                        // fill in cache with absolute url for url key
                                        base64SymbolCache[reason.url] = {
                                            "url": essentials.utilities.UrlUtilities.simplify(url)
                                        };
                                    }
                                }
                                // put the resultant data back into the symbols
                                for (var i = 0; i < pictureSymbols.length; i++) {
                                    var symbol = pictureSymbols[i];
                                    var cachedData = base64SymbolCache[symbol.url];
                                    if (cachedData) {
                                        // prefer encoded data
                                        if (cachedData.data) {
                                            symbol.imageData = cachedData.data;
                                            delete symbol.url;
                                        }
                                        else if (cachedData.url) {
                                            // fall back on absolute url if there was a CORS issue with Canvas/image
                                            symbol.url = cachedData.url;
                                        }
                                    }
                                    // correct the y offset for Essentials
                                    // x offset seems to be handled by Essentials without modification
                                    if (symbol.yoffset) {
                                        symbol.yoffset = symbol.yoffset * -1;
                                    }
                                }
                            });
                            promise.resolve(exportContext);
                        });
                    }
                    return promise;
                };
                ExportMapTask.prototype._adjustMeasurementsMarkup = function (webMapObject) {
                    var measurementLayer = this._getLayer(webMapObject, "_measurement");
                    if (measurementLayer && measurementLayer.id) {
                        // Here we are just taking care of adjusting the highlight behind the measurement text.
                        // The adjustment of the measurement text itself is taken care of later by a more generic method to adjust all the text.
                        this._adjustSvgSymbols(measurementLayer);
                    }
                };
                ExportMapTask.prototype._adjustPlotCoordinatesMarkup = function (webMapObject) {
                    var pcLayer = this._getLayer(webMapObject, "_coordinates");
                    if (pcLayer && pcLayer.id) {
                        // Here we are just taking care of adjusting the highlight behind the plot coordinates text.
                        // The adjustment of the plot coordinates text itself is taken care of later by a more generic method to adjust all the text.
                        this._adjustSvgSymbols(pcLayer);
                    }
                };
                ExportMapTask.prototype._adjustPlotCoordinatesMarkupOrder = function (webMapObject) {
                    // GVH-8876
                    // The Esri export map task groups the graphics by symbol type which breaks 
                    // our z-order. This is ugly, but we need to find the coordinate graphics 
                    // and put them back in order.
                    var pcLayer = this._getLayer(webMapObject, "_coordinates");
                    if (pcLayer && pcLayer.featureCollection && pcLayer.featureCollection.layers) {
                        var pointLayer = null;
                        var textLayer = null;
                        for (var i = 0; i < pcLayer.featureCollection.layers.length; i++) {
                            // Find the two sub layers
                            var jLayer = pcLayer.featureCollection.layers[i];
                            if (jLayer.layerDefinition) {
                                if (jLayer.layerDefinition.name === "pointLayer") {
                                    pointLayer = jLayer;
                                }
                                else if (jLayer.layerDefinition.name === "textLayer") {
                                    textLayer = jLayer;
                                }
                            }
                            if (pointLayer && textLayer) {
                                // Make sure they have the expected numbers of features
                                if (pointLayer.featureSet &&
                                    pointLayer.featureSet.features &&
                                    pointLayer.featureSet.features.length > 0 &&
                                    textLayer.featureSet &&
                                    textLayer.featureSet.features &&
                                    textLayer.featureSet.features.length > 0 &&
                                    textLayer.featureSet.features.length / pointLayer.featureSet.features.length === 1.5) {
                                    // Build a new combined list of features
                                    var combined = [];
                                    while (pointLayer.featureSet.features.length > 0) {
                                        // There are 3 text features for every point feature
                                        combined.push(textLayer.featureSet.features.pop());
                                        combined.push(textLayer.featureSet.features.pop());
                                        combined.push(textLayer.featureSet.features.pop());
                                        combined.push(pointLayer.featureSet.features.pop());
                                        combined.push(pointLayer.featureSet.features.pop());
                                    }
                                    // Update the pointLayer's features
                                    pointLayer.featureSet.features = combined.reverse();
                                }
                                break;
                            }
                        }
                    }
                };
                ExportMapTask.prototype._getLayer = function (webMapObject, layerIdContains) {
                    for (var i = 0; i < webMapObject.operationalLayers.length; i++) {
                        var operationalLayer = webMapObject.operationalLayers[i];
                        // Find the measurement layer
                        // the viewer appends _measurement to the layer name so this is how we find it
                        if (operationalLayer && operationalLayer.id && operationalLayer.id.indexOf(layerIdContains) > -1
                            && operationalLayer.featureCollection && operationalLayer.featureCollection.layers) {
                            return operationalLayer;
                        }
                    }
                };
                /**
                 * SVG symbols need to be transformed. We need to replace the esriPMS symbols which were created by ESRI with
                 * our simpleMarkerSymbols that contain the SVG path.
                 * @param lyr The {@link ExportMapService} which will be modified.
                 */
                ExportMapTask.prototype._adjustSvgSymbols = function (lyr) {
                    var layerId = lyr.id;
                    var smsGraphics = [];
                    // get the Esri layer which has the measurements
                    var graphicsLayer = this._esriMap.getLayer(layerId);
                    // In the resulting array we should have just visible symbols corresponding to the highlights 
                    var highlightsGraphics = graphicsLayer.graphics.filter(function (esriGraphic) {
                        // SVG path are interpreted as simplemarkersymbols
                        if (esriGraphic.symbol.type == "simplemarkersymbol" && esriGraphic.visible) {
                            return true;
                        }
                        return false;
                    });
                    for (var x = 0; x < highlightsGraphics.length; x++) {
                        smsGraphics.push(highlightsGraphics[x].toJson());
                    }
                    // replace the graphics in the featurecollection with the ones with Essentials friendly symbols
                    for (var x = 0; x < lyr.featureCollection.layers.length; x++) {
                        if (lyr.featureCollection.layers[x].layerDefinition.name === "pointLayer") {
                            lyr.featureCollection.layers[x].featureSet.features = smsGraphics;
                            break;
                        }
                    }
                };
                /**
                 * Text markup needs to be transformed. We need to replace the objects which were created by ESRI with our own which are modified by {@link utilities.PrintUtilities}
                 * @param webMapObject The {@link ExportContext} which will be modified.
                 */
                ExportMapTask.prototype._adjustText = function (webMapObject) {
                    for (var i = 0; i < webMapObject.operationalLayers.length; i++) {
                        var operationalLayer = webMapObject.operationalLayers[i];
                        // find layer with text in the FeatureCollection
                        if (operationalLayer && operationalLayer.id && operationalLayer.featureCollection && operationalLayer.featureCollection.layers) {
                            var hasText = false;
                            for (var y = 0; y < operationalLayer.featureCollection.layers.length; y++) {
                                var layer = operationalLayer.featureCollection.layers[y];
                                if (layer && layer.layerDefinition && layer.layerDefinition.name === "textLayer") {
                                    // found text
                                    hasText = true;
                                    break;
                                }
                            }
                            // skip layers without text
                            if (!hasText) {
                                continue;
                            }
                            var layerId = operationalLayer.id;
                            var textGraphics = [];
                            // get the Esri layer which has the measurements
                            var graphicsLayer = this._esriMap.getLayer(layerId);
                            if (graphicsLayer && graphicsLayer.graphics) {
                                // Get only the visible text symbols
                                var visibleTextGraphics = graphicsLayer.graphics.filter(function (esriGraphic) {
                                    if ((esriGraphic.symbol.type == "textsymbol" || esriGraphic.symbol instanceof esri.symbol.TextSymbol) && esriGraphic.visible) {
                                        return true;
                                    }
                                    return false;
                                });
                                for (var x = 0; x < visibleTextGraphics.length; x++) {
                                    var graphic = visibleTextGraphics[x];
                                    var adjustedTextSymbol = essentials.utilities.PrintUtilities.adjustTextSymbol(graphic, graphicsLayer.id);
                                    if (adjustedTextSymbol) {
                                        // copy the graphic
                                        var tempTextGraphic = new esri.Graphic(graphic.toJson());
                                        // apply new symbol
                                        tempTextGraphic.symbol = adjustedTextSymbol;
                                        textGraphics.push(tempTextGraphic.toJson());
                                    }
                                }
                                // replace the graphics in the featurecollection with the ones with Essentials friendly text symbols
                                for (var x = 0; x < operationalLayer.featureCollection.layers.length; x++) {
                                    if (operationalLayer.featureCollection.layers[x].layerDefinition.name === "textLayer") {
                                        operationalLayer.featureCollection.layers[x].featureSet.features = textGraphics;
                                    }
                                }
                            }
                        }
                    }
                };
                /**
                 * Explicitly sets the visibility of each service layer. Otherwise, Essentials will use the service's default
                 * visibility as configured in the site.
                 */
                ExportMapTask.prototype._setServiceVisibilities = function (webMapObject) {
                    if (webMapObject.operationalLayers) {
                        var operationalLayers = webMapObject.operationalLayers;
                        for (var i = 0; i < operationalLayers.length; i++) {
                            var operationalLayer = operationalLayers[i];
                            var serviceLayer = this._esriMap.getLayer(operationalLayer.id);
                            if (operationalLayer) {
                                operationalLayer.visibility = (serviceLayer ? serviceLayer.visible : true);
                            }
                        }
                    }
                };
                /**
                 * Dynamic Layers need to have their LayerDefinitions changed so Essentials can understand them.
                 * @param exportContext The {@link ExportContext} which will be modified.
                 */
                ExportMapTask.prototype._handleDynamicLayerDefs = function (exportContext) {
                    if (this._site) {
                        if (exportContext.operationalLayers) {
                            var operationalLayers = exportContext.operationalLayers;
                            for (var i = 0; i < operationalLayers.length; i++) {
                                var msId = operationalLayers[i].id;
                                var mapService = this._site.essentialsMap.findMapServiceById(msId);
                                if (mapService && mapService.serviceLayer instanceof esri.layers.ArcGISDynamicMapServiceLayer) {
                                    var operationalLayer = operationalLayers[i];
                                    var serviceLayer = mapService.serviceLayer;
                                    if (!operationalLayer) {
                                        continue;
                                    }
                                    if (operationalLayer.layers) {
                                        var newLayerDefs = [];
                                        var layers = operationalLayer.layers;
                                        for (var x = 0; x < layers.length; x++) {
                                            var existingLayerDef = layers[x];
                                            // Layers can have an ID of 0
                                            if (existingLayerDef && (existingLayerDef.id || existingLayerDef.id === 0)) {
                                                var layerId = existingLayerDef.id;
                                                // create a new container with some minimum information
                                                var newLayerDef = {
                                                    id: layerId,
                                                    name: existingLayerDef.name,
                                                    geometryType: existingLayerDef.geometryType ? existingLayerDef.geometryType : null
                                                };
                                                // definition expression
                                                if (existingLayerDef.layerDefinition) {
                                                    // If it has a drawing info, or a source, it's a dynamic layer and we need to copy it over.
                                                    // Seems like we don't want to copy over the whole thing all of the time, because having any object there for a non-dynamic layer can break layer definitions ('layerDef' parameter)
                                                    if (existingLayerDef.layerDefinition.drawingInfo || existingLayerDef.layerDefinition.source) {
                                                        if (!newLayerDef.layerDefinition) {
                                                            newLayerDef.layerDefinition = {};
                                                        }
                                                        newLayerDef.layerDefinition.drawingInfo = existingLayerDef.layerDefinition.drawingInfo;
                                                        newLayerDef.layerDefinition.source = existingLayerDef.layerDefinition.source;
                                                    }
                                                    if (existingLayerDef.layerDefinition.definitionExpression) {
                                                        // Check for a layer definition on newLayerDef. If this is there, then this is a dynamic layer and we need the definition expression in that layer definition
                                                        if (newLayerDef.layerDefinition) {
                                                            newLayerDef.layerDefinition.definitionExpression = existingLayerDef.layerDefinition.definitionExpression;
                                                        }
                                                        else {
                                                            newLayerDef.layerDef = existingLayerDef.layerDefinition.definitionExpression;
                                                        }
                                                    }
                                                }
                                                // add display names for dynamic layers
                                                if (layerId || layerId === 0) {
                                                    // have to do a toString because that is what the method is expecting.
                                                    var essLayer = mapService.findLayerById(layerId.toString());
                                                    if (essLayer && essLayer.displayName) {
                                                        // Take the display name from the essentials layer and put it in the layer definition so it's picked up by the legend.
                                                        // Only do this if there's already a layer definition though. This will be there for dynamic layers.
                                                        if (newLayerDef.layerDefinition) {
                                                            newLayerDef.layerDefinition.displayName = essLayer.displayName;
                                                        }
                                                    }
                                                }
                                                newLayerDefs.push(newLayerDef);
                                            }
                                        }
                                        // replace the layerdefs with our own
                                        operationalLayer.layers = newLayerDefs;
                                    }
                                    if (serviceLayer.gdbVersion) {
                                        operationalLayer.gdbVersion = serviceLayer.gdbVersion;
                                    }
                                    // make sure the operational layer has an array, even if empty
                                    operationalLayer.visibleLayers = mapService.serviceLayer.visibleLayers;
                                    // Esri only includes visible layers
                                    operationalLayer.visibility = true;
                                }
                            }
                        }
                    }
                };
                /**
                 * Feature Layers need some special attention. Esri builds them for us 99%, we just need to move some properties around.
                 * @param exportContext The {@link ExportContext} which will be modified.
                 */
                ExportMapTask.prototype._handleFeatureLayers = function (exportContext) {
                    if (this._site) {
                        if (exportContext.operationalLayers) {
                            var operationalLayers = exportContext.operationalLayers;
                            for (var i = 0; i < operationalLayers.length; i++) {
                                var msId = operationalLayers[i].id;
                                var mapService = this._site.essentialsMap.findMapServiceById(msId);
                                if (mapService && mapService.serviceLayer instanceof esri.layers.FeatureLayer) {
                                    var serviceLayer = mapService.serviceLayer;
                                    var operationalLayer = operationalLayers[i];
                                    var copyOperationalLayer = {
                                        id: msId,
                                        opacity: operationalLayer.opacity,
                                        visibility: true,
                                        url: operationalLayer.url,
                                        minScale: operationalLayer.minScale ? operationalLayer.minScale : 0,
                                        maxScale: operationalLayer.maxScale ? operationalLayer.maxScale : 0
                                    };
                                    if (serviceLayer.gdbVersion) {
                                        copyOperationalLayer.gdbVersion = serviceLayer.gdbVersion;
                                    }
                                    if (operationalLayer.layerDefinition) {
                                        if (operationalLayer.layerDefinition.drawingInfo) {
                                            // Essentials expects drawing info to be a property of the operational layer
                                            copyOperationalLayer.drawingInfo = operationalLayer.layerDefinition.drawingInfo;
                                        }
                                        if (operationalLayer.layerDefinition.definitionExpression) {
                                            copyOperationalLayer.where = operationalLayer.layerDefinition.definitionExpression;
                                        }
                                    }
                                    else {
                                        // GVH-9844
                                        copyOperationalLayer.where = serviceLayer.getDefinitionExpression();
                                    }
                                    // Keeping the feature collection.
                                    copyOperationalLayer.featureCollection = operationalLayer.featureCollection;
                                    // replace the operational layer
                                    operationalLayers[i] = copyOperationalLayer;
                                }
                            }
                        }
                    }
                };
                /**
                 * Removes any -1 values from visible layers array.
                 * A value of -1 will be present if no layers are checked as visible in a map service.
                 * @param exportContext The {@link ExportContext} which will be modified.
                 */
                ExportMapTask.prototype._cleanOutVisibility = function (exportContext) {
                    // if the -1 values are left in, then Essentials will display a layer for the particular mapservice when none are to be shown
                    if (exportContext.operationalLayers) {
                        var operationalLayers = exportContext.operationalLayers;
                        for (var i = 0; i < operationalLayers.length; i++) {
                            if (operationalLayers[i].visibleLayers) {
                                for (var j = 0; j < operationalLayers[i].visibleLayers.length; j++) {
                                    // use a == so this can handle strings and numbers although it should only ever be a number
                                    if (operationalLayers[i].visibleLayers[j] == -1) {
                                        operationalLayers[i].visibleLayers.splice(j, 1);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                };
                /**
                 * Modifies potential error causing configuration for WebTiledLayers and BingMaps into Essentials readable config.
                 * @param exportContext The {@link ExportContext} which will be modified.
                 */
                ExportMapTask.prototype._handleWebTiledLayers = function (exportContext) {
                    if (exportContext.operationalLayers) {
                        var operationalLayers = exportContext.operationalLayers;
                        for (var i = 0; i < operationalLayers.length; i++) {
                            if (operationalLayers[i].type === exportMap.ExportMapTypes.WEBTILED) {
                                // replace the operational layer
                                // removes things like copyright info and tokenized urls which can blow up on the server
                                operationalLayers[i] = {
                                    id: operationalLayers[i].id,
                                    opacity: operationalLayers[i].opacity,
                                    visibility: true
                                };
                            }
                            else if (operationalLayers[i].type === exportMap.ExportMapTypes.BINGAERIAL ||
                                operationalLayers[i].type === exportMap.ExportMapTypes.BINGAERIALLABELS ||
                                operationalLayers[i].type === exportMap.ExportMapTypes.BINGHYBRID ||
                                operationalLayers[i].type === exportMap.ExportMapTypes.BINGROADS) {
                                // Aerials with labels must be translated
                                if (operationalLayers[i].type === exportMap.ExportMapTypes.BINGAERIALLABELS) {
                                    operationalLayers[i].type = exportMap.ExportMapTypes.BINGHYBRID;
                                }
                                // replace the operational layer with an Essentials friendly config
                                operationalLayers[i] = {
                                    id: operationalLayers[i].id,
                                    opacity: operationalLayers[i].opacity,
                                    visibility: true,
                                    type: operationalLayers[i].type,
                                    token: operationalLayers[i]["key"],
                                    serverType: exportMap.BingEnvironment.PRODUCTION
                                };
                            }
                        }
                    }
                };
                /**
                 * Assigns an Essentials Map Service Id to the operational layers that contains
                 * an attribution data url. This is needed since the id property of the operational
                 * layer might not be accurate after we use esri's method to serialize the map.
                 * (e.g. the id for a WMS or WMTS layer would be something like 'layer0' instead of the proper id)
                 * @param exportContext The {@link ExportContext} which will be modified.
                 * @param esriMap The {@link esri.Map} that contains information about the attributionDataUrl from which the
                 * essentials map service Id can be extracted.
                 */
                ExportMapTask.prototype._handleLayersAttribution = function (webMapObject, esriMap) {
                    var esriMapLayerIds = esriMap.layerIds.concat(esriMap.graphicsLayerIds);
                    var attributionDataUrlPattern = new RegExp(".*mapservices/([^/]*)/Attribution[^/]*");
                    webMapObject.operationalLayers.forEach(function (operationalLayer) {
                        for (var index in esriMapLayerIds) {
                            if (!esriMapLayerIds.hasOwnProperty(index)) {
                                continue;
                            }
                            var layerId = esriMapLayerIds[index];
                            if (operationalLayer.id === layerId) {
                                var layer = esriMap.getLayer(layerId);
                                if (layer.hasAttributionData && layer.attributionDataUrl) {
                                    // The attribution data url is the only information we have left on the layer
                                    // that can help us identify the original map service since ESRI can change the Ids
                                    // during serialization.
                                    var matches = attributionDataUrlPattern.exec(layer.attributionDataUrl);
                                    if (matches && matches.length > 1) {
                                        var mapServiceId = matches[1];
                                        operationalLayer.mapServiceId = mapServiceId;
                                    }
                                }
                                else if (layer.layerId && !(operationalLayer.id.indexOf("-") > -1)) {
                                    // That is the case of a feature layer that is a child of a KML layer.
                                    // A reference to the parent layer id is stored that is the one that we need
                                    // on the server to gather information about the attribution.
                                    operationalLayer.mapServiceId = layer.layerId;
                                }
                                break;
                            }
                        }
                    });
                };
                /**
                 * Removes the bitmap image(s) for heatmaps provided by ESRI from webMapObject,
                 * and adds operational layers to webMapObject that correspond to the underlying
                 * heatmap renderer(s) attached to the esriMap.
                 * @param webMapObject the {@link ExportContext} to be modified
                 * @param esriMap the {@link esri.Map} that contains the heatmap renderer(s) from which
                 * the appropriate export information will be extracted
                 */
                ExportMapTask.prototype._handleHeatmapRenderer = function (webMapObject, esriMap) {
                    var idStart = "null_image";
                    var esriMapLayerIds = esriMap.layerIds.concat(esriMap.graphicsLayerIds);
                    esriMapLayerIds.forEach(function (id) {
                        var layer = esriMap.getLayer(id);
                        if (layer.visible && layer.renderer !== undefined && layer.renderer instanceof esri.renderer.HeatmapRenderer) {
                            // Here we gather the required information from esriMap to place into a new entry in webMapObject.
                            var minScale = (layer.minScale) ? layer.minScale : 0;
                            var maxScale = (layer.maxScale) ? layer.maxScale : 0;
                            var whereClause = (layer.getDefinitionExpression()) ? layer.getDefinitionExpression() : "";
                            var gdbVersion = (layer.gdbVersion) ? layer.gdbVersion : "";
                            var renderer = layer.renderer.toJson();
                            var pointDataSource = layer.url;
                            var weightField = layer.renderer.field ? layer.renderer.field : "";
                            var drawingInfo = {
                                renderer: renderer
                            };
                            var layerDef = {
                                name: layer.name,
                                geometryType: "esriGeometryPoint",
                                displayField: weightField
                            };
                            var opLayerOb = {
                                type: "HeatMap",
                                id: id,
                                opacity: 1,
                                minScale: minScale,
                                maxScale: maxScale,
                                where: whereClause,
                                gdbVersion: gdbVersion,
                                url: pointDataSource,
                                layerDefinition: layerDef,
                                drawingInfo: drawingInfo
                            };
                            // We replace the bitmap images provided by ESRI, with regenerated heatmap on the server.
                            // We are assuming that the order of heatmaps in the original webMapObject corresponds to the
                            // order of heatmaps in esriMap. The heatmaps will be in correct order with respect to other
                            // layers. However, heatmaps might not be in correct order with respect to each other.
                            for (var index = 0; index < webMapObject.operationalLayers.length; index++) {
                                if (webMapObject.operationalLayers[index].id.startsWith(idStart)) {
                                    webMapObject.operationalLayers[index] = opLayerOb;
                                    break;
                                }
                            }
                        }
                    });
                };
                /**
                 * Removes the ESRI-provided export for clusters and prepares clustering information for export to the server,
                 * where we re-query the feature data in order to provide clustering support for printing at different extents,
                 * including large-format printing.
                 * @param webMapObject the {@link ExportContext} to be modified
                 * @param esriMap the {@link esri.Map} that contains the cluster layer(s) from which
                 * the appropriate export information will be extracted
                 */
                ExportMapTask.prototype._handleClusters = function (webMapObject, esriMap) {
                    var esriMapLayerIds = esriMap.layerIds.concat(esriMap.graphicsLayerIds);
                    var clusterLayerIdTail = "-cluster";
                    var idsToDeleteFromWebMap = [];
                    webMapObject.operationalLayers.forEach(function (operationalLayer, index, layers) {
                        if (operationalLayer.id.endsWith(clusterLayerIdTail)) {
                            idsToDeleteFromWebMap.push(operationalLayer.id);
                        }
                    });
                    // Remove the cluster layer implementations from the web map
                    idsToDeleteFromWebMap.forEach(function (idToDel) {
                        for (var i = 0; i < webMapObject.operationalLayers.length; ++i) {
                            var layer = webMapObject.operationalLayers[i];
                            if (layer.id === idToDel) {
                                webMapObject.operationalLayers.splice(i, 1);
                                break;
                            }
                        }
                    });
                    // Now all of the ESRI-provided clustering export layers are removed, and we can construct our own for server-side rendering.
                    esriMapLayerIds.forEach(function (id) {
                        var layer = esriMap.getLayer(id);
                        if (layer.id.endsWith(clusterLayerIdTail) &&
                            layer.visible &&
                            layer.renderer !== undefined &&
                            layer.renderer instanceof esri.renderer.ClassBreaksRenderer &&
                            layer.featureLayer &&
                            layer.singleFeatureLayer) {
                            var underlyingLayer = layer.featureLayer;
                            var underlyingLayerId = underlyingLayer.id;
                            var pointDataSource = layer.url;
                            var attField = layer.renderer.attributeField;
                            var dist = layer.clusterRadius.get();
                            var maxInCluster = layer.maxFeaturesInCluster.get();
                            var labelCol = layer._clusterLabelColor;
                            var singleSymRenderer = layer.singleFeatureLayer.renderer.toJson();
                            var fullRenderer = layer.renderer.toJson();
                            var featureLayerName = underlyingLayer.name;
                            var minScale = (underlyingLayer.minScale) ? underlyingLayer.minScale : 0;
                            var maxScale = (underlyingLayer.maxScale) ? underlyingLayer.maxScale : 0;
                            var whereClause = (underlyingLayer.getDefinitionExpression()) ? underlyingLayer.getDefinitionExpression() : "";
                            var gdbVersion = (underlyingLayer.gdbVersion) ? underlyingLayer.gdbVersion : "";
                            // Remove the original feature layer from the web map
                            for (var i = 0; i < webMapObject.operationalLayers.length; ++i) {
                                if (webMapObject.operationalLayers[i].id === underlyingLayerId) {
                                    if (underlyingLayer.renderer === null) {
                                        webMapObject.operationalLayers.splice(i, 1);
                                    }
                                    break;
                                }
                            }
                            // We check to see if the cluster layer is 'exploded', in which case we are already passing a graphics layer,
                            // and so we should prevent the server-side clustering algorithm from engaging in that case.
                            if (layer.singleFeatureLayer.graphics.length == 0) {
                                // We populate the operationalLayer as closely to the web map specification and our internal precedents as possible.
                                var drawingInfo = {
                                    renderer: fullRenderer,
                                    singleSymbolRenderer: singleSymRenderer,
                                    labelColor: labelCol,
                                    distance: dist,
                                    maxFeaturesInCluster: maxInCluster
                                };
                                var layerDef = {
                                    name: featureLayerName,
                                    geometryType: "esriGeometryPoint",
                                    displayField: attField
                                };
                                var opLayerOb = {
                                    type: "Cluster",
                                    id: id,
                                    opacity: 1,
                                    minScale: minScale,
                                    maxScale: maxScale,
                                    where: whereClause,
                                    gdbVersion: gdbVersion,
                                    url: pointDataSource,
                                    layerDefinition: layerDef,
                                    drawingInfo: drawingInfo
                                };
                                // Insert the layer at the index of the original feature layer that we removed,
                                // or on the top if there 
                                webMapObject.operationalLayers.splice(i, 0, opLayerOb);
                            }
                        }
                    });
                };
                /**
                 * Removes any attributes from features which are not needed for printing. Attributes contribute to circular references and extra payload data.
                 * @param exportContext The {@link ExportContext} which will be modified.
                 */
                ExportMapTask.prototype._removeAttributes = function (exportContext) {
                    if (exportContext.operationalLayers) {
                        for (var i = 0; i < exportContext.operationalLayers.length; i++) {
                            var operationalLayer = exportContext.operationalLayers[i];
                            if (operationalLayer && operationalLayer.featureCollection && operationalLayer.featureCollection.layers) {
                                for (var j = 0; j < operationalLayer.featureCollection.layers.length; j++) {
                                    var layer = operationalLayer.featureCollection.layers[j];
                                    if (layer
                                        && layer.layerDefinition
                                        && layer.layerDefinition.drawingInfo
                                        && layer.layerDefinition.drawingInfo.renderer
                                        && (layer.layerDefinition.drawingInfo.renderer.type === "uniqueValue" || layer.layerDefinition.drawingInfo.renderer.type === "classBreaks")) {
                                        // These types of renderers rely on attribute data, so don't remove anything.
                                        continue;
                                    }
                                    if (layer && layer.featureSet && layer.featureSet.features) {
                                        for (var k = 0; k < layer.featureSet.features.length; k++) {
                                            var feature = layer.featureSet.features[k];
                                            if (feature && feature.attributes) {
                                                delete feature.attributes;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                };
                /**
                 * Important operations to run at the END of {@link ExportContext} modifications.
                 * Introduced as part of GVH-6002.
                 * @param exportContext The {@link ExportContext}.
                */
                ExportMapTask.prototype._finalizePrintingContext = function (exportContext) {
                    this._fixMapServiceIds(exportContext, this._esriMap, this._site);
                };
                /**
                 * Modifies the {@link ExportContext} for layers so that Essentials can associate them back to their original site configuration.
                 * @param exportContext the {@link ExportContext} to be modified.
                 * @param esriMap the {@link esri.Map} that contains the service layers.
                 * @param site The {@link essentials.Site}.
                 */
                ExportMapTask.prototype._fixMapServiceIds = function (exportContext, esriMap, site) {
                    if (!exportContext.operationalLayers || !esriMap || !site) {
                        return;
                    }
                    var operationalLayers = exportContext.operationalLayers;
                    for (var i = 0; i < operationalLayers.length; i++) {
                        var msId = operationalLayers[i].id;
                        var serviceLayer = esriMap.getLayer(msId);
                        // Checks for WMS and Tiled service layers
                        // These service layer types will not be created with a matching id to the site configuration
                        if (!serviceLayer ||
                            !(serviceLayer instanceof esri.layers.WMSLayer ||
                                serviceLayer instanceof esri.layers.TiledMapServiceLayer)) {
                            continue;
                        }
                        var mapService = null;
                        // Find the corresponding Essentials Map Service
                        for (var x = 0; x < site.essentialsMap.mapServices.length; x++) {
                            if (site.essentialsMap.mapServices[x].serviceLayer == serviceLayer) {
                                mapService = site.essentialsMap.mapServices[x];
                                break;
                            }
                        }
                        if (!mapService) {
                            continue;
                        }
                        // Translate the id back to the site configured id
                        operationalLayers[i].id = mapService.id;
                    }
                };
                /**
                 * Creates the request parameters for the ExportContext print operation.
                 * @param buildParameters The {@link WebMapBuilderParameters} which the print operation will be created from.
                 * @return A Promise which will contain the request parameters.
                 */
                ExportMapTask.prototype._marshalContent = function (buildParameters) {
                    var _this = this;
                    var promise = new dojo.Deferred();
                    var scale;
                    if (buildParameters.reportParameters && buildParameters.reportParameters.scale) {
                        scale = parseFloat(buildParameters.reportParameters.scale.scale);
                    }
                    this._getPrintingObjectForEssentials(scale)
                        .then(function (webMapRepresentation) {
                        // create the request content object
                        var content = { "f": "json", "if": "WebMap,blankMap" };
                        if (_this._site) {
                            // metadata
                            webMapRepresentation.product = "Geocortex Essentials " + _this._site.currentVersion;
                            if (_this._site.displayTimeZoneId) {
                                content.displayTimeZoneId = _this._site.displayTimeZoneId;
                            }
                        }
                        if (buildParameters.reportParameters) {
                            var reportParams = buildParameters.reportParameters;
                            if (!webMapRepresentation.mapOptions) {
                                webMapRepresentation.mapOptions = { extent: null };
                            }
                            // GVH-5822: Don't set a scale value unless explicitly defined in the report parameters.
                            delete webMapRepresentation.mapOptions.scale;
                            // append scale from report options
                            if (reportParams.scale) {
                                var scale = parseFloat(reportParams.scale.scale);
                                if (scale && !isNaN(scale)) {
                                    webMapRepresentation.mapOptions.scale = scale;
                                }
                            }
                            // user specified spatial reference
                            if (reportParams.targetSpatialReference) {
                                webMapRepresentation.mapOptions.spatialReference = reportParams.targetSpatialReference;
                            }
                            // handle extents - current extent will be presesnt in ExportContext already so overwrite here
                            //FULL_EXTENT and INITIAL_EXTENT may be orphan conditions, there does not seem to be any occasion where the
                            //extent type has such values.
                            if (reportParams.extentType == geocortex.essentials.ReportParameters.CURRENT_EXTENT && _this._esriMap) {
                                webMapRepresentation.mapOptions.extent = _this._esriMap.extent;
                            }
                            else if (reportParams.extentType == geocortex.essentials.ReportParameters.FULL_EXTENT && (_this._site && _this._site.essentialsMap)) {
                                webMapRepresentation.mapOptions.extent = _this._site.essentialsMap.fullExtent;
                            }
                            else if (reportParams.extentType == geocortex.essentials.ReportParameters.INITIAL_EXTENT && (_this._site && _this._site.essentialsMap)) {
                                webMapRepresentation.mapOptions.extent = _this._site.essentialsMap.initialExtent;
                            }
                            else if (reportParams.extentType == geocortex.essentials.ReportParameters.CUSTOM_EXTENT && reportParams.customExtent) {
                                webMapRepresentation.mapOptions.extent = reportParams.customExtent;
                            }
                            // create exportOptions
                            var exportOptions = {
                                dpi: null,
                                outputSize: []
                            };
                            //image dimensions - get user specified, else use map dimensions
                            if (reportParams.imageWidth) {
                                exportOptions.outputSize[0] = reportParams.imageWidth;
                            }
                            else {
                                exportOptions.outputSize[0] = _this._esriMap.width;
                            }
                            if (reportParams.imageHeight) {
                                exportOptions.outputSize[1] = reportParams.imageHeight;
                            }
                            else {
                                exportOptions.outputSize[1] = _this._esriMap.height;
                            }
                            // dpi
                            if (reportParams.resolution) {
                                exportOptions.dpi = reportParams.resolution.dpi;
                            }
                            else {
                                // default print dpi
                                exportOptions.dpi = 96;
                            }
                            webMapRepresentation.exportOptions = exportOptions;
                            if (reportParams.grid && reportParams.grid.id) {
                                // the grid is the only item currently in the layout options
                                var layoutOptions = { grid: reportParams.grid.id };
                                webMapRepresentation.layoutOptions = layoutOptions;
                            }
                            // custom report text fields (title, datum, descriptions as entered by user or by defaulted by admin)
                            if (reportParams.fields && reportParams.fields.length > 0) {
                                for (var i = 0; i < reportParams.fields.length; i++) {
                                    content[reportParams.fields[i].id] = reportParams.fields[i].value;
                                }
                            }
                            // output format (PNG, PDF, JPEG, ect)
                            if (reportParams.outputFormat) {
                                content.outputFormat = reportParams.outputFormat;
                            }
                            // feature ID's as a comma-separated string.
                            if (reportParams.featureIds) {
                                content.featureIDs = reportParams.featureIds.join(",");
                            }
                            // include georeference data
                            if (reportParams.includeGeoreferenceData) {
                                content.georef = reportParams.includeGeoreferenceData;
                            }
                            if (reportParams.includeData) {
                                content.of = content.of ? content.of + ",includeData" : "includeData";
                            }
                        }
                        if (buildParameters.queryParameters) {
                            content = dojo.mixin(buildParameters.queryParameters, content);
                            if (content.geometry) {
                                content.geometry = JSON.stringify(content.geometry);
                            }
                        }
                        // extras - not used currently, but allows for potential parameter expansion
                        if (buildParameters.operationParameters) {
                            content = dojo.mixin(buildParameters.operationParameters, content);
                        }
                        if (reportParams.notificationEmailAddress) {
                            content.emailAddress = reportParams.notificationEmailAddress;
                        }
                        // stringify the ExportContext
                        content.data = JSON.stringify(webMapRepresentation);
                        //resolve content;
                        promise.resolve(content);
                    }, function (error) { return promise.reject(new Error("Failed to serialize ExportContext content: {0}".format(error && error.message ? error.message : "Unable to determine cause"))); });
                    return promise;
                };
                return ExportMapTask;
            }());
            exportMap.ExportMapTask = ExportMapTask;
        })(exportMap = essentials.exportMap || (essentials.exportMap = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var utilities;
        (function (utilities) {
            /**
             * Internal implementation detail.
             * @private
             */
            var SettleInspectionState = (function () {
                function SettleInspectionState() {
                    this.state = { fulfilled: false, rejected: false };
                }
                SettleInspectionState.prototype.fulfill = function (value) {
                    this.state.fulfilled = true;
                    this.state.value = value;
                };
                SettleInspectionState.prototype.reject = function (reason) {
                    this.state.rejected = true;
                    this.state.reason = reason;
                };
                SettleInspectionState.prototype.isFulfilled = function () {
                    return this.state.fulfilled;
                };
                SettleInspectionState.prototype.isRejected = function () {
                    return this.state.rejected;
                };
                SettleInspectionState.prototype.isPending = function () {
                    return !this.state.fulfilled && !this.state.rejected;
                };
                SettleInspectionState.prototype.value = function () {
                    return this.state.value;
                };
                SettleInspectionState.prototype.reason = function () {
                    return this.state.reason;
                };
                return SettleInspectionState;
            }());
            /**
             * Contains utilities for working with `Promise` objects, including strategies for interoperating with different implementations of `Promise`.
             * For more information on Promises, see the [open standard](https://promisesaplus.com/).
             */
            var PromiseUtilities = (function () {
                function PromiseUtilities() {
                }
                /**
                 * Based on BlueBird's `settle` function. Accepts an array of {@link Thenable} objects and returns a {@link Thenable} that is resolved when all of the
                 * given promises are in a finalized state (i.e. either resolved or rejected).
                 * @param arg An untyped, promise-like object. For example, a `dojo.Deferred`.
                 */
                PromiseUtilities.settle = function (arg) {
                    // All this awful casting can go away when dojo.Deferred is typed with generics.
                    if (dojo.isArray(arg)) {
                        return PromiseUtilities._settleImpl(arg);
                    }
                    else if (arg.then) {
                        return arg.then(function (value) { return PromiseUtilities._settleImpl(value); });
                    }
                    throw new Error("Unknown parameter type.  Must be an array of promises or a promise of array of promises.");
                };
                /** @private */
                PromiseUtilities._settleImpl = function (promises) {
                    var deferred = new dojo.Deferred();
                    var checkPromises;
                    var settleInspections = promises.map(function (promise) {
                        var settleInspectionState = new SettleInspectionState();
                        if (!promise || typeof promise.then != "function") {
                            settleInspectionState.fulfill(promise);
                        }
                        else {
                            promise.then(function (value) {
                                settleInspectionState.fulfill(value);
                                if (checkPromises) {
                                    checkPromises();
                                }
                            }, function (reason) {
                                settleInspectionState.reject(reason);
                                if (checkPromises) {
                                    checkPromises();
                                }
                            });
                        }
                        return settleInspectionState;
                    });
                    checkPromises = function () {
                        if (settleInspections.every(function (v) { return !v.isPending(); })) {
                            deferred.resolve(settleInspections);
                        }
                    };
                    checkPromises();
                    return deferred.promise;
                };
                return PromiseUtilities;
            }());
            utilities.PromiseUtilities = PromiseUtilities;
        })(utilities = essentials.utilities || (essentials.utilities = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents information about an Essentials {@link Layer}.
         */
        var EssentialsLayerInfo = (function () {
            function EssentialsLayerInfo() {
            }
            return EssentialsLayerInfo;
        }());
        essentials.EssentialsLayerInfo = EssentialsLayerInfo;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/** @private */
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var Rx;
        (function (Rx) {
            /** @private */
            function nop() {
            }
            /** @private */
            var AnonymousObservable = (function () {
                function AnonymousObservable() {
                }
                AnonymousObservable.prototype.select = function (selector) {
                    var source = this;
                    var result = new AnonymousObservable();
                    result._subscribe = function (observer) {
                        var valid = true;
                        var newObserver = {
                            onNext: function (x) {
                                if (valid) {
                                    try {
                                        observer.onNext(selector(x));
                                    }
                                    catch (ex) {
                                        valid = false;
                                        observer.onError(ex);
                                    }
                                }
                            },
                            onError: function (e) {
                                if (valid) {
                                    valid = false;
                                    observer.onError(e);
                                }
                            },
                            onCompleted: function () {
                                if (valid) {
                                    valid = false;
                                    observer.onCompleted();
                                }
                            }
                        };
                        var subscription = source._subscribe(newObserver);
                        if (valid) {
                            return subscription;
                        }
                        subscription.dispose();
                        return { dispose: function () { } };
                    };
                    return result;
                };
                AnonymousObservable.prototype._subscribe = function (observer) {
                    return { dispose: nop };
                };
                AnonymousObservable.prototype.subscribe = function (onNextOrObserver, onError, onCompleted) {
                    if (arguments.length > 1) {
                        var observer = {
                            onNext: onNextOrObserver || nop,
                            onError: onError || nop,
                            onCompleted: onCompleted || nop
                        };
                        return this._subscribe(observer);
                    }
                    if (onNextOrObserver instanceof Function) {
                        if (onNextOrObserver.length > 1) {
                            var observer = {
                                onNext: function (x) { return onNextOrObserver(x); },
                                onError: function (x) { return onNextOrObserver(undefined, x); },
                                onCompleted: function () { return onNextOrObserver(); }
                            };
                            return this._subscribe(observer);
                        }
                        var observer = {
                            onNext: onNextOrObserver,
                            onError: onError || nop,
                            onCompleted: onCompleted || nop
                        };
                        return this._subscribe(observer);
                    }
                    if (onNextOrObserver) {
                        return this._subscribe(onNextOrObserver);
                    }
                    return this._subscribe({ onNext: nop, onError: nop, onCompleted: nop });
                };
                return AnonymousObservable;
            }());
            Rx.AnonymousObservable = AnonymousObservable;
        })(Rx = essentials.Rx || (essentials.Rx = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="FeatureLayerService.ts" />
/// <reference path="MapService.ts" />
/// <reference path="../essentials.ts" />
/// <reference path="Rx.light.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /** @docs-hide-from-nav */
        var ServiceRequestError = (function () {
            function ServiceRequestError() {
            }
            ServiceRequestError.prototype.toString = function () {
                return this.message;
            };
            return ServiceRequestError;
        }());
        essentials.ServiceRequestError = ServiceRequestError;
        ServiceRequestError.prototype.message = "An error occurred while performing the operation.";
        ServiceRequestError.prototype.details = new Array();
        ServiceRequestError.prototype.name = "ServiceRequestError";
        /** @docs-hide-from-nav */
        var ServiceRequestAbortedError = (function (_super) {
            __extends(ServiceRequestAbortedError, _super);
            function ServiceRequestAbortedError() {
                _super.apply(this, arguments);
            }
            return ServiceRequestAbortedError;
        }(ServiceRequestError));
        essentials.ServiceRequestAbortedError = ServiceRequestAbortedError;
        ServiceRequestAbortedError.prototype.message = "The request was aborted.";
        ServiceRequestAbortedError.prototype.name = "ServiceRequestAbortedError";
        /** @docs-hide-from-nav */
        var ServiceRequestObserver = (function () {
            function ServiceRequestObserver() {
            }
            ServiceRequestObserver.prototype.start = function () {
                try {
                    this.promise = geocortex.request(this);
                    if (this.valid) {
                        this.registration = this.servicePoint.cancellationToken.register(this.error.bind(this));
                    }
                    else {
                        this.promise.cancel();
                    }
                }
                catch (ex) {
                    this.error(ex);
                }
            };
            ServiceRequestObserver.prototype.load = function (json) {
                try {
                    if (this.member) {
                        var array = json[this.member];
                        if (array) {
                            for (var i = 0; i < array.length; i++) {
                                if (this.valid) {
                                    this.observer.onNext(array[i]);
                                }
                                else {
                                    break;
                                }
                            }
                        }
                    }
                    else if (this.valid) {
                        this.observer.onNext(json);
                    }
                    this.complete();
                }
                catch (ex) {
                    this.error(ex);
                }
            };
            ServiceRequestObserver.prototype.error = function (error) {
                if (this.valid) {
                    this.valid = false;
                    this.promise.cancel();
                    this.registration.dispose();
                    this.observer.onError(e || new ServiceRequestAbortedError());
                }
            };
            ServiceRequestObserver.prototype.complete = function () {
                if (this.valid) {
                    this.valid = false;
                    this.promise.cancel();
                    this.registration.dispose();
                    this.observer.onCompleted();
                }
            };
            ServiceRequestObserver.prototype.dispose = function () {
                if (this.valid) {
                    this.valid = false;
                    this.promise.cancel();
                    this.registration.dispose();
                }
            };
            return ServiceRequestObserver;
        }());
        ServiceRequestObserver.prototype.handleAs = "json";
        ServiceRequestObserver.prototype.valid = true;
        ServiceRequestObserver.prototype.registration = { dispose: function () { } };
        var base;
        var anchor;
        function resolveQuery(baseAddress, query) {
            if (!anchor) {
                base = document.head.getElementsByTagName("base")[0];
                if (!base) {
                    base = document.createElement("base");
                    base.setAttribute("href", window.location.href);
                    document.head.appendChild(base);
                }
                anchor = document.createElement("a");
            }
            try {
                var href = base.getAttribute("href");
                base.setAttribute("href", baseAddress);
                anchor.setAttribute("href", query);
                query = anchor.href;
            }
            finally {
                base.setAttribute("href", href);
            }
            return query;
        }
        function indexOfAny(query) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var i = query.length;
            for (var key = 0; key < args.length; key++) {
                var j = query.indexOf(args[key]);
                if (j >= 0 && j < i) {
                    i = j;
                }
            }
            return j;
        }
        function splitQuery(query) {
            var i = indexOfAny(query, "?", "!", "#");
            return { query: query.substring(0, i), tail: query.substring(i) };
        }
        /** @docs-hide-from-nav */
        var ServicePoint = (function () {
            function ServicePoint() {
            }
            /**
             * Formats the query resolving any placeholders and resolving the query to a fully-qualified query.
             *
             * @param query The query string to format.
             * @returns {string} The resulting formatted query.
             */
            ServicePoint.prototype.formatQuery = function (query) {
                var argArray = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    argArray[_i - 1] = arguments[_i];
                }
                var queryAsAny = query;
                var stuff = splitQuery(queryAsAny.format.apply(query, argArray));
                return resolveQuery(this.baseAddress, stuff.query) + stuff.tail;
            };
            /**
             * Returns the request as a reactive observable.
             *
             * @param query The query to execute upon observation.
             * @returns The observable source representing the query.
             */
            ServicePoint.prototype.getRequest = function (query, member) {
                var anonymousObserver = function (observer) {
                    this.observer = observer;
                    this.start();
                };
                anonymousObserver.prototype = new ServiceRequestObserver();
                anonymousObserver.prototype.servicePoint = this;
                anonymousObserver.prototype.query = query;
                anonymousObserver.prototype.member = member;
                var anonymousObservable = new essentials.Rx.AnonymousObservable();
                anonymousObservable._subscribe = function (observer) {
                    return new anonymousObserver(observer);
                };
                return anonymousObservable;
            };
            return ServicePoint;
        }());
        essentials.ServicePoint = ServicePoint;
        ServicePoint.prototype.baseAddress = window.location.href;
        ServicePoint.prototype.cancellationToken = {
            dispose: function () { },
            register: function (action) {
                return this;
            }
        };
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/arcgis-js-api.d.ts" />
/// <reference path="../../../../_Definitions/dojo.d.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents search query parameters for a Geocortex Search.
         */
        var SearchQuery = (function () {
            function SearchQuery() {
                /** The extent to search within. */
                this.extent = null;
                /** The maximum number of results to return. */
                this.maxResults = 50;
                /**
                 * The 'contains' parameter determines whether to look for an exact match of the search text or not. If "true",
                 * searches for a value that contains the searchText provided. This is a case-insensitive search.
                 * If "false", searches for an exact match of the searchText string. The exact match is case-sensitive.
                 * The default is "true".
                 */
                this.contains = true;
                /** If "true", the result set will include the geometry associated with each result. The default is "false". */
                this.returnGeometry = false;
                /**
                 * Indicates whether or not to return the results of the search highlighted in the given fields.
                 * Those results can be found on the feature's extended attributes property.
                 */
                this.returnHighlights = false;
                /**
                 * If "true", the response only includes an array of object IDs. Otherwise the response is a feature set.
                 * The default is "false".
                 */
                this.returnIdsOnly = false;
                /**
                 * If "true", the response only includes the count (number of features / records) that would be returned by a search.
                 * Otherwise the response is a feature set. The default is "false". This option supersedes the returnIdsOnly parameter.
                 */
                this.returnCountOnly = false;
                /** The search text string parameter. */
                this.searchText = null;
                /**
                 * The {@link esri.SpatialReference} for the returned geometries.
                 * If not specified, the output geometries are returned in the default spatial reference of WKID 4326 (WGS84).
                 */
                this.outSpatialReference = null;
            }
            /**
             * Converts these parameters into a JSON object.
             * @param map The {@link esri.Map}.
             * @param essentialsMap The {@link essentials.Map}.
             */
            SearchQuery.prototype.toJson = function (esriMap, essentialsMap) {
                if (!esriMap || !essentialsMap) {
                    throw new Error("Search query parameter creation is missing a main map.");
                }
                var jobject = {
                    searchText: this.searchText,
                    contains: this.contains,
                    returnGeometry: this.returnGeometry,
                    returnHighlights: this.returnHighlights,
                    returnIdsOnly: this.returnIdsOnly,
                    returnCountOnly: this.returnCountOnly
                };
                // Add optional envelope
                if (this.extent) {
                    jobject.envelope = "{0},{1},{2},{3}".format(this.extent.xmin, this.extent.ymin, this.extent.xmax, this.extent.ymax);
                }
                // GVH-3771 Add optional output spatial reference whenever geometries are returned or precedence is given to nearby results.
                if ((this.returnGeometry || this.extent) && this.outSpatialReference) {
                    // GVH-3495 Support WKT projections
                    jobject.outSR = this.outSpatialReference.toJson();
                }
                // Add optional MaxResults
                if (this.maxResults > 0) {
                    jobject.maxResults = this.maxResults;
                }
                // Add searchable layers to query. If no layers are specified, consider all layers associated with this site
                var targetLayers = this.searchLayers;
                if (!targetLayers || targetLayers.length == 0) {
                    targetLayers = essentialsMap.allLayers();
                }
                // Format into query string in form: layers="LA_Base(include:1,2);..."
                jobject.layers = this._getServiceStrings(targetLayers);
                return jobject;
            };
            SearchQuery.prototype._getServiceStrings = function (layers) {
                var serviceStrings = "";
                var services = {};
                // Group layers by map service
                for (var i = 0; i < layers.length; i++) {
                    var layer = layers[i];
                    // Exclude layers and map services where searchable == false
                    if (!layer || !layer.searchable || !layer.mapService || !layer.mapService.instantSearch) {
                        continue;
                    }
                    var key = layer.mapService.id;
                    if (!services.hasOwnProperty(key)) {
                        services[key] = [];
                    }
                    services[key].push(layer.id);
                }
                // Format into query string in form: layers=LA_Base(include:1,2);...
                for (var svc in services) {
                    if (!services.hasOwnProperty(svc)) {
                        continue;
                    }
                    serviceStrings += serviceStrings.length === 0 ? "" : ";";
                    serviceStrings += "{0}(include:{1})".format(svc, services[svc].join(","));
                }
                return serviceStrings;
            };
            return SearchQuery;
        }());
        essentials.SearchQuery = SearchQuery;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/arcgis-js-api.d.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents the result set of a Geocortex Search.
         */
        var SearchResultSet = (function () {
            /**
             * Initializes a new instance of the {@link geocortex.essentials.SearchResultSet} class.
             * @param options An arbitrary options object.
             */
            function SearchResultSet(options) {
                /** The set of search results.*/
                this.features = [];
                /** The {@link Layer} associated with this result set. */
                this.layer = null;
                if (options && options.hasOwnProperty("features")) {
                    this.features = options.features;
                }
                if (options && options.hasOwnProperty("layer")) {
                    this.layer = options.layer;
                }
            }
            return SearchResultSet;
        }());
        essentials.SearchResultSet = SearchResultSet;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/arcgis-js-api.d.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents the results of a Geocortex Search.
         */
        var SearchResultFeature = (function () {
            /**
             * Initializes a new instance of the {@link SearchResultFeature} class.
             * @param graphic The {@link esri.Graphic} represented by this result.
             * @param layer The link {@link Layer} that this search is for.
             */
            function SearchResultFeature(graphic, layer) {
                /** The related Esri feature.*/
                this.esriFeature = null;
                /** The layer this search result is a part of. */
                this.layer = null;
                /**  The highlights associated with this search result. */
                this.highlights = {};
                this.esriFeature = graphic;
                this.layer = layer;
            }
            return SearchResultFeature;
        }());
        essentials.SearchResultFeature = SearchResultFeature;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../FeatureLayerService.ts" />
/// <reference path="../MapService.ts" />
/// <reference path="../ServicePoint.ts" />
/// <reference path="ResultItem.ts" />
/** @private */
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var serviceDiscovery;
        (function (serviceDiscovery) {
            /** @private */
            var ServiceDiscoveryServicePoint = (function () {
                function ServiceDiscoveryServicePoint(service) {
                    this.service = service;
                }
                ServiceDiscoveryServicePoint.prototype.postProcess = function (item) {
                    if (!item.thumbnailUrl) {
                        item.thumbnailUrl = this.service.formatQuery("connections/{0}/preview?f=json&providerName={1}&url={2}", item.connection.id, item.serviceProviderName, item.url);
                    }
                    for (var i in item.children) {
                        this.postProcess(item.children[i]);
                    }
                    return item;
                };
                ServiceDiscoveryServicePoint.prototype.findServices = function (term) {
                    var postProcess = this.postProcess.bind(this.postProcess);
                    var query = this.service.formatQuery("connections/find?f=json&term={0}", term);
                    return this.service.getRequest(query, "results").select(postProcess);
                };
                ServiceDiscoveryServicePoint.prototype.expandService = function (id, providerName, url) {
                    if (arguments.length == 1) {
                        var item = id;
                        id = item.connection.id;
                        providerName = item.serviceProviderName;
                        url = item.url;
                    }
                    var postProcess = this.postProcess.bind(this.postProcess);
                    var query = this.service.formatQuery("connections/{0}/expand?f=json&providerName={1}&url={2}", id, providerName, url);
                    return this.service.getRequest(query, null).select(postProcess);
                };
                ServiceDiscoveryServicePoint.prototype.suggestHints = function (term) {
                    var query = this.service.formatQuery("connections/suggest?f=json&term={0}", term);
                    return this.service.getRequest(query, "hints");
                };
                ServiceDiscoveryServicePoint.prototype.realizeMapService = function (id, providerName, url, sr) {
                    if (arguments.length == 1) {
                        var item = id;
                        id = item.connection.id;
                        providerName = item.serviceProviderName;
                        url = item.url;
                    }
                    var realizer = function (json) {
                        if (json.serviceType.indexOf("FeatureLayer") >= 0) {
                            var fls = new essentials.FeatureLayerService(url);
                            fls._configureObject(json, true);
                            return fls;
                        }
                        else {
                            var ms = new essentials.MapService(url);
                            ms._configureObject(json, true);
                            return ms;
                        }
                    };
                    var query = this.service.formatQuery("connections/{0}/realize?f=json&providerName={1}&url={2}&sr={3}", id, providerName, url, sr);
                    return this.service.getRequest(query, null).select(realizer);
                };
                return ServiceDiscoveryServicePoint;
            }());
            serviceDiscovery.ServiceDiscoveryServicePoint = ServiceDiscoveryServicePoint;
        })(serviceDiscovery = essentials.serviceDiscovery || (essentials.serviceDiscovery = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var utilities;
        (function (utilities) {
            /**
             * Static utility methods for working with URLs.
             */
            var UrlUtilities = (function () {
                function UrlUtilities() {
                }
                /**
                 * Simplifies a URL by processing double dots (..) and single dots (.) in the URL.
                 * For example, `/sites/MySite/viewers/ViewerA/VirtualDirectory/../../` is simplified to `/sites/MySite/viewers/`.
                 * @param url The URL to simplify.
                 */
                UrlUtilities.simplify = function (url) {
                    var link = document.createElement("a");
                    link.href = url;
                    var reformattedUrl = link.href;
                    var lastChar = reformattedUrl.charAt(reformattedUrl.length - 1);
                    if (lastChar === "/" || lastChar === "\\") {
                        reformattedUrl = reformattedUrl.substr(0, reformattedUrl.length - 1);
                    }
                    return reformattedUrl;
                };
                /**
                 * Gets the components of a url (eg. host, protocol, path, query, etc.).
                 */
                UrlUtilities.getUrlComponents = function (url) {
                    var link = document.createElement("a");
                    link.href = url;
                    return {
                        host: link.host,
                        hostname: link.hostname,
                        protocol: link.protocol,
                        port: link.port,
                        query: link.search,
                        hash: link.hash,
                        path: link.pathname,
                        origin: link.protocol + "//" + link.host // host includes the port if non-default (not 80 for http and not 443 for https)
                    };
                };
                /**
                 * Resolves a relative URL, returning a fully qualified URL.
                 * @param baseAddress The base URL being resolved against.
                 * @param relativeUrl The URL being resolved.
                 * @param normalize Optional. If set to `true`, will simplify the URL before returning.
                 */
                UrlUtilities.resolveUrl = function (baseAddress, relativeUrl, normalize) {
                    if (normalize === void 0) { normalize = false; }
                    var trailingSlash = baseAddress.endsWith("/") ? "" : "/";
                    var newUrl = "" + baseAddress + trailingSlash + relativeUrl;
                    if (normalize) {
                        // Normalize the URL path - e.g. `/sites/MySite/viewers/ViewerA/VirtualDirectory/../../` is simplified to `/sites/MySite/viewers/`
                        newUrl = UrlUtilities.simplify(newUrl);
                    }
                    return newUrl;
                };
                return UrlUtilities;
            }());
            utilities.UrlUtilities = UrlUtilities;
        })(utilities = essentials.utilities || (essentials.utilities = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var exportMap;
        (function (exportMap) {
            /**
             * Contains parameters to use when exporting maps via {@link ExportMapTask}.
             * @private
             */
            var ExportMapParameters = (function () {
                function ExportMapParameters() {
                    /**
                     * Container to hold operation parameters.
                     * These parameters will be sent to Essentials during the request.
                     */
                    this.operationParameters = null;
                    /** The {@link geocortex.essentials.ReportParameters} which will be consumed by the {@link ExportMapTask}. */
                    this.reportParameters = null;
                    /** The query parameters used when building reports. */
                    this.queryParameters = null;
                    this.operationParameters = {};
                    this.reportParameters = new essentials.ReportParameters();
                }
                return ExportMapParameters;
            }());
            exportMap.ExportMapParameters = ExportMapParameters;
        })(exportMap = essentials.exportMap || (essentials.exportMap = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="FormItem.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            var MarkdownFormItem = (function (_super) {
                __extends(MarkdownFormItem, _super);
                /**
                 * Initializes a new instance of the {@link geocortex.forms.items.MarkdownFormItem} class.
                 * @param xmlNode Xml node containing the form item definition.
                 * @param formDefinition The form definition that this form item belongs to.
                 */
                function MarkdownFormItem(xmlNode, formDefinition) {
                    _super.call(this, xmlNode, formDefinition);
                    this.formItemType = "MarkdownFormItem";
                    if (xmlNode) {
                        this.plainText = new Observable(geocortex.forms.getElementText(xmlNode, "PlainText"));
                    }
                    else {
                        this.plainText = new Observable("");
                    }
                }
                /**
                 * @private Renders the form item.
                 */
                MarkdownFormItem.prototype._render = function () {
                    return geocortex.forms.renderFormItem(this);
                };
                return MarkdownFormItem;
            }(items.AbstractFormItem));
            items.MarkdownFormItem = MarkdownFormItem;
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var workflow;
    (function (workflow) {
        var ArgumentValueWrapper = (function () {
            /**
             * Initializes a new instance of the {@link geocortex.workflow.ArgumentValueWrapper} class.
             * @class
             * Represents an argument value used that will be assigned to a {@link geocortex.workflow.ArgumentInfo}.
             * @constructs
             * @param {String} runtimeTypeName The runtime type name of the argument value.
             * @param {Object} value The value of the argument.
             */
            function ArgumentValueWrapper(runtimeTypeName, value) {
                /**
                 * The runtime type name of the argument value.
                 * @type String
                 */
                this.runtimeTypeName = null;
                this.runtimeTypeName = runtimeTypeName || null;
                this.value = value || null;
            }
            return ArgumentValueWrapper;
        }());
        workflow.ArgumentValueWrapper = ArgumentValueWrapper;
    })(workflow = geocortex.workflow || (geocortex.workflow = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var utilities;
        (function (utilities) {
            /** @private */
            var LayerUtilities = (function () {
                function LayerUtilities() {
                }
                /** @private */
                LayerUtilities.createFeatureLayerFromCsv = function (layerContext, limitOption) {
                    var featureLayer = new dojo.Deferred();
                    if (!layerContext) {
                        featureLayer.resolve(null);
                        return featureLayer;
                    }
                    var csvStore = new dojox.data.CsvStore({
                        url: layerContext.url,
                        separator: layerContext.columnDelimiter || ","
                    });
                    csvStore.fetch({
                        onComplete: function (items, request) {
                            var latField, longField;
                            var objectId = 0;
                            var layerDef = layerContext.layerDefinition;
                            var featureCollection = {
                                "layerDefinition": layerDef,
                                "featureSet": {
                                    "features": [],
                                    "geometryType": "esriGeometryPoint"
                                }
                            };
                            var lowerBound = null;
                            var upperBound = null;
                            if (limitOption) {
                                lowerBound = limitOption.lowerBound || 0;
                                upperBound = limitOption.upperBound || items.length;
                            }
                            if (lowerBound || upperBound) {
                                items = items.slice(lowerBound, upperBound);
                            }
                            // Add records in this CSV store as graphics
                            dojo.forEach(items, function (item, index) {
                                if (index === 0) {
                                    if (layerContext.locationInfo) {
                                        latField = layerContext.locationInfo.latitudeFieldName;
                                        longField = layerContext.locationInfo.longitudeFieldName;
                                    }
                                }
                                var id = csvStore.getIdentity(item);
                                var attrs = csvStore.getAttributes(item), attributes = {};
                                // Read all the attributes for  this record/item
                                dojo.forEach(attrs, function (attr) {
                                    var value = Number(csvStore.getValue(item, attr));
                                    if (isNaN(value)) {
                                        attributes[attr] = csvStore.getValue(item, attr);
                                    }
                                    else {
                                        attributes[attr] = value;
                                    }
                                });
                                attributes["__OBJECTID"] = objectId;
                                objectId++;
                                var latitude = parseFloat(attributes[latField]);
                                var longitude = parseFloat(attributes[longField]);
                                if (isNaN(latitude) || isNaN(longitude)) {
                                    return;
                                }
                                var geometry = new esri.geometry.Point(longitude, latitude);
                                var feature = {
                                    "geometry": geometry.toJson(),
                                    "attributes": attributes
                                };
                                featureCollection.featureSet.features.push(feature);
                            });
                            var featureLayerFromCsv = new esri.layers.FeatureLayer(featureCollection);
                            // After instantiating the feature collection based feature layer here, 
                            // the Renderer's symbol strangely has the values of imageData and url swapped. 
                            // So what I do here is that I restore the symbol from the original layer definition. 
                            var symbol = null;
                            if (layerDef &&
                                layerDef.drawingInfo &&
                                layerDef.drawingInfo.renderer &&
                                layerDef.drawingInfo.renderer.symbol &&
                                layerDef.drawingInfo.renderer.symbol.type === "esriPMS") {
                                symbol = layerDef.drawingInfo.renderer.symbol;
                            }
                            if (symbol != null) {
                                featureLayerFromCsv.renderer.symbol.imageData = symbol.imageData;
                                featureLayerFromCsv.renderer.symbol.url = symbol.url;
                            }
                            if (layerContext.title) {
                                featureLayerFromCsv.name = layerContext.title;
                            }
                            featureLayerFromCsv.layerId = layerContext.id || geocortex.framework.utils.alphaNumericToken();
                            featureLayer.resolve(featureLayerFromCsv);
                        }
                    });
                    return featureLayer;
                };
                LayerUtilities.decomposeFeatureLayerUrl = function (layerUrl) {
                    var match = /(.+?)\/([0-9]*)(\?.*)?$/g.exec(layerUrl);
                    return {
                        serviceUrl: match[1],
                        layerId: parseInt(match[2]),
                        queryString: match[3]
                    };
                };
                return LayerUtilities;
            }());
            utilities.LayerUtilities = LayerUtilities;
        })(utilities = essentials.utilities || (essentials.utilities = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents the results of a Geocortex Search.
         */
        var SearchResults = (function () {
            function SearchResults() {
                /** An error that may or may not have happened during a Search. */
                this.error = null;
                /** The results of the search, if any. */
                this.results = [];
                /** The {@link SearchQuery} that this {@link SearchResults} resulted from. */
                this.queryParams = null;
            }
            return SearchResults;
        }());
        essentials.SearchResults = SearchResults;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var catalog;
        (function (catalog) {
            /** Represents an entry from a Layer Catalog. */
            var CatalogEntry = (function () {
                /** Creates a new instance of the CatalogEntry class. */
                function CatalogEntry() {
                    /** The ID of the entry. */
                    this.id = null;
                    /** The display name of the entry. */
                    this.displayName = null;
                    /** The collection of child entries. */
                    this.entries = null;
                    /** The type name of this entry. */
                    this.type = null;
                    this.entries = [];
                }
                return CatalogEntry;
            }());
            catalog.CatalogEntry = CatalogEntry;
        })(catalog = essentials.catalog || (essentials.catalog = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var catalog;
        (function (catalog) {
            /** Represents parameters to use when requesting Layer Catalog information from the Essentials REST API. */
            var LayerCatalogDetailsParams = (function () {
                /** Creates a new instance of the LayerCatalogDetailsParams class. */
                function LayerCatalogDetailsParams() {
                    /** The list of IDs to include in the layer catalog details query. */
                    this.ids = null;
                    this.ids = [];
                }
                return LayerCatalogDetailsParams;
            }());
            catalog.LayerCatalogDetailsParams = LayerCatalogDetailsParams;
        })(catalog = essentials.catalog || (essentials.catalog = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var catalog;
        (function (catalog) {
            /** An object that represents the parameters of a layer catalog query. This is a placeholder for future expansion.  */
            var LayerCatalogParams = (function () {
                function LayerCatalogParams() {
                }
                return LayerCatalogParams;
            }());
            catalog.LayerCatalogParams = LayerCatalogParams;
        })(catalog = essentials.catalog || (essentials.catalog = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var catalog;
        (function (catalog) {
            /** Represents a set of {@link CatalogEntry} instances returned from a REST Endpoint and for a particular {@link MapService}. */
            var LayerCatalogDetail = (function () {
                /** Creates an instance of a LayerCatalogDetail. */
                function LayerCatalogDetail() {
                    /** The ID of the {@link MapService} that this set of {@link CatalogEntry} instances belong to. */
                    this.mapServiceId = null;
                    /** The collection of catalog entries belonging to the {@link MapService} that this is associated with. */
                    this.entries = null;
                    this.entries = [];
                }
                return LayerCatalogDetail;
            }());
            catalog.LayerCatalogDetail = LayerCatalogDetail;
        })(catalog = essentials.catalog || (essentials.catalog = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
        * String constants that represent visibility settings for preserving user settings
        */
        var RefreshVisibility = (function () {
            function RefreshVisibility() {
            }
            RefreshVisibility.DEFAULT = "Default";
            RefreshVisibility.SHOW = "Show";
            RefreshVisibility.HIDE = "Hide";
            return RefreshVisibility;
        }());
        essentials.RefreshVisibility = RefreshVisibility;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../../_Definitions/bluebird.d.ts"/>
/// <reference path="../../../../../_Definitions/jquery.d.ts"/>
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var utilities;
        (function (utilities) {
            /**
             * Static utility methods for printing.
             */
            var PrintUtilities = (function () {
                function PrintUtilities() {
                }
                /**
                 * Adjusts text symbols to bring the ArcGIS API for JavaScript's interpretation of them in line with the Geocortex Essentials print and export map rest endpoints'
                 * interpretation, which may differ since Essentials caters to both the Silverlight and HTML5 viewers which handle text symbols slightly differently.
                 * @param graphic The esri {@link esri.Graphic} object containing the text symbol.
                 * @layerId string The Id of the layer containing the text symbol.
                 * @returns A copy of the original text symbol with the adjustments applied or `null` if the supplied graphic does not contain a text symbol.
                 */
                PrintUtilities.adjustTextSymbol = function (graphic, layerId) {
                    if (graphic && graphic.symbol instanceof esri.symbol.TextSymbol) {
                        var syncTextSymbolParams = function (sourceSym, destSym) {
                            // Adjust font size - If a number, round it (in case font has been user scaled using edit toolbar) and then append "px" to it. else use the original string.
                            destSym.font.size = ((sourceSym.font.size != undefined) && (typeof sourceSym.font.size === "number"))
                                ? Math.round((sourceSym.font.size)) + "px" : sourceSym.font.size;
                            // Adjust x, y and offsets. Esri's toJson() will convert them to pt's. We want them in pixels.
                            destSym.x = sourceSym.x;
                            destSym.y = sourceSym.y;
                            destSym.xoffset = sourceSym.xoffset;
                            destSym.yoffset = sourceSym.yoffset;
                            // Esri's js api 3.8, for some reason will mess around with the angle and negate them too. Revert this.
                            destSym.align = sourceSym.align;
                            destSym.angle = sourceSym.angle;
                            // GVH-8075 There is a level of uncertainty when it comes to alpha RGB values since we don't know if they are expressed already
                            // as values in the range [0;255] or [0;1]. We want values in the former range and as such we perform a conversion when in the wrong format. 
                            if (destSym.color.hasOwnProperty("a")) {
                                destSym.color.a = sourceSym.color.a >= 0 && sourceSym.color.a <= 1 ? sourceSym.color.a * 255 : sourceSym.color.a;
                            }
                        };
                        // Create a copy of the graphic symbol. We dont want the map graphics to get altered
                        var textSymbolCopy = new esri.symbol.TextSymbol(graphic.symbol.toJson());
                        // GVH-8075 It looks like after having created a copy the color can be in the wrong format (Colors like 1 255 255 255 in graphic.symbol become 1 0 0 0).
                        // To be sure that we have the right color we copy the color information back again in the copied symbol. 
                        textSymbolCopy.color = new esri.Color({
                            r: graphic.symbol.color.r,
                            g: graphic.symbol.color.g,
                            b: graphic.symbol.color.b,
                            a: graphic.symbol.color.a
                        });
                        syncTextSymbolParams(graphic.symbol, textSymbolCopy);
                        if (textSymbolCopy.toJson && (typeof textSymbolCopy.toJson === "function")) {
                            var origToJson = textSymbolCopy.toJson;
                            // We overload the toJson method here as a safety precaution in case it's called later in the "encodeJson" call in PrintTemplate.ts. As of esri's js api 3.8, 
                            // they've made the following changes which have necessiated this extreme step:
                            // 1) The setSize() function of a textSymbol will convert the size string ("12px", "12pt") etc. to pixels and store it as a plain number. This will choke Essentials on print.
                            // 2) The toJson() function will convert xoffsets, yoffsets, x, y and size to "pt" and store them - again as numbers.
                            // 3) We cant simply set the size to a string here because the next time toJson() is called on the object, size will be reported as NaN (not a number).
                            // Essentials is expecting pixels for the offsets and a string for the size so we modify the toJson() call of the textSymbol copies (not the originals) and proceed as normal.
                            // Note: If you try to create a  symbol copy using the textSymbol constructor which accepts Json, it's fine since the class will convert all these back to pixels. 
                            textSymbolCopy.toJson = function () {
                                var result = origToJson.call(textSymbolCopy);
                                syncTextSymbolParams(textSymbolCopy, result);
                                return result;
                            };
                        }
                        var labelWidth = null;
                        var labelHeight = null;
                        // GVH-8075 The text that is rendered on the map is not just a simple text within a div, rather it is a SVG path.
                        // This is an important distinction to make since the rendered size of a SVG text might be different compared to the same text with
                        // the same font information within a div. This is especially important when it comes to cross browser compatibility.
                        // The placement of the text on the final printed document depends on the text rendered size (width and height) so that offsets
                        // and alignments are displayed properly. Also we need the layerId since we want to rendere invisible text within the same layer that this
                        // textSymbol belongs to just in case there's any styling that affects the final size. 
                        // (Note that the previous code that was dealing with the text as part as a div is still here just in case there's other code that relies on this logic).
                        if (layerId) {
                            // The logic we use here is the same we use in measurement utils to calculate the size of the text.
                            var drawingMeasurementLayer = document.getElementById(layerId + "_layer");
                            var textContainer = null;
                            textContainer = document.createElementNS("http://www.w3.org/2000/svg", "text");
                            textContainer.setAttributeNS(null, "font-size", textSymbolCopy.font.size);
                            textContainer.setAttributeNS(null, "font-family", textSymbolCopy.font.family);
                            textContainer.setAttributeNS(null, "visibility", "hidden");
                            textContainer.textContent = textSymbolCopy.text;
                            drawingMeasurementLayer.appendChild(textContainer);
                            var bbox = textContainer.getBBox();
                            // GVH-8127 There are potentially different ways of detecting the height and width of the text.
                            // Initially we were using container.clientHeight and container.clientWidht that was only working in Chrome.
                            // Using the bounding box looked like a good cross browser solution but only for the height since bbox.width would be non existent in IE.
                            // For the width the only cross browser solution looked like being using the getComputedTextLenght method on the container.
                            // This combination should get the proper size on Chrome, IE and Firefox.
                            labelHeight = (labelHeight === null) ? bbox.height : labelHeight;
                            labelWidth = (labelWidth === null) ? textContainer.getComputedTextLength() : labelWidth;
                            drawingMeasurementLayer.removeChild(textContainer);
                        }
                        else {
                            // Calculate actual rendered text size.
                            var page = document.body;
                            var container = document.createElement("div");
                            var attr = { fontFamily: textSymbolCopy.font.family, fontSize: textSymbolCopy.font.size, fontWeight: textSymbolCopy.font.weight, padding: "0", position: "absolute", lineHeight: "1", visibility: "hidden" };
                            for (var p in attr) {
                                container.style[p] = attr[p];
                            }
                            container.appendChild(document.createTextNode(textSymbolCopy.text));
                            page.appendChild(container);
                            labelWidth = container.clientWidth;
                            labelHeight = container.clientHeight;
                            page.removeChild(container);
                        }
                        // Note: Essentials handles xoffset and yoffset differently from esri's javascript api (as of v3.7). 
                        // 1) While esri's js api takes the literal meaning of xoffset and yoffset (as expected - along the x and y axes) essentials takes 
                        // the angle of the text into consideration and ALWAYS offsets perpendicular (in case of yoffset) or parallel to the line (in case of xoffset). 
                        // In view of this confusion, we strip away offsets as not supported and only use them internally, keeping in mind essentials' interpretation of them,
                        // EXCEPT if angle is 0 ie the text symbol is parallel to the x-axis. 
                        textSymbolCopy.xoffset = (textSymbolCopy.angle === 0) ? textSymbolCopy.xoffset : 0;
                        textSymbolCopy.yoffset = (textSymbolCopy.angle === 0) ? textSymbolCopy.yoffset : 0;
                        // Handle specialzed measurement module graphics
                        if ((graphic["measurementId"] || graphic["coordinateId"]) && graphic.attributes && graphic.attributes["numberOfLines"]) {
                            //Set alignment (xoffset) to the middle of the text. Apply a label adjustment factor to account for discrepencies in printed font size as of esri's jsapi v3.8
                            if (graphic["measurementId"]) {
                                textSymbolCopy.xoffset = -((labelWidth / 2) + (labelHeight / 4));
                            }
                            else {
                                textSymbolCopy.xoffset = -((labelWidth / 4) + (labelHeight / 2));
                            }
                            // To center the text when just composed of one line we just have to shift it of half its height.
                            textSymbolCopy.yoffset = graphic.attributes["numberOfLines"] && graphic.attributes["numberOfLines"] == 1 ? (labelHeight / 2) : textSymbolCopy.yoffset;
                            // Because of the logic used to implement multiline text in HighlightedLabelGraphic the single line of text that is part of a text on multiple lines
                            // has a different alignment compared to single line text. Here we fix the offset to properly center the text on the highlight.
                            // It is an hack-ish solution but it takes into account all the computations about sizes that we do already in measurement utils to properly organize and display text.
                            if (textSymbolCopy.verticalAlignment == "start" && graphic.attributes["numberOfLines"] && graphic.attributes["numberOfLines"] > 1) {
                                var numberOfLines = graphic.attributes["numberOfLines"];
                                // labelHeight * 0.5 is the padding as defined in measurement utils. We devide it by two since the padding include both top and bottom.
                                // labelHeight * numberOfLines is the height of the highlight behind the text. We devide it by two because we want to center the text.
                                textSymbolCopy.yoffset = textSymbolCopy.yoffset - ((labelHeight * 0.5) / 2) + ((labelHeight * numberOfLines) / 2);
                            }
                        }
                        else {
                            // The esri js api assumes the anchor pt. of the text as the bottom left (of the text block) by default. Essentials assumes top left of the text block.
                            // Hence the print looks different from the text on the map. Adjust for this discrepancy.
                            // As of esri's api v3.8, a verticalAlignment parameter has been introduced with possible values "baseline"/"top"/"middle"/"bottom". Default is "baseline"/"bottom"
                            switch (textSymbolCopy.verticalAlignment) {
                                case "top":
                                    // Do nothing. Essentials already assumes "top" by default.
                                    break;
                                case "middle":
                                    textSymbolCopy.yoffset += (labelHeight / 2);
                                    break;
                                default:
                                    textSymbolCopy.yoffset += labelHeight * 0.75;
                            }
                            // GVH-8075 and GVH-8127 added from the HighlightedLabelGraphic class when text is a single line.
                            // This is needed since IE ignores vertical alignment so we have to do it ourselves.
                            if (graphic.attributes && graphic.attributes["customVerticalAlignment"] && graphic.attributes["customVerticalAlignment"] === "middle") {
                                textSymbolCopy.xoffset = 0;
                                textSymbolCopy.yoffset = 0;
                                textSymbolCopy.yoffset += Math.ceil(labelHeight / 2);
                            }
                            // As of esri's api 3.8 a horizontalAlignment parameter has been introduced with possible values "left"/"right"/"center"/"justify". 
                            // From test runs, it seems to take precedence over the align parameter if/when it's present.
                            var alignParam = textSymbolCopy.horizontalAlignment || textSymbolCopy.align || null;
                            // Essentials does not support alignment of text labels. It always aligns at the start. Handle cases for middle and end.
                            if (alignParam) {
                                switch (alignParam) {
                                    case esri.symbol.TextSymbol.ALIGN_MIDDLE:
                                    case "center":
                                    case "justify":
                                        textSymbolCopy.xoffset -= Math.ceil(labelWidth / 2);
                                        if (!graphic["coordinateId"]) {
                                            textSymbolCopy.xoffset -= Math.ceil(labelHeight / 4);
                                        }
                                        break;
                                    case esri.symbol.TextSymbol.ALIGN_END:
                                    case "right":
                                        textSymbolCopy.xoffset -= labelWidth;
                                }
                            }
                        }
                        return textSymbolCopy;
                    }
                    return null;
                };
                /**
                 * Adjusts picture marker symbols to ensure that they are sent to the Essentials REST endpoint in the format in which it's expecting them.
                 * @param graphic The graphic for which to adjust the marker symbol for.
                 * @returns A copy of the original {@link esri.symbols.PictureMarkerSymbol} with the adjustments applied or null if the supplied graphic does not contain a text symbol.
                 */
                PrintUtilities.adjustPictureMarkerSymbol = function (graphic) {
                    if (graphic && graphic.symbol instanceof esri.symbol.PictureMarkerSymbol) {
                        var pictureMarkerSymbolCopy = new esri.symbol.PictureMarkerSymbol(graphic.symbol.toJson());
                        if (pictureMarkerSymbolCopy.toJson && (typeof pictureMarkerSymbolCopy.toJson === "function")) {
                            var origToJson = pictureMarkerSymbolCopy.toJson;
                            pictureMarkerSymbolCopy.toJson = function () {
                                var result = origToJson.call(pictureMarkerSymbolCopy);
                                var symbolWidth, symbolHeight;
                                result["color"] = [0, 0, 0, 255];
                                if (!isNaN(symbolWidth = parseInt(pictureMarkerSymbolCopy.width, 10)) && !isNaN(symbolHeight = parseInt(pictureMarkerSymbolCopy.height, 10))) {
                                    // When converting to json, esri's api converts pixels to points. Essentials expects pixels
                                    result.width = symbolWidth;
                                    result.height = symbolHeight;
                                    // Esri's api anchors the picture at the top right. Essentials anchors it in the middle
                                    result.xoffset = (!isNaN(parseInt(result.xoffset))) ? result.xoffset + (symbolWidth / 2) : (symbolWidth / 2);
                                    result.yoffset = (!isNaN(parseInt(result.yoffset))) ? result.yoffset - (symbolHeight / 2) : (symbolHeight / 2);
                                }
                                return result;
                            };
                        }
                        return pictureMarkerSymbolCopy;
                    }
                    return null;
                };
                /**
                 * Gets the base64 representation for an image.
                 * If the image is from another domain and CORS is not configured on the server or otherwise available, the utility cannot convert the image.
                 * If this is the case, an object will be returned with the reject. This object contains an error and the url which caused the failure.
                 * @param url The URL of the image to encode.
                 * @param outputFormat Optional: Either `"image/png"` or `"image/jpg"`. If not specified, defaults to `"image/png"`.
                 * @returns A Promise-like object which contains the base64 and which URL the data is for.
                 */
                PrintUtilities.getImageAsBase64 = function (url, outputFormat) {
                    if (outputFormat === void 0) { outputFormat = "image/png"; }
                    var promise = new dojo.Deferred();
                    var canvas = document.createElement("canvas");
                    var ctx = canvas.getContext("2d");
                    var img = new Image();
                    img.onload = function () {
                        canvas.height = img.height;
                        canvas.width = img.width;
                        ctx.drawImage(img, 0, 0);
                        // this will throw a security exception if CORS is not enabled on the server as the canvas becomes 'tainted'
                        try {
                            var dataURL = canvas.toDataURL(outputFormat);
                            promise.resolve({
                                url: url,
                                data: dataURL.replace(/^data:image\/(png|jpg);base64,/, "")
                            });
                        }
                        catch (e) {
                            // pass back a url so we know which image the request failed for
                            promise.reject({
                                "url": url,
                                "error": e
                            });
                        }
                    };
                    // catch other errors
                    img.onerror = function (ev) {
                        promise.reject({
                            "url": url,
                            "error": new Error("Failed to download image.")
                        });
                    };
                    // load the image
                    img.src = url;
                    return promise;
                };
                return PrintUtilities;
            }());
            utilities.PrintUtilities = PrintUtilities;
        })(utilities = essentials.utilities || (essentials.utilities = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/arcgis-js-api.d.ts" />
/// <reference path="EssentialsLayerInfo.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents information about an Essentials FeatureSet for json serialization purposes.
         */
        var EssentialsFeatureSet = (function () {
            function EssentialsFeatureSet() {
            }
            EssentialsFeatureSet.prototype.toJson = function () {
                return JSON.stringify(this);
            };
            return EssentialsFeatureSet;
        }());
        essentials.EssentialsFeatureSet = EssentialsFeatureSet;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/Chart.Rest.d.ts" />
/// <reference path="../../../../_Definitions/Charting.Infrastructure.d.ts" />
/// <reference path="Layer.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Client representation of a layer chart object attached to a layer.
         */
        var LayerChart = (function () {
            function LayerChart(restLayerChart, layer) {
                this.layer = null;
                // GVH-4178 Charting is an optional component so we need to make sure it is loaded before we instantiate any of its classes
                if (geocortex.charting && dojo.isObject(geocortex.charting.configuration.ChartDefinition)) {
                    if (restLayerChart) {
                        this.id = restLayerChart.id;
                        this.displayName = restLayerChart.displayName;
                        this.defaultChart = restLayerChart.defaultChart;
                        this.chartFeatureType = restLayerChart.chartFeatureType;
                        this.chartDefinition = new geocortex.charting.configuration.ChartDefinition(restLayerChart.chartDefinition);
                        this.chartDefinition.id = this.id;
                        this.chartDefinition.displayName = this.displayName;
                    }
                    if (layer) {
                        // Currently the chart field display names (aliases) are not exposed in the chart REST endpoint.
                        // So we need to lookup the aliases from the information available within the Layer.
                        this.layer = layer;
                        this._setFieldDisplayNames(this.chartDefinition, layer);
                    }
                }
            }
            LayerChart.prototype._setFieldDisplayNames = function (chartDefinition, layer) {
                if (!layer || !chartDefinition) {
                    return;
                }
                // Create a field/alias lookup
                var lookup = {};
                for (var i = 0; i < layer.fields.length; i++) {
                    var gcxField = layer.fields[i];
                    if (gcxField) {
                        lookup[gcxField.name] = gcxField.displayName;
                    }
                }
                // Process the chart's category field
                if (chartDefinition.category.field.sourceType == geocortex.charting.ChartFieldSourceType.Field) {
                    chartDefinition.category.field.displayName = lookup[chartDefinition.category.field.name] || chartDefinition.category.field.name;
                }
                // Process the chart series
                for (var j = 0; j < chartDefinition.series.length; j++) {
                    var series = chartDefinition.series[j];
                    if (series && series.field.sourceType == geocortex.charting.ChartFieldSourceType.Field) {
                        series.field.displayName = lookup[series.field.name] || series.field.name;
                    }
                }
            };
            return LayerChart;
        }());
        essentials.LayerChart = LayerChart;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/framework.d.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var FormButton = (function () {
            /**
             * Initializes a new instance of the {@link geocortex.forms.FormButton} class.
             * @class A button used when displaying a form.
             * @constructs
             * @param xmlNode Xml node containing the data item definition.
             * @param value The value of the button.
             * @param causesValidation Indicates whether the validation of the form should be triggered when the button is pressed.
             * @param causesValidation Indicates whether the button is the default button.
             */
            function FormButton(label, value, causesValidation, isDefault) {
                this.label = new Observable(label);
                this.value = new Observable(value);
                this.isDefault = new Observable(isDefault || false);
                this.causesValidation = new Observable(causesValidation);
            }
            return FormButton;
        }());
        forms.FormButton = FormButton;
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../forms.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            var validation;
            (function (validation) {
                var ValidationItem = (function () {
                    /**
                     * Initializes a new instance of the {@link geocortex.forms.items.validation.ValidationItem} class.
                     * @param xmlNode Xml node containing the form item definition.
                     */
                    function ValidationItem(xmlNode) {
                        this.message = geocortex.forms.getElementText(xmlNode, "Message");
                    }
                    ValidationItem.prototype.validate = function (value) {
                        throw new Error("Abstract method");
                    };
                    return ValidationItem;
                }());
                validation.ValidationItem = ValidationItem;
            })(validation = items.validation || (items.validation = {}));
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="FormItem.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            var CheckBoxFormItem = (function (_super) {
                __extends(CheckBoxFormItem, _super);
                /**
                 * Initializes a new instance of the {@link CheckBoxFormItem} class.
                 * @param xmlNode Xml node containing the form item definition.
                 * @param formDefinition The form definition that this form item belongs to.
                 */
                function CheckBoxFormItem(xmlNode, formDefinition) {
                    var _this = this;
                    _super.call(this, xmlNode, formDefinition);
                    this.formItemType = "CheckBoxFormItem";
                    if (xmlNode) {
                        this.text = new Observable(geocortex.forms.getElementText(xmlNode, "Text"));
                        this.checked = new Observable(geocortex.forms._parseBoolean(geocortex.forms.getElementText(xmlNode, "Checked")));
                        this.textLocation = new Observable(geocortex.forms.getElementText(xmlNode, "TextLocation"));
                    }
                    else {
                        this.text = new Observable("");
                        this.checked = new Observable(false);
                        this.textLocation = new Observable("Right");
                    }
                    this.checked.bind(null, function (result) { return _this._notifyResultChanged(); });
                }
                /**
                 * Gets the result of the form item.
                 */
                CheckBoxFormItem.prototype.getResult = function () {
                    return new geocortex.forms.items.FormItemResult(this.argumentName.get(), this.checked.get());
                };
                /**
                 * @private Renders the form item.
                 */
                CheckBoxFormItem.prototype._render = function () {
                    return geocortex.forms.renderFormItem(this);
                };
                return CheckBoxFormItem;
            }(items.AbstractFormItem));
            items.CheckBoxFormItem = CheckBoxFormItem;
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="ExternalActivityInfo.ts" />
var geocortex;
(function (geocortex) {
    var workflow;
    (function (workflow) {
        var WorkflowState = (function () {
            /**
             * Initializes a new instance of the {@link geocortex.workflow.WorkflowState} class.
             * @class
             * Represents the state of a workflow.
             * @constructs
             * @param instanceId The instance Id of the workflow.
             * @param status The status of the workflow.
             * @param pendingExternalActivities The pending external activities of the workflow.
             * @param outputs The outputs of the workflow.
             * @param workflowData The internal workflow data of the workflow.
             * @param instanceData The internal instance data of the workflow.
             * @private
             */
            function WorkflowState(instanceId, status, pendingExternalActivities, outputs, workflowData, instanceData) {
                this.instanceId = instanceId;
                this.status = status;
                this.pendingExternalActivities = pendingExternalActivities;
                this.outputs = outputs;
                this.workflowData = workflowData;
                this.instanceData = instanceData;
            }
            return WorkflowState;
        }());
        workflow.WorkflowState = WorkflowState;
    })(workflow = geocortex.workflow || (geocortex.workflow = {}));
})(geocortex || (geocortex = {}));
/// <reference path="DefaultActivityHandlers.ts" />
/// <reference path="ActivityDispatcher.ts" />
/// <reference path="ArgumentValueWrapper.ts" />
/// <reference path="WorkflowControllerProxy.ts" />
/// <reference path="WorkflowState.ts" />
/// <reference path="../essentials/Workflow.ts" />
var geocortex;
(function (geocortex) {
    var workflow;
    (function (workflow_1) {
        var ActivityContext = (function () {
            /**
             * Initializes a new instance of the {@link geocortex.workflow.ActivityContext} class.
             * @class
             * Represents the runtime state of a workflow.
             * @constructs
             * @param {Object} dispatcher The activity dispatcher.
             * @param {Number} pendingIndex The index of the pending {@link geocortex.workflow.ExternalActivityInfo}.
             * @param {geocortex.essentials.Workflow} workflow The {@link geocortex.essentials.Workflow}.
             * @param {Object} workflowState The internal workflow state object.
             */
            function ActivityContext(dispatcher, pendingIndex, workflow, workflowState) {
                /**
                 * Occurs when an activity is completed.
                 * @event
                 */
                this.activityComplete = null;
                this._dispatcher = dispatcher;
                this._pendingIndex = pendingIndex;
                this._workflow = workflow;
                this._workflowState = workflowState;
            }
            /**
             * Gets the activity dispatcher.
             * @return {Object}
             */
            ActivityContext.prototype.dispatcher = function () {
                return this._dispatcher;
            };
            /**
             * Gets the {@link geocortex.essentials.Workflow}.
             * @return {{@link geocortex.essentials.Workflow}}
             */
            ActivityContext.prototype.workflow = function () {
                return this._workflow;
            };
            /**
             * Gets the display name of the activity.
             * @return {String}
             */
            ActivityContext.prototype.getDisplayName = function () {
                return this._workflowState ? this._workflowState.pendingExternalActivities[this._pendingIndex].displayName : "";
            };
            /**
             * Gets a array of all input names in the activity.
             * @return {String[]}
             */
            ActivityContext.prototype.getInputNames = function () {
                var result = [];
                if (this._workflowState) {
                    var inputs = this._workflowState.pendingExternalActivities[this._pendingIndex].inputs;
                    for (var i = 0; i < inputs.length; i++) {
                        result.push(inputs[i].name);
                    }
                }
                return result;
            };
            /**
             * Gets a array of all input names in the activity that match the specified type.
             * @param typeName The type name.
             * @return {String[]}
             */
            ActivityContext.prototype.getInputNamesByType = function (typeName) {
                var result = [];
                if (this._workflowState) {
                    var inputs = this._workflowState.pendingExternalActivities[this._pendingIndex].inputs;
                    for (var i = 0; i < inputs.length; i++) {
                        if ((inputs[i].typeName).indexOf(typeName) === 0) {
                            result.push(inputs[i].name);
                        }
                    }
                }
                return result;
            };
            /**
             * Gets a array of all output names in the activity.
             * @param typeName The type name.
             * @return {String[]}
             */
            ActivityContext.prototype.getOutputNames = function () {
                var result = [];
                if (this._workflowState) {
                    var outputs = this._workflowState.pendingExternalActivities[this._pendingIndex].outputs;
                    for (var i = 0; i < outputs.length; i++) {
                        result.push(outputs[i].name);
                    }
                }
                return result;
            };
            /**
             * Gets a array of all output names in the activity that match the specified type.
             * @return {String[]}
             */
            ActivityContext.prototype.getOutputNamesByType = function (typeName) {
                var result = [];
                if (this._workflowState) {
                    var outputs = this._workflowState.pendingExternalActivities[this._pendingIndex].outputs;
                    for (var i = 0; i < outputs.length; i++) {
                        if (outputs[i].typeName.indexOf(typeName) === 0) {
                            result.push(outputs[i].name);
                        }
                    }
                }
                return result;
            };
            /**
             * Gets the Geocortex Essentials {@link geocortex.essentials.Site} associated with the running workflow.
             * @return {{@link geocortex.essentials.Site}}
             */
            ActivityContext.prototype.getSite = function () {
                if (this._workflow != null) {
                    return this._workflow.site;
                }
                return null;
            };
            /**
             * Gets the ESRI map associated with the running workflow.
             * @return {{@esri Map map}}
             */
            ActivityContext.prototype.getEsriMap = function () {
                if (this._workflow != null && this._workflow.site != null) {
                    return this._workflow.site.getMap();
                }
                return null;
            };
            /**
             * Gets the value of an input argument.
             * @param {String} name The name of the input.
             * @return {Object}
             */
            ActivityContext.prototype.getValue = function (name) {
                if (this._workflowState) {
                    var inputs = this._workflowState.pendingExternalActivities[this._pendingIndex].inputs;
                    for (var i = 0; i < inputs.length; i++) {
                        if (inputs[i].name == name) {
                            return inputs[i].value;
                        }
                    }
                }
                return null;
            };
            /**
             * Gets the value of an output argument.
             * @param {String} name The name of the output.
             * @return {Object}
             */
            ActivityContext.prototype.getOutputValue = function (name) {
                if (this._workflowState) {
                    var outputs = this._workflowState.pendingExternalActivities[this._pendingIndex].outputs;
                    for (var i = 0; i < outputs.length; i++) {
                        if (outputs[i].name == name) {
                            return outputs[i].value;
                        }
                    }
                }
                return null;
            };
            /**
             * Gets the json value of an input argument.
             * @param {String} name The name of the input.
             * @return {String}
             */
            ActivityContext.prototype.getJsonValue = function (name) {
                var inputs = this._workflowState.pendingExternalActivities[this._pendingIndex].inputs;
                for (var i = 0; i < inputs.length; i++) {
                    if (inputs[i].name == name) {
                        return JSON.stringify(inputs[i].value);
                    }
                }
                return null;
            };
            /**
             * Gets the json value of an output argument.
             * @param {String} name The name of the output.
             * @return {String}
             */
            ActivityContext.prototype.getOutputJsonValue = function (name) {
                if (this._workflowState) {
                    var outputs = this._workflowState.pendingExternalActivities[this._pendingIndex].outputs;
                    for (var i = 0; i < outputs.length; i++) {
                        if (outputs[i].name == name) {
                            var outVal = outputs[i].value;
                            if (outVal && outVal.length === 1) {
                                outVal = outVal[0];
                            }
                            return JSON.stringify(outVal);
                        }
                    }
                }
                return null;
            };
            /**
             * Sets the value of an output argument.
             * @param {String} name The name of the output.
             * @param {Object} value The value of the output.
             * @param {Boolean} allowInsert Indicate that new output arguments can be added.
             */
            ActivityContext.prototype.setValue = function (name, value, allowInsert) {
                if (!this._workflowState) {
                    return;
                }
                var wasFound = false;
                var outputs = this._workflowState.pendingExternalActivities[this._pendingIndex].outputs;
                var runtimeTypeName = this._getRuntimeType(value);
                // Unwrap ArgumentValueWrapper values
                if (value) {
                    if (value instanceof geocortex.workflow.ArgumentValueWrapper) {
                        runtimeTypeName = value.runtimeTypeName;
                        value = value.value;
                    }
                }
                for (var i = 0; i < outputs.length; i++) {
                    if (outputs[i].name == name) {
                        wasFound = true;
                        var argument = outputs[i];
                        if (argument) {
                            argument.value = value;
                            if (runtimeTypeName != null) {
                                argument.runtimeTypeName = runtimeTypeName;
                            }
                        }
                        break;
                    }
                }
                // If this is a new argument and inserts are allow, add the new argument to the collection
                if (!wasFound && allowInsert) {
                    // If the runtime type is not available, make it System.Object
                    if (!runtimeTypeName) {
                        runtimeTypeName = "System.Object";
                    }
                    // Create a new argument with sensible defaults
                    var argument = new geocortex.workflow.ArgumentInfo();
                    argument.isRequired = false;
                    argument.name = name;
                    argument.value = value;
                    argument.typeName = runtimeTypeName;
                    argument.runtimeTypeName = runtimeTypeName;
                    // Add the new argument to the collection
                    this._workflowState.pendingExternalActivities[this._pendingIndex].outputs.push(argument);
                }
            };
            /**
             * Gets the type name of the activity in context.
             * @return {String}
             */
            ActivityContext.prototype.getActivityTypeName = function () {
                var typeName = "";
                if (this._workflowState) {
                    typeName = this._workflowState.pendingExternalActivities[this._pendingIndex].typeName;
                    if (typeName) {
                        var genericTypeIndex = typeName.indexOf("`");
                        if (genericTypeIndex >= 0) {
                            typeName = typeName.substring(0, genericTypeIndex);
                        }
                    }
                }
                return typeName;
            };
            /**
             * Gets the external id of the activity in context.
             * @return {String}
             */
            ActivityContext.prototype.getActivityExternalId = function () {
                return this._workflowState ? this._workflowState.pendingExternalActivities[this._pendingIndex].externalId : "";
            };
            /**
             * Gets the type name of an input argument.
             * @param {String} name The name of the input argument.
             * @return {String}
             */
            ActivityContext.prototype.getInputArgumentTypeName = function (name) {
                if (this._workflowState) {
                    var inputs = this._workflowState.pendingExternalActivities[this._pendingIndex].inputs;
                    for (var i = 0; i < inputs.length; i++) {
                        if (inputs[i].name == name) {
                            return inputs[i].typeName;
                        }
                    }
                }
                return "";
            };
            /**
             * Gets the runtime type name of an input argument.
             * @param {String} name The name of the input argument.
             * @return {String}
             */
            ActivityContext.prototype.getInputArgumentRuntimeTypeName = function (name) {
                var inputs = this._workflowState.pendingExternalActivities[this._pendingIndex].inputs;
                for (var i = 0; i < inputs.length; i++) {
                    if (inputs[i].name == name) {
                        return inputs[i].runtimeTypeName;
                    }
                }
                return "";
            };
            /**
             * Completes the activity in context. Raises the activityComplete event.
             */
            ActivityContext.prototype.completeActivity = function () {
                if (this._workflowState) {
                    // Mark the activity as complete
                    var activity = this._workflowState.pendingExternalActivities[this._pendingIndex];
                    if (activity.isComplete) {
                        // Already complete
                        return;
                    }
                    var oThis = this;
                    // If the user used the special ExternalID "debugger" then launch the activity debugger.
                    if ((this.getActivityExternalId() == "debugger") || (activity && activity.debug)) {
                        geocortex.workflow.DefaultActivityHandlers.showDebug(this, false, function () {
                            oThis._completeActivityInternal();
                        });
                    }
                    else {
                        this._completeActivityInternal();
                    }
                }
            };
            /**
             * Aborts the activity in context.
             */
            ActivityContext.prototype.abortActivity = function () {
                if (this._workflowState) {
                    var activity = this._workflowState.pendingExternalActivities[this._pendingIndex];
                    activity.isAborted = true;
                    this._workflowState.status = "Aborted: " + activity.displayName;
                }
                if (this._dispatcher != null) {
                    this._dispatcher.activityAbort(this);
                }
            };
            /**
             * @private
             */
            ActivityContext.prototype._completeActivityInternal = function () {
                if (!this._workflowState) {
                    return;
                }
                // Mark the activity as complete
                var activity = this._workflowState.pendingExternalActivities[this._pendingIndex];
                activity.isComplete = true;
                // Let listeners know the activity is complete
                if (this._dispatcher != null) {
                    this._dispatcher.activityComplete(this);
                }
                // Clear all inputs, they don't need to go back
                activity.inputs = null;
                // Now we need to find out if we need to synchronize or we're ready to go back to the server
                var syncToken = this._workflowState.pendingExternalActivities[this._pendingIndex].syncToken;
                var ready = true; // Ready by default
                // Check if we need to synchronize
                if (syncToken != "") {
                    var pendingExternalActivities = this._workflowState.pendingExternalActivities;
                    // Loop through the pending external activities
                    for (var i = 0; i < pendingExternalActivities.length; i++) {
                        // If this pending external activity is part of the synchronization and it's not complete, then we're not ready
                        // TODO: use mutex if possible
                        if ((pendingExternalActivities[i].syncToken == syncToken) && (!pendingExternalActivities[i].isComplete)) {
                            ready = false;
                            break;
                        }
                    }
                }
                // If we're ready, go to the server
                if (ready) {
                    geocortex.workflow.WorkflowControllerProxy._executeWorkflow(this._workflow, this._dispatcher, this._workflowState, null, this);
                    // Raise activity complete event
                    if (dojo.isFunction(this.activityComplete)) {
                        this.activityComplete(this);
                    }
                }
            };
            /**
             * Return the runtimeType of the value. Note that this is the .NET type name, for deserialization on the server.
             * @private
             */
            ActivityContext.prototype._getRuntimeType = function (value) {
                var result = "System.Object";
                if (value) {
                    if (typeof (value.isInstanceOf) == "function") {
                        if (value.isInstanceOf(esri.geometry.Extent)) {
                            result = "ESRI.ArcGIS.Client.Geometry.Envelope";
                        }
                        else if (value.isInstanceOf(esri.geometry.Extent)) {
                            result = "ESRI.ArcGIS.Client.Geometry.Envelope";
                        }
                        else if (value.isInstanceOf(esri.geometry.Point)) {
                            result = "ESRI.ArcGIS.Client.Geometry.MapPoint";
                        }
                        else if (value.isInstanceOf(esri.geometry.Multipoint)) {
                            result = "ESRI.ArcGIS.Client.Geometry.MultiPoint";
                        }
                        else if (value.isInstanceOf(esri.geometry.Polygon)) {
                            result = "ESRI.ArcGIS.Client.Geometry.Polygon";
                        }
                        else if (value.isInstanceOf(esri.geometry.Polyline)) {
                            result = "ESRI.ArcGIS.Client.Geometry.Polyline";
                        }
                        else if (value.isInstanceOf(esri.geometry.Geometry)) {
                            result = "ESRI.ArcGIS.Client.Geometry.Geometry";
                        }
                        else if (value.isInstanceOf(esri.layers.LayerDataSource)) {
                            result = "ESRI.ArcGIS.Client.LayerDataSource";
                        }
                        else if (value.isInstanceOf(esri.layers.LayerMapSource)) {
                            result = "ESRI.ArcGIS.Client.LayerMapSource";
                        }
                    }
                    else if (typeof (value) == "string") {
                        result = "System.String";
                    }
                    else if (typeof (value) == "number") {
                        result = "System.Double";
                    }
                    else if (typeof (value) == "boolean") {
                        result = "System.Boolean";
                    }
                    else if (typeof (value) == "object") {
                        // Check if we're dealing with a Date object, if so, type it correctly
                        if (typeof (value.getMonth) == "function") {
                            result = "System.DateTime";
                        }
                        else {
                            result = "System.Object";
                        }
                    }
                }
                return result;
            };
            return ActivityContext;
        }());
        workflow_1.ActivityContext = ActivityContext;
    })(workflow = geocortex.workflow || (geocortex.workflow = {}));
})(geocortex || (geocortex = {}));
/// <reference path="ActivityContext.ts" />
/// <reference path="../essentials/Workflow.ts" />
/// <reference path="ActivityDispatcher.ts" />
/// <reference path="WorkflowState.ts" />
/// <reference path="../essentials.ts" />
/// <reference path="ArgumentInfo.ts" />
var geocortex;
(function (geocortex) {
    var workflow;
    (function (workflow_2) {
        var WorkflowControllerProxy;
        (function (WorkflowControllerProxy) {
            function startWorkflow(workflow, dispatcher, inArgs) {
                WorkflowControllerProxy._executeWorkflow(workflow, dispatcher, null, inArgs, null);
            }
            WorkflowControllerProxy.startWorkflow = startWorkflow;
            /** @private */
            function _executeWorkflow(workflow, dispatcher, workflowState, inArgs, activityContext) {
                var params = {};
                if (workflow == null) {
                    var error = new Error("workflow cannot be null");
                    if (dispatcher != null) {
                        dispatcher.handleError(error, null);
                        return;
                    }
                    else {
                        throw error;
                    }
                }
                var runUrl = workflow.url + "/run";
                if (inArgs) {
                    // Must process workflow inputs so that special non-serializable types
                    // such as ESRI geometry can be serialized properly.	
                    geocortex.workflow.WorkflowControllerProxy._preProcessArguments(inArgs);
                    params.inargs = JSON.stringify(inArgs);
                }
                if (workflowState != null) {
                    var pendingActivities = workflowState.pendingExternalActivities;
                    // Must process the outputs so that special non-serializable types
                    // such as ESRI geometry can be serialized properly.			        	
                    for (var i = 0; i < pendingActivities.length; i++) {
                        geocortex.workflow.WorkflowControllerProxy._preProcessArguments(pendingActivities[i].outputs);
                    }
                    params.workflow = JSON.stringify(workflowState);
                }
                params = geocortex.encodeJson(dojo.mixin({
                    f: "json"
                }, params));
                if (dispatcher != null) {
                    dispatcher.isBusy = true;
                }
                dispatcher.webRequestBegin(runUrl, workflow);
                geocortex.request({
                    url: runUrl,
                    content: params,
                    load: dojo.hitch(this, function (results) {
                        dispatcher.webRequestComplete(runUrl, workflow);
                        geocortex.workflow.WorkflowControllerProxy._processWorkflowResults(results, workflow, dispatcher);
                    }),
                    error: dojo.hitch(this, function (error) {
                        if (dispatcher != null) {
                            dispatcher.isBusy = false;
                            dispatcher.handleError(error, activityContext);
                        }
                        else {
                            throw error;
                        }
                    }),
                    callbackParamName: "CallBack"
                }, { usePost: true });
            }
            WorkflowControllerProxy._executeWorkflow = _executeWorkflow;
            /** @private */
            function _processWorkflowResults(results, workflow, dispatcher) {
                if (dispatcher != null) {
                    dispatcher.isBusy = false;
                }
                if (!results) {
                    return;
                }
                // Trap errors
                if (results.error) {
                    var error = new Error("Error running workflow: " + results.error.message);
                    geocortex.workflow.WorkflowControllerProxy._handleErrorInternal(dispatcher, error);
                    return;
                }
                var workflowState = new geocortex.workflow.WorkflowState(results.instanceId, results.status, geocortex.workflow.WorkflowControllerProxy._getExternalActivities(results.pendingExternalActivities), geocortex.workflow.WorkflowControllerProxy._getArguments(results.outputs), results.workflowData, results.instanceData);
                if (workflowState.status == "Completed") {
                    // Notify listener that the workflow is complete
                    if (dispatcher != null) {
                        dispatcher.workflowComplete(workflowState.outputs, workflow);
                    }
                }
                else if (workflowState.status == "WaitingForExternalActivities") {
                    var pendingActivities = workflowState.pendingExternalActivities;
                    // Make sure we have the workflow and pending activities
                    if (pendingActivities != null) {
                        // Loop through the pending activities
                        for (var i = 0; i < pendingActivities.length; i++) {
                            // Create the activityContext
                            var activityContext = new geocortex.workflow.ActivityContext(dispatcher, i, workflow, workflowState);
                            // Notify listener that we're about to begin handling the activity
                            if (dispatcher != null) {
                                dispatcher.activityBegin(activityContext);
                            }
                            var externalActivity = pendingActivities[i];
                            // Must process workflow inputs so that special types such as ESRI geometry 
                            // are deserialized properly.	
                            geocortex.workflow.WorkflowControllerProxy._preProcessArguments(externalActivity.inputs);
                            try {
                                // If the user used the special ExternalID "debugger" then launch the activity debugger.
                                if ((activityContext.getActivityExternalId() === "debugger") || (externalActivity && externalActivity.debug)) {
                                    geocortex.workflow.DefaultActivityHandlers.showDebug(activityContext, true, function () {
                                        geocortex.workflow.WorkflowControllerProxy._dispatch(activityContext);
                                    });
                                }
                                else {
                                    // Dispatch the activity
                                    geocortex.workflow.WorkflowControllerProxy._dispatch(activityContext);
                                }
                            }
                            catch (error) {
                                geocortex.workflow.WorkflowControllerProxy._handleErrorInternal(dispatcher, error, activityContext);
                            }
                        }
                    }
                }
            }
            WorkflowControllerProxy._processWorkflowResults = _processWorkflowResults;
            /** @private */
            function _handleErrorInternal(dispatcher, error, activityContext) {
                // Allow the dispatcher to handle errors
                if (dispatcher != null) {
                    dispatcher.handleError(error, activityContext || null);
                }
                else {
                    throw error;
                }
            }
            WorkflowControllerProxy._handleErrorInternal = _handleErrorInternal;
            /** @private */
            function _preProcessArguments(args) {
                if (args != null) {
                    for (var i = 0; i < args.length; i++) {
                        /** @private */
                        var extractTypeName = function (rawTypeName) {
                            var typeNameShort = rawTypeName;
                            var commaPos = rawTypeName.indexOf(",");
                            if (commaPos > 0) {
                                typeNameShort = rawTypeName.substring(0, commaPos);
                            }
                            return typeNameShort;
                        };
                        // Try to deserialize with the run time type name first.  
                        var runTimeTypeNameShort = extractTypeName(args[i].runtimeTypeName);
                        args[i].value = geocortex.workflow.WorkflowControllerProxy._getObjectFromJsonWithType(args[i].value, runTimeTypeNameShort);
                        // If that doesn't work, use the typename.
                        if (args[i].value == null) {
                            var typeNameShort = extractTypeName(args[i].typeName);
                            args[i].value = geocortex.workflow.WorkflowControllerProxy._getObjectFromJsonWithType(args[i].value, typeNameShort);
                        }
                    }
                }
            }
            WorkflowControllerProxy._preProcessArguments = _preProcessArguments;
            /** @private */
            function _getObjectFromJsonWithType(value, typeName) {
                var result = value;
                // Check if we can match the type
                switch (typeName) {
                    case "ESRI.ArcGIS.Client.Tasks.FeatureSet":
                        // Convert ESRI client FeatureSet
                        var jsonFs = value;
                        if (jsonFs != null) {
                            // GVH-6137, GVH-6127: Workflow activities fail when an empty FeatureSet is passed in from workflow.
                            // Make sure the FeatureSet has a proper features array.
                            var esriFs = new esri.tasks.FeatureSet(jsonFs);
                            esriFs.features = esriFs.features || [];
                            result = esriFs;
                        }
                        break;
                    case "ESRI.ArcGIS.Client.Geometry.Geometry":
                    case "ESRI.ArcGIS.Client.Geometry.Envelope":
                    case "ESRI.ArcGIS.Client.Geometry.MapPoint":
                    case "ESRI.ArcGIS.Client.Geometry.MultiPoint":
                    case "ESRI.ArcGIS.Client.Geometry.Polygon":
                    case "ESRI.ArcGIS.Client.Geometry.Polyline":
                        // Convert ESRI client geometries
                        var jsonGeom = value;
                        if (jsonGeom != null) {
                            var esriGeom = esri.geometry.fromJson(jsonGeom);
                            // The default value for the spatialReference is coming from Esri, with a value of 4326
                            // Even when we don't give it a spatial reference.
                            if (esriGeom && esriGeom.spatialReference && !jsonGeom.spatialReference) {
                                esriGeom.spatialReference = null;
                            }
                            result = esriGeom;
                        }
                        break;
                    case "ESRI.ArcGIS.Client.Geometry.SpatialReference":
                        // Convert ESRI client spatial reference
                        var jsonSr = value;
                        if (jsonSr != null) {
                            result = new esri.SpatialReference(jsonSr);
                        }
                        break;
                    case "ESRI.ArcGIS.Client.LayerMapSource":
                        var jsonMapSource = value;
                        if (jsonMapSource) {
                            result = new esri.layers.LayerMapSource(jsonMapSource);
                        }
                        break;
                    case "ESRI.ArcGIS.Client.LayerDataSource":
                        var jsonMapSource = value;
                        if (jsonMapSource) {
                            result = new esri.layers.LayerDataSource(jsonMapSource);
                        }
                        break;
                    case "ESRI.ArcGIS.Client.TimeExtent":
                        if (value instanceof Array) {
                            var timeValues = value;
                            if (timeValues.length > 0) {
                                var startTime = new Date(timeValues[0]);
                                var endTime = timeValues.length > 1 ? new Date(timeValues[1]) : startTime;
                                result = new esri.TimeExtent(startTime, endTime);
                            }
                        }
                        break;
                    case "System.DateTime":
                        if (value instanceof Date) {
                            result = "/Date(" + value.getTime() + ")/";
                        }
                        break;
                }
                return result;
            }
            WorkflowControllerProxy._getObjectFromJsonWithType = _getObjectFromJsonWithType;
            /** @private */
            function _getExternalActivities(restObject) {
                var activities = [];
                if (restObject != null) {
                    for (var i = 0; i < restObject.length; i++) {
                        var activityObject = restObject[i];
                        var activity = new geocortex.workflow.ExternalActivityInfo();
                        activity._configureObject(activityObject);
                        activities[i] = activity;
                    }
                }
                return activities;
            }
            WorkflowControllerProxy._getExternalActivities = _getExternalActivities;
            /** @private */
            function _getArguments(restObject) {
                var arguments = [];
                if (restObject != null) {
                    for (var i = 0; i < restObject.length; i++) {
                        var argumentObject = restObject[i];
                        var argument = new geocortex.workflow.ArgumentInfo();
                        argument._configureObject(argumentObject);
                        arguments[i] = argument;
                    }
                }
                return arguments;
            }
            WorkflowControllerProxy._getArguments = _getArguments;
            /** @private */
            function _dispatch(activityContext) {
                // Dispatch the activity to the external dispatcher
                if (activityContext.dispatcher() != null) {
                    activityContext.dispatcher().dispatch(activityContext);
                }
                else {
                    throw new Error("Unhandled activity: " + activityContext.getActivityTypeName());
                }
            }
            WorkflowControllerProxy._dispatch = _dispatch;
        })(WorkflowControllerProxy = workflow_2.WorkflowControllerProxy || (workflow_2.WorkflowControllerProxy = {}));
    })(workflow = geocortex.workflow || (geocortex.workflow = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../workflow/WorkflowControllerProxy.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        /**
         * Represents a data item to display in a collection use in a ComboBox for example.
         */
        var DataItem = (function () {
            /**
             * Initializes a new instance of the {@link DataItem} class.
             * @param display The text to display to the user.
             * @param value The value held by the DataItem.
             * @param typeName The type name of the value.
             */
            function DataItem(display, value, typeName) {
                this.display = display;
                this.value = value;
                this.typeName = typeName;
            }
            /**
             * Gets the value of the `dataItem`.
             */
            DataItem.prototype.getValue = function () {
                var value = this.value;
                // Try to convert value to object using type
                if (this.typeName != null) {
                    value = geocortex.workflow.WorkflowControllerProxy._getObjectFromJsonWithType(value, this.typeName);
                }
                if ((this.value != null) && (typeof (this.value.__type) != "undefined")) {
                    delete value.__type;
                }
                return value;
            };
            return DataItem;
        }());
        forms.DataItem = DataItem;
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../../_Definitions/framework.d.ts" />
/// <reference path="../DataItem.ts" />
/// <reference path="FormItem.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            function initDataItemsFormItem(formItem, xmlNode, formDefinition) {
                formItem.dataItems = new ObservableCollection();
                if (xmlNode) {
                    var dataItems = geocortex.forms.getElement(xmlNode, "DataItems");
                    if (dataItems != null) {
                        // Add all the data items
                        for (var i = 0; i < dataItems.childNodes.length; i++) {
                            var node = dataItems.childNodes[i];
                            var dataItem = new geocortex.forms.DataItem(geocortex.forms.getElementText(node, "Display"), geocortex.forms.getElementText(node, "Value"), geocortex.forms.getElementText(node, "TypeName"));
                            if (dataItem != null) {
                                formItem.dataItems.addItem(dataItem);
                            }
                        }
                    }
                }
                // Add input data items.
                if (formDefinition) {
                    var inputData = formDefinition.inputData;
                    if (inputData && inputData.hasOwnProperty(formItem.itemID.get())) {
                        var input = inputData[formItem.itemID.get()];
                        formItem.dataItems.addItems(input);
                    }
                }
            }
            items.initDataItemsFormItem = initDataItemsFormItem;
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="DataItemsFormItem.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            var QueryTaskRunner = (function () {
                /**
                 * Initializes a new instance of the {@link geocortex.forms.items.QueryTaskFormItem} class.
                 * @param xmlNode Xml node containing the form item definition.
                 * @param formDefinition The form definition that this form item belongs to.
                 */
                function QueryTaskRunner(formItem, xmlNode, formDefinition) {
                    /**
                     * An event that is raised when a value has been selected and queries that cascade off of this control should be executed.
                     * @type geocortex.framework.events.Event
                     */
                    this.cascadingEvent = new geocortex.framework.events.Event("cascadingEvent");
                    /**
                     * Indicates that a query is in progress or the form item is otherwise busy.
                     * @type Observable(Boolean)
                     */
                    this.isBusy = new Observable(false);
                    /** @private */
                    this._queryId = 0;
                    if (!formItem.queryTaskRunner) {
                        formItem.queryTaskRunner = this;
                    }
                    if (formItem.queryTaskRunner !== this) {
                        throw new Error("FormItem in the constructor must be the QueryTaskFormItem containing the QueryTaskRunner");
                    }
                    this.formItem = formItem;
                    if (xmlNode) {
                        this.queryDisplayOutputField = new Observable(geocortex.forms.getElementText(xmlNode, "QueryDisplayOutputField"));
                        this.queryValueOutputField = new Observable(geocortex.forms.getElementText(xmlNode, "QueryValueOutputField"));
                        this.queryServiceUrl = new Observable(geocortex.forms.getElementText(xmlNode, "QueryServiceUrl"));
                        this.queryWhereClause = new Observable(geocortex.forms.getElementText(xmlNode, "QueryWhereClause"));
                        this.filterByInputGeometry = new Observable(geocortex.forms._parseBoolean(geocortex.forms.getElementText(xmlNode, "FilterByInputGeometry")));
                        this.queryCascadingID = new Observable(geocortex.forms.getElementText(xmlNode, "QueryCascadingID"));
                        this.proxyUrl = new Observable(geocortex.forms.getElementText(xmlNode, "ProxyUrl"));
                        this.token = new Observable(geocortex.forms.getElementText(xmlNode, "Token"));
                        if (geocortex.forms.getElementText(xmlNode, "LayerSourceJson")) {
                            this.layerSourceJson = new Observable(geocortex.forms.getElementText(xmlNode, "LayerSourceJson"));
                        }
                    }
                    else {
                        this.queryDisplayOutputField = new Observable(null);
                        this.queryValueOutputField = new Observable(null);
                        this.queryServiceUrl = new Observable(null);
                        this.queryWhereClause = new Observable(null);
                        this.filterByInputGeometry = new Observable(false);
                        this.queryCascadingID = new Observable(null);
                        this.proxyUrl = new Observable(null);
                        this.token = new Observable(null);
                    }
                    // Map this thing in the form definition so cascading relationships can be resolved.
                    if (formItem.formDefinition) {
                        formItem.formDefinition.map(formItem);
                    }
                    var cascadingId = this.queryCascadingID.get();
                    // If we have a cascading relationship, add a cascade handler to the form definition so that we are
                    // updated when the parent selection changes.
                    if (cascadingId != null && cascadingId != "") {
                        formItem.formDefinition.addCascading(cascadingId, formItem, function (value) {
                            if (value) {
                                this.queryTaskRunner.performQuery(value);
                            }
                            else {
                                this.clearDataItems();
                                this.triggerCascading(null);
                            }
                        });
                    }
                    if (!formItem.isBusy) {
                        formItem.isBusy = new Observable(false);
                    }
                    formItem.isBusy.sync(this.isBusy);
                }
                /**
                 * @private Notifies any listeners that a value has been selected and they should cascade.
                 */
                QueryTaskRunner.prototype.triggerCascading = function (selectedValue) {
                    this.cascadingEvent.publish(selectedValue);
                };
                /**
                 * @private
                 * Gets a value indicating whether this form item will actually be performing querying based on its configuration.
                 */
                QueryTaskRunner.prototype.isQueryable = function () {
                    if ((this.queryServiceUrl.get() == null) || (dojo.trim(this.queryServiceUrl.get()) === "") ||
                        (this.queryWhereClause.get() == null) || (dojo.trim(this.queryWhereClause.get()) === "") ||
                        (this.queryDisplayOutputField.get() == null) || (dojo.trim(this.queryDisplayOutputField.get()) === "")) {
                        return false;
                    }
                    return true;
                };
                /**
                 * @private Perform the query task to load items.
                 */
                QueryTaskRunner.prototype.performQuery = function (value, cascade) {
                    var _this = this;
                    // If we don't have the required information to perform a query, return
                    if (!this.isQueryable()) {
                        return;
                    }
                    this.formItem.dataItems.clear();
                    if (value == null) {
                        return;
                    }
                    var geometry = null;
                    // Check if we should filter by geometry and if geometry is available
                    if (this.filterByInputGeometry.get() && (this.formItem.formDefinition != null) && (this.formItem.formDefinition.inputGeometry)) {
                        geometry = this.formItem.formDefinition.inputGeometry;
                    }
                    var queryService = this.queryServiceUrl.get();
                    if (this.proxyUrl.get() && esri.getProxyRule(queryService) === undefined) {
                        esri.addProxyRule({
                            proxyUrl: this.proxyUrl.get(),
                            urlPrefix: queryService
                        });
                    }
                    if (this.token && this.token.get()) {
                        queryService += (dojo.indexOf(queryService, "?") >= 0 ? "&" : "?") + "token=" + this.token.get();
                    }
                    var queryTask;
                    if (this.layerSourceJson && this.layerSourceJson.get()) {
                        var layerSourceJsonObj = geocortex.essentials.RestHelper.getJsonObjectFromJsonString(this.layerSourceJson.get());
                        var opts = {
                            source: geocortex.essentials.RestHelper.getLayerSourceFromJsonObject(layerSourceJsonObj)
                        };
                        queryTask = new esri.tasks.QueryTask(queryService, opts);
                    }
                    else {
                        queryTask = new esri.tasks.QueryTask(queryService);
                    }
                    // Build query filter
                    var query = new esri.tasks.Query();
                    query.returnGeometry = false;
                    query.geometry = geometry;
                    query.outFields = [];
                    query.where = this._getWhereClause(value);
                    // Add display field
                    query.outFields.push(this.queryDisplayOutputField.get());
                    // Check if we add the value field
                    if ((this.queryValueOutputField.get() != null) &&
                        (dojo.trim(this.queryValueOutputField.get()) != "") &&
                        (this.queryValueOutputField.get() != this.queryDisplayOutputField.get())) {
                        query.outFields.push(this.queryValueOutputField.get());
                    }
                    // GVH-5315 and GE-7073 Checks for a "." in the outFields because that's a sign of a JoinField which is not compatible with returnDistinctValues
                    var hasJoinField = query.outFields.every(function (x) {
                        return x.indexOf(".") !== -1;
                    });
                    if (!hasJoinField) {
                        query.returnDistinctValues = true; //Supported on ArcGIS Server 10.1 and above, so client-side sorting is still necessary
                    }
                    this.isBusy.set(true);
                    ++this._queryId;
                    // Using a closure here allows us to take a snapshot of queryId at the time the query is dispatched. When the query returns, we
                    // can compare the ids and detect if another query has been launched since, in which case we will discard the results.
                    (function () {
                        var queryId = _this._queryId;
                        queryTask.execute(query, function (featureSet) {
                            var sortedList = [];
                            // Oops - we returned from the query, but queries have been launched since. Abort!
                            if (queryId != _this._queryId) {
                                return;
                            }
                            // Loop through the results to add to the select
                            for (var i = 0; i < featureSet.features.length; ++i) {
                                var fa = featureSet.features[i].attributes;
                                var display = null;
                                if (_this.queryDisplayOutputField.get() != null) {
                                    display = fa[_this.queryDisplayOutputField.get().trim()];
                                }
                                var value;
                                // Check if we have the value field
                                if ((_this.queryValueOutputField.get() != null) &&
                                    (dojo.trim(_this.queryValueOutputField.get()) != "") &&
                                    (_this.queryValueOutputField.get() != _this.queryDisplayOutputField.get())) {
                                    value = fa[_this.queryValueOutputField.get().trim()]; // Fix for GVH-5981
                                }
                                else {
                                    value = display;
                                }
                                sortedList.push(new geocortex.forms.DataItem(display, value, null));
                            }
                            // Sort.
                            sortedList.sort(function (a, b) {
                                return (a.display < b.display) ? -1 : 1;
                            });
                            if (_this.formatCallback) {
                                // Use the supplied format callback to format items. This is done _after_ sorting, since
                                // we don't want to sort dates and numbers lexicographically by the formatted value.
                                var type = geocortex.essentials.EsriFieldTypes.esriFieldTypeString;
                                if (featureSet.fields) {
                                    var field = featureSet.fields.filter(function (f) { return f.name === _this.queryDisplayOutputField.get(); })[0];
                                    if (field) {
                                        type = field.type;
                                    }
                                }
                                sortedList.forEach(function (dataItem) {
                                    dataItem.display = _this.formatCallback(dataItem.display, type);
                                });
                            }
                            if (_this.formItem.prepareForResults) {
                                _this.formItem.prepareForResults();
                            }
                            // In order to remove all duplicates from the list, we'll use an object (backed by a hash table) to store uniques and
                            // reduce complexity from O(n^2) to O(n log n).
                            function hashItem(item) {
                                return item.display + "-" + item.value;
                            }
                            var uniques = {};
                            var list = [];
                            for (var itemIx = 0; itemIx < sortedList.length; ++itemIx) {
                                var item = sortedList[itemIx];
                                var hash = hashItem(item);
                                // Duplicate? skip it.
                                if (uniques.hasOwnProperty(hash)) {
                                    continue;
                                }
                                // Stash it in our map and add it to the result list.
                                uniques[hash] = true;
                                list.push(item);
                            }
                            // Add the sorted items to the data item collection in one go.
                            _this.formItem.dataItems.addItems(list);
                            _this.isBusy.set(false);
                            var firstValue = null;
                            // Select the first item.
                            if (_this.formItem.dataItems.getLength() > 0) {
                                firstValue = _this.formItem.dataItems.getAt(0);
                            }
                            // Trigger the cascading event.
                            if (cascade === true) {
                                _this.triggerCascading(firstValue == null ? null : firstValue.value);
                            }
                            if (_this.formItem.handleResultsComplete) {
                                _this.formItem.handleResultsComplete();
                            }
                        });
                    })();
                };
                /**
                 * QueryTask supports the following token replacement schemes:
                 * {0} will be replaced by the previous value in the cascade, escaped
                 * {1:FormItem} will be replaced by the value in the form item with the matching id, unescaped
                 * {1:FormItem:SQL} will be replaced by the value in the form item with the matching id, escaped
                 * {1:FormItem:F[N]} will be replaced by the value as a number rounded to [N] decimal places
                 */
                QueryTaskRunner.prototype._getWhereClause = function (value) {
                    var _this = this;
                    var where = this.queryWhereClause.get();
                    where = where.replace(/{1:([a-zA-Z0-9]+)(:[a-zA-Z0-9]+)?}/g, function (match, formItemId, formatting) {
                        var formItem = _this.formItem.formDefinition.getFormItemById(formItemId);
                        if (!formItem) {
                            // The where clause is going to fail anyways so we might as well make it obvious.
                            return "{unknown form item " + formItemId + "}";
                        }
                        var value = formItem.getResult().value;
                        if (!formatting) {
                            return value;
                        }
                        if (formatting === ":SQL") {
                            return _this._escapeForWhere(value);
                        }
                        var regexpResults = /:[fF](\d+)/.exec(formatting);
                        if (regexpResults) {
                            return parseFloat(value).toFixed(+regexpResults[1]);
                        }
                        // GVS technically supports all formatters from http://msdn.microsoft.com/en-us/library/dwhawy9k.aspx as an implementation
                        // detail but they aren't documented and probably aren't useful.
                        return "{unknown format clause " + formatting + "}";
                    });
                    where = where.format(this._escapeForWhere(value));
                    return where;
                };
                /**
                 * Escape the given value so it can be placed in a where clause as a string.
                 */
                QueryTaskRunner.prototype._escapeForWhere = function (value) {
                    if (value && typeof value === "number") {
                        value = value.toString();
                    }
                    return (value || "").replace(/\'/g, "''");
                };
                return QueryTaskRunner;
            }());
            items.QueryTaskRunner = QueryTaskRunner;
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="QueryTaskFormItem.ts" />
/// <reference path="FormItem.ts" />
/// <reference path="LabelContainer.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            var ComboBoxFormItem = (function (_super) {
                __extends(ComboBoxFormItem, _super);
                /**
                 * Initializes a new instance of the {@link ComboBoxFormItem} class.
                 * @param xmlNode Xml node containing the form item definition.
                 * @param formDefinition The form definition that this form item belongs to.
                 */
                function ComboBoxFormItem(xmlNode, formDefinition) {
                    var _this = this;
                    _super.call(this, xmlNode, formDefinition);
                    /**
                     * Specifies whether or not we've set a default value so we don't do it again.
                     * @private
                     */
                    this._defaultSet = false;
                    /**
                     * The text that will be shown as the first item of ComboBox.
                     * @type Observable(String)
                     */
                    this.selectText = new Observable();
                    /**
                     * The selected object value
                     * @type Observable(string)
                     */
                    this.selected = new Observable();
                    /**
                     * The value that should be selected by default as defined in the form definition.
                     * @type Object
                     */
                    this.defaultSelectedValue = new Observable();
                    this.isBusy = new Observable(false);
                    this.formItemType = "ComboBoxFormItem";
                    items.initLabelContainer(this, xmlNode, formDefinition);
                    items.initDataItemsFormItem(this, xmlNode, formDefinition);
                    this.queryTaskRunner = new items.QueryTaskRunner(this, xmlNode, formDefinition);
                    if (xmlNode) {
                        var selectTextString = geocortex.forms.getElementText(xmlNode, "SelectText");
                        if (selectTextString) {
                            this.selectText.set(selectTextString);
                        }
                        var defaultSelectedValueString = geocortex.forms.getElementText(xmlNode, "SelectedValue");
                        if (defaultSelectedValueString) {
                            this.defaultSelectedValue.set(defaultSelectedValueString);
                        }
                    }
                    this.selected.bind(null, function (result) { return _this._notifyResultChanged(); });
                    this.prepareForResults();
                    // If this combobox is not doing a query, we can set the default value now
                    if (!this.queryTaskRunner.isQueryable()) {
                        this._selectDefaultValue();
                    }
                    var cascadingId = this.queryTaskRunner.queryCascadingID.get();
                    // If this control is not part of a cascading relationship, fire off the initial query.
                    if (cascadingId == null || cascadingId == "") {
                        this.queryTaskRunner.performQuery("");
                    }
                }
                /**
                 * Clears the data items. This includes the currently-selected (default) item.
                 */
                ComboBoxFormItem.prototype.clearDataItems = function () {
                    this.dataItems.clear();
                    this.selected.set(null);
                    this._defaultSet = false;
                };
                /** @private */
                ComboBoxFormItem.prototype._hasRealDataItem = function () {
                    return this.selected.get() != null;
                };
                /**
                 * @private Notifies any listeners that a value has been selected and they should cascade.
                 */
                ComboBoxFormItem.prototype.triggerCascading = function (value) {
                    // Clear cascaded fields.
                    if (this.selected.get() == null || !value) {
                        this.queryTaskRunner.cascadingEvent.publish(null);
                    }
                    var item = this.selected.get();
                    if (item === null) {
                        item = value;
                    }
                    if (item === null || item === undefined) {
                        this.queryTaskRunner.cascadingEvent.publish(null);
                    }
                    else {
                        this.queryTaskRunner.cascadingEvent.publish(item.value);
                    }
                };
                ComboBoxFormItem.prototype.prepareForResults = function () {
                    if (this.selectText.get()) {
                        var firstItemText = this.selectText.get();
                        var firstItem = new geocortex.forms.DataItem(firstItemText, "", null);
                        this.dataItems.insertItem(0, firstItem);
                    }
                };
                ComboBoxFormItem.prototype.handleResultsComplete = function () {
                    // Set the default value if we haven't already
                    if (!this._defaultSet) {
                        this._selectDefaultValue();
                        // When we select a default value we need to trigger the cascading query
                        if (this.selected.get() != null) {
                            this._defaultSet = true;
                            this.triggerCascading(this.selected.get());
                        }
                    }
                };
                /**
                 * Gets the result of the form item.
                 * @return {{@link geocortex.forms.items.FormItemResult}[]}
                 */
                ComboBoxFormItem.prototype.getResult = function () {
                    if (this.selected.get() == null) {
                        return new geocortex.forms.items.FormItemResult(this.argumentName.get(), null);
                    }
                    var item = this.selected.get();
                    if (!item) {
                        return new geocortex.forms.items.FormItemResult(this.argumentName.get(), null);
                    }
                    return new geocortex.forms.items.FormItemResult(this.argumentName.get(), item.getValue());
                };
                /**
                 * @private Add an option to the select item.
                 */
                ComboBoxFormItem.prototype._addOption = function (label, value) {
                    this.dataItems.addItem(new geocortex.forms.DataItem(label, value));
                };
                /**
                * @private Select the default value if it exists
                */
                ComboBoxFormItem.prototype._selectDefaultValue = function () {
                    var selectedItemArray = dojo.filter(this.dataItems.getItems(), dojo.hitch(this, function (d) {
                        if (this.defaultSelectedValue.get()) {
                            return d.value + "" === this.defaultSelectedValue.get() + "";
                        }
                        return false;
                    }));
                    if (selectedItemArray.length > 0) {
                        this.selected.set(selectedItemArray[0]);
                    }
                    else if (this.dataItems.length() > 0) {
                        this.selected.set(this.dataItems.getAt(0));
                    }
                };
                /**
                 * @private Renders the form item.
                 */
                ComboBoxFormItem.prototype._render = function () {
                    return geocortex.forms.renderFormItem(this);
                };
                return ComboBoxFormItem;
            }(items.AbstractFormItem));
            items.ComboBoxFormItem = ComboBoxFormItem;
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="LabelContainer.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            var TimePickerFormItem = (function (_super) {
                __extends(TimePickerFormItem, _super);
                /**
                 * Initializes a new instance of the {@link geocortex.forms.items.TimePickerFormItem} class.
                 * @param xmlNode Xml node containing the form item definition.
                 * @param formDefinition The form definition that this form item belongs to.
                 */
                function TimePickerFormItem(xmlNode, formDefinition) {
                    var _this = this;
                    _super.call(this, xmlNode, formDefinition);
                    /**
                     * Gets or sets the initial time of the time picker.
                     * @type Observable(Date)
                     */
                    this.initialTime = new Observable();
                    /**
                     * Gets or sets a value indicating whether the user can clear the control's value.
                     */
                    this.nullable = new Observable(false);
                    /**
                     * Gets or sets the time format (short or long).
                     * @type Observable(String)
                     */
                    this.timeFormat = new Observable();
                    /**
                     * If true, will display time in the jQuery time picker as a highlighted info message (if the jQuery time picker is active).
                     */
                    this.jQueryPickerTimeAsInfoMsg = new Observable(false);
                    this.formItemType = "TimePickerFormItem";
                    items.initLabelContainer(this, xmlNode, formDefinition);
                    if (xmlNode) {
                        // Make the control nullable, unless there's a "Required" validator attached.
                        var nullable = true;
                        var validationItems = xmlNode.getElementsByTagNameNS ? xmlNode.getElementsByTagNameNS("http://schemas.datacontract.org/2004/07/Geocortex.Forms.Client.Items.Validation", "ValidationItem") : xmlNode.getElementsByTagName("ValidationItem");
                        for (var i = 0; i < validationItems.length; i++) {
                            var type = validationItems[i].getAttributeNS("http://www.w3.org/2001/XMLSchema-instance", "type");
                            if (type && type.indexOf("RequiredValidationItem") >= 0) {
                                nullable = false;
                                break;
                            }
                        }
                        this.nullable.set(nullable);
                        var infoMsg = geocortex.forms.getElementText(xmlNode, "jQueryPickerTimeAsInfoMsg");
                        if (infoMsg) {
                            this.jQueryPickerTimeAsInfoMsg.set(infoMsg === "true");
                        }
                        var initializeWithCurrentTime = true;
                        var initTimeString = geocortex.forms.getElementText(xmlNode, "InitialTime");
                        if (geocortex.forms.getElementText(xmlNode, "InitializeWithCurrentTime") === null) {
                            // Preserve old behaviour for backward compatibility. A null initial value meant "use the current time".
                            initializeWithCurrentTime = !initTimeString;
                        }
                        else {
                            // New behaviour. Initial value can be the current time, null, or a specific time.
                            initializeWithCurrentTime = geocortex.forms.getElementText(xmlNode, "InitializeWithCurrentTime") === "true";
                        }
                        if (initializeWithCurrentTime) {
                            this.initialTime.set(new Date());
                        }
                        else if (initTimeString) {
                            if (!geocortex.framework.utils.DateUtils.containsTimezone(initTimeString)) {
                                initTimeString += geocortex.framework.utils.DateUtils.getTimezoneString();
                            }
                            this.initialTime.set(Date.fromISO(initTimeString));
                            this.timeFormat.set(geocortex.forms.getElementText(xmlNode, "TimeFormat"));
                        }
                        else {
                            this.initialTime.set(null);
                        }
                    }
                    else {
                        this.timeFormat.set("LongTime");
                        this.initialTime.set(new Date());
                    }
                    this.time = new Observable(this.initialTime.get());
                    this.time.bind(null, function (result) { return _this._notifyResultChanged(); });
                }
                /**
                 * Gets the result of the form item.
                 * @return {{@link geocortex.forms.items.FormItemResult}[]}
                 */
                TimePickerFormItem.prototype.getResult = function () {
                    var value = this.time.get();
                    // Native time pickers give us string values (on iOS at least) so we need to turn em back into date values
                    // that .NET serialization likes.
                    if (value) {
                        value = new Date(value.toString());
                        value = "/Date({0})/".format(value.getTime());
                    }
                    return new geocortex.forms.items.FormItemResult(this.argumentName.get(), value);
                };
                /**
                 * @private Renders the form item.
                 */
                TimePickerFormItem.prototype._render = function () {
                    return geocortex.forms.renderFormItem(this);
                };
                return TimePickerFormItem;
            }(items.AbstractFormItem));
            items.TimePickerFormItem = TimePickerFormItem;
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="TimePickerFormItem.ts" />
/// <reference path="LabelContainer.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            var DatePickerFormItem = (function (_super) {
                __extends(DatePickerFormItem, _super);
                /**
                 * Initializes a new instance of the {@link DatePickerFormItem} class.
                 * @param xmlNode Xml node containing the form item definition.
                 * @param formDefinition The form definition that this form item belongs to.
                 */
                function DatePickerFormItem(xmlNode, formDefinition) {
                    var _this = this;
                    _super.call(this, xmlNode, formDefinition);
                    /**
                     * Gets or sets a value indicating whether the user can clear the control's value.
                     */
                    this.nullable = new Observable(false);
                    this.formItemType = "DatePickerFormItem";
                    items.initLabelContainer(this, xmlNode, formDefinition);
                    var initializeWithCurrentDate = true;
                    if (xmlNode) {
                        // Make the control nullable, unless there's a "Required" validator attached.
                        var nullable = true;
                        var validationItems = xmlNode.getElementsByTagNameNS ? xmlNode.getElementsByTagNameNS("http://schemas.datacontract.org/2004/07/Geocortex.Forms.Client.Items.Validation", "ValidationItem") : xmlNode.getElementsByTagName("ValidationItem");
                        for (var i = 0; i < validationItems.length; i++) {
                            var type = validationItems[i].getAttributeNS("http://www.w3.org/2001/XMLSchema-instance", "type");
                            if (type && type.indexOf("RequiredValidationItem") >= 0) {
                                nullable = false;
                                break;
                            }
                        }
                        this.nullable.set(nullable);
                        this.dateFormat = new Observable(geocortex.forms.getElementText(xmlNode, "DateFormat"));
                        this.includeTimePicker = new Observable(geocortex.forms.getElementText(xmlNode, "IncludeTimePicker") === "true");
                        var initialTime = null;
                        if (this.includeTimePicker.get()) {
                            this.timePickerItem = new items.TimePickerFormItem(geocortex.forms.getElement(xmlNode, "TimePickerItem"));
                            initialTime = this.timePickerItem.initialTime.get();
                        }
                        var initDateString = geocortex.forms.getElementText(xmlNode, "InitialDate");
                        if (geocortex.forms.getElementText(xmlNode, "InitializeWithCurrentDate") === null) {
                            // Preserve old behaviour for backward compatibility. A null initial value meant "use the current date".
                            initializeWithCurrentDate = !initDateString;
                        }
                        else {
                            // New behaviour. Initial value can be the current date, null, or a specific date.
                            initializeWithCurrentDate = geocortex.forms.getElementText(xmlNode, "InitializeWithCurrentDate") === "true";
                        }
                        if (initDateString) {
                            // force time to be interpreted as local
                            if (geocortex.framework.utils.DateUtils.containsTimezone(initDateString)) {
                                var timeZoneIx = Math.max(initDateString.lastIndexOf("Z"), initDateString.lastIndexOf("+"), initDateString.lastIndexOf("-"));
                                if (timeZoneIx > 0) {
                                    initDateString = initDateString.substring(0, timeZoneIx);
                                }
                            }
                            initDateString += geocortex.framework.utils.DateUtils.getTimezoneString();
                        }
                        var initialDate = null;
                        if (initializeWithCurrentDate || initDateString) {
                            initialDate = new Date(initDateString);
                        }
                        if (initialDate && !isNaN(initialDate.getTime())) {
                            if (initialDate.getTimezoneOffset() != geocortex.framework.utils.DateUtils.getTimezoneOffset()) {
                                // Even though we just explicitly set the local timezone before we parsed it, this date object might still be in 
                                // a different timezone because the date is in a different daylight sayings state.  We'll nudge the time so it displays
                                // the same numbers even though it's in a different timezone.  This is the kind of lying that generally comes back
                                // to haunt you later.
                                initialDate.setTime(initialDate.getTime() - (geocortex.framework.utils.DateUtils.getTimezoneOffset() - initialDate.getTimezoneOffset()) * 60000);
                            }
                            if (initialTime) {
                                initialDate.setHours(initialTime.getHours());
                                initialDate.setMinutes(initialTime.getMinutes());
                                initialDate.setSeconds(initialTime.getSeconds());
                            }
                            this.initialDate = new Observable(initialDate);
                        }
                        else {
                            this.initialDate = new Observable(initialTime);
                        }
                    }
                    else {
                        // GVH 3780 the default should be consistant with how datetimes are displayed in the feature details
                        this.dateFormat = new Observable();
                        this.initialDate = new Observable(null);
                        this.includeTimePicker = new Observable(false);
                    }
                    if (initializeWithCurrentDate) {
                        var defaultDate = new Date();
                        if (!this.includeTimePicker.get()) {
                            defaultDate.setHours(0);
                            defaultDate.setMinutes(0);
                            defaultDate.setSeconds(0);
                        }
                        this.date = new Observable(defaultDate);
                        this.initialDate.set(defaultDate);
                    }
                    else {
                        this.date = new Observable(this.initialDate.get());
                    }
                    this.date.bind(null, function (result) { return _this._notifyResultChanged(); });
                }
                /**
                 * Gets the result of the form item.
                 * @return {{@link geocortex.forms.items.FormItemResult}[]}
                 */
                DatePickerFormItem.prototype.getResult = function () {
                    var unknownObject = this.date.get();
                    var value = unknownObject === null ? null : new Date(unknownObject.toString());
                    if (value) {
                        if (isNaN(value.getTime())) {
                            value = this.initialDate.get();
                        }
                        else {
                            // Native time pickers give us string values (on iOS at least) so we need to turn em back into date values
                            // that .NET serialization likes.
                            // GVH-2803: Temporary fix: The strings returned from native date pickers do not preserve timezone.
                            // When we create a date from these strings it assumes they are UTC. 
                            var offset = 0;
                            var nativePicker = (this["attached_pickerType"] && this["attached_pickerType"].get) ? (this["attached_pickerType"].get().toLowerCase().indexOf("native") > -1) : true;
                            // If we have a string, apply local timezone offset as we are still in the client's timezone.
                            if (!(unknownObject instanceof Date) && !this.includeTimePicker.get() && nativePicker) {
                                offset = value.getTimezoneOffset() * 60000;
                            }
                            value = "/Date({0})/".format(value.getTime() + offset);
                        }
                    }
                    return new geocortex.forms.items.FormItemResult(this.argumentName.get(), value);
                };
                /**
                 * @private Renders the form item.
                 */
                DatePickerFormItem.prototype._render = function () {
                    return geocortex.forms.renderFormItem(this);
                };
                return DatePickerFormItem;
            }(items.AbstractFormItem));
            items.DatePickerFormItem = DatePickerFormItem;
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="LabelContainer.ts" />
/// <reference path="FormItemResult.ts" />
/// <reference path="FormItem.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            var FilePickerFormItem = (function (_super) {
                __extends(FilePickerFormItem, _super);
                /**
                 * Initializes a new instance of the {@link FilePickerFormItem} class.
                 * @param xmlNode Xml node containing the form item definition.
                 * @param formDefinition The form definition that this form item belongs to.
                 */
                function FilePickerFormItem(xmlNode, formDefinition) {
                    var _this = this;
                    _super.call(this, xmlNode, formDefinition);
                    /**
                     * The result.
                     * @type Object[]
                     */
                    this.files = new ObservableCollection();
                    this.formItemType = "FilePickerFormItem";
                    // Support is based on the presence of the FileReader API http://caniuse.com/#feat=filereader
                    this.isSupported = new Observable((typeof FileReader !== "undefined") && this._isFileInputSupported());
                    if (xmlNode) {
                        this.acceptFileTypes = new Observable(geocortex.forms.getElementText(xmlNode, "AcceptFileTypes"));
                        this.allowMultiple = new Observable(geocortex.forms._parseBoolean(geocortex.forms.getElementText(xmlNode, "AllowMultiple")));
                    }
                    else {
                        this.acceptFileTypes = new Observable(null);
                        this.allowMultiple = new Observable(false);
                    }
                    items.initLabelContainer(this, xmlNode, formDefinition);
                    this.files.bind(null, function (result) { return _this._notifyResultChanged(); });
                }
                /**
                 * Clears the form item input.
                 */
                FilePickerFormItem.prototype.clear = function () {
                    // File inputs require special handling because browser security prevents 
                    // modification of the input's value. We need to clear the values from the 
                    // view model and re-render the form item.
                    this.files.clear();
                    this.refresh();
                };
                /**
                 * Gets the result of the form item.
                 * @return {{@link geocortex.forms.items.FormItemResult}[]}
                 */
                FilePickerFormItem.prototype.getResult = function () {
                    // Collect the results
                    var results = [];
                    for (var i = 0; i < this.files.getLength(); ++i) {
                        var file = this.files.getAt(i);
                        if (file) {
                            results.push(file);
                        }
                    }
                    // Use an argument wrapper because we need to set the runtime type and return an array
                    var wrapper = new geocortex.workflow.ArgumentValueWrapper("System.Collections.Generic.List`1[[Geocortex.Forms.Client.FileItem, Geocortex.EssentialsWpfApi]]", results);
                    var r = new items.FormItemResult(this.argumentName.get(), wrapper, true);
                    r.isList = true;
                    return r;
                };
                /**
                 * @private Renders the form item.
                 */
                FilePickerFormItem.prototype._render = function () {
                    return geocortex.forms.renderFormItem(this);
                };
                /* @private: Checks to see if input type="file" is supported or not
                 * Resolves GVH-2955
                 * This function obtained from https://github.com/viljamis/isFileInputSupported.js on 22/8/2013
                 * Licensed under the MIT license.
                 * Copyright (c) 2011-2012 Viljami Salminen, http://viljamis.com/
                 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
                 * documentation files (the "Software"), to deal in the Software without restriction, including without limitation
                 * the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
                 * to permit persons to whom the Software is furnished to do so, subject to the following conditions:
                 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
                 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
                 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
                 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
                 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
                 */
                FilePickerFormItem.prototype._isFileInputSupported = function () {
                    // Handle devices which falsely report support
                    if (navigator.userAgent.match(/(Android (1.0|1.1|1.5|1.6|2.0|2.1))|(Windows Phone (OS 7|8.0))|(XBLWP)|(ZuneWP)|(w(eb)?OSBrowser)|(webOS)|(Kindle\/(1.0|2.0|2.5|3.0))/)) {
                        return false;
                    }
                    // Create test element
                    var el = (document.createElement("input"));
                    el.type = "file";
                    return !(el.disabled);
                };
                return FilePickerFormItem;
            }(items.AbstractFormItem));
            items.FilePickerFormItem = FilePickerFormItem;
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="FormItem.ts" />
/// <reference path="../../forms.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            var ContainerFormItem = (function (_super) {
                __extends(ContainerFormItem, _super);
                /**
                 * Initializes a new instance of the {@link ContainerFormItem} class.
                 * @param xmlNode Xml node containing the form item definition.
                 * @param formDefinition The form definition that this form item belongs to.
                 */
                function ContainerFormItem(xmlNode, formDefinition) {
                    _super.call(this, xmlNode, formDefinition);
                    this.formItems = new ObservableCollection();
                    this.formItemType = "ContainerFormItem";
                    if (xmlNode) {
                        this.orientation = new Observable(geocortex.forms.getElementText(xmlNode, "Orientation"));
                        this.description = new Observable(geocortex.forms.getElementText(xmlNode, "Description"));
                        this.maxWidth = new Observable(parseInt(geocortex.forms.getElementText(xmlNode, "MaxWidth")));
                        this.visibleControlID = new Observable(geocortex.forms.getElementText(xmlNode, "VisibleControlID"));
                        this.visibleControlValue = new Observable(geocortex.forms.getElementText(xmlNode, "VisibleControlValue"));
                        var formItems = geocortex.forms.getElement(xmlNode, "FormItems");
                        if (formItems != null) {
                            // Add all the form items
                            for (var i = 0; i < formItems.childNodes.length; i++) {
                                var formItem = geocortex.forms.items._processFormItem(formItems.childNodes[i], this.formDefinition);
                                if (formItem != null) {
                                    this.formItems.addItem(formItem);
                                    // Provide the refresh method implementation for each child
                                    var _this = this;
                                    formItem.refresh = function () {
                                        var index = _this.formItems.indexOf(this);
                                        if (index >= 0) {
                                            _this.formItems.removeAt(index);
                                            _this.formItems.insertItem(index, this);
                                        }
                                    };
                                }
                            }
                        }
                    }
                    else {
                        this.orientation = new Observable("Vertical");
                        this.description = new Observable("");
                        this.maxWidth = new Observable(NaN);
                        this.visibleControlID = new Observable("");
                        this.visibleControlValue = new Observable("");
                    }
                }
                /**
                 * Validates the form item.
                 * Returns a collection of invalid items.
                 * @return {{@link geocortex.forms.items.validation.ValidationResult}[]}
                 */
                ContainerFormItem.prototype.validate = function () {
                    var result = [];
                    // Only validate visible items
                    if (this.isVisible.get()) {
                        if (this.formItems != null) {
                            // Add all the form items
                            for (var i = 0; i < this.formItems.getLength(); ++i) {
                                var item = this.formItems.getAt(i);
                                if (item.isVisible.get()) {
                                    var validationResults = item.validate();
                                    for (var j = 0; j < validationResults.length; ++j) {
                                        result.push(validationResults[j]);
                                    }
                                }
                            }
                        }
                    }
                    return result;
                };
                /**
                 * @private Get a flat list of results
                 */
                ContainerFormItem.prototype._getResults = function () {
                    var resultList = [];
                    for (var i = 0; i < this.formItems.getLength(); ++i) {
                        var item = this.formItems.getAt(i);
                        if (item.isVisible.get()) {
                            if (item instanceof ContainerFormItem) {
                                var tempResultList = item._getResults();
                                if (tempResultList != null) {
                                    for (var j = 0; j < tempResultList.length; ++j) {
                                        resultList.push(tempResultList[j]);
                                    }
                                }
                            }
                            else {
                                var result = item.getResult();
                                if (result != null) {
                                    resultList.push(result);
                                }
                            }
                        }
                    }
                    return resultList;
                };
                /**
                 * @private Destroy all form items that it contains
                 */
                ContainerFormItem.prototype._destroy = function () {
                    for (var i = this.formItems.length() - 1; i >= 0; i--) {
                        this.formItems.getAt(i)._destroy();
                    }
                    this.formItems.clear();
                };
                /**
                 * @private Renders the form item.
                 */
                ContainerFormItem.prototype._render = function () {
                    return geocortex.forms.renderFormItem(this);
                };
                /**
                 * Get the contained FormItem with the given id or null if none can be found.
                 */
                ContainerFormItem.prototype.getFormItemById = function (itemId) {
                    for (var i = 0, length = this.formItems.length(); i < length; i++) {
                        var formItem = this.formItems.getAt(i);
                        if (formItem.itemID.get() === itemId) {
                            return formItem;
                        }
                        else if (formItem.getFormItemById) {
                            formItem = formItem.getFormItemById(itemId);
                            if (formItem) {
                                return formItem;
                            }
                        }
                    }
                    return null;
                };
                /**
                 * Set the visibility of this FormItem based on the value of the controlling FormItem.
                 */
                ContainerFormItem.prototype.applyVisibility = function (controlFormItem) {
                    if (!controlFormItem) {
                        // Bail out
                        return;
                    }
                    var makeVisible = false;
                    var r = controlFormItem.getResult();
                    if (r !== null && r.value !== null) {
                        var visibleControlValue = this.visibleControlValue.get();
                        if (visibleControlValue) {
                            if (r.isList) {
                                // Any matching list items
                                var list = r.value;
                                if (list) {
                                    for (var i = 0; i < list.length; i++) {
                                        if (list[i].toString() === visibleControlValue) {
                                            makeVisible = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            else {
                                // String match
                                if (r.value === true || r.value === false) {
                                    // Case insensitive
                                    makeVisible = r.value.toString().toUpperCase() === visibleControlValue.toUpperCase();
                                }
                                else {
                                    makeVisible = r.value.toString() === visibleControlValue;
                                }
                            }
                        }
                        else {
                            // A target value was not specified. We can handle this if the form item result is a Boolean.
                            if (r.value === true) {
                                makeVisible = true;
                            }
                        }
                    }
                    this.isVisible.set(makeVisible);
                };
                /**
                 * Gets the display name for this container.
                 */
                ContainerFormItem.prototype.getDisplayName = function () {
                    return null;
                };
                return ContainerFormItem;
            }(items.AbstractFormItem));
            items.ContainerFormItem = ContainerFormItem;
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="ContainerFormItem.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            var GroupBoxFormItem = (function (_super) {
                __extends(GroupBoxFormItem, _super);
                /**
                 * Initializes a new instance of the {@link geocortex.forms.items.GroupBoxFormItem} class.
                 * @param xmlNode Xml node containing the form item definition.
                 * @param formDefinition The form definition that this form item belongs to.
                 */
                function GroupBoxFormItem(xmlNode, formDefinition) {
                    _super.call(this, xmlNode, formDefinition);
                    this.formItemType = "GroupBoxFormItem";
                    if (xmlNode) {
                        this.header = new Observable(geocortex.forms.getElementText(xmlNode, "Header"));
                    }
                    else {
                        this.header = new Observable(null);
                    }
                }
                /**
                 * @private Renders the form item.
                 */
                GroupBoxFormItem.prototype._render = function () {
                    return geocortex.forms.renderFormItem(this);
                };
                /**
                 * Gets the display name for this container.
                 */
                GroupBoxFormItem.prototype.getDisplayName = function () {
                    return this.header.get();
                };
                return GroupBoxFormItem;
            }(items.ContainerFormItem));
            items.GroupBoxFormItem = GroupBoxFormItem;
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="FormItem.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            var HyperlinkFormItem = (function (_super) {
                __extends(HyperlinkFormItem, _super);
                /**
                 * Initializes a new instance of the {@link geocortex.forms.items.HyperlinkFormItem} class.
                 * @param xmlNode Xml node containing the form item definition.
                 * @param formDefinition The form definition that this form item belongs to.
                 */
                function HyperlinkFormItem(xmlNode, formDefinition) {
                    var _this = this;
                    _super.call(this, xmlNode, formDefinition);
                    /**
                     * Gets or sets a value indicating whether the hyperlink was clicked by the user.
                     * @type Boolean
                     */
                    this.wasClicked = new Observable(false);
                    this.formItemType = "HyperlinkFormItem";
                    if (xmlNode) {
                        this.hyperlinkText = new Observable(geocortex.forms.getElementText(xmlNode, "HyperlinkText"));
                        this.target = new Observable(geocortex.forms.getElementText(xmlNode, "Target"));
                        this.uri = new Observable(geocortex.forms.getElementText(xmlNode, "Uri"));
                    }
                    else {
                        this.hyperlinkText = new Observable("Hyperlink");
                        this.target = new Observable("_blank");
                        this.uri = new Observable("");
                    }
                    this.wasClicked.bind(null, function (result) { return _this._notifyResultChanged(); });
                }
                /**
                 * Gets the result of the form item.
                 * @return {{@link geocortex.forms.items.FormItemResult}[]}
                 */
                HyperlinkFormItem.prototype.getResult = function () {
                    return new geocortex.forms.items.FormItemResult(this.argumentName.get(), this.wasClicked.get(), this.wasClicked.get());
                };
                /**
                 * @private Renders the form item.
                 */
                HyperlinkFormItem.prototype._render = function () {
                    return geocortex.forms.renderFormItem(this);
                };
                return HyperlinkFormItem;
            }(items.AbstractFormItem));
            items.HyperlinkFormItem = HyperlinkFormItem;
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="FormItem.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            var ImageFormItem = (function (_super) {
                __extends(ImageFormItem, _super);
                /**
                 * Initializes a new instance of the {@link geocortex.forms.items.ImageFormItem} class.
                 * @param xmlNode Xml node containing the form item definition.
                 * @param formDefinition The form definition that this form item belongs to.
                 */
                function ImageFormItem(xmlNode, formDefinition) {
                    _super.call(this, xmlNode, formDefinition);
                    this.formItemType = "ImageFormItem";
                    if (xmlNode) {
                        this.source = new Observable(geocortex.forms.getElementText(xmlNode, "Source"));
                        this.width = new Observable(geocortex.forms.getElementText(xmlNode, "Width"));
                        this.height = new Observable(geocortex.forms.getElementText(xmlNode, "Height"));
                        var width = this.width.get();
                        var height = this.height.get();
                        if (width && height) {
                            // Choosing the longest of the 2 and setting the other to auto is an imperfect way to do scaling in JS while maintaining the aspect ratio. There is no
                            // way to know if the auto part will not result in a greater number than was specified.
                            if (parseInt(width) > parseInt(height)) {
                                this.height.set("auto");
                            }
                            else {
                                this.width.set("auto");
                            }
                        }
                        else {
                            this.width = new Observable("auto");
                            this.height = new Observable("auto");
                        }
                    }
                    else {
                        this.source = new Observable("");
                        this.width = new Observable("auto");
                        this.height = new Observable("auto");
                    }
                }
                /**
                 * @private Renders the form item.
                 */
                ImageFormItem.prototype._render = function () {
                    return geocortex.forms.renderFormItem(this);
                };
                return ImageFormItem;
            }(items.AbstractFormItem));
            items.ImageFormItem = ImageFormItem;
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="QueryTaskFormItem.ts" />
/// <reference path="LabelContainer.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            var ListBoxFormItem = (function (_super) {
                __extends(ListBoxFormItem, _super);
                /**
                 * Initializes a new instance of the {@link geocortex.forms.items.ListBoxFormItem} class.
                 * @param xmlNode Xml node containing the form item definition.
                 * @param formDefinition The form definition that this form item belongs to.
                 */
                function ListBoxFormItem(xmlNode, formDefinition) {
                    var _this = this;
                    _super.call(this, xmlNode, formDefinition);
                    /**
                     * The selected value (or values).
                     * @type Object[]
                     */
                    this.selection = new ObservableCollection();
                    /**
                     * The values that should be selected by default as defined in the form definition.
                     */
                    this.selectedValues = new ObservableCollection();
                    /**
                     * A fast lookup object that contains a property for each of the default selected values.
                     * @private
                     */
                    this._selectedValuesLookup = null;
                    this.isBusy = new Observable(false);
                    this.formItemType = "ListBoxFormItem";
                    items.initLabelContainer(this, xmlNode, formDefinition);
                    items.initDataItemsFormItem(this, xmlNode, formDefinition);
                    // Default list box size is 6 rows
                    this.size = new Observable(6);
                    if (xmlNode) {
                        this.maxHeight = new Observable(parseInt(geocortex.forms.getElementText(xmlNode, "MaxHeight")));
                        this.selectionMode = new Observable(geocortex.forms.getElementText(xmlNode, "SelectionMode"));
                        // The size is only available as of Essentials 4.4
                        var rawSize = geocortex.forms.getElementText(xmlNode, "Size");
                        if (rawSize) {
                            var size = parseInt(rawSize);
                            if (size > 0) {
                                this.size.set(size);
                            }
                        }
                        // Set the default values
                        var selectedValues = geocortex.forms.getElement(xmlNode, "SelectedValues");
                        if (selectedValues) {
                            this._selectedValuesLookup = {};
                            var i;
                            for (i = 0; i < selectedValues.childNodes.length; i++) {
                                var selectedValue = selectedValues.childNodes[i].textContent;
                                this.selectedValues.addItem(selectedValue);
                                this._selectedValuesLookup[selectedValue + ""] = true;
                            }
                            this._setDefaults();
                            // GVH-6625: This adds the first dataItem to the selection, in case the user
                            // wants to click 'OK' before actually selecting an item in the ListBox. Since
                            // the first item appears to be selected by default, making it the actual
                            // default seems reasonable.            
                            if (this.selection.length() === 0 && this.dataItems.getItems().length !== 0) {
                                this.selection.addItem(this.dataItems.getAt(0));
                            }
                        }
                    }
                    else {
                        this.label = new geocortex.forms.items.LabelFormItem(null, this.formDefinition);
                        this.maxHeight = new Observable(NaN);
                        this.selectionMode = new Observable("Single");
                    }
                    this.queryTaskRunner = new items.QueryTaskRunner(this, xmlNode, formDefinition);
                    var cascadingId = this.queryTaskRunner.queryCascadingID.get();
                    // If this control is not part of a cascading relationship, fire off the initial query.
                    if (!cascadingId) {
                        this.queryTaskRunner.performQuery("");
                    }
                    // We need to use setTimeout to handle the case when the selection changes to zero results. 
                    // The event fires before the last items is removed. 
                    this.selection.bind(null, function (result) {
                        setTimeout(function () {
                            _this._notifyResultChanged();
                        }, 0);
                    });
                }
                /**
                 * Clears the data items.
                 */
                ListBoxFormItem.prototype.clearDataItems = function () {
                    this.dataItems.clear();
                };
                /** @protected */
                ListBoxFormItem.prototype._setDefaults = function () {
                    for (var i = 0; i < this.dataItems.getItems().length; i++) {
                        var dataItem = this.dataItems.getAt(i);
                        if (this._selectedValuesLookup[dataItem.value.toString()]) {
                            this.selection.addItem(dataItem);
                        }
                    }
                };
                ListBoxFormItem.prototype.handleResultsComplete = function () {
                    this._setDefaults();
                };
                /**
                 * @private Notifies any listeners that a value has been selected and they should cascade.
                 */
                ListBoxFormItem.prototype.triggerCascading = function (value) {
                    // Clear cascaded fields.
                    if (this.selection == null || !value) {
                        this.queryTaskRunner.cascadingEvent.publish(null);
                    }
                    var item = null;
                    if (this.selection != null) {
                        item = this.selection.getAt(0);
                    }
                    if (item == null && value != null) {
                        item = value;
                    }
                    if (item == null) {
                        this.queryTaskRunner.cascadingEvent.publish(null);
                    }
                    else {
                        this.queryTaskRunner.cascadingEvent.publish(item.value);
                    }
                };
                /**
                 * Gets the result of the form item.
                 * @return {{@link geocortex.forms.items.FormItemResult}[]}
                 */
                ListBoxFormItem.prototype.getResult = function () {
                    var result = null;
                    // Check if it's a single item.
                    if (this.selectionMode.get().toLowerCase() == "single") {
                        if (this.selection.getLength() > 0) {
                            var item = this.selection.getAt(0);
                            result = item ? item.getValue() : null;
                        }
                        return new items.FormItemResult(this.argumentName.get(), result, true);
                    }
                    else {
                        var results = [];
                        for (var i = 0; i < this.selection.getLength(); ++i) {
                            var item = this.selection.getAt(i);
                            result = item ? item.getValue() : null;
                            if (result) {
                                results.push(result);
                            }
                        }
                        result = new items.FormItemResult(this.argumentName.get(), results, true);
                        result.isList = true;
                        return result;
                    }
                };
                /**
                 * @private Renders the form item.
                 */
                ListBoxFormItem.prototype._render = function () {
                    return geocortex.forms.renderFormItem(this);
                };
                return ListBoxFormItem;
            }(items.AbstractFormItem));
            items.ListBoxFormItem = ListBoxFormItem;
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="FormItem.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            var RadioButtonFormItem = (function (_super) {
                __extends(RadioButtonFormItem, _super);
                /**
                 * Initializes a new instance of the {@link geocortex.forms.items.RadioButtonFormItem} class.
                 * @param xmlNode Xml node containing the form item definition.
                 * @param formDefinition The form definition that this form item belongs to.
                 */
                function RadioButtonFormItem(xmlNode, formDefinition) {
                    var _this = this;
                    _super.call(this, xmlNode, formDefinition);
                    this.formItemType = "RadioButtonFormItem";
                    if (xmlNode) {
                        this.text = new Observable(geocortex.forms.getElementText(xmlNode, "Text"));
                        this.checked = new Observable(geocortex.forms._parseBoolean(geocortex.forms.getElementText(xmlNode, "Checked")));
                        this.textLocation = new Observable(geocortex.forms.getElementText(xmlNode, "TextLocation"));
                        this.groupName = new Observable(geocortex.forms.getElementText(xmlNode, "GroupName"));
                    }
                    else {
                        this.text = new Observable(null);
                        this.checked = new Observable(false);
                        this.textLocation = new Observable("Right");
                        this.groupName = new Observable(null);
                    }
                    this.checked.bind(null, function (result) {
                        if (result) {
                            // HACK
                            // Uncheck the other radio buttons in the same group
                            RadioButtonFormItem._findButtonsInGroup(_this.groupName.get(), _this.formDefinition.containerFormItem).forEach(function (rb) {
                                if (rb !== _this) {
                                    rb.checked.set(false);
                                }
                            });
                        }
                        _this._notifyResultChanged();
                    });
                }
                /**
                 * Gets the result of the form item.
                 * @return {{@link geocortex.forms.items.FormItemResult}[]}
                 */
                RadioButtonFormItem.prototype.getResult = function () {
                    // HACK! Temporary. Using a closure passed in by a view allows us to get the checked state of this radio button
                    // without having to track others.
                    var closureHack = this["__getRadioValueClosure"];
                    var result = closureHack ? closureHack() : false;
                    return new geocortex.forms.items.FormItemResult(this.argumentName.get(), result);
                };
                /**
                 * @private Renders the form item.
                 */
                RadioButtonFormItem.prototype._render = function () {
                    return geocortex.forms.renderFormItem(this);
                };
                RadioButtonFormItem._findButtonsInGroup = function (groupName, container) {
                    var buttons = [];
                    if (container) {
                        container.formItems.get().forEach(function (item) {
                            if (item instanceof RadioButtonFormItem) {
                                if (item.groupName.get() === groupName) {
                                    buttons.push(item);
                                }
                            }
                            else if (item instanceof items.ContainerFormItem) {
                                RadioButtonFormItem._findButtonsInGroup(groupName, item).forEach(function (item2) { return buttons.push(item2); });
                            }
                        });
                    }
                    return buttons;
                };
                return RadioButtonFormItem;
            }(items.AbstractFormItem));
            items.RadioButtonFormItem = RadioButtonFormItem;
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="TextBoxFormItem.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            var AutoCompleteBoxFormItem = (function (_super) {
                __extends(AutoCompleteBoxFormItem, _super);
                /**
                 * Initializes a new instance of the {@link AutoCompleteBoxFormItem} class.
                 * @param xmlNode Xml node containing the form item definition.
                 * @param formDefinition The form definition that this form item belongs to.
                 */
                function AutoCompleteBoxFormItem(xmlNode, formDefinition) {
                    _super.call(this, xmlNode, formDefinition);
                    this.isBusy = new Observable(false);
                    this.formItemType = "AutoCompleteBoxFormItem";
                    if (xmlNode) {
                        this.minimumPrefixLength = new Observable(parseInt(geocortex.forms.getElementText(xmlNode, "MinimumPrefixLength")));
                        this.minimumPopulateDelay = new Observable(parseInt(geocortex.forms.getElementText(xmlNode, "MinimumPopulateDelay")));
                    }
                    else {
                        this.minimumPrefixLength = new Observable(3);
                        this.minimumPopulateDelay = new Observable(200);
                    }
                    items.initDataItemsFormItem(this, xmlNode, formDefinition);
                    this.queryTaskRunner = new items.QueryTaskRunner(this, xmlNode, formDefinition);
                }
                /**
                 * Clears the data items.
                 */
                AutoCompleteBoxFormItem.prototype.clearDataItems = function () {
                    this.dataItems.clear();
                };
                return AutoCompleteBoxFormItem;
            }(items.TextBoxFormItem));
            items.AutoCompleteBoxFormItem = AutoCompleteBoxFormItem;
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            var validation;
            (function (validation) {
                var ValidationResult = (function () {
                    /**
                     * Initializes a new instance of the {@link geocortex.forms.items.validation.ValidationResult} class.
                     * @param xmlNode Xml node containing the form item definition.
                     * @param errorMessage The error message to display to the user.
                     */
                    function ValidationResult(isValid, errorMessage) {
                        this.isValid = isValid;
                        this.errorMessage = errorMessage;
                    }
                    return ValidationResult;
                }());
                validation.ValidationResult = ValidationResult;
            })(validation = items.validation || (items.validation = {}));
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var FileItem = (function () {
            /**
             * Initializes a new instance of the {@link FileItem} class.
             */
            function FileItem() {
                this.fileName = null;
                this.fileDataBase64 = null;
                this.fileSize = 0;
                this.fileType = null;
            }
            return FileItem;
        }());
        forms.FileItem = FileItem;
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="ValidationItem.ts" />
/// <reference path="ValidationResult.ts" />
/// <reference path="../../../forms.ts" />
/// <reference path="../../FileItem.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            var validation;
            (function (validation) {
                var FileSizeValidationItem = (function (_super) {
                    __extends(FileSizeValidationItem, _super);
                    /**
                     * Initializes a new instance of the {@link geocortex.forms.items.validation.FileSizeValidationItem} class.
                     * @param xmlNode Xml node containing the form item definition.
                     */
                    function FileSizeValidationItem(xmlNode) {
                        _super.call(this, xmlNode);
                        this.totalFileSize = parseInt(geocortex.forms.getElementText(xmlNode, "TotalFileSize"));
                    }
                    /**
                     * Performs validation checks on a value.
                     * @return {{@link geocortex.forms.items.validation.ValidationResult}}
                     */
                    FileSizeValidationItem.prototype.validate = function (value) {
                        // File items are wrapped in an ArgumentValueWrapper. Unwrap them and add up the total file size.
                        if (value instanceof geocortex.workflow.ArgumentValueWrapper) {
                            if (value.value) {
                                if (value.value instanceof Array) {
                                    var size = 0;
                                    for (var i = 0; i < value.value.length; ++i) {
                                        var file = value.value[i];
                                        if (file) {
                                            if (file instanceof geocortex.forms.FileItem) {
                                                size += file.fileSize;
                                            }
                                        }
                                    }
                                    if (size > this.totalFileSize) {
                                        return new geocortex.forms.items.validation.ValidationResult(false, this.message);
                                    }
                                }
                            }
                        }
                        return new geocortex.forms.items.validation.ValidationResult(true, null);
                    };
                    return FileSizeValidationItem;
                }(validation.ValidationItem));
                validation.FileSizeValidationItem = FileSizeValidationItem;
            })(validation = items.validation || (items.validation = {}));
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="ValidationItem.ts" />
/// <reference path="ValidationResult.ts" />
/// <reference path="../../../forms.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            var validation;
            (function (validation) {
                var NumericRangeValidationItem = (function (_super) {
                    __extends(NumericRangeValidationItem, _super);
                    /**
                     * Initializes a new instance of the {@link geocortex.forms.items.validation.NumericRangeValidationItem} class.
                     * @param xmlNode Xml node containing the form item definition.
                     */
                    function NumericRangeValidationItem(xmlNode) {
                        _super.call(this, xmlNode);
                        this.minimumValue = parseFloat(geocortex.forms.getElementText(xmlNode, "MinimumValue"));
                        this.maximumValue = parseFloat(geocortex.forms.getElementText(xmlNode, "MaximumValue"));
                    }
                    /**
                     * Performs validation checks on a value.
                     * @return {{@link geocortex.forms.items.validation.ValidationResult}}
                     */
                    NumericRangeValidationItem.prototype.validate = function (value) {
                        // Don't fail validation on a null or empty value.
                        if (value === null || value === undefined || value === "") {
                            return new geocortex.forms.items.validation.ValidationResult(true, null);
                        }
                        var number = parseFloat(value);
                        // Check if the value is not within range (or not even a numer)
                        if ((number == null) || (isNaN(number)) || (number < this.minimumValue) || (number > this.maximumValue)) {
                            return new geocortex.forms.items.validation.ValidationResult(false, this.message);
                        }
                        else {
                            return new geocortex.forms.items.validation.ValidationResult(true, null);
                        }
                    };
                    return NumericRangeValidationItem;
                }(validation.ValidationItem));
                validation.NumericRangeValidationItem = NumericRangeValidationItem;
            })(validation = items.validation || (items.validation = {}));
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="ValidationResult.ts" />
/// <reference path="ValidationItem.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            var validation;
            (function (validation) {
                var RegexValidationItem = (function (_super) {
                    __extends(RegexValidationItem, _super);
                    /**
                     * Initializes a new instance of the {@link geocortex.forms.items.validation.RegexValidationItem} class.
                     * @param xmlNode Xml node containing the form item definition.
                     */
                    function RegexValidationItem(xmlNode) {
                        _super.call(this, xmlNode);
                        this.expression = geocortex.forms.getElementText(xmlNode, "Expression");
                        this.ignoreCase = geocortex.forms._parseBoolean(geocortex.forms.getElementText(xmlNode, "IgnoreCase"));
                    }
                    /**
                     * Performs validation checks on a value.
                     * @return {{@link geocortex.forms.items.validation.ValidationResult}}
                     */
                    RegexValidationItem.prototype.validate = function (value) {
                        // Don't fail validation on a null or empty value.
                        if (value === null || value === undefined || value === "") {
                            return new geocortex.forms.items.validation.ValidationResult(true, null);
                        }
                        var modifiers = "";
                        var expression = this.expression;
                        if (this.ignoreCase) {
                            modifiers += "i";
                        }
                        // Replace the email expression with a valid one for JavaScript
                        if (this.expression == "^(?(\")(\".+?\"@)|(([0-9a-zA-Z]((\\.(?!\\.))|[-!#\\$%&'\\*\\+/=\\?\\^`\\{\\}\\|~\\w])*)(?<=[0-9a-zA-Z])@))(?(\\[)(\\[(\\d{1,3}\\.){3}\\d{1,3}\\])|(([0-9a-zA-Z][-\\w]*[0-9a-zA-Z]\\.)+[a-zA-Z]{2,6}))$") {
                            expression = "^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,4}$";
                        }
                        var regEx = null;
                        try {
                            regEx = new RegExp(expression, modifiers);
                        }
                        catch (error) {
                        }
                        // Check if the string doesn't pass regex
                        if ((regEx != null) && !regEx.test(value)) {
                            return new geocortex.forms.items.validation.ValidationResult(false, this.message);
                        }
                        return new geocortex.forms.items.validation.ValidationResult(true, null);
                    };
                    return RegexValidationItem;
                }(validation.ValidationItem));
                validation.RegexValidationItem = RegexValidationItem;
            })(validation = items.validation || (items.validation = {}));
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            var validation;
            (function (validation) {
                var RequiredValidationItem = (function (_super) {
                    __extends(RequiredValidationItem, _super);
                    /**
                     * Initializes a new instance of the {@link geocortex.forms.items.validation.RequiredValidationItem} class.
                     * @param xmlNode Xml node containing the form item definition.
                     */
                    function RequiredValidationItem(xmlNode) {
                        _super.call(this, xmlNode);
                    }
                    /**
                     * Performs validation checks on a value.
                     * @return {{@link geocortex.forms.items.validation.ValidationResult}}
                     */
                    RequiredValidationItem.prototype.validate = function (value) {
                        var isValid = true;
                        var errorMessage = null;
                        // Check if there is a validation error (the field was not provided, but is required)
                        if ((value === undefined)
                            || (value === null)
                            || (typeof (value) === "string" && dojo.trim(value) === "")
                            || (value.length !== undefined && value.length <= 0)
                            || (value.value && dojo.isArray(value.value) && value.value.length === 0)) {
                            isValid = false;
                            errorMessage = this.message;
                        }
                        return new geocortex.forms.items.validation.ValidationResult(isValid, errorMessage);
                    };
                    return RequiredValidationItem;
                }(validation.ValidationItem));
                validation.RequiredValidationItem = RequiredValidationItem;
            })(validation = items.validation || (items.validation = {}));
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../_Definitions/dojo.d.ts" />
/// <reference path="forms/items/FormItem.ts" />
/// <reference path="forms/items/TextAreaFormItem.ts" />
/// <reference path="forms/items/TextBoxFormItem.ts" />
/// <reference path="forms/FormButton.ts" />
/// <reference path="forms/items/validation/ValidationItem.ts" />
/// <reference path="forms/items/CheckBoxFormItem.ts" />
/// <reference path="forms/items/ComboBoxFormItem.ts" />
/// <reference path="forms/items/DataItemsFormItem.ts" />
/// <reference path="forms/items/DatePickerFormItem.ts" />
/// <reference path="forms/items/FilePickerFormItem.ts" />
/// <reference path="forms/items/FormItem.ts" />
/// <reference path="forms/items/GroupBoxFormItem.ts" />
/// <reference path="forms/items/HyperlinkFormItem.ts" />
/// <reference path="forms/items/ImageFormItem.ts" />
/// <reference path="forms/items/MarkdownFormItem.ts" />
/// <reference path="forms/items/ListBoxFormItem.ts" />
/// <reference path="forms/items/RadioButtonFormItem.ts" />
/// <reference path="forms/items/AutoCompleteBoxFormItem.ts" />
/// <reference path="forms/items/validation/FileSizeValidationItem.ts" />
/// <reference path="forms/items/validation/NumericRangeValidationItem.ts" />
/// <reference path="forms/items/validation/RegexValidationItem.ts" />
/// <reference path="forms/items/validation/RequiredValidationItem.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        /**
         * Return this first immediate child element named elementName.
         * @param XmlNode The xml node to use to find the element with name elementName.
         * @param String The name of the element to get the text content from.
         */
        function getElement(xmlDoc, elementName) {
            var n = xmlDoc.getElementsByTagName(elementName);
            if (n.length >= 1) {
                for (var i = 0; i < n.length; i++) {
                    // We must ensure that the parentNode is the one we're looking for, Chrome returns all descendants. JSAPI-47 
                    if (n[i].parentNode === xmlDoc) {
                        return n[i];
                    }
                }
            }
            else {
                if (xmlDoc.childNodes.length > 0) {
                    var prefix = xmlDoc.childNodes[0].prefix;
                    if (prefix != "") {
                        n = xmlDoc.getElementsByTagName(prefix + ":" + elementName);
                        if (n.length >= 1) {
                            for (var i = 0; i < n.length; i++) {
                                // We must ensure that the parentNode is the one we're looking for, Chrome returns all descendants. JSAPI-47 
                                if (n[i].parentNode === xmlDoc) {
                                    return n[i];
                                }
                            }
                        }
                    }
                }
            }
            return null;
        }
        forms.getElement = getElement;
        /**
         * Return the text content of a child element named elementName.
         * @param XmlNode The xml node to use to find the element with name elementName.
         * @param String The name of the element to get the text content from.
         */
        function getElementText(xmlDoc, elementName) {
            var n = getElement(xmlDoc, elementName);
            if (n) {
                return dojox.xml.parser.textContent(n);
            }
            else {
                return null;
            }
        }
        forms.getElementText = getElementText;
        /**
         * Return the value of an attribute on the specified node.
         * @param XmlNode The xml node to use to find the attribute value with name attributeName.
         * @param String The name of the attribute to get the value from.
         */
        function getAttributeValue(xmlDoc, attributeName) {
            if (xmlDoc != null) {
                for (var i = 0; i < xmlDoc.attributes.length; i++) {
                    if (xmlDoc.attributes[i].name == attributeName) {
                        return xmlDoc.attributes[i].value;
                    }
                }
            }
            return null;
        }
        forms.getAttributeValue = getAttributeValue;
        /** @private */
        function _parseBoolean(value) {
            if (value != null) {
                switch (value.toLowerCase()) {
                    case "true":
                    case "yes":
                    case "1":
                        return true;
                    case "false":
                    case "no":
                    case "0":
                    case null:
                        return false;
                    default: return Boolean(value);
                }
            }
            // Null equals false
            return false;
        }
        forms._parseBoolean = _parseBoolean;
        function renderFormItem(fromItem) {
            throw new Error("This abstract function must be implemented by your UI system");
        }
        forms.renderFormItem = renderFormItem;
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var items;
        (function (items) {
            /**
             * @private Return the form item represented by the xml node.
             */
            function _processFormItem(xmlDoc, formDefinition) {
                var type = _getType(xmlDoc);
                var formItem = null;
                switch (type) {
                    case "AutoCompleteBoxFormItem":
                        formItem = new geocortex.forms.items.AutoCompleteBoxFormItem(xmlDoc, formDefinition);
                        break;
                    case "CheckBoxFormItem":
                        formItem = new geocortex.forms.items.CheckBoxFormItem(xmlDoc, formDefinition);
                        break;
                    case "ContainerFormItem":
                        formItem = new geocortex.forms.items.ContainerFormItem(xmlDoc, formDefinition);
                        break;
                    case "ComboBoxFormItem":
                        formItem = new geocortex.forms.items.ComboBoxFormItem(xmlDoc, formDefinition);
                        break;
                    case "DatePickerFormItem":
                        formItem = new geocortex.forms.items.DatePickerFormItem(xmlDoc, formDefinition);
                        break;
                    case "FilePickerFormItem":
                        formItem = new geocortex.forms.items.FilePickerFormItem(xmlDoc, formDefinition);
                        break;
                    case "GroupBoxFormItem":
                        formItem = new geocortex.forms.items.GroupBoxFormItem(xmlDoc, formDefinition);
                        break;
                    case "HyperlinkFormItem":
                        formItem = new geocortex.forms.items.HyperlinkFormItem(xmlDoc, formDefinition);
                        break;
                    case "ImageFormItem":
                        formItem = new geocortex.forms.items.ImageFormItem(xmlDoc, formDefinition);
                        break;
                    case "ListBoxFormItem":
                        formItem = new geocortex.forms.items.ListBoxFormItem(xmlDoc, formDefinition);
                        break;
                    case "MarkdownFormItem":
                        formItem = new geocortex.forms.items.MarkdownFormItem(xmlDoc, formDefinition);
                        break;
                    case "RadioButtonFormItem":
                        formItem = new geocortex.forms.items.RadioButtonFormItem(xmlDoc, formDefinition);
                        break;
                    case "TextAreaFormItem":
                        formItem = new geocortex.forms.items.TextAreaFormItem(xmlDoc, formDefinition);
                        break;
                    case "TextBoxFormItem":
                        formItem = new geocortex.forms.items.TextBoxFormItem(xmlDoc, formDefinition);
                        break;
                    case "TimePickerFormItem":
                        formItem = new geocortex.forms.items.TimePickerFormItem(xmlDoc, formDefinition);
                        break;
                }
                // Check if we should provide input data to the form item
                if (formItem.dataItems &&
                    formDefinition != null &&
                    formDefinition.inputData != null &&
                    formDefinition.inputData.hasOwnProperty(formItem.itemID)) {
                    formItem.dataItems.addItems(formDefinition.inputData.item(formItem.itemID));
                }
                return formItem;
            }
            items._processFormItem = _processFormItem;
            /**
             * @private Return the validation item represented by the xml node.
             */
            function _processValidationItem(xmlDoc) {
                var type = _getType(xmlDoc);
                var validationItem = null;
                switch (type) {
                    case "NumericRangeValidationItem":
                        validationItem = new forms.items.validation.NumericRangeValidationItem(xmlDoc);
                        break;
                    case "RequiredValidationItem":
                        validationItem = new forms.items.validation.RequiredValidationItem(xmlDoc);
                        break;
                    case "RegexValidationItem":
                        validationItem = new forms.items.validation.RegexValidationItem(xmlDoc);
                        break;
                    case "FileSizeValidationItem":
                        validationItem = new forms.items.validation.FileSizeValidationItem(xmlDoc);
                        break;
                }
                return validationItem;
            }
            items._processValidationItem = _processValidationItem;
            function _getType(xmlDoc) {
                var result = "";
                // Ensure that we have the proper object
                if ((xmlDoc != null) && (xmlDoc.attributes != null)) {
                    // Loop through the attributes to find the one about type
                    for (var i = 0; i < xmlDoc.attributes.length; i++) {
                        // There might be a namespace prefix, so do a fuzzy match for type
                        if (String(xmlDoc.attributes[i].nodeName).indexOf("type") >= 0) {
                            // Prune the namespace
                            var value = xmlDoc.attributes[i].nodeValue;
                            var pos = value.indexOf(":");
                            if ((pos >= 0) && (pos + 1 < value.length)) {
                                value = value.substr(pos + 1);
                            }
                            result = value;
                            break;
                        }
                    }
                }
                return result;
            }
            items._getType = _getType;
        })(items = forms.items || (forms.items = {}));
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="items/FormItem.ts" />
/// <reference path="../../../../_Definitions/framework.d.ts" />
/// <reference path="../forms.ts" />
/// <reference path="../../../../_Definitions/arcgis-js-api.d.ts" />
var geocortex;
(function (geocortex) {
    var forms;
    (function (forms) {
        var FormDefinition = (function () {
            /**
             * Initializes a new instance of the {@link geocortex.forms.FormDefinition} class.
             * @class Represents a workflow form.
             * @constructs
             * @param xmlString The xml of the form definition in a string.
             * @param inputData The dictionary of DataItem collection.
             * @param inputGeometry The geometry to use for filtering the entries in the list box.
             */
            function FormDefinition(xmlString, inputData, inputGeometry) {
                /**
                 * The Form Definition Language version.
                 * @type String
                 */
                this.version = null;
                /**
                 * The dictionary of collection of DataItem to be used when binding form items that derive from DataItemsFormItem, such as ComboBoxFormItem and ListBoxFormItem.
                 * @type Object
                 */
                this.inputData = null;
                /**
                 * The container form item.
                 * @type ContainerFormItem
                 */
                this.containerFormItem = null; // really a ContainerFormItem, but this causes a circular reference the compiler can't properly resolve yet
                // see https://typescript.codeplex.com/workitem/913
                /**
                 * The input geometry that can be used to filter the queries in the ComboBox and ListBox.
                 * @type esri.geometry.Geometry
                 */
                this.inputGeometry = null;
                /**
                 * The known types used by this form definition.
                 * @type String[]
                 */
                this.knownTypes = null;
                /** @private */
                this._formManager = null;
                /** @private */
                this._version = 1.1;
                /** @private */
                this._formContainer = null;
                /** @private */
                this._cascadingMap = null;
                /*** @private */
                this._controlMap = null;
                this.knownTypes = [];
                this.inputData = inputData;
                this.version = this._version;
                this._controlMap = {};
                this._cascadingMap = {};
                var xml = null;
                // Check if an xml string was passed in and if we can parse it to XML
                if (xmlString) {
                    xml = dojox.xml.parser.parse(xmlString);
                }
                // If an input geometry has been supplied, we need to attach it before we attempt to process
                if (inputGeometry) {
                    this.inputGeometry = inputGeometry;
                }
                if (xml != null) {
                    var xmlDoc = xml.documentElement;
                    var formVersion = geocortex.forms.getElementText(xmlDoc, "Version");
                    if (parseFloat(formVersion) > this._version) {
                        throw new Error("Form version " + formVersion + " is incompatible with current API version " + this._version);
                    }
                    this.title = new Observable(geocortex.forms.getElementText(xmlDoc, "Title"));
                    this.maxWidth = new Observable(parseInt(geocortex.forms.getElementText(xmlDoc, "MaxWidth")));
                    this.maxHeight = new Observable(parseInt(geocortex.forms.getElementText(xmlDoc, "MaxHeight")));
                    var knownTypes = geocortex.forms.getElement(xmlDoc, "KnownTypes");
                    if (knownTypes != null) {
                        for (var i = 0; i < knownTypes.childNodes.length; i++) {
                            this.knownTypes.push(knownTypes.childNodes[i].firstChild.data);
                        }
                    }
                    this.containerFormItem = new geocortex.forms.items.ContainerFormItem(geocortex.forms.getElement(xmlDoc, "ContainerFormItem"), this);
                }
                else {
                    this.containerFormItem = new geocortex.forms.items.ContainerFormItem(null, this);
                    this.containerFormItem.itemID = new Observable("Group1");
                    this.title = new Observable("");
                    this.maxWidth = new Observable(NaN);
                    this.maxHeight = new Observable(NaN);
                }
                // At this point, all child controls will have been recursively loaded and mapped. Hook up cascading events.
                for (var controlName in this._cascadingMap) {
                    if (!this._cascadingMap.hasOwnProperty(controlName)) {
                        continue;
                    }
                    for (var i = 0; i < this._cascadingMap[controlName].length; ++i) {
                        var entry = this._cascadingMap[controlName][i];
                        var control = this._controlMap[controlName];
                        control.queryTaskRunner.cascadingEvent.subscribe(entry["formItem"], entry["handler"]);
                    }
                }
            }
            /**
             * Adds a cascading relationship. The FormDefinition will satisfy these relationships after it loads all controls by attaching the supplied handler
             * to the cascading event of the specified control.
             * @param cascadingId The id of the control that supports cascading.
             * @param formItem The form item.
             * @param handler The handler that will be triggered when an item cascades.
             */
            FormDefinition.prototype.addCascading = function (cascadingId, formItem, handler) {
                if (this._cascadingMap.hasOwnProperty(cascadingId) == false) {
                    this._cascadingMap[cascadingId] = [];
                }
                this._cascadingMap[cascadingId].push({ formItem: formItem, handler: handler });
            };
            /**
             * Adds a control entry that allows the FormDefinition to quickly find the control by its ID.
             * @param item The form item.
             */
            FormDefinition.prototype.map = function (item) {
                this._controlMap[item.itemID.get()] = item;
            };
            /**
             * Renders a form and attaches it to the dom node. This method should be overridden in the viewer.
             * @param node The node to render.
             */
            FormDefinition.prototype.render = function (node) { };
            /**
             * Validates the form item.
             * Returns a collection of invalid items.
             * @return {{@link geocortex.forms.items.validation.ValidationResult}[]}
             */
            FormDefinition.prototype.validate = function () {
                return this.containerFormItem.validate();
            };
            /**
             * A flatten list of FormItemResult for all items in the FormDefinition.
             * @return {{@link geocortex.forms.items.FormItemResult}[]}
             */
            FormDefinition.prototype.getResults = function () {
                return this.containerFormItem._getResults();
            };
            /**
             * Destroy all the form ui dijits that were created.
             */
            FormDefinition.prototype.destroy = function () {
                this.containerFormItem._destroy();
            };
            /**
             * Get the contained FormItem with the given id or null if none can be found.
             */
            FormDefinition.prototype.getFormItemById = function (itemId) {
                return this.containerFormItem.getFormItemById(itemId);
            };
            return FormDefinition;
        }());
        forms.FormDefinition = FormDefinition;
    })(forms = geocortex.forms || (geocortex.forms = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../forms/FormDefinition.ts" />
/// <reference path="../../../../_Definitions/arcgis-js-api.d.ts" />
/// <reference path="../essentials/utilities/SiteResourceIdComparer.ts" />
/// <reference path="ActivityContext.ts" />
var geocortex;
(function (geocortex) {
    var workflow;
    (function (workflow) {
        var DefaultActivityHandlers;
        (function (DefaultActivityHandlers) {
            /** @private */
            function getPropertyIgnoreCase(objectWithProperties, prop) {
                for (var property in objectWithProperties) {
                    if (objectWithProperties.hasOwnProperty(property) && property.toLowerCase() === prop.toLowerCase()) {
                        return property;
                    }
                }
                return null;
            }
            DefaultActivityHandlers.getPropertyIgnoreCase = getPropertyIgnoreCase;
            /** @private */
            function handleReport(activityContext) {
                // Get input values
                var mapServiceId = activityContext.getValue("MapServiceId");
                var layerId = activityContext.getValue("LayerId");
                var layerName = activityContext.getValue("LayerName");
                var reportId = activityContext.getValue("ReportId");
                var report = null;
                var site = activityContext.getSite();
                // Let's try to find the report
                if (site && mapServiceId && (layerId || layerName) && reportId) {
                    var mapService = DefaultActivityHandlers.findMapServiceById(site, mapServiceId);
                    if (mapService) {
                        var layer = null;
                        if (layerId) {
                            // Find the layer by ID
                            layer = mapService.findLayerById(layerId);
                        }
                        else if (layerName) {
                            // Find the layer by Name
                            layer = mapService.findLayerByName(layerName);
                        }
                        if (layer != null) {
                            report = layer.findReportById(reportId);
                        }
                    }
                }
                // If no report was found, throw
                if (!report) {
                    activityContext.dispatcher().handleError(new Error("Cannot find report '" + reportId + "'"), activityContext);
                    return;
                }
                var query = new esri.tasks.Query();
                var reportParameters = new geocortex.essentials.ReportParameters();
                var showOpenReport = activityContext.getValue("ShowOpenReport");
                var geometry = activityContext.getValue("Geometry");
                var outSpatialReference = activityContext.getValue("OutSpatialReference");
                var text = activityContext.getValue("Text");
                var where = activityContext.getValue("Where");
                var outputFormat = activityContext.getValue("OutputFormat");
                var resolution = activityContext.getValue("Resolution");
                var customExtent = activityContext.getValue("CustomExtent");
                var spatialRelationship = activityContext.getValue("SpatialRelationship");
                var reportExtentType = activityContext.getValue("ReportExtentType");
                var notificationEmailAddress = activityContext.getValue("NotificationEmailAddress");
                var textFields = activityContext.getValue("TextFields");
                if (!reportExtentType) {
                    reportExtentType = geocortex.essentials.ReportParameters.CURRENT_EXTENT;
                }
                reportParameters.extentType = reportExtentType;
                if (outputFormat) {
                    reportParameters.outputFormat = outputFormat;
                }
                function findField(field) {
                    var result = null;
                    if (textFields && field) {
                        // Loop through the collection to find the correct field
                        for (var i = 0; i < textFields.length; i++) {
                            var wfField = textFields[i];
                            // REST API prefixes all text field IDs with tf_.
                            if (wfField.Key === field.displayName || "tf_" + wfField.Key === field.id || wfField.Key === field.id) {
                                result = wfField;
                                break;
                            }
                        }
                    }
                    return result;
                }
                // Add text fields
                if (report.textFields) {
                    // Loop through the fields
                    for (var fieldIndex in report.textFields) {
                        // Check if the field was provided by the activity
                        if (report.textFields.hasOwnProperty(fieldIndex)) {
                            var field = report.textFields[fieldIndex];
                            var activityField = findField(field);
                            if (activityField != null) {
                                // Add a copy of the field with the provided value
                                reportParameters.fields.push(new geocortex.essentials.TextField(field.id, field.displayName, activityField.Value, field.multiline));
                            }
                            else {
                                // Use the default field
                                reportParameters.fields.push(field);
                            }
                        }
                    }
                }
                if (notificationEmailAddress) {
                    reportParameters.notificationEmailAddress = notificationEmailAddress;
                }
                if (resolution) {
                    reportParameters.resolution = resolution;
                }
                if (customExtent) {
                    reportParameters.customExtent = customExtent;
                }
                query.spatialRelationship = geocortex.essentials.RestHelper._convertSpatialRelationshipFromDotnetIndex(spatialRelationship);
                if (geometry) {
                    query.geometry = geometry;
                }
                if (outSpatialReference) {
                    query.outSpatialReference = outSpatialReference;
                }
                if (text) {
                    query.text = text;
                }
                if (where) {
                    query.where = where;
                }
                report.run(query, reportParameters, function (sender) {
                    var reportHref = sender ? sender.href : null;
                    if (showOpenReport && reportHref && reportHref.length > 0) {
                        activityContext.dispatcher().handleOpenReportUrl(reportHref, activityContext);
                    }
                    // Set output values
                    activityContext.setValue("ResultUrl", reportHref);
                    // Complete the activity
                    activityContext.completeActivity();
                }, function (error) {
                    activityContext.dispatcher().handleError(new Error("Error running report '" + error.message + "'"), activityContext);
                });
            }
            DefaultActivityHandlers.handleReport = handleReport;
            /** @private */
            function showDebug(activityContext, isInput, callback) {
                var formDefinition = new geocortex.forms.FormDefinition();
                formDefinition.maxHeight.set(600);
                formDefinition.maxWidth.set(500);
                var argumentNames;
                if (isInput) {
                    formDefinition.title.set("Debug - Input Arguments for " + activityContext.getDisplayName());
                    formDefinition.containerFormItem.description.set("Input Arguments:");
                    argumentNames = activityContext.getInputNames();
                }
                else {
                    formDefinition.title.set("Debug - Output Arguments for " + activityContext.getDisplayName());
                    formDefinition.containerFormItem.description.set("Output Arguments:");
                    argumentNames = activityContext.getOutputNames();
                }
                if (argumentNames != null && argumentNames.length > 0) {
                    for (var i = 0; i < argumentNames.length; i++) {
                        var argumentName = argumentNames[i];
                        var value; // = processArgumentValue(activityContext, argumentName, isInput);
                        if (isInput) {
                            value = activityContext.getValue(argumentName);
                        }
                        else {
                            value = activityContext.getOutputValue(argumentName);
                        }
                        if (value) {
                            if (typeof (value) == "object") {
                                if (isInput) {
                                    value = activityContext.getJsonValue(argumentName);
                                }
                                else {
                                    value = activityContext.getOutputJsonValue(argumentName);
                                }
                            }
                        }
                        var textBox;
                        // Check is it's small enough for a textbox, otherwise use a text area
                        if ((!value) || ((String(value).length < 100) && (String(value).indexOf("\n") == -1))) {
                            textBox = new geocortex.forms.items.TextBoxFormItem(null, formDefinition);
                        }
                        else {
                            textBox = new geocortex.forms.items.TextAreaFormItem(null, formDefinition);
                            textBox.textboxHeight.set(100);
                        }
                        textBox.label = new geocortex.forms.items.LabelFormItem(null, formDefinition);
                        textBox.text.set(value);
                        textBox.textboxWidth.set(300);
                        textBox.label.text.set(argumentName);
                        textBox.readOnly.set(true);
                        formDefinition.containerFormItem.formItems.addItem(textBox);
                    }
                }
                var dispatcher = activityContext.dispatcher();
                // <jeffg> this smells like an egregious hack
                if ((dispatcher) && (typeof (dispatcher._showDebugHandler) == "function")) {
                    dispatcher._showDebugHandler(formDefinition, callback);
                }
                else if (callback) {
                    callback();
                }
            }
            DefaultActivityHandlers.showDebug = showDebug;
            /** @private */
            function handleGetBrowserUrl(activityContext) {
                activityContext.setValue("Url", window.location.href);
                activityContext.completeActivity();
            }
            DefaultActivityHandlers.handleGetBrowserUrl = handleGetBrowserUrl;
            /** @private */
            function handleExternalDelay(activityContext) {
                var delay = activityContext.getValue("Milliseconds");
                if (delay != null) {
                    setTimeout(function () {
                        activityContext.completeActivity();
                    }, delay);
                }
                else {
                    // Milliseconds was null
                    throw new Error("External Delay: required Milliseconds argument was not supplied.");
                }
            }
            DefaultActivityHandlers.handleExternalDelay = handleExternalDelay;
            /** @private */
            function handleGetExternalTimeInfo(activityContext) {
                var dt = new Date();
                // Silverlight and JavaScript offsets are inverses so to
                // match GVS this offset is converted to milliseconds and inverted
                activityContext.setValue("UtcOffset", dt.getTimezoneOffset() * -60000);
                activityContext.completeActivity();
            }
            DefaultActivityHandlers.handleGetExternalTimeInfo = handleGetExternalTimeInfo;
            /** @private */
            function handleWaitForGeoprocessorJobComplete(activityContext) {
                var geoprocessorUrl = activityContext.getValue("GeoprocessorUrl");
                var token = activityContext.getValue("Token");
                var proxyUrl = activityContext.getValue("ProxyURL");
                var updateDelay = activityContext.getValue("UpdateDelay");
                var jobId = activityContext.getValue("JobId");
                var handled = false;
                // Require GeoprocessorUrl and JobId arguments
                if (!geoprocessorUrl) {
                    throw new Error("GeoprocessorUrl parameter is missing.");
                }
                if (!jobId) {
                    throw new Error("JobId parameter is missing.");
                }
                var geoprocessor = new esri.tasks.Geoprocessor(geoprocessorUrl);
                // Note that ESRI's JavaScript API doesn't support proxyUrl or token the same way
                //geoprocessor.token = token;
                //geoprocessor.proxyURL = proxyUrl;
                if (updateDelay > 0) {
                    geoprocessor.setUpdateDelay(updateDelay);
                }
                dojo.connect(geoprocessor, "onError", function (event) {
                    // This doesn't mean the job failed. It means the check status call failed.
                    activityContext.setValue("Result", geocortex.workflow.DefaultActivityHandlers._getJobStatusCode(esri.tasks.JobInfo.STATUS_FAILED));
                    activityContext.completeActivity();
                });
                dojo.connect(geoprocessor, "onStatusUpdate", function (jobInfo) {
                    // If it's already handled, we should exit (this might be due to the timer mechanism in Flex and the single threading issues)
                    if (handled) {
                        return;
                    }
                    var status = jobInfo.jobStatus;
                    if ((status == esri.tasks.JobInfo.STATUS_CANCELLED) ||
                        (status == esri.tasks.JobInfo.STATUS_DELETED) ||
                        (status == esri.tasks.JobInfo.STATUS_FAILED) ||
                        (status == esri.tasks.JobInfo.STATUS_SUCCEEDED) ||
                        (status == esri.tasks.JobInfo.STATUS_TIMED_OUT)) {
                        handled = true;
                        // The job has completed
                        // This doesn't mean that the job was successful, only that it is done processing.
                        activityContext.setValue("Result", geocortex.workflow.DefaultActivityHandlers._getJobStatusCode(status));
                        activityContext.completeActivity();
                    }
                    else {
                        // Must keep on checking
                        window.setTimeout(function () { geoprocessor.checkJobStatus(jobId); }, updateDelay);
                    }
                });
                // Check the job status
                geoprocessor.checkJobStatus(jobId);
            }
            DefaultActivityHandlers.handleWaitForGeoprocessorJobComplete = handleWaitForGeoprocessorJobComplete;
            /** @private */
            function _getJobStatusCode(status) {
                switch (status) {
                    case "esriJobNew":
                        return 0;
                    case "esriJobSubmitted":
                        return 1;
                    case "esriJobWaiting":
                        return 2;
                    case "esriJobExecuting":
                        return 3;
                    case "esriJobSucceeded":
                        return 4;
                    case "esriJobFailed":
                        return 5;
                    case "esriJobTimedOut":
                        return 6;
                    case "esriJobCancelling":
                        return 7;
                    case "esriJobCancelled":
                        return 8;
                    case "esriJobDeleting":
                        return 9;
                    case "esriJobDeleted":
                        return 10;
                    default:
                        return -1;
                }
            }
            DefaultActivityHandlers._getJobStatusCode = _getJobStatusCode;
            /** @private */
            function handleGetLayerInfoByProperty(activityContext) {
                // If we aren't given an activity context, we will not have enough information to get the map service info.
                if (!activityContext) {
                    throw new Error("Get Map Service Info: required context was not supplied.");
                }
                // Get argument values
                var propertyName = activityContext.getValue("PropertyName");
                if (propertyName == null) {
                    throw new Error("Provide a Property Name: No property name available.");
                }
                // Get the site
                var site = activityContext.getSite();
                if (!site) {
                    throw new Error("Set Layer Visibility: No site available.");
                }
                var layersInfo = [];
                // Get the map services of the current site
                var mapServices = site.essentialsMap.mapServices;
                var tmpLayerInfo = { mapServiceUrl: "", mapServiceId: "", token: "", isVisible: false, isDynamic: false, propertyValue: null, id: "", name: "", displayName: "", layerUrl: "" };
                var dynamicLayerInfo = null;
                for (var i = 0; i < mapServices.length; i++) {
                    // Get current map service layers and tables
                    var layers = mapServices[i].layers.concat(mapServices[i].tables);
                    for (var j = 0; j < layers.length; j++) {
                        if (layers[j].properties[propertyName] != undefined) {
                            tmpLayerInfo.mapServiceUrl = mapServices[i].serviceUrl;
                            tmpLayerInfo.mapServiceId = mapServices[i].id;
                            tmpLayerInfo.token = mapServices[i].serviceToken;
                            tmpLayerInfo.isVisible = layers[j].isVisible();
                            tmpLayerInfo.isDynamic = layers[j].isDynamic;
                            tmpLayerInfo.propertyValue = layers[j].properties[propertyName];
                            tmpLayerInfo.id = layers[j].id;
                            tmpLayerInfo.name = layers[j].name;
                            tmpLayerInfo.displayName = layers[j].displayName;
                            if (mapServices[i].mapServiceType === geocortex.essentials.MapServiceType.FEATURE) {
                                tmpLayerInfo.layerUrl = tmpLayerInfo.mapServiceUrl;
                            }
                            else {
                                tmpLayerInfo.layerUrl = tmpLayerInfo.mapServiceUrl + "/" + (!tmpLayerInfo.isDynamic ? tmpLayerInfo.id : "dynamicLayer");
                            }
                            // GVH-3753
                            if (tmpLayerInfo.isDynamic) {
                                var serviceLayer = mapServices[0].serviceLayer;
                                if (serviceLayer && serviceLayer.dynamicLayerInfos) {
                                    for (var k = 0; k < serviceLayer.dynamicLayerInfos.length; k++) {
                                        dynamicLayerInfo = serviceLayer.dynamicLayerInfos[k];
                                        if (dynamicLayerInfo && dynamicLayerInfo.id.toString() === tmpLayerInfo.id) {
                                            if (dynamicLayerInfo.source) {
                                                tmpLayerInfo["layerSourceJson"] = JSON.stringify(dynamicLayerInfo.source.toJson());
                                            }
                                            break;
                                        }
                                    }
                                }
                            }
                            layersInfo.push(tmpLayerInfo);
                            tmpLayerInfo = { mapServiceUrl: "", mapServiceId: "", token: "", isVisible: false, isDynamic: false, propertyValue: null, id: "", name: "", displayName: "", layerUrl: "" };
                        }
                    }
                }
                activityContext.setValue("LayersInfo", layersInfo);
                // Complete the activity
                activityContext.completeActivity();
            }
            DefaultActivityHandlers.handleGetLayerInfoByProperty = handleGetLayerInfoByProperty;
        })(DefaultActivityHandlers = workflow.DefaultActivityHandlers || (workflow.DefaultActivityHandlers = {}));
    })(workflow = geocortex.workflow || (geocortex.workflow = {}));
})(geocortex || (geocortex = {}));
/// <reference path="DefaultActivityHandlers.ts" />
var geocortex;
(function (geocortex) {
    var workflow;
    (function (workflow) {
        var DefaultActivityHandlers;
        (function (DefaultActivityHandlers) {
            /** @private */
            function handleAlert(activityContext) {
                var title = activityContext.getValue("Title");
                var text = activityContext.getValue("Text");
                alert(text);
                activityContext.completeActivity();
            }
            DefaultActivityHandlers.handleAlert = handleAlert;
            /** @private */
            function handleConfirm(activityContext) {
                // Get input values
                var text = activityContext.getValue("Text");
                // Perform the action
                var result = confirm(text);
                if (result == null) {
                    result = false;
                }
                // Set output values
                activityContext.setValue("Result", result);
                // Complete the activity
                activityContext.completeActivity();
            }
            DefaultActivityHandlers.handleConfirm = handleConfirm;
            /** @private */
            function handlePrompt(activityContext) {
                //var title = activityContext.getValue("Title");
                var description = activityContext.getValue("Description");
                var defaultText = activityContext.getValue("DefaultText");
                var result = prompt(description, defaultText);
                activityContext.setValue("Result", result);
                activityContext.completeActivity();
            }
            DefaultActivityHandlers.handlePrompt = handlePrompt;
        })(DefaultActivityHandlers = workflow.DefaultActivityHandlers || (workflow.DefaultActivityHandlers = {}));
    })(workflow = geocortex.workflow || (geocortex.workflow = {}));
})(geocortex || (geocortex = {}));
/// <reference path="DefaultActivityHandlers.ts" />
var geocortex;
(function (geocortex) {
    var workflow;
    (function (workflow) {
        var DefaultActivityHandlers;
        (function (DefaultActivityHandlers) {
            /** @private */
            function handleSetLayerProperty(activityContext) {
                var friendlyMethodName = "Set Layer Property";
                // Get input values
                var mapServiceId = activityContext.getValue("MapServiceId");
                var layerId = activityContext.getValue("LayerId");
                var layerName = activityContext.getValue("LayerName");
                var propertyName = activityContext.getValue("PropertyName");
                var propertyValue = activityContext.getValue("Value");
                if (!mapServiceId) {
                    throw new Error(friendlyMethodName + ": required MapServiceId argument was not supplied.");
                }
                if (!layerId && !layerName) {
                    throw new Error(friendlyMethodName + ": a LayerId or a LayerName argument must be supplied.");
                }
                // Get the site
                var site = activityContext.getSite();
                if (!site) {
                    throw new Error(friendlyMethodName + ": No site available.");
                }
                // Find the map service by the id provided by activity context.
                var mapService = DefaultActivityHandlers.findMapServiceById(site, mapServiceId);
                if (!mapService || !mapService.serviceLayer) {
                    throw new Error(friendlyMethodName + ": Unable to find map service with ID '" + mapServiceId + "'");
                }
                var layer = null;
                if (layerId) {
                    layer = mapService.findLayerById(layerId);
                }
                else {
                    layer = mapService.findLayerByName(layerName);
                }
                if (!layer) {
                    throw new Error(friendlyMethodName + ": Unable to find layer with Name '" + layerName + "' or ID '" + layerId + "'.");
                }
                var propIgnoreCase = DefaultActivityHandlers.getPropertyIgnoreCase(layer, propertyName);
                if (propIgnoreCase) {
                    layer[propIgnoreCase] = propertyValue;
                }
                else {
                    // Try matching a property in the properties dictionary.
                    propIgnoreCase = DefaultActivityHandlers.getPropertyIgnoreCase(layer.properties, propertyName);
                    if (propIgnoreCase) {
                        layer.properties[propIgnoreCase] = propertyValue;
                    }
                    else {
                        throw new Error(friendlyMethodName + ": Layer does not support the property '" + propertyName + "'.");
                    }
                }
                activityContext.completeActivity();
            }
            DefaultActivityHandlers.handleSetLayerProperty = handleSetLayerProperty;
            /** @private */
            function handleGetLayerProperty(activityContext) {
                var friendlyMethodName = "Get Layer Property";
                // Get input values
                var mapServiceId = activityContext.getValue("MapServiceId");
                var layerId = activityContext.getValue("LayerId");
                var layerName = activityContext.getValue("LayerName");
                var propertyName = activityContext.getValue("PropertyName");
                if (!mapServiceId) {
                    throw new Error(friendlyMethodName + ": required MapServiceId argument was not supplied.");
                }
                if (!layerId && !layerName) {
                    throw new Error(friendlyMethodName + ": a LayerId or a LayerName argument must be supplied.");
                }
                // Get the site
                var site = activityContext.getSite();
                if (!site) {
                    throw new Error(friendlyMethodName + ": No site available.");
                }
                // Find the map service by the id provided by activity context.
                var mapService = DefaultActivityHandlers.findMapServiceById(site, mapServiceId);
                if (!mapService || !mapService.serviceLayer) {
                    throw new Error(friendlyMethodName + ": Unable to find map service with ID '" + mapServiceId + "'");
                }
                var layer = null;
                if (layerId) {
                    layer = mapService.findLayerById(layerId);
                }
                else {
                    layer = mapService.findLayerByName(layerName);
                }
                if (!layer) {
                    throw new Error(friendlyMethodName + ": Unable to find layer with Name '" + layerName + "' or ID '" + layerId + "'.");
                }
                var propIgnoreCase = DefaultActivityHandlers.getPropertyIgnoreCase(layer, propertyName);
                if (propIgnoreCase) {
                    activityContext.setValue("Value", layer[propIgnoreCase]);
                }
                else {
                    // Try matching a property in the properties dictionary.
                    propIgnoreCase = DefaultActivityHandlers.getPropertyIgnoreCase(layer.properties, propertyName);
                    if (propIgnoreCase) {
                        activityContext.setValue("Value", layer.properties[propIgnoreCase]);
                    }
                    else {
                        throw new Error(friendlyMethodName + ": Layer does not support the property '" + propertyName + "'.");
                    }
                }
                activityContext.completeActivity();
            }
            DefaultActivityHandlers.handleGetLayerProperty = handleGetLayerProperty;
            /** @private */
            function handleGetLayerVisibility(activityContext) {
                // Get input values
                var mapServiceId = activityContext.getValue("MapServiceId");
                var layerId = activityContext.getValue("LayerId");
                var layerName = activityContext.getValue("LayerName");
                var effectiveVisibility = activityContext.getValue("EffectiveVisibility");
                if (!mapServiceId) {
                    throw new Error("Get Layer Visibility: required MapServiceId argument was not supplied.");
                }
                if (!layerId && !layerName) {
                    throw new Error("Get Layer Visibility: a LayerId or a LayerName argument must be supplied.");
                }
                // Get the site
                var site = activityContext.getSite();
                if (!site) {
                    throw new Error("Get Layer Visibility: No site available.");
                }
                // Iterate over all map services
                var mapService = DefaultActivityHandlers.findMapServiceById(site, mapServiceId);
                if (!mapService) {
                    throw new Error("Get Layer Visibility: Unable to find map service with ID '" + mapServiceId + "'");
                }
                var layer = null;
                if (layerId) {
                    // Find the layer by ID
                    layer = mapService.findLayerById(layerId);
                }
                else if (layerName) {
                    // Find the layer by Name
                    layer = mapService.findLayerByName(layerName);
                }
                if (!layer) {
                    throw new Error("Get Layer Visibility: Unable to find layer with ID '" + layerId + "'" + " in map service with ID '" + mapServiceId + "'");
                }
                var visibility = layer.isVisible();
                if (effectiveVisibility) {
                    visibility = false;
                    // Determine layer effective visibility
                    if (layer.isVisible() && mapService.isVisible() && layer.withinScaleRange(null)) {
                        var visibleLayers = mapService.getVisibleLayers();
                        for (var i = 0; i < visibleLayers.length; i++) {
                            var visibleLayerName = visibleLayers[i];
                            if (visibleLayerName == layer.id) {
                                visibility = true;
                                break;
                            }
                        }
                    }
                }
                activityContext.setValue("Visible", visibility);
                activityContext.completeActivity();
            }
            DefaultActivityHandlers.handleGetLayerVisibility = handleGetLayerVisibility;
            /** @private */
            function handleSetLayerVisibility(activityContext) {
                // Get input values
                var mapServiceId = activityContext.getValue("MapServiceId");
                var layerId = activityContext.getValue("LayerId");
                var layerName = activityContext.getValue("LayerName");
                var visible = activityContext.getValue("Visible");
                if (!mapServiceId) {
                    throw new Error("Set Layer Visibility: required MapServiceId argument was not supplied.");
                }
                if (!layerId && !layerName) {
                    throw new Error("Set Layer Visibility: a LayerId or a LayerName argument must be supplied.");
                }
                if (visible === null) {
                    throw new Error("Set Layer Visibility: required Visible argument was not supplied.");
                }
                // Get the site
                var site = activityContext.getSite();
                if (!site) {
                    throw new Error("Set Layer Visibility: No site available.");
                }
                var mapService = DefaultActivityHandlers.findMapServiceById(site, mapServiceId);
                if (!mapService) {
                    throw new Error("Set Layer Visibility: Unable to find map service with ID '" + mapServiceId + "'");
                }
                var layer = null;
                if (layerId) {
                    layer = mapService.findLayerById(layerId);
                    if (!layer) {
                        throw new Error("Set Layer Visibility: Unable to find layer with ID '" + layerId + "'" + " in map service with ID '" + mapServiceId + "'");
                    }
                }
                else if (layerName) {
                    layer = mapService.findLayerByName(layerName);
                    if (!layer) {
                        throw new Error("Set Layer Visibility: Unable to find layer with name '" + layerName + "'" + " in map service with ID '" + mapServiceId + "'");
                    }
                }
                else {
                    throw new Error("Set Layer Visibility: must define layer ID or name");
                }
                layer.setVisibility(visible);
                activityContext.completeActivity();
            }
            DefaultActivityHandlers.handleSetLayerVisibility = handleSetLayerVisibility;
            /** @private */
            function handleGetLayerDefinition(activityContext) {
                // Get input values
                var mapServiceId = activityContext.getValue("MapServiceId");
                var layerId = activityContext.getValue("LayerId");
                var layerName = activityContext.getValue("LayerName");
                if (!mapServiceId) {
                    throw new Error("Get Layer Definition: required MapServiceId argument was not supplied.");
                }
                if (!layerId && !layerName) {
                    throw new Error("Get Layer Definition: a LayerId or a LayerName argument must be supplied.");
                }
                var definition = null;
                // Get the site
                var site = activityContext.getSite();
                if (site) {
                    // Iterate over all map services
                    var mapService = DefaultActivityHandlers.findMapServiceById(site, mapServiceId);
                    if (mapService && mapService.serviceLayer) {
                        if (!layerId && layerName) {
                            var layer = mapService.findLayerByName(layerName);
                            if (layer) {
                                layerId = layer.id;
                            }
                            else {
                                throw new Error("Set Layer Definition: Unable to find layer with Name '" + layerName + "'.");
                            }
                        }
                        if (mapService.serviceLayer instanceof esri.layers.ArcGISDynamicMapServiceLayer) {
                            if (mapService.serviceLayer.layerDefinitions) {
                                definition = mapService.serviceLayer.layerDefinitions[parseInt(layerId)];
                            }
                        }
                        else if (mapService.serviceLayer instanceof esri.layers.FeatureLayer) {
                            definition = mapService.serviceLayer.getDefinitionExpression();
                        }
                    }
                }
                activityContext.setValue("Definition", definition);
                activityContext.completeActivity();
            }
            DefaultActivityHandlers.handleGetLayerDefinition = handleGetLayerDefinition;
            /** @private */
            function handleSetLayerDefinition(activityContext) {
                // Get input values
                var mapServiceId = activityContext.getValue("MapServiceId");
                var layerId = activityContext.getValue("LayerId");
                var layerName = activityContext.getValue("LayerName");
                var definition = activityContext.getValue("Definition");
                if (!mapServiceId) {
                    throw new Error("Set Layer Definition: required MapServiceId argument was not supplied.");
                }
                if (!layerId && !layerName) {
                    throw new Error("Set Layer Definition: a LayerId or a LayerName argument must be supplied.");
                }
                // Get the site
                var site = activityContext.getSite();
                if (!site) {
                    throw new Error("Set Layer Visibility: No site available.");
                }
                // Iterate over all map services
                var mapService = DefaultActivityHandlers.findMapServiceById(site, mapServiceId);
                if (!mapService || !mapService.serviceLayer) {
                    throw new Error("Set Layer Definition: Unable to find map service with ID '" + mapServiceId + "'");
                }
                if (!layerId && layerName) {
                    var layer = mapService.findLayerByName(layerName);
                    if (layer) {
                        layerId = layer.id;
                    }
                    else {
                        throw new Error("Set Layer Definition: Unable to find layer with Name '" + layerName + "'.");
                    }
                }
                // This only works on AGS dynamic layers and feature layers
                if (mapService.serviceLayer instanceof esri.layers.ArcGISDynamicMapServiceLayer) {
                    var dynamicServiceLayer = mapService.serviceLayer;
                    if (!dynamicServiceLayer.layerDefinitions) {
                        dynamicServiceLayer.layerDefinitions = [];
                    }
                    dynamicServiceLayer.layerDefinitions[parseInt(layerId)] = definition;
                    dynamicServiceLayer.setLayerDefinitions(dynamicServiceLayer.layerDefinitions, true);
                }
                else if (mapService.serviceLayer instanceof esri.layers.FeatureLayer) {
                    mapService.serviceLayer.setDefinitionExpression(definition);
                }
                else {
                    throw new Error("Set Layer Definition: Map service type does not support layer definitions.");
                }
                activityContext.completeActivity();
            }
            DefaultActivityHandlers.handleSetLayerDefinition = handleSetLayerDefinition;
            /** @private */
            function handleGetGraphicsLayerContent(activityContext) {
                // Get input values
                var layerId = activityContext.getValue("GraphicsLayerId");
                var geometryType = activityContext.getValue("GeometryType");
                var esriGeometryType = null;
                if (geometryType !== null) {
                    if (geometryType === 0) {
                        esriGeometryType = "extent";
                    }
                    else if (geometryType === 1) {
                        esriGeometryType = "multipoint";
                    }
                    else if (geometryType === 2) {
                        esriGeometryType = "point";
                    }
                    else if (geometryType === 3) {
                        esriGeometryType = "polygon";
                    }
                    else if (geometryType === 4) {
                        esriGeometryType = "polyline";
                    }
                }
                // Get the map
                var map = activityContext.getEsriMap();
                if (map != null && map.graphicsLayerIds != null) {
                    // Find the first matching graphics layer
                    for (var i = 0; i < map.graphicsLayerIds.length; i++) {
                        if (layerId == map.graphicsLayerIds[i]) {
                            var gLayer = map.getLayer(map.graphicsLayerIds[i]);
                            if (gLayer != null && gLayer.graphics != null) {
                                // Construct a feature set 
                                // Clone each graphic to avoid serialization issues
                                var featureSet = new esri.tasks.FeatureSet();
                                for (var j = 0; j < gLayer.graphics.length; j++) {
                                    var graphic = gLayer.graphics[j];
                                    // Filter by geometry type
                                    if (esriGeometryType !== null) {
                                        if (graphic.geometry === null) {
                                            continue;
                                        }
                                        if (esriGeometryType !== graphic.geometry.type) {
                                            continue;
                                        }
                                    }
                                    var graphicCopy = new esri.Graphic(graphic.geometry, null, graphic.attributes, null);
                                    featureSet.features.push(graphicCopy);
                                }
                                activityContext.setValue("Features", featureSet);
                            }
                            break;
                        }
                    }
                }
                activityContext.completeActivity();
            }
            DefaultActivityHandlers.handleGetGraphicsLayerContent = handleGetGraphicsLayerContent;
            /** @private */
            function handleUpdateGraphicsLayer(activityContext) {
                // Get input values
                // NOTE: RendererTakesPrecedence is not supported in Esri's JavaScript API
                var layerId = activityContext.getValue("GraphicsLayerId");
                var removeAllFeatures = !!activityContext.getValue("RemoveAllFeatures");
                var featureSet = activityContext.getValue("FeatureSet");
                var rendererJson = activityContext.getValue("RendererJson");
                // Get the map
                var map = activityContext.getEsriMap();
                if (map == null) {
                    throw new Error("Update Graphics Layer: No map available.");
                }
                // Find or create the graphics layer
                var addLayer = false;
                var layer = DefaultActivityHandlers.findMapServiceByMap(map, layerId);
                if (!layer) {
                    // Create the layer
                    layer = new esri.layers.GraphicsLayer({ id: layerId });
                    addLayer = true;
                }
                else {
                    // Require a graphics layer
                    if (!(layer instanceof esri.layers.GraphicsLayer)) {
                        throw new Error("Update Graphics Layer: The layer '" + layerId + "' is not a GraphicsLayer");
                    }
                }
                try {
                    layer.suspend();
                    // Clear all graphics if requested to do so
                    if (removeAllFeatures) {
                        layer.clear();
                    }
                    // Insert graphics on top, assuming the FeatureSet is in the desired order (with zero being the graphic on top)
                    if (featureSet && featureSet.features) {
                        for (var i = featureSet.features.length - 1; i >= 0; --i) {
                            layer.add(featureSet.features[i]);
                        }
                    }
                    // Add/update the renderer if specified
                    if (rendererJson) {
                        layer.renderer = esri.renderer.fromJson(JSON.parse(rendererJson));
                    }
                    // Add the graphics layer if it doesn't already exist in the map
                    if (addLayer) {
                        map.addLayer(layer);
                    }
                }
                finally {
                    layer.resume();
                }
                activityContext.completeActivity();
            }
            DefaultActivityHandlers.handleUpdateGraphicsLayer = handleUpdateGraphicsLayer;
        })(DefaultActivityHandlers = workflow.DefaultActivityHandlers || (workflow.DefaultActivityHandlers = {}));
    })(workflow = geocortex.workflow || (geocortex.workflow = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var workflow;
    (function (workflow) {
        var DefaultActivityHandlers;
        (function (DefaultActivityHandlers) {
            /** @private */
            function findMapServiceById(site, serviceId) {
                if (serviceId && site && site.essentialsMap && site.essentialsMap.mapServices) {
                    return geocortex.essentials.utilities.SiteResourceIdComparer.lookUp(site.essentialsMap.mapServices, serviceId);
                }
                return null;
            }
            DefaultActivityHandlers.findMapServiceById = findMapServiceById;
            /** @private */
            function findMapServiceByMap(map, serviceId) {
                if (!map || !serviceId) {
                    return null;
                }
                // Search regular layers
                if (map.layerIds != null) {
                    for (var i = 0; i < map.layerIds.length; i++) {
                        var layer = map.getLayer(map.layerIds[i]);
                        if (layer != null && geocortex.essentials.utilities.SiteResourceIdComparer.equals(layer.id, serviceId)) {
                            // Found matching map service
                            return layer;
                        }
                    }
                }
                // Search graphics layers
                if (map.graphicsLayerIds != null) {
                    for (var i = 0; i < map.graphicsLayerIds.length; i++) {
                        var layer = map.getLayer(map.graphicsLayerIds[i]);
                        if (layer != null && geocortex.essentials.utilities.SiteResourceIdComparer.equals(layer.id, serviceId)) {
                            // Found matching map service
                            return layer;
                        }
                    }
                }
                return null;
            }
            DefaultActivityHandlers.findMapServiceByMap = findMapServiceByMap;
            /** @private */
            function handleRemoveMapService(activityContext) {
                // Get input values
                var mapServiceId = activityContext.getValue("MapServiceId");
                // Get the map
                var map = activityContext.getEsriMap();
                if (map == null) {
                    throw new Error("Remove Map Service: No map available.");
                }
                // Remove the Esri layer
                var esriLayer = findMapServiceByMap(map, mapServiceId);
                if (esriLayer) {
                    map.removeLayer(esriLayer);
                    // Remove the Essentials map service
                    var site = activityContext.getSite();
                    if (site && site.essentialsMap && site.essentialsMap.mapServices) {
                        site.essentialsMap.removeServiceLayer(esriLayer);
                    }
                }
                // Complete the activity
                activityContext.completeActivity();
            }
            DefaultActivityHandlers.handleRemoveMapService = handleRemoveMapService;
            /** @private */
            function handleSetImageServiceInfo(activityContext) {
                var imageServiceId = activityContext.getValue("ImageServiceId");
                var bandIds = activityContext.getValue("BandIds");
                var mosaicRuleObj = activityContext.getValue("MosaicRule");
                var renderingRuleObj = activityContext.getValue("RenderingRule");
                // Get the map
                var map = activityContext.getEsriMap();
                if (map == null) {
                    throw new Error("Set Image Service Info: No map available.");
                }
                require(["esri/layers/RasterFunction"], function (RasterFunction) {
                    var mapService = findMapServiceByMap(map, imageServiceId);
                    if (mapService instanceof esri.layers.ArcGISImageServiceLayer) {
                        var imageService = mapService;
                        if (bandIds) {
                            imageService.setBandIds(bandIds, true);
                        }
                        if (mosaicRuleObj) {
                            var mosaicRule = new esri.layers.MosaicRule(mosaicRuleObj);
                            if (!mosaicRule.method) {
                                // If the mosaic method was not specified reset the rule
                                mosaicRule = imageService.defaultMosaicRule;
                            }
                            imageService.setMosaicRule(mosaicRule, true);
                        }
                        if (renderingRuleObj) {
                            var rasterFunction = new esri.layers.RasterFunction(renderingRuleObj);
                            if (!rasterFunction.functionName) {
                                // If the raster function was not specified reset the rule
                                rasterFunction = null;
                            }
                            imageService.setRenderingRule(rasterFunction, true);
                        }
                        // Redraw the service
                        imageService.refresh();
                    }
                    activityContext.completeActivity();
                });
            }
            DefaultActivityHandlers.handleSetImageServiceInfo = handleSetImageServiceInfo;
            /** @private */
            function handleSetMapServiceVisibility(activityContext) {
                // Get input values
                var mapServiceId = activityContext.getValue("MapServiceId");
                var visible = activityContext.getValue("Visible");
                if (mapServiceId == null) {
                    throw new Error("Set Map Service Visibility: required MapServiceId argument was not supplied.");
                }
                if (visible == null) {
                    throw new Error("Set Map Service Visibility: required Visible argument was not supplied.");
                }
                // Get the map
                var map = activityContext.getEsriMap();
                // Get the site
                var site = activityContext.getSite();
                if (map == null) {
                    throw new Error("Set Map Service Visibility: No map available.");
                }
                var mapService = null;
                mapService = findMapServiceByMap(map, mapServiceId);
                if (mapService == null) {
                    throw new Error("Set Map Service Visibility: Unable to find map service with ID '" + mapServiceId + "'");
                }
                mapService.setVisibility(visible);
                activityContext.completeActivity();
                if (site && mapServiceId) {
                    var essentialsMapService = findMapServiceById(site, mapServiceId);
                    dojo.publish("MapServiceVisibilityChangedEvent", essentialsMapService);
                }
            }
            DefaultActivityHandlers.handleSetMapServiceVisibility = handleSetMapServiceVisibility;
            /** @private */
            function handleGetMapServiceInfo(activityContext) {
                // NOTE: This handler only supports the LayerId out argument for ArcGISDynamicMapServicLayer and ArcGISTiledMapServiceLayer map services
                // NOTE: This handler does not support the ProxyUrl out argument
                // If we aren't given an activity context, we will not have enough information to get the map service info.
                if (!activityContext) {
                    throw new Error("Get Map Service Info: required context was not supplied.");
                }
                // Get the MapServiceId and the Layer Name we will want to get the MapServiceUrl and Layer Id for.
                var mapServiceId = activityContext.getValue("MapServiceId");
                var layerName = activityContext.getValue("LayerName");
                // We will require the mapServiceId to know which one we want to get the MapServiceUrl for.
                if (mapServiceId == null) {
                    throw new Error("Get Map Service Info: required MapServiceId argument was not supplied.");
                }
                var mapServiceUrl = null;
                var token = null;
                var layerId = null;
                var source = null;
                var visible = false;
                // Get the map
                var map = activityContext.getEsriMap();
                if (map == null) {
                    throw new Error("Get Map Service Info: No map available.");
                }
                var site = activityContext.getSite();
                var mapService = null;
                var essMapService = null;
                // Find the map service in the site
                // The site provides us convenient access to the token. If we use the Esri map control we'd have to parse it out of the url.
                if (site != null && site.essentialsMap != null) {
                    essMapService = findMapServiceById(site, mapServiceId);
                    if (essMapService != null) {
                        mapService = essMapService.serviceLayer;
                        mapServiceUrl = essMapService.serviceUrl;
                        token = essMapService.findServiceToken();
                        visible = essMapService.isVisible();
                    }
                }
                if (mapService == null) {
                    // Fallback. Find the map service in the Esri map control.
                    // This code will only run if the service was added at runtime. This code does not obtain the token.
                    mapService = findMapServiceByMap(map, mapServiceId);
                    if (mapService) {
                        mapServiceUrl = mapService.url;
                        if (typeof mapService.visible === "boolean") {
                            visible = mapService.visible;
                        }
                    }
                }
                // Try to find the layer matching the specified layer name
                // NOTE: this only works for ArcGISDynamicMapServicLayer and ArcGISTiledMapServiceLayer map services
                if (layerName != null) {
                    var found = false;
                    if (mapService.supportsDynamicLayers && mapService.dynamicLayerInfos) {
                        var layerInfos = mapService.dynamicLayerInfos;
                        for (var i = 0; i < layerInfos.length; i++) {
                            var layerInfo = layerInfos[i];
                            if (layerInfo.name === layerName || "{0}".format(layerInfo.id) === layerName) {
                                found = true;
                                // We will always return "dynamicLayer" as the ID of the layer so that it can be
                                // appended to the map service URL to form a valid query URL.
                                layerId = "dynamicLayer";
                                source = layerInfo.source;
                                break;
                            }
                        }
                    }
                    if (!found && mapService.layerInfos) {
                        var layerInfos = mapService.layerInfos;
                        for (var i = 0; i < layerInfos.length; i++) {
                            var layerInfo = layerInfos[i];
                            if (layerInfo != null && layerInfo.id != null && layerInfo.name == layerName) {
                                found = true;
                                layerId = layerInfo.id;
                                break;
                            }
                        }
                    }
                    // Look for tables
                    if (!found && essMapService) {
                        var table = essMapService.findLayerOrTableByName(layerName);
                        if (table) {
                            found = true;
                            layerId = table.id;
                        }
                    }
                }
                // Set the result values
                activityContext.setValue("MapServiceUrl", mapServiceUrl);
                activityContext.setValue("Token", token);
                activityContext.setValue("LayerId", layerId);
                activityContext.setValue("Source", source);
                activityContext.setValue("Visible", visible);
                activityContext.completeActivity();
            }
            DefaultActivityHandlers.handleGetMapServiceInfo = handleGetMapServiceInfo;
            /** @private */
            function handleSetMapServiceProperty(activityContext) {
                var friendlyMethodName = "Set Map Service Property";
                // Get input values 
                var mapServiceId = activityContext.getValue("MapServiceId");
                var propertyName = activityContext.getValue("PropertyName");
                var propertyValue = activityContext.getValue("Value");
                if (!mapServiceId) {
                    throw new Error("{0}: required MapServiceId argument was not supplied.".format(friendlyMethodName));
                }
                if (!propertyName) {
                    throw new Error("{0}: required PropertyName argument was not supplied.".format(friendlyMethodName));
                }
                var map = activityContext.getEsriMap();
                if (!map) {
                    throw new Error("{0}: no map available.".format(friendlyMethodName));
                }
                var serviceLayer = findMapServiceByMap(map, mapServiceId);
                if (!serviceLayer) {
                    throw new Error("{0}: unable to find map service with ID '{1}'.".format(friendlyMethodName, mapServiceId));
                }
                if (propertyName.toLowerCase() === "gdbversion") {
                    if (serviceLayer instanceof esri.layers.FeatureLayer) {
                        // Set GDB version of a feature layer if its versioned
                        if (!serviceLayer.isDataVersioned) {
                            throw new Error("{0}: map service with ID '{1}' is not versioned.".format(friendlyMethodName, mapServiceId));
                        }
                        serviceLayer.setGDBVersion(propertyValue);
                    }
                    else if (serviceLayer instanceof esri.layers.ArcGISDynamicMapServiceLayer) {
                        serviceLayer.setGDBVersion(propertyValue);
                    }
                    else {
                        throw new Error("{0}: map service with ID '{1}' does not support GDB version.".format(friendlyMethodName, mapServiceId));
                    }
                }
                else if (propertyName.toLowerCase() === "visible") {
                    // The set method of the visible property does not use the same
                    // name, so check for it explicitly
                    serviceLayer.setVisibility(propertyValue);
                }
                else {
                    // Attempt to find a set method for a property, assumes the 
                    // property name is the same as in the set method name
                    propertyName = "set" + propertyName.toLowerCase();
                    var setMethod = null;
                    for (var property in serviceLayer) {
                        if (property.toLowerCase() === propertyName) {
                            setMethod = property;
                            break;
                        }
                    }
                    if (!setMethod) {
                        throw new Error("{0}: map service property '{1}' does not exist.".format(friendlyMethodName, propertyName));
                    }
                    serviceLayer[setMethod](propertyValue);
                }
                activityContext.completeActivity();
            }
            DefaultActivityHandlers.handleSetMapServiceProperty = handleSetMapServiceProperty;
        })(DefaultActivityHandlers = workflow.DefaultActivityHandlers || (workflow.DefaultActivityHandlers = {}));
    })(workflow = geocortex.workflow || (geocortex.workflow = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var workflow;
    (function (workflow) {
        var DefaultActivityHandlers;
        (function (DefaultActivityHandlers) {
            /** @private */
            function handleGetCurrentPosition(activityContext) {
                if (!navigator.geolocation) {
                    // Not supported
                    activityContext.setValue("ErrorCode", 2);
                    activityContext.setValue("ErrorMessage", "Geolocation is not supported.");
                    activityContext.completeActivity();
                    return;
                }
                var geolocateTimeoutDefault = 20000;
                var positionOptions = {
                    enableHighAccuracy: activityContext.getValue("EnableHighAccuracy"),
                    timeout: activityContext.getValue("Timeout") || geolocateTimeoutDefault,
                    maximumAge: activityContext.getValue("MaximumAge")
                };
                navigator.geolocation.getCurrentPosition(function (position) {
                    // Success
                    activityContext.setValue("Latitude", position.coords.latitude);
                    activityContext.setValue("Longitude", position.coords.longitude);
                    activityContext.setValue("Altitude", position.coords.altitude);
                    activityContext.setValue("Accuracy", position.coords.accuracy);
                    activityContext.setValue("AltitudeAccuracy", position.coords.altitudeAccuracy);
                    activityContext.setValue("Heading", position.coords.heading);
                    activityContext.setValue("Speed", position.coords.speed);
                    activityContext.setValue("Timestamp", position.timestamp);
                    activityContext.completeActivity();
                }, function (positionError) {
                    // Failed
                    activityContext.setValue("ErrorCode", positionError.code);
                    activityContext.setValue("ErrorMessage", positionError.message);
                    activityContext.completeActivity();
                }, positionOptions);
            }
            DefaultActivityHandlers.handleGetCurrentPosition = handleGetCurrentPosition;
            /** @private */
            function handleGetPhoto(activityContext) {
                if (!navigator["camera"]) {
                    activityContext.setValue("Message", "camera is not supported.");
                    activityContext.completeActivity();
                    return;
                }
                var options = {
                    quality: activityContext.getValue("Quality"),
                    destinationType: activityContext.getValue("DestinationType"),
                    sourceType: activityContext.getValue("SourceType"),
                    allowEdit: activityContext.getValue("AllowEdit"),
                    encodingType: activityContext.getValue("EncodingType"),
                    targetWidth: activityContext.getValue("TargetWidth"),
                    targetHeight: activityContext.getValue("TargetHeight")
                };
                navigator["camera"].getPicture(function (imageData) {
                    // Success
                    activityContext.setValue("ImageData", imageData);
                    activityContext.completeActivity();
                }, function (message) {
                    // Failed
                    activityContext.setValue("Message", message);
                    activityContext.completeActivity();
                }, options);
            }
            DefaultActivityHandlers.handleGetPhoto = handleGetPhoto;
        })(DefaultActivityHandlers = workflow.DefaultActivityHandlers || (workflow.DefaultActivityHandlers = {}));
    })(workflow = geocortex.workflow || (geocortex.workflow = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Manages layer visibilities and events.
         * @private
         */
        var LayerVisibilityEventManager = (function () {
            /**
             * Constructs an instance of the manager for a given service and layer.
             * @param mapService The {@link MapService} to manage.
             * @param serviceLayer The {@link esri.layers.Layer} to manage.
             */
            function LayerVisibilityEventManager(mapService, serviceLayer) {
                this._mapService = null;
                this._mapService = mapService;
                if (!(this._mapService.mapServiceType == geocortex.essentials.MapServiceType.WMS)
                    && !(this._mapService.mapServiceType == geocortex.essentials.MapServiceType.DYNAMIC)) {
                    throw new Error("LayerVisibilityEventManager: Only Dynamic and WMS Layer types supported.");
                }
                var _this = this;
                // GVH-2740 - Binding esri's setVisibleLayers method call so that the "LayerVisibilityChange" event 
                // is automatically thrown when layer visibility of either a dynamic or wms serviceLayer is changed.
                dojo["require"]("dojo.aspect");
                dojo.aspect.before(serviceLayer, "setVisibleLayers", function (ids, doNotRefresh) {
                    return _this.beforeESRIsetVisibleLayers(ids, doNotRefresh);
                });
                dojo.aspect.after(serviceLayer, "setVisibleLayers", function (ids, doNotRefresh, changedLayers) {
                    _this.afterESRIsetVisibleLayers(ids, doNotRefresh, changedLayers);
                }, true);
            }
            /**
             * Function invoked before the Esri `setVisibleLayers` function is called.
             * @private
             * @param ids IDs of layers to set the visibility of.
             * @param doNoRefresh Whether or not to actually refresh layer visibilities.
             */
            LayerVisibilityEventManager.prototype.beforeESRIsetVisibleLayers = function (ids, doNotRefresh) {
                var changedLayers = [];
                var idsToSetVisible = []; // Meant to contain actual layer id's in case this is a WMS Layer and ids contain layer names
                var counter = 0;
                if (doNotRefresh === undefined) {
                    doNotRefresh = false;
                }
                ///// VISIBILITY CHANGE INVOKED VIA ESSENTIALS LAYER 'setVisibility' METHOD (Layer.ts) /////
                // If the esri 'setVisibleLayers' function has been called via the essentials layer.ts 'setVisibility' method,
                // then this function will receive an id's array with special changedLayer property added. 
                // This is needed because in that case, only the particular essentials layer object whose visibility has been 
                // updated should be set since we want to respect the visibility state that any other sublayers may be configured to, 
                // by either the rest manager or the user via the layer list. 
                // This is different from changing the esri layer visibility programatically, which will update the essentials layer
                // object visibilities to the current set configuration and set all other layer visibilities to false.
                // IMPORTANT: Removing this property will cause the layer list to lose all visibility state information between calls
                if (ids["InternallyChangedLayer"]) {
                    var internallyChangedLayer = ids["InternallyChangedLayer"];
                    if (internallyChangedLayer.mapServiceId != undefined && internallyChangedLayer.layerId != undefined && internallyChangedLayer.visibility != undefined) {
                        changedLayers.push(internallyChangedLayer);
                    }
                    var setVisibleLayersArgs = [ids, doNotRefresh, changedLayers];
                    return setVisibleLayersArgs;
                }
                ///// PROGRAMATICALLY CHANGING ESRI LAYER VISIBILITIES /////
                // If its reached here, it means that layer visibility change has been invoked PROGRAMATICALLY via esri's setVisibleLayers method. 
                // The programmer needs to take care about not setting invalid configurations like setting the child to visible when the parent is not
                // Since this is technically an 'esri' function call intercepted, we cant modify esri's default behaviour here.
                // First, if this is a WMS Layer, we need to convert the provided ids from WMS Layer Names to WMS Layer ID's so our algorithm below can 
                // handle it. Otherwise we point to the original ids array.
                if (this._mapService.mapServiceType == geocortex.essentials.MapServiceType.DYNAMIC) {
                    idsToSetVisible = dojo.clone(ids); // leave it unchanged
                }
                else if (this._mapService.mapServiceType == geocortex.essentials.MapServiceType.WMS) {
                    for (var m = 0; ids && m < ids.length; m++) {
                        var id = this._findWmsLayerIdFromName(ids[m]); // will return null if id not found
                        if (id && id !== null) {
                            idsToSetVisible.push(id.toString());
                        }
                        else {
                            // Special case 1: If ANY of the supplied ids do not match any wms layer name, leave the 
                            // currently active layers alone i.e. do nothing
                            var setVisibleLayersArgs = [ids, doNotRefresh, changedLayers];
                            console.error("WARNING: LayerVisibilityEventManager could not find layer corresponding to WMS name [" + ids[m] + "] Possible Invalid configuration");
                            return setVisibleLayersArgs;
                        }
                    }
                }
                // Special case 2: If esri visibility is set to "-1" in case of a DYNAMIC map service, then all layers are 
                // toggled off. Nothing will be displayed on the map. If this happens, then iterate over all essentials layer objects and set their 
                // visibilities to false.
                if (ids && (this._mapService.mapServiceType == geocortex.essentials.MapServiceType.DYNAMIC)
                    && (ids.length === 1) && (ids[0] == "-1")) {
                    for (var a = 0; a < this._mapService.layers.length; a++) {
                        var layerId = this._mapService.layers[a].id;
                        changedLayers.push({ mapServiceId: this._mapService.id, layerId: layerId.toString(), visibility: false });
                        this._mapService.findLayerById(layerId)._syncProgramaticallyChangedLayerVisibility(false);
                    }
                    var setVisibleLayersArgs = [ids, doNotRefresh, changedLayers];
                    return setVisibleLayersArgs;
                }
                // Special case 3: If esri visibility is set to [] (empty array) or [""] for a dynamic or [] for a wms map  
                // service, reset all visibilities to the default visibility.
                if (ids && (ids.length === 0) ||
                    ((this._mapService.mapServiceType == geocortex.essentials.MapServiceType.DYNAMIC)
                        && (ids.length === 1) && ids[0] === "")) {
                    idsToSetVisible = this._mapService.getDefaultVisibleLayers();
                }
                // Ids of all currently Visible layers - including group layers and layers whose parent visibilities are set to false
                var allVisibleLayers = this._getAllCurrentlyVisibleLayers();
                // If any of the visible layers are not present in the supplied id's, AND if they're not group layers, add them to the changedLayers 
                // array with visibility set to false. 
                for (var i = 0; allVisibleLayers && (i < allVisibleLayers.length); i++) {
                    var layerId = allVisibleLayers[i];
                    if (idsToSetVisible && (idsToSetVisible.indexOf(layerId.toString()) < 0)) {
                        var layer = this._mapService.findLayerById(layerId);
                        if (layer) {
                            // Turn off ALL layers that should be off. If its a non group layer, then the process is pretty straightforward.
                            // if this is a group layer, then it shouldn't be present in id's anyway. Turn off. If any of its children are present in id's
                            // they'll turn it back on later. Be careful that the resultant changed layer list does NOT contain two duplicate entries for 
                            // a group layer first turned off and then turned on!! Monitor this while adding any group layer with visibility true later.
                            changedLayers.push({ mapServiceId: this._mapService.id, layerId: layerId.toString(), visibility: false });
                            // Set the geocortex.essentials.Layer visibility to match the programmatically set visibility
                            layer._syncProgramaticallyChangedLayerVisibility(false);
                        }
                    }
                }
                // Ids of all currently Visible layers - taking into consideration parent layer visibility and not including group layers
                // This is AFTER all layers that should be switched off have been switched off above.
                var currentlyVisibleLayerIds = this._mapService.getVisibleLayers();
                if (idsToSetVisible && idsToSetVisible.length > 0) {
                    // If the supplied ids are not in the visible layers list, add them to the changedLayers array with visibility set to true. 
                    // In case of group layers, check and make sure that there's no duplicate being added.
                    for (var j = 0; j < idsToSetVisible.length; j++) {
                        // Special Case 4: If a non number is passed in, Esri's api switches on layer 0 for arcGis dynamic layers
                        if ((this._mapService.mapServiceType == geocortex.essentials.MapServiceType.DYNAMIC)
                            && isNaN(parseInt(idsToSetVisible[j]))) {
                            idsToSetVisible[j] = "0";
                        }
                        //if idsToSetVisible[j] not present in currentlyVisibleLayers
                        if (currentlyVisibleLayerIds && (currentlyVisibleLayerIds.indexOf(idsToSetVisible[j].toString()) < 0)) {
                            var layer = this._mapService.findLayerById(idsToSetVisible[j]);
                            if (layer) {
                                // If this is a group layer, then perform a few extra operations
                                if (layer.subLayerIds && (layer.subLayerIds.length > 0)) {
                                    // Delete group layer if it exists in changedLayers
                                    this._deleteItemWithId(idsToSetVisible[j], changedLayers);
                                    // Also, if this layer happens to be a group layer, we need to set all its sublayers to true (esri api behaviour). Check if this
                                    // is the case and send out the necessary events
                                    this._recursivelyUpdateSublayerVisibility(layer, true, changedLayers);
                                }
                                // Now we can push in the layer. 
                                changedLayers.push({ mapServiceId: this._mapService.id, layerId: idsToSetVisible[j].toString(), visibility: true });
                                // Set the geocortex.essentials.Layer visibility to match the programmatically set visibility
                                layer._syncProgramaticallyChangedLayerVisibility(true);
                                // Since you can set any layer programatically in esri to visible regardless of whether their parents are visible or not, and since
                                // doing this would cause the essentials layer objects to get out of sync, check if this layer has a parent who is 
                                // not set to visible and if yes, set it to visible in the geocorex essentials layer object.
                                if (layer.parentLayerId && (layer.parentLayerId !== null) && (layer.parentLayerId !== undefined)) {
                                    this._recursivelyUpdateAncestorVisibility(layer, idsToSetVisible, changedLayers);
                                }
                            }
                        }
                    }
                }
                var setVisibleLayersArgs = [ids, doNotRefresh, changedLayers];
                return setVisibleLayersArgs;
            };
            /**
             * Function called by dojo aspect after Esri's `setVisibleLayers` function is called.
             * @private
             */
            LayerVisibilityEventManager.prototype.afterESRIsetVisibleLayers = function (ids, doNotRefresh, changedLayers) {
                if (changedLayers && changedLayers.length > 0) {
                    // The code below publishes an 'array within an array' on purpose since dojo seems to strip off the outer array if theres just
                    // one object/element in the array!
                    dojo.publish("LayerVisibilityChange", new Array(changedLayers));
                }
            };
            /** @private*/
            LayerVisibilityEventManager.prototype._recursivelyUpdateAncestorVisibility = function (layer, ids, changedLayers) {
                if (layer && layer.parentLayerId && (layer.parentLayerId !== null) && (layer.parentLayerId !== undefined)) {
                    var parentLayer = this._mapService.findLayerById(layer.parentLayerId);
                    if (!parentLayer.isVisible()) {
                        // Delete layer if it exists in changedLayers
                        this._deleteItemWithId(layer.parentLayerId, changedLayers);
                        parentLayer._syncProgramaticallyChangedLayerVisibility(true);
                        changedLayers.push({ mapServiceId: this._mapService.id, layerId: (layer.parentLayerId).toString(), visibility: true });
                    }
                    this._recursivelyUpdateAncestorVisibility(parentLayer, ids, changedLayers);
                }
            };
            /** @private */
            LayerVisibilityEventManager.prototype._recursivelyUpdateSublayerVisibility = function (layer, visible, changedLayers) {
                //If the layer is a group layer, set state of all its sub layers (including sub-sub, sub-sub-sub layers etc) to "visible" param
                if (layer.subLayerIds && (layer.subLayerIds.length > 0)) {
                    for (var x = 0; x < layer.subLayerIds.length; x++) {
                        var subLayer = this._mapService.findLayerById(layer.subLayerIds[x]);
                        var subLayerId = subLayer.id;
                        subLayer._syncProgramaticallyChangedLayerVisibility(visible);
                        this._deleteItemWithId(subLayerId, changedLayers); // Dont forget to delete it if it already exists in changedLayers!
                        changedLayers.push({ mapServiceId: this._mapService.id, layerId: subLayerId.toString(), visibility: visible });
                        // Check if this sublayer is in itself a group layer, and if yes, set visibility for its sub layers as well
                        if (subLayer.subLayerIds && (subLayer.subLayerIds.length > 0)) {
                            this._recursivelyUpdateSublayerVisibility(subLayer, visible, changedLayers);
                        }
                    }
                }
            };
            /**
             * Gets currently visible layers & group layers regarardless of whether parent layers are visible or not.
             * @private
             */
            LayerVisibilityEventManager.prototype._getAllCurrentlyVisibleLayers = function () {
                var result = [];
                for (var a = 0; a < this._mapService.layers.length; a++) {
                    var layer = this._mapService.layers[a];
                    if (layer.isVisible()) {
                        result.push((layer.id).toString());
                    }
                }
                return result;
            };
            /** @private */
            LayerVisibilityEventManager.prototype._findWmsLayerIdFromName = function (layerName) {
                for (var x = 0; x < this._mapService.layers.length; x++) {
                    var layer = this._mapService.layers[x];
                    if (layerName == layer.wmsLayerName) {
                        return layer.id;
                    }
                }
                return null;
            };
            /** @private */
            LayerVisibilityEventManager.prototype._deleteItemWithId = function (id, changedLayers) {
                for (var x = 0; x < changedLayers.length; x++) {
                    if (changedLayers[x].layerId == id) {
                        changedLayers.splice(x, 1);
                    }
                }
            };
            return LayerVisibilityEventManager;
        }());
        essentials.LayerVisibilityEventManager = LayerVisibilityEventManager;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/**
 * String constants that represent the various types of {@link MapService}.
 */
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var MapServiceType;
        (function (MapServiceType) {
            MapServiceType.DYNAMIC = "Dynamic";
            MapServiceType.TILED = "Tiled";
            MapServiceType.IMAGE = "Image";
            MapServiceType.BING = "Bing";
            MapServiceType.FEATURE = "Feature";
            MapServiceType.WMS = "WMS";
            MapServiceType.WMTS = "WMTS";
            MapServiceType.GEORSS = "GeoRss";
            MapServiceType.WEBTILED = "WebTiled";
            MapServiceType.VECTORTILE = "VectorTile";
            MapServiceType.KML = "Kml";
            MapServiceType.GRAPHICS = "Graphics";
            MapServiceType.LABEL = "Label";
            MapServiceType.STREAM = "Stream";
            MapServiceType.CSV = "Csv";
            MapServiceType.MAPIMAGE = "MapImage";
            MapServiceType.UNKNOWN = "Unknown";
        })(MapServiceType = essentials.MapServiceType || (essentials.MapServiceType = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/**
 * String constants that represent the various functions of {@link MapService}.
 */
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var MapServiceFunction;
        (function (MapServiceFunction) {
            MapServiceFunction.OPERATIONAL = "Operational";
            MapServiceFunction.BASE = "Base";
        })(MapServiceFunction = essentials.MapServiceFunction || (essentials.MapServiceFunction = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/**
 * String constants that represent various drawing behaviours.
 */
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var DrawingBehavior;
        (function (DrawingBehavior) {
            DrawingBehavior.MAP_SERVICE = "MapService";
            DrawingBehavior.FEATURE_LAYER = "FeatureLayer";
            DrawingBehavior.GEORSS_LAYER = "GeoRssLayer";
            DrawingBehavior.KML_SERVICE = "KmlService";
            DrawingBehavior["GeoRSS_LAYER"] = DrawingBehavior.GEORSS_LAYER; // non-standard naming, kept for legacy reasons
        })(DrawingBehavior = essentials.DrawingBehavior || (essentials.DrawingBehavior = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/**
 * String constants that represent various failure actions.
 */
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var FailureAction;
        (function (FailureAction) {
            FailureAction.IGNORE = "Ignore";
            FailureAction.WARN = "Warn";
            FailureAction.ERROR = "Error";
        })(FailureAction = essentials.FailureAction || (essentials.FailureAction = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/LayerTheme.Rest.d.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Represents a set of layers which are grouped together in a meaningful way for a certain use case.
         * There will typically be multiple layer themes in a site which the end user can toggle between,
         * effectively swapping ou the list of layers with the new list of layers as configured in the selected
         * layer theme. The theme allows for the inclusion/exclusion of layers, and for each layer that is
         * included in the theme, the visibility can be specified.
         */
        var LayerTheme = (function () {
            function LayerTheme(layerThemesInfo, idOrRestLayerTheme, displayName) {
                this.layerThemesInfo = layerThemesInfo;
                var restLayerTheme = (typeof idOrRestLayerTheme === "object") ? idOrRestLayerTheme : null;
                this._configureLayerTheme(restLayerTheme, idOrRestLayerTheme, displayName);
            }
            /**
             * Configure the {@link LayerTheme} from a {@link RestLayerTheme}
             */
            LayerTheme.prototype._configureLayerTheme = function (restLayerTheme, id, displayName) {
                this.id = restLayerTheme ? restLayerTheme.id : id;
                this.isDefaultTheme = (this.id === null);
                this.isActive = false; // Will be set when the theme is actually applied to the map
                this.displayName = restLayerTheme ? restLayerTheme.displayName : displayName;
                this.extensions = geocortex._getExtensions(restLayerTheme ? restLayerTheme.extensions : null);
                this.properties = restLayerTheme ? restLayerTheme.properties : null;
            };
            /**
             * Applies the theme settings to the map. This method iterates through all the layers in the map and adjusts
             * their visibility and other settings depending on if the layer is in the theme or not. By design, this method will
             * reapply the theme even if the theme has already been applied. It also ensures that the LayerThemesInfo.active theme
             * is set to this theme. In order to call this method, the LayerThemesInfo, and LayerThemesInfo.map properties must be
             * specified in order for this method to get access to the map.
             */
            LayerTheme.prototype.applyToMap = function () {
                var _this = this;
                if (this.layerThemesInfo == undefined) {
                    throw new Error("Could not apply theme '{0}' to the map because the LayerThemesInfo property is not set on this LayerTheme.".format(this.displayName));
                }
                var ltInfo = this.layerThemesInfo;
                var map = ltInfo.map;
                if (map == undefined) {
                    throw new Error("Failed to apply theme '{0}' to map because the Map property is not set on the LayerThemesInfo object.".format(this.displayName));
                }
                this.isActive = true;
                // Check if the active theme is correctly set in the layerThemesInfo object before raising the activeThemeChanged event
                if ((ltInfo.activeTheme && ltInfo.activeTheme !== this) || !ltInfo.activeTheme) {
                    if (ltInfo.activeTheme) {
                        ltInfo.previousTheme = ltInfo.activeTheme;
                        ltInfo.previousTheme.isActive = false;
                    }
                    ltInfo.activeTheme = this;
                }
                // Raise the layerThemeChangingEvent
                ltInfo.themeChangeInProgress = true; // Indicating that the theme is currently changing (GVH-6062).
                ltInfo.layerThemeChangingEvent({ currTheme: ltInfo.activeTheme, prevTheme: ltInfo.previousTheme });
                var applyDefaultThemeSettings = function (layerOrMapService, doNotRefresh) {
                    if (doNotRefresh === void 0) { doNotRefresh = false; }
                    layerOrMapService.setInActiveTheme(true); // Note: Always set in active theme first before setting visibility
                    applyVisibilityConditionally(layerOrMapService, layerOrMapService.configuredVisible, doNotRefresh);
                };
                var applyConfiguredThemeSettings = function (layerOrMapService, doNotRefresh) {
                    if (doNotRefresh === void 0) { doNotRefresh = false; }
                    var themeSetting = layerOrMapService.getLayerThemeSettings(_this.id);
                    layerOrMapService.setInActiveTheme(themeSetting != null);
                    var isVisible = false;
                    if (themeSetting != null) {
                        isVisible = themeSetting.visible != undefined ? themeSetting.visible : layerOrMapService.configuredVisible;
                    }
                    applyVisibilityConditionally(layerOrMapService, isVisible, doNotRefresh);
                };
                var applyVisibilityConditionally = function (layerOrMapService, visible, doNotRefresh) {
                    if (doNotRefresh === void 0) { doNotRefresh = false; }
                    if (layerOrMapService instanceof geocortex.essentials.Layer) {
                        var essLayer = layerOrMapService;
                        if (essLayer.mapService.supportsLayerVisibility()) {
                            var essVersion = essLayer.mapService.essentialsMap.site.getEssentialsVersion();
                            // GVH-5413: If we're dealing with essentials v4.02 and above, we have the configurable layer list which will convert group layers to folders. Dont allow these group layers to be turned
                            // off because once turned off, the layer list will not be able to turn them back on since they are not linked to the group folders (unlike mapservices that are linked to mapservice folders)
                            // If the group layer itself is kept on, the layerlist will automatically apply correct visibilities on it's sub layers based on the visibility of the containing folder.
                            if ((essVersion >= 4.02) && (essLayer.type === geocortex.essentials.LayerType.GROUP_LAYER)) {
                                visible = true;
                            }
                        }
                        else {
                            // Check if the layer is in the active theme. If we don't and the map service contains exactly one layer, but the layer is not 
                            // in the active theme (in which case visibility is false), it will force it's parent service visibility to off irrespective of what is configured in the theme.
                            // Also, if the parent layer is included in the layer list, let the visibility be controlled by the parent layer rather than applying
                            // it here and forcing the parent to the same visibility state regardless of theme setting.
                            if (essLayer.mapService.layers.length !== 1 || !essLayer.inActiveTheme || essLayer.mapService.includeInLayerList) {
                                return;
                            }
                        }
                    }
                    if (!layerOrMapService.isUserCreated) {
                        layerOrMapService.setVisibility(visible, doNotRefresh);
                    }
                };
                // Apply settings to map
                for (var x = 0; x < map.mapServices.length; x++) {
                    var mapService = map.mapServices[x];
                    var doNotRefresh = mapService.supportsLayerVisibility();
                    if (this.isDefaultTheme) {
                        applyDefaultThemeSettings(mapService);
                    }
                    else {
                        applyConfiguredThemeSettings(mapService);
                    }
                    // Update Layers but taking care of NOT refreshing mapServices that support layer visibility until we're done - see comments in GVH-4487 
                    for (var y = 0; y < mapService.layers.length; y++) {
                        var layer = mapService.layers[y];
                        if (this.isDefaultTheme) {
                            applyDefaultThemeSettings(layer, doNotRefresh);
                        }
                        else {
                            applyConfiguredThemeSettings(layer, doNotRefresh);
                        }
                    }
                    // In case of mapServices that support layer visibility, refresh the map services once we have applied all visibilities and the layer list has been updated
                    if (doNotRefresh) {
                        mapService.refresh();
                    }
                }
                // Refresh the filtered collections
                map.refreshFilteredCollections();
                // Raise the layerThemeChangedEvent
                ltInfo.themeChangeInProgress = false; // Indicating that the theme is finished changing (GVH-6062).
                ltInfo.layerThemeChangedEvent({ currTheme: ltInfo.activeTheme, prevTheme: ltInfo.previousTheme });
            };
            return LayerTheme;
        }());
        essentials.LayerTheme = LayerTheme;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Defines a reference to a theme and whether or not an object should be visible in that theme
         */
        var LayerThemeSetting = (function () {
            /**
             * Creates a new instance of the {@link LayerThemeSetting} class
             */
            function LayerThemeSetting(theme, visible) {
                this.theme = theme;
                this.visible = visible;
            }
            return LayerThemeSetting;
        }());
        essentials.LayerThemeSetting = LayerThemeSetting;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * A simple container for information about layer themes
         */
        var LayerThemesInfo = (function () {
            /**
             * Initializes a new instance of the {@link LayerThemesInfo} class
             */
            function LayerThemesInfo(map) {
                /**
                 * This event occurs just after a theme is changed. At this point the theme will have been applied to the map.
                 */
                this.layerThemeChangedEvent = function (args) { };
                /**
                 * Indicates whether or not the layer theme is currently in the process of changing.
                 * This value should be true in between the `layerThemeChangedEvent` and `layerThemeChangingEvent`.
                 */
                this.themeChangeInProgress = false; // GVH-6062
                /**
                 * This event occurs just before a theme is changed. At this point, the active theme property will be set, but the theme will not
                 * yet have been applied to the map.
                 */
                this.layerThemeChangingEvent = function (args) { };
                this.layerThemesConfigured = false;
                this.allowDefault = false;
                this.themes = [];
                this.map = map;
            }
            /**
             * Applies the theme with the specified ID to the map, and sets the _activeTheme property to reference that theme
             */
            LayerThemesInfo.prototype.applyTheme = function (id) {
                if (this.layerThemesConfigured) {
                    var theme = this.getTheme(id);
                    if (theme) {
                        theme.applyToMap(); // Doing this will also raise the onActiveThemeChanged event
                    }
                    else {
                        console.log("Error: Theme with ID '{0}' could not be found and was not activated.".format(id));
                    }
                }
                else {
                    console.log("Warning: No layer themes have been configured by the essentials administrator.");
                }
            };
            /**
             * Retrieves the theme with the specified id if it exists. Else returns null. If the optional matchAgainstIdAndName parameter is true,
             * it will attempt to match the given string against the theme name (case insensitive) as well as it's id.
             * @param themeIdentifier The theme identifier. Could be either the theme id (default) or the theme display name. If it's the display name then matchAgainstIdAndName needs to be set true
             * @param matchAgainstIdAndName A boolean which, if true, will cause this function to match the identifier against both layer id's and display names.
             */
            LayerThemesInfo.prototype.getTheme = function (themeIdentifier, matchAgainstIdAndName) {
                if (matchAgainstIdAndName === void 0) { matchAgainstIdAndName = false; }
                if (this.layerThemesConfigured) {
                    for (var x = 0; x < this.themes.length; x++) {
                        if (this.themes[x].id === themeIdentifier) {
                            return this.themes[x];
                        }
                        if (matchAgainstIdAndName && this.themes[x].displayName.toLowerCase() === themeIdentifier.toLowerCase()) {
                            return this.themes[x];
                        }
                    }
                }
                return null;
            };
            return LayerThemesInfo;
        }());
        essentials.LayerThemesInfo = LayerThemesInfo;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/arcgis-js-api.d.ts" />
/// <reference path="MapService.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Representation of a KML service. The properties in this class represent the configuration served from the Essentials REST API.
         */
        var KmlService = (function (_super) {
            __extends(KmlService, _super);
            function KmlService() {
                _super.apply(this, arguments);
                /** The update interval in seconds. The KML will be refreshed on this interval. */
                this.updateInterval = null;
                /** The esri KML layer. */
                this.serviceLayer = null;
                /** The spatial reference of the map. */
                this.mapSpatialReference = null;
            }
            /** @private */
            KmlService.prototype._configureObject = function (obj, deepInitialize) {
                if (obj === undefined) {
                    throw new Error("Incorrect map service object returned from initialization");
                }
                this.updateInterval = obj.updateInterval;
                _super.prototype._configureObject.call(this, obj, deepInitialize);
            };
            /** @private */
            KmlService.prototype._createServiceLayer = function () {
                var _this = this;
                var site = null;
                if (this.essentialsMap) {
                    site = this.essentialsMap.site;
                    this.mapSpatialReference = this.essentialsMap.initialExtent.spatialReference;
                }
                // NB: At the time of this writing, the function signature for the KMLLayer constructor is
                // incorrect in both Esri's Typescript definition file and the JS API documentation 
                // (see https://developers.arcgis.com/javascript/jsapi/kmllayer-amd.html#kmllayer1).
                // It's defined as:
                //
                // constructor(id: string, url: string, options?: esri.KMLLayerOptions);
                //
                // In fact, there is no "id" parameter. Rather than maintain our own patched version
                // of the definition file, we can use some hacky type casting to shift the arguments over.
                var options = { id: this.id, outSR: this.mapSpatialReference };
                this.serviceLayer = new esri.layers.KMLLayer(this.serviceUrl, options);
                if (this._initiallyVisible) {
                    this.serviceLayer.show();
                }
                else {
                    this.serviceLayer.hide();
                }
                // GVH-5681: There is a bug in KMLLayer introduced in the 3.13 JS API where one or more KML layers
                // ends up being invisible on the map. The source of the bug is that all instances of KMLLayer end 
                // up incorrectly sharing a single instance of an internal "_options" object, causing a "last one 
                // wins" race condition. This works around the issue by giving each instance its own set of options.
                this.serviceLayer._options = options;
                if (this.attributionDataUrl && this.attributionDataUrl !== "") {
                    this.serviceLayer.attributionDataUrl = this.attributionDataUrl;
                    this.serviceLayer.hasAttributionData = true;
                }
                else if (this.hasAttributionData) {
                    this.serviceLayer.attributionDataUrl = this.url + "/Attribution";
                    this.serviceLayer.hasAttributionData = true;
                }
                var loadHandle = this.serviceLayer.on("load", function (event) {
                    loadHandle.remove();
                    // The opacity has already been set, but for some reason needs to be set again
                    // once the KML is loaded, otherwise it isn't honoured.
                    _this.serviceLayer.setOpacity(_this.configuredOpacity);
                    _this._initializeKmlLayers();
                });
                this.serviceLayer.on("error", function (error) { return _this._layerLoadErrorHandler(error); });
                //this.serviceLayer.on("update-start", () => this._updateStartHandler());
                this.serviceLayer.setOpacity(this.configuredOpacity);
                if (this.updateInterval && !isNaN(this.updateInterval)) {
                    this.serviceLayer.setRefreshInterval(this.updateInterval);
                }
            };
            KmlService.prototype._updateStartHandler = function () {
                this._initializeKmlLayers();
            };
            KmlService.prototype._initializeKmlLayers = function () {
                // A KML layer can have up to 3 feature layers, one for each geometry type (point,
                // line, or polygon). It can also have an image layer corresponding to KML ground
                // overlays. Set up a few missing properties on the feature layers to make them play
                // nicely with identify operations and the map legend.
                var layers = this.serviceLayer.getLayers();
                for (var i = 0; i < layers.length; i++) {
                    if (layers[i] instanceof esri.layers.FeatureLayer) {
                        var featureLayer = layers[i];
                        featureLayer.layerId = +this.id;
                        featureLayer.name = this.displayName;
                        featureLayer.displayField = "name";
                        // When the feature layers are created, they are created with the map's 
                        // coordinate system, but may end up with a different yet equivalent WKID 
                        // (e.g. 3857 when the map is defined as 102100). In order for identify 
                        // queries to succeed, the WKIDs must match exactly.
                        layers[i].spatialReference = this.mapSpatialReference;
                    }
                }
            };
            return KmlService;
        }(essentials.MapService));
        essentials.KmlService = KmlService;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/arcgis-js-api.d.ts" />
/// <reference path="ActivityContext.ts" />
/** @docs-hide-from-nav */
var geocortex;
(function (geocortex) {
    var workflow;
    (function (workflow) {
        var CacheActivityHandlers;
        (function (CacheActivityHandlers) {
            var _cache = {};
            /** @private */
            function handleGetExternalValue(activityContext) {
                // Get input values
                var key = activityContext.getValue("Key");
                if (key != null) {
                    // Get the value from the cache
                    var value = _cache[key];
                    if (value === undefined) {
                        value = null;
                    }
                    // Set output values
                    activityContext.setValue("Value", value);
                }
                // Complete the activity
                activityContext.completeActivity();
            }
            CacheActivityHandlers.handleGetExternalValue = handleGetExternalValue;
            /** @private */
            function handleSetExternalValue(activityContext) {
                // Get input values
                var key = activityContext.getValue("Key");
                var value = activityContext.getValue("Value");
                if (key != null) {
                    _cache[key] = value;
                }
                // Complete the activity
                activityContext.completeActivity();
            }
            CacheActivityHandlers.handleSetExternalValue = handleSetExternalValue;
        })(CacheActivityHandlers = workflow.CacheActivityHandlers || (workflow.CacheActivityHandlers = {}));
    })(workflow = geocortex.workflow || (geocortex.workflow = {}));
})(geocortex || (geocortex = {}));
/// <reference path="ActivityDispatcher.ts" />
/// <reference path="DefaultActivityHandlers.ts" />
/// <reference path="CacheActivityHandlers.ts" />
var geocortex;
(function (geocortex) {
    var workflow;
    (function (workflow_3) {
        var DefaultActivityDispatcher = (function () {
            function DefaultActivityDispatcher(errorHandler, activityBeginHandler, activityCompleteHandler, workflowCompleteHandler, workflowAbortHandler, webRequestBeginHandler, webRequestCompleteHandler) {
                /**
                 * The value indicating whether the workflow controller is busy.
                 * @type Boolean
                 */
                this.isBusy = false;
                /** @private The draw object context for any activity that requires map interaction. Only one instance of the draw Object can be active at any given time */
                this._drawObjectContext = null;
                /** @private */
                this._registeredActivityHandlers = {};
                /** @private */
                this._registeredExternalIdHandlers = {};
                this.handleUnhandledActivityErrorFunction = null;
                this.handleOpenReportUrlFunction = null;
                /**
                 * @private
                 * The name of the default form container ID to use.
                 */
                this.defaultFormContainerId = "form-container-outer";
                this.defaultFormContentId = "form-container";
                this._handleErrorFunction = errorHandler || null;
                this._activityBeginFunction = activityBeginHandler || null;
                this._activityCompleteFunction = activityCompleteHandler || null;
                this._workflowAbortFunction = workflowAbortHandler || null;
                this._workflowCompleteFunction = workflowCompleteHandler || null;
                this._webRequestBeginFunction = webRequestBeginHandler || null;
                this._webRequestCompleteFunction = webRequestCompleteHandler || null;
                this.registerDefaultHandlers();
            }
            /**
             * Registers default handler behaviour.
             */
            DefaultActivityDispatcher.prototype.registerDefaultHandlers = function () {
                this.registerActivityHandler("Geocortex.Workflow.Activities.Alert", geocortex.workflow.DefaultActivityHandlers.handleAlert);
                this.registerActivityHandler("Geocortex.Workflow.Activities.CaptureGeometry", geocortex.workflow.DefaultActivityHandlers.handleCaptureGeometry);
                this.registerActivityHandler("Geocortex.Workflow.Activities.Confirm", geocortex.workflow.DefaultActivityHandlers.handleConfirm);
                this.registerActivityHandler("Geocortex.Workflow.Activities.ExportMap", geocortex.workflow.DefaultActivityHandlers.handleExportMap);
                this.registerActivityHandler("Geocortex.Workflow.Activities.ExternalDelay", geocortex.workflow.DefaultActivityHandlers.handleExternalDelay);
                this.registerActivityHandler("Geocortex.Workflow.Activities.GetBrowserUrl", geocortex.workflow.DefaultActivityHandlers.handleGetBrowserUrl);
                this.registerActivityHandler("Geocortex.Workflow.Activities.GetCurrentPosition", geocortex.workflow.DefaultActivityHandlers.handleGetCurrentPosition);
                this.registerActivityHandler("Geocortex.Workflow.Activities.GetExternalTimeInfo", geocortex.workflow.DefaultActivityHandlers.handleGetExternalTimeInfo);
                this.registerActivityHandler("Geocortex.Workflow.Activities.GetExternalValue", geocortex.workflow.CacheActivityHandlers.handleGetExternalValue);
                this.registerActivityHandler("Geocortex.Workflow.Activities.GetGraphicsLayerContent", geocortex.workflow.DefaultActivityHandlers.handleGetGraphicsLayerContent);
                this.registerActivityHandler("Geocortex.Workflow.Activities.GetLayerDefinition", geocortex.workflow.DefaultActivityHandlers.handleGetLayerDefinition);
                this.registerActivityHandler("Geocortex.Workflow.Activities.GetLayerInfoByProperty", geocortex.workflow.DefaultActivityHandlers.handleGetLayerInfoByProperty);
                this.registerActivityHandler("Geocortex.Workflow.Activities.GetLayerProperty", geocortex.workflow.DefaultActivityHandlers.handleGetLayerProperty);
                this.registerActivityHandler("Geocortex.Workflow.Activities.GetLayerVisibility", geocortex.workflow.DefaultActivityHandlers.handleGetLayerVisibility);
                this.registerActivityHandler("Geocortex.Workflow.Activities.GetMapExtent", geocortex.workflow.DefaultActivityHandlers.handleGetMapExtent);
                this.registerActivityHandler("Geocortex.Workflow.Activities.GetMapInfo", geocortex.workflow.DefaultActivityHandlers.handleGetMapInfo);
                this.registerActivityHandler("Geocortex.Workflow.Activities.GetMapServiceInfo", geocortex.workflow.DefaultActivityHandlers.handleGetMapServiceInfo);
                this.registerActivityHandler("Geocortex.Workflow.Activities.GetPhoto", geocortex.workflow.DefaultActivityHandlers.handleGetPhoto);
                this.registerActivityHandler("Geocortex.Workflow.Activities.PrintMap", geocortex.workflow.DefaultActivityHandlers.handlePrintMap);
                this.registerActivityHandler("Geocortex.Workflow.Activities.Prompt", geocortex.workflow.DefaultActivityHandlers.handlePrompt);
                this.registerActivityHandler("Geocortex.Workflow.Activities.RefreshMap", geocortex.workflow.DefaultActivityHandlers.handleRefreshMap);
                this.registerActivityHandler("Geocortex.Workflow.Activities.RemoveMapService", geocortex.workflow.DefaultActivityHandlers.handleRemoveMapService);
                this.registerActivityHandler("Geocortex.Workflow.Activities.Report", geocortex.workflow.DefaultActivityHandlers.handleReport);
                this.registerActivityHandler("Geocortex.Workflow.Activities.SetExternalValue", geocortex.workflow.CacheActivityHandlers.handleSetExternalValue);
                this.registerActivityHandler("Geocortex.Workflow.Activities.SetLayerDefinition", geocortex.workflow.DefaultActivityHandlers.handleSetLayerDefinition);
                this.registerActivityHandler("Geocortex.Workflow.Activities.SetLayerProperty", geocortex.workflow.DefaultActivityHandlers.handleSetLayerProperty);
                this.registerActivityHandler("Geocortex.Workflow.Activities.SetLayerVisibility", geocortex.workflow.DefaultActivityHandlers.handleSetLayerVisibility);
                this.registerActivityHandler("Geocortex.Workflow.Activities.SetMapExtent", geocortex.workflow.DefaultActivityHandlers.handleSetMapExtent);
                this.registerActivityHandler("Geocortex.Workflow.Activities.SetMapServiceVisibility", geocortex.workflow.DefaultActivityHandlers.handleSetMapServiceVisibility);
                this.registerActivityHandler("Geocortex.Workflow.Activities.UpdateGraphicsLayer", geocortex.workflow.DefaultActivityHandlers.handleUpdateGraphicsLayer);
                this.registerActivityHandler("Geocortex.Workflow.Activities.WaitForGeoprocessorJobComplete", geocortex.workflow.DefaultActivityHandlers.handleWaitForGeoprocessorJobComplete);
                this.registerActivityHandler("Geocortex.Workflow.Activities.SetImageServiceInfo", geocortex.workflow.DefaultActivityHandlers.handleSetImageServiceInfo);
                this.registerActivityHandler("Geocortex.Workflow.Activities.SetMapServiceProperty", geocortex.workflow.DefaultActivityHandlers.handleSetMapServiceProperty);
                this.registerExternalIdHandler("IntersectLayers", geocortex.workflow.DefaultActivityHandlers.handleIntersectLayers);
                this.registerExternalIdHandler("GetPhoto", geocortex.workflow.DefaultActivityHandlers.handleGetPhoto);
                // Not implemented:
                //this.registerActivityHandler("Geocortex.Workflow.Activities.NamedExtent", geocortex.workflow.DefaultActivityHandlers.handleNamedExtent);
                //this.registerActivityHandler("Geocortex.Workflow.Activities.DisplayForm", geocortex.workflow.DefaultActivityHandlers.handleForm);
                //this.registerActivityHandler("Geocortex.Workflow.Activities.DisplayHyperlink", geocortex.workflow.DefaultActivityHandlers.handleDisplayHyperlink);
            };
            /**
             * Determines whether this instance can handle the specified ActivityContext.
             * @param context The ActivityContext to test.
             * @return {Boolean}
             */
            DefaultActivityDispatcher.prototype.canHandleActivity = function (context) {
                if (!context) {
                    var err = new Error("Null ActivityContext passed to canHandleActivity.");
                    this.handleError(err, context);
                }
                if (context.getActivityExternalId() != null &&
                    this._registeredExternalIdHandlers[context.getActivityExternalId()] != null) {
                    return true;
                }
                var typeName = context.getActivityTypeName();
                if (typeName != null &&
                    this._registeredActivityHandlers[typeName]) {
                    return true;
                }
                return false;
            };
            /**
             * Registers a handler that will be called by the dispatcher if an activity with a matching external Id is encountered. This allows
             * the workflow developer to target a specific activity within a specific workflow instead of handling it based on the more general
             * type name. Note that a handler with a matching external Id overrides a matching type name.
             * @param externalId The Id of the activity to register handler for.
             * @param handler The handler to register for the given activity.
             */
            DefaultActivityDispatcher.prototype.registerExternalIdHandler = function (externalId, handler) {
                if (externalId == null || handler == null) {
                    var err = new Error("Null externalId or handler passed to registerExternalIdHandler.");
                    this.handleError(err, null);
                    return;
                }
                this._registeredExternalIdHandlers[externalId] = handler;
            };
            /**
             * Registers a handler that will be called when an activity with a matching type name is encountered.  Note that a handler with a matching
             * external Id overrides a matching type name.
             */
            DefaultActivityDispatcher.prototype.registerActivityHandler = function (activityTypeName, handler) {
                if (activityTypeName == null || handler == null) {
                    var err = new Error("Null activityTypeName or handler passed to registerActivityHandler.");
                    this.handleError(err, null);
                    return;
                }
                this._registeredActivityHandlers[activityTypeName] = handler;
            };
            /**
             * Performs the dispatching of an external activity. This will invoke the dispatchHandler.
             * @param context The context of the activity to dispatch.
             */
            DefaultActivityDispatcher.prototype.dispatch = function (context) {
                if (context == null) {
                    var err = new Error("Null ActivityContext passed to dispatch.");
                    this.handleError(err, context);
                    return;
                }
                var typeName = context.getActivityTypeName();
                var externalId = context.getActivityExternalId();
                if (!this.canHandleActivity(context)) {
                    var err = new Error("Unknown activity type '" + typeName + "' or external ID '" + externalId + "' encountered.");
                    this.handleUnhandledActivityErrorFunction(err, context);
                    return;
                }
                if (externalId != null && this._registeredExternalIdHandlers[externalId] != null) {
                    var action = this._registeredExternalIdHandlers[externalId];
                    action(context, this);
                }
                if (typeName != null && this._registeredActivityHandlers[typeName]) {
                    var action = this._registeredActivityHandlers[typeName];
                    action(context, this);
                }
            };
            /**
             * Handles error related to workflows. This will invoke the errorHandler.
             * @param error The error to handle.
             * @param activityContext The ActivityContext that generated the error.
             */
            DefaultActivityDispatcher.prototype.handleError = function (error, activityContext) {
                if (this._handleErrorFunction != null) {
                    this._handleErrorFunction(error, activityContext);
                }
            };
            DefaultActivityDispatcher.prototype.handleUnhandledActivityError = function (error, activityContext) {
                if (this.handleUnhandledActivityErrorFunction != null) {
                    this.handleUnhandledActivityErrorFunction(error, activityContext);
                }
                else {
                    this.handleError(error, activityContext);
                }
            };
            DefaultActivityDispatcher.prototype.handleOpenReportUrl = function (url, activityContext) {
                if (this.handleOpenReportUrlFunction != null) {
                    this.handleOpenReportUrlFunction(url, activityContext);
                }
                else {
                    // Fall back to trying to open the window
                    var openedWindow = window.open(url);
                }
            };
            /**
              * Called when a web request is started as part of a workflow.
              * @param url The web request URL.
              * @param workflow The current workflow.
              */
            DefaultActivityDispatcher.prototype.webRequestBegin = function (url, workflow) {
                if (this._webRequestBeginFunction != null) {
                    this._webRequestBeginFunction(url, workflow);
                }
            };
            /**
             * Called when a web request is completed as part of a workflow.
             * @param url The web request URL.
             * @param workflow The current workflow.
             */
            DefaultActivityDispatcher.prototype.webRequestComplete = function (url, workflow) {
                if (this._webRequestCompleteFunction != null) {
                    this._webRequestCompleteFunction(url, workflow);
                }
            };
            /**
             * Aborts any workflow activity that requires map interaction. e.g. CaptureGeometry.
             * @return A boolean value indicating if any active draw activity has been successfully cancelled or not
             */
            DefaultActivityDispatcher.prototype.abortMapBasedActivity = function () {
                if (this._drawObjectContext) {
                    if (!this._drawObjectContext.toolbar || !this._drawObjectContext.drawEvent || !this._drawObjectContext.activityContext) {
                        return false;
                    }
                    this._drawObjectContext.toolbar.deactivate();
                    dojo.disconnect(this._drawObjectContext.drawEvent);
                    this._drawObjectContext.activityContext.abortActivity();
                    this._drawObjectContext = null;
                }
                return true;
            };
            /**
             * Sets the value of the DrawObjectContext
             */
            DefaultActivityDispatcher.prototype.setDrawObjectContext = function (ctx) {
                this._drawObjectContext = ctx;
            };
            /**
             * Called when the client portion of an external activity is about to be dispatched. This will invoke the activityBeginHandler.
             * @param context The context of the activity that is about to begin.
             */
            DefaultActivityDispatcher.prototype.activityBegin = function (context) {
                if (this._activityBeginFunction != null) {
                    this._activityBeginFunction(context);
                }
            };
            /**
             * Called when the client portion of an external activity is complete. This will invoke the activityCompleteHandler.
             * @param context The context of the activity that has just completed.
             */
            DefaultActivityDispatcher.prototype.activityComplete = function (context) {
                if (this._activityCompleteFunction != null) {
                    this._activityCompleteFunction(context);
                }
            };
            /**
             * Called when the client portion of an external activity is aborted for some reason. This will invoke the workflowAbortHandler since the workflow can no longer
             * continue once a component activity is aborted.
             * @param context The context of the activity that was aborted
             */
            DefaultActivityDispatcher.prototype.activityAbort = function (context) {
                this.workflowAbort(context, context.workflow());
            };
            /**
             * Called when the workflow is complete.
             * @param outputs The outputs of the workflow that has just completed. This will invoke the workflowCompleteHandler.
             * @param workflow The workflow that has just completed.
             */
            DefaultActivityDispatcher.prototype.workflowComplete = function (outputs, workflow) {
                if (this._workflowCompleteFunction != null) {
                    this._workflowCompleteFunction(outputs, workflow);
                }
            };
            /**
             * Called if the workflow is aborted.
             * @param context The context of the activity that has caused the workflow to abort
             * @param workflow The workflow that has just been aborted
             */
            DefaultActivityDispatcher.prototype.workflowAbort = function (context, workflow) {
                if (this._workflowAbortFunction != null) {
                    this._workflowAbortFunction(context, workflow);
                }
            };
            return DefaultActivityDispatcher;
        }());
        workflow_3.DefaultActivityDispatcher = DefaultActivityDispatcher;
    })(workflow = geocortex.workflow || (geocortex.workflow = {}));
})(geocortex || (geocortex = {}));
/// <reference path="ActivityDispatcher.ts" />
/// <reference path="ActivityContext.ts" />
/// <reference path="../essentials/Workflow.ts" />
/// <reference path="DefaultActivityDispatcher.ts" />
var geocortex;
(function (geocortex) {
    var workflow;
    (function (workflow_4) {
        var SimpleActivityDispatcher = (function () {
            /**
             * Initializes a new instance of the {@link geocortex.workflow.SimpleActivityDispatcher} class.
             * @class
             * Represents a simple implementation of the ActivityDispatcher that allows the use of callback
             * functions to handle the dispatching functions. This is useful for unit testing.
             * @constructs
             * @param {Function} [dispatchHandler] The callback function that will handle the dispatching of activities. The function should expect an ActivityContext as parameter.
             * @param {Function} [errorHandler] The callback function that will handle errors. The function should expect an Error as parameter.
             * @param {Function} [activityBeginHandler] The callback function that will be called when an activity begins.
             * @param {Function} [activityCompleteHandler] The callback function that will be called when an activity completes.
             * @param {Function} [workflowCompleteHandler] The callback function that will be called when the workflow completes.
             */
            function SimpleActivityDispatcher(dispatchHandler, errorHandler, activityBeginHandler, activityCompleteHandler, workflowCompleteHandler, workflowAbortHandler, webRequestBeginHandler, webRequestCompleteHandler) {
                /** @private */
                this._defaultActivityDispatcher = new geocortex.workflow.DefaultActivityDispatcher();
                /**
                 * @private The draw object context for any activity that requires map interaction. Only one instance of the draw Object can be active at any given time
                 * @type {  activityContext: ActivityContext; toolbar: esri.toolbars.Draw; drawEvent: any }
                 */
                this._drawObjectContext = null;
                /**
                 * The value indicating whether the workflow controller is busy.
                 * @type Boolean
                 */
                this.isBusy = null;
                this._dispatchFunction = dispatchHandler || null;
                this._handleErrorFunction = errorHandler || null;
                this._activityBeginFunction = activityBeginHandler || null;
                this._activityCompleteFunction = activityCompleteHandler || null;
                this._workflowCompleteFunction = workflowCompleteHandler || null;
                this._workflowAbortFunction = workflowAbortHandler || null;
                this._webRequestBeginFunction = webRequestBeginHandler || null;
                this._webRequestCompleteFunction = webRequestCompleteHandler || null;
            }
            /**
             * Performs the dispatching of an external activity. This will invoke the dispatchHandler.
             * @param context The context of the activity to dispatch.
             */
            SimpleActivityDispatcher.prototype.dispatch = function (context) {
                if (this._defaultActivityDispatcher.canHandleActivity(context)) {
                    this._defaultActivityDispatcher.dispatch(context);
                    return;
                }
                if (this._dispatchFunction != null) {
                    this._dispatchFunction(context);
                }
            };
            /**
             * Handles error related to workflows. This will invoke the errorHandler.
             * @param error The error to handle.
             * @param activityContext The ActivityContext that generated the error.
             */
            SimpleActivityDispatcher.prototype.handleError = function (error, activityContext) {
                if (this._handleErrorFunction != null) {
                    this._handleErrorFunction(error, activityContext);
                }
            };
            /**
             * Aborts any workflow activity that requires map interaction. e.g. CaptureGeometry.
             * @return A boolean value indicating if any active draw activity has been successfully cancelled or not
             */
            SimpleActivityDispatcher.prototype.abortMapBasedActivity = function () {
                if (this._drawObjectContext) {
                    if (!this._drawObjectContext.toolbar || !this._drawObjectContext.drawEvent || !this._drawObjectContext.activityContext) {
                        return false;
                    }
                    this._drawObjectContext.toolbar.deactivate();
                    dojo.disconnect(this._drawObjectContext.drawEvent);
                    this._drawObjectContext.activityContext.abortActivity();
                    this._drawObjectContext = null;
                }
                return true;
            };
            /**
             * Sets the value of the DrawObjectContext
             */
            SimpleActivityDispatcher.prototype.setDrawObjectContext = function (ctx) {
                this._drawObjectContext = ctx;
            };
            /**
             * Called when the client portion of an external activity is about to be dispatched. This will invoke the activityBeginHandler.
             * @param context The context of the activity that is about to begin.
             */
            SimpleActivityDispatcher.prototype.activityBegin = function (context) {
                if (this._activityBeginFunction != null) {
                    this._activityBeginFunction(context);
                }
            };
            /**
             * Called when the client portion of an external activity is complete. This will invoke the activityCompleteHandler.
             * @param context The context of the activity that has just completed.
             */
            SimpleActivityDispatcher.prototype.activityComplete = function (context) {
                if (this._activityCompleteFunction != null) {
                    this._activityCompleteFunction(context);
                }
            };
            /**
             * Called when the client portion of an external activity is aborted for some reason. This will invoke the workflowborHandler since the workflow can no longer
             * continue once a component activity is aborted.
             * @param context The context of the activity that was aborted
             */
            SimpleActivityDispatcher.prototype.activityAbort = function (context) {
                this.workflowAbort(context, context.workflow());
            };
            /**
             * Called when a web request is started as part of a workflow.
             * @param url The web request URL.
             * @param workflow The current workflow.
             */
            SimpleActivityDispatcher.prototype.webRequestBegin = function (url, workflow) {
                if (this._webRequestBeginFunction != null) {
                    this._webRequestBeginFunction(url, workflow);
                }
            };
            /**
             * Called when a web request is completed as part of a workflow.
             * @param url The web request URL.
             * @param workflow The current workflow.
             */
            SimpleActivityDispatcher.prototype.webRequestComplete = function (url, workflow) {
                if (this._webRequestCompleteFunction != null) {
                    this._webRequestCompleteFunction(url, workflow);
                }
            };
            /**
             * Called when the workflow is complete.
             * @param outputs The outputs of the workflow that has just completed. This will invoke the workflowCompleteHandler.
             * @param workflow The workflow that has just completed.
             */
            SimpleActivityDispatcher.prototype.workflowComplete = function (outputs, workflow) {
                if (this._workflowCompleteFunction != null) {
                    this._workflowCompleteFunction(outputs, workflow);
                }
            };
            /**
             * Called if the workflow is aborted.
             * @param context The context of the activity that has caused the workflow to abort
             * @param workflow The workflow that has just been aborted
             */
            SimpleActivityDispatcher.prototype.workflowAbort = function (context, workflow) {
                if (this._workflowAbortFunction != null) {
                    this._workflowAbortFunction(context, workflow);
                }
            };
            SimpleActivityDispatcher.prototype.handleOpenReportUrl = function (url, activityContext) {
                window.open(url);
            };
            return SimpleActivityDispatcher;
        }());
        workflow_4.SimpleActivityDispatcher = SimpleActivityDispatcher;
    })(workflow = geocortex.workflow || (geocortex.workflow = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../essentials/TextField.ts" />
/// <reference path="ActivityContext.ts" />
/** @docs-hide-from-nav */
var geocortex;
(function (geocortex) {
    var workflow;
    (function (workflow) {
        var MapActivityHandlers;
        (function (MapActivityHandlers) {
            /** @private */
            function _pickSupported(list, item) {
                // Search for item in the list (of supported items)
                if (!list || (list.length <= 0)) {
                    return null;
                }
                // Case insensitive search
                if (item) {
                    var itemUpper = item.toUpperCase();
                    for (var i = 0; i < list.length; i++) {
                        var listItem = list[i];
                        if (listItem) {
                            if (listItem.toUpperCase() === itemUpper) {
                                return list[i];
                            }
                        }
                    }
                }
                return list[0];
            }
            MapActivityHandlers._pickSupported = _pickSupported;
            ;
            /** @private */
            function handleIntersectLayers(activityContext) {
                var separator = "\\\\";
                var outputLayers = [];
                var featureLayers = [];
                var groupLayers = [];
                var rasterLayers = [];
                var site = null;
                var essentialsMap = null;
                var mapService = null;
                var serviceLayers = null;
                var layer = null;
                var intersected = false;
                var intersections = null;
                // Loop counters
                var i, j, k, nameIndex, ai, bi;
                var sepIndex = -1;
                // Get input values
                var inputLayers = activityContext.getValue("InputLayers");
                // Un-qualifying the Layer Names if they are sub-layers of a group layer
                if (inputLayers && inputLayers.length > 0) {
                    for (nameIndex = 0; nameIndex < inputLayers.length; nameIndex++) {
                        sepIndex = inputLayers[nameIndex].lastIndexOf(separator);
                        if (sepIndex >= 0) {
                            inputLayers[nameIndex] = inputLayers[nameIndex].substring(sepIndex + separator.length);
                        }
                    }
                }
                else {
                    activityContext.dispatcher().handleError(new Error("Intersect Layers: no input layers provided."), activityContext);
                }
                site = activityContext.getSite();
                if (!site) {
                    activityContext.dispatcher().handleError(new Error("Intersect Layers: no site available."), activityContext);
                }
                essentialsMap = site.essentialsMap;
                if (!essentialsMap) {
                    activityContext.dispatcher().handleError(new Error("Intersect Layers: no map available."), activityContext);
                }
                if (!essentialsMap.mapServices || essentialsMap.mapServices.length <= 0) {
                    activityContext.dispatcher().handleError(new Error("Intersect Layers: no map service is configured for the map."), activityContext);
                }
                for (i = 0; i < essentialsMap.mapServices.length; i++) {
                    mapService = essentialsMap.mapServices[i];
                    serviceLayers = mapService.layers;
                    intersections = [];
                    var inputLength = inputLayers.length;
                    var serviceName = "";
                    serviceLayers.forEach(function (sl) {
                        serviceName = sl.name;
                        for (var i = 0; i < inputLength; ++i) {
                            if (serviceName === inputLayers[i]) {
                                intersections.push(sl);
                                break;
                            }
                        }
                    });
                    for (j = 0; j < intersections.length; j++) {
                        layer = intersections[j];
                        intersected = false;
                        switch (layer.type) {
                            case geocortex.essentials.LayerType.FEATURE_LAYER:
                                featureLayers.push(layer.name);
                                intersected = true;
                                break;
                            case geocortex.essentials.LayerType.GROUP_LAYER:
                                groupLayers.push(layer.name);
                                intersected = true;
                                break;
                            case geocortex.essentials.LayerType.RASTER_LAYER:
                                rasterLayers.push(layer.name);
                                intersected = true;
                                break;
                        }
                        if (intersected) {
                            outputLayers.push(layer.name);
                        }
                    }
                }
                // Set output values
                activityContext.setValue("OutputLayers", outputLayers);
                activityContext.setValue("FeatureLayers", featureLayers);
                activityContext.setValue("GroupLayers", groupLayers);
                activityContext.setValue("RasterLayers", rasterLayers);
                // Complete the activity
                activityContext.completeActivity();
            }
            MapActivityHandlers.handleIntersectLayers = handleIntersectLayers;
            /** @private */
            function handleExportMap(activityContext) {
                // Get input values
                var targetSpatialReference = activityContext.getValue("TargetSpatialReference");
                var customExtent = activityContext.getValue("CustomExtent");
                var resolution = activityContext.getValue("Resolution");
                var outputFormat = activityContext.getValue("OutputFormat");
                var scale = activityContext.getValue("Scale");
                var imageHeight = activityContext.getValue("ImageHeight");
                var imageWidth = activityContext.getValue("ImageWidth");
                var useTransparentBackground = activityContext.getValue("UseTransparentBackground");
                var site = null;
                var esriMap = null;
                var essentialsMap = null;
                var exportParameters = null;
                site = activityContext.getSite();
                if (!site) {
                    activityContext.dispatcher().handleError(new Error("Export Map: no site available."), activityContext);
                }
                esriMap = site.getMap();
                if (!esriMap) {
                    activityContext.dispatcher().handleError(new Error("Export Map: no map available."), activityContext);
                }
                essentialsMap = site.essentialsMap;
                if (!essentialsMap) {
                    activityContext.dispatcher().handleError(new Error("Export Map: no map available."), activityContext);
                }
                exportParameters = new geocortex.essentials.ReportParameters();
                exportParameters.outputFormat = geocortex.workflow.MapActivityHandlers._pickSupported(essentialsMap.supportedExportFormats, outputFormat);
                if (resolution) {
                    exportParameters.resolution = new geocortex.essentials.Resolution("", resolution);
                }
                if (scale) {
                    exportParameters.scale = new geocortex.essentials.Scale("", scale);
                }
                if (imageHeight) {
                    exportParameters.imageHeight = imageHeight;
                }
                else {
                    exportParameters.imageHeight = esriMap.height;
                }
                if (imageWidth) {
                    exportParameters.imageWidth = imageWidth;
                }
                else {
                    exportParameters.imageWidth = esriMap.width;
                }
                if (customExtent) {
                    exportParameters.customExtent = customExtent;
                }
                exportParameters.extentType = customExtent ? geocortex.essentials.ReportParameters.CUSTOM_EXTENT : geocortex.essentials.ReportParameters.CURRENT_EXTENT;
                exportParameters.useTransparentBackground = useTransparentBackground;
                if (targetSpatialReference) {
                    exportParameters.targetSpatialReference = targetSpatialReference;
                }
                if (esriMap) {
                    exportParameters.populateMapGraphicsLayers(esriMap);
                }
                essentialsMap.exportMap(exportParameters, function (sender) {
                    var reportHref = sender ? sender.href : null;
                    // Set output values
                    activityContext.setValue("ResultUrl", reportHref);
                    // Complete the activity
                    activityContext.completeActivity();
                }, function (error) {
                    activityContext.dispatcher().handleError(new Error("Error exporting map '" + error.message + "'"), activityContext);
                });
            }
            MapActivityHandlers.handleExportMap = handleExportMap;
            /** @private */
            function handlePrintMap(activityContext) {
                // Get input values
                var targetSpatialReference = activityContext.getValue("TargetSpatialReference");
                var textFields = activityContext.getValue("TextFields");
                var customExtent = activityContext.getValue("CustomExtent");
                var notificationEmailAddress = activityContext.getValue("NotificationEmailAddress");
                var resolution = activityContext.getValue("Resolution");
                var outputFormat = activityContext.getValue("OutputFormat");
                var scale = activityContext.getValue("Scale");
                var printTemplateId = activityContext.getValue("PrintTemplateId");
                var gridId = activityContext.getValue("GridId");
                // Site objects
                var site = null;
                var esriMap = null;
                var essentialsMap = null;
                var exportParameters = null;
                site = activityContext.getSite();
                if (!site) {
                    activityContext.dispatcher().handleError(new Error("Print Map: no site available."), activityContext);
                }
                esriMap = site.getMap();
                if (!esriMap) {
                    activityContext.dispatcher().handleError(new Error("Print Map: no map available."), activityContext);
                }
                var printTemplate = site.findPrintTemplateById(printTemplateId);
                if (!printTemplate) {
                    activityContext.dispatcher().handleError(new Error("Print Map: unable to find print template '" + printTemplateId + "'."), activityContext);
                }
                if (printTemplate.isPrinting()) {
                    activityContext.dispatcher().handleError(new Error("Print Map: unable to perform print operation because print template '" + printTemplateId + "' is busy."), activityContext);
                }
                var printParameters = new geocortex.essentials.ReportParameters();
                printParameters.outputFormat = geocortex.workflow.MapActivityHandlers._pickSupported(printTemplate.supportedOutputFormats, outputFormat);
                if (resolution) {
                    printParameters.resolution = new geocortex.essentials.Resolution("", resolution);
                }
                if (scale) {
                    printParameters.scale = new geocortex.essentials.Scale("", scale);
                }
                if (notificationEmailAddress) {
                    printParameters.notificationEmailAddress = notificationEmailAddress;
                }
                if (customExtent) {
                    printParameters.customExtent = customExtent;
                }
                printParameters.extentType = customExtent ? geocortex.essentials.ReportParameters.CUSTOM_EXTENT : geocortex.essentials.ReportParameters.CURRENT_EXTENT;
                if (targetSpatialReference) {
                    printParameters.targetSpatialReference = targetSpatialReference;
                }
                if (printTemplate.textFields && printTemplate.textFields.length > 0) {
                    if (textFields) {
                        for (var i = 0; i < textFields.length; i++) {
                            if (textFields[i]) {
                                for (var j = 0; j < printTemplate.textFields.length; j++) {
                                    if (textFields[i].Key === printTemplate.textFields[j].displayName) {
                                        var field = new geocortex.essentials.TextField(printTemplate.textFields[j].id, "", textFields[i].Value, false);
                                        printParameters.fields.push(field);
                                    }
                                }
                            }
                        }
                    }
                }
                if (gridId) {
                    var grids = dojo.filter(printTemplate.grids, function (g) { return g.id == gridId; });
                    if (grids.length > 0) {
                        printParameters.grid = grids[0];
                    }
                }
                printTemplate.print(printParameters, function (sender) {
                    var reportHref = sender ? sender.href : null;
                    // Set output values
                    activityContext.setValue("ResultUrl", reportHref);
                    // Complete the activity
                    activityContext.completeActivity();
                }, function (error) {
                    activityContext.dispatcher().handleError(new Error("Error printing map '" + error.message + "'"), activityContext);
                });
            }
            MapActivityHandlers.handlePrintMap = handlePrintMap;
        })(MapActivityHandlers = workflow.MapActivityHandlers || (workflow.MapActivityHandlers = {}));
    })(workflow = geocortex.workflow || (geocortex.workflow = {}));
})(geocortex || (geocortex = {}));
var geocortex;
(function (geocortex) {
    var workflow;
    (function (workflow) {
        var DefaultActivityHandlers;
        (function (DefaultActivityHandlers) {
            /** @private */
            function handleIntersectLayers(activityContext) {
                geocortex.workflow.MapActivityHandlers.handleIntersectLayers(activityContext);
            }
            DefaultActivityHandlers.handleIntersectLayers = handleIntersectLayers;
            /** @private */
            function handleExportMap(activityContext) {
                geocortex.workflow.MapActivityHandlers.handleExportMap(activityContext);
            }
            DefaultActivityHandlers.handleExportMap = handleExportMap;
            /** @private */
            function handlePrintMap(activityContext) {
                geocortex.workflow.MapActivityHandlers.handlePrintMap(activityContext);
            }
            DefaultActivityHandlers.handlePrintMap = handlePrintMap;
            /** @private */
            function handleRefreshMap(activityContext) {
                // Get input values
                var mapServiceId = activityContext.getValue("MapServiceId");
                // Get the esri map
                var map = activityContext.getEsriMap();
                if (map != null) {
                    // Iterate over all service layers
                    var refreshMapService = function (mapService) {
                        // Ensure the layer can be refreshed
                        var serviceLayer = mapService.serviceLayer;
                        var hasRefresh = typeof (serviceLayer.refresh) == "function";
                        if (hasRefresh) {
                            if (typeof (serviceLayer.disableClientCaching) == "boolean") {
                                // Temporarily disable client caching if this layer supports it
                                var disableClientCaching = serviceLayer.disableClientCaching;
                                serviceLayer.disableClientCaching = true;
                                serviceLayer.refresh();
                                serviceLayer.disableClientCaching = disableClientCaching;
                            }
                            else {
                                // Just refresh
                                serviceLayer.refresh();
                            }
                        }
                    };
                    var mapServices = activityContext.workflow().site.essentialsMap.mapServices;
                    // Refresh the specified layer or all layers if no id is supplied                    
                    if (mapServiceId) {
                        var mapService = geocortex.essentials.utilities.SiteResourceIdComparer.lookUp(mapServices, mapServiceId);
                        if (mapService) {
                            refreshMapService(mapService);
                        }
                    }
                    else {
                        dojo.forEach(mapServices, function (service) {
                            refreshMapService(service);
                        });
                    }
                }
                else {
                    // esri map not available, can't capture
                    throw new Error("Refresh Map: no map available.");
                }
                activityContext.completeActivity();
            }
            DefaultActivityHandlers.handleRefreshMap = handleRefreshMap;
            /** @private */
            function handleGetMapExtent(activityContext) {
                var map = activityContext.getEsriMap();
                if (map == null) {
                    throw new Error("Get Map Extent: No map available.");
                }
                activityContext.setValue("Extent", map.extent);
                activityContext.completeActivity();
            }
            DefaultActivityHandlers.handleGetMapExtent = handleGetMapExtent;
            /** @private */
            function handleGetMapInfo(activityContext) {
                var map = activityContext.getEsriMap();
                if (map == null) {
                    throw new Error("Get Map Info: No map available.");
                }
                activityContext.setValue("Extent", map.extent);
                activityContext.setValue("Scale", esri.geometry.getScale(map));
                activityContext.setValue("SpatialReference", map.spatialReference);
                activityContext.setValue("Height", map.height);
                activityContext.setValue("Width", map.width);
                var mapServiceIds = [];
                if (map.layerIds != null) {
                    mapServiceIds = mapServiceIds.concat(map.layerIds);
                }
                if (map.graphicsLayerIds != null) {
                    mapServiceIds = mapServiceIds.concat(map.graphicsLayerIds);
                }
                activityContext.setValue("MapServiceIds", mapServiceIds);
                activityContext.completeActivity();
            }
            DefaultActivityHandlers.handleGetMapInfo = handleGetMapInfo;
            /** @private */
            function handleSetMapExtent(activityContext) {
                var extent = activityContext.getValue("Extent");
                if (extent != null) {
                    var map = activityContext.getEsriMap();
                    if (map != null) {
                        if (!extent.spatialReference || (!extent.spatialReference.wkid && !extent.spatialReference.wkt)) {
                            // Ensure the extent has a proper spatial reference
                            extent.spatialReference = map.spatialReference;
                        }
                        var site = activityContext.getSite();
                        if (site && site.essentialsMap) {
                            //replacing map.setExtent(extent); with the new extent manager call
                            site.essentialsMap.extentManager.setExtentWithPriority(extent, 10);
                        }
                        else {
                            map.setExtent(extent);
                        }
                    }
                    else {
                        throw new Error("Set Map Extent: No map available.");
                    }
                }
                else {
                    // Extent was null
                    throw new Error("Set Map Extent: required Extent argument was not supplied.");
                }
                // Complete the activity
                activityContext.completeActivity();
            }
            DefaultActivityHandlers.handleSetMapExtent = handleSetMapExtent;
            /** @private */
            function handleCaptureGeometry(activityContext) {
                var dispatcher = activityContext.dispatcher();
                //GVH-3756: We want all current captureGeometry activities (if any) to be aborted
                if (!dispatcher.abortMapBasedActivity()) {
                    throw new Error("Could not deactivate current map based activity.");
                }
                /** @private Function called to complete the activity. */
                function completeActivity(geometry, eventHandler, toolbar) {
                    toolbar.deactivate();
                    dojo.disconnect(eventHandler);
                    dispatcher.setDrawObjectContext(null);
                    activityContext.setValue("Result", geometry);
                    activityContext.completeActivity();
                }
                ;
                // Get input values
                var typeParam = activityContext.getValue("CaptureType");
                function getDrawType(typeParam) {
                    var drawType;
                    switch (typeParam) {
                        case 0:
                            drawType = esri.toolbars.Draw.EXTENT;
                            break;
                        case 1:
                            drawType = esri.toolbars.Draw.FREEHAND_POLYGON;
                            break;
                        case 2:
                            drawType = esri.toolbars.Draw.FREEHAND_POLYLINE;
                            break;
                        case 3:
                            drawType = esri.toolbars.Draw.LINE;
                            break;
                        case 4:
                            drawType = esri.toolbars.Draw.POINT;
                            break;
                        case 5:
                            drawType = esri.toolbars.Draw.MULTI_POINT;
                            break;
                        case 6:
                            drawType = esri.toolbars.Draw.POLYGON;
                            break;
                        case 7:
                            drawType = esri.toolbars.Draw.POLYLINE;
                            break;
                        case 8:
                            completeActivity(map.extent, drawEvent, toolbar);
                            drawRequired = false;
                            break;
                        default:
                            drawType = esri.toolbars.Draw.EXTENT;
                            break;
                    }
                    return drawType;
                }
                ;
                // Get the esri map
                var map = activityContext.getEsriMap();
                if (map != null) {
                    if (typeof (esri.toolbars.Draw) != "function") {
                        throw new Error("doj" + "o.requ" + "ire(\"esri.toolbars.draw\") must be added to your client code to use CaptureGeometry activity.");
                    }
                    var toolbar = new esri.toolbars.Draw(map);
                    var drawEvent = dojo.connect(toolbar, "onDrawEnd", dojo.hitch(drawEvent, function (geometry) {
                        completeActivity(geometry, drawEvent, toolbar);
                    }));
                    var drawRequired = true;
                    var drawType = getDrawType(typeParam);
                    if (drawRequired) {
                        toolbar.activate(drawType);
                    }
                }
                else {
                    // esri map not available, can't capture
                    throw new Error("Capture Geometry: No map available.");
                }
                dispatcher.setDrawObjectContext({
                    activityContext: activityContext,
                    toolbar: toolbar,
                    drawEvent: drawEvent
                });
            }
            DefaultActivityHandlers.handleCaptureGeometry = handleCaptureGeometry;
        })(DefaultActivityHandlers = workflow.DefaultActivityHandlers || (workflow.DefaultActivityHandlers = {}));
    })(workflow = geocortex.workflow || (geocortex.workflow = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/dojo.d.ts" />
/** @docs-hide-from-nav */
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        var xmlUtils;
        (function (xmlUtils) {
            /**
             * recursively build object from xml doc
             */
            function parseObject(node) {
                if (node) {
                    try {
                        if (node.nodeType === 3 || node.nodeType === 4) {
                            var trimmed = String.prototype.trim ? node.nodeValue.trim() : dojo.string.trim(node.nodeValue);
                            if (trimmed.length === 0) {
                                return null;
                            }
                            return trimmed;
                        }
                        else if (node.nodeType === 1) {
                            var o = {};
                            var childCount = 0;
                            // attributes
                            dojo.forEach(node.attributes, function (attr) {
                                o[attr.nodeName] = attr.nodeValue;
                            });
                            // child nodes
                            var childNodes = node.childNodes;
                            dojo.forEach(childNodes, function (child) {
                                var childValue = geocortex.essentials.xmlUtils.parseObject(child);
                                if (childValue) {
                                    childCount++;
                                    // Has there been a previous node with the same name?
                                    // If so, convert to an array of nodes with this name
                                    if (o[child.nodeName]) {
                                        if (dojo.isArray(o[child.nodeName]) === false) {
                                            o[child.nodeName] = [o[child.nodeName]];
                                        }
                                        o[child.nodeName].push(childValue);
                                    }
                                    else {
                                        o[child.nodeName] = childValue;
                                    }
                                }
                            });
                            if (childCount === 1 && o["#text"]) {
                                // Only child was a text node
                                return o["#text"];
                            }
                            if (childCount === 1 && o["#cdata-section"]) {
                                // Only child was a cdata node
                                return o["#cdata-section"];
                            }
                            return o;
                        }
                    }
                    catch (err) {
                        throw new Error("Unable to parse XML object: " + err.toString());
                    }
                }
                return null;
            }
            xmlUtils.parseObject = parseObject;
            function getAllNodes(node) {
                var nodes = new dojo.NodeList();
                if (dojo.isIE) {
                    var childNodes = node.childNodes;
                    for (var i = 0; i < childNodes.length; i++) {
                        nodes.push(childNodes[i]);
                    }
                }
                else {
                    nodes = dojo.query("*", node);
                }
                return nodes;
            }
            xmlUtils.getAllNodes = getAllNodes;
            function getNodes(parentTagName, childTagName, doc) {
                var nodes = new dojo.NodeList();
                if (dojo.isIE) {
                    var parentNodes = doc.getElementsByTagName(parentTagName);
                    dojo.forEach(parentNodes, function (parent, idx, arr) {
                        var childNodes = parent.getElementsByTagName(childTagName);
                        dojo.forEach(childNodes, function (child, idx, arr) {
                            nodes.push(child);
                        });
                    });
                }
                else {
                    nodes = dojo.query(parentTagName + " > " + childTagName, doc);
                }
                return nodes;
            }
            xmlUtils.getNodes = getNodes;
            function getValue(source, document) {
                if (source) {
                    var node = source;
                    if (dojo.isString(source)) {
                        var arr = source.split(" > ");
                        var nlist = this.getNodes(arr[0], arr[1], document);
                        node = nlist[0];
                    }
                    if (node.firstChild && node.firstChild.nodeValue) {
                        return node.firstChild.nodeValue;
                    }
                    return "Node not valid";
                }
                return "No Value";
            }
            xmlUtils.getValue = getValue;
            function getAttribute(node, attrName) {
                if (node) {
                    if (dojo.isIE) {
                        for (var i = 0; i < node.attributes.length; i++) {
                            if (node.attributes[i].nodeName == attrName) {
                                return node.attributes[i].nodeValue;
                            }
                        }
                        return null;
                    }
                    else {
                        return node.getAttribute(attrName);
                    }
                }
                return "No Value";
            }
            xmlUtils.getAttribute = getAttribute;
        })(xmlUtils = essentials.xmlUtils || (essentials.xmlUtils = {}));
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../essentials.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Bundles the resulting object from a REST request, its JSON representation, and any error which occurred during the request into a single object.
         */
        var RestEndpointResult = (function () {
            /**
             * Initializes a new instance of the {@link RestEndpointResult} class.
             * @param resultObject The object that represents the results of the REST request.
             * @param error The error.
             */
            function RestEndpointResult(resultObject, error) {
                this.error = error;
                this.resultObject = resultObject;
                if (resultObject) {
                    //Create the json string representation of this object
                    this.rawJson = geocortex.encodeJson(resultObject);
                }
            }
            return RestEndpointResult;
        }());
        essentials.RestEndpointResult = RestEndpointResult;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../essentials.ts" />
/// <reference path="RestEndpointResult.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Provides the functionality to access a custom REST endpoint and process any resulting response objects.
         */
        var RestUtility = (function () {
            function RestUtility() {
                /** @private */
                this._activeEndpointRequest = false;
                /** @private */
                this._onRequestComplete = null;
                /** @private */
                this._onRequestError = null;
            }
            /**
             * Retrieves an object from an arbitrary rest endpoint. This is an asynchronous method, you may provide delegates for completion or error information.
             * @param endpointUrl The Rest endpoint to retrieve the object from.
             * @param completeHandler The delegate that will be called when the operation has completed
             *        (even if an error occurs).
             * @param errorHandler The delegate that will be called if an error occurs.
             * @param options Same as {@link esri.request} (useProxy, usePost).
             */
            RestUtility.prototype.getCustomRestEndpoint = function (endpointUrl, content, completeHandler, errorHandler, options) {
                // Is there an active request operation taking place??
                if (this._activeEndpointRequest) {
                    this._onEndpointRequestError(new Error("An operation is already in progress."));
                    return;
                }
                this._activeEndpointRequest = true;
                this._onRequestComplete = completeHandler;
                this._onRequestError = errorHandler;
                geocortex.request({
                    url: endpointUrl,
                    content: content,
                    load: dojo.hitch(this, this._onEndpointRequestComplete),
                    error: dojo.hitch(this, this._onEndpointRequestError),
                    callbackParamName: "CallBack"
                }, options);
            };
            /** @private */
            RestUtility.prototype._onEndpointRequestComplete = function (results) {
                this._activeEndpointRequest = false;
                try {
                    if (!results) {
                        results = { error: new Error("Expected results") };
                    }
                    if (results.error) {
                        // Check if the printing Failed event is defined
                        if (this._onRequestError) {
                            this._onRequestError(results.error);
                        }
                    }
                }
                finally {
                    if (this._onRequestComplete) {
                        this._onRequestComplete(new geocortex.essentials.RestEndpointResult(results, results.error));
                    }
                }
            };
            /** @private */
            RestUtility.prototype._onEndpointRequestError = function (error) {
                this._activeEndpointRequest = false;
                try {
                    if (this._onRequestError) {
                        this._onRequestError(error);
                    }
                }
                finally {
                    if (this._onRequestComplete) {
                        this._onRequestComplete(new geocortex.essentials.RestEndpointResult(null, error));
                    }
                }
            };
            return RestUtility;
        }());
        essentials.RestUtility = RestUtility;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));
/// <reference path="../../../../_Definitions/arcgis-js-api.d.ts" />
/// <reference path="XmlUtils.ts" />
/// <reference path="MapService.ts" />
var geocortex;
(function (geocortex) {
    var essentials;
    (function (essentials) {
        /**
         * Representation of a GeoRSS layer. The properties in this class represent the configuration served from the Essentials REST API.
         */
        var GeoRssLayerService = (function (_super) {
            __extends(GeoRssLayerService, _super);
            /**
            * Initializes a new instance of the {@link GeoRssLayerService} class.
            * @param url  The URL of the GeoRSS feed to load.
            */
            function GeoRssLayerService(url) {
                _super.call(this, url);
                /** @private */
                this._colorSet = false;
                /** @private */
                this._layerLoadCompleted = null;
                /**
                 * The color in which complex geometries like polygon and polyline will be drawn, represented as an integer array
                 * of red, green, and blue values in 0-255. */
                this.color = null;
                /** GeoRSS feed URL. */
                this.feedUrl = null;
                /** Picture image that represents a GeoRSS feed item. */
                this.feedImageUri = null;
                /** The GeoRSS feed update interval in seconds. The feed will be refreshed on this interval. */
                this.updateInterval = null;
                /** The symbol for feedImageUri. */
                this.pictureSymbol = null;
                /** The rendering symbol when no feedImageUri provided. */
                this.markerSymbol = null;
                /** The graphics layer which represents a GeoRSS layer. */
                this.geoRssLayer = null;
                /** The spatial reference of the map. */
                this.mapSpatialReference = null;
                /** A geometry service for projecting feed shapes to map spatial reference. */
                this.geometryService = null;
            }
            /** @private */
            GeoRssLayerService.prototype._configureObject = function (obj, deepInitialize) {
                if (obj === undefined) {
                    throw new Error("Incorrect map service object returned from initialization");
                }
                GeoRssLayerService.webMercatorSref = new esri.SpatialReference({ wkid: 102100 });
                GeoRssLayerService.wgs84Sref = new esri.SpatialReference({ wkid: 4326 });
                this.feedImageUri = obj.feedImageUri;
                this.updateInterval = obj.updateInterval;
                this.geoRssLayer = new esri.layers.GraphicsLayer({
                    opacity: obj.opacity,
                    id: obj.id,
                    visible: obj.visible
                });
                dojo.connect(this.geoRssLayer, "onError", this, this._layerLoadErrorHandler);
                if (obj.color) {
                    this.color = obj.color;
                    this._colorSet = true;
                    // Essentials provides the color's alpha value as a number between 0 and 255 (inclusive),
                    // but the constructor for dojo.Color expects a number between 0 and 1 (inclusive).
                    if (this.color.length > 3) {
                        this.color[3] = this.color[3] / 255;
                    }
                }
                _super.prototype._configureObject.call(this, obj, deepInitialize);
                if (this.attributionDataUrl && this.attributionDataUrl !== "") {
                    this.geoRssLayer.attributionDataUrl = this.attributionDataUrl;
                    this.geoRssLayer.hasAttributionData = true;
                }
                else if (this.hasAttributionData) {
                    this.geoRssLayer.attributionDataUrl = this.url + "/Attribution";
                    this.geoRssLayer.hasAttributionData = true;
                }
            };
            /** @private */
            GeoRssLayerService.prototype._createServiceLayer = function () {
                // Token replacement for marker symbol associated with the feed
                var site = null;
                if (this.essentialsMap) {
                    site = this.essentialsMap.site;
                    this.mapSpatialReference = this.essentialsMap.initialExtent.spatialReference;
                }
                if (this.feedImageUri) {
                    this.feedImageUri = geocortex.essentials.RestHelper.processClientSideTokens(site, this.feedImageUri);
                    this.pictureSymbol = new esri.symbol.PictureMarkerSymbol(this.feedImageUri, 25, 25);
                }
                else {
                    this.markerSymbol = new esri.symbol.SimpleMarkerSymbol(esri.symbol.SimpleMarkerSymbol.STYLE_CIRCLE, 15, new esri.symbol.SimpleLineSymbol(), new esri.Color(this.color));
                }
                // feedUrl is obsolete but gets populated here for backward compatibility.
                this.feedUrl = this.serviceUrl;
                this._loadFeed();
                if (this.updateInterval && !isNaN(this.updateInterval)) {
                    var _this = this;
                    this._layerLoadCompleted = false;
                    var startInterval = setInterval(function () {
                        if (_this._layerLoadCompleted) {
                            _this._loadFeed();
                        }
                        _this._layerLoadCompleted = false;
                    }, this.updateInterval * 1000);
                    dojo.connect(window, "onunload", function () {
                        clearInterval(startInterval);
                    });
                }
                this.serviceLayer = this.geoRssLayer;
            };
            /**
             * @private
             * Loads the GeoRSS feed.
             */
            GeoRssLayerService.prototype._loadFeed = function () {
                if (esri.config.defaults.io.proxyUrl) {
                    esri.request({
                        url: this.serviceUrl,
                        content: {},
                        handleAs: "xml",
                        load: dojo.hitch(this, this._handleFeed),
                        error: function (error) {
                            if (error && error.message && typeof (error.message) == "string") {
                                alert(error.message);
                            }
                        }
                    });
                }
            };
            /**
             * @private
             * Parses the GeoRSS feed and creates features from the feed items.
             */
            GeoRssLayerService.prototype._handleFeed = function (response) {
                var feedNode = this._getFeedRoot(response);
                if (!feedNode) {
                    return;
                }
                var feedNodeName = feedNode.nodeName;
                var urlBase = geocortex.essentials.xmlUtils.getAttribute(feedNode, "xml:base");
                var features = [];
                var entryNodes = null;
                // all items have the tag "entry" and live under the "feed" node
                if (feedNodeName === "feed") {
                    entryNodes = geocortex.essentials.xmlUtils.getNodes("feed", "entry", response);
                }
                else if (feedNodeName === "rdf") {
                    entryNodes = geocortex.essentials.xmlUtils.getNodes("rdf", "item", response);
                }
                else if (feedNodeName === "rss") {
                    entryNodes = geocortex.essentials.xmlUtils.getNodes("channel", "item", response);
                }
                if (!entryNodes) {
                    return;
                }
                var symbol = this.pictureSymbol || this.markerSymbol;
                entryNodes.forEach(dojo.hitch(this, function (node, idx, arr) {
                    var title;
                    var link;
                    var description;
                    var point = null;
                    var allEntryChildren = geocortex.essentials.xmlUtils.getAllNodes(node);
                    allEntryChildren.forEach(dojo.hitch(this, function (enode, eidx, earr) {
                        if (!enode.nodeName) {
                            // return simulates a continue here inside a forEach loop.
                            return;
                        }
                        // title is the same across all RSS formats
                        if (enode.nodeName === "title") {
                            title = enode.firstChild.nodeValue;
                        }
                        // if Atom = summary, in RSS 1,2 = description
                        if (feedNodeName === "feed") {
                            if (enode.nodeName === "summary") {
                                description = enode.firstChild.nodeValue;
                            }
                        }
                        else {
                            if (enode.nodeName === "description") {
                                description = enode.firstChild.nodeValue;
                            }
                        }
                        // in Atom link is an href attribute, RSS 1,2 it is the content of link
                        if (enode.nodeName === "link") {
                            if (feedNodeName === "feed") {
                                link = (urlBase || "") + geocortex.essentials.xmlUtils.getAttribute(enode, "href");
                            }
                            else {
                                // is rss 1 or 2
                                link = (urlBase || "") + enode.firstChild.nodeValue;
                            }
                        }
                        // Since RSS feeds can have conflicting name spaces present, check for all types of point
                        // GML RSS point
                        if (enode.nodeName === "georss:where") {
                            point = this._getGMLGRSSPoint(enode);
                        }
                        // Simple GeoRSS point
                        if (enode.nodeName === "georss:point") {
                            point = this._getSimpleGRSSPoint(enode);
                        }
                        // WC3 WGS84 point
                        if (enode.nodeName === "geo:lat") {
                            point = this._getW3CGRSSPoint(enode);
                        }
                    }));
                    if (point) {
                        var attrs = {
                            title: title,
                            content: description,
                            link: link
                        };
                        features.push(new esri.Graphic(point, symbol, attrs, null));
                    }
                }));
                if (this.mapSpatialReference) {
                    this._projectShapes(features, this.mapSpatialReference);
                }
            };
            /**
             * @private
             * Does the projection of the graphic objects onto the map.
             */
            GeoRssLayerService.prototype._projectShapes = function (features, outSR) {
                if (features && outSR) {
                    // If the features all have the same SR as the map, don't project, just call the callback
                    var bNeedProj = false;
                    var webMercatorWkid = GeoRssLayerService.webMercatorSref.wkid;
                    var wgs84Wkid = GeoRssLayerService.wgs84Sref.wkid;
                    for (var i = 0; i < features.length; i++) {
                        var g = features[i];
                        var geom = null;
                        if (g.geometry && g.geometry.spatialReference.wkid !== outSR.wkid) {
                            if (outSR.wkid === webMercatorWkid && g.geometry.spatialReference.wkid === wgs84Wkid) {
                                geom = esri.geometry.geographicToWebMercator(g.geometry);
                            }
                            else if (outSR.wkid === wgs84Wkid && g.geometry.spatialReference.wkid === webMercatorWkid) {
                                geom = esri.geometry.webMercatorToGeographic(g.geometry);
                            }
                            else {
                                geom = esri.geometry.geographicToWebMercator(g.geometry);
                                bNeedProj = true;
                            }
                            g.geometry = geom;
                        }
                    }
                    if (bNeedProj) {
                        var geometryArray = [];
                        var geometryServiceUrl = this.geometryServiceUrl || this._getDefaultGeometryServiceUrl();
                        var geometryServiceToken = this.geometryServiceUrl ? null : this._getDefaultGeometryServiceToken();
                        if (geometryServiceToken !== null) {
                            geometryServiceUrl += ((geometryServiceUrl.indexOf("?") > -1) ? "&token=" : "?token=") + encodeURIComponent(geometryServiceToken);
                        }
                        this.geometryService = new esri.tasks.GeometryService(geometryServiceUrl);
                        dojo.forEach(features, function (g) {
                            geometryArray.push(g.geometry);
                        });
                        var projectParams = new esri.tasks.ProjectParameters();
                        projectParams.geometries = geometryArray;
                        projectParams.outSR = outSR;
                        this.geometryService.project(projectParams, dojo.hitch(this, function (geometries) {
                            // Re-attaching the geometries back to features.
                            for (var geoIndex = 0; geoIndex < geometries.length; geoIndex++) {
                                features[geoIndex].geometry = geometries[geoIndex];
                            }
                            this._publishLayer(features);
                        }), this._projectionError);
                        return;
                    }
                }
                this._publishLayer(features);
            };
            GeoRssLayerService.prototype._publishLayer = function (features) {
                if (!this.geoRssLayer) {
                    return;
                }
                this.geoRssLayer.clear();
                dojo.forEach(features, dojo.hitch(this, function (g) {
                    this.geoRssLayer.add(g);
                }));
                this.geoRssLayer.redraw();
                var params = {
                    esriLayer: this.geoRssLayer
                };
                // Tells the world that a GeoRSS layer has been loaded
                dojo.publish("geoRssLayerLoaded", [params]);
                this._layerLoadCompleted = true;
            };
            /**
             * @private
             * Projection failed for GeoRss layer.
             */
            GeoRssLayerService.prototype._projectionError = function (error) {
                // alert(error);
            };
            /**
             * @private
             * Provides support for SIMPLE encoding.
             */
            GeoRssLayerService.prototype._getSimpleGRSSPoint = function (entryNode) {
                var stringPoint = entryNode.firstChild.nodeValue;
                var coords = stringPoint.split(" ");
                return new esri.geometry.Point(parseFloat(coords[1]), parseFloat(coords[0]), GeoRssLayerService.wgs84Sref);
            };
            /**
             * @private
             * Provides support for GML encoding.
             */
            GeoRssLayerService.prototype._getGMLGRSSPoint = function (entryNode) {
                var pointNode = this._getNonTextNodeChild(entryNode);
                var posNode = this._getNonTextNodeChild(pointNode);
                var gmlPosNodeValue = posNode.firstChild.nodeValue;
                var coords = gmlPosNodeValue.split(" ");
                return new esri.geometry.Point(parseFloat(coords[1]), parseFloat(coords[0]), GeoRssLayerService.wgs84Sref);
            };
            /**
             * @private
             * Gets a none-text element.
             */
            GeoRssLayerService.prototype._getNonTextNodeChild = function (node) {
                var childNodes = node.childNodes;
                for (var i = 0; i < childNodes.length; i++) {
                    if (childNodes[i].nodeType !== 3) {
                        return childNodes[i];
                    }
                }
            };
            /**
             * @private
             * Provides support for W3C geo vocabulary.
             */
            GeoRssLayerService.prototype._getW3CGRSSPoint = function (latNode) {
                if (!latNode.nextSibling) {
                    return null;
                }
                var longNode = latNode.nextSibling;
                if (latNode.nextSibling.nodeName === "#text") {
                    longNode = latNode.nextSibling.nextSibling;
                }
                var lat = latNode.firstChild.nodeValue;
                var lon = longNode.firstChild.nodeValue;
                return new esri.geometry.Point(parseFloat(lon), parseFloat(lat), GeoRssLayerService.wgs84Sref);
            };
            /**
             * @private
             * Gets the root node of the feed.
             */
            GeoRssLayerService.prototype._getFeedRoot = function (response) {
                if (!response) {
                    // A null response indicates that the result is not valid XML.
                    throw new Error("The GeoRSS service at " + this.feedUrl + " returned an invalid response.");
                }
                var childNodes = response.childNodes;
                for (var i = 0; i < childNodes.length; i++) {
                    if (!childNodes[i]) {
                        continue;
                    }
                    var childName = childNodes[i].nodeName;
                    var subString = childName.substring(0, 3);
                    if (subString !== "xml") {
                        return childNodes[i];
                    }
                }
                return null;
            };
            /**
             * WebMercator Spatial Reference. Some client-side handling exists, particularly between this and {@link wgs84Sref}.
             */
            GeoRssLayerService.webMercatorSref = null;
            /**
             * WGS84 Spatial reference. See {@link webMercatorSref}.
             */
            GeoRssLayerService.wgs84Sref = null;
            return GeoRssLayerService;
        }(essentials.MapService));
        essentials.GeoRssLayerService = GeoRssLayerService;
    })(essentials = geocortex.essentials || (geocortex.essentials = {}));
})(geocortex || (geocortex = {}));

/* End Script: _JavaScriptAPI/Essentials/essentials_ts_out.js ------------------------- */ 

//# sourceMappingURL=essentials_ts_out.js.map
