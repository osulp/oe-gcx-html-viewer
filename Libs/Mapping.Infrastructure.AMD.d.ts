/// <reference path="_all.d.ts" />
/// <reference path="Essentials.AMD.d.ts" />
/// <reference path="Framework.AMD.d.ts" />
/// <reference path="Framework.UI.AMD.d.ts" />
/// <reference path="kendo.all.d.ts" />
declare module "geocortex/infrastructure/AreaOfInterestMask" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
/**
 * Masks everything outside of a certain area of interest (AOI).
 */
export class AreaOfInterestMask {
    app: ViewerApplication;
    private _originalMapBackground;
    private _aoi;
    private _enabled;
    /**
      * Whether to set the map background color to be the same as the fill color. This can be be useful because the
      * mask may not reach all the way to the outer edges of the map. Setting this to true will ensure full coverage.
      */
    matchMapBackground: boolean;
    /**
      * The color of the mask.
      */
    fillColor: any;
    /**
      * The color of the AOI outline.
      */
    boundaryColor: esri.Color;
    /**
      * The thickness of the AOI otuline.
      */
    boundaryWidth: number;
    /**
      * The style of the AOI otuline.
      */
    boundaryStyle: any;
    /**
      * The layer id to use for map graphics.
      */
    layerId: string;
    constructor(app: ViewerApplication, config?: AreaOfInterestMaskConfig);
    /**
     * Shows the mask. Will not be shown if the mask is disabled.
     * @param areaOfInterest The area of interest to to be visible. Everything outside of this will be hidden.
     */
    show(areaOfInterest: esri.geometry.Polygon): void;
    /**
     * Eliminates the mask.
     */
    hide(): void;
    /**
     * Enables the mask. If it was not enabled while show() was called, this method will actually show the mask.
     */
    enable(): void;
    /**
     * Disables the mask. If show() is called while disabled, it will not actually be shown.
     */
    disable(): void;
    /**
     * Configures this AreaOfInterestMask to match the properties specified in the config. Any properties that are null
     * or undefined will retain their existing values.
     */
    configure(config?: AreaOfInterestMaskConfig): void;
    private _getLayer();
    private _getMapNode();
}
/**
 * Configuration properties for the AreaOfInterestMask.
 */
export interface AreaOfInterestMaskConfig {
    /**
      * Whether the mask should be actually shown or not when the show() method is called.
      * If disabled, it will not be shown, even if show() is called.
      */
    enabled?: boolean;
    /**
      * The color of the mask.
      */
    fillColor?: string | number[];
    /**
      * The color of the AOI outline.
      */
    boundaryColor?: string | number[];
    /**
      * The style of the AOI outline ("null", "solid", "dash", "dot").
      */
    boundaryStyle?: string;
    /**
      * The thickness of the AOI otuline.
      */
    boundaryWidth?: number;
    /**
      * The layer id to use for map graphics.
      */
    layerId?: string;
    /**
      * Whether to set the map background color to be the same as the fill color. This can be be useful because the
      * mask may not reach all the way to the outer edges of the map. Setting this to true will ensure full coverage.
      */
    matchMapBackground?: boolean;
}

}
declare module "geocortex/infrastructure/ArrayUtils" {
export class ArrayUtils {
    /**
     * Sorts an array based on a particular property or function value.
     */
    static sortBy<T>(items: Array<T>, selector: (item: T) => any): Array<T>;
    /**
     * Calculates the sum of all items based on a callback selector value.
     */
    static sum<T>(items: T[], callback: (item: T) => number): number;
    /**
     * Calculates the maximum of all items based on a callback selector value.
     */
    static max<T>(items: T[], callback: (item: T) => any): any;
    /**
     * Similar to Array.map, except that any time that an item in the input causes the callback function to throw an error,
     * an error handler will be invoked rather than aborting. These items will be skipped in the output, so unlike Array.map(),
     * it's possible that the output array may contain a different number of items from the input.
     */
    static mapWithErrorCallback<T, U>(array: T[], callback: (T) => U, errCallback: (item: T, error: Error, result: U[]) => void, thisArg?: any): U[];
    static findIndex<T>(array: T[], predicate: (T) => boolean): number;
    /**
     * Returns unique values found in an array of numbers or strings.
     * @param items The raw array of values
     */
    static unique<T extends number | string>(items: Array<T>): Array<T>;
}

}
declare module "geocortex/infrastructure/AttachmentInfo" {
import { Observable } from "geocortex/framework/observables";
export class AttachmentInfo {
    /**
     * The id of the attachment.
     * @type Number
     */
    id: Observable<number>;
    /**
     * The content type of the attachment file.
     * @type String
     */
    contentType: Observable<string>;
    /**
     * The size of the attachment.
     * @type Number
     */
    size: Observable<number>;
    /**
     * The name of the attachment.
     * @type String
     */
    name: Observable<string>;
    /**
     * The url to retrieve the attachment.
     * @type String
     */
    url: Observable<string>;
    /**
     * Initializes a new instance of the {@link AttachmentInfo} class.
     */
    constructor();
}

}
declare module "geocortex/infrastructure/AttributeGroup" {
export class AttributeGroup {
    /**
     * An attribute map that maps the name of an attribute to the value
     * @type Map object that represents a collection of attributes
     */
    attributes: {
        [key: string]: any;
    };
    /**
     * The source of this attribute group. Used if we need to resolve additional information, such as namings
     * @type Object the instance of the original owner of this set of attributes
     */
    owner: any;
}

}
declare module "geocortex/infrastructure/Bookmark" {
import { BookmarkSource } from "geocortex/infrastructure/BookmarkManager";
export interface Bookmark {
    name: string;
    extent: esri.geometry.Extent;
    source: BookmarkSource;
}

}
declare module "geocortex/infrastructure/BookmarkManager" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { Bookmark } from "geocortex/infrastructure/Bookmark";
import { Bookmark as WebMapBookmark } from "geocortex/infrastructure/webMap/Bookmark";
/**
 * Indicates where a bookmark was loaded from.
 */
export enum BookmarkSource {
    Site = 0,
    User = 1,
    Project = 2,
}
export class BookmarkManager {
    app: ViewerApplication;
    /** Stores bookmarks that come from a project. */
    private _projectBookmarks;
    constructor(app: ViewerApplication);
    /**
     * Gets all bookmarks.
     */
    getAll(): Promise<Bookmark[]>;
    /**
     * Gets the user-defined bookmarks.
     */
    getUserBookmarks(): Promise<Bookmark[]>;
    /**
     * Gets the bookmarks that are defined in the site.
     */
    getSiteBookmarks(): Promise<Bookmark[]>;
    /**
     * Gets the bookmarks that were restored from a project.
     */
    getProjectBookmarks(): Promise<Bookmark[]>;
    /**
     * Adds a new bookmark.
     */
    add(bookmark: Bookmark): Promise<void>;
    /**
     * Removes a bookmark. Only user-defined bookmarks can be removed this way.
     * @param bookmark The bookmark to remove, or the name of the bookmark. In the latter case,
     *     if multiple bookmarks exist with the given name, then ALL user-defined bookmarks with
     *     the given name will be removed.
     */
    remove(bookmark: Bookmark | string): Promise<void>;
    /**
     * Exports bookmarks in web map format.
     */
    export(sourceTypes?: BookmarkSource[]): Promise<WebMapBookmark[]>;
    private _save(bookmarks);
    private _serialize(bookmark);
    private _deserialize(serializedBookmark);
}

}
declare module "geocortex/infrastructure/BrowserUtils" {
/**
 * Detectes whether the current browser is Internet Explorer.
 * Returns the version number if it is or -1 if it's not.
 */
export function isIE(): number;
/**
 * Detectes whether the current browser is Edge.
 * Returns the version number if it is or -1 if it's not.
 */
export function isEdge(): number;
/**
 * Detects whether the current browser is Chrome
 */
export function isChrome(): boolean;
/**
 * Detectes whether the current browser is either Internet Explorer or Edge (versions 12 and above)
 * and returns the version. Returns -1 if the current browser is not IE.
 * Adapted from https://codepen.io/gapcode/pen/vEJNZN. Verified with https://msdn.microsoft.com/en-us/library/hh869301(v=vs.85).aspx.
 */
export function isInternetExplorerOrEdge(): number;

}
declare module "geocortex/infrastructure/CancellationToken" {
/**
 * A cancellation token allows you to check if an operation has been cancelled.
 * Additionally, you can subscribe to be notified when cancellation occurs.
 * CancellationTokens should only be obtained from the CancellationTokenSource.token property.
 */
export interface CancellationToken {
    /**
     * Specifies if cancellation has been requested. This value should never be set
     * explicitly. Instead, a CancellationToken should be cancelled using the CancellationTokenSource
     * that it was derived from.
     */
    isCancellationRequested: boolean;
    /**
     * Register a handler to be notified when cancellation occurs.
     */
    register(action: () => void): any;
}

}
declare module "geocortex/infrastructure/CancellationTokenSource" {
import { CancellationToken } from "geocortex/infrastructure/CancellationToken";
/**
 * A source for generating CancellationTokens. First create a CancellationTokenSource, then
 * using the token property to obtain the cancellation token. The token can be cancelled by
 * calling cancel() on the CancellationTokenSource.
 */
export class CancellationTokenSource {
    private _tokenImpl;
    private static _none;
    constructor();
    /**
     * Gets the cancellation token.
     */
    token(): CancellationToken;
    /**
     * Cancels the CancellationToken, setting isCancellationRequested to true, and invoking any registered listeners.
     */
    cancel(): void;
    /**
     * Removes subscriptions that were created using register().
     */
    dispose(): void;
    /**
     * Creates a CancellationToken that does nothing.
     */
    static none(): CancellationToken;
}

}
declare module "geocortex/infrastructure/ClusterLayer" {
import { Observable } from "geocortex/framework/observables";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { Layer } from "geocortex/essentials/Layer";
import { MapService } from "geocortex/essentials/MapService";
export interface Cluster {
    x: number;
    y: number;
    attributes: ClusterAttributes;
}
export interface ClusterAttributes {
    clusterCount: number;
    clusterId: number;
    extent: Array<number>;
}
export const ClusterHidingOptions: {
    "none": number;
    "unselected": number;
};
export interface GcxEventHandler {
    eventName: string;
    token: string;
}
export interface RendererInformation {
    rangeString: Observable<string>;
    isVisible: Observable<boolean>;
}
/**
 * Representation of a ClusterLayer.
 */
export class ClusterLayer extends esri.layers.GraphicsLayer {
    app: ViewerApplication;
    /** The Geocortex Layer that is used as the basis for the cluster layer. */
    gcxLayer: Layer;
    /** The Feature Layer that is used as the basis for the cluster layer. */
    featureLayer: esri.layers.FeatureLayer;
    /** Layer to represent the individual graphics within an expanded cluster. */
    singleFeatureLayer: esri.layers.GraphicsLayer;
    /** The radius of each cluster. */
    clusterRadius: Observable<number>;
    /** The maximum number of features to include in a cluster. */
    maxFeaturesInCluster: Observable<number>;
    hideClusters: Observable<number>;
    /** Retyping of the renderer to show that we're using a ClassBreaksRenderer */
    renderer: esri.renderer.ClassBreaksRenderer;
    /** Observale information about the renderer currently in use. Used by the legend. */
    rendererInformation: RendererInformation[];
    /** The renderer for the Feature Layer that is passed in on object construction. */
    featureLayerRenderer: esri.renderer.Renderer;
    /** All of the graphics from the feature layer. */
    protected _featureLayerGraphics: esri.Graphic[];
    /** Collection of information for all clusters. */
    protected _clusters: Cluster[];
    /** The clusters that are currently being hidden when a cluster is focused upon/exploded. */
    protected _hiddenClusters: esri.Graphic[];
    /** Color of the label on clusters. */
    protected _clusterLabelColor: esri.Color;
    /** Background color of clusters. */
    protected _clusterBackgroundColor: esri.Color;
    /** The name of the FeatureSet that the features inside of exploded clusters will be placed into. */
    protected _featureSetName: string;
    /** Event handlers that are handled by esri/dojo. */
    protected _esriEventHandlers: esri.Handle[];
    /** Event handlers that are handled by geocortex/Framework*/
    protected _gcxEventHandlers: GcxEventHandler[];
    /** The font size */
    protected _fontSize: string;
    /** The font family */
    protected _fontFamily: string;
    /** Flag to track whether a cluster was previously exploded */
    protected _clusterExploded: boolean;
    /** Flag to track whether map clicks are currently disabled */
    protected _mapClickEnabled: boolean;
    /** Needed to prevent bogus extent change events in Chrome */
    protected _currExtent: esri.geometry.Extent;
    /** Don't change this unless you are really sure you know what you are doing. */
    protected MAP_CLICK_PREVENTION_DELAY: number;
    /** Is this Chrome? */
    protected _isChrome: boolean;
    constructor(gcxLayer: Layer, app: ViewerApplication);
    /**
     * Called whenever clusters need to be recalculated.
     * Will clear the features from an exploded cluster on the map, recalculate the clusters, then redraw the cluster layer
     */
    recluster(): void;
    /**
     * Clears all of the event handlers, layers, and other persistent things that are associated with this cluster.
     */
    destroy(): void;
    /**
     * Used to detect when a cluster is clicked by the user.
     * If a valid click is detected, then all other clusters are hidden and the selected cluster has its graphics displayed.
     * @param event The ArcGIS MouseEvent that triggered the cluster's click action.
     */
    onFeatureClicked(event: esri.AGSMouseEvent): void;
    /**
     * Returns true if a cluster is exploded on the map
     * @returns boolean
     */
    isClusterExploded(): boolean;
    /**
     * Adds the cluster with a given id to a map tip, exploding it if necessary
     * @param  {} clusterId
     * @returns void
     */
    protected _addClusterToMapTip(clusterId: any, currentlyExploded: boolean): void;
    /**
     * If there is more than one feature in the cluster we need to 'explode' it to show all the features
     * @param clusterId
     */
    protected _explodeCluster(clusterId: any, clusterFeatures: esri.Graphic[], currentlyExploded: boolean): void;
    /**
     * Handles removing the current exploded cluster and reclustering it
     */
    protected _implodeCluster(): void;
    /**
     * Assigns values and event listeners concerned with the map.
     * @param map The esri map that is associated with this layer.
     */
    protected _setupEventListeners(map: esri.Map): void;
    /**
     * Runs after a geometry edit/feature editor is closed to ensure what is represented is proper.
     */
    protected _handleGeometryChange(): void;
    /**
     * Runs after the Feature Editor is closed.
     */
    protected _handleEditorClosedEvent(): void;
    /**
     * GVH-8134: Handling mouse up / mouse down instead of mapClick as map clicks can fail to fire in Chrome sometimes when clicking on a cluster layer.
     * This doesn't address the root cause (whatever that might be) but does effectively work around the problem.
     * @param event
     */
    protected _mapMouseDownEvent(event: MouseEvent): void;
    /**
     * Run whenever the map is clicked and the cluster layer is active.
     * @param event The MouseEvent/TouchEvent that triggered this.
     */
    protected _mapClickedEvent(event: any): void;
    /**
     * Run whenever the map's extent is changed and clustering is active.
     * @param extent The new extent of the map.
     * @param args Arguments involving the map's new extent.
     */
    protected _mapExtentChangedEvent(extent: any, args: any): void;
    /**
     * Clears the data from the cluster that has been exploded when a maptip is closed.
     */
    protected _mapTipClosedEvent(): void;
    /**
     * Cleans up the cluster layer that has been removed.
     * @param clusterLayer The ClusterLayer that is being disabled/removed.
     */
    protected _clusterLayerRemovedEvent(clusterLayer: ClusterLayer): void;
    /**
     * Raised whenever a layer's visibility changes. Used to make it so clusters are invisible when a layer is disabled at
     * the layer list level.
     * @param result An object with an Essentials Layer, MapService, and visibility boolean.
     */
    protected _layerVisibilityChangedEvent(result: {
        layer: Layer;
        mapService: MapService;
        visibility: boolean;
    }[]): void;
    /**
     * Sets up the renderer and the various breaks that are used to represent clusters at different sizes.
     * This can be called dynamically as the size of the clusters change depending on the number of features in the largest cluster.
     */
    protected _loadRenderer(): void;
    /**
     * Checks to see if a valid break can be generated from the passed in information. If so, then generates a break on the passed renderer.
     * @param renderer The ClassBreaksRenderer that will have a new break added to it.
     * @param symbolSize The size in pixels of the circle to be generated.
     * @param rangeStart The start of the range.
     * @param rangeEnd The end of the range.
     * @param largestClusterSize The number of features in the largest cluster on screen.
     * @param rendererInformationPosition RendererInformation tracks visibility/values on a 0-3 scale to communicate to the legend.
     */
    protected _addBreak(renderer: esri.renderer.ClassBreaksRenderer, symbolSize: number, rangeStart: number, rangeEnd: number, largestClusterSize: number, rendererInformationPosition: number): void;
    /**
     * Used to make the passed color arrray slightly transparent.
     * @param color An array of RGBA color values.
     */
    protected _makeTransparent(color: Array<number>): Array<number>;
    /**
     * Checks to see if the passed point is within the tolerance (pixels) of the current cluster.
     * @param point The point to compare to the cluster.
     * @param cluster The cluster to compare to the point.
     */
    protected _isValidCluster(point: esri.geometry.Point, cluster: Cluster, resolution: number): boolean;
    /**
     * Checks to see if the current cluster has exceeded the configured maximum cluster size.
     * Returns false if no maximum cluster size is configured.
     * @param cluster The cluster to evaluate.
     */
    protected _isClusterFull(cluster: Cluster): boolean;
    /**
     * Generates the clusters by going through the graphics stored in _featureLayerGraphics.
     */
    protected _generateClusters(): void;
    /**
     * Matches up graphics with clusters and associates them.
     * @param preserveClusterLocation Whether the addition of a point to a cluster should adjust where the cluster is located.
     */
    protected _addGraphicsToClusters(preserveClusterLocation: boolean): void;
    /**
     * Adds all generated clusters to the layer.
     * Before doing so, it checks to see what the breaks should be for graphically representing cluster size.
     */
    protected _showAllClusters(): void;
    /**
     * Adds an individual cluster to the layer.
     * @param cluster The cluster to add to the layer.
     */
    protected _showCluster(cluster: Cluster): void;
    /**
     * Retrieves the symbology associated with the passed esri graphic.
     * @param graphic The Esri graphic to retrieve the feature symbology for.
     */
    protected _getRenderedSymbol(graphic: esri.Graphic): esri.symbol.Symbol;
    /**
     * Adds a point to an existing cluster.
     * @param graphic The graphic to be associated with the cluster.
     * @param p The point/graphic that will readjust the cluster location.
     * @param cluster The cluster to be associated with.
     * @param preserveClusterLocation Whether the cluster's location should be adjusted when the point is added.
     */
    protected _clusterAddPoint(graphic: esri.Graphic, p: any, cluster: Cluster, preserveClusterLocation: boolean): void;
    /**
     * Called when there is no cluster within range of the point. Creates a new cluster in that location.
     * @param graphic The graphic to use as a reference for the beginning of the cluster.
     * @param graphic p The point specifying where the cluster is to be created.
     */
    protected _createCluster(graphic: esri.Graphic, point: esri.geometry.Point): void;
    /**
     * Enables normal clicks on the map again, used after the click to implode an exploded cluster.
     * Timeout is necessary here to prevent handling (sometimes!) the current mouse events as the enabled click.
     */
    protected _enableMapClick(): void;
    /**
     * Disables normal clicks on the map. We'll use the next click to implode a cluster instead.
     * This timeout needs to be the same as the timeout above to stop things being handled in the wrong order.
     */
    protected _disableMapClick(): void;
}

}
declare module "geocortex/infrastructure/ColorUtils" {
import { SymbolColor } from "geocortex/infrastructure/symbology/SymbolColor";
/**
 * Creates a color with the provided number array representation of the color, or null if one can not be created.
 * @param {Number[]} colorList A 3 or 4 element list in the order RGB or RGBA.
 * @returns {dojo.Color} color
 */
export function getColorFromList(colorList: number[]): dojo.Color;
/**
 * Creates a color with the provided hex string of the color, or null if one can not be created.
 * @param {String} color A 6 or 8 digit hex in RGB or ARGB form.
 * @returns {dojo.Color} color
 */
export function getColorFromString(color: string): esri.Color;
/**
 * Creates a CSS color string with the provided number array representation of the color.
 * @param colorList A 3 or 4 element list in the order RGB or RGBA.
 * @return The CSS color string or null.
 */
export function getStringFromList(colorList: number[]): string;
/**
 * Creates a CSS color string with the provided hex string of the color.
 * @param hexColor The 6 or 8 digit hex string in RGB or ARGB form.
 * @return The CSS color string or null.
 */
export function getStringFromHex(hexColor: string): string;
/**
 * Generate a selection of random colors that can be used in symbolization.
 * An attempt has been made to constrain the selection to colors that will 'look good'
 * while providing the most diverse set of colors possible. Use for up to 12 colors is generally ok.
 */
export function generateRandomColors(n?: number): SymbolColor[];
/**
 * Generate a random saturated color
 */
export function generateRandomColor(): SymbolColor;
/**
 * Detect whether or not the native color input type is supported by the current browser.
 * Returns true when color input is supported, false otherwise.
 */
export function isColorInputSupported(): boolean;

}
declare module "geocortex/infrastructure/commands.meta" {
/**
* @namespace Base namespace for the Geocortex Essentials HTML5 Viewer mapping infrastructure commands.
*/
/**
 * @private
 * @docs-hide-from-nav
 */
export module Commands {
    /**
     * A collection of metadata for the known commands
     ****** This should be updated whenever you add a new command.******
     * NOTE: This metadata is used by the management pack to suggest command names and values for command parameters. Hence:
     * 1) Mark commands that do not make sense to be configured via the management pack as private. For instance, if a command takes in a feature,
     * it's unlikely that it can be configured from the management pack - though it's theoretically possible. Mark it as private. On the
     * other hand, it may make sense to include a command that takes in an extent - since it may be practically possible to configure this from the management pack.
     * 2) We DON'T support commands with multiple input parameters anymore - only ones that take in a complex object with multiple parameters. Mark as private.
     * 3) This may mean that the metadata is not 100% accurate with respect to the actual command signature. For example, "Alert" takes in one required string
     * parameter and two optional string parameters. However, since we dont support multiple parameters in commands anymore, we'll just let the user think it takes
     * in one required string parameter (as far as the configuration experience from the management pack is concerned).
     */
    var commandsMetadata: CommandMetadata[];
    interface CommandMetadataDescriptor {
        arguments: string;
        description: string;
        isHyperlinkable: boolean;
        visibility: string;
    }
    interface CommandMetadata {
        name: string;
        metadata: CommandMetadataDescriptor;
    }
    /**
     * Returns the metadata for a given command name, or null if one is not found
     * @private
     * @param commandName The name of the command of interest
     * @returns Object representing command metadata
     */
    function metadataForCommandName(commandName: string): CommandMetadataDescriptor;
    /**
     * Returns the metadata for a given command name, or null if one is not found
     * @private
     */
    function publicCommands(): CommandMetadata[];
}

}
declare module "geocortex/infrastructure/commands" {
import { CommandsBase } from "geocortex/framework/commands";
import { TypedCommand } from "geocortex/framework/commands/TypedCommand";
import { DisplayBufferOptionsArgs } from "geocortex/infrastructure/buffer/DisplayBufferOptionsArgs";
import { ContextMenuArgs } from "geocortex/infrastructure/commandArgs/ContextMenuArgs";
import { ClusterLayerArgs } from "geocortex/infrastructure/commandArgs/ClusterLayerArgs";
import { Feature } from "geocortex/infrastructure/Feature";
import { HeatMapArgs } from "geocortex/infrastructure/commandArgs/HeatMapArgs";
import { MarkerArgs } from "geocortex/infrastructure/commandArgs/MarkerArgs";
import { AddStatusArgs } from "geocortex/infrastructure/commandArgs/AddStatusArgs";
import { DisplayNotificationArgs } from "geocortex/infrastructure/commandArgs/DisplayNotificationArgs";
import { BufferGeometryArgs } from "geocortex/infrastructure/buffer/BufferGeometryArgs";
import { ConfirmOptionsArgs } from "geocortex/infrastructure/commandArgs/ConfirmOptionArgs";
import { MapService } from "geocortex/essentials/MapService";
import { EditFeatureArgs } from "geocortex/infrastructure/commandArgs/EditFeatureArgs";
import { EditInMemoryArgs } from "geocortex/infrastructure/commandArgs/EditInMemoryArgs";
import { SelectionArgs } from "geocortex/infrastructure/commandArgs/SelectionArgs";
import { CreateOrEditFeatureFromBarcodeScanArgs } from "geocortex/infrastructure/commandArgs/CreateOrEditFeatureFromBarcodeScanArgs";
import { EditRelatedRecordArgs } from "geocortex/infrastructure/commandArgs/EditRelatedRecordArgs";
import { CutGraphicsArgs } from "geocortex/infrastructure/commandArgs/CutGraphicsArgs";
import { Project } from "geocortex/infrastructure/project/Project";
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { ActivityContext } from "geocortex/workflow/ActivityContext";
import { LayerDescriptor } from "geocortex/infrastructure/identify/LayerDescriptor";
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
import { ExportGraphicsLayerArgs } from "geocortex/infrastructure/commandArgs/ExportGraphicsLayerArgs";
import { FindAllSelectionMetadataArgs } from "geocortex/infrastructure/commandArgs/FindAllSelectionMetadataArgs";
import { FindMetadataForSelectionArgs } from "geocortex/infrastructure/commandArgs/FindMetadataForSelectionArgs";
import { FindSelectionArgs } from "geocortex/infrastructure/commandArgs/FindSelectionArgs";
import { GeolocateArgs } from "geocortex/infrastructure/commandArgs/GeolocateArgs";
import { FeatureSet } from "geocortex/infrastructure/FeatureSet";
import { IdentifyArgs } from "geocortex/infrastructure/commandArgs/IdentifyArgs";
import { ComponentFrameInfo } from "geocortex/infrastructure/integration/ComponentFrameInfo";
import { CoordinateBase } from "geocortex/infrastructure/coordinates/CoordinateBase";
import { Layer } from "geocortex/essentials/Layer";
import { TimeSliderProfile } from "geocortex/essentials/TimeSliderProfile";
import { ProjectArgs } from "geocortex/infrastructure/commandArgs/ProjectArgs";
import { CombineResultsArgs } from "geocortex/infrastructure/commandArgs/CombineResultsArgs";
import { ChartPointAdapterInterface } from "geocortex/charting/infrastructure/ChartPointAdapterInterface";
import { SearchProviderBase } from "geocortex/infrastructure/search/SearchProviderBase";
import { VisualizationArgs } from "geocortex/infrastructure/commandArgs/VisualizationArgs";
import { RenameSelectionArgs } from "geocortex/infrastructure/commandArgs/RenameSelectionArgs";
import { ShowOfflineMapEditorArgs } from "geocortex/infrastructure/commandArgs/ShowOfflineProfileEditorArgs";
import { ShowMapElementArgs } from "geocortex/infrastructure/commandArgs/ShowMapElementArgs";
import { RunReportArgs } from "geocortex/infrastructure/commandArgs/RunReportArgs";
import { OfflineMap } from "geocortex/infrastructure/offline/OfflineMap";
import { UpdateGraphicsArgs } from "geocortex/infrastructure/commandArgs/UpdateGraphicsArgs";
import { DeleteAttachmentsArgs } from "geocortex/infrastructure/commandArgs/DeleteAttachmentsArgs";
import { FilterControlQueryChangedEventArgs } from "geocortex/infrastructure/eventArgs/FilterControlQueryChangedEventArgs";
import { QueryOptions } from "geocortex/infrastructure/collaboration/QueryOptions";
import { RestRoom } from "geocortex/infrastructure/collaboration/RestRoom";
import { RestEvent } from "geocortex/infrastructure/collaboration/RestEvent";
import { RestEventRequestArgs } from "geocortex/infrastructure/collaboration/RestEventRequestArgs";
import { RestRoomRequestArgs } from "geocortex/infrastructure/collaboration/RestRoomRequestArgs";
import { HighlightFeatureArgs } from "geocortex/infrastructure/commandArgs/HighlightFeatureArgs";
export interface FrameworkCommands extends CommandsBase {
    /**
     * Activates buffering with the current settings for the specified command(s).
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ActivateBuffering
     * @param args A string or array of strings specifying the command(s) for which to deactivate buffering.
     * @introduced 2.5
     * @gcx-command-category Buffering
     */
    (commandName: "ActivateBuffering"): TypedCommand<{
        (args: string | string[]): void;
    }>;
    /**
    * Activates buffering for the specified command and displays the associated Buffer Options dialog.
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name ActivateBufferingAndDisplayOptions
    * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.buffer.DisplayBufferOptionsArgs} object or string specifying the command for which to activate buffering and display Buffer Options.
    * A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.buffer.DisplayBufferOptionsArgs} object has the following properties: `targetCommand` and `delegateFunction` (optional).
    * `targetCommand` is the command for which to activate buffering and display Buffer Options.
    * `delegateFunction` is a delegate function to execute when the user clicks the Continue button on the Buffer Options dialog.
    * @introduced 2.5
    * @gcx-command-category Buffering
    */
    (commandName: "ActivateBufferingAndDisplayOptions"): TypedCommand<{
        (args: DisplayBufferOptionsArgs | string): void;
    }>;
    /**
     * Activates any workflow container views associated with a given workflow.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ActivateContainersForWorkflow
     * @param args An object that has the following properties: `workflowId` and `containerNames` (optional).
     * `workflowId` is the ID of the workflow for which to activate container views.
     * `containerNames` is an array of names of workflow containers to activate. If not specified all containers are activated.
     * @private
     */
    (commandName: "ActivateContainersForWorkflow"): TypedCommand<{
        (args: {
            workflowId: string;
            containerNames: string[];
        }): void;
    }>;
    /**
     * Activates a context menu view that will be positioned based on the page x & y values specified.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ActivateContextMenu
     * @param options The context menu options.
     * @private
     */
    (commandName: "ActivateContextMenu"): TypedCommand<{
        (options: ContextMenuArgs): void;
    }>;
    /**
     * Activate the event copy menu.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ActivateEventCopyView
     * @param event The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.collaboration.RestEvent} to be copied.
     * @introduced 2.8
     * @private
     */
    (commandName: "ActivateEventCopyView"): TypedCommand<{
        (event: RestEvent): void;
    }>;
    /**
     * Edit the associated message for a collaboration event using its rest event.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ActivateEditCollaborationEventMessageView
     * @param event The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.collaboration.RestEvent} with a message to be modified.
     * @introduced 2.9
     * @private
     */
    (commandName: "ActivateEditCollaborationEventMessageView"): TypedCommand<{
        (event: RestEvent): void;
    }>;
    /**
     * Edit the associated message for a collaboration event using one of its drawn features.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ActivateEditCollaborationFeatureMessageView
     * @param feature The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature} with a message to be modified.
     * @introduced 2.9
     * @private
     */
    (commandName: "ActivateEditCollaborationFeatureMessageView"): TypedCommand<{
        (feature: Feature): void;
    }>;
    /**
     * Activates the Home Panel if it is configured to be included.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ActivateHomePanel
     * @introduced 1.3
     * @deprecated 2.0 Use ShowHomePanel instead.
     * @gcx-command-category Region and View
     */
    (commandName: "ActivateHomePanel"): TypedCommand<{
        (): void;
    }>;
    /**
     * Activates the Plot Coordinates View.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ActivatePlotCoordinatesView
     * @introduced 2.6
     * @gcx-command-category Plot Coordinates
     */
    (commandName: "ActivatePlotCoordinatesView"): TypedCommand<{
        (): void;
    }>;
    /**
     * Activates the Layer Selector for Identify and applies current settings.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ActivateSelectLayersForIdentify
     * @introduced 2.5
     * @gcx-command-category Layer Selector
     */
    (commandName: "ActivateSelectLayersForIdentify"): TypedCommand<{
        (): void;
    }>;
    /**
    * Applies the current query to the specified Filter Control.
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name ApplyFilterControlQuery
    * @param args An object specifyying the filter control id and the query to be applied to the specified filter control.
    * @introduced 2.8
    * @gcx-command-category Layer Selector
    */
    (commandName: "ApplyFilterControlQuery"): TypedCommand<{
        (args: FilterControlQueryChangedEventArgs): void;
    }>;
    /**
     * Deactivates the Layer Selector for Identify and enables all default identifiable layers.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DeactivateSelectLayersForIdentify
     * @introduced 2.5
     * @gcx-command-category Layer Selector
     */
    (commandName: "DeactivateSelectLayersForIdentify"): TypedCommand<{
        (): void;
    }>;
    /**
     * Activates the Layer Selector for Snapping.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ActivateSelectLayersForSnapping
     * @introduced 2.5
     * @gcx-command-category Layer Selector
     */
    (commandName: "ActivateSelectLayersForSnapping"): TypedCommand<{
        (): void;
    }>;
    /**
     * Deactivates the Layer Selector for Snapping.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DeactivateSelectLayersForSnapping
     * @introduced 2.5
     * @gcx-command-category Layer Selector
     */
    (commandName: "DeactivateSelectLayersForSnapping"): TypedCommand<{
        (): void;
    }>;
    /**
     * Activates Snapping.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ActivateSnapping
     * @introduced 2.5
     * @gcx-command-category Snapping
     */
    (commandName: "ActivateSnapping"): TypedCommand<{
        (): void;
    }>;
    /**
     * Deactivates Snapping.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DeactivateSnapping
     * @introduced 2.5
     * @gcx-command-category Snapping
     */
    (commandName: "DeactivateSnapping"): TypedCommand<{
        (): void;
    }>;
    /**
     * Activates any transient elements configured against a specific ID in the toolbar module.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ActivateTransientElements
     * @param id The ID of the entity (for example, tool) for which to activate any associated transient elements.
     * @introduced 1.3
     * @gcx-command-category Region and View
     */
    (commandName: "ActivateTransientElements"): TypedCommand<{
        (id: string): void;
    }>;
    /**
     * Bookmarks the current extent with the given name.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name AddBookmark
     * @param name The name by which to bookmark the current extent.
     * @introduced 2.0
     * @gcx-command-category Bookmark
     */
    (commandName: "AddBookmark"): TypedCommand<{
        (name: string): void;
    }>;
    /**
     * Adds a cluster layer to an existing Geocortex Layer that holds an Esri FeatureLayer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name AddClusterLayer
     * @param args Either a ClusterLayerArgs or String representing the Map Service's ID.
     * @introduced 2.5
     * @gcx-command-category Visualization
     */
    (commandName: "AddClusterLayer"): TypedCommand<{
        (args: ClusterLayerArgs | string): void;
    }>;
    /**
     * Add a collaboration event's graphics to the collaboration graphics layer as a Feature.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name AddCollaborationFeatures
     * @param event The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.collaboration.RestEvent} to be added to the collaboration markup layer.
     * @introduced 2.8
     * @private
     */
    (commandName: "AddCollaborationFeatures"): TypedCommand<{
        (event: RestEvent): void;
    }>;
    /**
     * Adds an individual feature to the current {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} displayed in the results view.
     * Typically, an end-user would click "Add to Results" on a map tip to add the feature to the results.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name AddFeatureToResults
     * @param feature The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature} to add to the results view.
     * @introduced 2.6
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "AddFeatureToResults"): TypedCommand<{
        (feature: Feature): void;
    }>;
    /**
     * Adds a heat map visualization to a given Geocortex layer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name AddHeatMap
     * @param args Either {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.HeatMapArgs} or a string representing the Map Service's ID.
     * @introduced 2.5
     * @gcx-command-category Visualization
     */
    (commandName: "AddHeatMap"): TypedCommand<{
        (args: HeatMapArgs | string): void;
    }>;
    /**
     * Creates and displays a marker on the map.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name AddMarker
     * @param arg The marker to add to the map, specified as the marker ID or as an instance of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.MarkerArgs}.
     * @introduced 2.5
     * @private
     */
    (commandName: "AddMarker"): TypedCommand<{
        (arg: string | MarkerArgs): void;
    }>;
    /**
     * Adds the given geometry to the markup layer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name AddMarkup
     * @param geometry The geometry to add to the markup layer.
     * @introduced 1.3
     * @gcx-command-category Markup
     */
    (commandName: "AddMarkup"): TypedCommand<{
        (geometry: esri.geometry.Geometry): void;
    }>;
    /**
     * Adds the given feature to the markup layer. (Identical to the AddMarkup command.)
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name AddMarkupFeature
     * @param feature The feature to add to the markup layer.
     * @introduced 2.8
     * @gcx-command-category Markup
     */
    (commandName: "AddMarkupFeature"): TypedCommand<{
        (feature: Feature): void;
    }>;
    /**
     * Adds the given geometry to the markup layer.  (Identical to the AddMarkup command.)
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name AddMarkupGeometry
     * @param geometry The geometry to add to the markup layer.
     * @introduced 2.0
     * @gcx-command-category Markup
     */
    (commandName: "AddMarkupGeometry"): TypedCommand<{
        (geometry: esri.geometry.Geometry): void;
    }>;
    /**
     * Creates and displays a pushpin for the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature} specified.
     * Pushpins must be enabled for this command to work.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name AddPushpin
     * @param feature The feature to generate a pushpin for.
     * @introduced 2.4
     * @gcx-command-category Pushpins
     */
    (commandName: "AddPushpin"): TypedCommand<{
        (feature: Feature): void;
    }>;
    /**
     * Creates and displays pushpins for the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} specified.
     * Pushpins must be enabled for this command to work.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name AddPushpins
     * @param fscId The ID of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} to generate pushpins for.
     * @introduced 2.3
     * @gcx-command-category Pushpins
     */
    (commandName: "AddPushpins"): TypedCommand<{
        (fscId: string): void;
    }>;
    /**
     * Displays a status indicator that can relay short messages in the results list or table.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name AddResultsStatus
     * @param messageOrArgs Either a string containing the message, or an {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.AddStatusArgs} object.
     * @introduced 2.6
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "AddResultsStatus"): TypedCommand<{
        (messageOrArgs: string | AddStatusArgs): void;
    }>;
    /**
     * Add a collaboration room to the auto join list.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name AutoJoinCollaborationRoom
     * @param id The id of the collaboration room to join.
     * @introduced 2.8
     * @gcx-command-category Collaboration
     */
    (commandName: "AutoJoinCollaborationRoom"): TypedCommand<{
        (id: string): void;
    }>;
    /**
     * Displays a status message for the query builder
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name AddQueryStatus
     * @param messageOrArgs The message to display or status arguments
     * @introduced 2.8
     * @gcx-command-category Query
     */
    (commandName: "AddQueryStatus"): TypedCommand<{
        (messageOrArgs: string | AddStatusArgs, opts: {
            error: boolean;
        }): void;
    }>;
    /**
     * Displays a status message for the filter builder
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name AddFilterStatus
     * @param messageOrArgs The message to display or status arguments
     * @introduced 2.8
     * @gcx-command-category Query
     */
    (commandName: "AddFilterStatus"): TypedCommand<{
        (messageOrArgs: string | AddStatusArgs, opts: {
            error: boolean;
        }): void;
    }>;
    /**
     * Removes a status message for the query builder
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RemoveQueryStatus
     * @introduced 2.8
     * @gcx-command-category Query
     */
    (commandName: "RemoveQueryStatus"): TypedCommand<{
        (): void;
    }>;
    /**
     * Removes a status message for the filter builder
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RemoveFilterStatus
     * @introduced 2.8
     * @gcx-command-category Query
     */
    (commandName: "RemoveFilterStatus"): TypedCommand<{
        (): void;
    }>;
    /**
     * Displays a status indicator that can relay tool tips and other types of short messages.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name AddStatus
     * @param statusArgs An instance of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.AddStatusArgs}, or a string.
     * @introduced 1.1
     * @gcx-workflow-requirements Note: In order to use this command in a workflow, you must pass the statusArgs parameter as a string.
     * @gcx-command-category Map Widget
     */
    (commandName: "AddStatus"): TypedCommand<{
        (statusArgs: AddStatusArgs): void;
        (statusArgs: string): void;
    }>;
    /**
     * Prompts the user for text to add as markup. When completed, text markup is added at the provided geometry.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name AddTextMarkup
     * @param geometry The geometry at which to place the text.
     * @introduced 2.0
     * @gcx-command-category Markup
     */
    (commandName: "AddTextMarkup"): TypedCommand<{
        (geometry: esri.geometry.Geometry): void;
    }>;
    /**
     * Adds a temporary markup graphic to the map. The command `ClearTemporaryMarkup` will clear this piece of markup.
     * Subsequent invocations of `AddTemporaryMarkupGeometry` will clear the previous piece of temporary markup.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name AddTemporaryMarkupGeometry
     * @param geometry A Geometry object representing the markup to draw.
     * @introduced 1.0
     * @gcx-command-category Markup
     */
    (commandName: "AddTemporaryMarkupGeometry"): TypedCommand<{
        (geometry: esri.geometry.Geometry): void;
    }>;
    /**
     * Activates a visual ripple on the point of the map specified. Used to implement the map Ripple click.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RippleClick
     * @param evt The MouseEvent that triggered the ripple click
     * @introduced 2.8
     * @private
     * @gcx-workflow-disabled
     * @gcx-command-category Map Widget
     */
    (commandName: "RippleClick"): TypedCommand<{
        (evt: MouseEvent): void;
    }>;
    /**
    * Toggles the ripple effect ( See RippleClick Command ) from a click on the map
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name ToggleRippleClick
    * @introduced 2.8
    * @private
    * @gcx-command-category Map Widget
    */
    (commandName: "ToggleRippleClick"): TypedCommand<{
        (): void;
    }>;
    /**
    * Disables the ripple effect ( See RippleClick Command ) from a click on the map
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name DisableRippleClick
    * @introduced 2.8
    * @private
    * @gcx-command-category Map Widget
    */
    (commandName: "DisableRippleClick"): TypedCommand<{
        (): void;
    }>;
    /**
    * Disables the ripple effect ( See RippleClick Command ) from a click on the map
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name EnableRippleClick
    * @introduced 2.8
    * @private
    * @gcx-command-category Map Widget
    */
    (commandName: "EnableRippleClick"): TypedCommand<{
        (): void;
    }>;
    /**
     * Displays an alert.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name Alert
     * @param message The body of the alert.
     * @param title The title of the alert.
     * @param callback A callback to execute when the alert is dismissed.
     * @introduced 1.0
     * @gcx-workflow-requirements In order to use this command in a workflow, you must omit the `callback` parameter.
     * @gcx-command-category Dialog
     */
    (commandName: "Alert"): TypedCommand<{
        (message: string, title?: string, callback?: () => void): void;
    }>;
    /**
     * Invokes a dialog that allows users to attach files to a given feature, when the browser environment supports it.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name AttachFileToFeature
     * @param feature The Geocortex feature to attach files to.
     * @introduced 1.3
     * @gcx-workflow-disabled
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "AttachFileToFeature"): TypedCommand<{
        (feature: Feature): void;
    }>;
    /**
     * Broadcasts the viewers current viewpoint to the specified external component.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name BroadcastCurrentViewpoint
     * @param ecId The ID of the external component to broadcast the viewpoint to.
     * @introduced 2.4
     * @gcx-command-category Integration
     */
    (commandName: "BroadcastCurrentViewpoint"): TypedCommand<{
        (ecId: string): void;
    }>;
    /**
     * Buffers input geometry, adds buffer markup to the map, and fires the callback and event with the buffered geometry. When the source command is specified, buffers using current settings for the command.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name BufferGeometry
     * @param bufferGeometryArgs The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.buffer.BufferGeometryArgs} object defining the geometry to buffer and the associated buffer parameters.
     * @introduced 2.5
     * @gcx-command-category Buffering
     */
    (commandName: "BufferGeometry"): TypedCommand<{
        (bufferGeometryArgs: BufferGeometryArgs): void;
    }>;
    /**
    * Cancels editing of a coordinate if currently active.
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name CancelEditCoordinate
    * @introduced 2.6
    * @gcx-command-category Plot Coordinates
    */
    (commandName: "CancelEditCoordinate"): TypedCommand<{
        (): void;
    }>;
    /**
     * Cancel any in-progress search on all providers.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name CancelSearch
     * @introduced 1.1
     * @gcx-command-category Search
     */
    (commandName: "CancelSearch"): TypedCommand<{
        (): void;
    }>;
    /**
     * Changes the style of markup to match the provided symbol.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ChangeMarkupStyle
     * @introduced 2.8
     * @param symbolJson the esri symbol in JSON string form
     */
    (commandName: "ChangeMarkupStyle"): TypedCommand<{
        (symbolJSON: string): void;
    }>;
    /**
     * Clears the active tool.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ClearActiveTool
     * @introduced 1.1
     * @gcx-command-category Map Widget
     */
    (commandName: "ClearActiveTool"): TypedCommand<{
        (): void;
    }>;
    /**
     * Removes the highlights from the charting highlight layer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ClearChartHighlights
     * @introduced 2.3
     * @private
     */
    (commandName: "ClearChartHighlights"): TypedCommand<{
        (): void;
    }>;
    /**
     * Removes all charts from the charting view.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ClearCharts
     * @introduced 2.3
     * @gcx-command-category Charting
     */
    (commandName: "ClearCharts"): TypedCommand<{
        (): void;
    }>;
    /**
     * Clears all the features from the collaboration markup layer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ClearCollaborationDrawings
     * @introduced 2.8
     * @gcx-command-category Collaboration
     */
    (commandName: "ClearCollaborationDrawings"): TypedCommand<{
        (): void;
    }>;
    /**
     * Clears all the features from the collaboration graphics layer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ClearCollaborationFeatures
     * @introduced 2.8
     * @private
     */
    (commandName: "ClearCollaborationFeatures"): TypedCommand<{
        (): void;
    }>;
    /**
     * Clears the highlights from the default highlight layer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ClearDefaultHighlights
     * @introduced 1.2
     * @deprecated 1.3 Use ClearHighlights with no args instead.
     * @gcx-command-category Highlighting
     */
    (commandName: "ClearDefaultHighlights"): TypedCommand<{
        (): void;
    }>;
    /**
     * Clear the information stored within `RelatedFeaturesView` and `RelatedFeaturesViewModel` (for example, which features are currently open).
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ClearFeatureInformation
     * @introduced 2.3
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "ClearFeatureInformation"): TypedCommand<{
        (): void;
    }>;
    /**
     * Clears the highlights from the default or supplied highlight layer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ClearHighlights
     * @introduced 1.2
     * @gcx-command-category Highlighting
     */
    (commandName: "ClearHighlights"): TypedCommand<{
        (layer?: string | esri.layers.GraphicsLayer): void;
    }>;
    /**
     * Prompts the user for confirmation, and if approved, clears all of the markup from the markup layer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ClearMarkup
     * @introduced 1.2
     * @gcx-command-category Markup
     */
    (commandName: "ClearMarkup"): TypedCommand<{
        (): void;
    }>;
    /**
     * Clears all of the markup from the markup layer without prompting for confirmation.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ClearMarkupQuiet
     * @introduced 1.2
     * @gcx-command-category Markup
     */
    (commandName: "ClearMarkupQuiet"): TypedCommand<{
        (): void;
    }>;
    /**
     * Clears any search results.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ClearSearch
     * @introduced 1.3
     * @gcx-command-category Search
     */
    (commandName: "ClearSearch"): TypedCommand<{
        (): void;
    }>;
    /**
     * Clears the open identify results/selection.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ClearSelection
     * @introduced 2.4
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "ClearSelection"): TypedCommand<{
        (): void;
    }>;
    /**
     * Clears locally stored offline data for the current application.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ClearStorageForApplication
     * @param promptUser Whether to display a prompt to the user before clearning.
     * @introduced 1.2
     * @gcx-command-category Offline
     */
    (commandName: "ClearStorageForApplication"): TypedCommand<{
        (promptUser?: boolean): void;
    }>;
    /**
     * Clears all offline data for the current domain. This includes data for all applications loaded from the current domain.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ClearStorageForDomain
     * @param promptUser Whether to display a prompt to the user before clearning.
     * @introduced 1.1
     * @gcx-command-category Offline
     */
    (commandName: "ClearStorageForDomain"): TypedCommand<{
        (promptUser?: boolean): void;
    }>;
    /**
     * Removes temporary markup created by the command `AddTemporaryMarkupGeometry`.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ClearTemporaryMarkup
     * @introduced 1.0
     * @gcx-command-category Markup
     */
    (commandName: "ClearTemporaryMarkup"): TypedCommand<{
        (): void;
    }>;
    /**
     * Clears list of trusted URLs which are added by clicking "yes" on potentially untrusted content popup.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ClearTrustedUrls
     * @introduced 2.7
     * @gcx-command-category Content Policy
     */
    (commandName: "ClearTrustedUrls"): TypedCommand<{
        (): void;
    }>;
    /**
     * Closes the BottomPanelRegion, if it is present in the current shell.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name CloseBottomRegion
     * @introduced 1.3
     * @gcx-command-category Region and View
     */
    (commandName: "CloseBottomRegion"): TypedCommand<{
        (): void;
    }>;
    /**
     * Closes the data frame, if it is present in the current shell.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name CloseDataFrame
     * @introduced 1.0
     * @gcx-command-category Region and View
     */
    (commandName: "CloseDataFrame"): TypedCommand<{
        (): void;
    }>;
    /**
     * Closes the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection}.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name CloseFeatureSetCollection
     * @param fscId The ID of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} to close.
     * @introduced 1.1
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "CloseFeatureSetCollection"): TypedCommand<{
        (fscId: string): void;
    }>;
    /**
     * Closes the Results Frame, in shells where it is present and active.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name CloseResultsFrame
     * @introduced 1.1
     * @gcx-command-category Region and View
     */
    (commandName: "CloseResultsFrame"): TypedCommand<{
        (): void;
    }>;
    /**
     * Closes the Overview Map when it is present.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name CloseOverviewMap
     * @introduced 2.4
     * @gcx-command-category Map Display
     */
    (commandName: "CloseOverviewMap"): TypedCommand<{
        (): void;
    }>;
    /**
     * Add a graphic to the collaboration markup layer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name CollaborationDraw
     * @param args The ESRI geometry to be added.
     * @introduced 2.8
     * @private
     */
    (commandName: "CollaborationDraw"): TypedCommand<{
        (args: esri.geometry.Geometry): void;
    }>;
    /**
     * Add a text graphic to the collaboration markup layer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name CollaborationDrawText
     * @param args The ESRI geometry to be added.
     * @introduced 2.8.1
     * @private
     */
    (commandName: "CollaborationDrawText"): TypedCommand<{
        (args: esri.geometry.Geometry): void;
    }>;
    /**
     * Displays a confirm.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name Confirm
     * @param message The body of the confirmation.
     * @param title The title of the confirmation.
     * @param callback A callback to execute with the result of the confirmation (`true` or `false`).
     * @introduced 1.0
     * @gcx-workflow-requirements In order to use this command in a workflow, you must omit the `callback` parameter.
     * @gcx-command-category Dialog
     */
    (commandName: "Confirm"): TypedCommand<{
        (message: string, title: string, callback: (confirmResult: boolean) => void, options?: ConfirmOptionsArgs): void;
    }>;
    /**
     * Displays a representation of the specified parameter object in the browser's debugging console.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ConsoleDir
     * @param value The object to display.
     * @introduced 2.7
     * @gcx-command-category Log
     */
    (commandName: "ConsoleDir"): TypedCommand<{
        (value: any): void;
    }>;
    /**
     * Copies a Collaboration Event to a new room.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name CopyCollaborationEvent
     * @param event The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.collaboration.RestEvent} to be copied.
     * @param toRoomId The destination room id.
     * @introduced 2.8
     * @private
     */
    (commandName: "CopyCollaborationEvent"): TypedCommand<{
        (event: RestEvent, toRoomId: string): void;
    }>;
    /**
     * Creates a feature attachment.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name CreateAttachment
     * @param args An object with the following members: mapService, layer, feature, featureUrl, filename, contentType, payload, successCallback, errorCallback.
     * @introduced 1.1
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "CreateAttachment"): TypedCommand<{
        (arg: {
            mapService: MapService;
            layer: esri.layers.FeatureLayer;
            feature: esri.Graphic;
            featureUrl: string;
            filename: string;
            contentType: string;
            payload;
            string;
            successCallback: () => void;
            errorCallback: (error: Error) => void;
        }): void;
    }>;
    /**
     * Creates a Collaboration Event.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name CreateCollaborationEvent
     * @param event The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.collaboration.RestEventRequestArgs} for the event being created.
     * @introduced 2.8
     * @private
     */
    (commandName: "CreateCollaborationEvent"): TypedCommand<{
        (event: RestEventRequestArgs): void;
    }>;
    /**
     * Creates a Collaboration Room.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name CreateCollaborationRoom
     * @param room The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.collaboration.RestRoomRequestArgs} with the information for the room being created.
     * @param callbackfn A callback to be executed on completion.
     * @introduced 2.8
     * @private
     */
    (commandName: "CreateCollaborationRoom"): TypedCommand<{
        (room: RestRoomRequestArgs, callbackfn?: (value: RestRoom) => {}): void;
    }>;
    /**
     * Creates a new feature.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name CreateFeature
     * @param arg An object with members: mapService, feature, successCallback, errorCallback.
     * @introduced 1.1
     * @gcx-command-category Editing
     */
    (commandName: "CreateFeature"): TypedCommand<{
        (arg: EditFeatureArgs): void;
    }>;
    /**
     * Creates new graphics. These edits are only applied to the graphics layer in memory.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name CreateGraphicsInMemory
     * @param args An instance of {@link EditInMemoryArgs} describing the graphics to create, with the following properties: `graphics`, `graphicsLayer`, `successCallback` (optional), `errorCallback` (optional).
     * `graphics` is an array of graphics to create.
     * `graphicsLayer` is the graphics layer to use to create the graphics.
     * `successCallback` is a callback function to call upon successfully creating the graphics.
     * `errorCallback` is a callback function to call when an error occurs while creating the graphics.
     * @introduced 2.5
     * @private
     */
    (commandName: "CreateGraphicsInMemory"): TypedCommand<{
        (args: EditInMemoryArgs): void;
    }>;
    /**
     * Creates a new highlight layer with the specified name, if one does not already exist.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name CreateHighlightLayer
     * @param layerName The name of the new layer to create.
     * @param fillColor the color to fill the highlight symbol with
     * @param borderColor the color of the highlight symbol outline
     * @param sharedGraphicsLayer use a graphics layer shared between highlight layers, or a graphics layer for this highlight layer only
     * @introduced 1.2
     * @deprecated 2.8 Recommended to use graphics layers for arbitrary graphics, and not to abuse highlighting.
     * @gcx-command-category Highlighting
     */
    (commandName: "CreateHighlightLayer"): TypedCommand<{
        (layerName: string, fillColor?: any, borderColor?: any, sharedGraphicsLayer?: boolean): void;
    }>;
    /**
     * Activates the markup style picker view. The view will be configured for the current markup type and symbol.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name CreateMarkupStyleView
     * @introduced 2.0
     * @gcx-command-category Markup
     */
    (commandName: "CreateMarkupStyleView"): TypedCommand<{
        (): void;
    }>;
    /**
     * Creates a new named, saved selection based on the supplied {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection}.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name CreateSelection
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.SelectionArgs} object with the following members: `name`, `featureSetCollection` (optional), `successCallback` (optional), `errorCallback` (optional).
     * @introduced 2.6
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "CreateSelection"): TypedCommand<{
        (args: SelectionArgs): void;
    }>;
    /**
     * Launch the barcode scanner, and use the result to create a new feature or edit an existing feature.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name CreateOrEditFeatureFromBarcodeScan
     * @param args An object that implements the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.CreateOrEditFeatureFromBarcodeScanArgs} interface with the following properties:
     * `featureServiceId` is ID of the feature service for which to create or edit a feature.
     * `scanResultFieldName` is the field name for which to set when creating a new feature, or search to edit an existing feature.
     * @introduced 2.5
     * @gcx-command-category Scanning
     */
    (commandName: "CreateOrEditFeatureFromBarcodeScan"): TypedCommand<{
        (args: CreateOrEditFeatureFromBarcodeScanArgs): void;
    }>;
    /**
     * Creates a related table record.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name CreateRelatedRecord
     * @param arg An object with the following members: mapService, layer, feature, relatedFeature, relationshipOrigin, relationshipDestination, successCallback, errorCallback.
     * @introduced 1.1
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "CreateRelatedRecord"): TypedCommand<{
        (arg: EditRelatedRecordArgs): void;
    }>;
    /**
     * Cut graphics using a polyline, updating the geometry of the original graphic and creating new graphics for each new geometry. Created graphics will copy
     * attribute values from the original graphic, but can be updated in the successCallback. These edits are only applied to the graphics layer in memory.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name CutGraphicsInMemory
     * @param args An instance of {@link CutGraphicsArgs} describing the graphics to cut.
     * @introduced 2.5
     * @private
     */
    (commandName: "CutGraphicsInMemory"): TypedCommand<{
        (args: CutGraphicsArgs): void;
    }>;
    /**
     * Deactivates buffering, if active, for the specified command(s).
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DeactivateBuffering
     * @param args A string or array of strings specifying the command(s) for which to deactivate buffering.
     * @introduced 2.5
     * @gcx-command-category Buffering
     */
    (commandName: "DeactivateBuffering"): TypedCommand<{
        (args: string | string[]): void;
    }>;
    /**
    * Deactivates buffering for the specified command and dismisses the associated Buffer Options dialog if it's active.
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name DectivateBufferingAndDisplayOptions
    * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.buffer.DisplayBufferOptionsArgs} object or string specifying the command for which to deactivate Buffer Options and dismiss the dialog.
    * @introduced 2.5
    * @gcx-command-category Buffering
    */
    (commandName: "DeactivateBufferingAndDismissOptions"): TypedCommand<{
        (args: DisplayBufferOptionsArgs | string): void;
    }>;
    /**
     * Deactivates any workflow container views associated with a given workflow.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DeactivateContainersForWorkflow
     * @param workflowId The ID of the workflow for which to deactivate container views.
     * @private
     */
    (commandName: "DeactivateContainersForWorkflow"): TypedCommand<{
        (workflowId: string): void;
    }>;
    /**
     * Deactivates the context menu view.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DeactivateContainersForWorkflow
     * @introduced 2.6
     * @private
     */
    (commandName: "DeactivateContextMenu"): TypedCommand<{
        (): void;
    }>;
    /**
     * Deletes feature attachments.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DeleteAttachments
     * @param arg The {@link DeleteAttachmentsArgs} object describing the attachments to delete.
     * @private
     */
    (commandName: "DeleteAttachments"): TypedCommand<{
        (arg: DeleteAttachmentsArgs): void;
    }>;
    /**
     * Deletes all plotted Coordinates from the map.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DeleteAllCoordinates
     * @introduced 2.6
     * @gcx-command-category Plot Coordinates
     */
    (commandName: "DeleteAllCoordinates"): TypedCommand<{
        (): void;
    }>;
    /**
     * Deletes one or many plotted Coordinates from the map.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DeleteCoordinates
     * @param descIds The string id, or array of string id's of the coordinate(s) to delete from the map.
     * @introduced 2.6
     * @gcx-command-category Plot Coordinates
     */
    (commandName: "DeleteCoordinates"): TypedCommand<{
        (descIds: string | string[]): void;
    }>;
    /**
     * Edits a plotted Coordinate on the map or creates a new coordinate in edit mode.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name EditCoordinate
     * @param descId The string id of the coordinate to edit. If unspecified, a new coordinate will be created in edit mode.
     * @introduced 2.6
     * @gcx-command-category Plot Coordinates
     */
    (commandName: "EditCoordinate"): TypedCommand<{
        (descId?: string): void;
    }>;
    /**
     * Deletes a feature.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DeleteFeature
     * @param arg An object with the following members: mapService, feature, successCallback, errorCallback.
     * @introduced 1.1
     * @gcx-command-category Editing
     */
    (commandName: "DeleteFeature"): TypedCommand<{
        (arg: {
            mapService: MapService;
            feature: esri.Graphic;
            successCallback?: () => void;
            errorCallback?: (error: Error) => void;
        }): void;
    }>;
    /**
     * Deletes graphics. These edits are only applied to the graphics layer in memory.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DeleteGraphicsInMemory
     * @param args An instance of {@link EditInMemoryArgs} describing the graphics to delete.
     * @introduced 2.5
     * @private
     */
    (commandName: "DeleteGraphicsInMemory"): TypedCommand<{
        (args: EditInMemoryArgs): void;
    }>;
    /**
     * Removes the given entry from the edit log, then saves the edit log.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DeleteFromEditLog
     * @param editLogEntry The edit log entry to remove.
     * @introduced 1.1
     * @gcx-command-category Editing
     */
    (commandName: "DeleteFromEditLog"): TypedCommand<{
        (editLogEntry: any): void;
    }>;
    /**
     * Deletes markup that intersects the extent of the provided geometry, prompting the user if multiple pieces of markup are selected for deletion.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DeleteMarkup
     * @param geometry The geometry to use for selecting markup to delete.
     * @introduced 2.0
     * @gcx-command-category Markup
     */
    (commandName: "DeleteMarkup"): TypedCommand<{
        (geometry: esri.geometry.Geometry): void;
    }>;
    /**
     * Deletes measurement markup that intersects the extent of the provided geometry, prompting the user if multiple pieces of measurement markup are selected for deletion.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DeleteMeasurement
     * @param geometry The geometry to use for selecting measurement markup to delete.
     * @introduced 2.1
     * @gcx-command-category Measurement
     */
    (commandName: "DeleteMeasurement"): TypedCommand<{
        (geometry: esri.geometry.Geometry): void;
    }>;
    /**
     * Deletes a project.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DeleteProject
     * @param project The unique ID of the project to delete, or an instance of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.project.Project} containing the project to delete.
     * @introduced 2.6
     * @gcx-command-category Projects
     */
    (commandName: "DeleteProject"): TypedCommand<{
        (project: string | Project): void;
    }>;
    /**
     * Deletes a named selection.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DeleteSelection
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.SelectionArgs} object with the following members: `name`, `featureSetCollection` (optional), `successCallback` (optional), `errorCallback` (optional).
     * @introduced 2.6
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "DeleteSelection"): TypedCommand<{
        (args: SelectionArgs): void;
    }>;
    /**
     * Deletes a related table record.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DeleteRelatedRecord
     * @param arg An object with the following members: mapService, layer, feature, relatedFeature, relationshipOrigin, relationshipDestination, successCallback, errorCallback.
     * @introduced 1.1
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "DeleteRelatedRecord"): TypedCommand<{
        (arg: EditRelatedRecordArgs): void;
    }>;
    /**
    * Prevents the commands configured to execute on map click from executing and also prevents the `MapClickedEvent` from firing.
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name DisableMapClick
    * @introduced 2.4
    * @gcx-command-category Map Widget
    */
    (commandName: "DisableMapClick"): TypedCommand<{
        (): void;
    }>;
    /**
    * Disables map keyboard navigation if currently enabled.
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name EnableMapKeyboardNavigation
    * @introduced 2.8
    * @gcx-command-category Map Widget
    */
    (commandName: "DisableMapKeyboardNavigation"): TypedCommand<{
        (): void;
    }>;
    /**
     * Disables the display of map tips on the map.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DisableMapTips
     * @introduced 2.3.1
     * @gcx-command-category Map Widget
     */
    (commandName: "DisableMapTips"): TypedCommand<{
        (): void;
    }>;
    /**
     * Disables the display of pushpins on the map.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DisablePushpins
     * @introduced 2.1
     * @gcx-command-category Pushpins
     */
    (commandName: "DisablePushpins"): TypedCommand<{
        (): void;
    }>;
    /**
     * Displays the Buffer Options dialog for the specified target command, and executes a optional delegate function when the user clicks the Continue button.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DisplayBufferOptions
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.buffer.DisplayBufferOptionsArgs} object or string defining the target command for which to show Buffer Options.
     * A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.buffer.DisplayBufferOptionsArgs} object has the following properties: `targetCommand` and `delegateFunction` (optional).
     * `targetCommand` is the command for which to activate buffering and display Buffer Options.
     * `delegateFunction` is a delegate function to execute when the user clicks the Continue button on the Buffer Options dialog.
     * @introduced 2.5
     * @gcx-command-category Buffering
     */
    (commandName: "DisplayBufferOptions"): TypedCommand<{
        (args: DisplayBufferOptionsArgs | string): void;
    }>;
    /**
     * Opens the specified chart in the charting view.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DisplayChartById
     * @param chartId The chart ID.
     * @introduced 2.3
     * @gcx-command-category Charting
     */
    (commandName: "DisplayChartById"): TypedCommand<{
        (chartId: string): void;
    }>;
    /**
     * Opens the specified external component in the external components view. If this component is open in a separate window, it will be closed.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DisplayDockedExternalComponentById
     * @param ecId The ID of the external component to dock in the viewer.
     * @introduced 2.4
     * @gcx-command-category Integration
     */
    (commandName: "DisplayDockedExternalComponentById"): TypedCommand<{
        (ecId: string): void;
    }>;
    /**
     * Displays a notification view and associated text, icon, and buttons
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DisplayNotification
     * @introduced 2.8
     * @gcx-command-category Map Widget
     */
    (commandName: "DisplayNotification"): TypedCommand<{
        (args: DisplayNotificationArgs | string): void;
    }>;
    /**
     * Opens the specified external component in a separate window from the viewer. If this component is open in the viewer, it will be closed.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DisplayUndockedExternalComponentById
     * @param ecId The ID of the external component to open in a new window.
     * @introduced 2.4
     * @gcx-command-category Integration
     */
    (commandName: "DisplayUndockedExternalComponentById"): TypedCommand<{
        (ecId: string): void;
    }>;
    /**
     * Displays a view in a workflow container.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DisplayWorkflowContainerContent
     * @param entry An object with the following properties: containerName, view, activityContext.
     * @introduced 1.0
     * @gcx-workflow-disabled
     * @gcx-command-category Workflow
     */
    (commandName: "DisplayWorkflowContainerContent"): TypedCommand<{
        (entry: {
            containerName: string;
            view: ViewBase;
            activityContext: ActivityContext;
        }): void;
    }>;
    /**
     * Modifies an existing Collaboration Event.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name EditCollaborationEvent
     * @param id The id of the original collaboration event.
     * @param event The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.collaboration.RestEventRequestArgs} with the information for the modified event.
     * @param callbackfn A callback to be executed on completion.
     * @introduced 2.8
     * @private
     */
    (commandName: "EditCollaborationEvent"): TypedCommand<{
        (id: string, event: RestEventRequestArgs, callbackfn?: (value: RestEvent) => {}): void;
    }>;
    /**
     * Edits the message of a given collaboration message.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name EditCollaborationMarkupMessage
     * @param id The id of the collaboration event whose message will be edited.
     * @param message The new message.
     * @introduced 2.8
     * @private
     */
    (commandName: "EditCollaborationMarkupMessage"): TypedCommand<{
        (id: string, message: string): void;
    }>;
    /**
     * Open the edit message view for a Collaboration event.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowEditCollaborationMessageView
     * @param event The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.collaboration.RestEvent} to be modified.
     * @introduced 2.8
     * @gcx-command-category Collaboration
     */
    (commandName: "ShowEditCollaborationMessageView"): TypedCommand<{
        (event: RestEvent): void;
    }>;
    /**
     * Open the edit message view for a Collaboration feature.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowEditCollaborationGraphicMessageView
     * @param event The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature} with a collaboration event to be modified.
     * @introduced 2.8
     * @gcx-command-category Collaboration
     */
    (commandName: "ShowEditCollaborationGraphicMessageView"): TypedCommand<{
        (feature: Feature): void;
    }>;
    /**
     * Modifies an existing Collaboration Room.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name EditCollaborationRoom
     * @param id The id of the original collaboration room.
     * @param room The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.collaboration.RestRoomRequestArgs} with the information for the modified room.
     * @param callbackfn A callback to be executed on completion.
     * @introduced 2.8
     * @private
     */
    (commandName: "EditCollaborationRoom"): TypedCommand<{
        (id: string, room: RestRoomRequestArgs, callbackfn?: (value: RestRoom) => {}): void;
    }>;
    /**
      * Edits markup that intersects the extent of the provided geometry.
      * @docs-gcx-command geocortex.essentialsHtmlViewer
      * @name EditMarkup
      * @param geometry The geometry to use for selecting markup to edit.
      * @introduced 2.0
      * @gcx-command-category Markup
      */
    (commandName: "EditMarkup"): TypedCommand<{
        (geometry: esri.geometry.Geometry): void;
    }>;
    /**
    * Enables all identifiable layers such that they participate in Identify operations.
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name EnableAllLayersForIdentify
    * @introduced 2.5
    * @gcx-command-category Identify
    */
    (commandName: "EnableAllLayersForIdentify"): TypedCommand<{
        (): void;
    }>;
    /**
     * Erases the given event after a confirmation dialog.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name EraseMarkupEvent
     * @param event The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.collaboration.RestEvent} to be erased.
     * @introduced 2.8
     * @gcx-command-category Collaboration
     */
    (commandName: "EraseMarkupEvent"): TypedCommand<{
        (event: RestEvent): void;
    }>;
    /**
    * Disables all identifiable layers such that they do not participate in Identify operations.
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name DisableAllLayersForIdentify
    * @introduced 2.5
    * @gcx-command-category Identify
    */
    (commandName: "DisableAllLayersForIdentify"): TypedCommand<{
        (): void;
    }>;
    /**
    * Enables the specified layer, if it's identifiable, such that it participates in Identify operations.
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name EnableLayerForIdentify
    * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.identify.LayerDescriptor} object specifying the layer to enable for identify.
    * @introduced 2.5
    * @gcx-command-category Identify
    */
    (commandName: "EnableLayerForIdentify"): TypedCommand<{
        (args: LayerDescriptor): void;
    }>;
    /**
    * Disables the specified layer, if it's in the list of identifiable layers, such that it does not participate in Identify operations.
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name DisableLayerForIdentify
    * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.identify.LayerDescriptor} object specifying the layer to enable for identify.
    * @introduced 2.5
    * @gcx-command-category Identify
    */
    (commandName: "DisableLayerForIdentify"): TypedCommand<{
        (args: LayerDescriptor): void;
    }>;
    /**
    * Enables all configured commands to execute on map click and also wires up the `MapClickEvent` to fire when the map is clicked.
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name EnableMapClick
    * @introduced 2.4
    * @gcx-command-category Map Widget
    */
    (commandName: "EnableMapClick"): TypedCommand<{
        (): void;
    }>;
    /**
    * Enables map keyboard navigation if currently disabled.
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name EnableMapKeyboardNavigation
    * @introduced 2.8
    * @gcx-command-category Map Widget
    */
    (commandName: "EnableMapKeyboardNavigation"): TypedCommand<{
        (): void;
    }>;
    /**
     * Enables the display of map tips on the map.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name EnableMapTips
     * @introduced 2.3.1
     * @gcx-command-category Map Widget
     */
    (commandName: "EnableMapTips"): TypedCommand<{
        (): void;
    }>;
    /**
     * Enables the display of pushpins on the map.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name EnablePushpins
     * @introduced 2.1
     * @gcx-command-category Pushpins
     */
    (commandName: "EnablePushpins"): TypedCommand<{
        (): void;
    }>;
    /**
     * Enables or disables the refinement of a global search from within search hints (if any).
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name EnableSearchRefinement
     * @param enable Whether or not to enable the search refinement.  To hide the refinement button, set to `false`.  The default is `false`.
     * @introduced 2.0
     * @gcx-command-category Search
     */
    (commandName: "EnableSearchRefinement"): TypedCommand<{
        (enable?: boolean): void;
    }>;
    /**
     * Separates multi-part graphics into individual graphics. Created graphics will copy attribute values from the original
     * graphic, but can be updated in the successCallback. These edits are only applied to the graphics layer in memory.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ExplodeGraphicsInMemory
     * @param args An instance of {@link EditInMemoryArgs} describing the graphics to separate.
     * @introduced 2.5
     * @private
     */
    (commandName: "ExplodeGraphicsInMemory"): TypedCommand<{
        (args: EditInMemoryArgs): void;
    }>;
    /**
     * Exports the data from a feature set to an external data format (csv, xlsx, shp).
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ExportResultsTo
     * @param args An object with the following members: `format`, `fsc`.
     * @introduced 2.4
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "ExportResultsTo"): TypedCommand<{
        (args: {
            format: string;
            fsc: FeatureSetCollection;
        }): void;
    }>;
    /**
     * Exports the markup layer to a Shapefile.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ExportMarkupLayer
     * @introduced 2.6
     * @gcx-command-category Markup
     */
    (commandName: "ExportMarkupLayer"): TypedCommand<{
        (): void;
    }>;
    /**
     * Exports graphics layer to the specified format.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ExportGraphicsLayer
     * @introduced 2.6
     * @param args a {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.ExportGraphicsLayerArgs} object.
     * @gcx-command-category Export
     */
    (commandName: "ExportGraphicsLayer"): TypedCommand<{
        (args: ExportGraphicsLayerArgs): void;
    }>;
    /**
     * Focusses map.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name FocusMap
     * @introduced 2.9
     * @param args a {@link esri.Map} object.
     * @gcx-command-category Region and View
     */
    (commandName: "FocusMap"): TypedCommand<{
        (args: esri.Map): void;
    }>;
    /**
     * Focusses search.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name FocusSearch
     * @introduced 2.9
     * @gcx-command-category Region and View
     */
    (commandName: "FocusSearch"): TypedCommand<{
        (): void;
    }>;
    /**
     * Lists all the available metadata for named selections.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name FindAllSelectionMetadata
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.FindAllSelectionMetadataArgs} object with the following optional members: `successCallback` and `errorCallback`.
     * @introduced 2.6
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "FindAllSelectionMetadata"): TypedCommand<{
        (args: FindAllSelectionMetadataArgs): void;
    }>;
    /**
     * Looks up metadata about a particular named selection.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name FindMetadataForSelection
     * @param args An object with the following optional members: `name`, `featureSetCollectionId`, `successCallback` and `errorCallback`.
     * @introduced 2.6
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "FindMetadataForSelection"): TypedCommand<{
        (args: FindMetadataForSelectionArgs): void;
    }>;
    /**
     * Looks up a particular named selection.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name FindSelection
     * @param args An object with the following optional members: `name`, `successCallback` and `errorCallback`.
     * @introduced 2.6
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "FindSelection"): TypedCommand<{
        (args: FindSelectionArgs): void;
    }>;
    /**
     * Focuses on the first selectable input in the passed view.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name FocusOnFirstInputInView
     * @param view The view to focus on.
     * @introduced 2.4
     * @gcx-command-category Region and View
     */
    (commandName: "FocusOnFirstInputInView"): TypedCommand<{
        (view: ViewBase): void;
    }>;
    /**
     * Set the preferred command to open the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} for the given source name.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name FSMCollectionSetCommand
     * @param sourceName The string source name whose command you want to change.
     * @param commandName The command to run for the source name.
     * @introduced 1.2
     * @deprecated 2.4 This is now an internal implementation detail. For control over how different sources of features
     * populate the viewer, consult the `resultMappings` option in the viewer's configuration file(s).
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "FSMCollectionSetCommand"): TypedCommand<{
        (sourceName: string, commandName: string): void;
    }>;
    /**
     * Zooms to the current location of the device when it becomes available.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name Geolocate
     * @param options (Optional) A {@link GeolocateArgs} object with the following optional properties: `profile`, `accuracyThreshold` and `timeLimit`.
     * `profile`: A string representing the name of a single geolocation profile to use from those defined in the Geolocate view model's configuration.
     * `accuracyThreshold`: A number representing the accuracy radius, in meters, at which the geolocation process will be satisfied.
     * `timeLimit`: A number representing the duration, in milliseconds, that the geolocation process will spend awaiting better geolocation data before giving up.
     * `toolFriendly`: A boolean indicating whether or not to tolerate an active tool. If `false`, any active tool will be cleared before the geolocation proceeds.  The default is `false`.
     * @introduced 1.1
     * @gcx-command-category Geolocation
     */
    (commandName: "Geolocate"): TypedCommand<{
        (options?: GeolocateArgs): void;
    }>;
    /**
     * Enables the following of the device's location when it is available, panning the map.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name GeolocateFollow
     * @introduced 2.3
     * @gcx-command-category Geolocation
     */
    (commandName: "GeolocateFollow"): TypedCommand<{
        (): void;
    }>;
    /**
     * Stops the tracking and following of the device's location.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name GeolocateStop
     * @introduced 2.3
     * @gcx-command-category Geolocation
     */
    (commandName: "GeolocateStop"): TypedCommand<{
        (): void;
    }>;
    /**
     * Enables the tracking of the device's location when it is available, without panning the map.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name GeolocateTrack
     * @introduced 2.3
     * @gcx-command-category Geolocation
     */
    (commandName: "GeolocateTrack"): TypedCommand<{
        (): void;
    }>;
    /**
     * Displays a circle around the user's position that indicates the accuracy of the GPS reading.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name GeolocateShowBuffer
     * @introduced 2.3
     * @gcx-command-category Geolocation
     */
    (commandName: "GeolocateShowBuffer"): TypedCommand<{
        (): void;
    }>;
    /**
     * Hides the circle around the user's position that indicates the accuracy of the GPS reading.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name GeolocateHideBuffer
     * @introduced 2.3
     * @gcx-command-category Geolocation
     */
    (commandName: "GeolocateHideBuffer"): TypedCommand<{
        (): void;
    }>;
    /**
     * Retrieves a Collaboration Event.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name GetCollaborationEvent
     * @param id The id of the collaboration event.
     * @param callbackfn A callback to be executed on completion.
     * @introduced 2.8
     * @private
     */
    (commandName: "GetCollaborationEvent"): TypedCommand<{
        (id: string, callbackfn?: (value: RestEvent) => {}): void;
    }>;
    /**
     * Retrieves the list of available Collaboration rooms.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name GetCollaborationRooms
     * @param activeRoomsOnly A boolean indicating whether to restrict results to active rooms, defaults to 'true'.
     * @param callbackfn A callback to be executed on completion.
     * @introduced 2.8
     * @private
     */
    (commandName: "GetCollaborationRooms"): TypedCommand<{
        (activeRoomsOnly: boolean, callbackfn?: (rooms: RestRoom[]) => {}): void;
    }>;
    /**
     * Gets the edit log, passing it into a callback. If an error occurs, the error is passed into the callback.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name GetEditLog
     * @param callback A callback function that the edit log is passed to.
     * @introduced 1.1
     * @gcx-command-category Editing
     */
    (commandName: "GetEditLog"): TypedCommand<{
        (callback: (response: any, responseJson?: any) => void): void;
    }>;
    /**
     * Creates view for all configured feature details providers and embeds them into feature details dialog.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name GetFeatureDetailsProviders
     * @param feature The current feature in context.
     * @private
     */
    (commandName: "GetFeatureDetailsProviders"): TypedCommand<{
        (feature: Feature): void;
    }>;
    /**
     * Gets features related to a MapService based on a specific relationship and object ID.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name GetRelatedFeatures
     * @param arg An object with the following members: `mapService`, `relationshipId`, `objectId`, `successCallback`, `errorCallback`.
     * @introduced 1.1
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "GetRelatedFeatures"): TypedCommand<{
        (arg: {
            mapService: MapService;
            relationshipId: number;
            objectId: number;
            successCallback: (results: esri.Graphic[]) => void;
            errorCallback: (error: Error) => void;
            currentFeature?: esri.Graphic | Feature;
        }): void;
    }>;
    /**
     * Executes a saved query using a given id. Displays the results
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RunSavedQueryById
     * @param id The id of the query to execute
     * @param successCallback
     * @param errorCallback - if the query is not found, the value of err.code = NOTFOUND
     * @introduced 2.8
     * @gcx-command-category Query
     */
    (commandName: "RunSavedQueryById"): TypedCommand<{
        (id: string): void;
    }>;
    /**
     * Executes a saved filter using a given id. Displays the results
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RunSavedFilterById
     * @param id The id of the filter to execute
     * @param successCallback
     * @param errorCallback - if the filter is not found, the value of err.code = NOTFOUND
     * @introduced 2.8
     * @gcx-command-category Query
     */
    (commandName: "RunSavedFilterById"): TypedCommand<{
        (id: string): void;
    }>;
    /**
     * Performs a global search using all active providers.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name GlobalSearch
     * @param searchText The text for which to search.
     * @introduced 1.1
     * @gcx-command-category Search
     */
    (commandName: "GlobalSearch"): TypedCommand<{
        (searchText: string): void;
    }>;
    /**
     * Generates a sharing link, passing it into a callback.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name HandleGenerateSharingLink
     * @param callback A callback to execute with the generated sharing link.
     * @introduced 2.4
     * @gcx-command-category Share
     */
    (commandName: "HandleGenerateSharingLink"): TypedCommand<{
        (callback: (myURL: string) => void): void;
    }>;
    /**
     * Hides the feature attribute editor used to edit feature attributes.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name HideFeatureAttributeEditor
     * @introduced 1.3
     * @deprecated 2.3 This command should never be used as it can lead to a confusing state,
     * since it only hides the editing pane without canceling feature editing.
     * @gcx-command-category Offline
     */
    (commandName: "HideFeatureAttributeEditor"): TypedCommand<{
        (): void;
    }>;
    /**
     * Hides the Feature Details dialog.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name HideFeatureDetails
     * @introduced 2.6
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "HideFeatureDetails"): TypedCommand<{
        (): void;
    }>;
    /**
     * Prevents the display of map tips by setting their visibility to `false`.  Map tips must be enabled for this command to work.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name HideAllMapTips
     * @introduced 2.3.1
     * @gcx-command-category Map Widget
     */
    (commandName: "HideAllMapTips"): TypedCommand<{
        (): void;
    }>;
    /**
     * Hides all plotted Coordinates temporarily.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name HideAllCoordinates
     * @introduced 2.6
     * @gcx-command-category Plot Coordinates
     */
    (commandName: "HideAllCoordinates"): TypedCommand<{
        (): void;
    }>;
    /**
     * Hides one or many plotted Coordinates temporarily.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name HideCoordinates
     * @param descIds The string id, or array of string id's of the coordinate(s) to hide.
     * @introduced 2.6
     * @gcx-command-category Plot Coordinates
     */
    (commandName: "HideCoordinates"): TypedCommand<{
        (descIds: string | string[]): void;
    }>;
    /**
     * Hides any coordinate actions view that is currently active.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name HideCoordinateActions
     * @introduced 2.6
     * @gcx-command-category Plot Coordinates
     */
    (commandName: "HideCoordinateActions"): TypedCommand<{
        (): void;
    }>;
    /**
     * Removes a modal message.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name HideFeatureLayerModalMessage
     * @private
     */
    (commandName: "HideFeatureLayerModalMessage"): TypedCommand<{
        (): void;
    }>;
    /**
     * Hides the feature template picker used to create new features.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name HideFeatureTemplatePicker
     * @introduced 1.3
     * @gcx-command-category Editing
     */
    (commandName: "HideFeatureTemplatePicker"): TypedCommand<{
        (): void;
    }>;
    /**
     * Deactivates/hides the Home Panel if it is configured to be included.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name HideHomePanel
     * @introduced 2.7
     * @gcx-command-category Region and View
     */
    (commandName: "HideHomePanel"): TypedCommand<{
        (): void;
    }>;
    /**
     * Hides the log view.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name HideLog
     * @introduced 2.0
     * @gcx-command-category Log
     */
    (commandName: "HideLog"): TypedCommand<{
        (): void;
    }>;
    /**
     * Removes an element previously anchored to the map using the command `ShowMapElement`.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name HideMapElement
     * @param elementId The ID of the element to remove.
     * @introduced 1.0
     * @gcx-command-category Map Widget
     */
    (commandName: "HideMapElement"): TypedCommand<{
        (elementId: string): void;
    }>;
    /**
     * Closes the map service actions view.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name HideMapServiceActions
     * @introduced 2.7
     * @gcx-workflow-disabled
     * @gcx-command-category Layer List
     */
    (commandName: "HideMapServiceActions"): TypedCommand<{
        (): void;
    }>;
    /**
     * Prevents the display of map tips by setting their visibility to `false`, and suspends displaying map tips.  Map tips must be enabled for this command to work.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name HideMapTips
     * @introduced 2.3.1
     * @gcx-command-category Map Widget
     */
    (commandName: "HideMapTips"): TypedCommand<{
        (): void;
    }>;
    /**
     * Closes the Layer Properties panel.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name HideLayerPropertiesView
     * @introduced 2.7
     * @gcx-command-category Layer Addition
     */
    (commandName: "HideLayerPropertiesView"): TypedCommand<{
        (): void;
    }>;
    /**
     * Prevents the display of markers by setting their visibility to `false`.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name HideMarkers
     * @introduced 2.5
     * @private
     */
    (commandName: "HideMarkers"): TypedCommand<{
        (): void;
    }>;
    /**
     * Dismisses the Markup Style view if it is open.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name HideMarkupStyleView
     * @introduced 2.8
     * @gcx-command-category Markup
     */
    (commandName: "HideMarkupStyleView"): TypedCommand<{
        (): void;
    }>;
    /**
     * Prevents the display of pushpins by setting their visibility to `false`.  Pushpins must be enabled for this command to work.
     * Pushpins must be enabled for this command to work.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name HidePushpins
     * @introduced 2.1
     * @gcx-command-category Pushpins
     */
    (commandName: "HidePushpins"): TypedCommand<{
        (): void;
    }>;
    /**
     * Highlights all of the features in the specified feature set in the charting highlight layer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name HighlightChartFeatureSet
     * @param featureSet The Geocortex feature set to highlight.
     * @introduced 2.3
     * @gcx-workflow-disabled
     * @gcx-command-category Charting
     */
    (commandName: "HighlightChartFeatureSet"): TypedCommand<{
        (featureSet: FeatureSet): void;
    }>;
    /**
     * Highlights the features of a given collaboration event.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name HighlightCollaborationFeatures
     * @param eventId The id of the event to be highlighted.
     * @introduced 2.8
     * @private
     */
    (commandName: "HighlightCollaborationFeatures"): TypedCommand<{
        (eventId: string): void;
    }>;
    /**
     * Highlights all of the features in the specified Esri feature set in the active highlight layer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name HighlightEsriFeatureSet
     * @param esriFeatureSet The set of features to highlight.  An instance of {@link esri.tasks.FeatureSet}.
     * @introduced 1.2
     * @deprecated 2.8 Use 'HighlightFeature' or 'HighlightFeatures'
     * @gcx-hyperlink-disabled
     * @gcx-command-category Highlighting
     */
    (commandName: "HighlightEsriFeatureSet"): TypedCommand<{
        (featureSet: esri.tasks.FeatureSet): void;
    }>;
    /**
     * Highlights the feature (or array of features) in the default (or specified) highlight layer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name HighlightFeature
     * @param feature The Geocortex feature (or array of features) to highlight.
     * @introduced 1.2
     * @gcx-command-category Highlighting
     */
    (commandName: "HighlightFeature"): TypedCommand<{
        (feature: esri.tasks.FeatureSet | Feature | Feature[] | HighlightFeatureArgs): void;
    }>;
    /**
     * Highlights the feature (or array of features) in the default (or specified) highlight layer. Synonym for HighlightFeature
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name HighlightFeatures
     * @param feature The Geocortex feature (or array of features) to highlight.
     * @introduced 1.2
     * @gcx-command-category Highlighting
     */
    (commandName: "HighlightFeatures"): TypedCommand<{
        (feature: esri.tasks.FeatureSet | Feature | Feature[] | HighlightFeatureArgs): void;
    }>;
    /**
     * Clears existing highlights and highlights all specified features on the default (or specified) highlight layer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ClearAndHighlightFeatures
     * @param features The Geocortex features to highlight.
     * @introduced 2.8
     * @gcx-command-category Highlighting
     */
    (commandName: "ClearAndHighlightFeatures"): TypedCommand<{
        (features: esri.tasks.FeatureSet | Feature | Feature[] | HighlightFeatureArgs): void;
    }>;
    /**
     * Focus the specified feature on the active highlight layer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name FocusFeature
     * @param feature The Geocortex feature to focus.
     * @introduced 2.8
     * @gcx-command-category Highlighting
     */
    (commandName: "FocusFeature"): TypedCommand<{
        (feature: esri.tasks.FeatureSet | Feature | Feature[] | HighlightFeatureArgs): void;
    }>;
    /**
     * Clears the focus from a feature if it's currently focused, returning it to the highlighted state.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ClearFeatureEmphasis
     * @param feature The Geocortex feature to clear the feature emphasis from.
     * @introduced 2.8
     * @gcx-command-category Highlighting
     */
    (commandName: "ClearFeatureFocus"): TypedCommand<{
        (feature: esri.tasks.FeatureSet | Feature | Feature[] | HighlightFeatureArgs): void;
    }>;
    /**
     * Clears the feature highlight from a feature. This will also clear the emphasis.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ClearFeatureEmphasis
     * @param feature The Geocortex feature to clear the highlight from.
     * @introduced 2.8
     * @gcx-workflow-disabled
     * @gcx-command-category Highlighting
     */
    (commandName: "ClearFeatureHighlight"): TypedCommand<{
        (feature: Feature | Feature[] | HighlightFeatureArgs): void;
    }>;
    /**
     * Highlights the feature in the default highlight layer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name HighlightFeatureDefault
     * @param feature The Geocortex feature to highlight.
     * @introduced 1.2
     * @deprecated 1.3 Use HighlightFeature instead.
     * @gcx-workflow-disabled
     * @gcx-command-category Highlighting
     */
    (commandName: "HighlightFeatureDefault"): TypedCommand<{
        (feature: Feature): void;
    }>;
    /**
     * Highlights all of the features in the specified FeatureSet in the active highlight layer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name HighlightFeatureSet
     * @param featureSet The Geocortex feature set to highlight.
     * @introduced 1.2
     * @deprecated 2.8 We don't use this, but if it is required please just add FeatureSet to the existing HighlightFeature command signature.
     * @gcx-workflow-disabled
     * @gcx-command-category Highlighting
     */
    (commandName: "HighlightFeatureSet"): TypedCommand<{
        (featureSet: FeatureSet): void;
    }>;
    /**
     * Executes an identify operation on a geometry.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name Identify
     * @param geometry The ESRI geometry to identify with.
     * @param args Alternatively, specify the Identify arguments. An instance of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.IdentifyArgs}.
     * @introduced 1.0
     * @gcx-command-category Identify
     */
    (commandName: "Identify"): TypedCommand<{
        (geometry: esri.geometry.Geometry): void;
        (args: IdentifyArgs): void;
    }>;
    /**
     * Activates the Buffer Options dialog, buffers input geometry using settings specified by the user, places temporary markup on the map and identifies using the buffered geometry.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name IdentifyBufferedGeometry
     * @param geometry The Esri geometry with which to buffer and identify.
     * @introduced 2.5
     * @gcx-command-category Buffering
     */
    (commandName: "IdentifyBufferedGeometry"): TypedCommand<{
        (geometry: esri.geometry.Geometry): void;
    }>;
    /**
     * Activates the Buffer Options dialog, buffers input feature geometry using settings specified by the user, places temporary markup on the map and identifies using the buffered geometry.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name IdentifyBufferedFeature
     * @param feature An {@link esri.Graphic} or {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature} that has the geometry with which to buffer and identify.
     * @introduced 2.5
     * @gcx-command-category Buffering
     */
    (commandName: "IdentifyBufferedFeature"): TypedCommand<{
        (feature: esri.Graphic | Feature): void;
    }>;
    /**
     * Activates the Buffer Options dialog, buffers the specified feature set geometry using settings specified by the user, places temporary markup on the map and identifies using the buffered geometry.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name IdentifyBufferedFeatureSet
     * @param featureSetOrFeatureSetColl A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSet} or {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} or `string` representing the
     * feature set that has the geometry with which to buffer and identify. If a {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} or {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} ID is specified, the currently selected feature set will be used as input. If no feature set is currently selected, the first one will be used.
     * @introduced 2.5
     * @gcx-command-category Buffering
     */
    (commandName: "IdentifyBufferedFeatureSet"): TypedCommand<{
        (featureSetOrFeatureSetColl: FeatureSet | FeatureSetCollection | string): void;
    }>;
    /**
     * Activates the Buffer Options dialog, buffers the specified feature set collection geometries using settings specified by the user, places temporary markup on the map and identifies using the buffered geometry.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name IdentifyBufferedFeatureSetCollection
     * @param fsc A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} or `string` representing the feature set collection that has the geometries with which to buffer and identify.
     * @introduced 2.5
     * @gcx-command-category Buffering
     */
    (commandName: "IdentifyBufferedFeatureSetCollection"): TypedCommand<{
        (fsc: FeatureSetCollection | string): void;
    }>;
    /**
     * Executes an Identify operation on the given geometry and sets "MapTip" as the feature source.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name InvokeMapTip
     * @param geometry The geometry for which to invoke the map tip.
     * @introduced 1.1
     * @gcx-command-category Map Widget
     */
    (commandName: "InvokeMapTip"): TypedCommand<{
        (geometry: esri.geometry.Geometry): void;
    }>;
    /**
     * Tells the Geocortex Essentials Site object to begin initialization.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name InitializeSite
     * @param mapControl The {@link esri.Map} object with which this Site will be initialized.
     * @introduced 1.0
     * @deprecated 2.8 The site is no longer initialized via command.
     * @gcx-command-category Start-Up
     */
    (commandName: "InitializeSite"): TypedCommand<{
        (mapControl: esri.Map): void;
    }>;
    /**
     * Integrate a {@link essentials.MapService} and its sub-components into the viewer and onto the map.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name AddMapService
     * @param mapService The {@link essentials.MapService} which contains a service layer and Geocortex layers to be integrated
     * onto the map and into the viewer. Supported map service types include: {@link essentials.FeatureLayerService}, {@link essentials.KmlService},
     * and {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.LayerIntegrationUtils.LocalFeatureLayerService}.
     * @introduced 2.6
     * @gcx-command-category Layer List
     */
    (commandName: "AddMapService"): TypedCommand<{
        (mapService: MapService): void;
    }>;
    /**
     * Lauches a QR scan, then calls the provided callback with the result.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name LaunchBarcodeScannerWithCallback
     * @param callback When a QR scan completes, this function is called and passed the scanning result object as an argument.
     * @introduced 2.5
     * @gcx-command-category Scanning
     */
    (commandName: "LaunchBarcodeScannerWithCallback"): TypedCommand<{
        (callback: (result) => void): void;
    }>;
    /**
     * Wires up a {@link geocortex.essentialsHtmlViewer.integration.PostMessageTransport} and enables
     * bi-directional communication with the component.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ListenToExternalComponentFrame
     * @param projectArgs An instance of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.integration.ComponentFrameInfo} describing an external component.
     * @introduced 2.4
     * @gcx-command-category Integration
     */
    (commandName: "ListenToExternalComponentFrame"): TypedCommand<{
        (arg: ComponentFrameInfo): void;
    }>;
    /**
     * Load a collaboration event's graphics to the collaboration graphics layer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name LoadCollaborationMarkupGraphics
     * @param event The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.collaboration.RestEvent} to be loaded into markup.
     * @introduced 2.8
     * @private
     */
    (commandName: "LoadCollaborationMarkupGraphics"): TypedCommand<{
        (event: RestEvent): void;
    }>;
    /**
     * Loads a project and applies it to the viewer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name LoadProject
     * @param project The unique ID of the project to load, or an instance of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.project.Project} containing the project data.
     * @introduced 2.6
     * @gcx-command-category Projects
     */
    (commandName: "LoadProject"): TypedCommand<{
        (project: string | Project): void;
    }>;
    /**
     * Presents a user interface for managing the list of available named, saved selections.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ListSelections
     * @introduced 2.6
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "ListSelections"): TypedCommand<{
        (): void;
    }>;
    /**
     * Presents a user interface for managing the list of available named queries.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ListQueries
     * @introduced 2.8
     */
    (commandName: "ListQueries"): TypedCommand<{
        (): void;
    }>;
    /**
     * Presents a user interface for managing the list of available named filters.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ListFilters
     * @introduced 2.8
     */
    (commandName: "ListFilters"): TypedCommand<{
        (): void;
    }>;
    /**
     * Logs an event for Geocortex Optimizer.
     * @name LogOptimizerEvent
     * @param eventName The type of event to log.
     * @param eventInfo Information about the event; varies based on the eventName.
     * @introduced 2.1
     * @gcx-command-category Optimizer
     */
    (commandName: "LogOptimizerEvent"): TypedCommand<{
        (eventName: string, eventInfo: string): void;
    }>;
    /**
     * Tells the map control to resize itself. This should be called after altering the map container's dimensions.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name MapResize
     * @introduced 1.0
     * @gcx-command-category Map Display
     */
    (commandName: "MapResize"): TypedCommand<{
        (): void;
    }>;
    /**
    * Instructs the region hosting a view to maximize itself, if it supports this action. As of version 2.4, only the `BottomPanelRegion` and its subregions support this action.
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name MaximizePanel
    * @param viewId The ID of the view requesting its region to maximize itself.
    * @introduced 2.4
    * @gcx-command-category Region and View
    */
    (commandName: "MaximizePanel"): TypedCommand<{
        (viewId: string): void;
    }>;
    /**
     * Computes the area, perimeter and individual segment lengths for the specified polygon geometry and plots it on the map along with its measurements.
     * Uses the spatial reference, calculation mode and units specified for the measurement module
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name MeasureArea
     * @param polygon A polygon geometry object.  (Note: An Esri graphic or Geocortex feature may also be provided as arguments instead of a polygon geometry.)
     * @introduced 2.0
     * @gcx-command-category Measurement
     */
    (commandName: "MeasureArea"): TypedCommand<{
        (polygon: esri.geometry.Polygon): void;
    }>;
    /**
     * Computes the total and segment distance measurements for the specified Polyline geometry and plots it on the map along with its measurements.
     * Uses the spatial reference, calculation mode and units specified for the measurement module.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name MeasureDistance
     * @param polyline A polyline geometry object (Note: An Esri graphic or Geocortex feature may also be provided as arguments instead of a polyline geometry)
     * @introduced 2.0
     * @gcx-command-category Measurement
     */
    (commandName: "MeasureDistance"): TypedCommand<{
        (polyline: esri.geometry.Polyline): void;
    }>;
    /**
     * Opens the After Action Playback view.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name OpenAfterActionPlayback
     * @introduced 2.8
     * @gcx-command-category Collaboration
     */
    (commandName: "OpenAfterActionPlayback"): TypedCommand<{
        (): void;
    }>;
    /**
     * Opens the Collaboration view.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name OpenCollaboration
     * @introduced 2.8
     * @gcx-command-category Collaboration
     */
    (commandName: "OpenCollaboration"): TypedCommand<{
        (): void;
    }>;
    /**
     * Opens the image associated with a given ShareImageEvent given its map Feature.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name OpenEventFeatureImage
     * @param feature The Geocortex feature for the ShareImageEvent.
     * @introduced 2.8.1
     * @private
     */
    (commandName: "OpenEventFeatureImage"): TypedCommand<{
        (feature: Feature): void;
    }>;
    /**
     * Opens the data frame, if it is present in the current shell.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name OpenDataFrame
     * @introduced 1.0
     * @gcx-command-category Region and View
     */
    (commandName: "OpenDataFrame"): TypedCommand<{
        (): void;
    }>;
    /**
     * Opens the data frame, if open, focusses it. This command is not available for handheld.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name OpenAndFocusDataFrame
     * @introduced 2.9
     * @gcx-command-category Region and View
     */
    (commandName: "OpenAndFocusDataFrame"): TypedCommand<{
        (): void;
    }>;
    /**
     * Opens the IWantToMenu, if open, focusses it.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name OpenAndFocusIWantToMenu
     * @introduced 2.9
     * @gcx-command-category Region and View
     */
    (commandName: "OpenAndFocusIWantToMenu"): TypedCommand<{
        (): void;
    }>;
    /**
     * Opens the bottom region, if it is present in the current shell.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name OpenBottomRegion
     * @introduced 1.3
     * @gcx-command-category Region and View
     */
    (commandName: "OpenBottomRegion"): TypedCommand<{
        (): void;
    }>;
    /**
     * Opens the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} with the given ID.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name OpenFeatureSetCollection
     * @param fscId The ID of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} to open.
     * @introduced 1.1
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "OpenFeatureSetCollection"): TypedCommand<{
        (fscId: string): void;
    }>;
    /**
     * Opens a new browser window to the authenticated users ArcGIS Portal 'My Content' page.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name OpenPortalMyContentWindow
     * @introduced 2.6
     * @gcx-command-category Navigation
     */
    (commandName: "OpenPortalMyContentWindow"): TypedCommand<{
        (): void;
    }>;
    /**
     * Opens the Results Frame in shells where it is present.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name OpenResultsFrame
     * @introduced 1.1
     * @gcx-command-category Region and View
     */
    (commandName: "OpenResultsFrame"): TypedCommand<{
        (): void;
    }>;
    /**
     * Opens the Overview Map when it is present.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name OpenOverviewMap
     * @param focus An optional parameter for focussing on overviewMap. Defaults to true.
     * @introduced 2.4
     * @gcx-command-category Map Display
     */
    (commandName: "OpenOverviewMap"): TypedCommand<{
        (focus?: boolean): void;
    }>;
    /**
     * Pans the map down on the vertical axis.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name PanDown
     * @param panStep The percentage of the current map view to pan down. @introduced 2.4
     * @introduced 1.3
     * @gcx-command-category Navigation
     */
    (commandName: "PanDown"): TypedCommand<{
        (panStep?: number): void;
    }>;
    /**
     * Pans the map left on the horizontal axis.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name PanLeft
     * @param panStep The percentage of the current map view to pan to the left. @introduced 2.4
     * @introduced 1.3
     * @gcx-command-category Navigation
     */
    (commandName: "PanLeft"): TypedCommand<{
        (panStep?: number): void;
    }>;
    /**
     * Pans the map right on the vertical axis.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name PanRight
     * @param panStep The percentage of the current map view to pan to the right. @introduced 2.4
     * @introduced 1.3
     * @gcx-command-category Navigation
     */
    (commandName: "PanRight"): TypedCommand<{
        (panStep?: number): void;
    }>;
    /**
     * Pans to the extent of all the specified features.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name PanToAllFeatures
     * @param features An array containing the features to which to pan.  If empty, no panning occurs.
     * @introduced 2.3
     * @gcx-workflow-disabled
     * @gcx-command-category Navigation
     */
    (commandName: "PanToAllFeatures"): TypedCommand<{
        (features: Feature[]): void;
    }>;
    /**
     * Pans to a Geocortex feature.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name PanToFeature
     * @param feature The Geocortex feature to be panned to.
     * @introduced 1.1
     * @gcx-workflow-disabled
     * @gcx-command-category Navigation
     */
    (commandName: "PanToFeature"): TypedCommand<{
        (feature: Feature): void;
    }>;
    /**
     * Pans to a Geocortex feature if the feature is outside of the map's extent, otherwise nothing happens.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name PanToFeatureIfOutsideMapExtent
     * @param feature The Geocortex feature to be panned to.
     * @introduced 2.4
     * @gcx-workflow-disabled
     * @gcx-command-category Navigation
     */
    (commandName: "PanToFeatureIfOutsideMapExtent"): TypedCommand<{
        (feature: Feature): void;
    }>;
    /**
     * Pans to a point on the map.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name PanToPoint
     * @param point The point to pan to.
     * @introduced 1.0
     * @gcx-command-category Navigation
     */
    (commandName: "PanToPoint"): TypedCommand<{
        (geometry: esri.geometry.Point): void;
    }>;
    /**
     * Pans the map up on the vertical axis.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name PanUp
     * @param panStep The percentage of the current map view to pan up. @introduced 2.4
     * @introduced 1.3
     * @gcx-command-category Navigation
     */
    (commandName: "PanUp"): TypedCommand<{
        (panStep?: number): void;
    }>;
    /**
    * Plots a coordinate or a number of coordinates on the map.
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name PlotCoordinates
    * @param baseCoords The (@link infrastructure.coordinates.CoordinateBase} (or array of multiple base coordinates) to plot.
    * @introduced 2.6
    * @gcx-command-category Plot Coordinates
    */
    (commandName: "PlotCoordinates"): TypedCommand<{
        (baseCoords: CoordinateBase | CoordinateBase[]): void;
    }>;
    /**
     * Populates the LabelOptions view.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name PopulateLabelOptionsView
     * @param layer The layer that is having its label options changed
     * @introduced 2.7
     * @gcx-command-category Label Options
     */
    (commandName: "PopulateLabelOptionsView"): TypedCommand<{
        (layer: Layer): void;
    }>;
    /**
     * Displays a dialog to create a printable map.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name PrintMap
     * @introduced 1.3
     * @gcx-command-category Print
     */
    (commandName: "PrintMap"): TypedCommand<{
        (): void;
    }>;
    /**
     * Push the contents of one collaboration room to another.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name PushCollaborationRoom
     * @param source The id of the source collaboration room.
     * @param destination The id of the original collaboration event.
     * @param queryOptions The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.collaboration.QueryOptions} with the event types to be copied.
     * @param callbackfn A callback to be executed on completion.
     * @introduced 2.8
     * @private
     */
    (commandName: "PushCollaborationRoom"): TypedCommand<{
        (sourceRoom: string, destinationRoom: string, queryOptions?: QueryOptions, callbackfn?: (value: boolean) => {}): void;
    }>;
    /**
     * Displays a dialog to export the map.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowExportMapDialog
     * @introduced 2.4
     * @gcx-command-category Export
     */
    (commandName: "ShowExportMapDialog"): TypedCommand<{
        (): void;
    }>;
    /**
     * Shows the layer catalog view.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowLayerCatalog
     * @introduced 2.7
     * @gcx-command-category Layer Catalog
     */
    (commandName: "ShowLayerCatalog"): TypedCommand<{
        (): void;
    }>;
    /**
    * Activates and shows the time slider if time slider profiles have been defined in the site.
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name ActivateTimeSlider
    * @introduced 2.7
    * @gcx-command-category TimeSlider
    */
    (commandName: "ActivateTimeSlider"): TypedCommand<{
        (): void;
    }>;
    /**
    * Deactivates time settings applied to the map and hides the Time Slider.
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name DeactivateTimeSlider
    * @introduced 2.7
    * @gcx-command-category TimeSlider
    */
    (commandName: "DeactivateTimeSlider"): TypedCommand<{
        (): void;
    }>;
    /**
    * Hides the time slider if currently visible but does not deactivate time settings applied to the map..
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name HideTimeSlider
    * @introduced 2.7
    * @gcx-command-category TimeSlider
    */
    (commandName: "HideTimeSlider"): TypedCommand<{
        (): void;
    }>;
    /**
    * Shows the time slider settings view..
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name ShowTimeSliderSettings
    * @introduced 2.7
    * @gcx-command-category TimeSlider
    */
    (commandName: "ShowTimeSliderSettings"): TypedCommand<{
        (): void;
    }>;
    /**
    * Hides the time slider settings view.
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name HideTimeSliderSettings
    * @introduced 2.7
    * @gcx-command-category TimeSlider
    */
    (commandName: "HideTimeSliderSettings"): TypedCommand<{
        (): void;
    }>;
    /**
    * Toggles the time slider actions container visibility.
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name ToggleTimeSliderActions
    * @introduced 2.7
    * @gcx-command-category TimeSlider
    */
    (commandName: "ToggleTimeSliderActions"): TypedCommand<{
        (): void;
    }>;
    /**
    * Starts playback for an open time slider.
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name StartTimeSliderPlayback
    * @introduced 2.9
    * @gcx-command-category TimeSlider
    */
    (commandName: "StartTimeSliderPlayback"): TypedCommand<{
        (): void;
    }>;
    /**
    * Stops playback for an open time slider.
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name StopTimeSliderPlayback
    * @introduced 2.9
    * @gcx-command-category TimeSlider
    */
    (commandName: "StopTimeSliderPlayback"): TypedCommand<{
        (): void;
    }>;
    /**
    * Steps the time slider forward in an open time slider.
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name StepTimeSliderForward
    * @introduced 2.9
    * @gcx-command-category TimeSlider
    */
    (commandName: "StepTimeSliderForward"): TypedCommand<{
        (): void;
    }>;
    /**
    * Steps the time slider backward in an open time slider.
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name StepTimeSliderBack
    * @introduced 2.9
    * @gcx-command-category TimeSlider
    */
    (commandName: "StepTimeSliderBack"): TypedCommand<{
        (): void;
    }>;
    /**
    * Sets a specified time slider profile or updates the existing profile if only a partial profile is specified.
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name SetTimeSliderProfile
    * @introduced 2.7
    * @gcx-command-category TimeSlider
    */
    (commandName: "SetTimeSliderProfile"): TypedCommand<{
        (profile: TimeSliderProfile): void;
    }>;
    /**
     * Adds catalog layers.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @param args A comma seperated string of layer ids.
     * @name AddCatalogLayers
     * @introduced 2.7
     * @gcx-command-category Layer Catalog
     */
    (commandName: "AddCatalogLayers"): TypedCommand<{
        (args: string): void;
    }>;
    /**
     * Appends catalog layers.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @param args A comma seperated string of layer ids.
     * @name AppendCatalogLayers
     * @introduced 2.7
     * @gcx-command-category Layer Catalog
     */
    (commandName: "AppendCatalogLayers"): TypedCommand<{
        (args: string): void;
    }>;
    /**
     * Clears all catalog layers.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ClearLayerCatalogLayers
     * @introduced 2.7
     * @gcx-command-category Layer Catalog
     */
    (commandName: "ClearLayerCatalogLayers"): TypedCommand<{
        (): void;
    }>;
    /**
     * Clear all saved queries
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ClearSavedQueries
     * @param successCallback
     * @param errorCallback
     * @introduced 2.8
     * @gcx-command-category Query
     */
    (commandName: "ClearSavedQueries"): TypedCommand<{
        (): void;
    }>;
    /**
     * Clear all saved filters
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ClearSavedFilters
     * @param successCallback
     * @param errorCallback
     * @introduced 2.8
     * @gcx-command-category Query
     */
    (commandName: "ClearSavedFilters"): TypedCommand<{
        (): void;
    }>;
    /**
     * Remove a collaboration event's graphics from the collaboration graphics layer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RemoveCollaborationFeatures
     * @param eventId The id of the collaboration event to be removed from the collaboration markup layer.
     * @introduced 2.8
     * @private
     */
    (commandName: "RemoveCollaborationFeatures"): TypedCommand<{
        (eventId: string): void;
    }>;
    /**
     * Removes specific layer catalog item like layer or map service(will not work for map service which has multiple layers like dynamicmapService).
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @param arg item to be removed
     * @name RemoveLayerCatalogItem
     * @introduced 2.7
     * @gcx-command-category Layer Catalog
     */
    (commandName: "RemoveLayerCatalogItem"): TypedCommand<{
        (arg: any): void;
    }>;
    /**
     * Calls a geometry service to project geometries between different coordinate systems.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name Project
     * @param projectArgs An instance of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.ProjectArgs}.
     * @introduced 1.1
     * @gcx-hyperlink-disabled
     * @gcx-workflow-disabled
     * @gcx-command-category Projection
     */
    (commandName: "Project"): TypedCommand<{
        (arg: ProjectArgs): void;
    }>;
    /**
     * Displays a prompt.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name Prompt
     * @param title The title of the prompt box.
     * @param description The text description to show in the prompt.
     * @param defaultText Default text that will appear in the input text box.
     * @param callback An optional callback to fire if the window was closed without clicking OK or Cancel.
     * @introduced 1.0
     * @gcx-workflow-recommendations Instead of using the `Prompt` viewer command in workflows, use the `Prompt` workflow activity that is provided in Workflow Designer.
     * @gcx-command-category Dialog
     */
    (commandName: "Prompt"): TypedCommand<{
        (title: string, description: string, defaultText: string, callback: (inputText: string) => void): void;
    }>;
    /**
     * Resets the timer of the status view model.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name PulseStatus
     * @param statusId ID of the status message whose timer need to be reset.
     * @introduced 1.1
     * @gcx-command-category Map Widget
     */
    (commandName: "PulseStatus"): TypedCommand<{
        (statusId: string): void;
    }>;
    /**
     * Recenters the map to its existing position the next time the map is resized.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RecenterMapOnNextMapResize
     * @introduced 1.1
     * @gcx-command-category Map Display
     */
    (commandName: "RecenterMapOnNextMapResize"): TypedCommand<{
        (): void;
    }>;
    /**
     * Refresh the list of offline maps on the OfflineMapsList view.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RefreshOfflineMapsList
     * @introduced 2.6
     * @gcx-command-category Offline Profiles
     */
    (commandName: "RefreshOfflineMapsList"): TypedCommand<{
        (): void;
    }>;
    /**
     * Reverses the last recorded undo operation or transaction.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name Redo
     * @introduced 2.5
     * @gcx-command-category Undo and Redo
     */
    (commandName: "Redo"): TypedCommand<{
        (): void;
    }>;
    /**
     * Performs advanced set operations with multiple lists of results.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name CombineResults
     * @param args A {@link CombineResultsArgs} object with the following members: `combineMode`, `featureSetCollectionIds`, `currentResults` (optional), `successCallback` (optional) and `errorCallback` (optional).
     * @introduced 2.6
     * @private
     */
    (commandName: "CombineResults"): TypedCommand<{
        (args: CombineResultsArgs): void;
    }>;
    /**
     * Activates a series of views that guide the user to perform advanced set operations with multiple lists of results.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name CombineResultsInteractive
     * @param operationType One of: `union`, `intersect`, `subtract`, `replace`. If not specified, `replace` is used by default.
     * @introduced 2.6
     * @private
     */
    (commandName: "CombineResultsInteractive"): TypedCommand<{
        (args: {
            mode: string;
            currentResults: FeatureSetCollection | string;
        }): void;
    }>;
    /**
     * Only keeps results from the current set of results that also appear in the supplied {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection}.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ResultsIntersect
     * @param args Either a {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} or a string representing the collection ID.
     * @introduced 2.6
     * @gcx-workflow-requirements In order to use this command in a workflow, you must use the ID of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} as the parameter.
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "ResultsIntersect"): TypedCommand<{
        (args: FeatureSetCollection | string): void;
    }>;
    /**
     * Replaces the current set of results with the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} supplied as argument.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ResultsReplace
     * @param args Either a {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} or a string representing the collection ID.
     * @introduced 2.6
     * @gcx-workflow-requirements In order to use this command in a workflow, you must use the ID of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} as the parameter.
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "ResultsReplace"): TypedCommand<{
        (args: FeatureSetCollection | string): void;
    }>;
    /**
     * Removes the supplied {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} from the current set of results.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ResultsSubtract
     * @param args Either a {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} or a string representing the collection ID.
     * @introduced 2.6
     * @gcx-workflow-requirements In order to use this command in a workflow, you must use the ID of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} as the parameter.
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "ResultsSubtract"): TypedCommand<{
        (args: FeatureSetCollection | string): void;
    }>;
    /**
     * Adds the supplied {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} to the current set of results.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ResultsUnion
     * @param args Either a {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} or a string representing the collection ID.
     * @introduced 2.6
     * @gcx-workflow-requirements In order to use this command in a workflow, you must use the ID of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} as the parameter.
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "ResultsUnion"): TypedCommand<{
        (args: FeatureSetCollection | string): void;
    }>;
    /**
     * Refresh the list of browsable projects.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RefreshProjectsList
     * @introduced 2.6
     * @gcx-command-category Projects
     */
    (commandName: "RefreshProjectsList"): TypedCommand<{
        (): void;
    }>;
    /**
     * Registers a chart point data adapter if it is not already registered.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RegisterChartPointAdapter
     * @param arg An object with the following members: adapter, sourceType.
     * @private
     */
    (commandName: "RegisterChartPointAdapter"): TypedCommand<{
        (arg: {
            adapter: ChartPointAdapterInterface;
            sourceType: string;
        }): void;
    }>;
    /**
     * Registers a search provider if it is not already registered.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RegisterSearchProvider
     * @param provider The search provider instance to be registered.
     * @private
     */
    (commandName: "RegisterSearchProvider"): TypedCommand<{
        (provider: SearchProviderBase): void;
    }>;
    /**
     * Registers a {@link geocortex.essentials.Layer} with the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.snapping.SnappingProvider}.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RegisterSnappingLayer
     * @param layer The {@link geocortex.essentials.Layer} to be registered.
     * @gcx-command-category Snapping
     */
    (commandName: "RegisterSnappingLayer"): TypedCommand<{
        (layer: Layer): void;
    }>;
    /**
     * Registers multiple layers with the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.snapping.SnappingProvider}.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RegisterSnappingLayers
     * @param layers An array of {@link geocortex.essentials.Layer} instances to be registered.
     * @gcx-command-category Snapping
     */
    (commandName: "RegisterSnappingLayers"): TypedCommand<{
        (layers: Layer[]): void;
    }>;
    /**
     * Removes a notification view by id
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RemoveNotification
     * @introduced 2.8
     * @gcx-command-category Map Widget
     */
    (commandName: "RemoveNotification"): TypedCommand<{
        (id: string): void;
    }>;
    /**
     * Removes a {@link geocortex.essentials.Layer} from the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.snapping.SnappingProvider}.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RemoveSnappingLayer
     * @param layer The {@link geocortex.essentials.Layer} to be removed.
     * @gcx-command-category Snapping
     */
    (commandName: "RemoveSnappingLayer"): TypedCommand<{
        (layer: Layer): void;
    }>;
    /**
     * Removes multiple layers from the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.snapping.SnappingProvider}.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RegisterSnappingLayers
     * @param layers An array of {@link geocortex.essentials.Layer} instances to be removed.
     * @gcx-command-category Snapping
     */
    (commandName: "RemoveSnappingLayers"): TypedCommand<{
        (layers: Layer[]): void;
    }>;
    /**
     * Removes a bookmark with the given name, if it exists.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RemoveBookmark
     * @param name The name of the bookmark to remove.
     * @introduced 2.0
     * @gcx-command-category Bookmark
     */
    (commandName: "RemoveBookmark"): TypedCommand<{
        (name: string): void;
    }>;
    /**
     * Removes the specified chart from the charting view.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RemoveChartById
     * @param chartId The chart Id.
     * @introduced 2.3
     * @gcx-command-category Charting
     */
    (commandName: "RemoveChartById"): TypedCommand<{
        (chartId: string): void;
    }>;
    /**
     * Removes a cluster layer from an existing Geocortex Layer that holds an Esri FeatureLayer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RemoveClusterLayer
     * @param args Either a ClusterLayerArgs or String representing the Map Service's ID.
     * @introduced 2.5
     * @gcx-command-category Visualization
     */
    (commandName: "RemoveClusterLayer"): TypedCommand<{
        (args: ClusterLayerArgs | string): void;
    }>;
    /**
     * Removes an individual feature from the current {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} displayed in the results view.
     * Typically, an end-user would click "Remove from Results" on a map tip to remove the feature from the results.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RemoveFeatureFromResults
     * @param feature The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature} to remove from the results view.
     * @introduced 2.6
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "RemoveFeatureFromResults"): TypedCommand<{
        (feature: Feature): void;
    }>;
    /**
     * Removes an individual feature set from the current {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} displayed in the results view.
     * Typically, an end-user would click "Remove Feature Set from Results" on a feature set element's inline context menu to remove the feature from the results.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RemoveFeatureSetFromResults
     * @param feature The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSet} to remove from the results view.
     * @introduced 2.8
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "RemoveFeatureSetFromResults"): TypedCommand<{
        (fs: FeatureSet): void;
    }>;
    /**
     * Removes the specified collection from the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetManager}.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RemoveFeatureSetCollection
     * @param fsc The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} to remove.
     * @introduced 1.2
     * @gcx-workflow-disabled
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "RemoveFeatureSetCollection"): TypedCommand<{
        (fsc: FeatureSetCollection): void;
    }>;
    /**
     * Removes the collection specified by ID from the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetManager}.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RemoveFeatureSetCollectionById
     * @param fscId ID of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} to remove.
     * @introduced 1.2
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "RemoveFeatureSetCollectionById"): TypedCommand<{
        (fscId: string): void;
    }>;
    /**
     * Removes a heat map visualization from a Geocortex layer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RemoveHeatMap
     * @param args Either {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.HeatMapArgs} or a string representing the Map Service's ID.
     * @introduced 2.5
     * @gcx-command-category Visualization
     */
    (commandName: "RemoveHeatMap"): TypedCommand<{
        (args: HeatMapArgs | string): void;
    }>;
    /**
     * Removes the highlight layer with the specified name, if one exists.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RemoveHighlightLayer
     * @param layerName The name of the layer to remove.
     * @introduced 1.2
     * @deprecated 2.8 Not recommended to manage multiple highlight layers externally.
     * @gcx-command-category Highlighting
     */
    (commandName: "RemoveHighlightLayer"): TypedCommand<{
        (layerName: string): void;
    }>;
    /**
     * Removes the marker from the map.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RemoveMarker
     * @param id The ID of the marker to be removed.
     * @introduced 2.5
     * @private
     */
    (commandName: "RemoveMarker"): TypedCommand<{
        (id: string): void;
    }>;
    /**
     * Removes a user added {@link essentials.MapService} off of the map and out of the viewer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RemoveMapService
     * @param mapService The {@link essentials.MapService} to be removed.
     * @introduced 2.7
     * @gcx-command-category Layer List
     */
    (commandName: "RemoveMapService"): TypedCommand<{
        (mapService: MapService): void;
    }>;
    /**
     * Removes the pushpin from the map for the given feature, if there is one.
     * Pushpins must be enabled for this command to work.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RemovePushpin
     * @introduced 2.4
     * @gcx-command-category Pushpins
     */
    (commandName: "RemovePushpin"): TypedCommand<{
        (feature: Feature): void;
    }>;
    /**
     * Removes all pushpins from the map.
     * Pushpins must be enabled for this command to work.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RemovePushpins
     * @introduced 2.3
     * @gcx-command-category Pushpins
     */
    (commandName: "RemovePushpins"): TypedCommand<{
        (): void;
    }>;
    /**
     * Removes the specified external component from the viewer. If the component is in a separate window, that window will be closed.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RemoveExternalComponentById
     * @param ecId The ID of the external component to remove.
     * @introduced 2.4
     * @gcx-command-category Integration
     */
    (commandName: "RemoveExternalComponentById"): TypedCommand<{
        (ecId: string): void;
    }>;
    /**
     * Removes the status indicator from the results list or table.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RemoveResultsStatus
     * @introduced 2.6
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "RemoveResultsStatus"): TypedCommand<{
        (): void;
    }>;
    /**
     * Removes the status indicator with the specified ID from the screen.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RemoveStatus
     * @param statusId The ID of the status indicator which needs to be removed.  If not specified, the last one is removed.
     * @introduced 1.1
     * @gcx-command-category Map Widget
     */
    (commandName: "RemoveStatus"): TypedCommand<{
        (statusId?: string): void;
    }>;
    /**
     * Remove a user added {@link essentials.Layer} (and its parent map service) off of the map and out of the viewer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RemoveUserAddedLayer
     * @param gcxLayer The {@link essentials.Layer} to be removed.
     * @introduced 2.6
     * @gcx-command-category Layer List
     */
    (commandName: "RemoveUserAddedLayer"): TypedCommand<{
        (gcxLayer: Layer): void;
    }>;
    /**
     * Removes the visualization from a Geocortex layer, if one is enabled.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RemoveVisualization
     * @param args Either a {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.VisualizationArgs} object or a string representing the ID of the map service.
     * @introduced 2.5
     * @gcx-command-category Visualization
     */
    (commandName: "RemoveVisualization"): TypedCommand<{
        (args: VisualizationArgs | string): void;
    }>;
    /**
     * Removes any custom symbolization from a layer and returns it to the default state.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RemoveVisualization
     * @param args An object containing a gcxLayer parameter, which is either a {@link essentials.Layer} or a string giving the layer id.
     * @introduced 2.7
     * @gcx-command-category Visualization
     */
    (commandName: "RemoveSymbolization"): TypedCommand<{
        (args: {
            gcxLayer: Layer | string;
        }): void;
    }>;
    /**
     * Applies the supplied renderer to the supplied layer. Layer must be a feature layer or a dynamic mapservice layer that supports resymbolization.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RemoveVisualization
     * @param args An object containing a gcxLayer parameter, which is either a {@link essentials.Layer} or a string giving the layer id and a renderer parameter, which is either an esri.renderer.Renderer object or the JSON string representation of one.
     * @introduced 2.7
     * @gcx-command-category Visualization
     */
    (commandName: "ResymbolizeLayer"): TypedCommand<{
        (args: {
            gcxLayer: Layer | string;
            renderer: esri.renderer.Renderer | string;
        }): void;
    }>;
    /**
     * Assigns a new name to a saved selection.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RenameSelection
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.RenameSelectionArgs} object with the following members: `newName`, `name`, `featureSetCollection` (optional), `successCallback` (optional) and `errorCallback` (optional).
     * @introduced 2.6
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "RenameSelection"): TypedCommand<{
        (args: RenameSelectionArgs): void;
    }>;
    /**
     * Loads a named, saved selection into the results view.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RestoreSelection
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.SelectionArgs} object with the following members: `name`, `featureSetCollection` (optional), `successCallback` (optional), `errorCallback` (optional).
     * @introduced 2.6
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "RestoreSelection"): TypedCommand<{
        (args: SelectionArgs): void;
    }>;
    /**
     * Instructs the region hosting a view to restore itself to its previous dimensions, if it supports this action. As of version 2.4, only the `BottomPanelRegion` and its subregions support this action.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RestorePanel
     * @param viewId The ID of the view requesting its region to restore itself to the default dimensions.
     * @introduced 2.4
     * @gcx-command-category Region and View
     */
    (commandName: "RestorePanel"): TypedCommand<{
        (viewId: string): void;
    }>;
    /**
     * Recalculate the size and layout of the shell and refresh the shell accordingly.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ResizeShell
     * @introduced 1.2.1
     * @gcx-command-category Shell
     */
    (commandName: "ResizeShell"): TypedCommand<{
        (): void;
    }>;
    /**
     * Displays previously hidden map tips by setting their visibility to `true`.  Map tips must be enabled for this command to work.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RestoreAllMapTips
     * @introduced 2.3.1
     * @gcx-command-category Map Widget
     */
    (commandName: "RestoreAllMapTips"): TypedCommand<{
        (): void;
    }>;
    /**
     * Resumes the previously suspended display of map tips.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ResumeMapTips
     * @introduced 2.0
     * @gcx-command-category Map Widget
     */
    (commandName: "ResumeMapTips"): TypedCommand<{
        (): void;
    }>;
    /**
     * Executes preset actions for the supplied feature set when a user clicks on a chart point.
     * This includes highlighting, pan/zoom, opening Feature Details, or running a command.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RunChartFeatureActions
     * @param featureSet The Geocortex feature set.
     * @introduced 2.3
     * @gcx-workflow-disabled
     * @gcx-command-category Charting
     */
    (commandName: "RunChartFeatureActions"): TypedCommand<{
        (featureSet: FeatureSet): void;
    }>;
    /**
     * Runs a workflow.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RunWorkflowById
     * @param workflowId The ID of the workflow to run.
     * @introduced 1.0
     * @gcx-command-category Workflow
     */
    (commandName: "RunWorkflowById"): TypedCommand<{
        (workflowId: string): void;
    }>;
    /**
     * Runs a workflow with a set of input arguments.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RunWorkflowWithArguments
     * @param arg An object that contains a property called workflowId representing the ID of the workflow, as well
     * as any other number of named arguments to pass to the workflow.
     * @introduced 1.2
     * @gcx-command-category Workflow
     * @gcx-workflow-requirements Note: In order to use this command in a workflow, you must pass the arg parameter as a `Newtonsoft.Json.Linq.JObject`.
     */
    (commandName: "RunWorkflowWithArguments"): TypedCommand<{
        (arg: {
            workflowId: string;
            [key: string]: string;
        }): void;
    }>;
    /**
     * Runs a workflow with a geometry used as an input argument.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RunWorkflowWithGeometry
     * @param arg An object with the following properties: workflowId, geometry.
     * @introduced 1.1
     * @gcx-workflow-disabled
     * @gcx-command-category Workflow
     */
    (commandName: "RunWorkflowWithGeometry"): TypedCommand<{
        (arg: {
            workflowId: string;
            geometry: esri.geometry.Geometry;
        }): void;
    }>;
    /**
     * If a user has screen reader software enabled, then the provided string is immediately spoken to them.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ScreenReaderNarrate
     * @param inputText A string that will be spoken to the user.
     * @introduced 2.4
     * @gcx-command-category WCAG
     */
    (commandName: "ScreenReaderNarrate"): TypedCommand<{
        (inputText: string): void;
    }>;
    /**
     * Disables the "ScreenReaderNarrate" command temporarily.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name DisableScreenReaderNarrate
     * @introduced 2.6
     * @gcx-command-category WCAG
     */
    (commandName: "DisableScreenReaderNarrate"): TypedCommand<{
        (): void;
    }>;
    /**
     * Enables screen reader narration if it was previously disabled using "DisableScreenReaderNarrate". Note that it will keep track of the number of calls to the
     * "DisableScreenReaderNarrate" command and will only reactivate the screen reader once all disable commands have been cancelled by a matching enable command.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name EnableScreenReaderNarrate
     * @introduced 2.6
     * @gcx-command-category WCAG
     */
    (commandName: "EnableScreenReaderNarrate"): TypedCommand<{
        (): void;
    }>;
    /**
     * Selects a base map by name and makes it visible. All other base maps are faded out.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SelectBaseMap
     * @param basemapName The name of the base map to switch to.
     * @introduced 2.0
     * @gcx-command-category Basemap
     */
    (commandName: "SelectBaseMap"): TypedCommand<{
        (basemapName: string): void;
    }>;
    /**
     * Sets the active highlight layer to the one matching the name provided, if one exists.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SetActiveHighlightLayer
     * @param layerName The name of the layer to set as active.
     * @introduced 1.2
     * @deprecated 2.8 Use 'HighlightFeatureArgs' to specify a highlight layer when using commands (it will be created if not available)
     * @gcx-command-category Highlighting
     */
    (commandName: "SetActiveHighlightLayer"): TypedCommand<{
        (layerName: string): void;
    }>;
    /**
     * Sets the default highlight layer as the active highlight layer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SetActiveHighlightLayerDefault
     * @deprecated 2.8 Use 'HighlightFeatureArgs' to specify a highlight layer when using commands
     * @introduced 1.3
     * @gcx-command-category Highlighting
     */
    (commandName: "SetActiveHighlightLayerDefault"): TypedCommand<{
        (): void;
    }>;
    /**
     * Sets the active tool.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SetActiveTool
     * @param toolName The name of the tool to activate.
     * @introduced 1.1
     * @gcx-command-category Map Widget
     */
    (commandName: "SetActiveTool"): TypedCommand<{
        (toolName: string): void;
    }>;
    /**
     * Sets the location of the collaboration photo point.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SetCollaborationImageLocation
     * @param args The ESRI geometry of the photo point.
     * @introduced 2.8
     * @private
     */
    (commandName: "SetCollaborationImageLocation"): TypedCommand<{
        (args: esri.geometry.Geometry): void;
    }>;
    /**
     * Sets the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} of interest that will be used to generate data for charts.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SetCollectionOfInterest
     * @param fscId The ID of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} for which to display charts.
     * @introduced 2.3
     * @gcx-command-category Charting
     */
    (commandName: "SetCollectionOfInterest"): TypedCommand<{
        (fscId: string): void;
    }>;
    /**
     * Sets the edit log, passing it into a callback. If an error occurs, the error is passed into the callback.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SetEditLog
     * @param editLog An array of edit logs to set.
     * @param errorCallback A callback to execute when an error occurs.
     * @introduced 1.1
     * @gcx-command-category Editing
     */
    (commandName: "SetEditLog"): TypedCommand<{
        (editLog: any[], errorCallback: (error: Error) => void): void;
    }>;
    /**
     * Sets the geometry for the feature currently being edited.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SetEditorFeatureGeometry
     * @param geometry Geometry for the feature currently being edited.
     * @private
     */
    (commandName: "SetEditorFeatureGeometry"): TypedCommand<{
        (geometry: esri.geometry.Geometry): void;
    }>;
    /**
     * Sets the current highlight border color to use, if the feature does not specify one.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SetHighlightBorderColor
     * @param color A 6 or 8 digit hex string representation of the color in RGB or ARGB form, respectively.
     * @param layer The name of the highlight layer to set (default if left out)
     * @introduced 1.2
     * @gcx-command-category Highlighting
     */
    (commandName: "SetHighlightBorderColor"): TypedCommand<{
        (color: string, layer?: string): void;
    }>;
    /**
     * Sets the current highlight border width to use, if the feature does not specify one.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SetHighlightBorderWidth
     * @param width A number representing the width in pixels.
     * @param layer The name of the highlight layer to set (default if left out)
     * @introduced 2.7
     * @gcx-command-category Highlighting
     */
    (commandName: "SetHighlightBorderWidth"): TypedCommand<{
        (width: number, layer?: string): void;
    }>;
    /**
     * Sets the current highlight fill color to use, if the feature does not specify one.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SetHighlightFillColor
     * @param color A 6 or 8 digit hex string representation of the color in RGB or ARGB form, respectively.
     * @param layer The name of the highlight layer to set (default if left out)
     * @introduced 1.2
     * @gcx-command-category Highlighting
     */
    (commandName: "SetHighlightFillColor"): TypedCommand<{
        (color: string, layer?: string): void;
    }>;
    /**
     * Sets the current combine mode to use for the identify tool.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SetIdentifyCombineMode
     * @param mode A string representing the combine mode for the identify tool.
     * @introduced 2.8
     * @gcx-command-category Tool
     */
    (commandName: "SetIdentifyCombineMode"): TypedCommand<{
        (mode: string): void;
    }>;
    /**
     * Sets the highlight border color to use for an focused feature.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SetFocusedBorderColor
     * @param color Any string recognized by the dojo.Color constructor.
     * @param layer The name of the highlight layer to set (default if left out)
     * @introduced 2.8
     * @gcx-command-category Highlighting
     */
    (commandName: "SetFocusedBorderColor"): TypedCommand<{
        (color: string, layer?: string): void;
    }>;
    /**
     * Sets the current highlight fill color to use for an focused feature.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SetFocusedFillColor
     * @param color Any string recognized by the dojo.Color constructor.
     * @param layer The name of the highlight layer to set (default if left out)
     * @introduced 2.8
     * @gcx-command-category Highlighting
     */
    (commandName: "SetFocusedFillColor"): TypedCommand<{
        (color: string, layer?: string): void;
    }>;
    /**
     * Sets the measurement units for the measurements performed by the measurement module.  Also updates existing measurements already on the map.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SetMeasurementUnits
     * @param lengthUnits A string with the following possible values: `feet`, `yard`, `meter`, `kilometer`, `mile`, `nauticalMile`.
     * @param areaUnits A string with the following possible values: `sqFeet`, `sqYard`, `sqMeter`, `sqKilometer`, `sqMile`, `sqNauticalMile`, `acre`, `hectare`.
     * @introduced 2.0
     * @gcx-command-category Measurement
     */
    (commandName: "SetMeasurementUnits"): TypedCommand<{
        (lengthUnits: string, areaUnits: string): void;
    }>;
    /**
     * Sets the geometry to be used in the offline map being edited.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SetOfflineMapEditorGeometry
     * @param geometry The geometry to set, or null to clear.
     * @introduced 2.0
     * @gcx-command-category Offline Profiles
     */
    (commandName: "SetOfflineMapEditorGeometry"): TypedCommand<{
        (geometry: esri.geometry.Polygon): void;
    }>;
    /**
     * Sets the time extent for the map.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SetTimeExtent
     * @param timeExtent The time extent for which data is displayed on the map.
     * @introduced 2.4
     * @gcx-command-category Map Display
     */
    (commandName: "SetTimeExtent"): TypedCommand<{
        (timeExtent: esri.TimeExtent): void;
    }>;
    /**
     * Used to start the process for creating a new related record/feature. Is activated by clicking 'Create A New Related ____' in the related feature details view.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name StartEditingNewRelatedRecord
     * @param item A RelatedLayerEntry object with the following properties: `id`, `text`, `relatedFeature`, `essentialsRelatedFeature` (optional), `feature` (optional), `editable` and `relationship`.
     * @param isNew A boolean value indicating whether the record is new or not.
     * @introduced 2.3
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "StartEditingNewRelatedRecord"): TypedCommand<{
        (item: any, isNew: boolean): void;
    }>;
    /**
     * Shares the Viewer url on the specified platform.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShareOn
     * @param name The id of the sharing option as specified on the configuration file.
     * @introduced 2.4
     * @gcx-command-category Share
     */
    (commandName: "ShareOn"): TypedCommand<{
        (id: string): void;
    }>;
    /**
     * Activates the accessibility view.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowAccessibilityView
     * @introduced 2.5
     * @gcx-command-category Accessibility
     */
    (commandName: "ShowAccessibilityView"): TypedCommand<{
        (): void;
    }>;
    /**
     * Prompts the user to bookmark the current extent by entering a name. Requires that the `BookmarkViewModel`'s property, `bookmarksEnabled`, is set to `true`.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowAddBookmark
     * @introduced 2.4
     * @gcx-command-category Bookmark
     */
    (commandName: "ShowAddBookmark"): TypedCommand<{
        (): void;
    }>;
    /**
     * Shows all plotted coordinates (including temporarily hidden ones) on the map.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowAllCoordinates
     * @introduced 2.6
     * @gcx-command-category Plot Coordinates
     */
    (commandName: "ShowAllCoordinates"): TypedCommand<{
        (): void;
    }>;
    /**
     * Opens the Collaboration event copy view.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowCopyDialogForEvent
     * @param event The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.collaboration.RestEvent} to be copied.
     * @introduced 2.8
     * @gcx-command-category Collaboration
     */
    (commandName: "ShowCopyDialogForEvent"): TypedCommand<{
        (event: RestEvent): void;
    }>;
    /**
     * Shows one or many plotted, temporarily hidden Coordinates on the map.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowCoordinates
     * @param descIds The string id, or array of string id's of the coordinate(s) to show on the map.
     * @introduced 2.6
     * @gcx-command-category Plot Coordinates
     */
    (commandName: "ShowCoordinates"): TypedCommand<{
        (descIds: string | string[]): void;
    }>;
    /**
     * Shows the configured coordinate actions.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowCoordinateActions
     * @param descId The id of the coordinate descriptor for which to display coordinate actions.
     * @introduced 2.6
     * @gcx-command-category Plot Coordinates
     */
    (commandName: "ShowCoordinateActions"): TypedCommand<{
        (descId: string): void;
    }>;
    /**
     * Shows the skip links.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowSkipLinks
     * @introduced 2.9
     * @gcx-command-category Region and View
     */
    (commandName: "ShowSkipLinks"): TypedCommand<{
        (): void;
    }>;
    /**
    * Shows the labelOptions view
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name ShowLabelOptionsView
    * @param layer The layer for which the label options view will be opened.
    * @introduced 2.7
    * @gcx-command-category Label Options
    */
    (commandName: "ShowLabelOptionsView"): TypedCommand<{
        (layer: Layer): void;
    }>;
    /**
     * Opens the Layer Properties panel from the Layer Actions menu.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowLayerPropertiesView
     * @param layer The layer whose properties may be altered.
     * @introduced 2.7
     * @gcx-command-category Layer Addition
     */
    (commandName: "ShowLayerPropertiesView"): TypedCommand<{
        (layer: Layer): void;
    }>;
    /**
     * Displays the available options for refining the current set of results; that is, Union, Subtract, Intersect.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name "ShowSearchOptions"
     * @param fscOrId The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} or its ID, to refine.
     * @introduced 2.6
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "ShowSearchOptions"): TypedCommand<{
        (fscOrId: FeatureSetCollection | string): void;
    }>;
    /**
     * Displays the Bookmarked Locations menu if the `BookmarkViewModel`'s property, `bookmarksEnabled`, is set to `true`.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowBookmarks
     * @introduced 2.0
     * @gcx-command-category Bookmark
     */
    (commandName: "ShowBookmarks"): TypedCommand<{
        (): void;
    }>;
    /**
     * Activates the charting view.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowChartingView
     * @introduced 2.3
     * @gcx-command-category Charting
     */
    (commandName: "ShowChartingView"): TypedCommand<{
        (): void;
    }>;
    /**
     * Activates the export web map view.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowExportWebMapDialog
     * @introduced 2.6
     * @gcx-command-category Export
     */
    (commandName: "ShowExportWebMapDialog"): TypedCommand<{
        (): void;
    }>;
    /**
     * Shows the feature attribute editor used to edit feature attributes.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowFeatureAttributeEditor
     * @introduced 1.3
     * @deprecated 2.3 The feature editor will automatically appear when editing a feature is started.
     * @gcx-command-category Offline
     */
    (commandName: "ShowFeatureAttributeEditor"): TypedCommand<{
        (): void;
    }>;
    /**
     * Creates and displays the Feature Details dialog for the first feature in the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} specified.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowFirstFeatureFromCollection
     * @param arg A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} or its ID, whose first feature's details are to be shown.
     * @introduced 2.6
     * @gcx-workflow-requirements In order to use this command in a workflow, you must use the ID of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} as the parameter.
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "ShowFirstFeatureFromCollection"): TypedCommand<{
        (arg: string | FeatureSetCollection): void;
    }>;
    /**
     * Creates and displays the Feature Details dialog for the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature} or {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} specified.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowFeatureDetails
     * @param arg A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature} or a {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} ID for which to show the Feature Details component.
     * @introduced 1.3
     * @gcx-workflow-requirements In order to use this command in a workflow, you must use the ID of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} as the parameter.
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "ShowFeatureDetails"): TypedCommand<{
        (arg: Feature | string): void;
    }>;
    /**
     * Creates and displays the Feature Details dialog for the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature} in Compact View mode. If the feature is not specified, details for the last feature will be displayed.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowFeatureDetailsCompact
     * @param feature A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature} for which to show the feature details. If not specified, details for the last feature will be displayed.
     * @introduced 2.4
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "ShowFeatureDetailsCompact"): TypedCommand<{
        (feature?: Feature): void;
    }>;
    /**
     * Creates and displays the Feature Details dialog for the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature} in Expanded View mode. If the feature is not specified, details for the last feature will be displayed.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowFeatureDetailsExpanded
     * @param feature A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature} for which to show the feature details. If not specified, details for the last feature will be displayed.
     * @introduced 2.4
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "ShowFeatureDetailsExpanded"): TypedCommand<{
        (feature?: Feature): void;
    }>;
    /**
    * Deactivates the Maptip(except handheld) and Creates and displays the Feature Details dialog for the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature}
    * @docs-gcx-command geocortex.essentialsHtmlViewer
    * @name ShowFeatureDetailsFromMaptip
    * @param arg A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature}
    * @introduced 2.8
    * @gcx-command-category Feature
    */
    (commandName: "ShowFeatureDetailsFromMaptip"): TypedCommand<{
        (arg: Feature): void;
    }>;
    /**
     * Creates and displays the Feature Details dialog for the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature} in the specified view mode. If the feature is not specified, details for the last feature will be displayed.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SetFeatureDetailsMode
     * @param args A string specifying the view mode, or a configuration object with two properties: `viewMode` and `feature`. If the feature is not specified, details for the last feature will be displayed.
     * @introduced 2.4
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "SetFeatureDetailsMode"): TypedCommand<{
        (args: string | {
            viewMode: string;
            feature?: Feature;
        }): void;
    }>;
    /**
     * Creates a ModalMessageView view and displays the given message.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowFeatureLayerModalMessage
     * @param message The message to be displayed in the ModalMessageView view.
     * @private
     */
    (commandName: "ShowFeatureLayerModalMessage"): TypedCommand<{
        (message: string): void;
    }>;
    /**
     * Shows the feature template picker used to create new features. If a layer is supplied, shows the templates for the layer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowFeatureTemplatePicker
     * @introduced 1.2
     * @param layer A feature layer for which to display templates.
     * @param relatedFeature An Esri feature with the information needed to create a related feature.
     * @gcx-command-category Editing
     */
    (commandName: "ShowFeatureTemplatePicker"): TypedCommand<{
        (layer?: Layer, relatedFeature?: esri.Graphic): void;
    }>;
    /**
     * Shows the previously opened feature when browsing related features in the feature details view.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowFeatureParentDetails
     * @introduced 2.3
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "ShowFeatureParentDetails"): TypedCommand<{
        (): void;
    }>;
    /**
     * Displays the Geolocate Menu if at least one Geolocate option is enabled.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowBookmarks
     * @introduced 2.3
     * @gcx-command-category Geolocation
     */
    (commandName: "ShowGeolocateMenu"): TypedCommand<{
        (): void;
    }>;
    /**
     * Activates the Home Panel if it is configured to be included.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowHomePanel
     * @introduced 2.0
     * @gcx-command-category Region and View
     */
    (commandName: "ShowHomePanel"): TypedCommand<{
        (): void;
    }>;
    /**
     * Activates the external component view.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowExternalComponentView
     * @introduced 2.4
     * @gcx-command-category Integration
     */
    (commandName: "ShowExternalComponentView"): TypedCommand<{
        (): void;
    }>;
    /**
     * Shows available actions for a given layer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowLayerActions
     * @param layer The Geocortex layer to show layer actions for.
     * @introduced 1.3
     * @gcx-workflow-disabled
     * @gcx-command-category Layer
     */
    (commandName: "ShowLayerActions"): TypedCommand<{
        (layer: Layer): void;
    }>;
    /**
     * Displays the layer list.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowLayerList
     * @introduced 1.1
     * @deprecated 2.3 Using `ActivateView` and pass the ID `LayerListView`.
     * @gcx-command-category Layer List
     */
    (commandName: "ShowLayerList"): TypedCommand<{
        (): void;
    }>;
    /**
     * Shows available actions for a given map service.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowMapServiceActions
     * @param mapService The Geocortex map service to show actions for.
     * @introduced 2.7
     * @gcx-workflow-disabled
     * @gcx-command-category Layer List
     */
    (commandName: "ShowMapServiceActions"): TypedCommand<{
        (mapService: MapService): void;
    }>;
    /**
     * Displays previously hidden map tips by setting their visibility to `true`, and resumes displaying map tips.  Map tips must be enabled for this command to work.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowMapTips
     * @introduced 2.3.1
     * @gcx-command-category Map Widget
     */
    (commandName: "ShowMapTips"): TypedCommand<{
        (): void;
    }>;
    /**
     * Displays a dialog to save a {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} as a named selection.
     * If name is specified, the dialog will pre-populate the name input field.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowSaveSelectionDialog
     * @param fscOrId The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} or its ID, to save.
     * @param name (Optional) The name of the selection.
     * @introduced 2.6
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "ShowSaveSelectionDialog"): TypedCommand<{
        (fscOrId: FeatureSetCollection | string, name?: string): void;
    }>;
    /**
     * Show the offline map editor.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowOfflineMapEditor
     * @param args Arguments to showing the offline map editor.
     * @gcx-command-category Offline Profiles
     */
    (commandName: "ShowOfflineMapEditor"): TypedCommand<{
        (args: ShowOfflineMapEditorArgs): void;
    }>;
    /**
     * Opens the Social Media sharing view.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowShareView
     * @introduced 2.4
     * @gcx-command-category Share
     */
    (commandName: "ShowShareView"): TypedCommand<{
        (): void;
    }>;
    /**
     * Displays the layer list.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SwitchToLayerView
     * @introduced 2.3
     * @gcx-command-category Layer List
     */
    (commandName: "SwitchToLayerView"): TypedCommand<{
        (): void;
    }>;
    /**
     * Displays the legend view.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SwitchToLegendView
     * @introduced 2.3
     * @gcx-command-category Layer List
     */
    (commandName: "SwitchToLegendView"): TypedCommand<{
        (): void;
    }>;
    /**
     * Shows the log view if the parameter is `true`.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowLog
     * @param show To show the log, set to `true`; otherwise set to `false`.  The default is `false`.
     * @introduced 2.0
     * @gcx-command-category Log
     */
    (commandName: "ShowLog"): TypedCommand<{
        (show?: boolean): void;
    }>;
    /**
     * Activates the map view, ensuring that it is active and visible.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowMap
     * @introduced 1.1
     * @gcx-command-category Map Display
     */
    (commandName: "ShowMap"): TypedCommand<{
        (): void;
    }>;
    /**
     * Displays a map tip callout anchored to a given point.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowMapCallout
     * @param parameter An instance of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.ShowMapElementArgs} with the following properties: `elementID`, `mapPoint`, `content`, `title`, `delay`.
     * @introduced 1.0
     * @gcx-workflow-disabled
     * @gcx-command-category Map Widget
     */
    (commandName: "ShowMapCallout"): TypedCommand<{
        (args: ShowMapElementArgs): void;
    }>;
    /**
     * Displays an element anchored to a specific point on the map.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowMapElement
     * @param args An instance of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.ShowMapElementArgs} with the following properties: `elementID`, `mapPoint`, `content`, `title`, `delay`.
     * @introduced 1.0
     * @gcx-workflow-disabled
     * @gcx-command-category Map Widget
     */
    (commandName: "ShowMapElement"): TypedCommand<{
        (args: ShowMapElementArgs): void;
    }>;
    /**
     * Displays a feature in the map tip view.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowMapTip
     * @param feature The Geocortex feature to show the Map Tip for.
     * @introduced 1.1
     * @gcx-workflow-disabled
     * @gcx-command-category Map Widget
     */
    (commandName: "ShowMapTip"): TypedCommand<{
        (feature: Feature): void;
    }>;
    /**
     * Displays a feature in a map tip callout anchored to the map
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowMapTipInCallout
     * @param feature The Geocortex feature to show the Map Tip for.
     * @introduced 2.4
     * @gcx-workflow-disabled
     * @gcx-command-category Map Widget
     */
    (commandName: "ShowMapTipInCallout"): TypedCommand<{
        (feature: Feature): void;
    }>;
    /**
     * Shows map tip results for a {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} previously added to the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetManager}.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowMapTipResults
     * @param fscId The ID of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} to display.
     * @introduced 1.0
     * @gcx-command-category Map Widget
     */
    (commandName: "ShowMapTipResults"): TypedCommand<{
        (fscId: string): void;
    }>;
    /**
     * Shows map tip results for a {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} previously added to the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetManager},
     * in a floating callout window on the map.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowMapTipResultsInCallout
     * @param fscId The ID of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} to display.
     * @introduced 2.4
     * @gcx-command-category Map Widget
     */
    (commandName: "ShowMapTipResultsInCallout"): TypedCommand<{
        (fscId: string): void;
    }>;
    /**
     * Displays markers by setting their visibility to `true`.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowMarkers
     * @introduced 2.5
     * @private
     */
    (commandName: "ShowMarkers"): TypedCommand<{
        (): void;
    }>;
    /**
     * Displays pushpins by setting their visibility to `true`, for each result in the results list or results table.  Pushpins must be enabled for this command to work.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowPushpins
     * @introduced 2.1
     * @gcx-command-category Pushpins
     */
    (commandName: "ShowPushpins"): TypedCommand<{
        (): void;
    }>;
    /**
     * Cancels any feature placement while a feature is being created or edited.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name StopFeaturePlacementState
     * @introduced 2.5
     * @gcx-command-category Feature Editing
     */
    (commandName: "StopFeaturePlacementState"): TypedCommand<{
        (): void;
    }>;
    /**
     * Presents a user interface for choosing to run a report from a list of reports that are available to the given reportable input (group of features).
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ListReports
     * @param reportable: A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature}, {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSet}, {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection}, or a {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature} array.
     * @introduced 2.5
     * @gcx-command-category Reporting
     */
    (commandName: "ListReports"): TypedCommand<{
        (reportable: FeatureSetCollection | FeatureSet | Feature | Feature[]): void;
    }>;
    /**
     * Alias to the command `ListReports` for backwards-compatibility with the Silverlight viewer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RunFeatureReport
     * @param feature: A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature} object.
     * @introduced 2.5
     * @gcx-command-category Reporting
     */
    (commandName: "RunFeatureReport"): TypedCommand<{
        (feature: Feature): void;
    }>;
    /**
     * Alias to the command `ListReports` for backwards-compatibility with the Silverlight viewer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RunFeaturesReport
     * @param feature: A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSet} object.
     * @introduced 2.5
     * @gcx-command-category Reporting
     */
    (commandName: "RunFeaturesReport"): TypedCommand<{
        (featureSet: FeatureSet): void;
    }>;
    /**
     * Runs a given report on the provided features, and displays the result (a download link to the report file) to the user.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name RunReport
     * @param args: A {@link RunReportArgs} object with the following properties: `report`, `reportable` and `reportParameters` (optional).
     * `report` is the report to run.
     * `reportable` is the group of features upon which the report shall be run.
     * `reportParameters` are the report parameters passed along to the REST endpoint.
     * @introduced 2.5
     * @gcx-command-category Reporting
     */
    (commandName: "RunReport"): TypedCommand<{
        (args: RunReportArgs): void;
    }>;
    /**
     * Displays the user interface to fill in details about a project to be saved.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SaveAsProject
     * @introduced 2.6
     * @gcx-command-category Projects
     */
    (commandName: "SaveAsProject"): TypedCommand<{
        (): void;
    }>;
    /**
     * Save the current state of the viewer as a project or displays the user interface to fill in details about the project to be saved.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SaveProject
     * @introduced 2.6
     * @gcx-command-category Projects
     */
    (commandName: "SaveProject"): TypedCommand<{
        (): void;
    }>;
    /**
     * Shows the user interface for editing a project.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowProjectEditor
     * @param project The unique ID of the project to edit, or an instance of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.project.Project} containing the project to edit.
     * @introduced 2.6
     * @gcx-command-category Projects
     */
    (commandName: "ShowProjectEditor"): TypedCommand<{
        (project: string | Project): void;
    }>;
    /**
     * Shows the user interface for browsing and loading projects.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowProjects
     * @introduced 2.6
     * @gcx-command-category Projects
     */
    (commandName: "ShowProjects"): TypedCommand<{
        (): void;
    }>;
    /**
     * Displays the list of features in the given {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} as a list.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowResultsList
     * @param fsc A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} or the ID of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection}.
     * @introduced 1.1
     * @gcx-hyperlink-disabled
     * @gcx-workflow-requirements In order to use this command in a workflow, you must use the ID of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} as the parameter.
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "ShowResultsList"): TypedCommand<{
        (fsc: any): void;
    }>;
    /**
     * Displays the list of features in the given {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} in a tabular view.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowResultsTable
     * @param fsc A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} or the ID of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection}.
     * @introduced 1.0
     * @gcx-hyperlink-disabled
     * @gcx-workflow-requirements In order to use this command in a workflow, you must use the ID of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} as the parameter.
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "ShowResultsTable"): TypedCommand<{
        (fsc: any): void;
    }>;
    /**
     * Switches from Results Table to Results List view if the Results Table view is currently active.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SwitchToListResultsView
     * @introduced 2.6
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "SwitchToListResultsView"): TypedCommand<{
        (): void;
    }>;
    /**
     * Switches from Results List to Results Table view if the Results List view is currently active.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SwitchToTabularResultsView
     * @introduced 2.6
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "SwitchToTabularResultsView"): TypedCommand<{
        (): void;
    }>;
    /**
     * Shows the user interface for sharing projects.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowShareProject
     * @param project The unique ID of the project to share, or an instance of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.project.Project} containing the project to share.
     * @introduced 2.6
     * @gcx-command-category Projects
     */
    (commandName: "ShowShareProject"): TypedCommand<{
        (project: string | Project): void;
    }>;
    /**
     * Shows the visualization options view for a given Geocortex layer if the layer supports any visualizations.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ShowVisualizationView
     * @param args Either the Geocortex layer or a string representing the Map Service's ID.
     * @introduced 2.5
     * @gcx-command-category Visualization
     */
    (commandName: "ShowVisualizationView"): TypedCommand<{
        (args: Layer | string): void;
    }>;
    /**
     * Navigates to the sign-in page.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SignIn
     * @param signInUrl An optional sign-in URL, otherwise the site default will be used.
     * @introduced 2.2
     * @gcx-command-category User
     */
    (commandName: "SignIn"): TypedCommand<{
        (signInUrl: string): void;
    }>;
    /**
     * Signs the current user out.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SignOut
     * @introduced 2.2
     * @gcx-command-category User
     */
    (commandName: "SignOut"): TypedCommand<{
        (): void;
    }>;
    /**
     * Begins an edit attributes and geometry editing operation on an existing feature.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name StartEditingAttributesAndGeometryFeature
     * @param feature The existing Geocortex Feature to be edited.
     * @param isNewFeature If the feature is new, set to `true`; otherwise, set to `false`.  The default is `false`.
     * @private
     */
    (commandName: "StartEditingAttributesAndGeometryFeature"): TypedCommand<{
        (feature: Feature, isNewFeature?: boolean): void;
    }>;
    /**
     * Creates a view to change and existing edit.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name StartEditingEditLogEntry
     * @param editLogEntry The edit to be changed.
     * @private
     */
    (commandName: "StartEditingEditLogEntry"): TypedCommand<{
        (editLogEntry: any): void;
    }>;
    /**
     * Begins an edit operation on an existing feature.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name StartEditingFeature
     * @param feature The existing Geocortex Feature to be edited.
     * @param isNewFeature If the feature is new, set to `true`; otherwise, set to `false`.  The default is `false`.
     * @private
     */
    (commandName: "StartEditingFeature"): TypedCommand<{
        (feature: Feature, isNewFeature?: boolean): void;
    }>;
    /**
     * Creates a view to edit a new feature.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name StartEditingNewFeature
     * @param feature A new instance of an esri.Graphic.
     * @param layer An editable feature layer from which the new feature is to belong to.
     * @param editGeometry Whether to immediately start editing the geometry, defaults to `true`.
     * @private
     */
    (commandName: "StartEditingNewFeature"): TypedCommand<{
        (feature: esri.Graphic, layer: esri.layers.FeatureLayer, editGeometry?: boolean): void;
    }>;
    /**
     * Starts syncing the feature data for a collection of offline maps, and displays the progress to the user.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name StartOfflineFeatureSync
     * @param args The arguments to the command.
     * @introduced 2.8
     * @gcx-hyperlink-disabled
     * @gcx-command-category Offline
     */
    (commandName: "StartOfflineFeatureSync"): TypedCommand<{
        (args: {
            offlineMaps: OfflineMap[];
        }): void;
    }>;
    /**
     * Starts downloading an offline map and displays the progress to the user.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name StartOfflineDownloadAndShowProgress
     * @param args The arguments to the command.
     * @introduced 2.6
     * @gcx-command-category Offline
     */
    (commandName: "StartOfflineDownloadAndShowProgress"): TypedCommand<{
        (args: {
            offlineMap: OfflineMap;
        }): void;
    }>;
    /**
     * Starts syncing an offline map and displays the progress to the user.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name StartOfflineSyncAndShowProgress
     * @param args The arguments to the command.
     * @introduced 2.6
     * @gcx-hyperlink-disabled
     * @gcx-command-category Offline
     */
    (commandName: "StartOfflineSyncAndShowProgress"): TypedCommand<{
        (args: {
            offlineMap: OfflineMap;
        }): void;
    }>;
    /**
     * Zooms in a step.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name StepZoomIn
     * @introduced 1.0
     * @gcx-command-category Navigation
     */
    (commandName: "StepZoomIn"): TypedCommand<{
        (): void;
    }>;
    /**
     * Zooms out a step.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name StepZoomOut
     * @introduced 1.0
     * @gcx-command-category Navigation
     */
    (commandName: "StepZoomOut"): TypedCommand<{
        (): void;
    }>;
    /**
     * Deactivates the Edit tool, if markup is being edited.  If nothing is being edited, the Edit tool remains active.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name StopEditingMarkup
     * @param clearActiveTool To clear the active tool, set to `true`; otherwise, set to `false`. The default is `false`.
     * @introduced 2.0
     * @gcx-command-category Markup
     */
    (commandName: "StopEditingMarkup"): TypedCommand<{
        (clearActiveTool?: boolean): void;
    }>;
    /**
     * Suspends the display of map tips, allowing other components the opportunity to interact with the map without invoking map tips on click/tap events.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SuspendMapTips
     * @introduced 2.0
     * @gcx-command-category Map Widget
     */
    (commandName: "SuspendMapTips"): TypedCommand<{
        (): void;
    }>;
    /**
     * Switches to the specified layer theme.
     * It activates the theme and updates the map based on the theme settings in the site.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SwitchToLayerTheme
     * @param themeIdentifier The ID or the display name of the layer theme.
     * @introduced 2.3
     * @gcx-command-category Layer Theme
     */
    (commandName: "SwitchToLayerTheme"): TypedCommand<{
        (themeIdentifier: String): void;
    }>;
    /**
     * Puts the application in an offline state, if the application supports offline capabilities.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name TakeApplicationOffline
     * @introduced 1.1
     * @gcx-hyperlink-disabled
     * @gcx-command-category Offline
     */
    (commandName: "TakeApplicationOffline"): TypedCommand<{
        (): void;
    }>;
    /**
     * Dismisses the specified view on the next tap anywhere on the screen. Optionally fires specified callbacks.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name TapToDismiss
     * @param args An object with the following properties: `view`, `onOtherInteracted` (optional) and `onElementInteracted` (optional).
     * `view` represents the view to be dismissed.
     * `onOtherInteracted` represents the callback to fire if an external element is clicked.
     * `onElementInteracted` represents the callback to fire if the same element is clicked.
     * @introduced 2.4
     * @gcx-hyperlink-disabled
     * @gcx-command-category Map Widget
     */
    (commandName: "TapToDismiss"): TypedCommand<{
        (args: {
            view: ViewBase;
            onOtherInteracted?: (evt?: Event) => void;
            onElementInteracted?: (evt?: Event) => void;
        }): void;
    }>;
    /**
     * Transitions the application from an offline state to an online state.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name TakeApplicationOnline
     * @introduced 1.1
     * @gcx-hyperlink-disabled
     * @gcx-command-category Offline
     */
    (commandName: "TakeApplicationOnline"): TypedCommand<{
        (): void;
    }>;
    /**
     * Activates or deactivates the data frame.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ToggleDataFrame
     * @introduced 1.0
     * @gcx-command-category Region and View
     */
    (commandName: "ToggleDataFrame"): TypedCommand<{
        (): void;
    }>;
    /**
     * Toggle Dynamic Labels
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ToggleDynamicLabels
     * @param layer The layer that will have its labels turned on or off.
     * @introduced 2.7
     * @gcx-command-category Label Options
    */
    (commandName: "ToggleDynamicLabels"): TypedCommand<{
        (layer: Layer): void;
    }>;
    /**
     * Activates or deactivates the log view, based on whether or not it is currently active.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ToggleLogView
     * @introduced 1.0
     * @gcx-command-category Region and View
     */
    (commandName: "ToggleLogView"): TypedCommand<{
        (): void;
    }>;
    /**
     * Activates or deactivates the mouse coordinates widget, based on whether or not it is currently active.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ToggleMouseCoordinates
     * @introduced 2.4
     * @gcx-command-category Region and View
     */
    (commandName: "ToggleMouseCoordinates"): TypedCommand<{
        (): void;
    }>;
    /**
     * Activates or deactivates the results frame.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ToggleResultsFrame
     * @introduced 1.1
     * @gcx-command-category Region and View
     */
    (commandName: "ToggleResultsFrame"): TypedCommand<{
        (): void;
    }>;
    /**
     * Toggle whether the specified external component is synchronized with the viewer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ToggleExternalComponentSyncById
     * @param ecId The ID of the external component which will toggle whether it is synchronized with the viewer.
     * @introduced 2.4
     * @gcx-command-category Integration
     */
    (commandName: "ToggleExternalComponentSyncById"): TypedCommand<{
        (ecId: string): void;
    }>;
    /**
     * Toggles the visibility of the toolbar, if present.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ToggleToolbar
     * @introduced 1.3
     * @gcx-command-category Region and View
     */
    (commandName: "ToggleToolbar"): TypedCommand<{
        (): void;
    }>;
    /**
     * Opens the toolbar, if present.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name OpenToolbar
     * @introduced 2.5
     * @gcx-command-category Region and View
     */
    (commandName: "OpenToolbar"): TypedCommand<{
        (): void;
    }>;
    /**
     * Closes the toolbar, if present.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name CloseToolbar
     * @introduced 2.5
     * @gcx-command-category Region and View
     */
    (commandName: "CloseToolbar"): TypedCommand<{
        (): void;
    }>;
    /**
     * Opens the toolbar, if present. If already open, puts the toolbar in focus.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name OpenAndFocusToolbar
     * @introduced 2.9
     * @gcx-command-category Region and View
     */
    (commandName: "OpenAndFocusToolbar"): TypedCommand<{
        (): void;
    }>;
    /**
     * Activates a tab by its ID or name.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name SetCurrentTab
     * @param tabId The ID or name of the tab to activate.
     * @introduced 2.8
     * @gcx-command-category Region and View
     */
    (commandName: "SetCurrentTab"): TypedCommand<{
        (tabId: string): void;
    }>;
    /**
     * Invokes the last recorded undo operation or transaction.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name Undo
     * @introduced 2.5
     * @gcx-command-category Undo and Redo
     */
    (commandName: "Undo"): TypedCommand<{
        (): void;
    }>;
    /**
     * Merge graphics into a single graphic. The merged graphic will use the attributes of the first graphic, but can be
     * updated in the `successCallback`. These edits are only applied to the graphics layer in memory.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name UnionGraphicsInMemory
     * @param args An instance of {@link EditInMemoryArgs} describing the graphics to edit.
     * @introduced 2.5
     * @private
     */
    (commandName: "UnionGraphicsInMemory"): TypedCommand<{
        (args: EditInMemoryArgs): void;
    }>;
    /**
     * Updates a feature attachment.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name UpdateAttachment
     * @param arg An object with the following members: `mapService`, `layer`, `feature`, `featureUrl`, `filename`, `contentType`, `payload`, `successCallback`, `errorCallback`.
     * @private
     */
    (commandName: "UpdateAttachment"): TypedCommand<{
        (arg: {
            mapService: MapService;
            layer: esri.layers.FeatureLayer;
            feature: esri.Graphic;
            featureUrl: string;
            filename: string;
            contentType: string;
            payload;
            string;
            successCallback: () => void;
            errorCallback: (error: Error) => void;
        }): void;
    }>;
    /**
     * Updates (edits) an existing feature. If the application is offline, an update entry is added to the edit log.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name UpdateFeature
     * @param arg An object with the following members: `mapService`, `feature`, `successCallback` (optional), `errorCallback` (optional).
     * @introduced 1.1
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "UpdateFeature"): TypedCommand<{
        (arg: EditFeatureArgs): void;
    }>;
    /**
     * Updates existing graphics. These edits are only applied to the graphics layer in memory.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name UpdateGraphicsInMemory
     * @param args An instance of {@link UpdateGraphicsArgs} describing the graphics to update.
     * @introduced 2.5
     * @private
     */
    (commandName: "UpdateGraphicsInMemory"): TypedCommand<{
        (args: UpdateGraphicsArgs): void;
    }>;
    /**
     * Updates a related table record.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name UpdateRelatedRecord
     * @param arg An object with the following members: `mapService`, `layer`, `feature`, `relatedFeature`, `relationshipOrigin`, `relationshipDestination`, `successCallback`, `errorCallback`.
     * @introduced 1.1
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "UpdateRelatedRecord"): TypedCommand<{
        (arg: EditRelatedRecordArgs): void;
    }>;
    /**
     * Update the visible ModalMessageView to also include the given message.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name UpdateFeatureLayerModalMessage
     * @param message The new message to be displayed in the ModalMessageView view.
     * @param type A string constant indicating type.
     * @private
     */
    (commandName: "UpdateFeatureLayerModalMessage"): TypedCommand<{
        (message: string, tyype?: string): void;
    }>;
    /**
     * Updates the marker with the given marker arguments.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name UpdateMarker
     * @param args An instance of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.MarkerArgs}.
     * @introduced 2.5
     * @private
     */
    (commandName: "UpdateMarker"): TypedCommand<{
        (args: MarkerArgs): void;
    }>;
    /**
     * Updates an existing named, saved selection with the supplied {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection}.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name UpdateSelection
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.SelectionArgs} object with the following members: `name`, `featureSetCollection` (optional), `successCallback` (optional), `errorCallback` (optional).
     * @introduced 2.6
     * @gcx-command-category Feature and Feature Set
     */
    (commandName: "UpdateSelection"): TypedCommand<{
        (args: SelectionArgs): void;
    }>;
    /**
     * Updates the message shown on the status indicator.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name UpdateStatus
     * @param statusArgs An instance of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.AddStatusArgs}, or a string.
     * @introduced 2.4
     * @gcx-workflow-requirements Note: In order to use this command in a workflow, you must pass the `statusArgs` parameter as a string.
     * @gcx-command-category Map Widget
     */
    (commandName: "UpdateStatus"): TypedCommand<{
        (statusArgs: AddStatusArgs): void;
        (statusArgs: string): void;
    }>;
    /**
     * Prompt the user to upload layers onto the map straight from their own computer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name UploadData
     * @param process Optional `UploadDataProcess` object which can be used to skip dialogs or resume an in-progress upload data process.
     * @introduced 2.6
     * @gcx-command-category Upload Data
     */
    (commandName: "UploadData"): TypedCommand<{
        (process?: any): void;
    }>;
    /**
     * Verify that no active room has the provided name.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name VerifyRoomNameUnique
     * @param name The name to be verified.
     * @param callbackfn A callback to be executed on completion.
     * @introduced 2.8
     * @private
     */
    (commandName: "VerifyRoomNameUnique"): TypedCommand<{
        (name: string, callbackfn?: (args: {
            roomName: string;
            unique: boolean;
        }) => {}): void;
    }>;
    /**
     * Executes a command on the collaboration WebSocket.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name WebSocketCommand
     * @param commandName The name of the websocket command to be executed
     * @param parameters The parameters of the command to be executed
     * @introduced 2.8
     * @private
     */
    (commandName: "WebSocketCommand"): TypedCommand<{
        (commandName: string, ...parameters: any[]): void;
    }>;
    /**
     * Zooms out to the given extent.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ZoomOutToExtent
     * @introduced 1.1
     * @param extent The extent to zoom out to.
     * @gcx-command-category Navigation
     */
    (commandName: "ZoomOutToExtent"): TypedCommand<{
        (extent: esri.geometry.Extent): void;
    }>;
    /**
     * Zooms to the extent of all the features.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ZoomToAllFeatures
     * @param features An array containing the features to which to zoom.
     * @introduced 1.1
     * @gcx-workflow-disabled
     * @gcx-command-category Navigation
     */
    (commandName: "ZoomToAllFeatures"): TypedCommand<{
        (features: Feature[]): void;
    }>;
    /**
     * Zooms to the extent of all the features in the feature set.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ZoomToEsriFeatureSet
     * @param featureSet The featureSet to zoom to.
     * @introduced 1.0
     * @deprecated 1.1 Use `ZoomToFeatures` instead, passing a Geocortex `FeatureSet` object.
     * @gcx-command-category Navigation
     */
    (commandName: "ZoomToEsriFeatureSet"): TypedCommand<{
        (featureSet: esri.tasks.FeatureSet): void;
    }>;
    /**
     * Zooms to the given extent.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ZoomToExtent
     * @param extent The extent to zoom to.
     * @introduced 1.0
     * @gcx-command-category Navigation
     */
    (commandName: "ZoomToExtent"): TypedCommand<{
        (extent: esri.geometry.Extent): void;
    }>;
    /**
     * Zooms to a feature.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ZoomToFeature
     * @param feature The Geocortex feature for which to zoom to.
     * @introduced 1.0
     * @gcx-workflow-disabled
     * @gcx-command-category Navigation
     */
    (commandName: "ZoomToFeature"): TypedCommand<{
        (feature: Feature): void;
    }>;
    /**
     * Zooms to a feature if the it's outside of the map's extent, otherwise nothing happens.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ZoomToFeatureIfOutsideMapExtent
     * @param feature The Geocortex feature for which to zoom to.
     * @introduced 2.4
     * @gcx-workflow-disabled
     * @gcx-command-category Navigation
     */
    (commandName: "ZoomToFeatureIfOutsideMapExtent"): TypedCommand<{
        (feature: Feature): void;
    }>;
    /**
     * Zooms to the extent of all the features in the feature set.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ZoomToFeatures
     * @param featureSet The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSet} to which to zoom.
     * @introduced 1.1
     * @gcx-workflow-disabled
     * @gcx-command-category Navigation
     */
    (commandName: "ZoomToFeatures"): TypedCommand<{
        (featureSet: FeatureSet): void;
    }>;
    /**
     * Zooms to the extent of all the features in the given Feature Set Collection.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ZoomToFeatureSetCollection
     * @param featureSetCollection The  FeatureSetCollection to zoom to.
     * @introduced 2.8
     * @gcx-workflow-disabled
     * @gcx-command-category Navigation
     */
    (commandName: "ZoomToFeatureSetCollection"): TypedCommand<{
        (featureSetCollection: FeatureSetCollection): void;
    }>;
    /**
     * Zooms to the full extent of the current Site.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ZoomToFullExtent
     * @introduced 1.3
     * @gcx-command-category Navigation
     */
    (commandName: "ZoomToFullExtent"): TypedCommand<{
        (): void;
    }>;
    /**
     * Zooms to the initial extent of the current Site.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ZoomToInitialExtent
     * @introduced 1.0
     * @gcx-command-category Navigation
     */
    (commandName: "ZoomToInitialExtent"): TypedCommand<{
        (): void;
    }>;
    /**
     * Zooms to the previous recorded map extent (if any)
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ZoomToPreviousExtent
     * @introduced 2.3
     * @gcx-command-category Navigation
     */
    (commandName: "ZoomToPreviousExtent"): TypedCommand<{
        (): void;
    }>;
    /**
     * Zooms to the bookmarked extent with the specified name.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ZoomToNamedExtent
     * @param bookmarkName The name of the bookmarked extent to which to zoom.
     * @introduced 2.4
     * @gcx-command-category Navigation
     */
    (commandName: "ZoomToNamedExtent"): TypedCommand<{
        (bookmarkName: string): void;
    }>;
    /**
     * Zooms to the next recorded map extent (if any).
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ZoomToNextExtent
     * @introduced 2.3
     * @gcx-command-category Navigation
     */
    (commandName: "ZoomToNextExtent"): TypedCommand<{
        (): void;
    }>;
    /**
     * Zooms to the current offline map's extent. If there is no current offline map, then nothing happens.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ZoomToOfflineMapExtent
     * @introduced 2.6
     * @gcx-command-category Navigation
     */
    (commandName: "ZoomToOfflineMapExtent"): TypedCommand<{
        (): void;
    }>;
    /**
     * Zooms to the extent of all the features in a layer.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ZoomToLayerExtent
     * @param layer The Geocortex layer whose extent to zoom to.
     * @introduced 1.3
     * @gcx-workflow-disabled
     * @gcx-command-category Navigation
     */
    (commandName: "ZoomToLayerExtent"): TypedCommand<{
        (layer: Layer): void;
    }>;
    /**
     * Zooms to the scale at which features in a layer become visible.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ZoomToLayerVisibleScale
     * @param layer The Geocortex layer whose visibility scale to zoom to.
     * @introduced 1.3
     * @gcx-workflow-disabled
     * @gcx-command-category Navigation
     */
    (commandName: "ZoomToLayerVisibleScale"): TypedCommand<{
        (layer: Layer): void;
    }>;
    /**
     * Zooms to the given scale.
     * @docs-gcx-command geocortex.essentialsHtmlViewer
     * @name ZoomToScale
     * @param scale The denominator of the scale to zoom to.  The viewer rounds the denominator to the nearest integer, if necessary.
     * @introduced 1.3
     * @gcx-command-category Navigation
     */
    (commandName: "ZoomToScale"): TypedCommand<{
        (scale: number): void;
    }>;
}

}
declare module "geocortex/infrastructure/CommandViewModel" {
import { ViewModelBase } from "geocortex/framework/ui/ViewModelBase";
import { Observable } from "geocortex/framework/observables";
import { TypedCommand } from "geocortex/framework/commands/TypedCommand";
import { Application } from "geocortex/framework/application/Application";
/**
 * Note: This is for single argument commands only. Multiple argument commands should be phased out and avoided.
 * @docs-hide-from-nav
 * @private
 */
export class CommandViewModel extends ViewModelBase {
    /** Name of the command. */
    commandName: string;
    /** The command parameter, as configured. */
    commandParameter: any;
    /** Indicates whether the command can currently execute or not. */
    canExecute: Observable<boolean>;
    notExecuteHidden: Observable<boolean>;
    protected _canExecuteChangedBindingToken: string;
    protected _command: TypedCommand<any>;
    /**
     * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.command.CommandViewModel} class.
     * @class
     * <p> CommandViewModel presents the generic commands along with its attributes such as command parameters.</p>
     * @constructs
     * @param app The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this command belongs to.
     * @param libraryId The ID of the library this component belongs to.
     * @param commandName The name of the command
     * @param commandParameter The parameter associated with this command.
     */
    constructor(app: Application, libraryId: string, commandName: string, commandParameter: string);
    /**
     * Applies a new contextual parameter to this command.
     * @param context
     */
    applyContext(context: any): void;
    /**
     * @private
     * Binds to a command by name.
     */
    private _bindToCommand(commandName, commandParameter?);
    /**
     * @private
     * Handles a "CanExecuteChanged" event for non batch commands.
     */
    private _handleCanExecuteChanged();
}

}
declare module "geocortex/infrastructure/ContentPolicy" {
import { UriDetails, NavigableLinkUriDetails } from "geocortex/infrastructure/FilterUtils";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { SiteUrlValidator } from "geocortex/infrastructure/validation/SiteUrlValidator";
import { ValidationResult } from "geocortex/infrastructure/validation/Validator";
export const enum PolicyFlags {
    DisableSecurityPrompt = 1,
    DisablePromptOnImages = 2,
    TrustExactUrl = 4,
}
/**
 * Content Policy Facility screens URIs to ensure their safety.
 */
export class ContentPolicy {
    protected _app: ViewerApplication;
    protected _siteValidator: SiteUrlValidator;
    protected _debounceHandle: number;
    protected _debounceInterval: number;
    protected _flags: number;
    constructor(app: ViewerApplication);
    hasFlag(flag: PolicyFlags): boolean;
    setFlag(flag: PolicyFlags): void;
    /**
     * Screen a collection of URI details.
     */
    screenUris(uris: UriDetails[]): Promise<UriDetails[]>;
    tryScreenNavLinkSynchronously(uri: NavigableLinkUriDetails): boolean;
    protected _validateUris(uris: UriDetails[]): Promise<UriDetails[]>;
    protected _validateUriAgainstSite(uri: UriDetails): Promise<ValidationResult<string>>;
    protected _promptForUris(uris: UriDetails[]): Promise<UriDetails[]>;
    private _enqueueConfirmation(uriConfirmation);
    private _processConfirmationQueue();
    private _getConfirmation(uriConfirmation);
    protected _getMemoizationKey(uri: UriDetails): string;
    protected _memoizeResult(uri: UriDetails, result: boolean): void;
    protected _getMemoizedResult(uri: UriDetails): boolean;
    /**
     * Screen a data URI.
     */
    protected _screenDataUri(uri: string): string;
}

}
declare module "geocortex/infrastructure/DataLinkingResult" {
import { AttributeGroup } from "geocortex/infrastructure/AttributeGroup";
import { Observable } from "geocortex/framework/observables";
import { DataLink } from "geocortex/essentials/DataLink";
export class DataLinkingResult {
    /** @private This is used for lazy loading of an attributes group. */
    private _attributeGroup;
    /**
     * This references the original datalink that was used to create this object
     * @type DataLink
     */
    dataLink: Observable<DataLink>;
    /**
     * This is the raw data from a datalinking request. This contains columns and rows.
     * @type Object
     */
    table: Observable<any>;
    /**
     * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.DataLinkingResult} class.
     */
    constructor();
    /**
     * Converts the table of the datalink to a basic attribute map.
     */
    toAttributes(): any;
    /**
     * Returns a copy of this datalink in an attribute group form.
     */
    asAttributeGroup(): AttributeGroup;
}

}
declare module "geocortex/infrastructure/DateFormat" {
/**
 * Pre-defined format specifiers for use with formatDate().
 */
export class DateFormat {
    /**
     * A localized representation of a date (e.g. "09/04/1986" for en-US locale).
     */
    static DATE_SHORT: string;
    /**
     * A localized long representation of a date (e.g. "September 4 1986" for en-US locale).
     */
    static DATE_LONG: string;
    /**
     * A localized short representation of the time (e.g. "8:30 PM" for en-US locale).
     */
    static TIME_SHORT: string;
    /**
     * A localized representation of the time including seconds (e.g. "8:30:25 PM" for en-US locale).
     */
    static TIME_LONG: string;
    /**
     * A localized representation of date and time (e.g. "Sep 4 1986 8:30 PM" for en-US locale).
     */
    static DATE_TIME_SHORT: string;
    /**
     * A localized long representation of date and time (e.g. "September 4 1986 8:30 PM" for en-US locale).
     */
    static DATE_TIME_LONG: string;
    /**
     * A localized full representation of date and time, including day of week (e.g. "Thursday, September 4 1986 8:30 PM" for en-US locale).
     */
    static FULL: string;
    /**
     * The date and time in ISO-8601 format (e.g. "2014-09-08T08:02:17-05:00"). Invariant.
     */
    static ISO_8601: string;
    /**
     * An invariant representation of a date. Guarantees that the date can be parsed back into the same date, regardless of locale.
     * Equivalent to ISO-8601.
     */
    static ROUND_TRIP: string;
    /**
     * The default representation for date values (equivalent to DATE_TIME_SHORT).
     */
    static DEFAULT: string;
    /**
     * The default set of formats used for parsing date values.
     */
    static DEFAULT_PARSING_FORMATS: string[];
}

}
declare module "geocortex/infrastructure/DatumTransformParameters" {
/**
 * Describes an object that represents the projection parameters related to applying a datum transform.
 */
export interface DatumTransformParameters {
    /** The spatial reference for the datum transform to be applied on the projection geometry parameters. */
    transformation: esri.SpatialReference;
    /** Whether or not to transform forward. The direction of transformation is determined by the direction of the to/from spatial references for the transformation. */
    transformForward: boolean;
}

}
declare module "geocortex/infrastructure/DatumTransformRegistryItem" {
/**
 * Describes an object that represents which spatial references require a specific datum transform.
 */
export interface DatumTransformRegistryItem {
    /** The spatial reference that the geometries are being projected from. */
    fromSR: esri.SpatialReference;
    /** The spatial reference that the geometries are being projected to. */
    toSR: esri.SpatialReference;
    /** The datum transform to apply when projecting. */
    transformation: esri.SpatialReference;
}

}
declare module "geocortex/infrastructure/Dictionary" {
export class Dictionary<TValue> {
    private _backingStore;
    /**
    An implementation of a dictionary. This is really similar to a plain old object
    in JavaScript except that it's typed for TypeScript.
    @class
     */
    constructor();
    containsKey(key: string): boolean;
    get(key: string): TValue;
    set(key: string, value: TValue): void;
    remove(key: string): boolean;
    clear(): void;
    values(): TValue[];
    keys(): string[];
}
export function toDictionary<TSource, TResult>(items: TSource[], keySelector: (object: TSource) => string, valueSelector: (object: TSource) => TResult): Dictionary<TResult>;

}
declare module "geocortex/infrastructure/DistanceConverter" {
/**
* Returns true if units are convertible.
* @param targetUnit The type of unit we want to convert to
* @param sourceUnit The type of unit we are converting from
*/
export function canConvert(targetUnit: string, sourceUnit: string): boolean;
/**
 * Converts an unit to another
 * @param targetUnit The type of unit we want to convert to
 * @param distance Distance in original unit type
 * @param sourceUnit The type of unit we are converting from
 */
export function convert(targetUnit: string, distance: number, sourceUnit: string): number;

}
declare module "geocortex/infrastructure/events" {
import { EventsBase } from "geocortex/framework/events";
import { TypedEvent } from "geocortex/framework/events/TypedEvent";
import { AccessibleMapComponent } from "geocortex/infrastructure/accessibility/AccessibleMapComponent";
import { ActiveToolChangedEventArgs } from "geocortex/infrastructure/eventArgs/ActiveToolChangedEventArgs";
import { IdentifiableLayerInfo } from "geocortex/infrastructure/identify/IdentifiableLayerInfo";
import { AuthenticationEventArgs } from "geocortex/infrastructure/eventArgs/AuthenticationEventArgs";
import { BufferDistanceChangedEventArgs } from "geocortex/infrastructure/buffer/BufferDistanceChangedEventArgs";
import { BufferOperationResult } from "geocortex/infrastructure/buffer/BufferOperationResult";
import { BufferOperationError } from "geocortex/infrastructure/buffer/BufferOperationError";
import { ComponentViewpointMessage } from "geocortex/infrastructure/integration/ComponentViewpointMessage";
import { PlotCoordinatesEventArgs } from "geocortex/infrastructure/eventArgs/PlotCoordinatesEventArgs";
import { PlotCoordinatesIdUpdatedEventArgs } from "geocortex/infrastructure/eventArgs/PlotCoordinatesIdUpdatedEventArgs";
import { FeatureSet } from "geocortex/infrastructure/FeatureSet";
import { EditVertexMovedEventArgs } from "geocortex/infrastructure/eventArgs/EditVertexMovedEventArgs";
import { ComponentInitializationMessage } from "geocortex/infrastructure/integration/ComponentInitializationMessage";
import { Feature } from "geocortex/infrastructure/Feature";
import { SyncParameters } from "geocortex/infrastructure/offline/SyncParameters";
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { LayerListFolderItem } from "geocortex/infrastructure/layerList/LayerListFolderItem";
import { FeatureSetManagerEventArgs } from "geocortex/infrastructure/eventArgs/FeatureSetManagerEventArgs";
import { GeolocationEventArgs } from "geocortex/infrastructure/eventArgs/GeolocationEventArgs";
import { GeometryEditCompletedEventArg } from "geocortex/infrastructure/eventArgs/GeometryEditCompletedEventArg";
import { GraphicDrawActivatedEventArgs } from "geocortex/infrastructure/eventArgs/GraphicDrawActivatedEventArgs";
import { GraphicDrawDeactivatedEventArgs } from "geocortex/infrastructure/eventArgs/GraphicDrawDeactivatedEventArgs";
import { GraphicEditActivatedEventArgs } from "geocortex/infrastructure/eventArgs/GraphicEditActivatedEventArgs";
import { GraphicEditDeactivatedEventArgs } from "geocortex/infrastructure/eventArgs/GraphicEditDeactivatedEventArgs";
import { GraphicVertexAddedEventArgs } from "geocortex/infrastructure/eventArgs/GraphicVertexAddedEventArgs";
import { GraphicVertexMovedEventArgs } from "geocortex/infrastructure/eventArgs/GraphicVertexMovedEventArgs";
import { Layer } from "geocortex/essentials/Layer";
import { MapService } from "geocortex/essentials/MapService";
import { LayerListLayerItem } from "geocortex/infrastructure/layerList/LayerListLayerItem";
import { LayerDescriptor } from "geocortex/infrastructure/identify/LayerDescriptor";
import { LayerDefinitionExpressionAppliedEventArgs } from "geocortex/infrastructure/eventArgs/LayerDefinitionExpressionAppliedEventArgs";
import { LayerList } from "geocortex/infrastructure/layerList/LayerList";
import { LayerThemeEventArgs } from "geocortex/essentials/LayerThemeEventArgs";
import { MapExtentEventArgs } from "geocortex/infrastructure/eventArgs/MapExtentEventArgs";
import { LayerListMapServiceItem } from "geocortex/infrastructure/layerList/LayerListMapServiceItem";
import { MapServiceLayersChangedEventArgs } from "geocortex/infrastructure/eventArgs/MapServiceLayersChangedEventArgs";
import { MarkerPointerEventArgs } from "geocortex/infrastructure/eventArgs/MarkerPointerEventArgs";
import { MarkerDragEventArgs } from "geocortex/infrastructure/eventArgs/MarkerDragEventArgs";
import { MenuView } from "geocortex/infrastructure/menus/MenuView";
import { MenuItemViewModel } from "geocortex/infrastructure/menus/MenuItemViewModel";
import { OfflineMapsLoadedEventArgs, OfflineMapAddedEventArgs, OfflineMapRemovedEventArgs, OfflineMapActivatedEventArgs, OfflineMapSyncedEventArgs, OfflineMapSyncErrorEventArgs } from "geocortex/infrastructure/eventArgs/OfflineMapEventArgs";
import { OfflineMapEditorFinishedEventArgs } from "geocortex/infrastructure/eventArgs/OfflineMapEditorFinishedEventArgs";
import { SelectionChangedEventArgs } from "geocortex/infrastructure/eventArgs/SelectionChangedEventArgs";
import { SelectionEventArgs } from "geocortex/infrastructure/eventArgs/SelectionEventArgs";
import { ResizeInformation } from "geocortex/infrastructure/ui/components/SmartPanel/SmartPanelView";
import { PrintTemplate } from "geocortex/essentials/PrintTemplate";
import { ProjectEditorFinishedEventArgs } from "geocortex/infrastructure/eventArgs/ProjectEditorFinishedEventArgs";
import { Project } from "geocortex/infrastructure/project/Project";
import { QueryCompletedEventArgs } from "geocortex/infrastructure/eventArgs/QueryCompletedEventArgs";
import { UndoRedoEventArgs } from "geocortex/infrastructure/eventArgs/UndoRedoEventArgs";
import { ReportResultEventArgs } from "geocortex/infrastructure/eventArgs/ReportResultEventArgs";
import { ResultsPageChangedEventArgs } from "geocortex/infrastructure/eventArgs/ResultsPageChangedEventArgs";
import { SearchProgressEventArgs } from "geocortex/infrastructure/eventArgs/SearchProgressEventArgs";
import { SearchHintItem } from "geocortex/infrastructure/search/SearchHintItem";
import { Site } from "geocortex/essentials/Site";
import { SnappingFeedbackEventArgs } from "geocortex/infrastructure/eventArgs/SnappingFeedbackEventArgs";
import { StateChangedEventArgs } from "geocortex/infrastructure/eventArgs/StateChangedEventArgs";
import { SyncInfoRefreshedEventArgs } from "geocortex/infrastructure/eventArgs/SyncInfoRefreshedEventArgs";
import { TimeSliderProfile } from "geocortex/essentials/TimeSliderProfile";
import { TimeSliderProfileChangingEventArgs } from "geocortex/infrastructure/eventArgs/TimeSliderProfileChangingEventArgs";
import { ToggleButtonStateChangedEventArgs } from "geocortex/infrastructure/eventArgs/ToggleButtonStateChangedEventArgs";
import { ToolbarButtonClickedEventArgs } from "geocortex/infrastructure/eventArgs/ToolbarButtonClickedEventArgs";
import { ToolInputMethodChangedEvent } from "geocortex/infrastructure/eventArgs/ToolInputMethodChangedEvent";
import { TransientActivatedEventArgs } from "geocortex/infrastructure/eventArgs/TransientActivatedEventArgs";
import { ToolbarTabChangedEventArgs } from "geocortex/infrastructure/eventArgs/ToolbarTabChangedEventArgs";
import { UserEventArgs } from "geocortex/infrastructure/eventArgs/UserEventArgs";
import { ViewContainerViewClosedEventArgs } from "geocortex/framework-ui/ViewContainer/ViewContainerViewClosedEventArgs";
import { MapViewpointMessage } from "geocortex/infrastructure/integration/MapViewpointMessage";
import { Workflow } from "geocortex/essentials/Workflow";
import { ActivityContext } from "geocortex/workflow/ActivityContext";
import { GraphicEditingDoneEventArgs } from "geocortex/infrastructure/eventArgs/GraphicEditingDoneEventArgs";
import { GraphicRemovedEventArgs } from "geocortex/infrastructure/eventArgs/GraphicRemovedEventArgs";
import { GeometryChangedEventArgs } from "geocortex/infrastructure/eventArgs/GeometryChangedEventArgs";
import { GraphicAttributesChangedEventArgs } from "geocortex/infrastructure/eventArgs/GraphicAttributesChangedEventArgs";
import { FilterControlEventArgs } from "geocortex/infrastructure/eventArgs/FilterControlEventArgs";
import { FilterControlQueryChangedEventArgs } from "geocortex/infrastructure/eventArgs/FilterControlQueryChangedEventArgs";
import { RestEvent } from "geocortex/infrastructure/collaboration/RestEvent";
import { RestRoom } from "geocortex/infrastructure/collaboration/RestRoom";
import { WebSocketConnection } from "geocortex/infrastructure/webSocket/WebSocketConnection";
export interface FrameworkEvents extends EventsBase {
    /**
     * Raised when the accessibility icon content has been initialized.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name AccessibilityIconContentInitializedEvent
     * @introduced 2.5
     * @gcx-event-category Accessibility
     */
    (eventName: "AccessibilityIconContentInitializedEvent"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised when a keyboard accessible component begins execution.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name AccessibleComponentStartedEvent
     * @param component The keyboard accessible component.
     * @introduced 2.4
     * @gcx-event-category Tool
     */
    (eventName: "AccessibleComponentStartedEvent"): TypedEvent<{
        (component: AccessibleMapComponent): void;
    }>;
    /**
     * Raised when a keyboard accessible component has ended execution.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name AccessibleComponentCompletedEvent
     * @param component The keyboard accessible component.
     * @introduced 2.4
     * @gcx-event-category Tool
     */
    (eventName: "AccessibleComponentCompletedEvent"): TypedEvent<{
        (component: AccessibleMapComponent): void;
    }>;
    /**
     * Raised before the active tool has been changed. This event gives subscribers an opportunity to cleanup their state before the new tool is activated.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ActiveToolChangingEvent
     * @param args An object containing the newly active tool (or null if no tool is active), and the previously active tool (or null if no tool was previously active).
     * @introduced 2.8
     * @gcx-event-category Tool
     * @private
     */
    (eventName: "ActiveToolChangingEvent"): TypedEvent<{
        (args: ActiveToolChangedEventArgs): void;
    }>;
    /**
     * Raised when the active tool has changed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ActiveToolChangedEvent
     * @param args An object containing the newly active tool (or null if no tool is active), and the previously active tool (or null if no tool was previously active).
     * @introduced 1.1
     * @gcx-event-category Tool
     */
    (eventName: "ActiveToolChangedEvent"): TypedEvent<{
        (args: ActiveToolChangedEventArgs): void;
    }>;
    /**
    * Raised when the all identifiable layers are enabled for identify operations.
    * @docs-gcx-event geocortex.essentialsHtmlViewer
    * @name AllLayersEnabledForIdentifyEvent
    * @param IdentifiableLayerInfos: An array of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.identify.IdentifiableLayerInfo} objects representing the current set of identifiable layers.
    * @introduced 2.5
    * @gcx-event-category Identify
    */
    (eventName: "AllLayersEnabledForIdentifyEvent"): TypedEvent<{
        (IdentifiableLayerInfos: IdentifiableLayerInfo[]): void;
    }>;
    /**
    * Raised when the all identifiable layers are disabled for identify operations.
    * @docs-gcx-event geocortex.essentialsHtmlViewer
    * @name AllLayersDisabledForIdentifyEvent
    * @param IdentifiableLayerInfos: An array of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.identify.IdentifiableLayerInfo} objects representing the current set of identifiable layers.
    * @introduced 2.5
    * @gcx-event-category Identify
    */
    (eventName: "AllLayersDisabledForIdentifyEvent"): TypedEvent<{
        (IdentifiableLayerInfos: IdentifiableLayerInfo[]): void;
    }>;
    /**
     * Raised when an application's storage space is cleared.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ApplicationStorageClearedEvent
     * @introduced 1.2
     * @gcx-event-category Offline
     */
    (eventName: "ApplicationStorageClearedEvent"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised when a user fails to authenticate against a {@link essentials.Site}.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name AuthenticationFailedEvent
     * @introduced 1.0
     * @gcx-event-category Authentication and Authorization
     */
    (eventName: "AuthenticationFailedEvent"): TypedEvent<{
        (args: AuthenticationEventArgs): void;
    }>;
    /**
     * Raised when a user successfully authenticates against a Site.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name AuthenticationSucceededEvent
     * @param args An object containing the following fields: result, username, token.
     * @introduced 1.0
     * @gcx-event-category Authentication and Authorization
     */
    (eventName: "AuthenticationSucceededEvent"): TypedEvent<{
        (args: AuthenticationEventArgs): void;
    }>;
    /**
     * Raised when a bookmark is added or removed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name BookmarksModifiedEvent
     * @param bookmarksJson A JSON string containing all the bookmarks currently in the local storage of the browser.
     * @introduced 2.0
     * @gcx-event-category Bookmark
     */
    (eventName: "BookmarksModifiedEvent"): TypedEvent<{
        (bookmarksJson: any): void;
    }>;
    /**
     * Raised when the Bottom Region is maximized.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name BottomRegionMaximizedEvent
     * @introduced 2.4
     * @gcx-event-category Interface
     */
    (eventName: "BottomRegionMaximizedEvent"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised when the Bottom Region is restored to its previous dimensions.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name BottomRegionRestoredEvent
     * @introduced 2.4
     * @gcx-event-category Interface
     */
    (eventName: "BottomRegionRestoredEvent"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised when a new Cluster Layer is added to the map.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ClusterLayerAddedEvent
     * @param clusterLayer The new ClusterLayer.
     * @introduced 2.5
     * @gcx-event-category Visualization
     */
    (eventName: "ClusterLayerAddedEvent"): TypedEvent<{
        (clusterLayer: any): void;
    }>;
    /**
     * Raised when a Cluster Layer is removed from the map.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ClusterLayerRemovedEvent
     * @param clusterLayer The ClusterLayer that has been removed from the map.
     * @introduced 2.5
     * @gcx-event-category Visualization
     */
    (eventName: "ClusterLayerRemovedEvent"): TypedEvent<{
        (clusterLayer: any): void;
    }>;
    /**
    * Raised when a plotted coordinate is temporarily hidden.
    * @docs-gcx-event geocortex.essentialsHtmlViewer
    * @name CoordinateSetHiddenEvent
    * @param coordId The coordinate Id that has currently been set hidden.
    * @introduced 2.6
    * @gcx-event-category Plot Coordinates
    */
    (eventName: "CoordinateSetHiddenEvent"): TypedEvent<{
        (coordId: string): void;
    }>;
    /**
    * Raised when a plotted coordinate which was hidden, is set visible again.
    * @docs-gcx-event geocortex.essentialsHtmlViewer
    * @name CoordinateSetHiddenEvent
    * @param coordId The coordinate Id that has currently been set visible.
    * @introduced 2.6
    * @gcx-event-category Plot Coordinates
    */
    (eventName: "CoordinateSetVisibleEvent"): TypedEvent<{
        (coordId: string): void;
    }>;
    /**
     * Raised when buffering is activated for a target command or commands.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name BufferingActivatedEvent
     * @param args A string or array of strings specifying the command(s) for which buffering has been activated.
     * @introduced 2.5
     * @gcx-event-category Buffering
     */
    (eventName: "BufferingActivatedEvent"): TypedEvent<{
        (args: string | string[]): void;
    }>;
    /**
    * Raised when buffering is deactivated for a target command or commands.
    * @docs-gcx-event geocortex.essentialsHtmlViewer
    * @name BufferingDeactivatedEvent
    * @param args A string or array of strings specifying the command(s) for which buffering has been deactivated.
    * @introduced 2.5
    * @gcx-event-category Buffering
    */
    (eventName: "BufferingDeactivatedEvent"): TypedEvent<{
        (args: string | string[]): void;
    }>;
    /**
    * Raised when the current buffer distance or units for a command are changed by the user via the Buffer Options dialog.
    * @docs-gcx-event geocortex.essentialsHtmlViewer
    * @name BufferDistanceChangedEvent
    * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.buffer.BufferDistanceChangedEventArgs} object denoting the new buffer distance configuration.
    * @introduced 2.5
    * @gcx-event-category Buffering
    */
    (eventName: "BufferDistanceChangedEvent"): TypedEvent<{
        (args: BufferDistanceChangedEventArgs): void;
    }>;
    /**
     * Raised when a buffering operation successfully completes.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name BufferingCompletedEvent
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.buffer.BufferOperationResult} object, with either the buffered `geometry` or an array of `geometries` as its properties.
     * @introduced 2.5
     * @gcx-event-category Buffering
     */
    (eventName: "BufferingCompletedEvent"): TypedEvent<{
        (args: BufferOperationResult): void;
    }>;
    /**
     * Raised when a buffering operation returns an error.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name BufferingErrorEvent
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.buffer.BufferOperationError} object.
     * @introduced 2.5
     * @gcx-event-category Buffering
     */
    (eventName: "BufferingErrorEvent"): TypedEvent<{
        (args: BufferOperationError): void;
    }>;
    /**
     * Raised when the Buffer Options dialog for any command is dismissed when the user clicks Continue.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name BufferOptionsDismissedEvent
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.buffer.BufferDistanceChangedEventArgs} object containing the buffer settings when the view was dismissed, with the following properties: `distance`, `unit` and `targetCommands`.
     * `distance` is the distance amount entered by the user.
     * `unit` is the distance unit entered by the user.
     * `targetCommands` are the commands to which buffering will be applied.
     * @introduced 2.5
     * @gcx-event-category Buffering
     */
    (eventName: "BufferOptionsDismissedEvent"): TypedEvent<{
        (args: BufferDistanceChangedEventArgs): void;
    }>;
    /**
     * Raised when the Collaboration module successfully Initializes.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name CollaborationInitializedEvent
     * @introduced 2.8
     * @gcx-event-category Start-Up, Initialization and Shutdown
     */
    (eventName: "CollaborationInitializedEvent"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised when the Compact Toolbar is expanded or collapsed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name CompactToolbarStateChanged
     * @param isExpanded Whether the Compact Toolbar has been expanded or not.
     * @introduced 2.4
     * @gcx-event-category Interface
     */
    (eventName: "CompactToolbarStateChangedEvent"): TypedEvent<{
        (isExpanded: boolean): void;
    }>;
    /**
     * Raised when an external components viewpoint has been updated.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ComponentViewpointUpdatedEvent
     * @param arg An instance of {@link essentialsHtmlViewer.mapping.infrastructure.integration.ComponentViewpointMessage}, that represents the updated viewpoint of the component.
     * @introduced 2.4
     * @gcx-event-category Integration
     */
    (eventName: "ComponentViewpointUpdatedEvent"): TypedEvent<{
        (arg: ComponentViewpointMessage): void;
    }>;
    /**
     * Raised when a coordinate is resolved and successfully plotted on the map.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name CoordinateAddedEvent
     * @param arg An instance of {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.PlotCoordinatesEventArgs}, that represents the coordinate just added to the map.
     * @introduced 2.6
     * @gcx-event-category Plot Coordinates
     */
    (eventName: "CoordinateAddedEvent"): TypedEvent<{
        (arg: PlotCoordinatesEventArgs): void;
    }>;
    /**
     * Raised when a coordinate is successfully edited.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name CoordinateEditedEvent
     * @param arg An instance of {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.PlotCoordinatesEventArgs}, that represents the coordinate that was just edited.
     * @introduced 2.6
     * @gcx-event-category Plot Coordinates
     */
    (eventName: "CoordinateEditedEvent"): TypedEvent<{
        (arg: PlotCoordinatesEventArgs): void;
    }>;
    /**
     * Raised when a coordinate is successfully deleted and removed from the map.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name CoordinateDeletedEvent
     * @param arg An instance of {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.PlotCoordinatesEventArgs}, that represents the coordinate that was just deleted
     * @introduced 2.6
     * @gcx-event-category Plot Coordinates
     */
    (eventName: "CoordinateDeletedEvent"): TypedEvent<{
        (arg: PlotCoordinatesEventArgs): void;
    }>;
    /**
     * Raised when a coordinate's id is updated, possibly as a result of another coordinate in the coordinate list being deleted.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name CoordinateIdUpdatedEvent
     * @param arg An instance of {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.PlotCoordinatesIdUpdatedEventArgs}, that represents the coordinate whose Id was just updated
     * @introduced 2.6
     * @gcx-event-category Plot Coordinates
     */
    (eventName: "CoordinateIdUpdatedEvent"): TypedEvent<{
        (arg: PlotCoordinatesIdUpdatedEventArgs): void;
    }>;
    /**
     * Raised when a coordinate successfully updates itself in response to a change in the global coordinate system setting.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name CoordinateSystemUpdateAppliedEvent
     * @param arg An instance of {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.PlotCoordinatesEventArgs}, that represents the coordinate whose coordinate system was just updated.
     * @introduced 2.6
     * @gcx-event-category Plot Coordinates
     */
    (eventName: "CoordinateSystemUpdateAppliedEvent"): TypedEvent<{
        (arg: PlotCoordinatesEventArgs): void;
    }>;
    /**
     * Raised when the context menu is activated.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ContextMenuActivated
     * @introduced 2.6
     * @gcx-event-category Interface
     */
    (eventName: "ContextMenuActivated"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised when the context menu is deactivated.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ContextMenuDeactivated
     * @introduced 2.6
     * @gcx-event-category Interface
     */
    (eventName: "ContextMenuDeactivated"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised when a Collaboration image event finishes loading.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name CollaborationImageLoadedEvent
     * @param event The ImageRestEvent that was loaded.
     * @introduced 2.8
     * @gcx-event-category Collaboration
     * @private
     */
    (eventName: "CollaborationImageLoadedEvent"): TypedEvent<{
        (event: RestEvent): void;
    }>;
    /**
     * Raised when a Collaboration event's graphics are removed from the map.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name CollaborationMapEventDeleted
     * @param eventId The id of the deleted event.
     * @introduced 2.8
     * @gcx-event-category Collaboration
     * @private
     */
    (eventName: "CollaborationMapEventDeletedEvent"): TypedEvent<{
        (eventId: string): void;
    }>;
    /**
     * Raised when a collaboration room is updated.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name CollaborationRoomUpdatedEvent
     * @param room The {@link essentialsHtmlViewer.mapping.infrastructure.collaboration.RestRoom} that has been updated.
     * @introduced 2.8
     * @gcx-event-category Collaboration
     */
    (eventName: "CollaborationRoomUpdatedEvent"): TypedEvent<{
        (room: RestRoom): void;
    }>;
    /**
     * Raised when datalinks are discovered for the current {@link essentialsHtmlViewer.mapping.infrastructure.FeatureSet} and resolution begins.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name DatalinkResolutionStartedEvent
     * @param datalinkId The ID of the datalink to resolve.
     * @param featureSet The {@link essentialsHtmlViewer.mapping.infrastructure.FeatureSet} containing features with datalinks to be resolved.
     * @introduced 2.5
     * @gcx-event-category Editing
     */
    (eventName: "DatalinkResolutionStartedEvent"): TypedEvent<{
        (datalinkId: string, featureSet: FeatureSet): void;
    }>;
    /**
     * Raised when datalinks are successfully resolved.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name DatalinkResolutionCompletedEvent
     * @param datalinkId The ID of the datalink to resolve.
     * @param featureSet The {@link essentialsHtmlViewer.mapping.infrastructure.FeatureSet} containing features with resolved datalinks.
     * @introduced 2.5
     * @gcx-event-category Editing
     */
    (eventName: "DatalinkResolutionCompletedEvent"): TypedEvent<{
        (datalinkId: string, featureSet: FeatureSet): void;
    }>;
    /**
     * Raised when the Data Frame is closed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name DataFrameClosedEvent
     * @introduced 1.1
     * @gcx-event-category Interface
     */
    (eventName: "DataFrameClosedEvent"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised when offline data is cleared for an entire domain.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name DomainStorageClearedEvent
     * @introduced 1.1
     * @gcx-event-category Offline
     */
    (eventName: "DomainStorageClearedEvent"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised when the Data Frame is opened.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name DataFrameOpenedEvent
     * @introduced 1.1
     * @gcx-event-category Interface
     */
    (eventName: "DataFrameOpenedEvent"): TypedEvent<{
        (bottomPanelHeightPercent?: number): void;
    }>;
    /**
     * Raised when the feature editor is closed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name EditorClosedEvent
     * @introduced 2.5
     * @gcx-event-category Editing
     */
    (eventName: "EditorClosedEvent"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised when a vertex within the Esri editor is dragged with the mouse.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name EditVertexHandleMovedEvent
     * @param args A reference to the dragging handle graphic.
     * @introduced 2.5
     * @gcx-event-category Editing
     */
    (eventName: "EditVertexHandleMovedEvent"): TypedEvent<{
        (args: esri.Graphic): void;
    }>;
    /**
     * Raised when a vertex is moved with the keyboard.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name EditVertexMovedEvent
     * @param args An {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.EditVertexMovedEventArgs} object with the following properties: `sender`, `mapPoint` and `screenPoint`.
     * `sender` is the sender.
     * `mapPoint` is the map coordinates of the vertex.
     * `screenPoint` is screen cooridinates of the vertex.
     * @introduced 2.5
     * @gcx-event-category Editing
     */
    (eventName: "EditVertexMovedEvent"): TypedEvent<{
        (args: EditVertexMovedEventArgs): void;
    }>;
    /**
     * Raised when a new feature is about to be created.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name EditorPreCreateFeatureEvent
     * @param feature The feature that is about to be created.
     * @introduced 1.2
     * @gcx-event-category Editing
     */
    (eventName: "EditorPreCreateFeatureEvent"): TypedEvent<{
        (feature: esri.Graphic): void;
    }>;
    /**
     * Raised when an existing feature is about to be updated.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name EditorPreUpdateFeatureEvent
     * @param feature The feature that is about to be updated.
     * @introduced 1.2
     * @gcx-event-category Editing
     */
    (eventName: "EditorPreUpdateFeatureEvent"): TypedEvent<{
        (feature: esri.Graphic): void;
    }>;
    /**
     * Raised when an HTTP request to an Esri resource is started.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name EsriWebRequestStartedEvent
     * @param url The URL for the web request.
     * @introduced 2.5
     * @gcx-event-category Performance
     */
    (eventName: "EsriWebRequestStartedEvent"): TypedEvent<{
        (url: string): void;
    }>;
    /**
     * Raised when an HTTP request to an Esri resource is completed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name EsriWebRequestCompletedEvent
     * @param url The URL for the web request.
     * @introduced 2.5
     * @gcx-event-category Performance
     */
    (eventName: "EsriWebRequestCompletedEvent"): TypedEvent<{
        (url: string): void;
    }>;
    /**
     * Raised when an external component has established a {@link essentialsHtmlViewer.integration.PostMessageTransport}.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ExternalComponentInitializedEvent
     * @param arg An instance of {@link essentialsHtmlViewer.mapping.infrastructure.integration.ComponentInitializationMessage}, that represents a previous state of the component.
     * @introduced 2.4
     * @gcx-event-category Integration
     */
    (eventName: "ExternalComponentInitializedEvent"): TypedEvent<{
        (arg: ComponentInitializationMessage): void;
    }>;
    /**
     * Raised when a file attachment is added to a feature.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name FeatureAttachmentAddedEvent
     * @param feature The feature to which the file was attached successfully
     * @introduced 1.3
     * @gcx-event-category Editing
     */
    (eventName: "FeatureAttachmentAddedEvent"): TypedEvent<{
        (feature: Feature): void;
    }>;
    /**
     * Raised when a feature is changed - for example when datalinks are asynchronously resolved.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name FeatureChangedEvent
     * @param feature The feature that was changed.
     * @introduced 1.2
     * @gcx-event-category Editing
     */
    (eventName: "FeatureChangedEvent"): TypedEvent<{
        (feature: Feature): void;
    }>;
    /**
    * Raised when the current feature whose details are being displayed by the Feature Details module changes.
    * @docs-gcx-event geocortex.essentialsHtmlViewer
    * @name FeatureDetailsCurrentFeatureChanged
    * @param feature The current feature for which the Feature Details module is displaying details.
    * @introduced 2.4
    * @gcx-event-category Feature Details
    */
    (eventName: "FeatureDetailsCurrentFeatureChanged"): TypedEvent<{
        (feature: Feature): void;
    }>;
    /**
    * Raised when the Feature Details module is invoked in order to display results for a given feature.
    * @docs-gcx-event geocortex.essentialsHtmlViewer
    * @name FeatureDetailsInvokedEvent
    * @param feature The current feature for which the Feature Details module is displaying details.
    * @introduced 2.6
    * @gcx-event-category Feature Details
    */
    (eventName: "FeatureDetailsInvokedEvent"): TypedEvent<{
        (feature: Feature): void;
    }>;
    /**
     * Raised when a feature is created.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name FeatureCreatedEvent
     * @param feature The feature that was created.
     * @introduced 2.3
     * @gcx-event-category Editing
     */
    (eventName: "FeatureCreatedEvent"): TypedEvent<{
        (feature: esri.Graphic): void;
    }>;
    /**
     * Raised when a feature data synchronization has completed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name FeatureDataSyncCompleteEvent
     * @introduced 2.6
     * @gcx-event-category Offline
     */
    (eventName: "FeatureDataSyncCompletedEvent"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised when a feature data synchronization has started.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name FeatureDataSyncStartedEvent
     * @param parameters The sync parameters that were used to specify which data should be synced.
     * @introduced 2.6
     * @gcx-event-category Offline
     */
    (eventName: "FeatureDataSyncStartedEvent"): TypedEvent<{
        (parameters: SyncParameters): void;
    }>;
    /**
     * Raised when a feature is deleted.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name FeatureDeletedEvent
     * @param feature The feature that was deleted.
     * @introduced 1.2
     * @gcx-event-category Editing
     */
    (eventName: "FeatureDeletedEvent"): TypedEvent<{
        (feature: esri.Graphic): void;
    }>;
    /**
     * Raised when a feature is edited.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name FeatureEditedEvent
     * @param args An object with the following properties: `originalFeature` and `editedFeature`.
     * `originalFeature` is the {@link esri.Graphic} representing the original feature.
     * `editedFeature` is the {@link esri.Graphic} representing the edited feature.
     * @introduced 1.3
     * @gcx-event-category Editing
     */
    (eventName: "FeatureEditedEvent"): TypedEvent<{
        (args: {
            originalFeature: esri.Graphic;
            editedFeature: esri.Graphic;
        }): void;
    }>;
    /**
    * Raised when the query associated with a particular filter control changes.
    * @docs-gcx-event geocortex.essentialsHtmlViewer
    * @name FilterControlQueryChangedEvent
    * @param args An object which defines the query passed in to the filter, along with the filter ID.
    * @introduced 2.8
    * @gcx-event-category Filter-Control
    */
    (eventName: "FilterControlQueryChangedEvent"): TypedEvent<{
        (args: FilterControlQueryChangedEventArgs): void;
    }>;
    /**
    * Raised when the results associated with a filter control change as a result of a different query being applied to the filter.
    * @docs-gcx-event geocortex.essentialsHtmlViewer
    * @name FilterControlResultChangedEvent
    * @param args An object with the filterable items associated with the filter, along with the filter ID.
    * @introduced 2.8
    * @gcx-event-category Filter-Control
    */
    (eventName: "FilterControlResultChangedEvent"): TypedEvent<{
        (args: FilterControlEventArgs<any>): void;
    }>;
    /**
     * Raised when a module opens a flyout menu.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name FlyoutActivated
     * @param view The view whose flyout menu opened.
     * @introduced 2.4
     * @gcx-event-category Interface
     */
    (eventName: "FlyoutActivated"): TypedEvent<{
        (view: ViewBase): void;
    }>;
    /**
     * Raised when a module closes a flyout menu.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name FlyoutDeactivated
     * @param view The view whose flyout menu closed.
     * @introduced 2.4
     * @gcx-event-category Interface
     */
    (eventName: "FlyoutDeactivated"): TypedEvent<{
        (view: ViewBase): void;
    }>;
    /**
     * Raised when a folder item in the layer list is clicked or tapped.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name FolderClickedEvent
     * @param context The folder item in the layer list.  An instance of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.layerList.LayerListFolderItem}.
     * @introduced 2.3
     * @gcx-event-category Layer List
     */
    (eventName: "FolderClickedEvent"): TypedEvent<{
        (context: LayerListFolderItem): void;
    }>;
    /**
     * Raised when a {@link essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} is added to the {@link essentialsHtmlViewer.mapping.infrastructure.FeatureSetManager}.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name FSMCollectionAddedEvent
     * @param args An instance of {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.FeatureSetManagerEventArgs}.
     * @introduced 1.0
     * @gcx-event-category Feature Set Collection
     */
    (eventName: "FSMCollectionAddedEvent"): TypedEvent<{
        (args: FeatureSetManagerEventArgs): void;
    }>;
    /**
     * Raised when a {@link essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} in the {@link essentialsHtmlViewer.mapping.infrastructure.FeatureSetManager} is altered.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name FSMCollectionChangedEvent
     * @param args An instance of {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.FeatureSetManagerEventArgs}.
     * @introduced 1.0
     * @gcx-event-category Feature Set Collection
     */
    (eventName: "FSMCollectionChangedEvent"): TypedEvent<{
        (args: FeatureSetManagerEventArgs): void;
    }>;
    /**
     * Raised when a {@link essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} is closed in the {@link essentialsHtmlViewer.mapping.infrastructure.FeatureSetManager}.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name FSMCollectionClosedEvent
     * @param args An instance of {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.FeatureSetManagerEventArgs}.
     * @introduced 1.0
     * @gcx-event-category Feature Set Collection
     */
    (eventName: "FSMCollectionClosedEvent"): TypedEvent<{
        (args: FeatureSetManagerEventArgs): void;
    }>;
    /**
     * Raised when a {@link essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} is opened in the {@link essentialsHtmlViewer.mapping.infrastructure.FeatureSetManager}.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name FSMCollectionOpenedEvent
     * @param args An instance of {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.FeatureSetManagerEventArgs}.
     * @introduced 1.0
     * @gcx-event-category Feature Set Collection
     */
    (eventName: "FSMCollectionOpenedEvent"): TypedEvent<{
        (args: FeatureSetManagerEventArgs): void;
    }>;
    /**
     * Raised when a {@link essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} is removed from the {@link essentialsHtmlViewer.mapping.infrastructure.FeatureSetManager}.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name FSMCollectionRemovedEvent
     * @param args An instance of {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.FeatureSetManagerEventArgs}.
     * @introduced 1.0
     * @gcx-event-category Feature Set Collection
     */
    (eventName: "FSMCollectionRemovedEvent"): TypedEvent<{
        (args: FeatureSetManagerEventArgs): void;
    }>;
    /**
     * Raised after a successful geolocation operation.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name GeolocatedEvent
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.GeolocationEventArgs} object containing the following properties: `mapPoint`, `location`, `typeOfGeolocation`, `accuracyThreshold`, `timedOut`.
     * `mapPoint` represents the map point of the user's position in Web Mercator.
     * `location` represents the location of the user, as returned directly from the HTML5 geolocation event.
     * `typeOfGeolocation` is a string indicating whether the current geolocation result was from single geolocation, tracking or following.
     * `accuracyThreshold` is a number indicating the accuracy radius, in meters, that was specified to satisfy a single-reading geolocation.
     * `timedOut` is `true` when the time limit specified for single-reading geolocation has been reached; otherwise, it is `false`.
     * @introduced 1.0
     * @gcx-event-category Map
     */
    (eventName: "GeolocatedEvent"): TypedEvent<{
        (args: GeolocationEventArgs): void;
    }>;
    /**
     * Raised when a geolocation operation fails in find, track, or follow mode.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name GeolocationFailedEvent
     * @param args An object containing the following properties: `error`, `isFollowing` and `isTracking`.
     * @introduced 2.3
     * @gcx-event-category Map
     */
    (eventName: "GeolocationFailedEvent"): TypedEvent<{
        (args: {
            error: PositionError;
            isFollowing: boolean;
            isTracking: boolean;
        }): void;
    }>;
    /**
     * Raised when geometry of a feature has been edited.
     * @name GeometryEditCompletedEvent
     * @param args An object that represents information about the edit, containing the properties: `editedGraphic`, `originalGraphic`, `cancelled`.
     * @introduced 1.3
     * @gcx-event-category Editing
     */
    (eventName: "GeometryEditCompletedEvent"): TypedEvent<{
        (args: GeometryEditCompletedEventArg): void;
    }>;
    /**
     * Raised when editing of the geometry of a feature has started.
     * @name GeometryEditInvokedEvent
     * @param graphic The Esri Graphic being edited.
     * @introduced 1.3
     * @gcx-event-category Editing
     */
    (eventName: "GeometryEditInvokedEvent"): TypedEvent<{
        (graphic: esri.Graphic): void;
    }>;
    /**
     * Raised when the attributes of esri graphic are updated.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name GraphicAttributesChangedEvent
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.GraphicAttributesChangedEventArgs} object with the following properties: `graphic`.
     * @introduced 2.8
     * @gcx-event-category Editing
     */
    (eventName: "GraphicAttributesChangedEvent"): TypedEvent<{
        (args: GraphicAttributesChangedEventArgs): void;
    }>;
    /**
     * Raised when the component for drawing shapes is activated.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name GraphicDrawActivatedEvent
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.GraphicDrawActivatedEventArgs} object with the following properties: `sender` and `geometryType`.
     * @introduced 2.4
     * @gcx-event-category Tool
     */
    (eventName: "GraphicDrawActivatedEvent"): TypedEvent<{
        (args: GraphicDrawActivatedEventArgs): void;
    }>;
    /**
     * Raised when the user has ended drawing.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name GraphicDrawCompletedEvent
     * @param geometry The geometry of the shape that was drawn. Coordinates of this geometry have the same spatial reference of the map.
     * @introduced 2.4
     * @gcx-event-category Tool
     */
    (eventName: "GraphicDrawCompletedEvent"): TypedEvent<{
        (geometry: esri.geometry.Geometry): void;
    }>;
    /**
     * Raised when the component for drawing shapes is deactivated.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name GraphicDrawDeactivatedEvent
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.GraphicDrawDeactivatedEventArgs} object with the following properties: `sender` and `geometryType`.
     * @introduced 2.4
     * @gcx-event-category Tool
     */
    (eventName: "GraphicDrawDeactivatedEvent"): TypedEvent<{
        (args: GraphicDrawDeactivatedEventArgs): void;
    }>;
    /**
     * Raised when the component for editing a point-based feature is activated.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name GeometryEditPointActivatedEvent
     * @introduced 2.5
     * @gcx-event-category Tool
     */
    (eventName: "GeometryEditPointActivatedEvent"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised when the component for editing graphics is activated.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name GraphicEditActivatedEvent
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.GraphicEditActivatedEventArgs} object with the following properties: `sender`, `tool` and `graphic`.
     * @introduced 2.4
     * @gcx-event-category Tool
     */
    (eventName: "GraphicEditActivatedEvent"): TypedEvent<{
        (args: GraphicEditActivatedEventArgs): void;
    }>;
    /**
     * Raised when the component for editing graphics is deactivated.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name GraphicEditDeactivatedEvent
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.GraphicEditDeactivatedEventArgs} object with the following properties: `sender`, `tool`, `graphic`, `isModified` (optional), `cancelled` (optional).
     * @introduced 2.4
     * @gcx-event-category Tool
     */
    (eventName: "GraphicEditDeactivatedEvent"): TypedEvent<{
        (args: GraphicEditDeactivatedEventArgs): void;
    }>;
    /**
     * Raised when mouse is released while moving, rotating, scaling or moving vertex of the esri graphic.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name GeometryChangedEvent
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.GeometryChangedEventArgs} object with the following properties: `graphic`.
     * @introduced 2.8
     * @gcx-event-category Editing
     */
    (eventName: "GeometryChangedEvent"): TypedEvent<{
        (args: GeometryChangedEventArgs): void;
    }>;
    /**
     * Raised when the component for editing draw/markup graphics is activated after a drawing is completed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name GraphicDrawAccessibleEditActivatedEvent
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.GraphicEditActivatedEventArgs} object with the following properties: `sender`, `tool` and `graphic`.
     * @introduced 2.5
     * @gcx-event-category Tool
     */
    (eventName: "GraphicDrawAccessibleEditActivatedEvent"): TypedEvent<{
        (args: GraphicEditActivatedEventArgs): void;
    }>;
    /**
     * Raised when the component for editing draw/markup graphics is deactivated after a drawing is completed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name GraphicDrawAccessibleEditDeactivatedEvent
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.GraphicEditDeactivatedEventArgs} object with the following properties: `sender`, `tool`, `graphic`, `isModified` (optional), `cancelled` (optional).
     * @introduced 2.5
     * @gcx-event-category Tool
     */
    (eventName: "GraphicDrawAccessibleEditDeactivatedEvent"): TypedEvent<{
        (args: GraphicEditDeactivatedEventArgs): void;
    }>;
    /**
     * Raised when we are done editing a clickable graphic.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name GraphicEditingDoneEvent
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.GraphicEditingDoneEventArgs} object with the following properties: `old` and `new`.
     * @introduced 2.8
     * @gcx-event-category Editing
     */
    (eventName: "GraphicEditingDoneEvent"): TypedEvent<{
        (args: GraphicEditingDoneEventArgs): void;
    }>;
    /**
     * Raised when a clickable graphic is removed from the map.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name GraphicRemovedEvent
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.GraphicRemovedEventArgs} object with the following properties: `graphic`.
     * @introduced 2.8
     * @gcx-event-category Editing
     */
    (eventName: "GraphicRemovedEvent"): TypedEvent<{
        (args: GraphicRemovedEventArgs): void;
    }>;
    /**
     * Raised when the symbology of edited markup changes
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name GraphicSymbolChangedEvent
     * @param graphic The edited graphic with new symbol applied
     * @introduced 2.8
     * @gcx-event-category Markup
     */
    (eventName: "GraphicSymbolChangedEvent"): TypedEvent<{
        (graphic: esri.Graphic): void;
    }>;
    /**
     * Raised when a new vertex is added to a polyline or polygon or a new point is added to a multipoint in an active drawing session.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name GraphicVertexAddedEvent
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.GraphicVertexAddedEventArgs} object with the following properties: `sender`, `mapPoint`, `screenPoint`.
     * @introduced 2.4
     * @gcx-event-category Tool
     */
    (eventName: "GraphicVertexAddedEvent"): TypedEvent<{
        (args: GraphicVertexAddedEventArgs): void;
    }>;
    /**
     * Raised when the graphic vertex drawing tool is moved using the keyboard.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name GraphicVertexMovedEvent
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.GraphicVertexMovedEventArgs} object with the following properties: `sender`, `mapPoint`, `screenPoint`.
     * @introduced 2.4
     * @gcx-event-category Tool
     */
    (eventName: "GraphicVertexMovedEvent"): TypedEvent<{
        (args: GraphicVertexMovedEventArgs): void;
    }>;
    /**
     * Raised when a Geocortex layer has a heat map visualization added.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name HeatMapAddedEvent
     * @param gcxLayer The Geocortex layer that had the heat map added.
     * @introduced 2.5
     * @gcx-event-category Visualization
     */
    (eventName: "HeatMapAddedEvent"): TypedEvent<{
        (gcxLayer: Layer): void;
    }>;
    /**
     * Raised when a Geocortex layer has a heat map visualization removed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name HeatMapRemovedEvent
     * @param gcxLayer The Geocortex layer that had the heat map removed.
     * @introduced 2.5
     * @gcx-event-category Visualization
     */
    (eventName: "HeatMapRemovedEvent"): TypedEvent<{
        (gcxLayer: Layer): void;
    }>;
    /**
     * Raised when the combine mode for the identify tool changes.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name IdentifyCombineModeChangeEvent
     * @param mode A string representing the new identify tool combine mode.
     * @introduced 2.8
     * @gcx-event-category Tool
     */
    (eventName: "IdentifyCombineModeChangeEvent"): TypedEvent<{
        (mode: string): void;
    }>;
    /**
     * Raised when label symbolization is changed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name LabelOptionsChanged
     * @param gcxLayer The Geocortex layer that has had its label options changed.
     * @introduced 2.7
     * @gcx-event-category Label Options
     */
    (eventName: "LabelOptionsChanged"): TypedEvent<{
        (gcxLayer: Layer): void;
    }>;
    /**
    * Raised when label symbolization is reset back to default.
    * @docs-gcx-event geocortex.essentialsHtmlViewer
    * @name LabelsResetEvent
    * @introduced 2.7
    * @gcx-event-category Label Options
    */
    (eventName: "LabelsResetEvent"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised when a layer has been added to the map.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name LayerAddedEvent
     * @param serviceLayer The Esri service layer which has been added to the map.
     * @param service The map service specific to this layer.
     * @introduced 1.1
     * @gcx-event-category Map
     */
    (eventName: "LayerAddedEvent"): TypedEvent<{
        (serviceLayer: esri.layers.Layer, service: MapService): void;
    }>;
    /**
     * Raised when a layer is added to the map, or a layer fails to be added to the map.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name LayerAddedWithResultEvent
     * @param serviceLayer The Esri service layer added to the map.
     * @param error (Optional) Available when an error occurs during the update.
     * @introduced 1.1
     * @gcx-event-category Map
     */
    (eventName: "LayerAddedWithResultEvent"): TypedEvent<{
        (serviceLayer: esri.layers.Layer, error?: Error): void;
    }>;
    /**
     * Raised when a layer item in the layer list is clicked or tapped.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name LayerClickedEvent
     * @param context The layer item in the layer list that was clicked or tapped.  An instance of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.layerList.LayerListLayerItem}.
     * @introduced 1.1
     * @gcx-event-category Layer List
     */
    (eventName: "LayerClickedEvent"): TypedEvent<{
        (context: LayerListLayerItem): void;
    }>;
    /**
    * Raised when a specific layer has been disabled from participating in identify operations.
    * @docs-gcx-event geocortex.essentialsHtmlViewer
    * @name LayerDisabledForIdentifyEvent
    * @param layer A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.identify.LayerDescriptor} object describing the layer that has been disabled for identify, with the following properties: `mapServiceId` and `layerId` (optional).
    * @introduced 2.5
    * @gcx-event-category Identify
    */
    (eventName: "LayerDisabledForIdentifyEvent"): TypedEvent<{
        (layer: LayerDescriptor): void;
    }>;
    /**
    * Raised when a filter is applied using the Filter Builder tool
    * @docs-gcx-event geocortex.essentialsHtmlViewer
    * @name FilterBuilderLayerDefinitionAppliedEvent
    * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.LayerDefinitionExpressionAppliedEventArgs} object with a `gcxlayer` property referring to the current layer being filtered.
    * @introduced 2.7
    * @gcx-event-category Query Builder
    */
    (eventName: "FilterBuilderLayerDefinitionAppliedEvent"): TypedEvent<{
        (args: LayerDefinitionExpressionAppliedEventArgs): void;
    }>;
    /**
    * Raised when a specific layer's display name has been changed.
    * @docs-gcx-event geocortex.essentialsHtmlViewer
    * @name LayerDisplayNameChanged
    * @param layer The layer whose display name was just changed.
    * @introduced 2.7
    * @gcx-event-category Layer Addition
    */
    (eventName: "LayerDisplayNameChanged"): TypedEvent<{
        (layer: Layer): void;
    }>;
    /**
    * Raised when a specific layer has been enabled such that it participates in identify operations.
    * @docs-gcx-event geocortex.essentialsHtmlViewer
    * @name LayerEnabledForIdentifyEvent
    * @param layer A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.identify.LayerDescriptor} object describing the layer that has been enabled for identify, with the following properties: `mapServiceId` and `layerId` (optional).
    * @introduced 2.5
    * @gcx-event-category Identify
    */
    (eventName: "LayerEnabledForIdentifyEvent"): TypedEvent<{
        (layer: LayerDescriptor): void;
    }>;
    /**
     * Raised after the configurable layer list has initialized and the initial layer theme has been loaded.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name LayerListInitializedEvent
     * @param sender The core layer list object reference.  An instance of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.layerList.LayerList}.
     * @introduced 2.3
     * @gcx-event-category Layer List
     */
    (eventName: "LayerListInitializedEvent"): TypedEvent<{
        (sender: LayerList): void;
    }>;
    /**
     * Raised when a layer item in the layer list is pressed for a long time.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name LayerLongPressedEvent
     * @param context The layer item corresponding to the layer which was pressed for a long time.  An instance of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.layerList.LayerListLayerItem}.
     * @introduced 1.1
     * @gcx-event-category Layer List
     */
    (eventName: "LayerLongPressedEvent"): TypedEvent<{
        (context: LayerListLayerItem): void;
    }>;
    /**
     * Raised when a layer item in the layer list is clicked or tapped.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name LayerPressedEvent
     * @param context The layer item in the layer list that was clicked or tapped.  An instance of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.layerList.LayerListLayerItem}.
     * @introduced 1.1
     * @gcx-event-category Layer List
     */
    (eventName: "LayerPressedEvent"): TypedEvent<{
        (context: LayerListLayerItem): void;
    }>;
    /**
     * Raised when a layer has been removed from the map.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name LayerRemovedEvent
     * @param serviceLayer The Esri service layer which has been removed.
     * @introduced 1.1
     * @gcx-event-category Map
     */
    (eventName: "LayerRemovedEvent"): TypedEvent<{
        (serviceLayer: esri.layers.Layer): void;
    }>;
    /**
     * Raised when more than one layer is added to the map, or more than one layer fails to be added to the map.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name LayersAddedWithResultEvent
     * @param results An array of result objects with the following properties: `layer`, `success`, `error`.
     * @introduced 1.1
     * @gcx-event-category Map
     */
    (eventName: "LayersAddedWithResultEvent"): TypedEvent<{
        (results: {
            layer: esri.layers.Layer;
            success?: boolean;
            error?: Error;
        }[]): void;
    }>;
    /**
     * Raised when a layer finishes updating its content.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name LayerUpdateEndedEvent
     * @param serviceLayer The Esri service layer whose attribute has been updated.
     * @param service The {@link essentials.MapService} specific to this layer.
     * @introduced 1.1
     * @gcx-event-category Map
     */
    (eventName: "LayerUpdateEndedEvent"): TypedEvent<{
        (serviceLayer: esri.layers.Layer, service: MapService): void;
    }>;
    /**
    * Raised when the provider has finished fetching all expected catalog layers.
    * @docs-gcx-event geocortex.essentialsHtmlViewer
    * @name LayerCatalogProviderFinishedEvent
    * @introduced 2.7
    * @gcx-event-category Layer Catalog
    * @private
    */
    (eventName: "LayerCatalogProviderFinishedEvent"): TypedEvent<{
        (): void;
    }>;
    /**
    * Raised when the provider has started fetching all expected catalog layers.
    * @docs-gcx-event geocortex.essentialsHtmlViewer
    * @name LayerCatalogProviderStartedEvent
    * @introduced 2.7
    * @gcx-event-category Layer Catalog
    * @private
    */
    (eventName: "LayerCatalogProviderStartedEvent"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised when a layer begins to update its content.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name LayerUpdateStartedEvent
     * @param serviceLayer The Esri service layer whose attribute will be updated.
     * @param service The {@link essentials.MapService} specific to this layer.
     * @introduced 1.1
     * @gcx-event-category Map
     */
    (eventName: "LayerUpdateStartedEvent"): TypedEvent<{
        (serviceLayer: esri.layers.Layer, service: MapService): void;
    }>;
    /**
     * Raised when the visibility of a layer has changed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name LayerVisibilityChangedEvent
     * @param results An array of result objects with the following properties: `layer`, `mapService`, `visibility`.
     * `layer` represents the site (Essentials) layer whose visibility changed;
     * `mapService` represents the map service specific to this layer;
     * `visibility` indicates whether or not the layer is visible after the visibility changed.
     * @introduced 2.3
     * @gcx-event-category Interface
     */
    (eventName: "LayerVisibilityChangedEvent"): TypedEvent<{
        (results: {
            layer: Layer;
            mapService: MapService;
            visibility: boolean;
        }[]): void;
    }>;
    /**
     * Raised just before the layer theme is changed. At this point, the active theme property will be set, but the theme will not
     * yet have been applied to the map.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name LayerThemeChangingEvent
     * @param layerThemeEventArgs A {@link geocortex.essentials.LayerThemeEventArgs} object containing the following properties: `currTheme` and `prevTheme`.
     * `currTheme` represents the current layer theme.
     * `prevTheme` represents the previous layer theme.
     * @introduced 2.3
     * @gcx-event-category Layer Theme
     */
    (eventName: "LayerThemeChangingEvent"): TypedEvent<{
        (layerThemeEventArgs: LayerThemeEventArgs): void;
    }>;
    /**
     * Raised just after the layer theme has changed. At this point the theme will have been applied to the map.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name LayerThemeChangedEvent
     * @param layerThemeEventArgs A {@link geocortex.essentials.LayerThemeEventArgs} object containing the following properties: `currTheme` and `prevTheme`.
     * `currTheme` represents the current layer theme.
     * `prevTheme` represents the previous layer theme.
     * @introduced 2.3
     * @gcx-event-category Layer Theme
     */
    (eventName: "LayerThemeChangedEvent"): TypedEvent<{
        (layerThemeEventArgs: LayerThemeEventArgs): void;
    }>;
    /**
     * Raised when a Geocortex layer has its visualization changed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name LayerVisualizationChangedEvent
     * @param gcxLayer The Geocortex layer whose visualization changed.
     * @introduced 2.5
     * @gcx-event-category Visualization
     */
    (eventName: "LayerVisualizationChangedEvent"): TypedEvent<{
        (gcxLayer: Layer): void;
    }>;
    /**
     * Raised when a map callout window is closed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapCalloutClosedEvent
     * @param elementID The unique element ID indicating which callout was closed, corresponding to the `elementID` parameter that was passed to the `ShowMapCallout` command.
     * @introduced 2.4
     * @gcx-event-category Interface
     */
    (eventName: "MapCalloutClosedEvent"): TypedEvent<{
        (elementID: string): void;
    }>;
    /**
     * Raised when a user clicks on the map.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapClickedEvent
     * @param mouseEvent A {@link MouseEvent}.
     * @introduced 1.1
     * @gcx-event-category Map
     */
    (eventName: "MapClickedEvent"): TypedEvent<{
        (mouseEvent: MouseEvent): void;
    }>;
    /**
     * Raised when a user clicks on the map, containing the point where the click occured. This is a repackaging of the 'MapClickedEvent' containing only the Point object.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapClickedPointEvent
     * @param point An instance of {@link esri.geometry.Point}, that represents the point on the map where the user clicked.
     * @introduced 2.9
     * @gcx-event-category Map
     */
    (eventName: "MapClickedPointEvent"): TypedEvent<{
        (point: esri.geometry.Point): void;
    }>;
    /**
     * Raised when a user triggers the context menu via right-click or long press of the map.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapContextMenuPointUpdatedEvent
     * @param point An instance of {@link esri.geometry.Point}, that represents the point on the map where the user activated the context menu.
     * @introduced 2.6
     * @gcx-event-category Interface
     */
    (eventName: "MapContextMenuPointUpdatedEvent"): TypedEvent<{
        (point: esri.geometry.Point): void;
    }>;
    /**
     * Raised as the extent of the map changes.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapExtentChangingEvent
     * @param mapExtentEventArgs An object that represents a center point on the current scale and resolution of the map.
     * @introduced 1.1
     * @gcx-event-category Map
     */
    (eventName: "MapExtentChangingEvent"): TypedEvent<{
        (mapExtentEventArgs: MapExtentEventArgs): void;
    }>;
    /**
     * Raised when the extent of the map completes a pan or zoom operation.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapExtentChangedEvent
     * @param extent The current extent of the map.
     * @param mapExtentEventArgs An object that represents a center point on the current scale and resolution of the map.
     * @introduced 1.1
     * @gcx-event-category Map
     */
    (eventName: "MapExtentChangedEvent"): TypedEvent<{
        (extent: esri.geometry.Extent, mapExtentEventArgs: MapExtentEventArgs): void;
    }>;
    /**
     * Raised as the extent of the map changes.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapExtentChangeEvent
     * @param extent The current extent of the map.
     * @param delta The change (in screen-space) of the coordinates from the last MapExtentChangeEvent.
     * @param levelChange Whether the user has zoomed to a new level on a tiled map service.
     * @param lod The level of detail for a tiled map service at the start of a zoom.
     * @introduced 1.0
     * @gcx-event-category Map
     */
    (eventName: "MapExtentChangeEvent"): TypedEvent<{
        (extent: esri.geometry.Extent, delta: esri.geometry.Point, levelChange: boolean, lod: esri.layers.LOD): void;
    }>;
    /**
     * Raised when the Esri map control is loaded.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapLoadedEvent
     * @param map The instance of the map that was loaded.
     * @introduced 1.0
     * @gcx-event-category Load
     */
    (eventName: "MapLoadedEvent"): TypedEvent<{
        (map: esri.Map): void;
    }>;
    /**
     * Raised when a user clicks on the map before releasing the mouse button.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapMouseDownEvent
     * @param mouseEvent An object describing the mouse down event.
     * @introduced 1.1
     * @gcx-event-category Map
     */
    (eventName: "MapMouseDownEvent"): TypedEvent<{
        (mouseEvent: MouseEvent): void;
    }>;
    /**
     * Raised when a user hovers on the map.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapMouseHoverEvent
     * @param mouseHoverCoords An object containing the clientX and clientY mouse values when the hover occurs.
     * @introduced 2.4
     * @gcx-event-category Map
     */
    (eventName: "MapMouseHoverEvent"): TypedEvent<{
        (mouseHoverCoords: {
            clientX: number;
            clientY: number;
        }): void;
    }>;
    /**
     * Raised when a user clicks on the map after releasing the mouse button.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapMouseUpEvent
     * @param mouseEvent An object describing the mouse up event.
     * @introduced 2.4
     * @gcx-event-category Map
     */
    (eventName: "MapMouseUpEvent"): TypedEvent<{
        (mouseEvent: MouseEvent): void;
    }>;
    /**
     * Raised when a pan operation is completed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapPanEndedEvent
     * @param extent The current extent of the map.
     * @param endPoint The end point of the pan operation. Contains the following properties: `x`, `y`.
     * @introduced 1.1
     * @gcx-event-category Map
     */
    (eventName: "MapPanEndedEvent"): TypedEvent<{
        (extent: esri.geometry.Extent, endPoint: esri.geometry.Point): void;
    }>;
    /**
     * Raised while a pan operation is in progress.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapPanEvent
     * @param extent The current extent of the map.
     * @param delta A point representing the change in screen-space as the map is panning.
     * @introduced 1.0
     * @gcx-event-category Map
     */
    (eventName: "MapPanEvent"): TypedEvent<{
        (extent: esri.geometry.Extent, delta: esri.geometry.Point): void;
    }>;
    /**
     * Raised at the beginning of a pan operation on the map.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapPanStartedEvent
     * @param extent The current extent of the map.
     * @param startPoint The starting point (in screen-space) where the pan was initiated from.
     * @introduced 1.1
     * @gcx-event-category Map
     */
    (eventName: "MapPanStartedEvent"): TypedEvent<{
        (extent: esri.geometry.Extent, startPoint: esri.geometry.Point): void;
    }>;
    /**
     * Raised when a map service is added to the Essentials Map.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapServiceAddedEvent
     * @param mapService The {@link essentials.MapService} which was added.
     * @introduced 2.2
     * @gcx-event-category Map
     */
    (eventName: "MapServiceAddedEvent"): TypedEvent<{
        (mapService: MapService): void;
    }>;
    /**
     * Raised when a map service layer in the layer list is clicked or tapped.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapServiceClickedEvent
     * @param context The map service item for the map service layer that was clicked or tapped.  An instance of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.layerList.LayerListMapServiceItem}.
     * @introduced 1.1
     * @gcx-event-category Layer List
     */
    (eventName: "MapServiceClickedEvent"): TypedEvent<{
        (context: LayerListMapServiceItem): void;
    }>;
    /**
     * Raised when a {@link essentials.MapService} has layers change by a user.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapServiceLayersChangedEvent
     * @param mapService The {@link essentials.MapService} which layers changed.
     * @introduced 2.2
     * @gcx-event-category Map
     */
    (eventName: "MapServiceLayersChangedEvent"): TypedEvent<{
        (mapService: MapService): void;
    }>;
    /**
     * Raised when a user changes the layers of a {@link essentials.MapService}.  For example, when new dynamic layers are added to the map.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapServiceLayersChangedWithResultEvent
     * @param args A {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.MapServiceLayersChangedEventArgs} object with the following properties: `mapService`, `newItems` and `oldItems`.
     * @introduced 2.5.2
     * @gcx-event-category Map
     */
    (eventName: "MapServiceLayersChangedWithResultEvent"): TypedEvent<{
        (args: MapServiceLayersChangedEventArgs): void;
    }>;
    /**
     * Raised when a property on a {@link essentials.MapService} changes.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapServicePropertyChangedEvent
     * @param mapService The {@link essentials.MapService} which changed.
     * @introduced 2.2
     * @gcx-event-category Map
     */
    (eventName: "MapServicePropertyChangedEvent"): TypedEvent<{
        (mapService: MapService): void;
    }>;
    /**
     * Raised when a map service is removed from the Essentials Map.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapServiceRemovedEvent
     * @param mapService The {@link essentials.MapService} which was removed.
     * @introduced 2.2
     * @gcx-event-category Map
     */
    (eventName: "MapServiceRemovedEvent"): TypedEvent<{
        (mapService: MapService): void;
    }>;
    /**
     * Raised when the visibility of a map service has changed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapServiceVisibilityChangedEvent
     * @param serviceLayer The Esri service layer whose visibility changed.
     * @param service The {@link essentials.MapService} specific to this layer.
     * @introduced 2.3
     * @gcx-event-category Map
     */
    (eventName: "MapServiceVisibilityChangedEvent"): TypedEvent<{
        (serviceLayer: esri.layers.Layer, service: MapService): void;
    }>;
    /**
     * Raised when the preferred extent to show on startup changes.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapStartupExtentChangedEvent
     * @param extent The extent to be shown on startup
     * @private
     */
    (eventName: "MapStartupExtentChangedEvent"): TypedEvent<{
        (extent: esri.geometry.Extent): void;
    }>;
    /**
     * Raised when the time extent of the map changes.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapTimeExtentChangedEvent
     * @param timeExtent The new time extent of the map.
     * @introduced 2.7
     * @gcx-event-category Interface
     */
    (eventName: "MapTimeExtentChangedEvent"): TypedEvent<{
        (timeExtent: esri.TimeExtent): void;
    }>;
    /**
     * Raised when the map tip window is closed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapTipClosedEvent
     * @introduced 1.1
     * @gcx-event-category Interface
     */
    (eventName: "MapTipClosedEvent"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised when a zoom operation completes.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapZoomEndedEvent
     * @param extent The current extent of the map.
     * @param zoomFactor Represents the percentage that the map zoomed in or out from the previous extent.
     * @param anchor The position of the cursor in screen-space.
     * @param level The level of a tiled map service at the start of a zoom.
     * @introduced 1.1
     * @gcx-event-category Map
     */
    (eventName: "MapZoomEndedEvent"): TypedEvent<{
        (extent: esri.geometry.Extent, zoomFactor: number, anchor: esri.geometry.Point, level: number): void;
    }>;
    /**
     * Raised during a zoom operation.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapZoomEvent
     * @param extent The current extent of the map.
     * @param zoomFactor Represents the percentage that the map zoomed in or out from the previous extent.
     * @param anchor The position of the cursor in screen-space.
     * @introduced 1.0
     * @gcx-event-category Map
     */
    (eventName: "MapZoomEvent"): TypedEvent<{
        (extent: esri.geometry.Extent, zoomFactor: number, anchor: esri.geometry.Point): void;
    }>;
    /**
     * Raised when a map zoom operation begins.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MapZoomStartedEvent
     * @param extent The current extent of the map.
     * @param zoomFactor Represents the percentage that the map zoomed in or out from the previous extent.
     * @param anchor The position of the cursor in screen-space.
     * @param level The level of a tiled map service at the start of a zoom.
     * @introduced 1.1
     * @gcx-event-category Map
     */
    (eventName: "MapZoomStartedEvent"): TypedEvent<{
        (extent: esri.geometry.Extent, zoomFactor: number, anchor: esri.geometry.Point, level: number): void;
    }>;
    /**
     * Raised when a marker is clicked.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MarkerClickedEvent
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.MarkerPointerEventArgs} object with the following properties: `id`, `graphic`, `mapPoint`, `screenPoint` and `button`.
     * @introduced 2.5
     * @private
     */
    (eventName: "MarkerClickedEvent"): TypedEvent<{
        (args: MarkerPointerEventArgs): void;
    }>;
    /**
     * Raised when a marker stops dragging (pointer has been released).
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MarkerDragEndEvent
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.MarkerDragEventArgs} object with the following properties: `id`, `centerPoint`, `mapPoint` and `screenPoint`.
     * @introduced 2.5
     * @private
     */
    (eventName: "MarkerDragEndEvent"): TypedEvent<{
        (args: MarkerDragEventArgs): void;
    }>;
    /**
     * Raised when a marker is being dragged.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MarkerDragEvent
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.MarkerDragEventArgs} object with the following properties: `id`, `centerPoint`, `mapPoint` and `screenPoint`.
     * @introduced 2.5
     * @private
     */
    (eventName: "MarkerDragEvent"): TypedEvent<{
        (args: MarkerDragEventArgs): void;
    }>;
    /**
     * Raised when a marker begins dragging.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MarkerDragStartEvent
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.MarkerDragEventArgs} object with the following properties: `id`, `centerPoint`, `mapPoint` and `screenPoint`.
     * @introduced 2.5
     * @private
     */
    (eventName: "MarkerDragStartEvent"): TypedEvent<{
        (args: MarkerDragEventArgs): void;
    }>;
    /**
     * Raised when a pointer input is pressed down on a marker.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MarkerPointerDownEvent
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.MarkerPointerEventArgs} object with the following properties: `id`, `graphic`, `mapPoint`, `screenPoint` and `button`.
     * @introduced 2.5
     * @private
     */
    (eventName: "MarkerPointerDownEvent"): TypedEvent<{
        (args: MarkerPointerEventArgs): void;
    }>;
    /**
     * Raised when a pointer input is pressed up on a marker.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MarkerPointerUpEvent
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.MarkerPointerEventArgs} object with the following properties: `id`, `graphic`, `mapPoint`, `screenPoint` and `button`.
     * @introduced 2.5
     * @private
     */
    (eventName: "MarkerPointerUpEvent"): TypedEvent<{
        (args: MarkerPointerEventArgs): void;
    }>;
    /**
     * Raised when a marker is updated.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MarkerUpdatedEvent
     * @param graphic The marker graphic that was updated.
     * @introduced 2.5
     * @private
     */
    (eventName: "MarkerUpdatedEvent"): TypedEvent<{
        (graphic: esri.Graphic): void;
    }>;
    /**
     * Raised when markup is added to the map.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MarkupAddedEvent
     * @param graphic The Esri graphic that is added.
     * @introduced 2.0
     * @gcx-event-category Markup
     */
    (eventName: "MarkupAddedEvent"): TypedEvent<{
        (graphic: esri.Graphic): void;
    }>;
    /**
     * Raised when markup is cleared from the map.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MarkupClearedEvent
     * @introduced 2.0
     * @gcx-event-category Markup
     */
    (eventName: "MarkupClearedEvent"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised when markup is deleted from the map.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MarkupDeletedEvent
     * @param graphic The Esri graphic that is deleted.
     * @introduced 2.0
     * @gcx-event-category Markup
     */
    (eventName: "MarkupDeletedEvent"): TypedEvent<{
        (graphic: esri.Graphic): void;
    }>;
    /**
     * Raised when editing of a specific piece of markup begins.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MarkupEditingStartedEvent
     * @param graphic The Esri graphic that is being edited.
     * @introduced 2.0
     * @gcx-event-category Markup
     */
    (eventName: "MarkupEditingStartedEvent"): TypedEvent<{
        (graphic: esri.Graphic): void;
    }>;
    /**
     * Raised when editing of a specific piece of markup ends.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MarkupEditingStoppedEvent
     * @param graphic The Esri graphic that is no longer being edited.
     * @introduced 2.0
     * @gcx-event-category Markup
     */
    (eventName: "MarkupEditingStoppedEvent"): TypedEvent<{
        (graphic: esri.Graphic): void;
    }>;
    /**
     * Raised when the type of markup being configured has changed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MarkupSymbolChangedEvent
     * @param symbol An esri.symbol.Symbol with the current markup style.
     * @introduced 2.8
     * @gcx-event-category Markup
     */
    (eventName: "MarkupSymbolChangedEvent"): TypedEvent<{
        (symbol: esri.symbol.Symbol): void;
    }>;
    /**
     * Raised when markup has been updated on the map.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MarkupUpdatedEvent
     * @param graphic The Esri graphic that was updated.
     * @introduced 2.5
     * @gcx-event-category Markup
     */
    (eventName: "MarkupUpdatedEvent"): TypedEvent<{
        (graphic: esri.Graphic): void;
    }>;
    /**
     * Raised when the type of markup being configured has changed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MarkupTypeChangedEvent
     * @param type One of "point" "polyline" "polygon" or "text"
     * @introduced 2.8
     * @gcx-event-category Markup
     */
    (eventName: "MarkupTypeChangedEvent"): TypedEvent<{
        (type: string): void;
    }>;
    /**
     * Raised when a measurement is opened in the markup editor.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MeasurementEditingStartedEvent
     * @param args The event arguments, with the following properties: `graphic`.
     * `graphic` represents the Esri graphic that has been selected.
     * @introduced 2.5
     * @gcx-event-category Measurement
     */
    (eventName: "MeasurementEditingStartedEvent"): TypedEvent<{
        (args: {
            graphic: esri.Graphic;
        }): void;
    }>;
    /**
     * Raised when a measurement markup is successfully and completely added without errors for a given geometry, including all applicable measurements and labels.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MeasurementMarkupAdded
     * @param args The event arguments, with the following properties: `graphic`, `measurementDescriptor`.
     * `graphic` represents the Esri graphic that was added;
     * `measurementDescriptor` represents the descriptor object for the currently added markup that contains information about all the measurement properties.
     * @introduced 2.0
     * @gcx-event-category Measurement
     */
    (eventName: "MeasurementMarkupAdded"): TypedEvent<{
        (args: {
            graphic: esri.Graphic;
            measurementDescriptor: any;
        }): void;
    }>;
    /**
     * Raised when a measurement markup is successfully and completely added without errors for a given geometry, including all applicable measurements and labels.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MeasurementMarkupDeleted
     * @param args The event arguments, with the following properties: `graphic`, `measurementDescriptor`.
     * `graphic` represents the Esri graphic that was deleted;
     * `measurementDescriptor` represents the descriptor object for the currently deleted markup that contains information about all the measurement properties.
     * @introduced 2.0
     * @gcx-event-category Measurement
     */
    (eventName: "MeasurementMarkupDeleted"): TypedEvent<{
        (args: {
            graphic: esri.Graphic;
            measurementDescriptor: any;
        }): void;
    }>;
    /**
     * Raised when an item in a menu is activated.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name MenuItemInvokedEvent
     * @param args The event arguments, with the following properties: `menuView`, `menuId` and `menuItem`.
     * `menuView` is the {@link essentialsHtmlViewer.mapping.infrastructure.menus.MenuView}.
     * `menuId` is the ID of the menu.
     * `menuItem` is the menu item itself.
     * @introduced 2.4
     * @gcx-event-category Menus
     */
    (eventName: "MenuItemInvokedEvent"): TypedEvent<{
        (args: {
            menuView: MenuView;
            menuId: string;
            menuItem: MenuItemViewModel;
        }): void;
    }>;
    /**
     * Raised when the offline manager has finished loading the offline maps from storage.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name OfflineMapsLoadedEvent
     * @param args Details of the event.ProjectEditorFinishedEventArgs
     * @introduced 2.6
     * @gcx-event-category Offline Maps
     */
    (eventName: "OfflineMapsLoadedEvent"): TypedEvent<{
        (args: OfflineMapsLoadedEventArgs): void;
    }>;
    /**
    * Raised when a user has made edits to their offline map
    * @docs-gcx-event geocortex.essentialsHtmlViewer
    * @name OfflineMapEditedEvent
    * @introduced 2.7
    * @gcx-event-category Offline Maps
    */
    (eventName: "OfflineMapEditedEvent"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised when a new offline map has been added to the offline manager.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name OfflineMapAddedEvent
     * @param args Details of the event.
     * @introduced 2.6
     * @gcx-event-category Offline Maps
     */
    (eventName: "OfflineMapAddedEvent"): TypedEvent<{
        (args: OfflineMapAddedEventArgs): void;
    }>;
    /**
     * Raised when a new offline map has been added to the offline manager.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name OfflineMapRemovedEvent
     * @param args Details of the event.
     * @introduced 2.6
     * @gcx-event-category Offline Maps
     */
    (eventName: "OfflineMapRemovedEvent"): TypedEvent<{
        (args: OfflineMapRemovedEventArgs): void;
    }>;
    /**
     * Raised when an offline map has been activated (or null offlineMap arg for none).
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name OfflineMapActivatedEvent
     * @param args Details of the event.
     * @introduced 2.6
     * @gcx-event-category Offline Maps
     */
    (eventName: "OfflineMapActivatedEvent"): TypedEvent<{
        (args: OfflineMapActivatedEventArgs): void;
    }>;
    /**
     * Raised when the offline map editor has finished.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name OfflineMapEditorFinishedEvent
     * @param args Details of the event.
     * @introduced 2.6
     * @gcx-event-category Offline Maps
     */
    (eventName: "OfflineMapEditorFinishedEvent"): TypedEvent<{
        (args: OfflineMapEditorFinishedEventArgs): void;
    }>;
    /**
     * Raised when a new offline map has been synced.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name OfflineMapSyncedEvent
     * @param args Details of the event.
     * @introduced 2.6
     * @gcx-event-category Offline Maps
     */
    (eventName: "OfflineMapSyncedEvent"): TypedEvent<{
        (args: OfflineMapSyncedEventArgs): void;
    }>;
    /**
     * Raised when an offline map sync error occurs. Either on initial download or subsequent sync.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name OfflineMapSyncErrorEvent
     * @param args Details of the event.
     * @introduced 2.8
     * @gcx-event-category Offline Maps
     */
    (eventName: "OfflineMapSyncErrorEvent"): TypedEvent<{
        (args: OfflineMapSyncErrorEventArgs): void;
    }>;
    /**
     * Raised when a named selection has been changed in any way. Renaming a selection raises this event.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name SelectionChangedEvent
     * @param args The event arguments, with the following properties: `name`, `fsc, `previousName`.
     * @introduced 2.6
     * @gcx-event-category Named Selection
     */
    (eventName: "SelectionChangedEvent"): TypedEvent<{
        (args: SelectionChangedEventArgs): void;
    }>;
    /**
     * Raised when named selection has been successfully saved.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name SelectionCreatedEvent
     * @param args The event arguments, with the following properties: `name`, `fsc.
     * @introduced 2.6
     * @gcx-event-category Named Selection
     */
    (eventName: "SelectionCreatedEvent"): TypedEvent<{
        (args: SelectionEventArgs): void;
    }>;
    /**
     * Raised when named selection has been removed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name SelectionRemovedEvent
     * @param args The event arguments, with the following properties: `name`, `fsc.
     * @introduced 2.6
     * @gcx-event-category Named Selection
     */
    (eventName: "SelectionRemovedEvent"): TypedEvent<{
        (args: SelectionEventArgs): void;
    }>;
    /**
     * Raised when a smart panel starts to be resized.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name PanelResizeStartEvent
     * @param graphic An object with the following properties: `viewId` and `resizeInformation`.
     * `viewId` represents the ID of the view.
     * `resizeInformation` represents a {@link ResizeInformation} object that contains information about the resizing operation.
     * @introduced 2.4
     * @gcx-event-category Interface
     */
    (eventName: "PanelResizeStartEvent"): TypedEvent<{
        (args: {
            viewId: string;
            resizeInformation: ResizeInformation;
        }): void;
    }>;
    /**
     * Raised as a smart panel is resized.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name PanelResizingEvent
     * @param graphic An object with the following properties: `viewId` and `resizeInformation`.
     * `viewId` represents the ID of the view.
     * `resizeInformation` represents a {@link ResizeInformation} object that contains information about the resizing operation.
     * @introduced 2.4
     * @gcx-event-category Interface
     */
    (eventName: "PanelResizingEvent"): TypedEvent<{
        (args: {
            viewId: string;
            resizeInformation: ResizeInformation;
        }): void;
    }>;
    /**
     * Raised when the resizing operation for a smart panel is completed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name PanelResizeEndEvent
     * @param graphic An object with the following properties: `viewId` and `resizeInformation`.
     * `viewId` represents the ID of the view.
     * `resizeInformation` represents a {@link ResizeInformation} object that contains information about the resizing operation.
     * @introduced 2.4
     * @gcx-event-category Interface
     */
    (eventName: "PanelResizeEndEvent"): TypedEvent<{
        (args: {
            viewId: string;
            resizeInformation: ResizeInformation;
        }): void;
    }>;
    /**
     * Raised when user selecte a different print layout.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name PrintPreviewLayoutChangedEvent
     * @introduced 2.6
     * @gcx-event-category Print
     */
    (eventName: "PrintPreviewLayoutChangedEvent"): TypedEvent<{
        (): void;
    }>;
    /**
    * Raised when user selecte a different print scale.
    * @docs-gcx-event geocortex.essentialsHtmlViewer
    * @name PrintPreviewScaleChangedEvent
    * @introduced 2.6
    * @gcx-event-category Print
    */
    (eventName: "PrintPreviewScaleChangedEvent"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised when a request to print a template is sent to the server.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name PrintTemplateStartedEvent
     * @param template The print template to be generated.
     * @introduced 2.5
     * @gcx-event-category Print
     */
    (eventName: "PrintTemplateStartedEvent"): TypedEvent<{
        (template: PrintTemplate): void;
    }>;
    /**
     * Raised when a print template operation has completed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name PrintTemplateCompletedEvent
     * @param template The print template used.
     * @introduced 2.5
     * @gcx-event-category Print
     */
    (eventName: "PrintTemplateCompletedEvent"): TypedEvent<{
        (template: PrintTemplate): void;
    }>;
    /**
     * Raised when a print template operation has errored.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name PrintTemplateErrorEvent
     * @param error The error that occurred.
     * @introduced 2.7
     * @gcx-event-category Print
     */
    (eventName: "PrintTemplateErrorEvent"): TypedEvent<{
        (error: Error): void;
    }>;
    /**
     * Raised when a project is successfully deleted.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ProjectDeletedEvent
     * @param project The ID of the project that was deleted.
     * @introduced 2.6
     * @gcx-event-category Projects
     */
    (eventName: "ProjectDeletedEvent"): TypedEvent<{
        (projectId: string): void;
    }>;
    /**
     * Raised when a project has begun being deleted.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ProjectDeletingEvent
     * @param project The ID of the project that is being deleted.
     * @introduced 2.6
     * @gcx-event-category Projects
     */
    (eventName: "ProjectDeletingEvent"): TypedEvent<{
        (projectId: string): void;
    }>;
    /**
     * Raised when the project editor has finished editing.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ProjectEditorFinishedEvent
     * @param args A {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.ProjectEditorFinishedEventArgs} object with the following properties: `canceled`, `existingProject`, and `newProject`.
     * @introduced 2.6
     * @gcx-event-category Projects
     */
    (eventName: "ProjectEditorFinishedEvent"): TypedEvent<{
        (args: ProjectEditorFinishedEventArgs): void;
    }>;
    /**
     * Raised when an attempt to save, load, or delete a project fails.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ProjectErrorEvent
     * @param project The project that caused the error.
     * @param error The error that occurred.
     * @introduced 2.6
     * @gcx-event-category Projects
     */
    (eventName: "ProjectErrorEvent"): TypedEvent<{
        (project: Project, error: Error): void;
    }>;
    /**
     * Raised when a project is successfully loaded and applied.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ProjectLoadedEvent
     * @param project The project that was loaded.
     * @introduced 2.6
     * @gcx-event-category Projects
     */
    (eventName: "ProjectLoadedEvent"): TypedEvent<{
        (project: Project): void;
    }>;
    /**
     * Raised when a project has begun loading.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ProjectLoadingEvent
     * @param projectId The ID of the project that is loading.
     * @introduced 2.6
     * @gcx-event-category Projects
     */
    (eventName: "ProjectLoadingEvent"): TypedEvent<{
        (projectId: string): void;
    }>;
    /**
     * Raised when a project is successfully saved.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ProjectSavedEvent
     * @param project The project that was saved.
     * @introduced 2.6
     * @gcx-event-category Projects
     */
    (eventName: "ProjectSavedEvent"): TypedEvent<{
        (project: Project): void;
    }>;
    /**
     * Raised when a project has begun saving.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ProjectSavingEvent
     * @param project The project that is saving.
     * @introduced 2.6
     * @gcx-event-category Projects
     */
    (eventName: "ProjectSavingEvent"): TypedEvent<{
        (project: Project): void;
    }>;
    /**
     * Raised when a pushpin has been clicked.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name PushpinClickedEvent
     * @param graphic An instance of {@link esri.Graphic} that represents the pushpin being clicked.
     * @introduced 2.1
     * @gcx-event-category Pushpins
     */
    (eventName: "PushpinClickedEvent"): TypedEvent<{
        (graphic: esri.Graphic): void;
    }>;
    /**
     * Raised when the mouse first enters the bounding area of a pushpin.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name PushpinMouseEnterEvent
     * @param graphic An {@link esri.Graphic} that represents the pushpin where the mouse pointer is hovering.
     * @introduced 2.1
     * @gcx-event-category Pushpins
     */
    (eventName: "PushpinMouseEnterEvent"): TypedEvent<{
        (graphic: esri.Graphic): void;
    }>;
    /**
     * Raised when the mouse exits the bounding area of a pushpin.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name PushpinMouseLeaveEvent
     * @param graphic An instance of {@link esri.Graphic} that represents the pushpin where the mouse pointer was previously hovering.
     * @introduced 2.1
     * @gcx-event-category Pushpins
     */
    (eventName: "PushpinMouseLeaveEvent"): TypedEvent<{
        (graphic: esri.Graphic): void;
    }>;
    /**
     * Raised when the left mouse button is pressed down while the mouse cursor is on a pushpin.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name PushpinMouseButtonDownEvent
     * @param graphic An instance of {@link esri.Graphic} that represents the pushpin where the left mouse button was pressed down.
     * @introduced 2.1
     * @gcx-event-category Pushpins
     */
    (eventName: "PushpinMouseLeftButtonDownEvent"): TypedEvent<{
        (graphic: esri.Graphic): void;
    }>;
    /**
     * Raised when the left mouse button is released while the mouse cursor is on a pushpin.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name PushpinMouseButtonUpEvent
     * @param graphic An instance of {@link esri.Graphic} that represents the pushpin where the left mouse button was released.
     * @introduced 2.1
     * @gcx-event-category Pushpins
     */
    (eventName: "PushpinMouseLeftButtonUpEvent"): TypedEvent<{
        (graphic: esri.Graphic): void;
    }>;
    /**
     * Raised when the right mouse button is pressed down while the mouse cursor is on a pushpin.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name PushpinMouseButtonDownEvent
     * @param graphic An instance of {@link esri.Graphic} that represents the pushpin where the right mouse button was pressed down.
     * @introduced 2.1
     * @gcx-event-category Pushpins
     */
    (eventName: "PushpinMouseRightButtonDownEvent"): TypedEvent<{
        (graphic: esri.Graphic): void;
    }>;
    /**
     * Raised when the right mouse button is released while the mouse cursor is on a pushpin.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name PushpinMouseButtonUpEvent
     * @param graphic An instance of {@link esri.Graphic} that represents the pushpin where the right mouse button was released.
     * @introduced 2.1
     * @gcx-event-category Pushpins
     */
    (eventName: "PushpinMouseRightButtonUpEvent"): TypedEvent<{
        (graphic: esri.Graphic): void;
    }>;
    /**
    * Raised after a query is completed using the query builder tool.
    * @docs-gcx-event geocortex.essentialsHtmlViewer
    * @name QueryCompletedEvent
    * @param args An {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.QueryCompletedEventArgs} object with the following properties: `layer`, 'query' and `error` (optional).
    * @introduced 2.7
    * @gcx-event-category Query
    */
    (eventName: "QueryCompletedEvent"): TypedEvent<{
        (args: QueryCompletedEventArgs): void;
    }>;
    /**
    * Raised after the saved query collection is changed
    * @docs-gcx-event geocortex.essentialsHtmlViewer
    * @name SavedQueriesChangedEvent
    * @introduced 2.8
    * @gcx-event-category Query
    */
    (eventName: "SavedQueriesChangedEvent"): TypedEvent<{
        (): void;
    }>;
    /**
    * Raised after the saved filters collection is changed
    * @docs-gcx-event geocortex.essentialsHtmlViewer
    * @name SavedFiltersChangedEvent
    * @introduced 2.8
    * @gcx-event-category Query
    */
    (eventName: "SavedFiltersChangedEvent"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised after the Undo Manager performs a redo operation.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name RedoCompletedEvent
     * @param args An {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.UndoRedoEventArgs`} object with the following properties: `sender` and `operation` (optional).
     * `sender` is a reference to the sender.
     * `operation` is the operation that triggered the event.
     * @introduced 2.5
     * @gcx-event-category Undo and Redo
     */
    (eventName: "RedoCompletedEvent"): TypedEvent<{
        (args: UndoRedoEventArgs): void;
    }>;
    /**
     * Raised when a redo operation begins.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name RedoStartedEvent
     * @param args An {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.UndoRedoEventArgs} object with the following properties: `sender` and `operation` (optional).
     * `sender` is a reference to the sender.
     * `operation` is the operation that triggered the event.
     * @introduced 2.5
     * @gcx-event-category Undo and Redo
     */
    (eventName: "RedoStartedEvent"): TypedEvent<{
        (args: UndoRedoEventArgs): void;
    }>;
    /**
     * Raised when a new related record has been created.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name RelatedRecordCreatedEvent
     * @param feature The new record that has been created.
     * @introduced 2.3
     * @gcx-event-category Editing
     */
    (eventName: "RelatedRecordCreatedEvent"): TypedEvent<{
        (feature: esri.Graphic): void;
    }>;
    /**
     * Raised when an existing related record has been edited.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name RelatedRecordCreatedEvent
     * @param feature The record that has been edited.
     * @introduced 2.3
     * @gcx-event-category Editing
     */
    (eventName: "RelatedRecordEditedEvent"): TypedEvent<{
        (feature: esri.Graphic): void;
    }>;
    /**
     * Raised when a request to print a layer report template is sent to the server.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ReportTemplateStartedEvent
     * @param reportId The ID of the layer report template.
     * @param mapServiceId The ID of the map service containing the layer with the report template.
     * @param layerId The ID of the layer with the configured report template.
     * @introduced 2.5
     * @gcx-event-category Print
     */
    (eventName: "ReportTemplateStartedEvent"): TypedEvent<{
        (reportId: string, mapServiceId: string, layerId: string): void;
    }>;
    /**
     * Raised when a layer report print template operation has completed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ReportTemplateCompletedEvent
     * @param reportId The ID of the layer report template.
     * @param mapServiceId The ID of the map service containing the layer with the report template.
     * @param layerId The ID of the layer with the configured report template.
     * @introduced 2.5
     * @gcx-event-category Print
     */
    (eventName: "ReportTemplateCompletedEvent"): TypedEvent<{
        (reportId: string, mapServiceId: string, layerId: string): void;
    }>;
    /**
     * Raised when a `RunReport` command is executed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ReportStartedEvent
     * @param reportId The ID of the layer report template.
     * @param mapServiceId The ID of the map service that is being used by the report.
     * @param layerId The ID of the layer that is being used by the report.
     * @introduced 2.7
     * @gcx-event-category Reporting
     */
    (eventName: "ReportStartedEvent"): TypedEvent<{
        (reportId: string, mapServiceId: string, layerId: string);
    }>;
    /**
     * The result of a successful `RunReport` command, which contains a download link to the report file.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ReportResultEvent
     * @param result A {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.ReportResultEventArgs} object with the following properties: `isAsync` and `href`.
     * `isAsync` is a boolean indicating whether the report result was asynchronous.
     * `href` is the download URL for the resultant report file.  In async mode, this is the URL to the report progress or download page.
     * @introduced 2.5
     * @gcx-event-category Reporting
     */
    (eventName: "ReportResultEvent"): TypedEvent<{
        (result: ReportResultEventArgs);
    }>;
    /**
     * Raised when a `RunReport` command fails in error.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ReportErrorEventl
     * @param error The Error object returned by the Report JavaScript API.
     * @introduced 2.5
     * @gcx-event-category Reporting
     */
    (eventName: "ReportErrorEvent"): TypedEvent<{
        (error: Error);
    }>;
    /**
     * When a feature is clicked in the results list view.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ResultsListFeatureClickedEvent
     * @param feature The feature that was clicked.
     * @introduced 1.0
     * @gcx-event-category Interface
     */
    (eventName: "ResultsListFeatureClickedEvent"): TypedEvent<{
        (feature: Feature): void;
    }>;
    /**
     * When a feature is pressed using a long press in the results list view.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ResultsListFeaturePressedEvent
     * @param feature The feature that was pressed.
     * @introduced 1.0
     * @gcx-event-category Interface
     */
    (eventName: "ResultsListFeaturePressedEvent"): TypedEvent<{
        (feature: Feature): void;
    }>;
    /**
     * When the current page of results has changed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ResultsPageChangedEvent
     * @param args An object that represents the new page of results, and contains the following properties: `featureSetCollection`, `newValue`.
     * @introduced 2.3
     * @gcx-event-category Interface
     */
    (eventName: "ResultsPageChangedEvent"): TypedEvent<{
        (args: ResultsPageChangedEventArgs): void;
    }>;
    /**
     * When a feature is clicked in the results table view.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ResultsTableFeatureClickedEvent
     * @param feature The feature that was clicked.
     * @introduced 1.0
     * @gcx-event-category Interface
     */
    (eventName: "ResultsTableFeatureClickedEvent"): TypedEvent<{
        (feature: Feature): void;
    }>;
    /**
     * When a feature is pressed using a long press in the results table view.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ResultsTableFeaturePressedEvent
     * @param feature The feature that was pressed.
     * @introduced 1.0
     * @gcx-event-category Interface
     */
    (eventName: "ResultsTableFeaturePressedEvent"): TypedEvent<{
        (feature: Feature): void;
    }>;
    /**
     * Raised when the Results view is collapsed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ResultsViewCollapsedEvent
     * @param view The view that was collapsed.
     * @introduced 2.1
     * @gcx-event-category Interface
     */
    (eventName: "ResultsViewCollapsedEvent"): TypedEvent<{
        (view: ViewBase): void;
    }>;
    /**
     * Raised when the Results view is opened.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ResultsViewOpenedEvent
     * @param view The view that was opened.
     * @introduced 2.1
     * @gcx-event-category Interface
     */
    (eventName: "ResultsViewOpenedEvent"): TypedEvent<{
        (view: ViewBase): void;
    }>;
    /**
     * Raised when the Results view is closed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ResultsViewClosedEvent
     * @param view The view that was closed.
     * @introduced 2.6
     * @gcx-event-category Interface
     */
    (eventName: "ResultsViewClosedEvent"): TypedEvent<{
        (view: ViewBase): void;
    }>;
    /**
     * Raised when progress updates are available for a search that is in progress.
     * The progress event may represent an error, failure, success etc.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name SearchProgressEvent
     * @param eventArgs An instance of {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.SearchProgressEventArgs}.
     * @introduced 1.1
     * @gcx-event-category Search
     */
    (eventName: "SearchProgressEvent"): TypedEvent<{
        (eventArgs: SearchProgressEventArgs): void;
    }>;
    /**
     * Raised when a search hint is clicked in the search auto-complete drop down.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name SearchHintClickedEvent
     * @param hintItem An instance of {@link essentialsHtmlViewer.mapping.infrastructure.search.SearchHinItem}.
     * @introduced 2.0
     * @gcx-event-category Search
     */
    (eventName: "SearchHintClickedEvent"): TypedEvent<{
        (eventArgs: SearchHintItem): void;
    }>;
    /**
     * Raised when a user is not authorized for a site. This event is fired instead of SiteInitializationFailedEvent.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name SiteAuthorizationFailedEvent
     * @param error The error that caused authorization to fail.
     * @introduced 1.2
     * @gcx-event-category Start-Up, Initialization and Shutdown
     */
    (eventName: "SiteAuthorizationFailedEvent"): TypedEvent<{
        (error: Error): void;
    }>;
    /**
     * Raised when the site fails to initialize. This event does not fire if SiteAuthorizationFailedEvent has fired.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name SiteInitializationFailedEvent
     * @param error The initialization error that prevented the site from successfully initializing.
     * @introduced 1.0
     * @gcx-event-category Start-Up, Initialization and Shutdown
     */
    (eventName: "SiteInitializationFailedEvent"): TypedEvent<{
        (error: Error): void;
    }>;
    /**
     * Raised when a site layer's initialization begins.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name SiteLayerLoadingEvent
     * @param layer The site layer that is initializing.
     * @introduced 2.5
     * @gcx-event-category Load
     */
    (eventName: "SiteLayerLoadingEvent"): TypedEvent<{
        (layer: Layer): void;
    }>;
    /**
     * Raised when a site layer is loaded.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name SiteLayerLoadedEvent
     * @param layer The site layer that is loaded.
     * @introduced 1.1
     * @gcx-event-category Load
     */
    (eventName: "SiteLayerLoadedEvent"): TypedEvent<{
        (layer: Layer): void;
    }>;
    /**
     * Raised when a site layer fails to load.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name SiteLayerLoadFailedEvent
     * @param error The error object that explains why site layer failed to load.
     * @introduced 1.1
     * @gcx-event-category Load
     */
    (eventName: "SiteLayerLoadFailedEvent"): TypedEvent<{
        (error: Error): void;
    }>;
    /**
     * Raised when the site begins to initialize.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name SiteInitializingEvent
     * @param initArgs The Geocortex Essentials {@link essentials.Site} that is beginning to initialize.
     * @introduced 2.5
     * @gcx-event-category Start-Up, Initialization and Shutdown
     */
    (eventName: "SiteInitializingEvent"): TypedEvent<{
        (initArgs: Site): void;
    }>;
    /**
     * Raised when the site successfully initializes.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name SiteInitializedEvent
     * @param initArgs The Geocortex Essentials site object that was initialized.
     * @introduced 1.0
     * @gcx-event-category Start-Up, Initialization and Shutdown
     */
    (eventName: "SiteInitializedEvent"): TypedEvent<{
        (initArgs: Site): void;
    }>;
    /**
     * Raised when the site has finished loading and there are layers that failed to load.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name SiteServiceLayersFailedEvent
     * @param failedServices An array of geocortex.essentials.MapService objects that failed to load.
     * @introduced 1.3
     * @gcx-event-category Start-Up, Initialization and Shutdown
     */
    (eventName: "SiteServiceLayersFailedEvent"): TypedEvent<{
        (failedServices: MapService[]): void;
    }>;
    /**
     * Raised when all service layers in a site are loaded.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name SiteServiceLayersLoadedEvent
     * @param site The site object that holds service layers.
     * @introduced 1.1
     * @gcx-event-category Load
     */
    (eventName: "SiteServiceLayersLoadedEvent"): TypedEvent<{
        (site: Site): void;
    }>;
    /**
     * Raised when the viewer begins federated sign in.  The application may close at any time if
     * sign in happens in the same browser tab.  This differs from `UserSigningInEvent` in that
     * the sign in need not be initiated by the user and cannot be cancelled.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name SigningInEvent
     * @param args The event arguments, including a `url` that is the sign in page.
     * @introduced 2.4
     * @gcx-event-category Authentication and Authorization
     */
    (eventName: "SigningInEvent"): TypedEvent<{
        (args: {
            url: string;
        }): void;
    }>;
    /**
     * Raised when the viewer begins signing out.  The application may close at any time. This differs
     * from `UserSigningOutEvent` in that the sign out need not be initiated by the user and cannot be cancelled.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name SigningOutEvent
     * @introduced 2.4
     * @gcx-event-category Authentication and Authorization
     */
    (eventName: "SigningOutEvent"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised when the bottom panel is closed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name SmallBottomPanelClosedEvent
     * @introduced 2.6
     * @gcx-event-category Interface
     */
    (eventName: "SmallBottomPanelClosedEvent"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised when the top right region is about to close in the small shell.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name SmallShellTopRightRegionClosingEvent
     * @introduced 2.8
     * @gcx-event-category Interface
     */
    (eventName: "SmallShellTopRightRegionClosingEvent"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised when the top right region is about to open in the small shell.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name SmallShellTopRightRegionOpeningEvent
     * @introduced 2.8
     * @gcx-event-category Interface
     */
    (eventName: "SmallShellTopRightRegionOpeningEvent"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised when the SnappingModule handles input movement. Contains the original input location as well as a snapping point or `null` if none was found.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name SnappingFeedbackEvent
     * @param args A {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.SnappingFeedbackEventArgs} object with the following properties: `snappingPoint` and `inputPoint`.
     * `snappingPoint` is the snapping point, or null if there is none.
     * `inputPoint` is the original input point.
     * @introduced 2.5
     * @gcx-event-category Tool
     */
    (eventName: "SnappingFeedbackEvent"): TypedEvent<{
        (args: SnappingFeedbackEventArgs): void;
    }>;
    /**
     * Raised when the sync info is refreshed. Sync info has information about which
     * feature layers have been downloaded (synced).
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name SyncInfoRefreshedEvent
     * @introduced 2.8.1
     * @gcx-event-category Offline
     */
    (eventName: "SyncInfoRefreshedEvent"): TypedEvent<{
        (syncInfo: SyncInfoRefreshedEventArgs): void;
    }>;
    /**
     * Raised when the user chooses a template from the template picker.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name StartFeaturePlacementEvent
     * @introduced 2.5
     * @gcx-event-category Tool
     */
    (eventName: "StartFeaturePlacementEvent"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised when an application state is entered by a triggering command or event.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name StateEnteredEvent
     * @param args A {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.StateChangedEventArgs} object with the following properties: `stateDefinition`, `activeStates`, `modalState` and `previousModalState`.
     * `stateDefinition` defines the state that was entered.
     * `activeStates` is an array of active states.
     * `modalState` is the currently active global state (if any).
     * `previousModalState` is the previous global state (if any).
     * @introduced 2.5
     * @gcx-event-category Interface
     */
    (eventName: "StateEnteredEvent"): TypedEvent<{
        (args: StateChangedEventArgs): void;
    }>;
    /**
     * Raised when an application state is exited by a triggering command or event.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name StateEnteredEvent
     * @param args A {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.StateChangedEventArgs} object with the following properties: `stateDefinition`, `activeStates`, `modalState` and `previousModalState`.
     * `stateDefinition` defines the state that was entered.
     * `activeStates` is an array of active states.
     * `modalState` is the currently active global state (if any).
     * `previousModalState` is the previous global state (if any).
     * @introduced 2.5
     * @gcx-event-category Interface
     */
    (eventName: "StateExitedEvent"): TypedEvent<{
        (args: StateChangedEventArgs): void;
    }>;
    /**
     * Raised after a user places a new feature on the map to be opened in the editor.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name StopFeaturePlacementEvent
     * @introduced 2.5
     * @gcx-event-category Tool
     */
    (eventName: "StopFeaturePlacementEvent"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised after a new time slider profile is set.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name TimeSliderProfileChanged
     * @param profile A {@link essentials.TimeSliderProfile} object.
     * @introduced 2.7
     * @gcx-event-category TimeSlider
     */
    (eventName: "TimeSliderProfileChangedEvent"): TypedEvent<{
        (profile: TimeSliderProfile): void;
    }>;
    /**
     * Raised when the current timeslider profile starts playing.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name TimeSliderPlayTimelineStartedEvent
     * @param profile The current {@link essentials.TimeSliderProfile} object.
     * @introduced 2.7
     * @gcx-event-category TimeSlider
     */
    (eventName: "TimeSliderPlayTimelineStartedEvent"): TypedEvent<{
        (profile: TimeSliderProfile): void;
    }>;
    /**
     * Raised when the current timeslider profile stops playing.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name TimeSliderPlayTimelineStoppedEvent
     * @param profile The current {@link essentials.TimeSliderProfile} object.
     * @introduced 2.7
     * @gcx-event-category TimeSlider
     */
    (eventName: "TimeSliderPlayTimelineStoppedEvent"): TypedEvent<{
        (profile: TimeSliderProfile): void;
    }>;
    /**
     * Raised when the time slider items move forward or backward.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name TimeSliderFrameChangedEvent
     * @param profile The current {@link essentials.TimeSliderProfile} object.
     * @introduced 2.9
     * @gcx-event-category TimeSlider
     */
    (eventName: "TimeSliderFrameChangedEvent"): TypedEvent<{
        (profile: TimeSliderProfile): void;
    }>;
    /**
     * Raised immediately after the command SetTimeSliderProfile is executed. Used to track the time slider playback state and profile before it is changed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name TimeSliderProfileChangingEvent
     * @param previousTimeSliderProfile The object containing the previous time slider profile and playback state.
     * `profile` is the previous {@link essentials.TimeSliderProfile} object.
     * `isPlayingBack` is a boolean of the previous playback state.
     * @introduced 2.9
     * @gcx-event-category TimeSlider
     */
    (eventName: "TimeSliderProfileChangingEvent"): TypedEvent<{
        (previousTimeSliderProfile: TimeSliderProfileChangingEventArgs): void;
    }>;
    /**
     * Raised after a toggle button changes its state.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ToggleButtonStateChangedEvent
     * @param args A {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.ToggleButtonStateChangedEventArgs} object with the following properties: `toggleButtonEntry` and `state`.
     * `toggleButtonEntry` is the {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.ToggleButtonStateChangedEventArgs} object that represents the toggle button entry.
     * `state` is the {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.ToggleButtonStateChangedEventArgs} object that represents the toggle button state.
     * @introduced 2.5
     * @gcx-event-category Tool
     */
    (eventName: "ToggleButtonStateChangedEvent"): TypedEvent<{
        (args: ToggleButtonStateChangedEventArgs): void;
    }>;
    /**
     * Raised when a button on the toolbar is clicked.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ToolbarButtonClickedEvent
     * @param args The object representing the clicked toolbar button with the following properties: `commandName`, `commandParameter`, `id`, `name` and `libraryId`.
     * `commandName` is the command name of the toolbar button.
     * `commandParameter` is the command parameter of the toolbar button.
     * `id` is the ID of the toolbar button.
     * `name` is the name of the toolbar button.
     * `libraryId` is the libaray ID of the toolbar button.
     * @introduced 2.5
     * @gcx-event-category Tool
     */
    (eventName: "ToolbarButtonClickedEvent"): TypedEvent<{
        (args: ToolbarButtonClickedEventArgs): void;
    }>;
    /**
     * Raised when a view tile is pressed in the toolbar in the small/handheld shell.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ToolbarViewTilePressedEvent
     * @param viewId The ID of the view whose tile was pressed.
     * @introduced 2.4
     * @gcx-event-category Interface
     */
    (eventName: "ToolbarViewTilePressedEvent"): TypedEvent<{
        (viewId: string): void;
    }>;
    /**
     * Raised when a multitool flyout menu is opened.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ToolbarFlyoutActivatedEvent
     * @param viewId The ID of the view whose multitool flyout menu opened.
     * @introduced 2.4
     * @gcx-event-category Interface
     */
    (eventName: "ToolbarFlyoutActivatedEvent"): TypedEvent<{
        (viewId: string): void;
    }>;
    /**
     * Raised when the input method (for example, keyboard or mouse) for the active tool has changed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ToolInputMethodChangedEvent
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.ToolInputMethodChangedEvent} object containing the following properties: `tool`, `newMethod` and `previousMethod`.
     * `tool` represents the tool whose input method changed.
     * `newMethod` represents the new input method.
     * `previousMethod` represents the previous input method.
     * @introduced 2.4
     * @gcx-event-category Tool
     */
    (eventName: "ToolInputMethodChangedEvent"): TypedEvent<{
        (args: ToolInputMethodChangedEvent): void;
    }>;
    /**
     * Raised when a multitool flyout menu is closed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ToolbarFlyoutDeactivatedEvent
     * @param viewId The ID of the view whose multitool flyout menu closed.
     * @introduced 1.0
     * @gcx-event-category Interface
     */
    (eventName: "ToolbarFlyoutDeactivatedEvent"): TypedEvent<{
        (viewId: string): void;
    }>;
    /**
     * Raised when a transient toolbar is activated.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name TransientActivatedEvent
     * @param args A {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.TransientActivatedEventArgs} object with the following properties: `stateName`, `viewId`, `regionId` and `widgetId`.
     * `stateName` is the state name.
     * `viewId` is the ID of the view.
     * `regionId` is the ID of the region.
     * `widgetId` is the ID of the widget.
     * @introduced 2.5
     * @gcx-event-category Tool
     */
    (eventName: "TransientActivatedEvent"): TypedEvent<{
        (args: TransientActivatedEventArgs): void;
    }>;
    /**
     * Raised when all transient toolbars are deactivated.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name TransientsDeactivatedEvent
     * @introduced 2.5
     * @gcx-event-category Tool
     */
    (eventName: "TransientsDeactivatedEvent"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised when active toolbar tab is changed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ToolbarTabChangedEvent
     * @param args A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.ToolbarTabChangedEventArgs} object with a `group` property referring to the currently selected toolbar tab.
     * @introduced 2.7
     * @gcx-event-category Tool
     */
    (eventName: "ToolbarTabChangedEvent"): TypedEvent<{
        (args: ToolbarTabChangedEventArgs): void;
    }>;
    /**
     * Raised when the last recorded operation has been reversed or rolled back by the Undo Manager.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name UndoCompletedEvent
     * @param args An {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.UndoRedoEventArgs} object with the following properties: `sender` and `operation` (optional).
     * `sender` is a reference to the sender.
     * `operation` is the operation that triggered the event.
     * @introduced 2.5
     * @gcx-event-category Undo and Redo
     */
    (eventName: "UndoCompletedEvent"): TypedEvent<{
        (args: UndoRedoEventArgs): void;
    }>;
    /**
     * Raised when a new undo operation is added to the undo stack.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name UndoOperationAddedEvent
     * @param args An {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.UndoRedoEventArgs} object with the following properties: `sender` and `operation` (optional).
     * `sender` is a reference to the sender.
     * `operation` is the operation that triggered the event.
     * @introduced 2.5
     * @gcx-event-category Undo and Redo
     */
    (eventName: "UndoOperationAddedEvent"): TypedEvent<{
        (args: UndoRedoEventArgs): void;
    }>;
    /**
     * Raised when an undo operation is discarded from the undo stack because the stack size exceeded the maximum number of operations.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name UndoOperationAddedEvent
     * @param args An {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.UndoRedoEventArgs} object with the following properties: `sender` and `operation` (optional).
     * `sender` is a reference to the sender.
     * `operation` is the operation that triggered the event.
     * @introduced 2.5
     * @gcx-event-category Undo and Redo
     */
    (eventName: "UndoOperationDiscardedEvent"): TypedEvent<{
        (args: UndoRedoEventArgs): void;
    }>;
    /**
     * Raised when an undo operation begins.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name UndoStartedEvent
     * @param args An {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.UndoRedoEventArgs} object with the following properties: `sender` and `operation` (optional).
     * `sender` is a reference to the sender.
     * `operation` is the operation that triggered the event.
     * @introduced 2.5
     * @gcx-event-category Undo and Redo
     */
    (eventName: "UndoStartedEvent"): TypedEvent<{
        (args: UndoRedoEventArgs): void;
    }>;
    /**
     * Raised when the undo stack changes.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name UndoStackChangedEvent
     * @param args An {@link essentialsHtmlViewer.mapping.infrastructure.eventArgs.UndoRedoEventArgs} object with the following properties: `sender` and `operation` (optional).
     * `sender` is a reference to the sender.
     * `operation` is the operation that triggered the event.
     * @introduced 2.5
     * @gcx-event-category Undo and Redo
     */
    (eventName: "UndoStackChangedEvent"): TypedEvent<{
        (args: UndoRedoEventArgs): void;
    }>;
    /**
     * Raised when an upload data process completes.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name UploadDataCompletedEvent
     * @param process The `UploadDataProcess` object containing all of the information about a given upload data process.
     * @introduced 2.6
     * @gcx-event-category Upload Data
     */
    (eventName: "UploadDataCompletedEvent"): TypedEvent<{
        (process: any): void;
    }>;
    /**
     * Raised when an upload data process fails.
     * @docs-gcx-event geocortex.UploadDataProcess
     * @name UploadDataFailedEvent
     * @param process The error that caused the upload data process to fail.
     * @introduced 2.6
     * @gcx-event-category Upload Data
     */
    (eventName: "UploadDataFailedEvent"): TypedEvent<{
        (error: Error): void;
    }>;
    /**
     * Raised when a user added layer or MapService is removed(Not raised when removed due to project restore).
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name UserAddedLayerOrMapServiceRemovedEvent
     * @param gcxLayer  The Geocortex layer or MapService which was removed.
     * @introduced 2.9.1
     * @gcx-event-category User Added Layer
     */
    (eventName: "UserAddedLayerOrMapServiceRemovedEvent"): TypedEvent<{
        (item: Layer | MapService): void;
    }>;
    /**
     * Raised when the user cancels the ArcGIS Online sign in process.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name UserSignInCancelledEvent
     * @param args The arguments containing a function callback called `tryAgainAction` with no parameters.
     * @introduced 1.3
     * @gcx-event-category Authentication and Authorization
     */
    (eventName: "UserSignInCancelledEvent"): TypedEvent<{
        (args: {
            tryAgainAction(): void;
        }): void;
    }>;
    /**
     * Raised when the user is about to navigate to the federated sign in page.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name UserSigningInEvent
     * @param eventArgs The event arguments, including an `isCancelled` flag that subscribers can set to cancel the sign-in.
     * @introduced 2.1
     * @gcx-event-category Authentication and Authorization
     */
    (eventName: "UserSigningInEvent"): TypedEvent<{
        (eventArgs: UserEventArgs): void;
    }>;
    /**
     * Raised when the user is about to sign out of the application.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name UserSigningOutEvent
     * @param eventArgs The event arguments, including an `isCancelled` flag that subscribers can set to cancel the sign-out.
     * @introduced 2.1
     * @gcx-event-category Authentication and Authorization
     */
    (eventName: "UserSigningOutEvent"): TypedEvent<{
        (eventArgs: UserEventArgs): void;
    }>;
    /**
     * Raised when the vertex edit handle is hidden.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name VertexHandleHiddenEvent
     * @introduced 2.5
     * @gcx-event-category Editing
     */
    (eventName: "VertexHandleHiddenEvent"): TypedEvent<{
        (): void;
    }>;
    /**
     * Raised when the vertex edit handle is shown.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name VertexHandleShownEvent
     * @param geometry The point geometry of the vertex handle.
     * @introduced 2.5
     * @gcx-event-category Editing
     */
    (eventName: "VertexHandleShownEvent"): TypedEvent<{
        (geometry: esri.geometry.Point): void;
    }>;
    /**
     * Raised when a view is activated inside a view container.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ViewActivatedInContainerEvent
     * @param view The view that was activated.
     * @introduced 1.1
     * @gcx-event-category Interface
     */
    (eventName: "ViewActivatedInContainerEvent"): TypedEvent<{
        (view: ViewBase): void;
    }>;
    /**
     * Raised when a ViewContainer View is closed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ViewContainerViewClosedEvent
     * @param eventArgs An instance of {@link geocortex.framework.ui.ViewContainer.ViewContainerViewClosedEventArgs}.
     * @introduced 1.1
     * @gcx-event-category Interface
     */
    (eventName: "ViewContainerViewClosedEvent"): TypedEvent<{
        (eventArgs: ViewContainerViewClosedEventArgs): void;
    }>;
    /**
     * Raised when a {@link essentialsHtmlViewer.integration.PostMessageTransport} has been wired up
     * with an external component and the viewers position has been updated.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ViewerPositionUpdatedEvent
     * @param arg An instance of {@link essentialsHtmlViewer.mapping.infrastructure.integration.MapViewpointMessage}, that represents the updated viewpoint of the viewer.
     * @introduced 2.4
     * @gcx-event-category Integration
     */
    (eventName: "ViewerPositionUpdatedEvent"): TypedEvent<{
        (arg: MapViewpointMessage): void;
    }>;
    /**
     * Raised when a viewpoint indicator of an external component has been updated on the viewer.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name ViewpointIndicatorUpdatedEvent
     * @param arg The point of the viewpoint indicator on the viewer. Contains the following properties: `x`, `y`.
     * @introduced 2.4
     * @gcx-event-category Integration
     */
    (eventName: "ViewpointIndicatorUpdatedEvent"): TypedEvent<{
        (arg: esri.geometry.Point): void;
    }>;
    /**
     * Raised when the visualization options view has been activated for a Geocortex layer.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name VisualizationViewActivatedEvent
     * @param gcxLayer The Geocortex layer.
     * @introduced 2.5
     * @gcx-event-category Visualization
     */
    (eventName: "VisualizationViewActivatedEvent"): TypedEvent<{
        (gcxLayer: Layer): void;
    }>;
    /**
     * Raised when the WebSocket successfully connects.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name WebSocketConnectedEvent
     * @param webSocket A {@link essentialsHtmlViewer.mapping.infrastructure.webSocket.WebSocketConnection} for the new connection.
     * @introduced 2.8
     * @gcx-event-category Collaboration
     */
    (eventName: "WebSocketConnectedEvent"): TypedEvent<{
        (webSocket: WebSocketConnection): void;
    }>;
    /**
     * Raised when the WebSocket disconnects.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name WebSocketDisconnected
     * @param webSocket A {@link essentialsHtmlViewer.mapping.infrastructure.webSocket.WebSocketConnection} for the closed connection.
     * @introduced 2.8
     * @gcx-event-category Collaboration
     */
    (eventName: "WebSocketDisconnectedEvent"): TypedEvent<{
        (webSocket: WebSocketConnection): void;
    }>;
    /**
     * Raised when a workflow is aborted.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name WorkflowAbortedEvent
     * @param workflow The workflow that aborted.
     * @introduced 1.1
     * @gcx-event-category Workflow
     */
    (eventName: "WorkflowAbortedEvent"): TypedEvent<{
        (workflow: Workflow): void;
    }>;
    /**
     * Raised when a workflow activity is completed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name WorkflowActivityCompletedEvent
     * @param workflow The workflow that includes the completed activity.
     * @introduced 1.1
     * @gcx-event-category Workflow
     */
    (eventName: "WorkflowActivityCompletedEvent"): TypedEvent<{
        (workflow: Workflow): void;
    }>;
    /**
     * Raised when a workflow activity fails to dispatch.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name WorkflowActivityDispatchErrorEvent
     * @param args An object with the following properties: `error`, `context`.
     * `error` represents the `Error` object that explains what went wrong.
     * `context` represents the `ActivityContext` object that holds parameters configured in the workflow.
     * @introduced 1.1
     * @gcx-event-category Workflow
     */
    (eventName: "WorkflowActivityDispatchErrorEvent"): TypedEvent<{
        (args: {
            error: Error;
            context: ActivityContext;
        }): void;
    }>;
    /**
     * Raised when a workflow activity begins execution.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name WorkflowActivityStartedEvent
     * @param workflow The workflow whose activity started.
     * @introduced 1.1
     * @gcx-event-category Workflow
     */
    (eventName: "WorkflowActivityStartedEvent"): TypedEvent<{
        (workflow: Workflow): void;
    }>;
    /**
     * Raised when a workflow execution is completed.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name WorkflowCompletedEvent
     * @param workflow The workflow that completed.
     * @introduced 1.1
     * @gcx-event-category Workflow
     */
    (eventName: "WorkflowCompletedEvent"): TypedEvent<{
        (workflow: Workflow, outputs: any): void;
    }>;
    /**
     * Raised when a single web request for a workflow completes. Note that a workflow typically consists of many
     * requests to the server.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name WorkflowWebRequestCompletedEvent
     * @param url The workflow request URL.
     * @param workflow The workflow for which the request was made.
     * @introduced 2.5
     * @gcx-event-category Workflow
     */
    (eventName: "WorkflowWebRequestCompletedEvent"): TypedEvent<{
        (url: string, workflow: Workflow): void;
    }>;
    /**
     * Raised when a single web request for a workflow is started. Note that a workflow typically consists of many
     * requests to the server.
     * @docs-gcx-event geocortex.essentialsHtmlViewer
     * @name WorkflowWebRequestStartedEvent
     * @param url The workflow request URL.
     * @param workflow The workflow for which the request was made.
     * @introduced 2.5
     * @gcx-event-category Workflow
     */
    (eventName: "WorkflowWebRequestStartedEvent"): TypedEvent<{
        (url: string, workflow: Workflow): void;
    }>;
}

}
declare module "geocortex/infrastructure/ExportTilesUtils" {
export interface ExportTilesParameters {
    /**
     * Allows exporting either a tile package or a cache raster data set. If the value is true,
     * output will be in tile package format, and if the value is false, a cache raster data set
     * is returned. The default value is false
     */
    tilePackage?: boolean;
    /**
     * The extent (bounding box) of the tile package or the cache dataset to be exported. If extent
     * does not include a spatial reference, the extent values are assumed to be in the spatial
     * reference of the map. The default value is full extent of the tiled map service.
     */
    exportExtent?: string;
    /**
     * Use this parameter to enable compression of JPEG tiles and reduce the size of the downloaded tile
     * package or the cache raster data set. Compressing tiles slightly compromises the quality of tiles
     * but helps reduce the size of the download.
     */
    optimizeTilesForSize?: boolean;
    /**
     * When optimizeTilesForSize=true, you can specify a compression factor. The value must be between 0 and 100.
     */
    compressionQuality?: number;
    /**
     * The criteria that will be used to select the tile service levels to export. The values can be Level IDs,
     * cache scales. or the resolution (in the case of image services).
     * Values: LevelID | Resolution | Scale
     */
    exportBy?: string;
    /**
     * Specifies the tiled service levels to export. The values should correspond to Level IDs, cache scales.
     * or the resolution as specified in exportBy parameter. The values can be comma separated values or a range.
     * Example 1: 1,2,3,4,5,6,7,8,9
     * Example 2: 1-4,7-9
     */
    levels?: string;
    /**
     * The areaOfInterest polygon allows exporting tiles within the specified polygon areas. This parameter
     * supersedes the exportExtent parameter.
     */
    areaOfInterest?: string;
    /**
     * Token required to access secured map service endpoint
     */
    token?: string;
}
export interface ExportTilesEstimate {
    totalSize: number;
    totalTilesToExport: number;
}
export interface DownloadableFile {
    name: string;
    url: string;
}
/**
 * Export tiles from a map service supporting the operation.
 * @param service The map service to export tiles from.
 * @param params Operation parameters.
 * @returns A promise of the URL(s) the newly exported tiles can be downloaded from.
 */
export function exportTiles(service: string | esri.layers.Layer, params: ExportTilesParameters): Promise<DownloadableFile[]>;
/**
 * Extimate the size of exported tiles from a map service supporting the operation.
 * @param service The map service to export tiles from.
 * @param params Operation parameters.
 * @returns A promise of an estimate of the size of the exported tiles.
 */
export function estimateExportTilesSize(service: string | esri.layers.Layer, params: ExportTilesParameters): Promise<ExportTilesEstimate>;

}
declare module "geocortex/infrastructure/Feature" {
import { Layer } from "geocortex/essentials/Layer";
import { TableRowViewModelInterface } from "geocortex/infrastructure/ui/components/Table/TableRowViewModelInterface";
import { FeatureSet } from "geocortex/infrastructure/FeatureSet";
import { LazyObservable } from "geocortex/framework-ui/LazyObservable";
import { Observable, ObservableCollection } from "geocortex/framework/observables";
import { FeatureAttribute } from "geocortex/infrastructure/FeatureAttribute";
import { FeatureHyperlink } from "geocortex/essentials/FeatureHyperlink";
import { AttachmentInfo } from "geocortex/infrastructure/AttachmentInfo";
import { AttributeGroup } from "geocortex/infrastructure/AttributeGroup";
import { DataLinkingResult } from "geocortex/infrastructure/DataLinkingResult";
export interface FeatureOptions {
    graphic?: esri.Graphic;
    layer?: Layer;
    featureLayer?: esri.layers.FeatureLayer;
    resolveLayerFields?: boolean;
    allowUnsafeContent?: boolean;
    timeZoneId?: string;
    displayTimeZoneId?: string;
}
export interface NameValueProperty {
    name: string;
    value: any;
}
/**
 * Observable view model for an ESRI Feature.
 */
export class Feature implements TableRowViewModelInterface {
    private _graphic;
    /**
     * Indicate if attachment infos are initialized
     * @private
     */
    private _isAttachmentInfosLoaded;
    /**
     * Default format to render the fields
     * @private
     */
    private _defaultFieldFormatString;
    /**
    * The token that should uniquely identify this feature for a specific application instance and run
    * @type AlphaNumeric token that *should* uniquely identify this feature
    */
    token: string;
    /**
     * The Layer this Feature is a part of.
     * @type geocortex.essentials.Layer
     */
    layer: Layer;
    /**
     * The esri feature layer associated with the feature.
     */
    featureLayer: esri.layers.FeatureLayer;
    /**
     * The last featureSet that this feature was added to.
     * @type FeatureSet
     */
    featureSet: FeatureSet;
    /**
    * The unique id's of the featureSets (if any) that currently contain this feature.
    * With the introduction of Save Selections, it is now possible for a feature to be added to multiple feature
    * sets simultaneously. The id of the latest featureSet that this feature is added to will be added to the end
    * of the arrray. This array is automatically managed when this feature is added to or removed from a featureSet.
    */
    featureSetUniqueIds: string[];
    /**
     * The label format this Feature uses to render a label.
     * @type String
     */
    labelFormat: LazyObservable<string>;
    /**
     * The configured min scale of the Feature.
     * @type Number
     */
    minScale: LazyObservable<number>;
    /**
     * The configured max scale of the Feature.
     * @type Number
     */
    maxScale: LazyObservable<number>;
    /**
     * The zoom scale of the Feature.
     * @type Number
     */
    zoomScale: LazyObservable<number>;
    /**
     * The zoom factor of the Feature.
     * @type Number
     */
    zoomFactor: LazyObservable<number>;
    /**
     * The zoom extent of the Feature.
     * @type Extent
     */
    zoomExtent: Observable<esri.geometry.Extent>;
    /**
     * The border color of the Feature.
     * @type String
     */
    borderColor: LazyObservable<number[]>;
    /**
    * The border width of the Feature.
    * @type Number
    */
    borderWidth: LazyObservable<number>;
    /**
     * The fill color of the Feature.
     * @type String
     */
    fillColor: LazyObservable<number[]>;
    /**
     * The id of the Feature.
     * @type Number
     */
    id: LazyObservable<string>;
    /**
     * The attributes for the Feature.
     * @type FeatureAttribute[]
     */
    attributes: ObservableCollection<FeatureAttribute>;
    /**
     * The label for the Feature.
     * @type String
     */
    label: LazyObservable<string>;
    /**
     * The plain label for the Feature, stripped of any HTML.
     * @type String
     */
    plainLabel: LazyObservable<string>;
    /**
     * The description for the Feature.
     * @type String
     */
    description: LazyObservable<string>;
    /**
     * The description format this Feature uses to render a description.
     * @type String
     */
    descriptionFormat: LazyObservable<string>;
    /**
     * The long description for the Feature.
     * @type String
     */
    longDescription: LazyObservable<string>;
    /**
     * The long description format this Feature uses to render a long description.
     * @type String
     */
    longDescriptionFormat: LazyObservable<string>;
    /**
     * The hyperlinks associated with the feature (if any)
     * @type FeatureHyperlink[]
     */
    hyperlinks: ObservableCollection<FeatureHyperlink>;
    /**
     * The extended properties for the Feature.
     * @type Array
     */
    extendedProperties: ObservableCollection<NameValueProperty>;
    /**
     * Get the attachment infos associated with the feature.
     * @type ObservableCollection
     */
    attachmentInfos: ObservableCollection<AttachmentInfo>;
    /**
     * Indicates that the attachmentInfos collection has been initialized.
     * @type Observable
     */
    attachmentInfosInitialized: Observable<boolean>;
    /**
     * Gets a value indicating whether the feature has attachments.
     * @type Boolean
     */
    hasAttachments: Observable<boolean>;
    /**
     * Gets a value indicating whether the feature has relationships.
     * @type Boolean
     */
    hasRelationships: Observable<boolean>;
    /**
     * Gets a value indicating whether the feature has visible relationships.
     * @type Boolean
     */
    hasVisibleRelationships: Observable<boolean>;
    /**
     * Gets a value indicating whether the feature has geometry attached.
     * @type Boolean
     */
    hasGeometry: LazyObservable<boolean>;
    /**
     * Gets a value indicating whether the feature has a valid geometry attached.
     * @type Boolean
     */
    hasValidGeometry: LazyObservable<boolean>;
    /**
     * Gets the Esri feature attached to the Geocortex feature.
     * @type esri.Graphic
     */
    esriFeature: Observable<esri.Graphic>;
    /** Observable public members - Layer config overrides */
    iconUri: LazyObservable<string>;
    /** linked data associated with a feature's linked attributes */
    linkedAttributes: ObservableCollection<AttributeGroup>;
    /** the features related data links */
    dataLinkingResults: ObservableCollection<DataLinkingResult>;
    /** The default format to use for displaying number fields that have no explicit format. */
    defaultNumberFormat: string;
    /** The default format to use for displaying date fields that have no explicit format. */
    defaultDateFormat: string;
    /** Whether the feature attribute data has been locally modified. */
    isModified: boolean;
    /** The IANA ID of the time zone in which this feature's field data are current.
      * Primarily used as a fallback when the FieldInfo object cannot access the appropriate ID.
      */
    timeZoneId: string;
    /** The IANA ID of the time zone in which this feature's field data will be displayed.
      * Primarily used as a fallback when the FieldInfo object cannot access the appropriate ID.
      */
    displayTimeZoneId: string;
    /**
     * Indicates if unsafe web content is allowed for rendering or not
     * @private
     */
    private _allowUnsafeContent;
    /**
     * Indicates if layer fields are to be resolved or not
     */
    private _resolveLayerFields;
    private _attributeValueBindingTokens;
    /**
     * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature} class.
     * @class
     * <p>Represents a Geocortex Essentials Feature.</p>
     * @constructs
     * @memberOf geocortex.essentialsHtmlViewer.mapping.infrastructure
     * @param options The options for the new Feature. (i.e. graphic / layer / resolveLayerFields / allowUnsafeContent)
     */
    constructor(options?: FeatureOptions);
    /**
     * Finds the extended property matching the specified name.
     * @param name The name of the property to find.
     */
    getExtendedPropertyByName(name: string): any;
    /**
     * Sets the extended property matching the specified name.
     * @param name The name of the property to update.
     * @param value The property value.
     */
    setExtendedProperty(name: string, value: any): void;
    /**
     * Connect the delegate functions that back the LazyObservables.  Most of
     * these don't cache but they could easily.
     */
    private connectDelegates();
    /**
     * Determines if the specified scale is within this layer's min and max scale.
     * @param scale The scale value to test if it is between this layer's min and max scale.
     * If a value is not provided for this parameter, then the map's current scale value will
     * be used.
     */
    withinScaleRange(scale: number): boolean;
    /**
     * Calculates a scale at which the layer would be visible if it's not already.
     * @param scale The scale
     * @return The scale at which the layer is visible, calculated to zoom in or out just enough such that the layer would be visible.  If the layer is already visible, the current map scale is returned.
     */
    calculateScaleToMakeVisible(scale: number): number;
    /**
     * Ensures that a field name can't be used for injection attacks when used to form a field token.
     * @param fieldName The field name to sanitize.
     */
    private _sanitizeFieldName(fieldName);
    /**
     * @private Returns the default field value
     */
    private _getDefaultFieldValue();
    /**
     * Clears the attachmentInfos and forces a re-query of all the attachments from the server the next attachmentInfos.get() is called.
     */
    resetAttachmentInfos(): void;
    /**
     * @private Prepare the attachments
     * @param resolveLayerFields Whether or not we should attempt to resolve the layers fields. Defaults to true.
     */
    private _prepAttachmentInfos();
    /**
     * Load the feature attributes with proper naming
     * @param resolveLayerFields Whether or not we should attempt to resolve the layers fields. Defaults to true.
     */
    loadAttributes(resolveLayerFields: boolean): void;
    /**
     * Takes a collection of attributes from an Esri Graphic (feature) and returns a collection of feature attributes with the proper naming.
     * @param attributes attribute Collection of name value pairs to which we will attempt to resolve names using this feature
     * @param resolveLayerFields Whether or not we should attempt to resolve the layers fields. Defaults to true.
     */
    getAttributesFromEsriFeature(attributes: any[], resolveLayerFields?: boolean): FeatureAttribute[];
    /**
     * Returns a set of all of the attributes associated with this feature
     * @param resolveLayerFields boolean: Whether we should look at the layers fields to resolve the names.
     * @return array an of FeatureAttribute objects where we have attempted to resolve the names using this feature
     */
    getAttributes(resolveLayerFields?: boolean): FeatureAttribute[];
    /**
     * Gets the value of the primary key field (ObjectID)
     * @return {Object} Value of the primary key field.
     */
    getPrimaryKeyValue(): string;
    /**
     * Gets the Url to the feature.
     * @return {String} Url to the Esri feature.
     */
    getFeatureUrl(): string;
    /**
     * Gets the feature's type as defined by its feature layer.
     */
    getType(): esri.layers.FeatureType;
    /**
     * Determines whether a Geocortex essentials feature is structurally equal to the current instance.
     *
     *     Structural equality means that two objects are equal because they have equal values.
     *     It differs from reference equality, which indicates that two object references are equal because they reference the same physical object.
     *     Note: This comparison does not take geometry into account
     *
     * @param o: The Geocortex essentials feature to compare with the current instance.
     * @returns `true` if the two objects are equal; otherwise, `false`.
     */
    structurallyEquals(o: Feature): boolean;
    /**
     * Checks if the given Geocortex essentials feature is equal to this feature
     * @param o: A Geocortex essentials feature to be compared
     */
    equals(o: Feature): boolean;
    /** @private Load the attachment infos asynchronously */
    private _loadAttachmentsInfos();
    /** The method formatTemplateString was made public to be consistent with silverlight viewer.
    * It is used by Hyperlink class "geocortex.essentialsHtmlViewer.mapping.modules.FeatureDetails.FeatureDetailsProviders.Hyperlink". */
    formatTemplateString(template: string): string;
    /**
     * Process the fieldName into a dataLink/attributeName pair
     * @param fieldName String containing the value of datalink ID and attribute name
     * @param result Empty map object used to store the datalink ID and attribute name
     */
    parseDataLinkId(fieldName: string, result: any): boolean;
    /**@private */
    protected _getLayerUniqueId(): string;
    private _setupLinkedAttributes();
    private _refreshPresentableValues();
}

}
declare module "geocortex/infrastructure/FeatureAttribute" {
import { TableColumnViewModelInterface } from "geocortex/infrastructure/ui/components/Table/TableColumnViewModelInterface";
import { Observable } from "geocortex/framework/observables";
import { LazyObservable } from "geocortex/framework-ui/LazyObservable";
export class FeatureAttribute implements TableColumnViewModelInterface {
    /**
     * The name of the attribute.
     * @type String
     */
    name: Observable<string>;
    /**
     * The alias name of the attribute.
     * @type String
     */
    alias: Observable<string>;
    /**
     * The display name of the attribute.
     * @type String
     */
    displayName: Observable<string>;
    /**
     * The value of the attribute.
     * @type Number, String, or Date
     */
    value: Observable<any>;
    /**
     * The processed value that takes the type of the attribute into account for display purposes
     * @type String
     */
    presentableValue: LazyObservable<string>;
    /**
     * Specifies whether or not the attribute should be displayed (visible).
     * @type Boolean
     */
    visible: Observable<boolean>;
    /**
     * Specifies the incoming type that the value should be considered. A value of this type is available in the presentableValue property
     * @type String
     */
    type: Observable<string>;
    /**
     * Indicates whether this value should be rendered as a hyperlink.
     */
    displayAsUrl: boolean;
    /**
     * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureAttribute} class.
     * @class
     * <p>Represents a Geocortex Essentials FeatureAttribute.</p>
     * @constructs
     * @memberOf geocortex.essentialsHtmlViewer.mapping.infrastructure
     * @param value The value of the attribute.
     * @param name The name of the attribute.
     * @param alias The alias name of the attribute.
     * @param displayName The display name of the attribute.
     */
    constructor(value?: any, name?: string, alias?: string, displayName?: string, visible?: boolean, presenterDelegate?: (value: string) => () => string, dataType?: string);
    /**
     * Matches attribute names generated by SEP that should not be visible.
     */
    static ignoreAttribute(name: any): boolean;
    private static ignoreAttributeMatcher;
}

}
declare module "geocortex/infrastructure/FeatureDescriptionPresenterView" {
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { XssHtmlValidator } from "geocortex/infrastructure/validation/XssHtmlValidator";
import { Feature } from "geocortex/infrastructure/Feature";
export class FeatureDescriptionPresenterView extends ViewBase {
    app: ViewerApplication;
    /** @private A collection of the commands we have seen so far. The position will be used as the ID Key */
    _uris: string[];
    /** @private An object used as a dictionary to cache known description formats. Compute once, serve many times. */
    _descFormats: {
        [descFormat: string]: string;
    };
    /**
     * A string for the name of the field that we will use for the template. This should be "description" or "longDescription"
     * If not specified, the system will default to the long description.
     */
    contentField: string;
    /** Validator which sanitizes HTML strings. */
    protected _xssHtmlValidator: XssHtmlValidator;
    /**
     * Construct a feature description presenter view.
     */
    constructor(app: ViewerApplication, libraryId?: string);
    /** @inherited */
    attach(viewModel: Feature): Promise<void>;
    /**
     * Clears the bindings on the current view model and reattaches the view to a new one.
     * To be used when changing the feature in this view.
     * @param feature The new feature that we would like to bind to
     */
    reattach(viewModel: Feature): Promise<void>;
    private _attach(viewModel, callback?);
    /**
     * Returns a boolean indicating if the content field of the attached feature is populated
     */
    hasContent(): boolean;
    /**
     * Returns a description for the given feature capable of performing commands in hyperlinks.
     * To be used with features that do not have relationships.
     * @deprecated 2.6 Use {@link getDescriptionContent} instead.
     * @param feature The feature what we would like to get the description for
     */
    descriptionGet(feature: Feature): Promise<string>;
    getContentFieldFormat(feature: Feature): string;
    /**
     * Returns a description for the given feature.
     * The description is populated with unbound command hyperlinks and image load handlers for handling layout changes.
     * Consumers must bind this content themselves.
     * Note that all anchor tags are converted to command hyperlinks that open the URLs only after verification via a {@link ContentPolicy}.
     * @param feature The feature what we would like to generate the descriptive content for.
     * @param descriptionFormat Optional parameter. If provided, will override the descriptionFormat for the feature - to be used for eg. when relationship replacement tokens resolve asynchronously.
     */
    getDescriptionContent(feature: Feature, descriptionFormat?: string): Promise<string>;
    /**
     * Renders a feature description into the provided HTML element, injecting command hyperlinks and image loading handlers.
     * @deprecated 2.6 Use {@link applyDescriptiveTemplate} instead.
     * @param feature The feature what we would like to get the description for
     * @param viewRoot The HTML element to assign the description to.
     */
    descriptionApply(feature: Feature, viewRoot: HTMLElement): Promise<any>;
    /**
     * Renders a feature description into the provided HTML element, injecting command hyperlinks and image loading handlers.
     * @param feature The feature what we would like to get the description for
     * @param viewRoot The HTML element to assign the description to.
     */
    applyDescriptiveTemplate(feature: Feature, viewRoot: HTMLElement): Promise<any>;
    /**
     * Extract command hyperlinks and replace them with placeholders.
     */
    protected _extractCommandHyperlinks(html: string): CommandHyperlinkPlaceholderState;
    /**
     * Inject command hyperlinks back into the subject of a previous extraction.
     */
    protected _injectCommandHyperlinks(state: CommandHyperlinkPlaceholderState): string;
    /**
     * Sanitize a string of HTML.
     */
    protected _sanitizeHtml(html: string): Promise<string>;
    /**
     * Creates a cleansed copy of a format with any command hyperlinks replaced with click handlers
     * @deprecated 2.6 Use {@link insertLinkAndImageBindings} instead.
     * @param Format the format template for this feature
     */
    cleansedFormatForFormat(descFormat: string): string;
    /**
     * Inserts command hyperlinks and image load handlers, the latter for the purpose of handling layout changes.
     * @param Format the format template for this feature
     */
    insertLinkAndImageBindings(descFormat: string): string;
    /**
     * Override this method to add custom behavior on image load.
     */
    handleImgLoad(evt: HTMLImageElement): void;
    /**
     * Finds the id for the given command hyperlink. If one is not found, creates one and returns that.
     * @param Uri the uri you would like the key for
     * @return Number
     */
    keyForUri(uri: string): number;
    /**
     * Attempts to parse the parameter string given into one with the given type. Also performs Token replacements
     * @param parameter the parameter string you are attempting to parse
     * @param paramType the type that you would like to get the parameter in.
     * @param context the context to use for any token replacements
     * @return Object an array of the command parameters given the given format.
     */
    parseArguments(parameter: string, paramType: string, context: any): string[];
    /**
     * Replaces any instances of the given token string with the attributes of a given feature, and returns if we any such substitutions occurred.
     * @param token The token string you would like to replace
     * @param feature The feature that should be used as a context for the token replacements
     * @param output An object whose value parameter will contain the substituted output if the token substitution succeeds
     * @return Boolean
     */
    tryPerformTokenSubstitution(token: string, feature: Feature, output: any): boolean;
    /**
     * Returns Html encoded quotes to their non-html forms
     * @param input the string to replace the quotes to non html quotes
     * @return String
     */
    decodeHtmlQuotes(input: string): string;
    /**
     * Returns Html encoded ampersands to their non-html forms
     * @param input the string to replace the ampersands to non html ampersands
     * @return String
     */
    decodeHtmlAmpersands(input: string): string;
    /**
     * A click handler for hyperlinks embedded in the descriptions returned from descriptionGet/descriptionApply
     * @param event The event object that was fired with the click
     * @param el The element where the click occurred
     * @param context The feature that is related to the description the click occurred in
     * @return Boolean if the event should propogate up
     */
    handleHyperlinkClick(event: Event, element: HTMLAnchorElement, context: any): boolean;
    /**
     * An event handler handler designed to stop events from propagating to overzealous parent views.
     * @param event The event object that was fired with the click
     * @param el The element where the click occurred
     * @param context The feature that is related to the description the click occurred in
     * @return False. If this was embedded, we never want our parents notified
     */
    ignoreEvent(event: Event, el: HTMLElement, context: any): boolean;
    /**
     * Runs the command named with the given parameters and context
     * @param commandName The name of the command we would like executed
     * @param parameter The parameter to be fed to the command. Encoded in either JSON or Query String format.
     * @param context The feature context that should be used for token replacements
     */
    runCommand(commandName: string, parameter: any, context: any): void;
}
/**
 * Defines the relationship between a command hyperlink and its placeholder.
 */
export interface CommandHyperlinkPlaceholder {
    commandHyperlink: string;
    placeholder: string;
}
/**
 * Keeps state of a command hyperlink extraction so that the hyperlinks can be injected into the place of their placeholders.
 */
export interface CommandHyperlinkPlaceholderState {
    html: string;
    commandHyperlinkPlaceholders: CommandHyperlinkPlaceholder[];
}

}
declare module "geocortex/infrastructure/FeatureSet" {
import { Layer } from "geocortex/essentials/Layer";
import { Application } from "geocortex/framework/application/Application";
import { LazyObservable } from "geocortex/framework-ui/LazyObservable";
import { ObservableCollection, Observable } from "geocortex/framework/observables";
import { Feature, NameValueProperty } from "geocortex/infrastructure/Feature";
import { FeatureAttribute } from "geocortex/infrastructure/FeatureAttribute";
import { CollectionChangedArgs } from "geocortex/framework/events/CollectionChangedArgs";
export enum DataLinksState {
    Unresolved = 0,
    Resolving = 1,
    Resolved = 2,
}
export interface FeatureSetOptions {
    esriFeatureSet?: esri.tasks.FeatureSet;
    layer?: Layer;
    featureLayer?: esri.layers.FeatureLayer;
    allowUnsafeContent?: boolean;
    app?: Application;
    defaultNumberFormat?: string;
    defaultDateFormat?: string;
    id?: string;
}
export class FeatureSet {
    /**
     * The {@link geocortex.framework.application.Application} that this module belongs to.
     */
    app: Application;
    /**
     * An id of this feature set
     * @type String
     */
    id: string;
    /**
     * Set of ESRI features
     * @type esri FeatureSet
     */
    esriFeatureSet: esri.tasks.FeatureSet;
    /**
     * The Layer this FeatureSet is a part of.
     * @type geocortex.essentials.Layer
     */
    layer: Layer;
    /**
    * The esri feature layer containing metadata about the feature attributes.
    */
    featureLayer: esri.layers.FeatureLayer;
    /**
     * An id guaranteed to be unique (auto-generated).
     * @type String
     */
    uniqueId: string;
    /**
     * The display name to be associated with this FeatureSet. Get display name from layer if not explicitly set.
     * @type String
     */
    displayName: LazyObservable<string>;
    /**
     * The collection of Geocortex Features.
     * @type ObservableCollection
     */
    features: ObservableCollection<Feature>;
    /**
     * The collection of feature attributes
     * @type ObservableCollection
     */
    attributes: ObservableCollection<FeatureAttribute>;
    /**
     * The icon associated with this featureSet. If not explicitly set, obtain from layer if available
     * @type String
     */
    iconUri: LazyObservable<string>;
    /**
     * More properties of feature set
     * @type ObservableCollection
     */
    extendedProperties: ObservableCollection<NameValueProperty>;
    /**
     * Only used by a particular view model.  This should be refactored out.
     */
    isSelectedInCollection: Observable<boolean>;
    /**
     * Whether the datalinks (if any) for this feature set have been resolved.
     */
    dataLinksResolved: Observable<boolean>;
    /** The default format to use for displaying number fields that have no explicit format. */
    defaultNumberFormat: string;
    /** The default format to use for displaying date fields that have no explicit format. */
    defaultDateFormat: string;
    /**
     * @private Indicates if unsafe web content is allowed for rendering or not
     * @type boolean
     */
    private _allowUnsafeContent;
    /** Keeps track of objectIds to ensure we there aren't duplicate features in this FeatureSet */
    private _objectIds;
    private _watchHandles;
    private _dataLinksState;
    /**
     * Indicates the current state with regard to resolving data links.
     */
    readonly dataLinksState: DataLinksState;
    protected setDataLinksState(value: DataLinksState): void;
    /**
     * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSet} class.
     * @class
     * <p>Represents a Geocortex Essentials FeatureSet.</p>
     * @constructs
     * @memberOf geocortex.essentialsHtmlViewer.mapping.infrastructure
     * @param options The options for the new FeatureSet (i.e. esriFeatureSet / layer / allowUnsafeContent).
     */
    constructor(options?: FeatureSetOptions);
    /**
     * Finds the extended property matching the specified name.
     * @param name The name of the property to find.
     */
    getExtendedPropertyByName(name: string): any;
    /**
     * Sets the extended property matching the specified name.
     * @param name The name of the property to update.
     * @param value The property value.
     */
    setExtendedProperty(name: string, value: any): void;
    /**
     * Adds a feature to this FeatureSet.
     * @param feature The feature to add to the featureSet.
     * @param doNotCheckForDuplicates When `true`, the supplied feature will be added to this set without checking for duplicates. The default value is `false`.
     */
    addFeature(feature: Feature, doNotCheckForDuplicates?: boolean): boolean;
    protected _addFeatureWithoutNotification(feature: Feature, doNotCheckForDuplicates?: boolean): boolean;
    /**
     * Removes a feature from this FeatureSet.
     *
     *     This method determines equality by using the default equality comparer for features, as defined in {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature.equals}().
     *     This method performs a linear search; therefore, this method is an O(n) operation, where n is the number of features.
     *
     * @param feature The feature to remove.
     * @return `true` if item was successfully removed; otherwise, `false`. This method also returns `false` if item is not found.
     */
    removeFeature(feature: Feature): boolean;
    protected _removeWithoutNotificationAt(index: number): boolean;
    /**
     * Determines whether a feature is in this FeatureSet.
     *
     *     This method determines equality by using the default equality comparer for features, as defined in {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature.equals}().
     *     This method performs a linear search; therefore, this method is an O(n) operation, where n is the number of features.
     *
     * @param feature The feature to locate in the FeatureSet.
     * @return `true` if feature is found in the FeatureSet; otherwise, `false`.
     */
    containsFeature(feature: Feature): boolean;
    /**
     * Removes all features from this FeatureSet.
     */
    clearFeatures(): void;
    /**
     * Load the geometries for the specified features (if not already loaded).
     * If null is passed in, the geometries for all features will be fetched.
     * @param features An array of features to load geometries for.
     * @param successCallback Function to be called when the geometries have been loaded.
     * @param errorCallback A function that is called if an error occurred.
     * @return {dojo.Deferred}
     */
    loadGeometries(features: Feature[], successCallback?: () => void, errorCallback?: (error: Error) => void): dojo.Deferred;
    /**
     * Finds the Geocortex feature having the given ID (primary key value).
     * @param id The ID to search for.
     * @return The Geocortex feature corresponding to the given ID if it exists, or null.
     */
    findFeatureById(id: any): Feature;
    /**
     * Finds the Geocortex feature corresponding to the given ESRI feature if it exists in the feature set.
     * There is an inherent assumption here that a Geocortex feature instance will be unique in a feature set.
     * @param esriFeature The esri graphic for which the corresponding Geocortex feature needs to be retrieved.
     * @return The Geocortex feature corresponding to the given ESRI feature, if it exists, or null.
     */
    findFeatureByEsriFeature(esriFeature: esri.Graphic): Feature;
    /**
     * Finds the ESRI features with given value of specified attribute in the given feature collection
     * @param key The value against which the features are to be checked.
     * @param keyName The name of the attribute whose value is to be compared.
     * @param collection An array of ESRI features which needs to be checked against the given value.
     * @return ESRI feature whose specified attribute's value is equal to the specified value
     * @private
     */
    private _findFeature(key, keyName, collection);
    /**
     * Loads the features from ESRI feature set
     */
    loadFeatures(): void;
    /**
     * Loads the feature attributes.
     */
    loadAttributes(): void;
    /**
     * Updates the current collection of features.
     * @params args Type of operation done on feature set.
     */
    featureSetChanged(args: CollectionChangedArgs): void;
    /**
     * Apply the datalinks with the given featureSet, datalinks and results collection
     * @param featureSet
     * @param dataLinks The datalinks to be applied
     * @param resultsCollection
     * @param onDataLinkAddedToFeature
     * @private
     */
    protected _applyDataLinks(featureSet: FeatureSet, features: Feature[], dataLinks: any[], resultsCollection: any[], onDataLinkAddedToFeature?: (feature: Feature) => void): void;
    /**
     * Resolves the datalinks (if any) for this feature set
     * @param onDataLinkAddedToFeature Function to be called when a datalink is resolved for a given feature
     * @param honorVisible Boolean of whether or not we should only resolve visible datalinks. By default this is true.
     * @param userState A User State that will be returned to the complete and fail callbacks
     * @param onDataLinkingComplete a function that is called if the operation completes successfully
     * @param onDataLinkingFailed a function that is called if an error occurs
     */
    resolveDataLinks<T>(onDataLinkAddedToFeature?: (feature: Feature) => void, honorVisible?: boolean, userState?: T, onDataLinkingComplete?: (featureSet: FeatureSet, userState: T) => void, onDataLinkingFailed?: (featureSet: FeatureSet, error: Error, userState: T) => void): void;
    /**
     * Executes the specified callback function when the datalinking operation is completed, or immediately if the
     * datalinks are already resolved.
     * @param callback The callback function to execute when the datalinks are resolved.
     */
    doWhenDataLinkingCompleted(callback: (featureSet: FeatureSet) => void): void;
    /**
     * Adds only those features to the feature set that are not already part of the feature set.
     */
    append(featureSet: FeatureSet): void;
    /**
     * Creates a new feature set that contains all elements that are present in either the current set or in the specified feature set.
     * @param other The feature set to add elements from.
     * @return A new feature set with the items added; or a copy of the original set if all the items were already in the set.
     */
    union(other: FeatureSet): FeatureSet;
    /**
     * Modifies the current set to produce the set union of two sequences of {@link Feature}s by using the default equality comparer.
     * In other words, it adds all of the elements in the second set to this set if they're not already present.
     * @param other Set containing elements to be added to this set.
     * @return `true` if this set changed as a result of the call; `false` otherwise.
     */
    unionInPlace(other: FeatureSet): boolean;
    /**
     * Creates a new feature set that contains elements of the current set that do not appear in the second set.
     * @param other The feature set whose elements that also occur in the first set will cause those elements to be removed from the returned set.
     * @return A new feature set that contains the set difference of the elements of two sets.
     */
    subtract(other: FeatureSet): FeatureSet;
    /**
     * Modifies the current set to produce the set difference of two sequences of {@link Feature}s by using the default equality comparer to compare values.
     * The set difference of two sets is defined as the elements of the first set that do not appear in the second set.
     * Note: This method modifies this set to only keep those elements that do not appear in the second set. It does not also include those elements in the second set that do not appear in this set.
     * @param other Set containing elements to be removed from this set.
     * @return `true` if this set changed as a result of the call; `false` otherwise.
     */
    subtractInPlace(other: FeatureSet): boolean;
    /**
     * Creates a new feature set that contains elements that exist in both this set and the specified set.
     * @param other The feature set to compare to the current set.
     * @return A new feature set that contains any elements that exist in both sets.
     */
    intersect(other: FeatureSet): FeatureSet;
    /**
     * Modifies the current set to produce the set intersection of two sequences of {@link Feature}s by using the default equality comparer to compare values.
     * The intersection of two sets A and B is defined as the set that contains all the elements of A that also appear in B, but no other elements.
     * @param other Set containing elements to be retained in this set.
     * @return `true` if this set changed as a result of the call; `false` otherwise.
     */
    intersectInPlace(other: FeatureSet): boolean;
    /**
     * Performs a shallow copy of this FeatureSet, returning the cloned value.
     */
    clone(): FeatureSet;
    /**
     * Given a FeatureSet, creates a new empty one just like the original (same layer, name etc)
     * Note: This method will not copy the features within the original FeatureSet.
     */
    cloneStructure(): FeatureSet;
    protected _cloneEsriStructure(esriFeatureSet: esri.tasks.FeatureSet): esri.tasks.FeatureSet;
    protected _watchFeatureSetChanges(): dojo.RemovableHandle;
    protected _unwatchFeatureSetChanges(): void;
}

}
declare module "geocortex/infrastructure/FeatureSetCollection" {
import { Observable, ObservableCollection } from "geocortex/framework/observables";
import { FeatureSet } from "geocortex/infrastructure/FeatureSet";
import { NameValueProperty, Feature } from "geocortex/infrastructure/Feature";
import { Layer } from "geocortex/essentials/Layer";
import { Dictionary } from "geocortex/infrastructure/Dictionary";
export class FeatureSetCollection {
    /**
     * The id of the feature set collection.
     * @type Number
     */
    id: string;
    /**
     * The displayName for the feature set collection.
     * @type String
     */
    displayName: Observable<string>;
    /**
     * Whether the feature set collection has been modified.
     */
    isModified: Observable<boolean>;
    /**
     * The collection of feature set objects constituting the collection.
     * @type ObservableCollection<FeatureSet>
     */
    featureSets: ObservableCollection<FeatureSet>;
    /**
     * The source of the feature set collection.
     * @type String
     */
    sourceName: string;
    /**
     * The tag for the feature set collection.
     * @type String
     */
    tag: any;
    /**
     * The extended collection for the feature set collection.
     * @type Array
     */
    extendedProperties: ObservableCollection<NameValueProperty>;
    /**
     * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection} class.
     * @class
     * <p>Represents a Geocortex Essentials FeatureSetCollection.</p>
     * @constructs
     * @memberOf geocortex.essentialsHtmlViewer.mapping.infrastructure
     */
    constructor();
    /**
     * Finds the extended property matching the specified name.
     * @param name The name of the property to find.
     */
    getExtendedPropertyByName(name: string): any;
    /**
     * Sets the extended property matching the specified name.
     * @param name The name of the property to update.
     * @param value The property value.
     */
    setExtendedProperty(name: string, value: any): void;
    /**
     * Returns the FeatureSet having the specified ID, or null if none exists.
     * @param id The id of the FeatureSet to return.
     * @return FeatureSet The FeatureSet with the specified ID.
     */
    getFeatureSetById(id: string): FeatureSet;
    /**
     * Returns the FeatureSet having the specified unique ID, or null if none exists.
     * @param id The unique id of the FeatureSet to return.
     * @return FeatureSet The FeatureSet with the specified unique ID.
     */
    getFeatureSetByUniqueId(id: string): FeatureSet;
    /**
     * Returns the FeatureSet having the specified {@link geocortex.essentials.Layer}, or null if none exists.
     * @param layer The Geocortex Layer of the FeatureSet to return.
     * @return FeatureSet The FeatureSet found, if any.
     */
    getFeatureSetByLayer(layer: Layer): FeatureSet;
    /**
    * Returns the FeatureSet having the specified {@link esri.layers.Layer}, or null if none exists.
    * Note - If possible, use getFeatureSetByLayer which takes geocortex.essentials.Layer rather than esri.layers.Layer as parameter.
    * This method is created primarily for layers which don't have essentials layer example - markup layer.
    * @param layer The esri Layer of the FeatureSet to return.
    * @return FeatureSet The FeatureSet found, if any.
    */
    getFeatureSetbyEsriLayer(layer: esri.layers.Layer): FeatureSet;
    /**
     * Searches all contained feature sets for a Geocortex feature corresponding to the specified ESRI feature, and returns it if found.
     * There is an inherent assumption here that a Geocortex feature instance will be unique among all feature sets in a feature set collection.
     * @param esriFeature The esri graphic for which the corresponding Geocortex feature needs to be retrieved.
     * @return The Geocortex feature corresponding to the given ESRI feature, if it exists, or null.
     */
    findFeatureByEsriFeature(esriFeature: esri.Graphic): Feature;
    /**
     * Returns the first Feature of the first FeatureSet, or null if none exists.
     * @return Feature The first Feature in the collection.
     */
    firstFeature(): Feature;
    /**
     * Get the number of features contained in all feature sets in this collection.
     */
    countFeatures(): number;
    /**
     * Clears the feature collection within each FeatureSet, before clearing the FeatureSet collection.
     */
    clear(): void;
    /**
     * Performs a shallow copy of this FeatureSetCollection, returning the cloned value.
     * @param deepCopy Whether to clone the FeatureSets belonging to this collection. Defaults to `false`
     */
    clone(deepCopy?: boolean): FeatureSetCollection;
    /**
     * Given a FeatureSetCollection, creates a new empty one just like the original (same layer, name etc)
     * Note: This method will not copy the feature sets within the original collection.
     */
    cloneStructure(): FeatureSetCollection;
    /**
     * Produces the set union of two sequences of {@link Feature}s by using the default equality comparer.
     * In other words, it adds all of the elements in the second set to this set if they're not already present.
     * @param fsc Set containing elements to be added to this set.
     * @return `true` if this set changed as a result of the call; `false` otherwise.
     */
    unionInPlace(other: FeatureSetCollection): boolean;
    unionManyInPlace(collections: FeatureSetCollection[]): boolean;
    /**
     * Produces the set difference of two sequences of {@link Feature}s by using the default equality comparer to compare values.
     * The set difference of two sets is defined as the members of the first set that do not appear in the second set.
     * Note: This method modifies this set to only keep those elements that do not appear in the second set. It does not also include those elements in the second set that do not appear in this set.
     * @param featureSet Set containing elements to be removed from this set.
     * @return `true` if this set changed as a result of the call; `false` otherwise.
     */
    subtractInPlace(other: FeatureSetCollection): boolean;
    subtractManyInPlace(collections: FeatureSetCollection[]): boolean;
    /**
     * Produces the set intersection of two sequences of {@link Feature}s by using the default equality comparer to compare values.
     * The intersection of two sets A and B is defined as the set that contains all the elements of A that also appear in B, but no other elements.
     * @param featureSet Set containing elements to be retained in this set.
     * @return `true` if this set changed as a result of the call; `false` otherwise.
     */
    intersectInPlace(other: FeatureSetCollection): boolean;
    intersectManyInPlace(collections: FeatureSetCollection[]): boolean;
    protected _generateLayerKey(mapServiceId: string, layerId: string): string;
    protected _buildLayerLookup(): Dictionary<FeatureSet>;
    protected _buildFeatureSetLookup(): Dictionary<FeatureSet>;
    protected _getFeatureSetByIdImpl(id: string, isUniqueId?: boolean): FeatureSet;
}

}
declare module "geocortex/infrastructure/FeatureSetManager" {
import { Application } from "geocortex/framework/application/Application";
import { ObservableCollection } from "geocortex/framework/observables";
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
import { FeatureSet } from "geocortex/infrastructure/FeatureSet";
import { Feature } from "geocortex/infrastructure/Feature";
export class FeatureSetManager {
    /**
     * The {@link geocortex.framework.application.Application} that this module belongs to.
     */
    app: Application;
    /**
     * The feature set collections being managed.
     * @type FeatureSetCollection[]
     */
    featureSetCollections: ObservableCollection<FeatureSetCollection>;
    /**
     * Map of ID -> FSC.
     * @private
     */
    _featureSetCollectionsMap: {
        [id: string]: FeatureSetCollection;
    };
    /**
     * Map of FSC ID -> event token for the collection changed event.
     * @private
     */
    _collectionChangedEventMap: {
        [id: string]: string;
    };
    /**
     * Map of ID -> Open count.
     * @private
     */
    _collectionOpenCount: {
        [id: string]: number;
    };
    /**
     * Map of FSC source name -> search suggestion.
     */
    _searchSuggestions: {
        [sourceName: string]: string;
    };
    /**
     * Initializes a new instance of an {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetManager} object.
     * @class
     * <p>The central clearing-house for all system activities that create and want to expose FeatureSet instances to other areas of the system.</p>
     * @constructs
     * @memberOf geocortex.essentialsHtmlViewer.mapping.infrastructure
     * @param app The {@link geocortex.framework.application.Application} that this module belongs to.
     */
    constructor(app: Application);
    /** @private Registers some view-related commands. */
    private _registerCommands();
    /**
     * Opens the specified collection.
     * Opening and closing a feature set collection does not actually change the behavior of the collection.  It is
     * used internally to keep track of multiple clients concurrently accessing a collection for the purposes of raising an event
     * when the collection is first opened and finally closed.
     * @param id The ID of the collection to open.
     * @return FeatureSetCollection The opened FeatureSetCollection for the id specified, or null if the FeatureSetCollection does not exist or could not be opened.
     */
    openCollection(id: string): FeatureSetCollection;
    /**
     * Closes the specified collection.
     * Opening and closing a feature set collection does not actually change the behavior of the collection.  It is
     * used internally to keep track of multiple clients concurrently accessing a collection for the purposes of raising an event
     * when the collection is first opened and finally closed.
     * @param id The ID of the collection to close.
     * @return Boolean True if the collection was successfully closed, False otherwise.
     */
    closeCollection(id: string): boolean;
    /**
     * Closes the specified collection if it's open.
     * Opening and closing a feature set collection does not actually change the behavior of the collection.  It is
     * used internally to keep track of multiple clients concurrently accessing a collection for the purposes of raising an event
     * when the collection is first opened and finally closed.
     * @param id The ID of the collection to close.
     * @return Boolean True if the collection was successfully closed (or is already closed), False otherwise.
     */
    tryCloseCollection(id: string): boolean;
    /**
     * Determines whether the specified collection is open.
     * @param id The ID of the collection to open.
     * @returns Boolean True if the collection is open, False otherwise.
     */
    isCollectionOpen(id: string): boolean;
    /**
     * Adds the specified collection to the feature set manager.
     * @param fsc The FeatureSetCollection to add.
     * @return Boolean, True if the operation was successful, false otherwise.
     */
    addCollection(fsc: FeatureSetCollection): boolean;
    /**
     * Adds the specified collection to the feature set manager.
     * @param fsc The FeatureSetCollection to add.
     * @return Boolean, True if the operation was successful, false otherwise.
     * @private
     */
    _addCollectionImpl(fsc: FeatureSetCollection): boolean;
    /**
     * Raises an event when a feature set collection is changed in feature set manager
     * @param args
     */
    handleCollectionChanged(fsc: FeatureSetCollection, args: any): void;
    /**
     * Removes the specified collection from the feature set manager.
     * @param fsc The FeatureSetCollection to remove.
     * @return Boolean, True if the operation was successful, false otherwise.
     */
    removeCollection(fsc: FeatureSetCollection): boolean;
    /**
     * Removes the specified collection from the feature set manager.
     * @param id The ID of the FeatureSetCollection to remove.
     * @return Boolean, True if the operation was successful, false otherwise.
     */
    removeCollectionById(id: string): boolean;
    /**
     * Determine whether the specified FeatureSetCollection can be removed from the manager.
     * @param fsc The FeatureSetCollection to remove.
     * @return Boolean, True if the specified FeatureSetCollection is currently managed, false otherwise.
     */
    canRemoveCollection(fsc: FeatureSetCollection): boolean;
    /**
     * Gets the specified feature set collection.
     * @param id The ID of the FeatureSetCollection to retrieve.
     * @return FeatureSetCollection, The retrieved FeatureSetCollection.
     */
    getCollectionById(id: string): FeatureSetCollection;
    /**
     * Get all feature collection ids managed by this class.
     */
    getCollectionIds(): string[];
    /**
     * Searches all contained feature set collections for a feature set having the specified unique id and returns it if it exists.
     * @param uniqueId The unique id of the feature set that is being searched for.
     * @return The feature set having the unique id or null if not found.
     */
    findFeatureSetByUniqueId(uniqueId: string): FeatureSet;
    /**
     * Searches all contained feature set collections for Geocortex feature(s) corresponding to the specified ESRI feature, and returns all existing instances.
     * @param esriFeature The esri graphic for which the corresponding Geocortex feature(s) needs to be retrieved.
     * @return The array Geocortex features corresponding to the given ESRI feature, if they exist, or an empty array.
     */
    findFeaturesByEsriFeature(esriFeature: esri.Graphic): Feature[];
    /**
     * Adds the specified search suggestions to the feature set manager.
     * @param searchSuggestions The object containing a map of FSC source name -> search suggestion.
     */
    addSearchSuggestions(searchSuggestions: {
        [sourceName: string]: string;
    }): void;
    /**
     * Gets the specified search suggestion.
     * @param sourceName The source name of the FeatureSetCollection suggestion to retrieve.
     * @return string The retrieved search suggestion.
     */
    getSearchSuggestion(sourceName: string): string;
    /**
     * Updates all collections with feature sets containing that particular feature in the feature set manager.
     * @param esriFeature The Esri feature that has been deleted.
     * @param discardEmptySets Whether to discard empty feature sets. Defaults to `true`.
     */
    updateCollectionsOnFeatureDeletion(esriFeature: esri.Graphic, discardEmptySets?: boolean): void;
    /**
     * Searches the open feature set collection for a feature set having the specified unique id and returns it if it exists.
     * @param uniqueId The unique id of the feature set that is being searched for.
     * @return The open feature set collection having the unique id or null if not found.
     */
    findOpenFeatureSetCollectionByFeatureSetUniqueId(uniqueId: string): FeatureSetCollection;
}

}
declare module "geocortex/infrastructure/FilterUtils" {
/**
 * Options for {@link sanitize}.
 */
export interface SanitizeOptions {
    allowArbitraryHyperlinks?: boolean;
    allowFrames?: boolean;
    /** Function that transforms URIs during the sanitization. */
    uriTransformer?: (uri: string, details: UriDetails) => string;
}
/**
 * Sanitize a string of unsafe HTML to eliminate XSS (cross-site scripting) security risks.
 * This method allows tags and standard attributes, however `data-` attributes are not allowed.
 * Script tags are not allowed either.
 * Note that you must pass a {@link SanitizeOptions.uriTransformer} function in the options
 * if you wish to allow URIs in your content.
 * @param unsafeHtml String of HTML to be scrubbed clean.
 * @param options {@link SanitizeOptions}.
 * @return Safe HTML that has been sanitized.
 */
export function sanitize(unsafeHtml: string, options?: SanitizeOptions): string;
/**
 * Strip all HTML out of a string.
 * @param unsafe String of text which will have its HTML stripped away.
 * @return A plain text string without any HTML markup.
 */
export function stripHtml(unsafe: string): string;
/**
 * Interfaces and implementation details specific to sanitization.
 */
export enum UriType {
    Markup = 0,
    Css = 1,
    NavigableLink = 2,
}
export interface UriDetailsBase {
    uri: string;
    type: UriType;
}
export interface MarkupUriDetails extends UriDetailsBase {
    tag: string;
    attribute: string;
}
export interface CssUriDetails extends UriDetailsBase {
    property: string;
}
export interface NavigableLinkUriDetails extends MarkupUriDetails {
    linkChallengeCallback?: Function;
    target?: string;
    forcePrompt?: boolean;
}
export type UriDetails = NavigableLinkUriDetails | MarkupUriDetails | CssUriDetails;
/**
 * A container for HTML content that is not trusted to be safe.
 * Has getters for accessing either the originally-provided unsafe HTML string, or a safely sanitized version.
 * Simplifies XSS security matters by making the handling of unsafe HTML obvious and clear.
 */
export class UnsafeHtml {
    /** The unsafe HTML. */
    protected _unsafeHtml: string;
    /** The safely sanitized version of the HTML. */
    protected _safeHtml: string;
    /**
     * Create a new container for unsafe HTML.
     */
    constructor(unsafeHtml: string, sanitizeOptions?: SanitizeOptions);
    /**
     * Update the HTML.
     */
    sanitize(unsafeHtml: string, sanitizeOptions?: SanitizeOptions): void;
    /**
     * Get the original unsafe HTML.
     */
    readonly unsafeHtml: string;
    /**
     * Get the safely sanitized version of the HTML.
     */
    readonly safeHtml: string;
}
/**
 * Utilities for parsing and assessing data URIs.
 */
export module DataUri {
    /** Whitelist for media types (MIME types without parameters like charset) which are allowed in safe data URI's. */
    var dataUriMediaTypeWhitelist: string[];
    /**
     * Data URI sub-components.
     */
    interface DataUriComponents {
        /** Original data URI that has been parsed. */
        uri: string;
        /** Meta data preamble of the data URI. */
        meta: string;
        /** Media type portion of the meta preamble. If undefined, assume "text/plain". */
        mediaType: string;
        /** Character set portion of the meta preamble. Starts with "charset=", or is undefined. */
        charset: string;
        /** Extension portion of the meta preamble. Can be 'base64', or undefined. */
        extension: string;
        /** Index of the first character of the payload. */
        payloadIndex: number;
    }
    /**
     * Break a data URI string down into its sub-components.
     * @param uri Data URI to parse.
     * @return {@link DataUriComponents} as seen in the URI (no defaults are provided, omitted optionals will be undefined).
     */
    function parseDataUri(uri: string): DataUriComponents;
    /**
     * Check if a data URI is safe, in that it cannot be used as an XSS attack vector.
     * The data URI is considered safe when its detected media type (MIME type) is present in the data URI media type whitelist.
     * @param uri Data URI to scrutinize for XSS safety.
     * @return True when the data URI is safe, false when the data URI is unsafe or invalid.
     */
    function isDataUriSafe(uri: string): boolean;
}

}
declare module "geocortex/infrastructure/FocusUtils" {
import { ViewBase } from "geocortex/framework/ui/ViewBase";
/**
 * Sets the focus on the first input control in a view (e.g. a textbox, drop-down, checkbox)
 * @param view The target view.
 */
export function focusOnFirstInput(view: ViewBase): void;
/**
 * Sets the focus on the map control (if available)
 * @param map The map control to focus on.
 */
export function focusOnMap(map: esri.Map): void;
/**
 * Sets the focus on the specified DOM element.
 * The focus is used to determine which element is the first to receive keyboard-related events.
 */
export function focus(domElement: HTMLElement): void;

}
declare module "geocortex/infrastructure/FormatUtils" {
/**
 * Pre-defined format specifiers for use with formatDate().
 */
export class DateFormat {
    /**
     * A localized representation of a date (e.g. "09/04/1986" for en-US locale).
     */
    static DATE_SHORT: string;
    /**
     * A localized long representation of a date (e.g. "September 4 1986" for en-US locale).
     */
    static DATE_LONG: string;
    /**
     * A localized short representation of the time (e.g. "8:30 PM" for en-US locale).
     */
    static TIME_SHORT: string;
    /**
     * A localized representation of the time including seconds (e.g. "8:30:25 PM" for en-US locale).
     */
    static TIME_LONG: string;
    /**
     * A localized representation of date and time (e.g. "Sep 4 1986 8:30 PM" for en-US locale).
     */
    static DATE_TIME_SHORT: string;
    /**
     * A localized long representation of date and time (e.g. "September 4 1986 8:30 PM" for en-US locale).
     */
    static DATE_TIME_LONG: string;
    /**
     * A localized full representation of date and time, including day of week (e.g. "Thursday, September 4 1986 8:30 PM" for en-US locale).
     */
    static FULL: string;
    /**
     * The date and time in ISO-8601 format (e.g. "2014-09-08T08:02:17-05:00"). Invariant.
     */
    static ISO_8601: string;
    /**
     * An invariant representation of a date. Guarantees that the date can be parsed back into the same date, regardless of locale.
     * Equivalent to ISO-8601.
     */
    static ROUND_TRIP: string;
    /**
     * The default representation for date values (equivalent to DATE_TIME_SHORT).
     */
    static DEFAULT: string;
    /**
     * The default set of formats used for parsing date values.
     */
    static DEFAULT_PARSING_FORMATS: string[];
}
/**
 * Pre-defined format specifiers for use with formatNumber().
 */
export class NumberFormat {
    /**
     * A localized representation of a number with a decimal separator and group separators (e.g. "12,345.67", "-42" for en-US locale).
     */
    static NUMBER: string;
    /**
     * A localized representation of a number with a decimal separator (e.g. "12345.67", "-42" for en-US locale).
     */
    static FIXED_POINT: string;
    /**
     * A localized representation of a monetary amount in a specific currency (e.g. "$123.45" for USD, "£123.45" for GBP for en-US locale).
     */
    static CURRENCY: string;
    /**
     * Same as CURRENCY, except that negative values are displayed in parentheses instead of using a "-" sign.
     */
    static ACCOUNTING: string;
    /**
     * A localized representation of a percentage (e.g. 0.99 -> "99%" in the en-US locale).
     */
    static PERCENT: string;
    /**
     * An invariant representation of a number (e.g. "12345.67"). Guarantees that the number can be parsed back
     * into the same number, regardless of locale.
     */
    static ROUND_TRIP: string;
    /**
     * The default representation for number values (equivalent to FIXED_POINT).
     */
    static DEFAULT: string;
}
export interface DateFormatOptions {
    /**
     * The timezone in which the data should be interpretted as.
     */
    timeZoneId: string;
    /**
    * The timezone in which the data should be presented to the user
    */
    displayTimeZoneId: string;
}
/**
 * Formats a value for display in the current locale.
 * @param value The value to format.
 */
export function format(value: any): string;
/**
 * Formats a date for display in the current locale.
 * @param date The date to format.
 * @param format One of the {@link DateFormat} constants, or a custom format string.
 *     The format string syntax is similar to this: https://msdn.microsoft.com/en-us/library/8kb3ddd4.aspx,
 *     with the following exceptions:
 *         - "/", and ":" are treated as literal characters.
 *         - "y" is treated as "yy", and "yyy" is treated as "yyyy".
 *         - "z" and "zz" and "zzz" are treated as the UTC offset
 *         - "t" is treated the same as "tt".
 *         - "F", "FF", "FFF" etc. will behave the same as "f", "ff", "fff", etc.
 *           Additionally, a maximum of 3 digits (milliseconds) is supported. Longer
 *           formatters like "fffff" are truncated to 3 digits, rather than padded with zeros.
 *         - "g", "gg", and "K" are not supported at all and will be ignored.
 *     The default format is DATE_TIME_SHORT.
 * @param options {@link DateFormatOptions} specifying the timezone and display timezone of the data.
 *     If the display timezone is specified and z's appear in the format, the UTC offset will be calculated
 *     for the display timezone instead of the timezone of the browser.
 */
export function formatDate(date: Date, format?: string, options?: DateFormatOptions): string;
/**
 * Formats a date for display in the current locale using relative time.
 * @param date The date to format.
 */
export function formatDateFromNow(date: Date, options?: DateFormatOptions): string;
/**
  * Formats a number for display using the application's current locale.
  * @param num The number to format.
  * @param format One of the {@link NumberFormat} constants, or a custom format string.
  *     The format string syntax is similar to this: https://msdn.microsoft.com/en-us/library/0c899ak8.aspx,
  *     with the following exceptions:
  *         - The per-mille placeholder (‰) is not supported.
  *         - Exponential notation is not supported.
  *         - Literal characters appearing in the middle of a number will not work properly (e.g "00ABC0.##").
  * @param options Additional options that further control how numbers are formatted. These only apply
  *     when using one of the pre-defined constants, NOT for custom formats. Options are:
  *         - currency: The 3-letter ISO 4217 currency code (e.g "USD", "CAD"). Required when formatting
  *           a number using NumberFormat.CURRENCY or NumberFormat.ACCOUNTING.
  *         - fractionalDigits: The number of digits to show after the decimal point. If unspecified, an
  *           appropriate value is determined based on the locale and currency.
  */
export function formatNumber(num: number, format?: string, options?: {
    currency?: string;
    fractionalDigits?: number;
}): string;
/**
 * Parses a value into a Date object, using the application's current locale. The input is assumed to be in local time.
 * See also {@link parseUtcDate()}.
 * @param input The input to parse. Numbers are treated as UNIX timestamps (always UTC).
 * @param format The format that string input is expected to be in. Can be either a single format, or one of several
 *     possible formats. Formats are either one of the {@link DateFormat} constants, or custom format strings
 *     (as per {@link formatDate()}).
 * @return A Date object corresponding to the input, which might be an Invalid Date (i.e. getTime() will be NaN).
 */
export function parseDate(input: any, format?: string | string[]): Date;
/**
 * Parses a value into a Date object, using the application's current locale. The input is assumed to be in UTC.
 * See also {@link parseDate()}.
 * @param input The input to parse. Numbers are treated as UNIX timestamps.
 * @param format The format that string input is expected to be in. Can be either a single format, or one of several
 *     possible formats. Formats are either one of the {@link DateFormat} constants, or custom format strings
 *     (as per {@link formatDate()}).
 * @return A Date object corresponding to the input, which might be an Invalid Date (i.e. getTime() will be NaN).
 */
export function parseUtcDate(input: any, format?: string | string[]): Date;
/**
 * Parses a value into a number, using the application's current locale.
 * @param input The input to parse.
 * @param format The format that string input is expected to be in. Can be either a single format, or one of several
 *     possible formats. Formats are either one of the {@link NumberFormat} constants, or custom format strings
 *     (as per {@link formatNumber()}).
 */
export function parseNumber(input: any, format?: string | string[]): number;

}
declare module "geocortex/infrastructure/GeometryUtils" {
import { Application } from "geocortex/framework/application/Application";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { DatumTransform } from "geocortex/infrastructure/gis/DatumTransform";
import { DatumTransformParameters } from "geocortex/infrastructure/DatumTransformParameters";
import { Map as EssentialsMap } from "geocortex/essentials/Map";
export var DEFAULT_GEOMETRY_SERVICE_URI: string;
/**
 * Returns true if a given geometry is valid, false otherwise.
 * @param geometry The geometry to test.
 */
export function isValidGeometry(geometry: esri.geometry.Geometry): boolean;
/**
 * Returns an approximation of the center point of the given geometry, as measured in Cartesian space.
 * @param geometry The geometry whose center needs to be returned
 */
export function getMiddle(geometry: esri.geometry.Geometry): esri.geometry.Point;
/**
 * Returns the midpoint of the line segment defined by two endpoints.
 * @param pointA The beginning point of the line segment.
 * @param pointB The ending point of the line segment.
 */
export function getMidpoint(pointA: esri.geometry.Point, pointB: esri.geometry.Point): esri.geometry.Point;
/**
 * Returns the type of ESRI geometry
 * @param typeName
 * @param defaultType
 */
export function getEsriGeometryType(typeName: string, defaultType?: string): string;
/**
 * This "protected" method is deprecated. Use the public "getGeometryService" instead. This is being retained in order to avoid breaking external/services
 *  code that may be using it.
 */
export function _getGeometryService(app: Application): esri.tasks.GeometryService;
/**
 * Returns the ESRI geometry service
 * @param app The {@link geocortex.framework.application.Application}
 */
export function getGeometryService(app: Application): esri.tasks.GeometryService;
/**
 * Returns the ArcGis version that the geometry service is hosted on. Returns null if unable to resolve.
 * The resultant promise is never rejected. If no geometry service url is provided, will retrieve version of
 * default geometry service configured in the app.
 * @param app The {@link geocortex.framework.application.Application}
 */
export function getGeometryServiceArcGisVersion(app: Application, geometryServiceUrl?: string): Promise<number>;
/**
 * Determines if there requires a projection to go between a given Spatial Reference and the current application instance.
 * @param geometry The geometry we would like to determine if it needs to be projected
 * @param app An instance of the application (used to get the current map spatial reference).
 */
export function needsProjection(geometry: esri.geometry.Geometry, app: ViewerApplication): boolean;
/**
 * Projects a geometry from one coordinate system to another (well-known) coordinate system, firing a failure callback on error.
 * @param geometry The geometry to project.
 * @param outSR The spatial reference of the target coordinate system.
 * @param callback The callback function for success (http://help.arcgis.com/en/webapi/javascript/arcgis/help/jsapi/geometryservice.htm#onProjectComplete).
 * @param errback The error callback function.
 * @param app An instance of the application (used to get the url to the geometry service).
 */
export function projectGeometry(geometry: esri.geometry.Geometry, outSR: esri.SpatialReference, callback: (projected: esri.geometry.Geometry) => void, errback: (error: Error) => void, app: Application): void;
/**
 * Projects a geometry from one coordinate system to another (well-known) coordinate system with a transformation, firing a failure callback on error.
 * @param geometry The geometry to project.
 * @param outSR The spatial reference of the target coordinate system.
 * @param transformationWkid The WKID for the transformation to be applied.
 * @param callback The callback function for success (http://help.arcgis.com/en/webapi/javascript/arcgis/help/jsapi/geometryservice.htm#onProjectComplete).
 * @param errback The error callback function.
 * @param app An instance of the application (used to get the url to the geometry service).
 */
export function projectGeometryWithTransform(geometry: esri.geometry.Geometry, outSR: esri.SpatialReference, transformationWkid: number, callback: (projected: esri.geometry.Geometry) => void, errback: (error: Error) => void, app: Application): void;
/**
* Projects the geometries provided in the projectParameters.
* @param projectParameters The project parameters (see http://help.arcgis.com/en/webapi/javascript/arcgis/help/jsapi/projectparameters.htm).
* @param callback The callback function for success (http://help.arcgis.com/en/webapi/javascript/arcgis/help/jsapi/geometryservice.htm#onProjectComplete).
* @param errback The error callback function.
* @param app An instance of the application (used to get the url to the geometry service).
*/
export function project(projectParameters: esri.tasks.ProjectParameters, callback: Function, errback: (error: Error) => void, app: Application): void;
/**
 * Simplify the polygons.
 * @param polygons An array of esri.geometry.Polygons.
 * @param callback A function to be called with the set of simplified polygons once completed.
 * @param errback The error callback function.
 * @param app An instance of the application (used to get the url to the geometry service).
 */
export function simplifyPolygons(polygons: esri.geometry.Polygon[], callback: Function, errback: (error: Error) => void, app: Application): void;
/**
 * Simplify a polygon.
 * @param polygon A single esri.geometry.Polygon.
 * @param callback A function to be called with a simplified polygon once completed.
 * @param errback The error callback function.
 * @param app An instance of the application (used to get the url to the geometry service).
 */
export function simplifyPolygon(polygon: esri.geometry.Polygon, callback: (poly: esri.geometry.Polygon) => void, errback: (error?: Error) => void, app: Application): void;
/**
 * Projects the geometries locally.
 * @param geometries An array of geometries which needs to be projected.
 * @param outSR {esri.SpatialReference} outSR The spatial reference to which the geometries should be converted
 * @param callback A function to be called after the geometries have been projected.
 * @param errback The error callback function.
 * @private
 */
export function _projectLocally(geometries: esri.geometry.Geometry[], outSR: esri.SpatialReference, callback: (geometries: esri.geometry.Geometry[]) => void, errback: (error: Error) => void): void;
/**
 * Creates and returns a circle with given specifications
 * @params
 * spatialReference Spatial Reference of the map
 * centerPoint Center point of the circle
 * radius Radius of the circle in meters
 * ringSize Number of points in the ring that proximate the circle
 */
export function createCircle(spatialReference: esri.SpatialReference, centerPoint: esri.geometry.Point, radius: number, ringSize: number): esri.geometry.Polygon;
/**
 * Fixes the aspect ratio, such that the width or height of the envelope is expanded
 * so that the aspect ratio of the envelope matches that of the reference envelope.
 * @param envelope The envelope, whose aspect ratio should be fixed.
 * @param reference The reference envelope, to match the aspect ratio to.
 * @returns A new envelope with the width or height adjusted to match the aspect ratio of the reference envelope.
 */
export function fixAspectRatio(newExtent: esri.geometry.Extent, referenceExtent: esri.geometry.Extent): esri.geometry.Extent;
/**
 * Converts an extent to a polygon.
 */
export function extentToPolygon(envelope: esri.geometry.Extent): esri.geometry.Polygon;
/**
 * Compares two point geometries for equality. Returns true if both Point structures contain the same X, Y values and spatial reference; otherwise, false.
 */
export function pointsAreEqual(a: esri.geometry.Point, b: esri.geometry.Point): boolean;
/**
 * Registers default datum transforms. This includes RD New (28992), British National Grid (27700), and Czech S-JTSK(102067).
 */
export function registerDefaultDatumTransforms(): void;
/**
 * Registers the datum transform to be used when projecting geometries between the specified spatial references.
 * @param datumTransforms An array of datum transforms to add to the registry
 */
export function registerDatumTransforms(datumTransforms: DatumTransform[]): void;
/**
 * Retrieves the datum transform to be used when projecting geometries between the specified spatial references, and whether to transform forward.
 * @param from The spatial reference you are projecting from.
 * @param to The spatial reference you are projecting to.
 * @returns An object with the properties `transformation` and `transformForward`, relating to the datum transform for the given spatial reference parameters.
 */
export function getDatumTransformParameters(from: esri.SpatialReference, to: esri.SpatialReference): DatumTransformParameters;
/**
 * Determines whether or not the geometries intersect.
 * @param geometry1 The geometry that is tested for the intersects relationship to the other geometry.
 * @param geometry2 The geometry being intersected.
 * @return A promise for whether or not the geometries intersect.
 */
export function intersects(geometry1: esri.geometry.Geometry, geometry2: esri.geometry.Geometry): Promise<boolean>;
export function unionGeometries(geometries: esri.geometry.Geometry[]): Promise<esri.geometry.Geometry>;
/**
 * Converts a specified number of meters on the current map given the current coordinate system (geographic or projected) to the corresponding number of map points.
 */
export function convertMetersToMapPoints(essentialsMap: EssentialsMap, inputMeters: number): Promise<number>;
/**
 * Separate a multi-part geometry into a list of individual geometries.
 * @param geometry The geometry to separate.
 */
export function explodeGeometry(geometry: esri.geometry.Geometry): esri.geometry.Geometry[];
/**
 * Split polyline or polygon geometries where they cross the cutter polyline.
 * @param geometries The polyline or polygon geometries to cut.
 * @param cutter The polyline used to cut the geometries.
 * @param app The {@link geocortex.framework.application.Application}.
 */
export function cutGeometries(geometries: esri.geometry.Geometry[], cutter: esri.geometry.Polyline, app: Application): Promise<esri.geometry.Geometry[][]>;
/**
 * Converts an envelope to a ring.
 */
export function toRing(env: esri.geometry.Extent): number[][];
/**
 * Creates a tolerance envelope around a point. Only applies to points; other geometries are returned as-is.
 * @param map The map instance.
 * @param geometry The geometry to create an envelope for.
 * @param pixelTolerance A positive integer that defines the maximum number of pixels away from the point geometry. Determines the width of the generated envelope.
 */
export function createToleranceEnvelope(map: esri.Map, geometry: esri.geometry.Geometry, pixelTolerance: number): esri.geometry.Geometry;
export function getRamerDouglasPeuckerSimplifiedGeometry(geom: esri.geometry.Geometry, epsilon: number): esri.geometry.Geometry;

}
declare module "geocortex/infrastructure/GraphicsLayerIds" {
/**
 * These strings are exported from mapping.infrastructure so that multiple modules can reference common graphics layers
 * without hardcoding their names. Though some of these are 'let' they cannot be modified once exported.
 * The only valid place to change the base id for markup (MARKUP_LAYER_ID) is in MarkupViewModel.ts, where it can be user configured.
 * Use the exported function to do this.
 *
 * TODO: Audit and consolidate graphics layers where possible. This is a lot of layers! Some of them can easily be reused!!
 */
/**
 * ID of the graphics layer used for markup and measurement markup (not measurement text)
 */
export let MARKUP_LAYER_ID: string;
/**
 * ID of the graphics layer used for coordinates. Must always be MARKUP_LAYER_ID + "_coordinates"
 */
export let COORDINATES_LAYER_ID: string;
/**
 * ID of the graphics layer used for measurement text. Must always be MARKUP_LAYER_ID + "_measurement"
 */
export let MEASUREMENT_LAYER_ID: string;
/**
 * ID of the graphics layer used for pushpins
 */
export const PUSHPINS_LAYER_ID = "DefaultPushpinsLayer";
/**
 * ID of the graphics layer used for highlights. Note that external projects may still create highlight layers with thier own graphics layers and not use this common one.
 */
export const HIGHLIGHT_LAYER_ID = "DefaultHighlightLayer";
/**
 * ID of the graphics layer used for collaboration markup
 */
export const COLLABORATION_LAYER_ID = "__CollaborationGraphicsLayer";
/**
 * ID of the temp graphics layer used by collaboration;
 */
export const COLLABORATION_SCRATCH_LAYER_ID = "CollaborationScratch";
/**
 * ID of the graphics layer used for snapping graphics
 */
export const SNAPPING_GRAPHICS_LAYER_ID = "snapping_graphics";
/**
 * ID of the graphics layer used for snapping helper graphics
 */
export const SNAPPING_HELPER_GRAPHICS_LAYER_ID = "snapping_helper_graphics";
/**
 * ID of the graphics layer used to temporarily hold edited graphics when snapping
 */
export const TEMP_SNAPPING_EDITOR_LAYER_ID = "temp_snapping_graphics_editing";
/**
 * ID of the graphics layer used for the Area of Interest mask
 */
export const AOI_MASK_LAYER_ID = "AreaOfInterestMask";
/**
 * ID of the layer used when editing a feature (by EditingModule)
 */
export const EDITING_LAYER_ID = "editing_layer";
/**
 * ID of the layer that is also used when editing a feature (by EditorViewModel) (?)
 */
export const EDITOR_CLONE_LAYER_ID = "editor_clone_layer";
/**
 * ID of the layer used for geolocation graphics
 */
export const GEOLOCATION_LAYER_ID = "geolocation_layer";
/**
 * ID of the layer used for 3rd party map indicators
 */
export const VIEWPOINT_INDICATOR_GRAPHICS_LAYER_ID = "viewpointIndicatorGraphicsLayer";
/**
 * ID of the layer used for 3rd party map graphics
 */
export const INTEGRATION_GRAPHICS_LAYER_ID = "integrationGraphicsLayer";
/**
 * ID of the graphics layer used by the Markers module
 */
export const MARKER_GRAPHICS_LAYER_ID = "MarkerGraphicsLayer";
/**
 * ID of a layer used for 'temporary markup'
 */
export const TEMP_GRAPHICS_LAYER_ID = "TemporaryMarkup";
/**
 * Only use this function to change the graphics layer ids, and then only on startup when none are created yet.
 * @param id The base id to use for graphics layers.
 */
export function changeGraphicsLayerIdBase(id: string): void;

}
declare module "geocortex/infrastructure/GraphicsLayerUtils" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { ClickableOptions } from "geocortex/infrastructure/clickableGraphics/ClickableOptions";
export const ExcludeFromEnum: {
    WebMapName: string;
    ExportApplyStateName: string;
    ExportMapTaskName: string;
};
/**
 * Types of graphics layer created internally by the Viewer. These need to be kept in a certain order.
 * Pushpins on top, labels below this, highlights underneath labels, and all above markup.
 */
export const GraphicsLayerType: {
    Pushpin: string;
    Label: string;
    Highlight: string;
    Markup: string;
};
/**
 * Create a new graphics layer and place it in the correct order in the map graphics layers collection.
 * @param id {string} Id of the graphics layer.
 * @param app {ViewerApplication} Reference to the ViewerApplication
 * @param layerType {GraphicsLayerType} One of "Pushpin", "Label", Highlight" or "Markup". Only required for layer creation. To simply retrieve a layer leave this out.
 * @param [registerClickable = true] {boolean} Auto-register this markup layer as clickable? Ignored for other layer types.
 */
export function getInternalGraphicsLayer(id: string, app: ViewerApplication, layerType?: string, registerClickable?: boolean): esri.layers.GraphicsLayer;
/**
 * Call this function to remove an internal graphics layer. This just ensures that the internal layer count
 * is correct and that new layers get added to the right location.
 * @param id {string} Id of the layer to remove
 * @param app {ViewerApplication}
 * @param layerType {GraphicsLayerType} Type of layer being removed. No checks performed to see if this is 'right'
 */
export function removeInternalGraphicsLayer(id: string, app: ViewerApplication, layerType: string): void;
/**
 * This method registers the markup layer as a clickable graphic layer
 * @param layer The markup layer
 * @param app The application that this module belongs to
 */
export function registerMarkupLayerAsClickable(layer: esri.layers.GraphicsLayer, app: ViewerApplication): void;
/**
 * This method registers the stream layer as a clickable graphic layer
 * @param layer The stream layer
 * @param app The application that this module belongs to
 * @param displayName The display name for the Stream layer
 */
export function registerStreamLayerAsClickable(layer: esri.layers.GraphicsLayer, app: ViewerApplication, displayName: string): void;
/**
 * This method registers a WFS layer as a clickable graphic layer
 * @param layer The WFS layer
 * @param app The application that this module belongs to
 * @param displayName The display name for the WFS layer
 */
export function registerWfsLayerAsClickable(layer: esri.layers.WFSLayer, app: ViewerApplication, displayName: string): void;
/**
 * Convenience method to register a graphics layer as clickable if it's not been registered already.
 * @param: layer The graphics layer to register
 * @param app The application this module belongs to
 * @param options The optional Clickable Options
 * @return True if successfully registered, false otherwise.
 */
export function tryRegisterClickableLayer(app: ViewerApplication, layer: esri.layers.GraphicsLayer, options?: ClickableOptions): boolean;
/**
 * Gets the map's graphics layers that are neither associated with the Essentials site nor used internally by GVH, all graphics layers except those excluded.
 */
export function getGraphicsLayersExceptExcluded(app: ViewerApplication, excludeFromList: string[]): esri.layers.GraphicsLayer[];
/**
 * Add a graphic to the specified layer. You must create the layer first.
 * @param graphic The graphic to be added
 * @param layerId The layer ID to add the graphic to
 * @app The app that this module belongs to
 * @return A boolean returning true on success and false otherwise
 */
export function addGraphicToLayer(graphic: esri.Graphic, layerId: string, app: ViewerApplication): boolean;

}
declare module "geocortex/infrastructure/GraphicUtils" {
import { Layer } from "geocortex/essentials/Layer";
import { Field } from "geocortex/essentials/Field";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { Feature } from "geocortex/infrastructure/Feature";
import { ClickableLayerInfo } from "geocortex/infrastructure/clickableGraphics/ClickableLayerInfo";
/**
 * Modifies the attributes array of the graphic so that it the keys are attribute
 * names instead of aliases (as defined in ArcGIS Server).  Those attributes
 * that are defined using attribute names will not be modified.
 * @param graphic The ESRI graphic
 * @param layer The Geocortex Essentials layer
 */
export function sanitizeAttributeNames(graphic: esri.Graphic, layer: Layer): void;
/** @private GVH-3473 Skip attribute names generated by SEP */
export function _isSEPCodedDomainField(field: Field, layer: Layer): boolean;
/**
 * Utility method to execute the deleteMarkup function silently without any prompts even if multiple markup are being deleted
 * @param geometry The geometry defining the area within which to delete markup. Typically passed in by the MapTool
 * @param layerIds A string array of id's of layers to delete markup from
 * @param app The current application instance
 * @param callback An optional callback function which, if defined, will be passed the array of deleted graphics.
 * @param onlyMeasurementMarkup: An optional parameter which if true will only delete measurement markup and labels from the specified layers. Defaults to false.
 */
export function deleteMarkupSilently(geometry: esri.geometry.Geometry, layerIds: string[], app: ViewerApplication, callback?: (deletedGraphics: esri.Graphic[]) => void, onlyMeasurementMarkup?: boolean): void;
/**
 * Utility method for the "DeleteMarkup" and "DeleteMeasurement" commands, common to the Markup and Measurement modules. Placing it here ensures that there's no dependency between the two modules and no
 * duplication of code. This method will delete all graphics from the given layer(s) and will display a warning if multiple items are being deleted (if configured). It can be run in two modes - if
 * onlyMeasurementMarkup is true, it will delete only markup which is tagged by the measurement module - otherwise it will delete all markup.
 * @param geometry The geometry defining the area within which to delete markup. Typically passed in by the MapTool
 * @param layerIds A string array of id's of layers to delete markup from
 * @param app The current application instance
 * @param callback An optional callback function which, if defined, will be passed the array of deleted graphics.
 * @param onlyMeasurementMarkup: An optional parameter which if true will only delete measurement markup and labels from the specified layers. Defaults to false.
 * @param multipleMarkupWarnMsg An optional string defining the language resource for the warning to be displayed if more than one markup is being deleted. If not provided, will disable this warning.
 * @param multipleMarkupWarnTitle An optional string defining the language resource for the title for the aforementioned warning.
 * @param libraryId An optional string defining the library id to retrieve the aforementioned language resources from. Defaults to "Mapping"
 */
export function deleteMarkup(geometry: esri.geometry.Geometry, layerIds: string[], app: ViewerApplication, callback?: (deletedGraphics: esri.Graphic[]) => void, onlyMeasurementMarkup?: boolean, multipleMarkupWarnMsg?: string, multipleMarkupWarnTitle?: string, libraryId?: string): void;
/**
 * Retrieves graphics contained within an extent specified by the given geometry from a given layer on the map.
 * @param geometry The geometry defining the area on the specified layer from which to extract markup
 * @param graphicsLayer The esri layer from which to extract markup
 * @param app The current application instance
 * @param markerSymbolBufferSize Optional. Represents the size of the box to buffer for a graphic with a simple/picture marker symbol. Defaults to the size of the bounding box of symbol in pixels.
 * @param pointBufferSize Optional. Represents the size of the box to buffer with the given point geometry as it's center. Defaults to 6.
 * @return An array of esri.Graphic objects contained within the specified geometry on the specified layer.
 */
export function getMarkupFromGeometry(geometry: esri.geometry.Geometry, graphicsLayer: esri.layers.GraphicsLayer, app: ViewerApplication, markerSymbolBufferSize?: number, pointBufferSize?: number): esri.Graphic[];
/** Get the extent represented by the geometry
 *  @param geometry The geometry whose extent needs to be returned.
 *  @param app The current application instance.
 *  @param pointBufferSize. Represents the size of extent to be created. Only applicable for point geometry.
 *  @returns The extent created from geometry.
 */
export function getExtentFromGeometry(geometry: esri.geometry.Geometry, app: ViewerApplication, pointBufferSize: number): esri.geometry.Extent;
/**
 * Checks if the supplied geometry intersects the supplied graphic.
 * @param geometry The geometry defining the area which might contain the graphic.
 * @param graphic The graphic which might be contained within the supplied geometry.
 * @param app The current application instance.
 * @return Promise Indicating if the esri.Graphic is contained within the supplied geometry.
 */
export function geometryIntersectsGraphic(geometry: esri.geometry.Geometry, graphic: esri.Graphic, app: ViewerApplication): Promise<boolean>;
/** @private Returns enhanced geometry which has proper hit area specified by markerSymbolBufferSize for the supplied pointgraphic and pointsymbol*/
export function _getEnhancedGeometryOfPointGraphic(pointGraphic: esri.Graphic, pointSymbol: esri.symbol.Symbol, app: ViewerApplication, markerSymbolBufferSize: number): esri.geometry.Polygon;
/** @private Returns enhanced geometry which has proper hit area specified by markerSymbolBufferSize for the supplied multipointgraphic and multipointSymbol*/
export function _getenhancedPolygonGeometryOfMultipoint(multipointGraphic: esri.Graphic, multipointSymbol: esri.symbol.Symbol, app: ViewerApplication, markerSymbolBufferSize: number): esri.geometry.Polygon;
/** @private Returns enhanced geometries which has proper hit area.
 ** We have enhanced geometries for every point of multipoint graphic. The size of enhanced geometry is specified by markerSymbolBufferSize
*/
export function _getEnhancedGeometriesOfMultiPoint(multipointGraphic: esri.Graphic, app: ViewerApplication, markerSymbolBufferSize: number): Array<esri.geometry.Polygon>;
/** @private Returns the enhanced geometry for supplied text graphic and textSymbol. Here we get the size of the text markup, and make a 'hit box' for the text to see if the user clicked it. */
export function _getEnhancedGeometryOfTextGraphic(textGraphic: esri.Graphic, textSymbol: esri.symbol.TextSymbol, app: ViewerApplication): esri.geometry.Polygon;
/**
 * Utility method to get size of the bounding box for simplemarkersymbol and picturemarkersymbol.
 * Note - Supports only simplemarkersymbol and picturemarkersymbol. Doesn't support visual variables.
 * @param sourceGraphic The graphic for which we want to get size of bounding box.
 * @param app Optional The current application instance.
 * @return The size of the bounding box.
*/
export function getBoundingBoxSize(sourceGraphic: esri.Graphic, app?: ViewerApplication): number;
/** @private */
export function _toRadians(degrees: number): number;
/**
 * Function to rotate any given polygon by a specified angle. Returns a rotated copy of the original polygon.
 * @param degreesClockwise The angle to rotate the polygon in, specified in degrees, in a clockwise direction (as is standard for esri)
 * @param pivotMapPoint The "pivot" around which to rotate the polygon. Is not required to lie on or within the polygon
 * @param polygon The polygon to rotate.
 * @return A rotated copy of the original polygon
 */
export function rotatePolygon(degreesClockwise: number, pivotMapPoint: esri.geometry.Point, polygon: esri.geometry.Polygon): esri.geometry.Polygon;
/** Function to generate a polygon containing a specified incircle with a given point as it's center.
 *  @param point The center of the specified incircle
 *  @param diameter The diameter of the specified incircle
 *  @param app The current application instance
 *  @param xoffset Optional. Represents the x offset.
 *  @param yoffset Optional. Represents the y offset.
 *  @return A polygon containing an incircle of the specified diameter, with the specified point as its center
 */
export function getPolygonFromPoint(point: esri.geometry.Point, diameter: number, app: ViewerApplication, xoffset?: number, yoffset?: number): esri.geometry.Polygon;
/**
 * Measures the actual rendered size of a text markup in pixels
 * @param labelStr: The text label to measure label size for
 * @param fontFamily The font family to be applied to the text
 * @param fontSize The size of the text in pixels
 * @param fontWeight Specifies weight of the font. Defaults to normal.
 * @return An object with the width and height of the specified label
 */
export function getRenderedTextMarkupSize(labelStr: string, fontFamily: string, fontSize: number, fontWeight?: string): {
    width: number;
    height: number;
};
export function getRenderedTextMarkupSize(labelStr: string, fontFamily: string, fontSize: string, fontWeight?: string): {
    width: number;
    height: number;
};
/**
 * Move a graphic on a graphics layer to the top. A low cost way to keep graphics organized
 * @param graphic The graphic to move.
 */
export function moveGraphicToTop(graphic: esri.Graphic): void;
/**
 * Checks whether the supplied graphic belongs to a clickable graphic layer.
 * @param app The application that this module belongs to
 * @param graphic The graphic to be checked
 * @return A boolean returning true if the supplied graphic belongs to a clickable graphic layer, false otherwise
 */
export function isClickableGraphic(app: ViewerApplication, graphic: esri.Graphic): boolean;
/**
 * Check whether the supplied feature is an editable (but not auto editable) clickable feature
 * @param feature The feature to check
 */
export function isEditableButNotAutoEditableClickableFeature(app: ViewerApplication, feature: Feature): boolean;
/**
 * Check whether the supplied feature is an auto-editable clickable feature
 * @param feature The feature to check
 */
export function isAutoEditableClickableFeature(app: ViewerApplication, feature: Feature): boolean;
/**
 * Returns the clickable layer info for a supplied graphic
 * @param The graphic to get layerInfo for
 */
export function getClickableLayerInfo(app: ViewerApplication, graphic: esri.Graphic): ClickableLayerInfo;
/**
 * Given a clickable graphic and a layerInfo (optional) returns the capabilities of that graphic
 * @param graphic The clickable graphic
 * @param layerInfo The layer info that goes with that graphic (optional)
 */
export function getCapabilitiesForGraphic(app: ViewerApplication, graphic: esri.Graphic, layerInfo?: ClickableLayerInfo): string[];
/** Deprecated methods for compatibility purposes follow */
/**
 * Retrieve the graphic layer with the specified id if it exists. If 'create' is true, create it if it doesn't
 * @param id {string} The layer ID to retrieve or to create
 * @param create {boolean} Create the layer if it doesn't exist if this is true
 * @param app {ViewerApplication} The application that this module belongs to
 * @return The retrieved or created Graphics layer
 * @deprecated 2.8 - Use GraphicsLayerUtils.getInternalGraphicsLayer directly.
 */
export function getGraphicsLayer(id: string, create: boolean, app: ViewerApplication): esri.layers.GraphicsLayer;
/**
 * Retrieve the markup layer with the specified id if it exists. If it doesn't exist, it will be created.
 * This method also optionally registers the markup layer as a clickable graphic layer.
 * @param app The application that this module belongs to
 * @return The retrieved or created Graphics layer
 * @deprecated 2.8 - Use GraphicsLayerUtils.getInternalGraphicsLayer directly
 */
export function getMarkupLayer(id: string, app: ViewerApplication): esri.layers.GraphicsLayer;
/**
 * Gets the map's graphics layers that are neither associated with the Essentials site nor used internally by GVH.
 * @deprecated as of GVH 2.8. use GraphicsLayerUtils.getGraphicsLayersExceptExcluded instead.
 */
export function getUserGraphicsLayers(app: ViewerApplication): esri.layers.GraphicsLayer[];
/**
 * Add a graphic to the specified layer. You must create the layer first.
 * @param graphic The graphic to be added
 * @param layerId The layer ID to add the graphic to
 * @app The app that this module belongs to
 * @return A boolean returning true on success and false otherwise
 * @deprecated 2.8 - Use GraphicsLayerUtils.addGraphicToLayer.
 */
export function addGraphicToLayer(graphic: esri.Graphic, layerId: string, app: ViewerApplication): boolean;

}
declare module "geocortex/infrastructure/HighlightLayer" {
import { SimpleRenderer } from "geocortex/infrastructure/SimpleRenderer";
/**
 * Abstraction of a graphics layer that allows multiple clients to place highlights on a single layer without interfering
 */
export class HighlightLayer {
    /** Name of this highlight layer */
    name: string;
    /** Underlying graphics layer */
    graphicsLayer: esri.layers.GraphicsLayer;
    /** Collection of graphics in this 'layer' */
    graphics: esri.Graphic[];
    innerHighlightBorderRenderer: SimpleRenderer;
    outerHighlightBorderRenderer: SimpleRenderer;
    innerFocusBorderRenderer: SimpleRenderer;
    outerFocusBorderRenderer: SimpleRenderer;
    constructor(name: string, layer: esri.layers.GraphicsLayer);
    /**
     * Add a graphic to the highlight layer
     * @param graphic
     */
    add(graphic: esri.Graphic): void;
    /**
     * Remove a graphic from the highlight layer
     * @param graphic
     */
    remove(graphic: esri.Graphic): void;
}

}
declare module "geocortex/infrastructure/HighlightManager" {
import { ModuleState } from "geocortex/infrastructure/project/ModuleState";
import { OperationalLayer } from "geocortex/infrastructure/project/OperationalLayer";
import { Feature } from "geocortex/infrastructure/project/Feature";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { Feature as InfrastructureFeature } from "geocortex/infrastructure/Feature";
import { HighlightLayer } from "geocortex/infrastructure/HighlightLayer";
export interface HighlightModuleConfig {
    fillColor?: string;
    borderColor?: string;
    outerBorderColor?: string;
    focusedFillColor?: string;
    focusedBorderColor?: string;
    outerFocusedBorderColor?: string;
    borderWidth?: number;
    outerBorderWidth?: number;
    highlightLineOpacity?: number;
    additionalLayers?: AdditionalHighlightLayer[];
    maxHighlightableGeometryVertices?: number;
    geometryGeneralization?: GeometryGeneralizationSettings;
}
export interface AdditionalHighlightLayer {
    name: string;
    borderColor?: string;
    borderWidth?: number;
    fillColor?: string;
}
export interface GeometryGeneralizationSettings {
    geometryGeneralizationEnabled: boolean;
    thresholdVertices: number;
    maxDeviationInMeters: number;
}
/**
 * These are the names of the Highlight 'layers' managed by this module, and not the ids of graphics layers
 * By default all highlights are displayed on a single graphics layer, though multiple can still be created for backwards compatibility
 */
export const DEFAULT_HIGHLIGHT_LAYER_NAME = "Default";
export const EDITOR_HIGHLIGHT_LAYER_NAME = "Editor";
/** Custom property on a graphic that stores the 'highlight id', which is a hash of the feature geometry */
export const HIGHLIGHT_ID_PROPERTY = "__gcxHlId";
/**
 * Represents the saved project state for the highlight manager.
 */
export interface HighlightManagerState extends ModuleState {
    /** The set of graphics layers which have been used for highlights. */
    highlightLayers: {
        [id: string]: OperationalLayer;
    };
    /** The name of the active highlight layer. */
    activeHighlightLayerName: string;
    /** A set of feature/layer pairs indicating which features have been highlighted on which highlight layer(s). */
    highlights: [{
        /** The feature (esri graphic) that is being highlighted. */
        feature: Feature;
        /** The layer that this highlight originally came from */
        originalLayer: string;
        /** The highlight layer where this feature is being highlighted (there can be more than one). */
        highlightLayer: string;
        /** Do these highlights use the default highlight graphics layer, or do they have their own? Added @ 2.8.1 */
        useDefaultHighlightLayer: boolean;
    }];
}
export class HighlightManager {
    /**
     * The {@link ViewerApplication} that this module belongs to.
     */
    app: ViewerApplication;
    /**
     * Default configuration for highlight layers
     */
    config: HighlightModuleConfig;
    /**
     * ID of the currently active highlight layer
     */
    activeHighlightLayerName: string;
    /**
     * This function will be invoked if the max highlightable vertices threshold is exceeded (after generalization if configured). Such graphics will not be highlighted.
     */
    onMaxGeometryVerticesExceeded: (graphic: esri.Graphic) => void;
    /**
     * Collection of named highlight layers
     * @private
     */
    private _highlightLayers;
    /**
     * The collection of object id of the original graphic to mapping objects that contain the managed (original) graphic, and the cloned graphics, and layer
     * This is structured so that a single graphic (keyed by gcxHlId) can appear highlighted on multiple layers. Each ManagedGraphic in the array
     * represents an instance of that graphic on a different highlight layer. This is important, for example, when a feature in a map tip
     * is also identified and appears in the results list.
     * @private
     */
    private _managedGraphics;
    /**
     * Control the appearance of borders when set with a command that has a single width parameter.
     */
    private _minBorder;
    private _defaultBorderOffset;
    private _ramerGeomGeneralizationDisabled;
    private _ramerDeviationInMeters;
    private _ramerEpsilon;
    private _ramerGeomVerticesThreshold;
    private _maxHighlightableGeometryVertices;
    private _geometryCache;
    private _maxGeomCacheItems;
    /**
     * A list of ids corresponding to suppressed highlights. This is used by editing to temporarily disable highlighting,
     * with the ability to restore to the original state afterwards.
     */
    private _supressedHighlightIds;
    /**
     * Initializes a new instance of an {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.HighlightManager} object.
     * @class
     * <p>The central system for highlighting features.</p>
     * @constructs
     * @memberOf geocortex.essentialsHtmlViewer.mapping.infrastructure
     * @param app The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this module belongs to.
     */
    constructor(app: ViewerApplication);
    /**
     * Gets the current fill color.
     * Returns the 6 or 8 digit hex color in RGB or ARGB form.
     * The transparent fill is applied to the bottom graphic.
     */
    getHighlightFillColor(layer?: string | HighlightLayer): string;
    /**
     * Gets the current border color.
     * Returns the 6 or 8 digit hex color in RGB or ARGB form.
     * The bright color of the inner line is taken to be the highlight color
     */
    getHighlightBorderColor(layer?: string | HighlightLayer): string;
    /**
     * Gets the current border width.
     * Returns the width of the bottom border.
     */
    getHighlightBorderWidth(layer?: string | HighlightLayer): number;
    /**
     * Sets the fill color to the one specified.
     * @param {String} color Any color format accepted by dojo.Color constructor.
     */
    setHighlightFillColor(color: string | esri.Color, layer?: string | HighlightLayer): void;
    /**
     * Sets the border color to the one specified. Used by commands and config that takes a single color
     * @param {String} color Any color format accepted by dojo.Color constructor.
     */
    setHighlightBorderColor(color: string | esri.Color, layer?: string | HighlightLayer): void;
    /**
     * Individual setter for outer highlight border color
     */
    setOuterHighlightBorderColor(color: string | esri.Color, layer?: string | HighlightLayer): void;
    /**
     * Individual setter for inner highlight border color
     */
    setInnerHighlightBorderColor(color: string | esri.Color, layer?: string | HighlightLayer): void;
    /**
     * Sets the border width to the one specified. Note that highlights and focus have the same border width at the moment.
     * This is for commands that use a single value to set the highlight border width.
     * @param {number} width The number (in pixels) for the width of the highlight.
     */
    setBorderWidth(width: number, layer?: string | HighlightLayer): void;
    /**
     * Individual setter for inner border width.
     */
    setInnerBorderWidth(width: number, layer?: string | HighlightLayer): void;
    /**
     * Individual setter for outer border width.
     */
    setOuterBorderWidth(width: number, layer?: string | HighlightLayer): void;
    /**
     * Gets the current focused fill color.
     * Returns the 6 or 8 digit hex color in RGB or ARGB form.
     */
    getFocusedFillColor(layer?: string | HighlightLayer): string;
    /**
     * Gets the current focused border color.
     * Returns the 6 or 8 digit hex color in RGB or ARGB form.
     */
    getFocusedBorderColor(layer?: string | HighlightLayer): string;
    /**
     * Sets the focused fill color to the one specified.
     * @param {String} color Any color format accepted by dojo.Color constructor.
     */
    setFocusedFillColor(color: string, layer?: string | HighlightLayer): void;
    /**
     * Sets the focused border color to the one specified. Used by commands and config that takes a single color
     * @param {String} color Any color format accepted by dojo.Color constructor.
     */
    setFocusedBorderColor(color: string, layer?: string | HighlightLayer): void;
    /**
     * Individual setter for outer focus border color
     */
    setOuterFocusedBorderColor(color: esri.Color | string, layer?: string | HighlightLayer): void;
    /**
     * Individual setter for inner focus border color
     */
    setInnerFocusedBorderColor(color: esri.Color | string, layer?: string | HighlightLayer): void;
    /**
     * Sets the opacity of polyline highlights. Other geometry types are not affected.
     */
    setHighlightLineOpacity(opacity: number, layer?: string | HighlightLayer): void;
    /**
     * Applies the default highlight configuration to the named highlight layer
     * @param layer
     */
    applyHighlightConfiguration(layerName: string): void;
    /**
     * Gets the set of graphics layers used by highlight layers, keyed by name.
     * @DEPRECATED: This method doesn't really make sense anymore as a single graphics layer can be used by multiple highlight layers.
     */
    getHighlightLayers(): {
        [name: string]: esri.layers.GraphicsLayer;
    };
    /**
     * Gets the set of infrastructure.HighlightLayer currently in use, keyed by name.
     */
    getInternalHighlightLayers(): {
        [name: string]: HighlightLayer;
    };
    /**
     * Gets the maximum number of vertices a geometry can contain for it to be highlightable. A value of '0' means unlimited.
     */
    getMaxHighlightableGeometryVertices(): number;
    /**
     * Sets the maximum number of vertices a geometry can contain for it to be highlightable. A value of '0' means unlimited.
     */
    setMaxHighlightableGeometryVertices(val: number): void;
    /**
     * Creates a new highlight layer that uses its own graphics layer, returning the graphics layer used.
     * @DEPRECATED: Use highlightManager.getOrCreateInternalHighlightLayer, with the option to use a unique or common graphics layer
    * @param {String} layerName The name of the layer to create.
    * @param {String|number} fillColor The color to fill with, leave as null for default
    * @param {String|number} borderColor The color to color the border with, leave as null for default
     */
    getOrCreateHighlightLayer(layerName: string, fillColor?: any, borderColor?: any): esri.layers.GraphicsLayer;
    /**
     * Creates a new highlighting layer with the specified name. This will throw an error if a layer with the specified name exists.
     * @param {String} layerName The name of the layer to create.
     * @param {String|number} fillColor The color to fill with, leave as null for default
     * @param {String|number} borderColor The color to color the border with, leave as null for default
     */
    getOrCreateInternalHighlightLayer(layerName: string, fillColor?: any, borderColor?: any, useCommonGraphicsLayer?: boolean): HighlightLayer;
    /**
     * Sets the active highlight layer.
     * This is the layer that new features will be added to, or cleared from.
     * TODO: Deprecate this concept entirely. Still technically necessary from workflow if managing multiple highlight layers though.
     * @param {String} layerName The name of the layer to set as Active.
     */
    setActiveHighlightLayer(layerName: string): void;
    /**
     * Sets the geometry generalization parameters. If any of the parameters is 0 or invalid, generalization is disabled.
     * @return Returns a promise which is resolved when the appropriate internal parameters are computed and applied.
     */
    setGeometryGeneralizationParams(thresholdVertices: number, maxDeviationInMeters: number): Promise<void>;
    /**
    * Gets the geometry generalization parameters. If any of the parameters is 0, generalization is disabled.
    */
    getGeometryGeneralizationParams(): {
        thresholdVertices: number;
        maxDeviationMeters: number;
    };
    /**
     * Highlights the features in the Esri Feature Set provided, and adds them to the active highlight later, or the layer specified layer.
     * Features added will take the fill and border color that are currently set.
     * @param {esri.tasks.FeatureSet} esriFeatureSet The Esri feature set to highlight.
     * @param {String} [highlightLayerId] The highlight layer to add the highlights to.
     */
    highlightEsriFeatureSet(esriFeatureSet: esri.tasks.FeatureSet, highlightLayerName?: string): void;
    /**
     * Highlights the features in the list of features provided, and adds them to the active highlight later, or the user specified layer.
     * Features added will take the fill and border color that are specified in the feature, or the current highlight colors if one is not specified.
     * @param {geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature[]} features The list of features to highlight.
     * @param {String} [highlightLayerId] The highlight layer to add the highlights to.
     */
    highlightFeatures(features: InfrastructureFeature[] | esri.Graphic[], highlightLayerId?: string): void;
    /**
     * Highlights the provided graphics on the provided layer (or default)
     * @DEPRECATED call highlightManager.highlightFeatures instead, or use the commands from HighlightModule
     */
    highlightGraphics(graphics: esri.Graphic[], highlightLayerName?: string): void;
    /**
     * Highlights and focuses the features in the list of features provided, and adds them to the active highlight later, or the layer specified layer.
     * Features added will take the fill and border color that are specified in the feature, or the current highlight colors if one is not specified.
     * @param {geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature[]} features The list of features to highlight.
     * @param {String} [highlightLayerId] The highlight layer to add the highlights to.
     */
    focusFeatures(features: InfrastructureFeature[] | esri.Graphic[], highlightLayerId?: string): void;
    /**
     * Same as above, but the wrong name
     * @DEPRECATED: Please use highlightManager.focusFeatures
     */
    emphasizeFeatures(features: InfrastructureFeature[] | esri.Graphic[], highlightLayerId?: string): void;
    /**
     * Clears the specified features from the specified (or default) highlight layer
     * @param features
     * @param highlightLayerName
     */
    clearHighlight(features: InfrastructureFeature[] | esri.Graphic[], highlightLayerName?: string): void;
    /**
     * Suppresses highlights, with the ability to return to the original state by calling enableHighlight
     * Note that highlights will be suppressed across all layers the geometry appears on (to deal properly with temp editing layers)
     * @param graphic The graphic to supress.
     */
    suppressHighlight(graphic: esri.Graphic): void;
    /**
     * Enables highlights on a graphic which has been suppressed. This will restore the original highlighted/focused state
     * @param graphic The graphic to enable.
     */
    enableHighlight(graphic: esri.Graphic): void;
    /**
     * Given a graphic, this method will change all stored highlights using the attached or supplied highlightId
     * to use a new highlightId created from the geometry of the graphic. Use when a graphics geometry changes.
     * @param graphic
     * @param originalHighlightId
     */
    updateHighlightId(graphic: esri.Graphic, originalHighlightId?: string): void;
    /**
     * Clears the focused highlights on features in the list of features provided, returning them to the default highlight state
     * @param {geocortex.essentialsHtmlViewer.mapping.infrastructure.Feature[]} features The list of features to highlight.
     * @param {String} [highlightLayerId] The highlight layer to add the highlights to.
     */
    clearFocus(features: InfrastructureFeature[] | esri.Graphic[], highlightLayerName?: string): void;
    /**
     * Same as above, but has the wrong name
     * @DEPRECATED: Please use highlightManager.clearFocus instead.
     */
    clearEmphasis(features: InfrastructureFeature[] | esri.Graphic[], highlightLayerName?: string): void;
    /**
     * Removes the layer with the specified name, and any associated highlights.
     * @param {String} layerName The name of the layer to remove.
     */
    removeHighlightLayer(layerName: string): void;
    /**
     * Clears the highlights from the default layer, or the named or provided layer if one is named or provided.
     * @param {String|esri.layers.GraphicsLayer|HighlightLayer} [layerName] The name of or layer to clear.
     */
    clearHighlights(layer?: esri.layers.GraphicsLayer | HighlightLayer | string): void;
    /**
     * Called when LayerVisualizationChangedEvent fires. Will reapply highlight symbology using the renderer currently active on the layer.
     */
    refreshHighlights(highlightLayerId?: string): void;
    /**
     * Redraws the current set of highlights. If any have been suppressed or have changed geometries this will update them.
     */
    redrawHighlights(highlightLayerId?: string): void;
    /**
     * Gets a highlight layer with the specified name.
     * @param {String} layerName The name of the layer to get.
     * @returns {infrastructure.HighlightLayer} highlight layer
     */
    getInternalHighlightLayer(layerName: string): HighlightLayer;
    /**
     * Gets the graphics layer associated with a particular highlight layer name
     * @DEPRECATED: use highlightManager.getInternalHighlightLayer and check the graphicsLayer property on the returned object
     */
    getHighlightLayer(layerName: string): esri.layers.GraphicsLayer;
    /**
     * Gets a highlight layer with the specified name, or the active layer if one is not specified.
     * @param {String} [layerName] The name of the layer to get.
     * @returns {esri.layer.GraphicsLayer} highlight layer
     */
    getInternalHighlightLayerOrActive(layerName?: string): HighlightLayer;
    /**
     * Gets the graphics layer associated with the named or active highlight layer
     * @DEPRECATED: Use getInternalHighlightLayerOrActive to get the infrastructure.HighlightLayer instance instead.
     */
    getHighlightLayerOrActive(layerName?: string): esri.layers.GraphicsLayer;
    /**
     * Returns the graphics currently in the active highlight layer.
     * @returns {esri.Graphic[]} active layer highlighted graphics.
     */
    activeHighlightLayerGraphics(): esri.Graphic[];
    /**
     * Returns the graphics currently in the default highlight layer.
     * @returns {esri.Graphic[]} default layer highlighted graphics.
     */
    defaultHighlightLayerGraphics(): esri.Graphic[];
    private _highlightFeaturesImpl(features, highlightLayerName?, focusedHighlight?);
    /**
     * Draws the graphic to the specified esri.layer.GraphicsLayer.
     * @param The graphic to be drawn
     * @param The specified graphic layer
     */
    private _highlightGraphic(graphic, highlightLayer, highlightFocused?, gcxFeature?);
    /**
     * Removes only the focused state, leaving a highlight behind if it is highlighted as well.
     * If you pass in a layer it only looks on that layer. If you don't it looks on all of them.
     */
    private _clearFeatureFocus(graphic, highlightLayer);
    /**
     * Removes all graphics and stored data associated with a highlight
     * If you pass in a layer it only looks on that layer. If you don't it looks on all of them.
     */
    private _clearFeatureHighlight(graphic, highlightLayer?);
    /**
     * Create a 'managedGraphic' to represent the highlight, or return an existing item. Will return null if the graphic has geometry which exceeds the maximum configured highlightable vertices.
     */
    private _getOrCreateMangedGraphic(graphic, highlightLayer, gcxFeature?);
    /**
     * Keeps track of a pairing of original graphic + cloned graphic for a particular layer.
     */
    private _trackGraphic(originalGraphic, outerBorderGraphic, innerBorderGraphic, highlightLayer, originalSymbol, originalLayerId?, gcxFeature?);
    /**
     * Bump all focus graphics to the top.
     */
    private _moveFocusGraphicsToTop();
    /**
     * Add a pushpin to this highlight if it passes certain tests
     * Must be a point, or out of scale range to get a pushpin.
     * @param managedGraphic
     * @param highlightLayer
     * @param gcxFeature
     */
    private _addPushpinIfNeeded(managedGraphic, highlightLayer, gcxFeature?);
    /**
     * Converts an esri.Color object to ARGB hex format
     * @param color
     */
    private _toARGBHex(color);
    /**
     * Given a graphic, return the highlight id to use. This is based on the graphic geometry.
     * @param graphic
     */
    private _getHighlightId(graphic);
    /**
     * Returns a positive integer hash (as a string) for a given geometry
     * @param geom
     */
    private _getGeometryHash(geom);
    /**
     * Given a highlight id, check to see if we have cached the geometry to use to highlight it, and return it if found
     * @param highlightId
     */
    private _getCachedGeometry(highlightId);
    /**
     * This function is intended to cache only generalized geometries since the generalization algorithm may be expensive for geometries with a large number of vertices.
     * In IE11 for instance, geometries with 50,000 vertices take about 700ms to get generalized.
     */
    private _cacheGeometry(highlightId, geom);
    private _clearGeometryCache();
    private _setHighlightId(graphic, id);
    /**
     * Sometimes when editing, features with *slightly* different geometries from the original get sent.
     * This updates the highlightId to reflect the new geometry.
     */
    private _refreshHighlightId(graphic, originalId?);
    /** @private  Returns the esri.layers.GraphicsLayer that is currently set as the active highlight layer. */
    private _activeHighlightLayer();
    /** Determines whether to use the Ramer-Douglas-Peucker generalization routine for the provided graphic */
    private _shouldGeneralizeGeometry(geom);
    private _getOrCreateHighlightGeometry(geom, highlightId?);
    private _geometryExceedsMaxVertices(geom);
    /**
     * Returns the managed graphic object, given a graphic and the highlight layer it appears on
     */
    private _retrieveManagedGraphic(graphic, layer);
    /**
     * Get all the unique graphics layer ids contained within the highlight layers collection
     */
    private _getUniqueHighlightGraphicsLayerIds();
    /**
     * Export saved project state
     */
    exportState(): Promise<HighlightManagerState>;
    /**
     * Restore state from a saved project
     * @param state
     */
    applyState(state: HighlightManagerState): Promise<void>;
}

}
declare module "geocortex/infrastructure/HtmlUtils" {
/**
 * Polls until a certain criteria is met, or a timeout occurs.
 * @param callback The function used to check if a condition is met.
 * @param interval The fequency with which to poll in milliseconds.
 * @param timeout The total amount of time that will be waited before timing out, in milliseconds.
 */
export function pollUntil(callback: () => boolean, interval?: number, timeout?: number): Promise<{}>;

}
declare module "geocortex/infrastructure/KmlFeature" {
import { Feature, FeatureOptions } from "geocortex/infrastructure/Feature";
/** A special property added to an esri feature to indicate that it came from a KML service. */
export const isKmlProperty = "__isKml";
/**
 * A {@link Feature} belonging to a KML service.
 */
export class KmlFeature extends Feature {
    constructor(options?: FeatureOptions);
}

}
declare module "geocortex/infrastructure/LayerIntegrationUtils" {
import { FeatureLayerService } from "geocortex/essentials/FeatureLayerService";
import { Layer } from "geocortex/essentials/Layer";
import { KmlService } from "geocortex/essentials/KmlService";
import { Layer as WebMapLayer } from "geocortex/infrastructure/webMap/Layer";
/**
 * Queries the provided map service URL, and returns an array of feature service URLs that were found.
 * @param url Map service URL to interrogate for feature services.
 * @returns The promise of an array of feature service URLs.
 */
export function discoverFeatureServices(url: string): Promise<string[]>;
/**
 * Build and initialize a populated Geocortex feature layer map service based on the provided feature service URL.
 * The returned feature layer service will come with a service layer and a single Geocortex layer.
 * @param url The URL to the feature service endpoint.
 * @returns The promise of a Geocortex feature layer map service.
 */
export function buildFeatureLayerService(serviceUrl: string): Promise<FeatureLayerService>;
/**
 * Build and initialize a KML map service based on the provided KML service URL.
 * @param serviceUrl The URL to the esri KML service layer.
 * @param serviceDefinition A map service definition object containing the properties for the new map service (optional).
 * @returns The promise of a Geocortex KmlService.
 */
export function buildKmlService(serviceUrl: string, serviceDefinition?: any): Promise<KmlService>;
/**
 * Create a local map service from a serialized feature layer (JSON data called a 'Feature Collection').
 * @param featureCollection An esri `FeatureCollection`, which is a serialized representation of a feature layer.
 * @param serviceDefinition A map service definition object containing the properties for the new map service (optional).
 * @returns A Promise of a local feature layer service that exists in a disconnected state (does not have a valid URL).
 */
export function buildLocalFeatureLayerService(featureCollectionObject: WebMapLayer, serviceDefinition?: any): Promise<LocalFeatureLayerService>;
/**
 * Specialized esri feature layer that exists in a disconnected state (no URL).
 */
export class LocalFeatureLayer extends esri.layers.FeatureLayer {
    /**
     * Create a LocalFeatureLayer from a feature layer that is serialized as a FeatureCollection.
     * @param options: `LocalFeatureLayerConstructorOptions`.
     */
    constructor(featureCollectionObject: WebMapLayer);
    /**
     * Special query handling for local feature layers, overriding `queryFeatures` of the Esri API.
     * The Esri API allows only simple extent-based queries to be performed clientside. For more complex queries (involving polygons, for example), the Esri API will query the server.
     * Local feature layers, which exist in a disconnected state (no URL), have no associated server endpoint available to query.
     * In order to perform queries with complex geometry on local feature layers, this method performs the query with a simplified version of the geometry (an extent) which yields false positives, which we then manually filter out by using the Esri geometry engine.
     */
    queryFeatures(originalQuery: esri.tasks.Query, callback?: Function, errback?: Function): any;
}
/**
 * Specialized Geocortex feature layer map service that exists in a disconnected state (no URL).
 */
export class LocalFeatureLayerService extends FeatureLayerService {
}
/**
 * Specialized Geocortex layer that exists in a disconnected state (no URL).
 */
export class LocalLayer extends Layer {
}

}
declare module "geocortex/infrastructure/MapUtils" {
import { Site } from "geocortex/essentials/Site";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
/**
 * Scales the ESRI map's extent by the given factor
 * @param map The ESRI map
 * @param factor The factor by which the map's extent need to be scaled
 * @param zoomFromExtent Value of initial extent of the map
 * @return Value of the new scaled extent
 */
export function stepZoom(map: esri.Map, factor: number, zoomFromExtent: esri.geometry.Extent): esri.geometry.Extent;
/**
 * Safely scales the ESRI map's extent by the given factor with the given priority and name
 * @param map The Essentials map
 * @param factor The factor by which the map's extent need to be scaled
 * @param zoomFromExtent Value of initial extent of the map
 * @param startupPriority The priority of this extent change if called while the map is still loading
 * @param generalPriority The priority of this extent change if called after the map has loaded
 * @return Value of the new scaled extent
 */
export function stepZoomWithPriority(site: Site, factor: number, zoomFromExtent: esri.geometry.Extent, startupPriority?: number): esri.geometry.Extent;
/**
 * Gets the current extent of the given geometry
 * @param geometry The ESRI geometry whose extent is to be returned
 * @return Extent of the given geometry
 */
export function getExtent(geometry: esri.geometry.Geometry): esri.geometry.Extent;
/**
 * Pans to the given geometry after apply a projection if required.
 * @param app The application which contains the map to pan
 * @param geometry The ESRI geometry which the map should be panned to
 * @param startupPriority The priority of this extent change if called while the map is still loading
 * @param generalPriority The priority of this extent change if called after the map has loaded
 */
export function panToPointWithPriority(app: ViewerApplication, geometry: esri.geometry.Geometry, startupPriority: number, showMap: boolean): void;
/**
 * Zooms to the given extent after applying a projection if required.
 * @param app The application which contains the map
 * @param extent The ESRI extent which the map should zoom to
 * @param showMap A boolean indicating if the map should be shown before performing the extent change
 */
export function zoomToExtent(app: ViewerApplication, extent: esri.geometry.Extent, showMap: boolean): void;
/**
 * Zooms to the given extent with the specified priority after applying a projection if required.
 * @param app The application which contains the map to pan
 * @param extent The ESRI extent which the map should zoom to
 * @param startupPriority The priority of this extent change if called while the map is still loading
 */
export function zoomToExtentWithPriority(app: ViewerApplication, extent: esri.geometry.Extent, startupPriority: number, showMap: boolean): void;
/**
 * This function will only be effective when the map has a tiled base map layer. In such cases, simply determining the scale at which a
 * layer is visible may not be sufficient as this scale may fall between two LOD scale ranges. In such cases, esri will choose the LOD with the nearest scale
 * to zoom to - but the layer may NOT be visible at that scale. This function fetches the scale of the nearest LOD (either less than or more than the specified scale)
 * at which the layer will be visible.
 * @param mode An enum which can be either "lessThan" or "greaterThan"
 * @param scale The target scale
*  @return The nearest LOD with scale less than or more than (depending on mode) the target scale OR the input scale if a tiled base map is not added to the map
*/
export function getClosestScale(map: esri.Map, mode: ScaleChangeMode, scale: number): number;
export enum ScaleChangeMode {
    LessThan = 0,
    GreaterThan = 1,
}
export function cloneEsriFeature(feature: esri.Graphic): esri.Graphic;
export function esriFeatureAttributesEqual(attributes1: any, attributes2: any, fieldsToIgnore?: string[]): boolean;
export function esriFeaturesEqual(graphic1: esri.Graphic, graphic2: esri.Graphic): boolean;
export function esriGeometriesEqual(g1: esri.geometry.Geometry, g2: esri.geometry.Geometry): boolean;
export function compareTypeSR(g1: esri.geometry.Geometry, g2: esri.geometry.Geometry): boolean;
export function esriPointsEqual(thisGeom: esri.geometry.Point, oGeom: esri.geometry.Point): boolean;
export function esriMultipointsEqual(thisGeom: esri.geometry.Multipoint, oGeom: esri.geometry.Multipoint): boolean;
export function esriPolylinesEqual(thisGeom: esri.geometry.Polyline, oGeom: esri.geometry.Polyline): boolean;
export function esriPolygonsEqual(thisGeom: esri.geometry.Polygon, oGeom: esri.geometry.Polygon): boolean;
export function esriExtentsEqual(thisGeom: esri.geometry.Extent, oGeom: esri.geometry.Extent): boolean;
/**
 * Finds a feature on a given layer using structural comparison.
 * @param feature The esri.Graphic to find.
 * @param layer The feature layer to search.
 */
export function findFeatureInLayer(feature: esri.Graphic, layer: esri.layers.FeatureLayer): esri.Graphic;
/**
 * Finds a feature on the map. This method is crucial for dealing with OnDemand layers, as feature instances
 * obtained from OnDemand layers became detached from the map and we often need to re-attach to the "fresh"
 * instance of a feature.
 * @param feature The esri.Graphic to find.
 * @param site The Site, containing the map.
 * @param layerHint A layer possibly containing the feature, to search first.
 */
export function findFeatureInMap(feature: esri.Graphic, site: Site, layerHint?: esri.layers.FeatureLayer): esri.Graphic;
/**
 * Get an image URI for the thumbnail. Can be a hosted image or a data URI.
 * @param app The application which contains the map to create a thumbnail for.
 * @param extent The extent to create the thumbnail for. Defaults to the maps current extent.
 * @param width The width of the thumbnail.
 * @param height The height of the thumbnail.
 * @param dpi The DPI to use for the thumbnail resolution.
 * @return A promise of the thumbnail.
 */
export function getThumbnailUri(app: ViewerApplication, extent?: esri.geometry.Extent, width?: number, height?: number, dpi?: number): Promise<string>;

}
declare module "geocortex/infrastructure/MatrixUtils" {
export interface TransformationResult {
    geometry: esri.geometry.Geometry;
    transform: dojox.gfx.matrix.Matrix2D;
}
export class MatrixUtils {
    /**
     * Translates (moves) a given polygon or polyline by a specified offset.
     * @param geometry The Geometry to rotate.
     * @param dx The X offset.
     * @param dy The Y offset.
     */
    static translate(geometry: esri.geometry.Geometry, map: esri.Map, dx: number, dy: number): TransformationResult;
    /**
     * Rotates a given polygon or polyline by a specified angle.
     * @param geometry The Geometry to rotate.
     * @param degreesClockwise The angle to rotate the polygon in, specified in degrees, in a clockwise direction (as is standard for esri)
     * @param pivotMapPoint The "pivot" around which to rotate the polygon. Is not required to lie on or within the polygon.
     */
    static rotate(geometry: esri.geometry.Geometry, map: esri.Map, degreesClockwise: number, pivotMapPoint?: esri.geometry.Point): TransformationResult;
    /**
     * Scales (resizes) a given polygon or polyline by a specified scaling factor.
     * @param geometry The Geometry to rotate.
     * @param scaleX A scaling factor used for the x coordinate, or a uniform scaling factor used for the both coordinates.
     * @param scaleY (Optional) A scaling factor used for the y coordinate.
     */
    static scale(geometry: esri.geometry.Geometry, map: esri.Map, scaleX: number, scaleY?: number): TransformationResult;
    /**
     * Returns an approximation of the center point of the given geometry, as measured in Cartesian space.
     * @param geometry The geometry whose center needs to be returned
     */
    static getCentroid(geometry: esri.geometry.Geometry): esri.geometry.Point;
    private static _applyOffset(geometry, paths, dx, dy, map);
    private static _applyOffset(geometry, rings, dx, dy, map);
    private static _applyTransform(geometry, paths, transformation);
    private static _applyTransform(geometry, rings, transformation);
}

}
declare module "geocortex/infrastructure/NumberFormat" {
/**
 * Pre-defined format specifiers for use with formatNumber().
 */
export class NumberFormat {
    /**
     * A localized representation of a number with a decimal separator and group separators (e.g. "12,345.67", "-42" for en-US locale).
     */
    static NUMBER: string;
    /**
     * A localized representation of a number with a decimal separator (e.g. "12345.67", "-42" for en-US locale).
     */
    static FIXED_POINT: string;
    /**
     * A localized representation of a monetary amount in a specific currency (e.g. "$123.45" for USD, "£123.45" for GBP for en-US locale).
     */
    static CURRENCY: string;
    /**
     * Same as CURRENCY, except that negative values are displayed in parentheses instead of using a "-" sign.
     */
    static ACCOUNTING: string;
    /**
     * A localized representation of a percentage (e.g. 0.99 -> "99%" in the en-US locale).
     */
    static PERCENT: string;
    /**
     * An invariant representation of a number (e.g. "12345.67"). Guarantees that the number can be parsed back
     * into the same number, regardless of locale.
     */
    static ROUND_TRIP: string;
    /**
     * The default representation for number values (equivalent to FIXED_POINT).
     */
    static DEFAULT: string;
}
export function isNumeric(value: any): boolean;

}
declare module "geocortex/infrastructure/ObjectFilter" {
export module ObjectFilter {
    const FILTERED: {};
    /**
     * Filters an object graph according to the rules defined in a filter.
     * Returns an object graph with the same structure as the original, minus any properties that were removed
     *     by the filter. Note that prototype chains are NOT preserved by this method -- the result will be a
     *     simple instance of Object. Cycles and shared object references within the input object will be
     *     preserved in the output (presuming that they pass the filter).
     * @param object The object graph to filter.
     * @param filter A value that determines which properties of the original object are kept in the
     * result. A filter can take on one of the following values:
     *   1. A boolean value. If true, then the value will be retained, otherwise it will be discarded.
     *   2. An object. Each property defined on the filter is itself a filter that is applied to the equivalent
     * property on the original object. Any properties that are not defined in the filter are automatically
     * excluded from the original object.
     *   3. An instance of {@link validation.Validator}. The value will be checked against
     * the validator's `validate()` method, and will be kept only if the validation is successful.
     *   4. A callback function. The function will be invoked with the value, and the result will be used to
     * perform further filtering.
     *
     * For array properties, the filter value can be an object containing a single property named `item`. In
     * this case, the value of the filter's `item` property will be used to filter each item in the array, using
     * the same rules as above.
     * @param context Arbitrary data that will be passed to validators and callbacks within the filter.
     */
    function filter(object: Object, filter: any, context?: any): Promise<Object>;
}

}
declare module "geocortex/infrastructure/ObjectTraverser" {
export class ObjectTraverser {
    /**
     * Visits every node in a tree, using a depth first search, and calls a callback function for that node.
     */
    static visit(tree: any, callback: (value: any, context: {
        propertyName: any;
        parent: any;
    }) => boolean): void;
    private static visitImpl(tree, context, callback);
}

}
declare module "geocortex/infrastructure/PortalUtils" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { Identity } from "geocortex/essentials/Principal";
/**
 * Get a arcgis.com or Portal identity if it exists.
 * @param app The current application instance
 */
export function getPortalIdentity(app: ViewerApplication): Identity;
/**
 * Check if the authenticated user has access to Portal.
 * @param app The current application instance
 */
export function hasAccessToPortal(app: ViewerApplication): boolean;
/**
 * Check if the authenticated user has create content privilege in Portal.
 * @param app The current application instance
 */
export function hasCreateContentPrivilege(app: ViewerApplication): boolean;
/**
 * Check if the authenticated user has publishFeature privilege in Portal.
 * @param app The current application instance
 */
export function hasPublishFeaturePrivilege(app: ViewerApplication): boolean;
/**
 * Gets the Portal base URL.
 * @param app The current application instance
 */
export function getPortalBaseUrl(app: ViewerApplication): string;
/**
 * Gets the Portal My Content page URL.
 * @param app The current application instance
 */
export function getPortalMyContentUrl(app: ViewerApplication): string;
/**
 * Gets the Portal item page URL for the given item id.
 * @param itemId The item id
 * @param app The current application instance
 */
export function getPortalItemUrl(itemId: string, app: ViewerApplication): string;

}
declare module "geocortex/infrastructure/PresentableDelegateFactory" {
import { Field } from "geocortex/essentials/Field";
import { FieldInfo } from "geocortex/infrastructure/gis/FieldInfo";
import { Feature } from "geocortex/infrastructure/Feature";
export class PresentableDelegateFactory {
    static typeIdForLayerAndAttributes(layer: esri.layers.FeatureLayer, attributes: any): any;
    static typeFromLayerAndId(layer: esri.layers.FeatureLayer, id: any): esri.layers.FeatureType;
    static makeValueTruthy(value: any): any;
    static valuePresenterDelegate(field: string | Field | FieldInfo, feature: Feature): (value: any) => () => string;
}

}
declare module "geocortex/infrastructure/PromiseUtils" {
import { Thenable } from "geocortex/framework/Thenable";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
export module PromiseUtils {
    /**
     * Similar to Promise.all(), except that any rejected promises are skipped, rather than causing the entire
     * promise to be rejected. As a result, the returned array might contain less elements than the original.
     */
    function allSkipRejected<R>(values: Thenable<Thenable<R>[]>, logErrors?: boolean): Promise<R[]>;
    function allSkipRejected<R>(values: Thenable<R[]>, logErrors?: boolean): Promise<R[]>;
    function allSkipRejected<R>(values: Thenable<R>[], logErrors?: boolean): Promise<R[]>;
    function allSkipRejected<R>(values: R[], logErrors?: boolean): Promise<R[]>;
    /**
     * Similar to Promise.map(), except that any rejected promises are skipped, rather than causing the entire
     * promise to be rejected. As a result, the returned array might contain less elements than the original.
     */
    function mapSkipRejected<R, U>(values: Thenable<Thenable<R>[]>, mapper: (item: R, index: number, arrayLength: number) => Thenable<U>, option?: {
        concurrency: number;
    }, logErrors?: boolean): Promise<U[]>;
    function mapSkipRejected<R, U>(values: Thenable<Thenable<R>[]>, mapper: (item: R, index: number, arrayLength: number) => U, option?: {
        concurrency: number;
    }, logErrors?: boolean): Promise<U[]>;
    function mapSkipRejected<R, U>(values: Thenable<R[]>, mapper: (item: R, index: number, arrayLength: number) => Thenable<U>, option?: {
        concurrency: number;
    }, logErrors?: boolean): Promise<U[]>;
    function mapSkipRejected<R, U>(values: Thenable<R[]>, mapper: (item: R, index: number, arrayLength: number) => U, option?: {
        concurrency: number;
    }, logErrors?: boolean): Promise<U[]>;
    function mapSkipRejected<R, U>(values: Thenable<R>[], mapper: (item: R, index: number, arrayLength: number) => Thenable<U>, option?: {
        concurrency: number;
    }, logErrors?: boolean): Promise<U[]>;
    function mapSkipRejected<R, U>(values: Thenable<R>[], mapper: (item: R, index: number, arrayLength: number) => U, option?: {
        concurrency: number;
    }, logErrors?: boolean): Promise<U[]>;
    function mapSkipRejected<R, U>(values: R[], mapper: (item: R, index: number, arrayLength: number) => Thenable<U>, option?: {
        concurrency: number;
    }, logErrors?: boolean): Promise<U[]>;
    function mapSkipRejected<R, U>(values: R[], mapper: (item: R, index: number, arrayLength: number) => U, option?: {
        concurrency: number;
    }, logErrors?: boolean): Promise<U[]>;
    /**
     * Similar to Promise.props(), except that any rejected promises are skipped, rather than causing the entire
     * promise to be rejected. As a result, the returned object might contain less properties than the original.
     */
    function propsSkipRejected(object: Thenable<Object>): Promise<Object>;
    function propsSkipRejected(object: Object): Promise<Object>;
    /**
     * Logs a warning if the given promise is rejected.
     * @param promise The promise that might be rejected.
     * @param app The application
     * @param warning The warning text to log. May contain a "{0}" placeholder that will be substituted with the actual error.
     */
    function warnOnReject<T>(promise: Thenable<T>, app: ViewerApplication, warning: string): Promise<T>;
}

}
declare module "geocortex/infrastructure/Reporting" {
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
import { FeatureSet } from "geocortex/infrastructure/FeatureSet";
import { Feature } from "geocortex/infrastructure/Feature";
/**
 * Returns an array of all Features within a given Reportable input (group of features).
 */
export function getAllFeaturesFromReportable(reportable: FeatureSetCollection | FeatureSet | Feature | Feature[]): Feature[];

}
declare module "geocortex/infrastructure/ReverseGeocoder" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { GeocodingEndpoint } from "geocortex/essentials/GeocodingEndpoint";
export interface ReverseGeocodeFunction {
    (location: esri.geometry.Point): Promise<ReverseGeocodeResult>;
}
export interface ReverseGeocodeResult {
    address: string;
    location: esri.geometry.Point;
}
export class ReverseGeocoder {
    private app;
    private geocoder;
    private geocoderToken;
    private geocoderUrl;
    private _agsGeocoder;
    private _bingMapsKey;
    private _bingMapsCulture;
    private SEARCH_RADIUS;
    private AGS_ADDRESS_FIELD;
    private BING_REQUEST_TEMPLATE;
    constructor(app: ViewerApplication, geocoderConfig: GeocodingEndpoint);
    /**
     * Given a point, executes a reverse geocode operation and returns the result in a promise
     */
    reverseGeocode(location: esri.geometry.Point): Promise<ReverseGeocodeResult>;
    /**
     * Initializes the appropriate geocoder given the endpoint type, and sets the geocoding function to use
     */
    private _initializeGeocoder(geocoderConfig);
    private _updateUrl(newToken);
    /**
     * Traverses address object, composes array of values, and returns comma-separated field values
     */
    private _parseAddressObject(inputObject);
    /**
     *  Executes a reverse geocode operation on an ArcGIS Server or Online geocode endpoint
     */
    private _executeAgsReverseGeocode(location);
    /**
     * Executes a reverse geocode operation on a Bing geocode endpoint
     */
    private _executeBingReverseGeocode(location);
    private _noGeocoderConfigured(location);
}

}
declare module "geocortex/infrastructure/SecurityUtils" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { Identity, Claim } from "geocortex/essentials/Principal";
/**
 * Get an identity based on the authentication type.
 * @param authenticationType The authentication type of the identity to find
 * @param app The current application instance
 */
export function getIdentity(authenticationType: string, app: ViewerApplication): Identity;
/**
 * Get a claim based on the claim type.
 * @param identity The identity in which to search for claims
 * @param type The claim type to find
 */
export function getClaimsByType(identity: Identity, type: string): Claim[];
/**
 * Get a claim based on the claim value.
 * @param identity The identity in which to search for claims
 * @param value The claim value to find
 */
export function getClaimsByValue(identity: Identity, value: string): Claim[];
/**
 * Get a claim based on the claim type and value.
 * @param identity The identity in which to search for claims
 * @param type The claim type to find
 * @param value The claim value to find
 */
export function getClaimByTypeAndValue(identity: Identity, type: string, value: string): Claim;
/**
 * Check if the identity has a given privilege.
 * @param identity The identity in which to search the claims for a specific privilege
 * @param value The privilege value to find
 */
export function hasPrivilegeClaim(identity: Identity, value: string): boolean;

}
declare module "geocortex/infrastructure/ShellUtils" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
/**
 * Viewer Shell (Desktop, Tablet, Handheld) Utilities.
 */
/**
 * Debounces a given function and runs it once all view related events have settled for a specified timeout (defaults to 400ms). This function cannot guarantee deterministic results and we don't recommend
 * you use it unless absolutely necessary. There may be points of failure introduced if, for instance, a large number of modules use it and activate views of their own. This may lead to unintended
 * behavior.
 * @param app The {@link ViewerApplication} invoking this function.
 * @param delegate The function to execute after debouncing.
 * @param settleThreshold Optional parameter that can be used to set the settle threshold. Defaults to 400ms.
 */
export function debounceViewEvents(app: ViewerApplication, delegate: Function, settleThresholdMs?: number): void;
/**
 * Debounces a given function and runs it once all target events have settled for a specified timeout (defaults to 200ms). This function cannot guarantee deterministic results and we don't recommend
 * you use it unless absolutely necessary.
 * @param app The {@link ViewerApplication} invoking this function.
 * @param delegate The function to execute after debouncing.
 * @param targetEvents The list of events that will cause the given delegate to get debounced.
 * @param settleThreshold Optional parameter that can be used to set the settle threshold. Defaults to 400ms.
 */
export function debounceEvents(app: ViewerApplication, delegate: Function, targetEvents: string[], settleThresholdMs?: number): void;
/**
 * A reliable way to test an element for a class that works in IE9
 */
export function hasClass(target: any, className: string): boolean;
/**
 * Returns a function, that, when invoked, will only be triggered at most once
 * during a given window of time. Normally, the throttled function will run
 * as much as it can, without ever going more than once per `wait` duration
 * @param func Function to call
 * @param wait Time to throttle
 * @param options If you'd like to disable the execution on the leading edge, pass
 `{leading: false}`. To disable execution on the trailing edge, ditto.
*/
export function throttle(func: Function, wait: number, options?: {
    leading?: boolean;
    trailing?: boolean;
}): Function;

}
declare module "geocortex/infrastructure/SimpleRenderer" {
/**
 * Presents a similar interface to {@link esri.renderer.Renderer} as a graphic can be supplied to getSymbol()
 * and a symbol recieved in return. Despite the name, this is used exclusively for highlight graphics in GVH,
 * and as such, the getSymbol method has been modified to produce these.
 * @private
 */
export class SimpleRenderer {
    /**
     * The color scheme to fill the graphics.
     */
    fillColor: esri.Color;
    /**
     * The color scheme to draw the border of the graphics.
     */
    borderColor: esri.Color;
    /**
    * The width to draw the border of the graphics.
    */
    borderWidth: number;
    /**
     * Special opacity setting for polylines, but not marker or polygon outlines
     */
    polylineOpacity: number;
    /**
     * Matches a member in {@link esri.renderer.Renderer}.
     */
    defaultSymbol: esri.symbol.Symbol;
    private _pictureMarkerSymbolCache;
    /**
     * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.SimpleRenderer} class.
     * @constructs
     * @memberOf geocortex.essentialsHtmlViewer.mapping.infrastructure.SimpleRenderer
     */
    constructor();
    /**
     * Returns the clone of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.SimpleRenderer} object
     * @return {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.SimpleRenderer}
     */
    clone(): SimpleRenderer;
    /**
     * Returns the highlight or emphasis symbols corresponding to the geometry of given graphic.
     * 'highlight' being the thicker border on the bottom, and 'emphasis' being the thinner line on top.
     * @param graphic The ESRI graphic
     * @param symbol Original symbol which can be used to influence the produced symbol.
     * @param isEmphasis Flag to apply special rules for drawing the emphasis line
     * @return The ESRI symbol
     */
    getSymbol(graphic: esri.Graphic, symbol?: esri.symbol.Symbol, isEmphasis?: boolean): esri.symbol.Symbol;
    toJson(): any;
}

}
declare module "geocortex/infrastructure/SymbolUtils" {
import { SimpleMarkerSymbol, SimpleLineSymbol, SimpleFillSymbol } from "geocortex/infrastructure/webMap/Symbol";
import { LazyObservable } from "geocortex/framework-ui/LazyObservable";
/**
 * Default markup symbols. These are observables so they can be imported and assigned by the MarkupModule.
 */
export let defaultPointMarkup: LazyObservable<esri.symbol.SimpleMarkerSymbol>;
export let defaultPolylineMarkup: LazyObservable<esri.symbol.SimpleLineSymbol>;
export let defaultPolygonMarkup: LazyObservable<esri.symbol.SimpleFillSymbol>;
export let defaultTextMarkup: LazyObservable<esri.symbol.TextSymbol>;
/**
 * The size values in a renderer JSON object need to be converted from points to pixels in order
 * to be able to recreate the same renderer using the JSAPI. 96dpi is assumed and there are 72 points in an inch.
 */
export const POINTS_TO_PIXELS: number;
/**
 * Returns default color. If any modifications are provided, we will return a color with those modifications made
 * @param {Object} [options] modifications to make to the default color
 * @return {dojo.Color}
 */
export function defaultSymbolColor(options?: {
    r?: number;
    g?: number;
    b?: number;
    a?: number;
}): dojo.Color;
/**
 * Returns the ESRI default marker symbol
 */
export function defaultMarkerSymbol(): esri.symbol.SimpleMarkerSymbol;
/**
 * Returns the ESRI default line symbol
 */
export function defaultLineSymbol(): esri.symbol.SimpleLineSymbol;
/**
 * Returns the ESRI default fill symbol
 */
export function defaultFillSymbol(): esri.symbol.SimpleFillSymbol;
/**
 * Returns the ESRI default text symbol
 */
export function defaultTextSymbol(disableHalo?: boolean): esri.symbol.TextSymbol;
/**
 * Returns a default symbol
 * @param markupType The type of symbol to return.
 */
export function defaultSymbol(symbolType: string): esri.symbol.Symbol;
/**
 * Returns the default markup symbol
 * These may be changed by the configuration of the MarkupModule, though they do not depend on it.
 * @param symbolType
 */
export function defaultMarkupSymbol(symbolType: string): esri.symbol.Symbol;
/**
 * Fast javascript hashing from https://github.com/darkskyapp/string-hash
 * @param input A string to create an unsigned integer hash for
 */
export function stringToHash(input: string): number;
/**
 * Convert from the 'featureType' string stored in the layer object to a SymbolType
 * @param type A layer.featureType string
 */
export function layerFeatureTypeToSymbolType(type: string): string;
/**
 * Convert from the 'type' propety of an esri.symbol.Symbol to the SymbolType string values
 */
export function fromEsriSymbolType(type: string): string;
/**
 * Angles are stored differently in ESRI's webMap or REST API symbol representation
 * This converts from the webMap variant to JSAPI
 * @param angle
 */
export function webMapAngleToJSAPIAngle(angle: number): number;
/**
 * Rotate a point around an origin
 * @param cx origin x
 * @param cy origin y
 * @param x point x
 * @param y point y
 * @param angle rotation angle
 */
export function rotate(cx: number, cy: number, x: number, y: number, angle: number): {
    x: number;
    y: number;
};
/**
 * Create an SVG swatch that displays a preview of the given symbol
 * @param div The div to attach the swatch to
 * @param size The size of the swatch
 * @param symbol The esri.symbol.Symbol to create a swatch for
 */
export function createSymbolSwatch(div: HTMLElement, size: number, symbol: esri.symbol.Symbol): void;
/**
 * Create an SVG swatch that displays a preview of the given symbol
 * @param div The div to attach the swatch to
 * @param size The size of the swatch
 * @param symbol The esri.symbol.TextSymbol to create a swatch for
 * @param graphicsLayer The graphicsLayer used to draw the halo. Not altered in any way.
 */
export function createTextSymbolSwatch(div: HTMLElement, size: number, symbol: esri.symbol.TextSymbol, graphicsLayer: esri.layers.GraphicsLayer): void;
export function esriSymbolsEqual(a: esri.symbol.Symbol, b: esri.symbol.Symbol): boolean;
/**
 * Gets the symbol libraries from the essentials symbol endpoint. Caches responses so we request a particular library only once.
 * @param symbolLibraryUrl The url for the essentials symbol library.
 * @return The library object from Essentials.
 */
export function getEssentialsSymbolLibrary(symbolLibraryUrl: string): Promise<Object>;
/**
 * Common attributes for SimpleMarker, SimpleLine and SimpleFill symbols
 */
export type SimpleSymbol = SimpleMarkerSymbol | SimpleLineSymbol | SimpleFillSymbol;
/**
 * Common attributes for SimpleMarker and SimpleFill symbols
 */
export type SimpleOutlinedSymbol = SimpleMarkerSymbol | SimpleFillSymbol;

}
declare module "geocortex/infrastructure/TaskUtils" {
import { Layer } from "geocortex/essentials/Layer";
import { MapService } from "geocortex/essentials/MapService";
import { FieldInfo } from "geocortex/infrastructure/gis/FieldInfo";
import { Trace } from "geocortex/framework/utils/Trace";
/**
* Gets the url that an esri.tasks.QueryTask can be run against for this layer. Suggested to use `getQueryTask` instead.
* @param layer The Geocortex/Esri Layer that is to be queried.
* @param mapService Required when passing an Esri Layer.
* @returns The url for the query endpoint.
* @deprecated 2.6 Use `getQueryTask` or `getIntersectTask` instead.
*/
export function getQueryTaskUrl(layer: Layer | esri.layers.Layer, mapService?: MapService): string;
/**
* Gets an esri.tasks.QueryTask that can be run against for this layer.
* @param layer The Geocortex/Esri Layer that is to be queried.
* @param mapService Required if using an esri.layers.Layer as the layer parameter.
* @returns The constructed esri.tasks.QueryTask for the resource.
*/
export function getQueryTask(layer: Layer | esri.layers.Layer, mapService?: MapService): esri.tasks.QueryTask;
/**
 * Get the service URL, or return null if we don't support identify operations for that service.
 */
export function getIdentifyTaskUrl(mapService: MapService): string;
/**
 * Gets an esri.tasks.IdentifyTask for a {@link geocortex.essentials.MapService}.
 * @param mapService The {@link geocortex.essentials.MapService}.
 * @returns The constructed esri.tasks.IdentifyTask for the resource.
 */
export function getIdentifyTask(mapService: MapService): esri.tasks.IdentifyTask;
/**
 * Takes a (presumably properly formatted) url string and associated MapService returns with an added token if needed.
 * @param url String for the URL that is going to be used in the Task.
 * @param mapService The MapService associated with the passed URL.
 */
export function getTokenizedUrl(url: string, mapService: MapService): string;
/**
 * Evaluates whether a provided Layer can be identified.
 * @param layer A Layer that is to be tested for its ability to be identified.
 */
export function canIdentifyLayer(layer: Layer): boolean;
/**
 * Evaluates whether a provided Layer can be queried.
 * @param layer A Layer that is to be tested for its ability to be queried.
 */
export function canQueryLayer(layer: Layer): boolean;
/**
 * Evaluates whether a provided MapService can be queried.
 * @param service A MapService that is to be tested for its ability to be queried.
 */
export function canQueryMapService(mapService: MapService): boolean;
/**
 * Creates a where clause that will search every provided fields with the search text provided.
 * @param layer The layer to create the where clause for
 * @param fields The fields that will be part of the where clause
 * @param searchText The search text to use in those fields
 * @param trace The trace object for logging purposes (optional)
 */
export function getSearchTextWhereClause(layer: Layer, fields: FieldInfo[], searchText: string, trace?: Trace): string;

}
declare module "geocortex/infrastructure/TimeSliderUtils" {
import { TimeUnits } from "geocortex/essentials/TimeUnits";
/**
* Utility method to convert the given time units to milliseconds.
* @param timeUnit The time unit to convert to milliseconds.
* @return The number of milliseconds. NaN if an unknown time unit is specified.
*/
export function convertTimeUnitToMilliseconds(timeUnit: TimeUnits): number;
/**
* Computes the slider time interval in milliseconds. Returns NaN if invalid.
* @param timeInterval The configured time interval.
* @param timeIntervalUnit The time interval units.
*/
export function computeTimeIntervalInMs(timeInterval: number, timeIntervalUnit: TimeUnits): number;

}
declare module "geocortex/infrastructure/TimeZoneUtils" {
import { Layer } from "geocortex/essentials/Layer";
import { MapService } from "geocortex/essentials/MapService";
/**
 * Time is a tricky business, made more tricky by local implementation of time zones. The two major concepts when dealing with time are that of an
 * "instant" and that of a "clock"; in general, an "instant" is the moment in the history of the Universe when an event precisely occurs (setting aside
 * concerns of relativity and the impossibility of simultinaety), and clocks around the world will say different things to describe this instant. By
 * convention, the "standard" clock is one which is set in Universal Coordinated Time (UTC). All local times (i.e., all other clock times) are offset by
 * some number of minutes from UTC, generally (though not always) in hour or half-hour increments. A "time zone", by definition, is an area of the world
 * in which all clocks agree with one another. Thus the same instant will have the same "clock time" inside a given time zone, but the "clock time" for
 * that same instant will generally differ across different time zones.
 *
 * Computers have tried to make this process as seamless as possible by communicating time via UTC timestamps, and then converting those timestamps to
 * the clock time of their local time zone. So in the viewer, when a user sees a date, that date has been consumed by JavaScript as a timestamp in UTC, and the
 * Date object converts itself to the system time of the client machine when it is presented to the user.
 *
 * TimeZoneUtils solves two problems associated with this behaviour. The first is ArcGIS Server generally communicates dates as UTC timestamps, while
 * administrators do not always store their times in UTC. This can lead to the wrong time showing up when JavaScript automatically converts the timestamp
 * from UTC time to local time, since the timestamp might not actually describe an instant in UTC time. The second problem is that administrators may
 * wish their dates to look the same for all of their users, regardless of the users' time zones; that is, they do not want the dates converted to the
 * users' clock times, but instead to the clock time of a preselected time zone, and they want this time to look the same no matter where the user is
 * located in the world. The various constants and methods in this module are designed with these problems in mind.
 */
export const UTC_ZONE_ID: string;
/**
 * Retrieves the time zone from a layer (or the layer's map service, or the site).
 * @param holder The layer whose time zone we are interrogating.
 */
export function getTimeZoneFromLayer(holder: Layer): string;
/**
 * Retrieves the time zone from a map service (or the site).
 * @param holder The map service whose time zone we are interrogating.
 */
export function getTimeZoneFromMapService(holder: MapService): string;
/**
 * Retrieves the display time zone from a map service's site.
 * @param holder The map service whose display time zone we are interrogating.
 */
export function getDisplayTimeZoneFromMapService(holder: MapService): string;
/**
 * This method offsets displayed dates to display to the user in a time zone defined by an administrator. JavaScript's native
 * Date objects automatically display themselves in the local time of the client machine. For example, if a date reads 3PM in
 * New York, in general that same date will read 12PM in Los Angeles. This is not appropriate for all applications; sometimes
 * we would like to make sure a date has the same display value to any user in any location. The current method accomplishes that.
 * @param date The date to modify for display.
 * @param databaseTimeZoneId The time zone of the date as stored in the database.
 * @param displayTimeZoneId The time zone in which the date should be displayed.
 */
export function correctDatesForDisplayInDisplayTimeZone(date: Date, databaseTimeZoneId: string, displayTimeZoneId: string): Date;
/**
 * Many users store dates in their local time zones, and they may not advertise this fact to ArcGIS Server.
 * This may cause a mismatch when ArcGIS Server serializes the date field as a UNIX timestamp,
 * whose time zone is always UTC (also known as GMT). Thus the browser will offset the dates it displays in local time, assuming
 * that its Date objects are generated from UNIX timestamps; in this function, dates' presentable values are offset to their true
 * UTC values, depending on the time zone ID for the layer (or map service, or site) containing this date. If there is no time
 * zone ID, this function should not be called; if the time zone ID is a UTC equivalent (e.g., Etc/GMT, Etc/UCT, Etc/UCT), then
 * no offset should be applied.
 * @param date The date to potentially offset.
 * @param timeZoneId The IANA ID of the time zone in which the data are recorded in the database
 */
export function correctDatesForDisplayInLocalTime(date: Date, timeZoneId: string): Date;
/**
 * Many users store dates in their local time zones, and they may not advertise this fact to ArcGIS Server.
 * This may cause a mismatch when ArcGIS Server serializes the date field as a UNIX timestamp,
 * whose time zone is always UTC (also known as GMT). Thus the browser will submit dates to the server in UTC, regardless of
 * which time zone the data are stored in; in this function, dates' submitted values are offset to their true
 * UTC values, depending on the time zone ID for the layer (or map service, or site) containing this date. If there is no time
 * zone ID, this function should not be called; if the time zone ID is a UTC equivalent (e.g., Etc/GMT, Etc/UCT, Etc/UCT), then
 * no offset should be applied.
 * @param date The date to offset
 * @param databaseTimeZoneId The IANA ID of the time zone in which the data are recorded in the database
 * @param displayTimeZoneId The IANA ID of the time zone in which the data are displayed to the user.
 */
export function correctDatesToSubmitInDatabaseTime(date: Date, databaseTimeZoneId: string, displayTimeZoneId?: string): Date;
/**
 * The QueryBuilder takes date objects implicitly in local time (with respect to the browser) and parses them as strings, which
 * we then submit as a query. This is not always appropriate if, for example, the database is properly-configured in UTC, or if
 * it happens to be in another time zone. Hence this method corrects a date from the browser's time to the zone corresponding to
 * the given database and display time zone IDs.
 * @param date The date to offset
 * @param databaseTimeZoneId The IANA ID of the time zone in which the data are recorded in the database
 * @param displayTimeZoneId The IANA ID of the time zone in which the data are displayed.
 */
export function correctDatesToQueryInDatabaseTime(date: Date, databaseTimeZoneId: string, displayTimeZoneId?: string): Date;

}
declare module "geocortex/infrastructure/UrlUtilities" {
import { Dictionary } from "geocortex/infrastructure/Dictionary";
/**
 * Convert a dictionary of query parameters into a string.
 * @param queryStrings The query string dictionary
 * @return The string of all the query parameters
 */
export function queryStringDictionaryToString(queryStrings: Dictionary<string>): string;
/**
 * Parses a URL query string into a dictionary of key/value pairs.
 */
export function queryStringToDictionary(queryString: string): Dictionary<string>;
/**
 * Parses a URL into its component parts.
 * Note that the object returned from this method will suffer from quirks of IE. It's pathname will not have a leading '/',
 * Unless we add it to a document. See https://connect.microsoft.com/IE/Feedback/Details/1002846
 * @param url The URL to parse.
 */
export function parseUrl(url: string): Location;
/**
 * Adds (or updates) a query parameter in a URL.
 * @param url The URL to add a parameter to.
 * @param parameter The name of the query parameter to add. If it already exists, the value will be updated.
 * @param value The value for the query parameter.
 */
export function addQueryParameter(url: string, parameter: string, value: string): string;
/**
 * Removes a query parameter from a URL, if it exists.
 * @param url The URL to add a parameter to.
 * @param parameter The name of the query parameter to remove.
 */
export function removeQueryParameter(url: string, parameter: string): string;
/**
 * Gets the URL to the containing "folder" for the given URL. For exmple:
 * getFolder("http://server.com/foo/bar/img.jpeg") -> "http://server.com/foo/bar/"
 * getFolder("http://server.com/foo/bar") -> "http://server.com/foo/bar/"
 * Note that the query string and fragment are discarded in the result.
 * Note that the object returned from this method will suffer from quirks of IE. It's pathname will not have a leading '/',
 * Unless we add it to a document. See https://connect.microsoft.com/IE/Feedback/Details/1002846
 * @param url The URL to extract the folder from.
 */
export function getFolder(url: string | Location): Location;
/**
 * Removes all query parameters from the url.
 * Note that the query string and fragment are discarded in the result.
 * Note that the object returned from this method will suffer from quirks of IE. It's pathname will not have a leading '/',
 * Unless we add it to a document. See https://connect.microsoft.com/IE/Feedback/Details/1002846
 * @param url The URL to extract the new url from which does not contain query parameters.
 */
export function removeParameters(url: string | Location): Location;

}
declare module "geocortex/infrastructure/Viewer" {
import { Application } from "geocortex/framework/application/Application";
import { Site } from "geocortex/essentials/Site";
import { Observable } from "geocortex/framework/observables";
import { AccessibilityManager } from "geocortex/infrastructure/accessibility/AccessibilityManager";
import { CoordinatesManager } from "geocortex/infrastructure/coordinates/CoordinatesManager";
import { FeatureSetManager } from "geocortex/infrastructure/FeatureSetManager";
import { SearchManager } from "geocortex/infrastructure/search/SearchManager";
import { HighlightManager } from "geocortex/infrastructure/HighlightManager";
import { NativeManager } from "geocortex/infrastructure/native/NativeManager";
import { OfflineManager } from "geocortex/infrastructure/offline/OfflineManager";
import { StateManager } from "geocortex/infrastructure/states/StateManager";
import { UndoManager } from "geocortex/infrastructure/undo/UndoManager";
import { MenuRegistry } from "geocortex/infrastructure/menus/MenuRegistry";
import { ToolRegistry } from "geocortex/infrastructure/tools/ToolRegistry";
import { ToolbarGroupRegistry } from "geocortex/infrastructure/toolbarGroup/ToolbarGroupRegistry";
import { ClickableGraphicsRegistry } from "geocortex/infrastructure/clickableGraphics/ClickableGraphicsRegistry";
import { ProjectManager } from "geocortex/infrastructure/project/ProjectManager";
import { WebMapManager } from "geocortex/infrastructure/webMap/WebMapManager";
import { BookmarkManager } from "geocortex/infrastructure/BookmarkManager";
import { ContentPolicy } from "geocortex/infrastructure/ContentPolicy";
import { DefaultActivityDispatcher } from "geocortex/workflow/DefaultActivityDispatcher";
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { ActivityDispatcher } from "geocortex/workflow/ActivityDispatcher";
export class ViewerApplication extends Application {
    version: string;
    map: esri.Map;
    site: Site;
    markupLayer: Observable<esri.layers.GraphicsLayer>;
    accessibilityManager: AccessibilityManager;
    coordinatesManager: CoordinatesManager;
    featureSetManager: FeatureSetManager;
    searchManager: SearchManager;
    highlightManager: HighlightManager;
    nativeManager: NativeManager;
    offlineManager: OfflineManager;
    stateManager: StateManager;
    undoManager: UndoManager;
    menuRegistry: MenuRegistry;
    toolRegistry: ToolRegistry;
    toolbarGroupRegistry: ToolbarGroupRegistry;
    isArcGisWebApp: boolean;
    viewerConfigPath: string;
    project: ProjectManager;
    webMap: WebMapManager;
    bookmarks: BookmarkManager;
    clickableGraphics: ClickableGraphicsRegistry;
    private _applicationContentPolicy;
    private _workflowActivityDispatcher;
    private _activityTypeHandlerQueue;
    private _activityIdHandlerQueue;
    private _localeResourcesLoaded;
    private _initialProjectPromise;
    private _offlineManagerLoaded;
    constructor(configObject: any, hostElement?: HTMLElement, id?: string, configTokens?: {
        [token: string]: string;
    });
    readonly defaultContentPolicy: ContentPolicy;
    followNavigationLink(args: {
        url: string;
        element: HTMLAnchorElement;
    }): boolean;
    protected _registerApplicationLevelCommands(): void;
    protected _executeOpenWebPage(argument: string | {
        url: string;
        element: HTMLAnchorElement;
    } | {
        url: string;
        isLink: boolean;
    }): boolean;
    /**
     * Register an implementation of the "RelayCommand" command.
     * This command is useful in menu item config which would normally pass a command paramter containing "{{context}}".
     * Using this command we can access child properties of the {{context}}
     */
    private _registerRelayCommand();
    initialize(): void;
    /**
     * Returns a promise that is fulfilled when the Essentials site is initialized.
     */
    waitUntilSiteInitialized(): Promise<void>;
    /**
     * Returns a promise that is fulfilled when the Document Store is initialized.
     */
    waitUntilDocumentStoreInitialized(): Promise<void>;
    /**
     * Returns a promise that is fulfilled when the OfflineManager is loaded.
     */
    waitUntilOfflineManagerLoaded(): Promise<void>;
    /**
     * Returns a promise that is fulfilled when the esri map is loaded (i.e., the first service layer has been
     * added to the map and its spatial reference set).
     */
    waitUntilMapLoaded(): Promise<void>;
    /**
     * Returns a promise that is fulfilled when the given service layer has finished loading.
     */
    waitUntilServiceLayerLoaded(serviceLayer: esri.layers.Layer): Promise<void>;
    /**
     * Returns a promise that is fulfilled when all service layers in the site have finished loading.
     */
    waitUntilSiteServiceLayersLoaded(): Promise<void>;
    /**
     * Returns a promise that is fulfilled when the all libraries are loaded.
     */
    waitUntilAllLibrariesLoaded(): Promise<void>;
    /**
     * Returns a promise that is fulfilled when the view with the given ID is initialized.
     */
    waitUntilViewInitialized(viewId: string): Promise<ViewBase>;
    registerActivityTypeHandler(typeName: string, handler: Function): void;
    registerActivityIdHandler(id: string, handler: Function): void;
    getWorkflowActivityDispatcher(): ActivityDispatcher;
    setWorkflowActivityDispatcher(dispatcher: DefaultActivityDispatcher): void;
    /**
     * Shuts down the application, releasing all modules, views, bindings, view models, regions, commands, and events.
     */
    shutdown(state: any): void;
    /**
     * Called immediately after the configuration object has been loaded from JSON, and before any libraries are downloaded.
     * have been downloaded.
     * @protected
     */
    onConfigurationLoaded(configObject: any): void;
    protected getInitialState(moduleName: string, libraryId: string): Promise<any>;
    private _locale;
    locale: string;
    doWhenMapInitialized(action: () => void): void;
    /**
     * Loads necessary locale resources for 3rd party libraries once the application locale is known.
     */
    private _loadThirdPartyLocaleResources();
    private _loadMomentLocaleData();
    private _loadGlobalizeLocaleData();
    /**
     * A list of locales that are supported by Moment.js.
     */
    private _momentLocales;
    /**
     * A list of locales that are supported by Globalize.js.
     */
    private _globalizeLocales;
    /**
     * Maps a locale code to one of the available locales for Moment.js.
     */
    private _getMomentLocaleForLocale(locale);
    /**
     * Maps a locale code to one of the available locales for Globalize.js.
     */
    private _getGlobalizeLocaleForLocale(locale);
    /**
     * Given a list of available locales, chooses the most appropriate match for a target locale.
     */
    private _getBestMatchLocale(locale, availableLocales);
    /**
     * Parses a locale code into its component parts.
     */
    private _parseLocale(locale);
    /**
     * Converts a locale code to its canonicalized form, e.g. "de-ch" becomes "de-CH", "ZH-HANS-CN" becomes "zh-Hans-CN").
     */
    private _canonicalizeLocale(locale);
}

}
declare module "geocortex/infrastructure/VisualizationUtils" {
import { Layer } from "geocortex/essentials/Layer";
import { FeatureHeatMap } from "geocortex/essentials/FeatureHeatMap";
/**
 * Gets the feature heat map settings for a geocortex layer.
 * @param gcxLayer the layer to get the feature heat map from.
 * @returns The feature heat map or null.
 */
export function getFeatureHeatMap(gcxLayer: Layer): FeatureHeatMap;
/**
 * Gets the heat map renderer for a geocortex layer.
 * @param gcxLayer The layer to get the heat map renderer from.
 * @returns The heat map renderer or null.
 */
export function getHeatMapRenderer(gcxLayer: Layer): esri.renderer.HeatmapRenderer;

}
declare module "geocortex/infrastructure/accessibility/AccessibilityManager" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { AccessibleMapComponent } from "geocortex/infrastructure/accessibility/AccessibleMapComponent";
import { ExtendedDrawOptions } from "geocortex/infrastructure/accessibility/ExtendedDrawOptions";
import { Draw } from "geocortex/infrastructure/accessibility/Draw";
import { ExtendedEditOptions } from "geocortex/infrastructure/accessibility/ExtendedEditOptions";
import { Edit } from "geocortex/infrastructure/accessibility/Edit";
/**
 * The accessibility manager is the central access point for all things WCAG within the viewer.
 */
export class AccessibilityManager {
    /**
     * The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this accessibility manager instance belongs to.
     */
    app: ViewerApplication;
    /** An object map of all referenced components that can be instantiated by this factory. */
    private _registeredComponentTypes;
    /** An stack of all currently active keyboard components. */
    private _stack;
    /**
     * Initializes a new instance of the {@link AccessibilityManager} class.
     * @param app The {@link framework.application.Application} that this instance belongs to.
     */
    constructor(app: ViewerApplication);
    registerComponent(name: string, typeName: string): void;
    unregisterComponent(name: string): boolean;
    /** Creates an Esri draw object. See {@link esri.toolbars.Draw} */
    createComponent(name: "esri.toolbars.draw", map: esri.Map, options?: esri.DrawOptions): esri.toolbars.Draw;
    /** Creates an Esri edit object. See {@link esri.toolbars.Edit} */
    createComponent(name: "esri.toolbars.edit", map: esri.Map, options?: esri.EditOptions): esri.toolbars.Edit;
    /** Creates a keyboard accessible draw object. See {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.accessibility.Draw} */
    createComponent(name: "geocortex.accessibility.draw", map: esri.Map, options?: ExtendedDrawOptions): Draw;
    /** Creates a keyboard accessible edit object. See {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.accessibility.Edit} */
    createComponent(name: "geocortex.accessibility.edit", map: esri.Map, options?: ExtendedEditOptions): Edit;
    createComponent(name: string, map: esri.Map, options?: any): any;
    /**
     * @private
     * A central location to ensure proper access to keyboard events. Whenever a new accessible component
     * is activated that requests access to keyboard events, the AccessibilityManager will suspend existing tools
     * until the current one completes execution.
     * This is modelled with a stack structure.
     */
    protected _handleAccessibleComponentStarted(sender: AccessibleMapComponent): void;
    /**
     * @private
     * A central location to ensure proper access to keyboard events. Whenever a new accessible component
     * is activated that requests access to keyboard events, the AccessibilityManager will suspend existing tools
     * until the current one completes execution.
     * This is modelled with a stack structure.
     */
    protected _handleAccessibleComponentCompleted(sender: AccessibleMapComponent): void;
}

}
declare module "geocortex/infrastructure/accessibility/AccessibilityProviderBase" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
export class AccessibilityProviderBase {
    /**
     * The {@link geocortex.framework.application.Application} that this view belongs to.
     */
    app: ViewerApplication;
    libraryId: string;
    /**
     * The ID of the provider.
     * @type String
     */
    id: string;
    constructor(app: ViewerApplication, libraryId: string);
    initialize(config: any): void;
}

}
declare module "geocortex/infrastructure/accessibility/AccessibleMapComponent" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { MapNavigationState } from "geocortex/infrastructure/accessibility/MapNavigationState";
/**
 * Base class for accessible components
 */
export class AccessibleMapComponent {
    /**
     * The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this Draw toolbar instance belongs to.
     */
    app: ViewerApplication;
    /** The mode the component is running - e.g. mouse, keyboard */
    inputMethod: string;
    suspended: boolean;
    isKeyboardActive: boolean;
    id: string;
    /** The map instance. */
    _map: esri.Map;
    private _mapNavState;
    /** Event handles */
    private _mouseDownHandle;
    private _keyDownHandle;
    private _keyUpHandle;
    constructor(map: esri.Map, app?: ViewerApplication);
    setMap(map: esri.Map): void;
    setApp(app: ViewerApplication): void;
    /**
     * Sets the current input method for this component (for example, mouse or keyboard).
     * @param method The input method. See {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.accessibility.InputMethod} for valid values.
     */
    setInputMethod(method: string): void;
    setKeyboardActive(value: boolean): void;
    suspend(): void;
    resume(): void;
    disableMapNavigation(hideZoomSlider?: boolean, hidePanArrows?: boolean, disableGraphicMouseEvents?: boolean): MapNavigationState;
    enableMapNavigation(showZoomSlider?: boolean, showPanArrows?: boolean, enableGraphicMouseEvents?: boolean, mapState?: MapNavigationState): void;
    getMapState(): MapNavigationState;
    activateMouseControls(resetInputMethod?: boolean): void;
    deactivateMouseControls(resetInputMethod?: boolean): void;
    activateKeyboardControls(resetInputMode?: boolean): void;
    deactivateKeyboardControls(resetInputMethod?: boolean): void;
    toggleKeyboardMode(): void;
    /**
     * Fired when the input method for this component (e.g. keyboard, mouse) has changed.
     */
    onInputMethodChange(result: {
        previousMethod: string;
        newMethod: string;
    }): void;
    /**
     * Internal method that subclasses should override to provide keyboard handling.
     */
    onKeyboardStart(): void;
    /**
     * Internal method that subclasses should override to provide keyboard handling.
     * @param cancelled Whether the operation was cancelled.
     */
    onKeyboardStop(cancelled?: boolean): void;
    /**
     * Internal method that subclasses should override to provide keyboard handling.
     */
    protected _onKeyDown(event: KeyboardEvent): void;
    /**
     * Internal method that subclasses should override to provide keyboard handling.
     */
    protected _onKeyUp(event: KeyboardEvent): void;
}

}
declare module "geocortex/infrastructure/accessibility/BoxEditor" {
import { EditCapabilityBase } from "geocortex/infrastructure/accessibility/EditCapabilityBase";
import { BoxEditorOptions } from "geocortex/infrastructure/accessibility/BoxEditorOptions";
import { EditInterface } from "geocortex/infrastructure/accessibility/EditInterface";
export class BoxEditor extends EditCapabilityBase {
    private _options;
    private _scaleEnabled;
    private _rotateEnabled;
    private _uniformScaling;
    private _isTextPoint;
    private _modified;
    private _isRotating;
    private _isScaling;
    private _lineSymbol;
    private _markerSymbol;
    private _transform;
    /** Keyboard event subscriptions */
    private _keyDownHandle;
    private _keyUpHandle;
    constructor(graphic: esri.Graphic, map: esri.Map, owner: EditInterface, isTextPoint: boolean, options?: BoxEditorOptions);
    destroy(): void;
    protected _init(): void;
    protected _cleanUp(): void;
    /**
     * Provides keyboard handling for the BoxEditor component.
     * @private
     */
    protected _onKeyDownHandler(event: KeyboardEvent): void;
    /**
     * Keyboard event handler
     * @private
     */
    protected _onKeyUpHandler(event: KeyboardEvent): void;
    protected _rotateGraphic(degreesClockwise: number, pivotMapPoint?: esri.geometry.Point): void;
    protected _scaleGraphic(scaleX: number, scaleY?: number): void;
}

}
declare module "geocortex/infrastructure/accessibility/BoxEditorOptions" {
export interface BoxEditorOptions {
    rotateEnabled?: boolean;
    scaleEnabled?: boolean;
    uniformScaling?: boolean;
    rotationAngle?: number;
    scaleFactor?: number;
    preciseRotationAngle?: number;
    preciseScaleFactor?: number;
    boxLineSymbol?: esri.symbol.SimpleLineSymbol;
    boxHandleSymbol?: esri.symbol.SimpleMarkerSymbol;
}

}
declare module "geocortex/infrastructure/accessibility/Draw" {
import { AccessibleMapComponent } from "geocortex/infrastructure/accessibility/AccessibleMapComponent";
import { Edit } from "geocortex/infrastructure/accessibility/Edit";
import { ExtendedDrawOptions } from "geocortex/infrastructure/accessibility/ExtendedDrawOptions";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { GraphicDrawActivatedEventArgs } from "geocortex/infrastructure/eventArgs/GraphicDrawActivatedEventArgs";
import { GraphicDrawDeactivatedEventArgs } from "geocortex/infrastructure/eventArgs/GraphicDrawDeactivatedEventArgs";
import { GraphicVertexAddedEventArgs } from "geocortex/infrastructure/eventArgs/GraphicVertexAddedEventArgs";
import { GraphicVertexMovedEventArgs } from "geocortex/infrastructure/eventArgs/GraphicVertexMovedEventArgs";
import { GraphicEditActivatedEventArgs } from "geocortex/infrastructure/eventArgs/GraphicEditActivatedEventArgs";
import { GraphicEditDeactivatedEventArgs } from "geocortex/infrastructure/eventArgs/GraphicEditDeactivatedEventArgs";
/**
 * Toolbar that supports functionality to create new geometries by drawing them: points (POINT or MULTI_POINT),
 * lines (LINE, POLYLINE, or FREEHAND_POLYLINE), polygons (FREEHAND_POLYGON or POLYGON), or rectangles (EXTENT).
 * To edit geometries of existing graphics, use the Edit Toolbar.
 */
export class Draw extends AccessibleMapComponent implements esri.toolbars.Draw {
    /** Draws an arrow. */
    static ARROW: string;
    /** Draws a circle. */
    static CIRCLE: string;
    /** Draws an arrow that points down. */
    static DOWN_ARROW: string;
    /** Draws an ellipse. */
    static ELLIPSE: string;
    /** Draws an extent box. */
    static EXTENT: string;
    /** Draws a freehand polygon. */
    static FREEHAND_POLYGON: string;
    /** Draws a freehand polyline. */
    static FREEHAND_POLYLINE: string;
    /** Draws an arrow that points left. */
    static LEFT_ARROW: string;
    /** Draws a line. */
    static LINE: string;
    /** Draws a Multipoint. */
    static MULTI_POINT: string;
    /** Draws a point. */
    static POINT: string;
    /** Draws a polygon. */
    static POLYGON: string;
    /** Draws a polyline. */
    static POLYLINE: string;
    /** Draws a rectangle. */
    static RECTANGLE: string;
    /** Draws an arrow that points right. */
    static RIGHT_ARROW: string;
    /** Draws a triangle. */
    static TRIANGLE: string;
    /** Draws an arrow that points up. */
    static UP_ARROW: string;
    /**
     * Symbol to be used when drawing a Polygon or Extent.
     */
    fillSymbol: esri.symbol.SimpleFillSymbol;
    /**
     * Symbol to be used when drawing a Polyline.
     */
    lineSymbol: esri.symbol.SimpleLineSymbol;
    /**
     * Symbol to be used when drawing a Point or Multipoint.
     */
    markerSymbol: esri.symbol.SimpleMarkerSymbol;
    /**
     * When set to false, the geometry is modified to be topologically correct.
     */
    respectDrawingVertexOrder: boolean;
    /**
     * Marker symbol used to draw the vertices while in keyboard mode. Valid for polyline and polygon geometries.
     */
    vertexSymbol: esri.symbol.SimpleMarkerSymbol;
    /**
     * Marker symbol used to draw the currently selected vertex while in keyboard mode. Valid for polyline and polygon geometries.
     */
    selectedVertexSymbol: esri.symbol.MarkerSymbol;
    private static _draw;
    /** @private */
    private static createEllipse(options);
    /** @private */
    private static createCircle(options);
    /** Templates for pre-defined shapes that can be drawn with this tool */
    protected _arrowShapeTemplate: number[][];
    protected _leftArrowShapeTemplate: number[][];
    protected _rightArrowShapeTemplate: number[][];
    protected _upArrowShapeTemplate: number[][];
    protected _downArrowShapeTemplate: number[][];
    protected _triangleShapeTemplate: number[][];
    protected _rectangleShapeTemplate: number[][];
    /** The default (mouse-driven) drawing tools */
    private _drawObject;
    /** Internal shape editing tools */
    private _editObject;
    /** The type of geometry drawn. */
    private _geometryType;
    /** The draw options */
    private _options;
    private _defaultOptions;
    /** Whether we are in a drawing session */
    private _active;
    /** The shape being drawn */
    private _graphic;
    /** Collection of digitized vertices when in keyboard mode. Valid for polyline and polygon geometries */
    /** _points and _onClickHandler are private members of Esri draw toolbar that are manipulated within the MapTool class */
    private _points;
    /** Deferred representing a drawing operation. It can result in either a default shape (e.g. circle) or a shape digitized via keyboard (e.g. polygon) */
    private _createGeometryDeferred;
    /** Whether polyline/polygon keyboard drawing is active */
    private _isPlottingPolyGeometry;
    /** Whether the polygon/polyline vertex anchor has been moved with the keyboard */
    private _lastVertexPosition;
    /** The polyline/polygon vertex anchor (red dot). Valid for polyline and polygon geometries */
    private _vertexAnchor;
    /** The ghost line is displayed when moving vertices. Valid for polyline and polygon geometries */
    private _ghostLine;
    /** Handles returned by dojo.aspect */
    private _handles;
    private _polyGeometryKeyDownHandle;
    private _editCompletedHandle;
    private _dblClickHandlerToken;
    private _lastSnappingPoint;
    /**
     * Creates a new Draw object.
     * @param map Map the toolbar is associated with.
     * @param options Parameters that define the functionality of the draw toolbar.
     */
    constructor(map: esri.Map, options?: ExtendedDrawOptions, app?: ViewerApplication);
    /**
     * Activates the toolbar for drawing geometries.
     * @param geometryType The type of geometry drawn.
     * @param options Options that define the functionality of the draw toolbar.
     */
    activate(geometryType: string, options?: ExtendedDrawOptions): void;
    /**
     * Deactivates the toolbar and reactivates map navigation.
     */
    deactivate(): void;
    /**
     * Finishes drawing the geometry and fires the onDrawEnd event.
     */
    finishDrawing(): void;
    /**
     * Sets the fill symbol.
     * @param fillSymbol The fill symbol.
     */
    setFillSymbol(fillSymbol: esri.symbol.SimpleFillSymbol): void;
    /**
     * Sets the line symbol.
     * @param lineSymbol The line symbol.
     */
    setLineSymbol(lineSymbol: esri.symbol.SimpleLineSymbol): void;
    /**
     * Sets the marker symbol.
     * @param markerSymbol The marker symbol.
     */
    setMarkerSymbol(markerSymbol: esri.symbol.SimpleMarkerSymbol): void;
    /**
     * Sets whether the polygon geometry should be modified to be topologically correct.
     * @param value When set to false, the geometry is modified to be topologically correct.
     */
    setRespectDrawingVertexOrder(value: boolean): void;
    /**
     * Sets the vertex marker symbol.
     * @param markerSymbol The marker symbol.
     */
    setVertexSymbol(markerSymbol: esri.symbol.SimpleMarkerSymbol): void;
    /**
     * Sets the vertex highlight marker symbol.
     * @param markerSymbol The marker symbol.
     */
    setSelectedVertexSymbol(markerSymbol: esri.symbol.SimpleMarkerSymbol): void;
    activateMouseControls(resetInputMode?: boolean): void;
    deactivateMouseControls(resetInputMode?: boolean): void;
    raiseGraphicDrawActivated(eventArgs?: GraphicDrawActivatedEventArgs): void;
    raiseGraphicDrawDeactivated(eventArgs?: GraphicDrawDeactivatedEventArgs): void;
    raiseGraphicVertexAdded(eventArgs?: GraphicVertexAddedEventArgs): void;
    raiseGraphicVertexMoved(eventArgs?: GraphicVertexMovedEventArgs): void;
    /** Fired when the user has ended drawing. */
    on(type: "draw-complete", listener: (event: {
        geographicGeometry: esri.geometry.Geometry;
        geometry: esri.geometry.Geometry;
        target: esri.toolbars.Draw;
    }) => void): esri.Handle;
    /** Fired when drawing is complete. */
    on(type: "draw-end", listener: (event: {
        geometry: esri.geometry.Geometry;
        target: esri.toolbars.Draw;
    }) => void): esri.Handle;
    on(type: string, listener: (event: any) => void): esri.Handle;
    /**
     * Fired when the drawing tools are activated.
     */
    onActivate(): void;
    /**
     * Fired when the drawing tools are deactivated.
     */
    onDeactivate(): void;
    /**
     * Fired when the user has ended drawing.
     * @param result The event object has the following properties: geometry, geographicGeometry.
     * `geometry` represents the shape that was drawn. Coordinates of this geometry have the same spatial reference of the map.
     * `geographicGeometry` represents the drawn shape in geographic coordinates (latitude, longitude). Only available when the map's
     * spatial reference is Web Mercator or Geographic (4326)
     */
    onDrawComplete(result: {
        geographicGeometry: esri.geometry.Geometry;
        geometry: esri.geometry.Geometry;
    }): void;
    /**
     * Fired when drawing is complete.
     * @param geometry Geometry drawn on the client.
     */
    onDrawEnd(geometry: esri.geometry.Geometry): void;
    /**
     * Internal method that subclasses should override to provide keyboard handling.
     */
    onKeyboardStart(): void;
    /**
     * Internal method that subclasses should override to provide keyboard handling.
     * @param cancelled Whether the operation was cancelled.
     */
    onKeyboardStop(cancelled?: boolean): void;
    /**
     * Provides keyboard handling for the Draw component.
     */
    protected _onKeyDown(event: KeyboardEvent): void;
    /**
     * GVH measurement tools rely on private/unsupported methods of the Esri Draw object. This is one of them.
     * @private
     */
    protected _onClickHandler(event: esri.AGSMouseEvent): void;
    /** Whether keyboard input is supported for the specified geometry type. Keyboard input is not supported for freehand drawing. */
    protected _supportsKeyboardInput(geometryType: string): boolean;
    protected _finishKeyboardDrawing(raiseDrawEndEvent?: boolean): void;
    protected _clear(): void;
    /**
     * Fires the draw-end event.
     * @private
     */
    protected _drawEnd(geometry: esri.geometry.Geometry): void;
    protected _moveVertexAnchor(dx: number, dy: number): void;
    private _handleSnappingEvent(args);
    /** @private Updates the ghost line, displayed when moving vertices. Valid for polyline and polygon geometries. */
    protected _updateGhostLine(vertexLocation: esri.geometry.Point): void;
    protected _addVertex(vertex: esri.geometry.Point): void;
    /** Starts digitizing polygons, polylines or multi-points via the keyboard. Returns a promise that is fulfilled once the user completes the drawing. */
    protected _drawPolyGeometry(start: esri.geometry.Point, geometryType: string): Promise<esri.geometry.Geometry>;
    /** Handles keyboard input for plotting polygons, polylines and multipoints. */
    protected _drawPolyGeometry_handleKeyDown(resolve: (result: esri.geometry.Geometry | Promise<esri.geometry.Geometry>) => void, reject: (error: any) => void): dojo.RemovableHandle;
    /** Plots a shape on the map. It will produce either a default shape (e.g. circle) or a shape digitized via the keyboard (e.g. polygon) */
    protected _plotShape(location: esri.geometry.Point, geometryType: string): Promise<esri.geometry.Geometry>;
    protected _editShape(geometry: esri.geometry.Geometry): void;
    /**
     * Raises the draw-end event after editing is completed.
     * @private
     */
    protected _onEditShapeCompleted(tool: number, graphic: esri.Graphic, info: {
        isModified: boolean;
        cancelled?: boolean;
    }): void;
    protected _toPolygon(ring: number[][], dx: number, dy: number): esri.geometry.Polygon;
    protected _syncPointsCollection(): void;
    protected _getEditMode(geometryType: string): {
        mode: number;
        options?: esri.EditOptions;
    };
    protected _vertexCount(g: esri.geometry.Geometry): number;
    /**
     * Esri's JavaScript API 3.8 have caused numerous problems with markup and measurement, resulting in the need for numerous hacks
     * and workarounds in the measurement, markup and printing modules, and possibly others as well.
     * This is a central placeholder for all hacks and workarounds needed by the WCAG accessible tools.
     *
     * See GVH-3523, GVH-3535, GVH-3516, GVH-4973
     */
    protected _twoClicksWithin300MsFixup(): void;
    protected _twoClicksWithin300MsFixup_handleClick(evt: esri.AGSMouseEvent, origOnClickHandler: () => void): void;
    protected _extraPointOnTouchDevicesFixup(): void;
}
/**
 * Editing component used internally by the Draw component.
 * It explicitly overrides a few parent methods to avoid emitting events since this component is internal.
 */
export class EditInternal extends Edit {
    protected raiseGraphicEditActivated(eventArgs?: GraphicEditActivatedEventArgs): void;
    protected raiseGraphicEditDeactivated(eventArgs?: GraphicEditDeactivatedEventArgs): void;
}

}
declare module "geocortex/infrastructure/accessibility/Edit" {
import { AccessibleMapComponent } from "geocortex/infrastructure/accessibility/AccessibleMapComponent";
import { ExtendedEditOptions } from "geocortex/infrastructure/accessibility/ExtendedEditOptions";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { GraphicEditActivatedEventArgs } from "geocortex/infrastructure/eventArgs/GraphicEditActivatedEventArgs";
import { GraphicEditDeactivatedEventArgs } from "geocortex/infrastructure/eventArgs/GraphicEditDeactivatedEventArgs";
import { EditCapabilityBase } from "geocortex/infrastructure/accessibility/EditCapabilityBase";
import { EditInterface } from "geocortex/infrastructure/accessibility/EditInterface";
/**
 * The Edit toolbar is a helper class that provides functionality to move graphics or
 * modify individual vertices, i.e., edit the geometry of existing graphics.
 * To add new graphics, use the Draw toolbar.
 */
export class Edit extends AccessibleMapComponent implements esri.toolbars.Edit, EditInterface {
    /** When a textSymbol point is in edit mode, double-clicking leads to text editing mode, which is a text box where uses can change the text content. */
    static EDIT_TEXT: number;
    /** Display and edit vertices of a Polyline, Polygon, or Multipoint. */
    static EDIT_VERTICES: number;
    /** Move graphic to a new location on the map. */
    static MOVE: number;
    /** Rotate the graphic. */
    static ROTATE: number;
    /** Scale or resize a graphic. */
    static SCALE: number;
    private static _edit;
    /** The default (mouse-driven) drawing tools */
    private _editObject;
    /** The editing options */
    private _options;
    private _defaultOptions;
    /** The active tool(s). Can be a combination of several tools, e.g. Edit.MOVE | Edit.SCALE */
    private _tool;
    /** Whether the shape being edited is text markup */
    private _isTextPoint;
    private _editHandle;
    private _isGeo;
    /** Whether we are in a editing session */
    private _active;
    /** Whether the shape has been modified */
    private _modified;
    /** Whether the editing operation has been cancelled */
    private _cancelled;
    /** Whether the mouse handles need refreshing (e.g. the graphic was changed via the keyboard) */
    private _needsRefresh;
    /** The shape being drawn */
    private _graphic;
    /** Handles returned by dojo.aspect */
    private _handles;
    /** Snapping feedback event token */
    private _snappingFeedbackEventToken;
    /** The last found snapping point */
    private _lastSnapPoint;
    /** Editing capabilities (e.g. move, scale, rotate, vertex editing) */
    private _graphicMover;
    private _vertexEditor;
    private _boxEditor;
    /** Handle symbol changes to edited point graphics */
    private _symbolChangeHandle;
    private _editNotificationViewId;
    /**
     * Creates a new Edit object. A map is a required parameter.
     * @param map Map the toolbar is associated with.
     * @param options Optional parameters.
     */
    constructor(map: esri.Map, options?: esri.EditOptions, app?: ViewerApplication);
    _addPointerEventsOnRedraw(): void;
    /**
     * Activates the toolbar to edit the supplied graphic. After activation the toolbar is ready for user interaction using the specified tool.
     * @param tool Specify the active tool(s). Combine tools using the | operator.
     * @param graphic The graphic to edit.
     * @param options See the object specifications table below for the structure of the `options` object.
     */
    activate(tool: number, graphic: esri.Graphic, options?: esri.EditOptions): void;
    private _addPointEditHandles(sourceGraphic);
    private _calculatePath(size, spikeSize);
    private _getTargetGraphic(sourceGraphic, sourceSymbol, targetSize, spikeSize, style, color);
    /**
     * Deactivates the toolbar. Call this method to deactivate the toolbar after editing the graphic.
     */
    deactivate(): void;
    private _removePointEditHandles(graphic);
    private _hidePointEditHandles(graphic);
    private _showPointEditHandles(graphic);
    private _updateLocationPointEditHandles(graphic);
    private _updateSizePointEditHandles(graphic);
    /**
     * Convert a polygon to an extent. Used for zoom operations using the keyboard.
     * @param polygon A esri.geometry.Polygon polygon that is to be converted to an extent.
     */
    protected _convertPolygonToExtent(polygon: any): esri.geometry.Extent;
    getOptions(): ExtendedEditOptions;
    /**
     * Returns an object with the following properties that describe the current state: `tool`, `graphic`, `isModified`.
     */
    getCurrentState(): {
        tool: number;
        graphic: esri.Graphic;
        isModified: boolean;
    };
    /**
     * Returns an array with the available tools (for example, [MOVE tool, ROTATE tool, SCALE tool]).
     */
    getEnabledTools(): EditCapabilityBase[];
    /**
     * Refreshes the internal state of the toolbar.
     */
    refresh(): void;
    setNeedsRefresh(value: boolean): void;
    suspend(): void;
    resume(): void;
    isActive(): boolean;
    activateMouseControls(resetInputMode?: boolean): void;
    deactivateMouseControls(resetInputMode?: boolean): void;
    /** Activates the toolbar for editing geometries. */
    on(type: "activate", listener: (event: {
        graphic: esri.Graphic;
        tool: number;
        target: esri.toolbars.Edit;
    }) => void): esri.Handle;
    /** Deactivates the toolbar and reactivates map navigation. */
    on(type: "deactivate", listener: (event: {
        graphic: esri.Graphic;
        info: any;
        tool: number;
        target: esri.toolbars.Edit;
    }) => void): esri.Handle;
    /** Fires when a graphic is clicked. */
    on(type: "graphic-click", listener: (event: {
        graphic: esri.Graphic;
        info: any;
        target: esri.toolbars.Edit;
    }) => void): esri.Handle;
    /** Fires when the user begins to move a graphic. */
    on(type: "graphic-first-move", listener: (event: {
        graphic: esri.Graphic;
        target: esri.toolbars.Edit;
    }) => void): esri.Handle;
    /** Fired continuously as the graphic moves. */
    on(type: "graphic-move", listener: (event: {
        graphic: esri.Graphic;
        transform: any;
        target: esri.toolbars.Edit;
    }) => void): esri.Handle;
    /** Fired when the mouse button is pressed down on the graphic, usually while moving a graphic. */
    on(type: "graphic-move-start", listener: (event: {
        graphic: esri.Graphic;
        target: esri.toolbars.Edit;
    }) => void): esri.Handle;
    /** Fired when the mouse button is released, usually after moving the graphic. */
    on(type: "graphic-move-stop", listener: (event: {
        graphic: esri.Graphic;
        transform: any;
        target: esri.toolbars.Edit;
    }) => void): esri.Handle;
    /** Fires continuously as a graphic is rotated. */
    on(type: "rotate", listener: (event: {
        graphic: esri.Graphic;
        info: any;
        target: esri.toolbars.Edit;
    }) => void): esri.Handle;
    /** Fires when the user begins to drag a handle to rotate the graphic. */
    on(type: "rotate-first-move", listener: (event: {
        graphic: esri.Graphic;
        target: esri.toolbars.Edit;
    }) => void): esri.Handle;
    /** Fires when a user clicks on the handle to begin rotating a graphic. */
    on(type: "rotate-start", listener: (event: {
        graphic: esri.Graphic;
        target: esri.toolbars.Edit;
    }) => void): esri.Handle;
    /** Fires when the mouse button is released from the rotate handle to finish rotating the graphic. */
    on(type: "rotate-stop", listener: (event: {
        graphic: esri.Graphic;
        info: any;
        target: esri.toolbars.Edit;
    }) => void): esri.Handle;
    /** Fires continuously as the graphic is being scaled. */
    on(type: "scale", listener: (event: {
        graphic: esri.Graphic;
        info: any;
        target: esri.toolbars.Edit;
    }) => void): esri.Handle;
    /** Fires when the user begins to drag a handle to scale the graphic. */
    on(type: "scale-first-move", listener: (event: {
        graphic: esri.Graphic;
        target: esri.toolbars.Edit;
    }) => void): esri.Handle;
    /** Fires when a user clicks on the handle to scale or resize a graphic. */
    on(type: "scale-start", listener: (event: {
        graphic: esri.Graphic;
        target: esri.toolbars.Edit;
    }) => void): esri.Handle;
    /** Fires when the mouse button is released from the scale handle to finish scaling the graphic. */
    on(type: "scale-stop", listener: (event: {
        graphic: esri.Graphic;
        info: any;
        target: esri.toolbars.Edit;
    }) => void): esri.Handle;
    /** Fired after a new vertex is added to a polyline or polygon or a new point is added to a multipoint. */
    on(type: "vertex-add", listener: (event: {
        graphic: esri.Graphic;
        vertexinfo: any;
        target: esri.toolbars.Edit;
    }) => void): esri.Handle;
    /** Fired when the mouse button is clicked on the vertex of a polyline or polygon or a point in a multipoint. */
    on(type: "vertex-click", listener: (event: {
        graphic: esri.Graphic;
        vertexinfo: any;
        target: esri.toolbars.Edit;
    }) => void): esri.Handle;
    /** Fired after a vertex(polyline, polygon) or point(multipoint) is deleted. */
    on(type: "vertex-delete", listener: (event: {
        graphic: esri.Graphic;
        vertexinfo: any;
        target: esri.toolbars.Edit;
    }) => void): esri.Handle;
    /** Fired when the user begins to move the vertex of a polyline or polygon or a point of a multipoint. */
    on(type: "vertex-first-move", listener: (event: {
        graphic: esri.Graphic;
        vertexinfo: any;
        target: esri.toolbars.Edit;
    }) => void): esri.Handle;
    /** Fires as the mouse exits a vertex(polyline, polygon) or a point(multipoint). */
    on(type: "vertex-mouse-out", listener: (event: {
        graphic: esri.Graphic;
        vertexinfo: any;
        target: esri.toolbars.Edit;
    }) => void): esri.Handle;
    /** Fired when the mouse moves over a vertex (polyline, polygon) or point (multipoint). */
    on(type: "vertex-mouse-over", listener: (event: {
        graphic: esri.Graphic;
        vertexinfo: any;
        target: esri.toolbars.Edit;
    }) => void): esri.Handle;
    /** Fired continuously as the user is moving a vertex (polyline, polygon) or point (multipoint). */
    on(type: "vertex-move", listener: (event: {
        graphic: esri.Graphic;
        transform: any;
        vertexinfo: any;
        target: esri.toolbars.Edit;
    }) => void): esri.Handle;
    /** Fired when the mouse button is pressed down on a vertex (polyline, polygon) or point (multipoint). */
    on(type: "vertex-move-start", listener: (event: {
        graphic: esri.Graphic;
        vertexinfo: any;
        target: esri.toolbars.Edit;
    }) => void): esri.Handle;
    /** Fired when the mouse button is released from a vertex (polyline, polygon) or point(multipoint). */
    on(type: "vertex-move-stop", listener: (event: {
        graphic: esri.Graphic;
        transform: any;
        vertexinfo: any;
        target: esri.toolbars.Edit;
    }) => void): esri.Handle;
    on(type: string, listener: (event: any) => void): esri.Handle;
    /**
     * Fired when the editing tools are activated.
     * @param tool The editing type. The constants table lists valid editing values.
     * @param graphic The graphic to edit whose vertices will be edited or moved.
     */
    onActivate(tool: number, graphic: esri.Graphic): void;
    /**
     * Fired when the editing tools are deactivated.
     * @param tool The editing type. The constants table lists valid editing values.
     * @param graphic The graphic the toolbar was associated with.
     * @info An object with the following properties: isModified
     */
    onDeactivate(tool: number, graphic: esri.Graphic, info: {
        isModified: boolean;
        cancelled?: boolean;
    }): void;
    /**
     * Fired when a graphic is clicked. Applicable only when the MOVE tool is active.
     * @param graphic The clicked graphic.
     * @param info An object with the following properties: `mapPoint`, `screenPoint`
     */
    onGraphicClick(graphic: esri.Graphic, info: {
        mapPoint: esri.geometry.Point;
        screenPoint: esri.geometry.ScreenPoint;
    }): void;
    /** @private */
    _onGraphicClickImpl(graphic: esri.Graphic, info: {
        mapPoint: esri.geometry.Point;
        screenPoint: esri.geometry.ScreenPoint;
    }): void;
    /**
     * Fired when the user begins to move a graphic. Applicable only when the MOVE tool is active.
     * @param graphic The graphic associated with the toolbar.
     */
    onGraphicFirstMove(graphic: esri.Graphic): void;
    /** @private */
    _onGraphicFirstMoveImpl(graphic: esri.Graphic): void;
    /**
     * Fired continuously as the graphic moves. Applicable only when the MOVE tool is active.
     * @param graphic The graphic associated with the toolbar.
     * @param transform Represents the linear transformation applied to the graphic.
     */
    onGraphicMove(graphic: esri.Graphic, transform: any): void;
    /** @private */
    _onGraphicMoveImpl(graphic: esri.Graphic, transform: any): void;
    /**
     * Fired when the mouse button is pressed down on the graphic, usually while moving a graphic. Applicable only when the MOVE tool is active.
     * @param graphic The graphic associated with the toolbar.
     */
    onGraphicMoveStart(graphic: esri.Graphic): void;
    /** @private */
    _onGraphicMoveStartImpl(graphic: esri.Graphic): void;
    /**
     * Fired when the mouse button is released, usually after moving the graphic. Applicable only when the MOVE tool is active.
     * @param graphic The graphic associated with the toolbar.
     * @param transform Represents the linear transformation applied to the graphic.
     */
    onGraphicMoveStop(graphic: esri.Graphic, transform: any): void;
    /** @private */
    _onGraphicMoveStopImpl(graphic: esri.Graphic, transform: any): void;
    /**
     * Fired continuously as a graphic is rotated.
     * @param graphic The rotated graphic.
     * @param info The info object has the following properties: `transform`, `angle`, `around`
     */
    onRotate(graphic: esri.Graphic, info: any): void;
    /** @private */
    _onRotateImpl(graphic: esri.Graphic, info: any): void;
    /**
     * Fired when the user begins to drag a handle to rotate the graphic.
     * @param graphic The rotated graphic.
     */
    onRotateFirstMove(graphic: esri.Graphic): void;
    /** @private */
    _onRotateFirstMoveImpl(graphic: esri.Graphic): void;
    /**
     * Fired when a user clicks on the handle to begin rotating a graphic.
     * @param graphic The rotated graphic.
     */
    onRotateStart(graphic: esri.Graphic): void;
    /** @private */
    _onRotateStartImpl(graphic: esri.Graphic): void;
    /**
     * Fired when the mouse button is released from the rotate handle to finish rotating the graphic.
     * @param graphic The rotated graphic.
     * @param info The info object has the following properties: `transform`, `angle`, `around`
     */
    onRotateStop(graphic: esri.Graphic, info: any): void;
    /** @private */
    _onRotateStopImpl(graphic: esri.Graphic, info: any): void;
    /**
     * Fired continuously as the graphic is being scaled.
     * @param graphic The scaled graphic.
     * @param info The info object has the following properties: `transform`, `scaleX`, `scaleY`, `around`
     */
    onScale(graphic: esri.Graphic, info: any): void;
    /** @private */
    _onScaleImpl(graphic: esri.Graphic, info: any): void;
    /**
     * Fired when the user begins to drag a handle to scale the graphic.
     * @param graphic The scaled graphic.
     */
    onScaleFirstMove(graphic: esri.Graphic): void;
    /** @private */
    _onScaleFirstMoveImpl(graphic: esri.Graphic): void;
    /**
     * Fired when a user clicks on the handle to scale or resize a graphic.
     * @param graphic The scaled graphic.
     */
    onScaleStart(graphic: esri.Graphic): void;
    /** @private */
    _onScaleStartImpl(graphic: esri.Graphic): void;
    /**
     * Fired when the mouse button is released from the scale handle to finish scaling the graphic.
     * @param graphic The scaled graphic.
     * @param info The info object has the following properties: `transform`, `scaleX`, `scaleY`, `around`
     */
    onScaleStop(graphic: esri.Graphic, info: any): void;
    /** @private */
    _onScaleStopImpl(graphic: esri.Graphic, info: any): void;
    /**
     * Fired after a new vertex is added to a polyline or polygon or a new point is added to a multipoint. Applicable only when the EDIT_VERTICES tool is active.
     * @param graphic The graphic associated with the toolbar.
     * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
     */
    onVertexAdd(graphic: esri.Graphic, vertexInfo: any): void;
    /** @private */
    _onVertexAddImpl(graphic: esri.Graphic, vertexInfo: any): void;
    /**
     * Fired when the mouse button is clicked on the vertex of a polyline or polygon or a point in a multipoint. Applicable only when the EDIT_VERTICES tool is active.
     * @param graphic The graphic associated with the toolbar.
     * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
     */
    onVertexClick(graphic: esri.Graphic, vertexInfo: any): void;
    /** @private */
    _onVertexClickImpl(graphic: esri.Graphic, vertexInfo: any): void;
    /**
     * Fired after a vertex(polyline, polygon) or point(multipoint) is deleted. Applicable only when the EDIT_VERTICES tool is active.
     * @param graphic The graphic associated with the toolbar.
     * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
     */
    onVertexDelete(graphic: esri.Graphic, vertexInfo: any): void;
    /** @private */
    _onVertexDeleteImpl(graphic: esri.Graphic, vertexInfo: any): void;
    /**
     * Fired when the user begins to move the vertex of a polyline or polygon or a point of a multipoint. Applicable only when the EDIT_VERTICES tool is active.
     * @param graphic The graphic associated with the toolbar.
     * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
     */
    onVertexFirstMove(graphic: esri.Graphic, vertexInfo: any): void;
    /** @private */
    _onVertexFirstMoveImpl(graphic: esri.Graphic, vertexInfo: any): void;
    /**
     * Fired as the mouse exits a vertex(polyline, polygon) or a point(multipoint). Applicable only when the EDIT_VERTICES tool is active.
     * @param graphic The graphic associated with the toolbar.
     * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
     */
    onVertexMouseOut(graphic: esri.Graphic, vertexInfo: any): void;
    /** @private */
    _onVertexMouseOutImpl(graphic: esri.Graphic, vertexInfo: any): void;
    /**
     * Fired when the mouse moves over a vertex (polyline, polygon) or point (multipoint). Applicable only when the EDIT_VERTICES tool is active.
     * @param graphic The graphic associated with the toolbar.
     * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
     */
    onVertexMouseOver(graphic: esri.Graphic, vertexInfo: any): void;
    /** @private */
    _onVertexMouseOverImpl(graphic: esri.Graphic, vertexInfo: any): void;
    /**
     * Fired continuously as the user is moving a vertex (polyline, polygon) or point (multipoint). Applicable only when the EDIT_VERTICES tool is active.
     * @param graphic The graphic associated with the toolbar.
     * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
     * @param transform Represents the linear transformation applied to the graphic.
     */
    onVertexMove(graphic: esri.Graphic, vertexInfo: any, transform: any): void;
    /** @private */
    _onVertexMoveImpl(graphic: esri.Graphic, vertexInfo: any, transform: any): void;
    /**
     * Fired when the mouse button is pressed down on a vertex (polyline, polygon) or point (multipoint). Applicable only when the EDIT_VERTICES tool is active.
     * @param graphic The graphic associated with the toolbar.
     * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
     */
    onVertexMoveStart(graphic: esri.Graphic, vertexInfo: any): void;
    /** @private */
    _onVertexMoveStartImpl(graphic: esri.Graphic, vertexInfo: any): void;
    /**
     * Fired when the mouse button is released from a vertex (polyline, polygon) or point(multipoint). Applicable only when the EDIT_VERTICES tool is active.
     * @param graphic The graphic associated with the toolbar.
     * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
     * @param transform Represents the linear transformation applied to the graphic.
     */
    onVertexMoveStop(graphic: esri.Graphic, vertexInfo: any, transform: any): void;
    /** @private */
    _onVertexMoveStopImpl(graphic: esri.Graphic, vertexInfo: any, transform: any): void;
    /**
     * Internal method that subclasses should override to provide keyboard handling.
     */
    onKeyboardStart(): void;
    /**
     * Internal method that subclasses should override to provide keyboard handling.
     * @param cancelled Whether the operation was cancelled.
     */
    onKeyboardStop(cancelled?: boolean): void;
    /**
     * Provides keyboard handling for the Edit component.
     */
    protected _onKeyDown(event: KeyboardEvent): void;
    protected raiseGraphicEditActivated(eventArgs?: GraphicEditActivatedEventArgs): void;
    protected raiseGraphicEditDeactivated(eventArgs?: GraphicEditDeactivatedEventArgs): void;
    /**
     * Changes the current status message to something like:
     * "Use arrows to move, R to rotate, S to scale, V to select vertex. Combine with ALT for finer control. Combine with SHIFT to reverse."
     * It will also narrate the above text via the ScreenReaderNarrate command.
     * Implementors should override this method if they want to suppress this behavior.
     */
    protected _updateToolStatusMessage(): void;
    protected _clear(): void;
    private _getSymbol(graphic);
    protected _enableMove(graphic: esri.Graphic): boolean;
    protected _enableBoxEditing(graphic: esri.Graphic, scaleEnabled: boolean, rotateEnabled: boolean): boolean;
    protected _enableVertexEditing(graphic: esri.Graphic): boolean;
    /**
     * Contains logic to check if there is a snapping point to replace the moved point.
     * Snapping is difficult with points during keyboard edits as we do not have a vertex handle which is separate from the actual graphic.
     * This handles points when the move is finished and does a last minute geometry swap. If the geometry is swapped before this time,
     * the point can become locked to the same point on the screen.
     * @param editingGraphic The editing graphic.
     * @param overridePoint The point geometry to override.
     */
    protected _adjustGraphicMoverPoint(editingGraphic: esri.Graphic, overridePoint: esri.geometry.Point): void;
    protected _disableMove(): void;
    protected _disableBoxEditing(): void;
    protected _disableVertexEditing(): void;
}

}
declare module "geocortex/infrastructure/accessibility/EditCapability" {
import { EditInterface } from "geocortex/infrastructure/accessibility/EditInterface";
export interface EditCapability {
    owner: EditInterface;
    graphic: esri.Graphic;
    map: esri.Map;
    suspended: boolean;
    destroy(): void;
    refresh(force?: boolean): void;
    suspend(): void;
    resume(): void;
}

}
declare module "geocortex/infrastructure/accessibility/EditCapabilityBase" {
import { EditCapability } from "geocortex/infrastructure/accessibility/EditCapability";
import { EditInterface } from "geocortex/infrastructure/accessibility/EditInterface";
export class EditCapabilityBase implements EditCapability {
    owner: EditInterface;
    graphic: esri.Graphic;
    map: esri.Map;
    suspended: boolean;
    constructor(graphic: esri.Graphic, map: esri.Map, owner: EditInterface);
    destroy(): void;
    refresh(force?: boolean): void;
    suspend(): void;
    resume(): void;
}

}
declare module "geocortex/infrastructure/accessibility/EditInterface" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { ExtendedEditOptions } from "geocortex/infrastructure/accessibility/ExtendedEditOptions";
export interface EditInterface {
    /**
     * The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this instance belongs to.
     */
    app: ViewerApplication;
    /**
     * Refreshes the internal state of the toolbar.
     */
    refresh(): void;
    suspend(): void;
    resume(): void;
    getOptions(): ExtendedEditOptions;
    /**
     * Fired when a graphic is clicked. Applicable only when the MOVE tool is active.
     * @param graphic The clicked graphic.
     * @param info An object with the following properties: `mapPoint`, `screenPoint`
     */
    onGraphicClick(graphic: esri.Graphic, info: {
        mapPoint: esri.geometry.Point;
        screenPoint: esri.geometry.ScreenPoint;
    }): void;
    /**
     * Fired when the user begins to move a graphic. Applicable only when the MOVE tool is active.
     * @param graphic The graphic associated with the toolbar.
     */
    onGraphicFirstMove(graphic: esri.Graphic): void;
    /**
     * Fired continuously as the graphic moves. Applicable only when the MOVE tool is active.
     * @param graphic The graphic associated with the toolbar.
     * @param transform Represents the linear transformation applied to the graphic.
     */
    onGraphicMove(graphic: esri.Graphic, transform: any): void;
    /**
     * Fired when the mouse button is pressed down on the graphic, usually while moving a graphic. Applicable only when the MOVE tool is active.
     * @param graphic The graphic associated with the toolbar.
     */
    onGraphicMoveStart(graphic: esri.Graphic): void;
    /**
     * Fired when the mouse button is released, usually after moving the graphic. Applicable only when the MOVE tool is active.
     * @param graphic The graphic associated with the toolbar.
     * @param transform Represents the linear transformation applied to the graphic.
     */
    onGraphicMoveStop(graphic: esri.Graphic, transform: any): void;
    /**
     * Fired continuously as a graphic is rotated.
     * @param graphic The rotated graphic.
     * @param info The info object has the following properties: `transform`, `angle`, `around`
     */
    onRotate(graphic: esri.Graphic, info: any): void;
    /**
     * Fired when the user begins to drag a handle to rotate the graphic.
     * @param graphic The rotated graphic.
     */
    onRotateFirstMove(graphic: esri.Graphic): void;
    /**
     * Fired when a user clicks on the handle to begin rotating a graphic.
     * @param graphic The rotated graphic.
     */
    onRotateStart(graphic: esri.Graphic): void;
    /**
     * Fired when the mouse button is released from the rotate handle to finish rotating the graphic.
     * @param graphic The rotated graphic.
     * @param info The info object has the following properties: `transform`, `angle`, `around`
     */
    onRotateStop(graphic: esri.Graphic, info: any): void;
    /**
     * Fired continuously as the graphic is being scaled.
     * @param graphic The scaled graphic.
     * @param info The info object has the following properties: `transform`, `scaleX`, `scaleY`, `around`
     */
    onScale(graphic: esri.Graphic, info: any): void;
    /**
     * Fired when the user begins to drag a handle to scale the graphic.
     * @param graphic The scaled graphic.
     */
    onScaleFirstMove(graphic: esri.Graphic): void;
    /**
     * Fired when a user clicks on the handle to scale or resize a graphic.
     * @param graphic The scaled graphic.
     */
    onScaleStart(graphic: esri.Graphic): void;
    /**
     * Fired when the mouse button is released from the scale handle to finish scaling the graphic.
     * @param graphic The scaled graphic.
     * @param info The info object has the following properties: `transform`, `scaleX`, `scaleY`, `around`
     */
    onScaleStop(graphic: esri.Graphic, info: any): void;
    /**
     * Fired after a new vertex is added to a polyline or polygon or a new point is added to a multipoint. Applicable only when the EDIT_VERTICES tool is active.
     * @param graphic The graphic associated with the toolbar.
     * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
     */
    onVertexAdd(graphic: esri.Graphic, vertexInfo: any): void;
    /**
     * Fired when the mouse button is clicked on the vertex of a polyline or polygon or a point in a multipoint. Applicable only when the EDIT_VERTICES tool is active.
     * @param graphic The graphic associated with the toolbar.
     * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
     */
    onVertexClick(graphic: esri.Graphic, vertexInfo: any): void;
    /**
     * Fired after a vertex(polyline, polygon) or point(multipoint) is deleted. Applicable only when the EDIT_VERTICES tool is active.
     * @param graphic The graphic associated with the toolbar.
     * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
     */
    onVertexDelete(graphic: esri.Graphic, vertexInfo: any): void;
    /**
     * Fired when the user begins to move the vertex of a polyline or polygon or a point of a multipoint. Applicable only when the EDIT_VERTICES tool is active.
     * @param graphic The graphic associated with the toolbar.
     * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
     */
    onVertexFirstMove(graphic: esri.Graphic, vertexInfo: any): void;
    /**
     * Fired as the mouse exits a vertex(polyline, polygon) or a point(multipoint). Applicable only when the EDIT_VERTICES tool is active.
     * @param graphic The graphic associated with the toolbar.
     * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
     */
    onVertexMouseOut(graphic: esri.Graphic, vertexInfo: any): void;
    /**
     * Fired when the mouse moves over a vertex (polyline, polygon) or point (multipoint). Applicable only when the EDIT_VERTICES tool is active.
     * @param graphic The graphic associated with the toolbar.
     * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
     */
    onVertexMouseOver(graphic: esri.Graphic, vertexInfo: any): void;
    /**
     * Fired continuously as the user is moving a vertex (polyline, polygon) or point (multipoint). Applicable only when the EDIT_VERTICES tool is active.
     * @param graphic The graphic associated with the toolbar.
     * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
     * @param transform Represents the linear transformation applied to the graphic.
     */
    onVertexMove(graphic: esri.Graphic, vertexInfo: any, transform: any): void;
    /**
     * Fired when the mouse button is pressed down on a vertex (polyline, polygon) or point (multipoint). Applicable only when the EDIT_VERTICES tool is active.
     * @param graphic The graphic associated with the toolbar.
     * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
     */
    onVertexMoveStart(graphic: esri.Graphic, vertexInfo: any): void;
    /**
     * Fired when the mouse button is released from a vertex (polyline, polygon) or point(multipoint). Applicable only when the EDIT_VERTICES tool is active.
     * @param graphic The graphic associated with the toolbar.
     * @param vertexInfo An object with properties: `isGhost`, `pointIndex`, `segmentIndex`
     * @param transform Represents the linear transformation applied to the graphic.
     */
    onVertexMoveStop(graphic: esri.Graphic, vertexInfo: any, transform: any): void;
}

}
declare module "geocortex/infrastructure/accessibility/ExtendedDrawOptions" {
export interface ExtendedDrawOptions extends esri.DrawOptions {
    vertexOffsetX?: number;
    vertexOffsetY?: number;
    preciseVertexOffsetX?: number;
    preciseVertexOffsetY?: number;
    vertexSymbol?: esri.symbol.SimpleMarkerSymbol;
    selectedVertexSymbol?: esri.symbol.SimpleMarkerSymbol;
    enableEditing?: boolean;
}

}
declare module "geocortex/infrastructure/accessibility/ExtendedEditOptions" {
export interface ExtendedEditOptions extends esri.EditOptions {
    narrateKeyboardShortcuts?: boolean;
    rotateHandleOffset?: number;
    boxLineSymbol?: esri.symbol.SimpleLineSymbol;
    boxHandleSymbol?: esri.symbol.SimpleMarkerSymbol;
    textAnchorSymbol?: esri.symbol.SimpleMarkerSymbol;
    selectedVertexSymbol?: esri.symbol.SimpleMarkerSymbol;
}

}
declare module "geocortex/infrastructure/accessibility/GraphicMover" {
import { EditCapabilityBase } from "geocortex/infrastructure/accessibility/EditCapabilityBase";
import { GraphicMoverOptions } from "geocortex/infrastructure/accessibility/GraphicMoverOptions";
import { EditInterface } from "geocortex/infrastructure/accessibility/EditInterface";
import { EditVertexMovedEventArgs } from "geocortex/infrastructure/eventArgs/EditVertexMovedEventArgs";
export class GraphicMover extends EditCapabilityBase {
    private _options;
    private _modified;
    private _isMoving;
    private _transform;
    private _textAnchor;
    /** Keyboard event subscriptions */
    private _keyDownHandle;
    private _keyUpHandle;
    constructor(graphic: esri.Graphic, map: esri.Map, owner: EditInterface, textAnchor?: esri.Graphic, options?: GraphicMoverOptions);
    hasMoved(): boolean;
    destroy(): void;
    refresh(force?: boolean): void;
    protected _needsRefresh(): boolean;
    protected _init(): void;
    protected _cleanUp(): void;
    /**
     * Provides keyboard handling for the GraphicMover component.
     */
    protected _onKeyDownHandler(event: KeyboardEvent): void;
    /**
     * Keyboard event handler
     */
    protected _onKeyUpHandler(event: KeyboardEvent): void;
    protected _moveGraphic(dx: number, dy: number): void;
    protected _raiseEditVertexMoved(eventArgs: EditVertexMovedEventArgs): void;
}

}
declare module "geocortex/infrastructure/accessibility/GraphicMoverOptions" {
export interface GraphicMoverOptions {
    offsetX?: number;
    offsetY?: number;
    preciseOffsetX?: number;
    preciseOffsetY?: number;
}

}
declare module "geocortex/infrastructure/accessibility/InputMethod" {
export class InputMethod {
    static MOUSE: string;
    static KEYBOARD: string;
}

}
declare module "geocortex/infrastructure/accessibility/MapNavigationState" {
export interface MapNavigationState {
    isClickRecenter?: boolean;
    isDoubleClickZoom?: boolean;
    isKeyboardNavigation?: boolean;
    isPan?: boolean;
    isPanArrows?: boolean;
    isRubberBandZoom?: boolean;
    isScrollWheelZoom?: boolean;
    isShiftDoubleClickZoom?: boolean;
    isZoomSlider?: boolean;
}

}
declare module "geocortex/infrastructure/accessibility/MultipointVertexEditor" {
import { VertexEditor } from "geocortex/infrastructure/accessibility/VertexEditor";
export class MultipointVertexEditor extends VertexEditor {
    protected _getSegments(geometry: esri.geometry.Multipoint): esri.geometry.Point[][];
    protected _getMidpointSegments(geometry: esri.geometry.Geometry): esri.geometry.Point[][];
    protected _insertGraphicVertex(vertex: esri.geometry.Point, segmentIndex: number, pointIndex: number): void;
    protected _updateGraphicVertex(vertex: esri.geometry.Point, segmentIndex: number, pointIndex: number): void;
    protected _deleteGraphicVertex(segmentIndex: number, pointIndex: number): void;
}

}
declare module "geocortex/infrastructure/accessibility/PolygonVertexEditor" {
import { VertexEditor } from "geocortex/infrastructure/accessibility/VertexEditor";
export class PolygonVertexEditor extends VertexEditor {
    protected _getSegments(geometry: esri.geometry.Polygon): esri.geometry.Point[][];
    protected _getMidpointSegments(geometry: esri.geometry.Polygon): esri.geometry.Point[][];
    protected _insertGraphicVertex(vertex: esri.geometry.Point, segmentIndex: number, pointIndex: number): void;
    protected _updateGraphicVertex(vertex: esri.geometry.Point, segmentIndex: number, pointIndex: number): void;
    protected _deleteGraphicVertex(segmentIndex: number, pointIndex: number): void;
}

}
declare module "geocortex/infrastructure/accessibility/PolylineVertexEditor" {
import { VertexEditor } from "geocortex/infrastructure/accessibility/VertexEditor";
export class PolylineVertexEditor extends VertexEditor {
    protected _getSegments(geometry: esri.geometry.Polyline): esri.geometry.Point[][];
    protected _getMidpointSegments(geometry: esri.geometry.Polyline): esri.geometry.Point[][];
    protected _insertGraphicVertex(vertex: esri.geometry.Point, segmentIndex: number, pointIndex: number): void;
    protected _updateGraphicVertex(vertex: esri.geometry.Point, segmentIndex: number, pointIndex: number): void;
    protected _deleteGraphicVertex(segmentIndex: number, pointIndex: number): void;
}

}
declare module "geocortex/infrastructure/accessibility/VertexEditor" {
import { EditCapabilityBase } from "geocortex/infrastructure/accessibility/EditCapabilityBase";
import { VertexInfo } from "geocortex/infrastructure/accessibility/VertexInfo";
import { VertexEditorOptions } from "geocortex/infrastructure/accessibility/VertexEditorOptions";
import { EditInterface } from "geocortex/infrastructure/accessibility/EditInterface";
import { SnappingFeedbackEventArgs } from "geocortex/infrastructure/eventArgs/SnappingFeedbackEventArgs";
import { EditVertexMovedEventArgs } from "geocortex/infrastructure/eventArgs/EditVertexMovedEventArgs";
export class VertexEditor extends EditCapabilityBase {
    /** Keyboard event subscriptions */
    private _keyDownHandle;
    private _keyUpHandle;
    /** X-Offset, Y-Offset to apply to vertices being moved  */
    private _keyDx;
    private _keyDy;
    protected _transform: dojox.gfx.matrix.Matrix2D;
    protected _isMoving: boolean;
    protected _isActive: boolean;
    /** Array of vertices managed by this editor */
    protected _vertexControls: VertexInfo[][];
    /** Array of "ghost" vertices managed by this editor. Ghost vertices are located at the midpoint of every segment. */
    protected _midpointControls: VertexInfo[][];
    /** Flattened array of all vertices (real and ghost) in proper order. Used to determine the next and previous vertex to jump to via keyboard */
    protected _allControls: VertexInfo[];
    /** Currently selected/highlighted vertex */
    protected _selectedControl: VertexInfo;
    /** The vertex anchor (red dot) */
    protected _vertexHandleGraphic: esri.Graphic;
    protected _options: VertexEditorOptions;
    protected _snappingInputMovedToken: string;
    /**
     * This method is obsolete. Call ```createVertexEditor``` in ```VertexEditorFactory``` instead.
     */
    static create(graphic: esri.Graphic, map: esri.Map, owner: EditInterface, options?: VertexEditorOptions): VertexEditor;
    constructor(graphic: esri.Graphic, map: esri.Map, owner: EditInterface, options?: VertexEditorOptions);
    protected _handleSnappingInputMovedEvent(args: SnappingFeedbackEventArgs): void;
    isActive(): boolean;
    hideVertexHandle(): void;
    showVertexHandle(): void;
    destroy(): void;
    refresh(force?: boolean): void;
    getSelectedVertex(): VertexInfo;
    /** Updates the position of the currently selected vertex whenever a vertex is added */
    onVertexAdd(vertexInfo: VertexInfo): void;
    /** Updates the position of the currently selected vertex whenever a vertex is deleted */
    onVertexDelete(vertexInfo: VertexInfo): void;
    protected _init(): void;
    protected _cleanUp(): void;
    protected _getSegments(geometry: esri.geometry.Geometry): esri.geometry.Point[][];
    protected _getMidpointSegments(geometry: esri.geometry.Geometry): esri.geometry.Point[][];
    protected _updatePoints(points: VertexInfo[]): void;
    protected _insertGraphicVertex(vertex: esri.geometry.Point, segmentIndex: number, pointIndex: number): void;
    protected _updateGraphicVertex(vertex: esri.geometry.Point, segmentIndex: number, pointIndex: number): void;
    protected _deleteGraphicVertex(segmentIndex: number, pointIndex: number): void;
    protected _findVertex(point: esri.geometry.Point, vertices: VertexInfo[][]): VertexInfo;
    protected _addControllers(): void;
    protected _removeControllers(): void;
    protected _refreshControllers(): void;
    protected _add(segments: esri.geometry.Point[][], isGhost?: boolean): VertexInfo[][];
    protected _remove(vertices: VertexInfo[][]): void;
    protected _refresh(vertices: VertexInfo[][], segments: esri.geometry.Point[][], isGhost?: boolean): void;
    protected _previous(): void;
    protected _next(): void;
    /**
     * Provides keyboard handling for the VertexEditor component.
     * @private
     */
    protected _onKeyDownHandler(event: KeyboardEvent): void;
    protected _onKeyDownWhenActive(event: KeyboardEvent): void;
    protected _move(vertexInfo: VertexInfo, dx: number, dy: number): void;
    protected _raiseEditVertexMoved(eventArgs: EditVertexMovedEventArgs): void;
    protected _moveStop(vertexInfo: VertexInfo, dx: number, dy: number): void;
    protected _delete(vertexInfo: VertexInfo): void;
}

}
declare module "geocortex/infrastructure/accessibility/VertexEditorFactory" {
import { EditInterface } from "geocortex/infrastructure/accessibility/EditInterface";
import { VertexEditorOptions } from "geocortex/infrastructure/accessibility/VertexEditorOptions";
import { VertexEditor } from "geocortex/infrastructure/accessibility/VertexEditor";
/**
 * Creates a new instance of {@link VertexEditor}. For internal use only.
 * @param graphic The graphic to edit.
 * @param map Map the toolbar is associated with.
 * @param owner The Edit toolbar owning this instance.
 * @param options Optional parameters.
 */
export function createVertexEditor(graphic: esri.Graphic, map: esri.Map, owner: EditInterface, options?: VertexEditorOptions): VertexEditor;

}
declare module "geocortex/infrastructure/accessibility/VertexEditorOptions" {
export interface VertexEditorOptions {
    /** Specifies whether users can add new vertices. */
    allowAddVertices?: boolean;
    /** Specifies whether users can delete vertices. */
    allowDeleteVertices?: boolean;
    /**  Marker symbol used to draw the currently selected vertex while in keyboard mode. */
    selectedVertexSymbol?: esri.symbol.MarkerSymbol;
    offsetX?: number;
    offsetY?: number;
    preciseOffsetX?: number;
    preciseOffsetY?: number;
}

}
declare module "geocortex/infrastructure/accessibility/VertexInfo" {
export interface VertexInfo {
    /** Specifies whether the event fired for an existing vertex or a ghost vertex. When true, pointIndex indicates the position the vertex will take when added to the graphic. */
    isGhost: boolean;
    /** Index of the vertex in the segment indicated by segmentIndex. */
    pointIndex: number;
    /** Index of the ring or path that contains the vertex. Always 0 for multipoints. */
    segmentIndex: number;
    /** The vertex location on the map. */
    point?: esri.geometry.Point;
}

}
declare module "geocortex/infrastructure/buffer/BufferArgsBase" {
import { BufferOperationResult } from "geocortex/infrastructure/buffer/BufferOperationResult";
/**
 * The base interface for the "BufferGeometry" and "BufferGeometries" command arguments.
 * Note: Either the bufferDistance/buffeerUnit combination or the sourceCommand must be specified. Explicitly specifying buffer unit/distance will override source.
 */
export interface BufferArgsBase {
    /**
     * The distance to buffer.
     */
    bufferDistance?: number;
    /**
     * The unit to buffer in. Will accept any standard geometry service constant or "feet", "meter", "kilometer", "mile", "nauticalmile" or "yard".
     */
    bufferUnit?: string;
    /**
     * The source command that's calling this buffer request. If source command is specified settings as configured in the buffer module will be used for the buffer
     * operation unless bufferDisance and bufferUnit are explicitly set.
     */
    sourceCommand?: string;
    /**
     * The id for the buffer operation. Can be used to track buffer events and compare them with original requests.
     */
    bufferId?: string;
    /**
     * The spatial reference to buffer in.
     */
    bufferSpatialReference?: esri.SpatialReference;
    /**
     * The spatial reference to return the geometries in.
     */
    outSpatialReference?: esri.SpatialReference;
    /**
     * Whether or not geodesic measurements should be applied for buffering. If the input coordinate system is geographic, this must be set to true.
     */
    geodesic?: boolean;
    /**
     * Whether or not to union the results as a single geometry. Might be multipart.
     */
    unionResults?: boolean;
    /**
     * The callback to fire on successful completion of the buffer operation.
     */
    callback?: (results: BufferOperationResult) => void;
    /**
     * The callback to fire on buffering error.
     */
    errback?: (error: BufferOperationResult) => void;
    /**
     * Write buffer to markup layer for later use
     */
    writeToMarkupLayer?: boolean;
}

}
declare module "geocortex/infrastructure/buffer/BufferDistanceChangedEventArgs" {
import { BufferUnitDesc } from "geocortex/infrastructure/buffer/BufferUnitDesc";
/**
 * Interface for the BufferDistanceChangedEvent event arguments
 */
export interface BufferDistanceChangedEventArgs {
    /**
     * The currently set distance for buffering.
     */
    distance: number;
    /**
     * The currently selected buffering unit description.
     */
    unit: BufferUnitDesc;
    /**
     * The target commands to which these buffer settings will apply.
     */
    targetCommands: string[];
    /**
     * Write buffer to markup layer for later use
     */
    writeToMarkupLayer?: boolean;
}

}
declare module "geocortex/infrastructure/buffer/BufferGeometriesArgs" {
import { BufferArgsBase } from "geocortex/infrastructure/buffer/BufferArgsBase";
/**
 * interface for the BufferGeometriies command argument.
 */
export interface BufferGeometriesArgs extends BufferArgsBase {
    /**
     * The array of input geometries to buffer.
     */
    geometries: esri.geometry.Geometry[];
}

}
declare module "geocortex/infrastructure/buffer/BufferGeometryArgs" {
import { BufferArgsBase } from "geocortex/infrastructure/buffer/BufferArgsBase";
/**
 * Interface for the BufferGeometry command argument.
 */
export interface BufferGeometryArgs extends BufferArgsBase {
    /**
     * The input geometry to buffer.
     */
    geometry: esri.geometry.Geometry;
}

}
declare module "geocortex/infrastructure/buffer/BufferOperationError" {
import { BufferResultBase } from "geocortex/infrastructure/buffer/BufferResultBase";
/**
 * Interface for the error object returned on a buffer operation error.
 */
export interface BufferOperationError extends BufferResultBase {
    /**
     * The javascript error object returned on error.
     */
    error: Error;
}

}
declare module "geocortex/infrastructure/buffer/BufferOperationResult" {
import { BufferResultBase } from "geocortex/infrastructure/buffer/BufferResultBase";
/**
 * Interface for the results returned on a successful buffer operation.
 */
export interface BufferOperationResult extends BufferResultBase {
    /**
     * The buffered geometry returned on successful completion of a BufferGeometry operation.
     */
    geometry?: esri.geometry.Geometry;
    /**
     * The array of buffered geometries returned on successful completion of a BufferGeometries operation.
     */
    geometries?: esri.geometry.Geometry[];
}

}
declare module "geocortex/infrastructure/buffer/BufferResultBase" {
/**
 * Base interface for the results returned on either a succesful or unsuccesful BufferGeometry or BufferGeometries operation.
 */
export interface BufferResultBase {
    /**
     * The buffer id if defined in the BufferGeometry(ies) input argument object.
     */
    bufferId?: string;
    /**
     * The source command, if any, that invoked the buffer operation for which this object represents the result.
     */
    sourceCommand?: string;
}

}
declare module "geocortex/infrastructure/buffer/BufferUnitDesc" {
/**
 * Interface for the buffer unit descriptions used for buffering.
 */
export interface BufferUnitDesc {
    /**
     * The configured display name for this buffer unit.
     */
    displayName: string;
    /**
     * The string representing the configuration for this unit. Currently supported values are "feet", "meter", kilometer", "mile",
     * "nauticalmile" and "yard".
     */
    config: string;
}

}
declare module "geocortex/infrastructure/buffer/BufferUnits" {
import { BufferUnitDesc } from "geocortex/infrastructure/buffer/BufferUnitDesc";
/**
 * Interface representing the currently supported buffer units supported by the buffer module.
 */
export interface BufferUnits {
    /**
     * Unit description for 'Feet".
     */
    feet?: BufferUnitDesc;
    /**
     * Unit description for "Yard".
     */
    yard?: BufferUnitDesc;
    /**
    * Unit description for "Meter".
    */
    meter?: BufferUnitDesc;
    /**
     * Unit description for "Kilometer".
     */
    kilometer?: BufferUnitDesc;
    /**
     * Unit description for "Mile".
     */
    mile?: BufferUnitDesc;
    /**
     * Unit description for "Nautical Mile".
     */
    nauticalmile?: BufferUnitDesc;
}

}
declare module "geocortex/infrastructure/buffer/BufferUtils" {
import { BufferUnits } from "geocortex/infrastructure/buffer/BufferUnits";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { BufferGeometryArgs } from "geocortex/infrastructure/buffer/BufferGeometryArgs";
import { BufferResultBase } from "geocortex/infrastructure/buffer/BufferResultBase";
import { BufferGeometriesArgs } from "geocortex/infrastructure/buffer/BufferGeometriesArgs";
import { BufferUnitDesc } from "geocortex/infrastructure/buffer/BufferUnitDesc";
/**
 * The buffer units that the Buffer Module supports along with their descriptions. This static object will
 * be populated with the configured language resources when the buffer module initializes.
 */
export var SUPPORTED_BUFFER_UNITS: BufferUnits;
/**
 * The geometry service has no inherent support for yards. Defining our own constant here so we can support it.
 */
export var GCX_UNIT_YARDS: number;
/**
 * Buffers a given geometry and returns a promise containing the Buffer Results.
 * @param app The application that's requesting the buffer operation.
 * @param bufferGeometryArgs The {@link infrastructure.buffer.BufferGeometryArgs} object containing the buffer configuration.
 * @returns A Promise returning a {@link infrastructure.buffer.BufferOperationResult} object on success and a {@link infrastructure.buffer.BufferOperationError} object on failure.
 */
export function bufferGeometry(app: ViewerApplication, bufferGeometryArgs: BufferGeometryArgs): Promise<BufferResultBase>;
/**
 * Buffers an array of given geometries and returns a promise containing the Buffer Results. The input geometries need not be of the same type. However, multiple buffer requests may
 * be issued if geometries are of different types.
 * @param app The application that's requesting the buffer operation.
 * @param bufferGeometriesArgs The {@link infrastructure.buffer.BufferGeometriesArgs} object containing the buffer configuration.
 * @returns A Promise returning a {@link infrastructure.buffer.BufferOperationResult} object on success and a {@link infrastructure.buffer.BufferOperationError} object on failure.
 */
export function bufferGeometries(app: ViewerApplication, bufferGeometriesArgs: BufferGeometriesArgs): Promise<BufferResultBase>;
/**
* Buffers an array of given geometries and returns a promise containing the Buffer Results. Note that all input geometries must be of the same type.
* @param app The application that's requesting the buffer operation.
* @param bufferParameters The {@link esri.tasks.BufferParameters} object containing the buffer configuration.
* @returns A Promise returning a {@link infrastructure.buffer.BufferOperationResult} object on success and a {@link infrastructure.buffer.BufferOperationError} object on failure.
*/
export function buffer(app: ViewerApplication, bufferParameters: esri.tasks.BufferParameters): Promise<BufferResultBase>;
/**
 * Checks to see if a given WKID is geographic or not.
 */
export function isGeographicWkid(wkid: string | number): boolean;
/**
* Retrieves the unit description from the configuration string used by the Buffer Module.
* @param config A string containing the configuration value for which the unit description is required. Can be any SUPPORTED_BUFFER_UNITS property value.
* @return A {@link infrastructure.buffer.BufferUnitDesc} object with details about the configured language resources for the config string.
*/
export function getUnitDescFromConfig(config: string): BufferUnitDesc;
/**
* Returns the type of ESRI Geometry Service unit constant. Works for standard abbreviations, display text and esri.Unit constants. Will also work to convert between
* string representations of esri's geometry service unit constants and the constants themselves.
* @param typeName
* @param defaultType
* @return esri.tasks.GeometryService unit constant
*/
export function getGeometryServiceUnitConstant(typeName: string, defaultUnit?: any): any;
export function convertLength(length: number, fromUnit: number, toUnit: number): number;

}
declare module "geocortex/infrastructure/buffer/DisplayBufferOptionsArgs" {
import { BufferDistanceChangedEventArgs } from "geocortex/infrastructure/buffer/BufferDistanceChangedEventArgs";
/**
 * Interface for the arguments passed to the DisplayBufferOptions command. The command can also take in a simple string specifying the target command.
 */
export interface DisplayBufferOptionsArgs {
    /**
     * The target command for which the buffer options display is requested.
     */
    targetCommand: string;
    /**
     * The delegate function, if any, that executes when the user hits the continue button on the DisplayBufferOptions dialog
     */
    delegateFunction?: (args?: BufferDistanceChangedEventArgs) => void;
}

}
declare module "geocortex/infrastructure/clickableGraphics/ClickableGraphicsRegistry" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { ClickableLayerInfo } from "geocortex/infrastructure/clickableGraphics/ClickableLayerInfo";
import { ClickableOptions } from "geocortex/infrastructure/clickableGraphics/ClickableOptions";
/**
 * Central management component for creating and accessing clickable graphics from any module across the viewer.
 */
export class ClickableGraphicsRegistry {
    /**
     * The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this clickable graphics registry belongs to.
     */
    app: ViewerApplication;
    private _clickableGraphicLayers;
    private _defaultCallback(graphic);
    private _defaultOptions;
    /**
     * Initializes a new instance of the ClickableGraphicsRegistry class.
     * @param app The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this instance belongs to.
     */
    constructor(app: ViewerApplication);
    /**
     * Registers a graphic layer.
     * @param graphicsLayer The graphic layer to register.
     * @param options An optional ClickableOptions pertaining to clickable graphics layer.
     */
    register(graphicsLayer: esri.layers.GraphicsLayer, options?: ClickableOptions): void;
    /**
    * Unregisters a graphic layer.
    * @param graphicsLayer The graphic layer to unregister.
    */
    unregister(graphicsLayer: esri.layers.GraphicsLayer): void;
    /**
     * Returns ClickableLayerInfo.
     * @param graphicsLayer The graphic layer to unregister.
     * @returns ClickableLayerInfo which Contains information about clickable layer in a map
     */
    getLayerInfo(graphicsLayer: esri.layers.GraphicsLayer): ClickableLayerInfo;
    /**
     * Returns an array of ClickableLayerInfos.
     * @returns array of ClickableLayerInfos which Contains information about clickable layer in a map.
     */
    getLayerInfos(): ClickableLayerInfo[];
    /**
     * Unregisters all clickable graphic layers registered in the registry.
     */
    clear(): void;
    /**
     * Checks if a given esri graphic layer is registered to be clickable.
     * @returns boolean.
     */
    isLayerRegistered(graphicsLayer: esri.layers.GraphicsLayer): boolean;
    /** Releases resources when the instance is no longer needed.  */
    private _disposeLayerInfoObject(layerInfo);
    private _handleLayerRemoved(layer);
}

}
declare module "geocortex/infrastructure/clickableGraphics/ClickableLayerInfo" {
/**
 * Contains information about clickable layer in a map
 */
export interface ClickableLayerInfo {
    graphicsLayerId: string;
    displayName: string;
    autoEditable: boolean;
    aliases?: {
        [attribute: string]: string;
    };
    canEdit?(graphic: esri.Graphic): boolean;
    canDelete?(graphic: esri.Graphic): boolean;
    canChangeStyles?(graphic: esri.Graphic): boolean;
}

}
declare module "geocortex/infrastructure/clickableGraphics/ClickableOptions" {
/**
 * Clickable options pertaining to clickable graphics layer.
 * @private
 */
export interface ClickableOptions {
    displayName: string;
    autoEditable: boolean;
    aliases?: {
        [attribute: string]: string;
    };
    canEdit?(graphic: esri.Graphic): boolean;
    canDelete?(graphic: esri.Graphic): boolean;
    canChangeStyles?(graphic: esri.Graphic): boolean;
}

}
declare module "geocortex/infrastructure/collaboration/GroupedMarkupFeatures" {
export interface GroupedMarkupFeatures {
    /** A JSON FeatureSet containing Point features. */
    points?: any;
    /** A JSON FeatureSet containing Polyline features. */
    polylines?: any;
    /** A JSON FeatureSet containing Polygon features. */
    polygons?: any;
    /** A JSON FeatureSet containing Rectangle features. */
    rectangles?: any;
}

}
declare module "geocortex/infrastructure/collaboration/ICollaborationEventViewModel" {
import { ViewModelBase } from "geocortex/framework/ui/ViewModelBase";
import { RestRoom } from "geocortex/infrastructure/collaboration/RestRoom";
import { RestEvent } from "geocortex/infrastructure/collaboration/RestEvent";
export interface ICollaborationEventViewModel extends ViewModelBase {
    /** The RestEvent which this viewmodel is for. */
    event: RestEvent;
    /** The RestRoom which this viewmodel belongs to. */
    room: RestRoom;
    /** The action which happens when the event is clicked. */
    onClick(): void;
    /** The action which happens when the event is loaded. */
    loadEvent(): void;
    /** The action which happens when the event is unloaded. */
    unloadEvent(): void;
}

}
declare module "geocortex/infrastructure/collaboration/ICollaborationHandler" {
import { RestRoom } from "geocortex/infrastructure/collaboration/RestRoom";
import { RestEvent } from "geocortex/infrastructure/collaboration/RestEvent";
import { RestRoomRequestArgs } from "geocortex/infrastructure/collaboration/RestRoomRequestArgs";
import { QueryResponse } from "geocortex/infrastructure/collaboration/QueryResponse";
import { QueryOptions } from "geocortex/infrastructure/collaboration/QueryOptions";
import { RestEventRequestArgs } from "geocortex/infrastructure/collaboration/RestEventRequestArgs";
import { RoomQueryOptions } from "geocortex/infrastructure/collaboration/RoomQueryOptions";
export interface ICollaborationHandler {
    getRooms(queryOptions: RoomQueryOptions): Promise<RestRoom[]>;
    createRoom(room: RestRoomRequestArgs): Promise<RestRoom>;
    editRoom(id: string, room: RestRoomRequestArgs): Promise<RestRoom>;
    query(queryOptions: QueryOptions): Promise<QueryResponse>;
    addEvent(event: RestEventRequestArgs): Promise<RestEvent>;
    joinRoom(roomId: string): Promise<RestRoom>;
    leaveRoom(roomId: string): Promise<RestRoom>;
    copyEvent(eventId: string, roomId: string): Promise<RestEvent>;
    editEvent(id: string, event: RestEventRequestArgs): Promise<RestEvent>;
    getEvent(id: string): Promise<RestEvent>;
    checkRoomNameUnique(name: string, appId: string): Promise<{
        roomName: string;
        unique: boolean;
    }>;
    getLatestState(queryOptions: QueryOptions): Promise<QueryResponse>;
    pushRoom(sourceRoom: string, destinationRoom: string, queryOptions: QueryOptions): Promise<boolean>;
}

}
declare module "geocortex/infrastructure/collaboration/ImageRestEvent" {
import { MessageRestEvent } from "geocortex/infrastructure/collaboration/MessageRestEvent";
export interface ImageRestEvent extends MessageRestEvent {
    data: {
        location: any;
        message: string;
    };
}

}
declare module "geocortex/infrastructure/collaboration/MessageRestEvent" {
import { RestEvent } from "geocortex/infrastructure/collaboration/RestEvent";
export interface MessageRestEvent extends RestEvent {
    data: {
        message: string;
    };
}

}
declare module "geocortex/infrastructure/collaboration/QueryOptions" {
/** Defines the structure for options which can be sent to Collaboration query endpoints. */
export interface QueryOptions {
    /** An array of Room ids to fetch events for. */
    rooms: string[];
    /** The number of events to return. */
    pageSize?: number;
    /** Return events which occured before this Id. */
    getBeforeId?: string;
    /** Return events which occured after this Id. */
    getAfterId?: string;
    /** Return events matching the following event type. */
    eventTypes?: string[];
    /** Return data for active rooms only. */
    activeRoomsOnly?: boolean;
    /** Filter results by Data range. */
    dateRange?: {
        /** Start date. */
        start: Date;
        /** End date. */
        end: Date;
    };
}

}
declare module "geocortex/infrastructure/collaboration/QueryResponse" {
import { RestEvent } from "geocortex/infrastructure/collaboration/RestEvent";
/** Describes the object which is returned from Collaboration query endpoints. */
export interface QueryResponse {
    /** An array of returned RestEvents. */
    events: RestEvent[];
    /** The count of returned RestEvents. */
    resultCount: number;
}

}
declare module "geocortex/infrastructure/collaboration/RestEvent" {
/**
 * Represents an object retrieved from the Collaboration services which is an Event.
 */
export interface RestEvent {
    /** The type of the event. */
    type: string;
    /** The Room Id that the event belongs to. */
    roomId: string;
    /** The Id of the event. */
    id: string;
    /** A JSON data payload. */
    data: any;
    /** The created date. */
    created: string;
    /** The creator. */
    createdBy: string;
    /** Whether the current user owns the event **/
    isOwner: boolean;
    /** The ID of an attached document. */
    attachmentId?: string;
    /**
     * If the event was copied or modified from another event.
     * Used for chaining and finding latest Room state.
     */
    sourceEvent?: string;
}

}
declare module "geocortex/infrastructure/collaboration/RestEventRequestArgs" {
export interface RestEventRequestArgs {
    type: string;
    roomId: string;
    attachmentId?: string;
    data: any;
}

}
declare module "geocortex/infrastructure/collaboration/RestRoom" {
/**
 * Represents an object retrieved from the Collaboration services which is a Room.
 */
export interface RestRoom {
    /** The Id of the Room. */
    id: string;
    /** The display name. */
    displayName: string;
    /** The active state of the Room. */
    active: boolean;
    global?: boolean;
    isOwner?: boolean;
    isContributor?: boolean;
    color?: string;
    created: string;
    createdBy: string;
}

}
declare module "geocortex/infrastructure/collaboration/RestRoomRequestArgs" {
export interface RestRoomRequestArgs {
    displayName: string;
    active: boolean;
    color?: string;
    applicationId?: string;
}

}
declare module "geocortex/infrastructure/collaboration/RoomQueryOptions" {
export interface RoomQueryOptions {
    applicationId: string;
    activeRoomsOnly?: boolean;
}

}
declare module "geocortex/infrastructure/collaboration/ShareMarkupRestEvent" {
import { MessageRestEvent } from "geocortex/infrastructure/collaboration/MessageRestEvent";
import { GroupedMarkupFeatures } from "geocortex/infrastructure/collaboration/GroupedMarkupFeatures";
export interface ShareMarkupRestEvent extends MessageRestEvent {
    data: {
        /** An object containing FeatureSet JSON. */
        markup: GroupedMarkupFeatures;
        message: string;
    };
}

}
declare module "geocortex/infrastructure/commandArgs/AddStatusArgs" {
import { ImageProperties } from "geocortex/infrastructure/commandArgs/ImageProperties";
export class AddStatusArgs {
    /**
     * The message text to display.
     * @type String
     */
    text: string;
    /**
     * The title to display on the close button.
     */
    closeTitle?: string;
    /**
     * The uri and/or class of the status image, and the mandatory alt text
     * @type ImageProperties
     */
    imageProperties?: ImageProperties;
    /**
     * A callback function to invoke when the status message is dismissed by the user.
     * @type Function
     */
    userClosedCallback?: () => void;
    /**
     * The css class name to apply to the status message.
     * @type String
     */
    statusClass?: string;
    /**
     * The ID of the status message. You can use this ID later on for the "PulseStatus" command and the "RemoveStatus" command.
     * If you do not supply a value, an ID will be created and assigned to id property so that you can use it later on.
     * @type String
     */
    id?: string;
    /**
     * The timeout in milliseconds after which time the status message will go away.  A value of 0 or less than 0 means never time out.
     * @type Number
     */
    timeoutMS?: number;
    /**
     * If set to true, then a busy icon will be used - likely an animation to shown activity.
     * @type Boolean
     */
    showBusyIcon?: boolean;
    /**
     * Optional region where status messages are to be shown. If specified, the status messages will be created and activated in this region.
     */
    regionName?: string;
    /**
     * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.commandArgs.AddStatusArgs} class.

     * @param text The message text to display.
     * @param imageProperties The URI or class of the image icon to show beside the text and the alt text.
     * @param userClosedCallback A callback function to invoke when the status message is dismissed by the user.
     * @param id The ID of the status message. You can use this ID later on for the "PulseStatus" command and the "RemoveStatus" command.
     *        If you do not supply a value, an ID will be created and assigned to id property so that you can use it later on.
     * @param timeoutMS The timeout in milliseconds after which time the status message will go away.  A value of 0 or less than 0 means never time out.
     * @param showBusyIcon If set to true, then a busy icon will be used - likely an animation to shown activity.
     */
    constructor(text: string, imageProperties?: ImageProperties, userClosedCallback?: () => void, id?: string, timeoutMS?: number, showBusyIcon?: boolean);
}

}
declare module "geocortex/infrastructure/commandArgs/ClusterLayerArgs" {
import { Layer } from "geocortex/essentials/Layer";
export class ClusterLayerArgs {
    /** The Geocortex Layer that the ClusterLayer is going to be based off of. */
    gcxLayer: Layer;
}

}
declare module "geocortex/infrastructure/commandArgs/CombineResultsArgs" {
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
import { CombineResultsResponse } from "geocortex/infrastructure/selection/CombineResultsResponse";
export interface CombineResultsArgs {
    /** Describes how the specified features should be combined with existing features in the collection of results. Valid values are: `replace`, `union`, `intersect`, `subtract` */
    combineMode: string;
    /** Array of IDs corresponding to the FeatureSetCollections to operate against the current set of results in the results view */
    featureSetCollectionIds: string[];
    currentResults?: FeatureSetCollection | string;
    /** A callback to execute upon successfully modifying the FeatureSetCollections. */
    successCallback?: (info: CombineResultsResponse) => void;
    /** A callback to execute when there is an error modifying the FeatureSetCollections. */
    errorCallback?: (error: Error) => void;
}

}
declare module "geocortex/infrastructure/commandArgs/ConfirmOptionArgs" {
/**
 * Specifies additional options that can be passed in to the Confirm command.
 */
export interface ConfirmOptionsArgs {
    /**
     * Custom text to display for the "OK" button (default is the value of the language resource "language-common-ok").
     */
    okLabel?: string;
    /**
     * Custom text to display for the "Cancel" button (default is the value of the language resource "language-common-cancel").
     */
    cancelLabel?: string;
    /**
     * Boolean indicating if this view is sticky. Works for only MultiViewRegionAdapter.
     * If a view is marked as sticky, view activations in that MultiViewRegionAdapter will be blocked until the sticky view is deactivated.
     * Also, deactivation of PopupModalRegionAdapter through CloseModalRegion command will be blocked until that sticky view is deactivated.
    */
    sticky?: boolean;
}

}
declare module "geocortex/infrastructure/commandArgs/ContextMenuArgs" {
export interface ContextMenuArgs {
    /**
     * The absolute X position in pixels of where to position the context menu in respect to the page
     */
    pageX: number;
    /**
     * The absolute Y position in pixels of where to position the context menu in respect to the page
     */
    pageY: number;
    /**
     * The view id to activate that is hosted in the ContextMenuContentRegion
     */
    viewId?: string;
}

}
declare module "geocortex/infrastructure/commandArgs/CreateOrEditFeatureFromBarcodeScanArgs" {
/**
 * Options for the `CreateOrEditFeatureFromBarcodeScan` command.
 */
export interface CreateOrEditFeatureFromBarcodeScanArgs {
    /** The ID of the feature map service on which to place a new feature or find an existing one. */
    featureServiceId: string;
    /** The field name to set (when creating a feature) or search for (when looking to edit an existing feature). */
    scanResultFieldName: string;
}

}
declare module "geocortex/infrastructure/commandArgs/CutGraphicsArgs" {
import { EditInMemoryArgs } from "geocortex/infrastructure/commandArgs/EditInMemoryArgs";
/**
 * Describes the arguments for cutting graphics in memory.
 */
export interface CutGraphicsArgs extends EditInMemoryArgs {
    /**
     * The polyline used to cut the graphics.
     */
    polyline?: esri.geometry.Polyline;
}

}
declare module "geocortex/infrastructure/commandArgs/DeleteAttachmentsArgs" {
export interface DeleteAttachmentsArgs {
    feature: esri.Graphic;
    layer: esri.layers.FeatureLayer;
    attachmentIds: number[];
    callback: (result: any) => void;
    errback: (error: any) => void;
}

}
declare module "geocortex/infrastructure/commandArgs/DisplayNotificationArgs" {
import { ImageProperties } from "geocortex/infrastructure/commandArgs/ImageProperties";
/**
 * Describes the arguments for the AddNotification command.
 */
export interface DisplayNotificationArgs {
    /**
     * Id of this notification
     * @type string
     */
    id: string;
    /**
     * The notification text to display
     * @type String
     */
    text: string;
    /**
     * The icon information (uri, class, and alt text)
     * @type ImageProperties
     */
    iconProperties?: ImageProperties;
    /**
     * Collection of buttons on the notification
     * @type Collection
     */
    buttons?: NotificationActionButton[];
    /**
     * Optional region where notifications are to be shown. If specified, the notification will be created and activated in this region.
     * @type String
     */
    regionName?: string;
    /**
     * Optional button for removing the notification display
     * @type NotificationActionButton
     */
    closeButton?: NotificationActionButton;
}
export interface NotificationActionButton {
    text?: string;
    callback?: () => void;
}

}
declare module "geocortex/infrastructure/commandArgs/DownloadOfflineResourcesArgs" {
/**
 * Describes the arguments for the DownloadOfflineResources command.
 */
export interface DownloadOfflineResourcesArgs {
    /**
     * The ID to give to the offline resources downloaded.
     */
    id: string;
    /**
     * An optional callback for success.
     */
    successCallback?: () => void;
    /**
     * An optional callback on error.
     * @param error The error of the operation.
     */
    errorCallback?: (error: Error) => void;
    /**
     * Whether to activate the offline resources immediately upon completion.
     * Default is false.  Errors from activation will go to the errorCallback
     * if it is defined.
     */
    activateOnSuccess?: boolean;
}

}
declare module "geocortex/infrastructure/commandArgs/EditAttachmentArgs" {
export interface EditAttachmentArgs {
    feature: esri.Graphic;
    layer: esri.layers.FeatureLayer;
    featureUrl: string;
    filename: string;
    contentType: string;
    payload: string;
    callback: (result: any) => void;
}

}
declare module "geocortex/infrastructure/commandArgs/EditFeatureArgs" {
import { MapService } from "geocortex/essentials/MapService";
export interface EditFeatureArgs {
    mapService: MapService | string;
    layer: esri.layers.FeatureLayer;
    feature: esri.Graphic;
    successCallback?: (graphic?: esri.Graphic) => void;
    errorCallback?: (error: Error) => void;
}

}
declare module "geocortex/infrastructure/commandArgs/EditInMemoryArgs" {
/**
 * Describes the arguments for commands that edit graphics in memory.
 */
export interface EditInMemoryArgs {
    /**
     * The graphics to edit.
     */
    graphics: esri.Graphic[];
    /**
     * The graphics layer to edit the graphics on.
     */
    graphicsLayer: esri.layers.GraphicsLayer;
    /**
     * A callback to execute upon successfully editing the graphics. Can be used to update attributes for edited graphics. The edits
     * will not be added to the undo manager until this callback has been resolved.
     */
    successCallback?: (addedGraphics: esri.Graphic[], updatedGraphics: esri.Graphic[], deletedGraphics: esri.Graphic[]) => Promise<void>;
    /**
     * A callback to execute when there is an error editing the graphics.
     */
    errorCallback?: (error: Error) => void;
}

}
declare module "geocortex/infrastructure/commandArgs/EditRelatedRecordArgs" {
import { EditFeatureArgs } from "geocortex/infrastructure/commandArgs/EditFeatureArgs";
export interface EditRelatedRecordArgs extends EditFeatureArgs {
    relatedFeature?: esri.Graphic;
    relationshipOrigin?: esri.layers.Relationship;
    relationshipDestination?: esri.layers.Relationship;
}

}
declare module "geocortex/infrastructure/commandArgs/ExportGraphicsLayerArgs" {
export interface ExportGraphicsLayerArgs {
    /** The Graphics Layer to be exported. */
    graphicLayer: esri.layers.GraphicsLayer;
    /** The format for exporting the graphics layer. */
    format: string;
}

}
declare module "geocortex/infrastructure/commandArgs/FindAllSelectionMetadataArgs" {
import { SelectionMetadata } from "geocortex/infrastructure/selection/SelectionMetadata";
export interface FindAllSelectionMetadataArgs {
    /** A callback to execute upon success. */
    successCallback?: (results: SelectionMetadata[]) => void;
    /** A callback to execute when there is an error. */
    errorCallback?: (error: Error) => void;
}

}
declare module "geocortex/infrastructure/commandArgs/FindMetadataForSelectionArgs" {
import { SelectionMetadata } from "geocortex/infrastructure/selection/SelectionMetadata";
export interface FindMetadataForSelectionArgs {
    /** The name of the selection. */
    name?: string;
    /** The feature set collection ID */
    featureSetCollectionId?: string;
    /** A callback to execute upon success. */
    successCallback?: (metadata: SelectionMetadata) => void;
    /** A callback to execute when there is an error. */
    errorCallback?: (error: Error) => void;
}

}
declare module "geocortex/infrastructure/commandArgs/FindSelectionArgs" {
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
export interface FindSelectionArgs {
    /** The name of the selection. */
    name: string;
    /** A callback to execute upon success. */
    successCallback?: (results: FeatureSetCollection) => void;
    /** A callback to execute when there is an error. */
    errorCallback?: (error: Error) => void;
}

}
declare module "geocortex/infrastructure/commandArgs/GeolocateArgs" {
/**
 * Options that are relevant to a single-point geolocation (Find Me).
 */
export interface SingleGeolocationProfile {
    accuracyThreshold?: number;
    timeLimit?: number;
}
/**
 * Arguments for the `Geolocate` command.
 */
export interface GeolocateArgs extends SingleGeolocationProfile {
    /** The name of the singleGeolocationProfile to use. */
    profile?: string;
    /** If true, the geolocate command will tolerate an active tool. If false, the active tool will be cleared away. Defaults to false. */
    toolFriendly?: boolean;
}

}
declare module "geocortex/infrastructure/commandArgs/HeatMapArgs" {
import { Layer } from "geocortex/essentials/Layer";
export interface HeatMapArgs {
    /** The Geocortex Layer to visualize with a heat map. */
    gcxLayer: Layer;
    /** Whether or not the visualization is being applied on application startup. */
    onStartUp?: boolean;
}

}
declare module "geocortex/infrastructure/commandArgs/HighlightFeatureArgs" {
import { Feature } from "geocortex/infrastructure/Feature";
export interface HighlightFeatureArgs {
    feature: esri.Graphic | Feature | Feature[];
    layer: string;
}

}
declare module "geocortex/infrastructure/commandArgs/IdentifyArgs" {
import { Layer } from "geocortex/essentials/Layer";
import { IdentifiableLayerInfo } from "geocortex/infrastructure/identify/IdentifiableLayerInfo";
export interface IdentifyArgs {
    geometry: esri.geometry.Geometry;
    source: string;
    extent?: esri.geometry.Extent;
    width?: number;
    height?: number;
    pixelTolerance?: number;
    polygonPixelTolerance?: number;
    topMostLayerOnly?: boolean;
    visibleLayersOnly?: boolean;
    visibleMapServicesOnly?: boolean;
    layersInVisibleScaleRangeOnly?: boolean;
    returnGeometry?: boolean;
    delayFSCOpen?: boolean;
    layerRestriction?: (layer: Layer) => boolean;
    doNotBuffer?: boolean;
    identifiableLayerInfo?: IdentifiableLayerInfo[];
    restrictRasterIdentifyToPoint?: boolean;
    /** See geocortex/infrastructure/selection/CombineMode for values */
    combineMode?: string;
}

}
declare module "geocortex/infrastructure/commandArgs/ImageProperties" {
export interface ImageProperties {
    uri?: string;
    class?: string;
    altText: string;
}

}
declare module "geocortex/infrastructure/commandArgs/MarkerArgs" {
/**
 * Describes the arguments for a marker.
 */
export interface MarkerArgs {
    /** The ID of the marker. */
    id: string;
    /** The symbol json object to represent the marker. Object syntax can be found at http://help.arcgis.com/en/arcgisserver/10.0/apis/rest/symbol.html. */
    symbolJson?: Object;
    /** The uri of the icon used to represent the marker. If a symbol json is also supplised the symbol will be preferred. */
    iconUri?: string;
    /** The width of the marker icon. Required if 'iconUri' is given. */
    iconWidth?: number;
    /** The height of the marker icon. Required if 'iconUri' is given. */
    iconHeight?: number;
    /** The geometry of the marker. */
    geometry?: esri.geometry.Geometry;
    /** The center point of the marker. If a geometry is also supplied the geometry will be preferred. */
    center?: esri.geometry.Point;
    /** The angle of the marker. */
    angle?: number;
    /** Whether or not the marker is visible. */
    visible?: boolean;
    /** Whether or not the marker is draggable. */
    draggable?: boolean;
    /** The ID of the marker graphics layer */
    graphicsLayerId?: string;
}

}
declare module "geocortex/infrastructure/commandArgs/ProjectArgs" {
export class ProjectArgs {
    /**
     * The spatial reference of the output object.
     * @type SpatialReference
     */
    outputSpatialReference: esri.SpatialReference;
    /**
    * The array of geometries that need to be projected.
    * @type Geometry[]
    */
    geometries: esri.geometry.Geometry[];
    /**
     * The well-known id {wkid:number} or well-known text {wkt:string} or for the datum transformation to be applied on the projected geometries.
     * If a transformation is specified a value must also be specified for the transformForward property.
     * If a transformation is not specified, a default GeoTransformation is used.
     * @type Object
     */
    transformation: {
        wkid?: number;
        wkt?: string;
    };
    /**
     * The function to call when the method has completed. The arguments in the function are the same as the onProjectComplete event.
     * @type Function
     */
    callback: (geometries: esri.geometry.Geometry[]) => void;
    /**
     * An error object is returned if an error occurs on the Server during task execution.
     * @type Function
     */
    errback: (error: Error) => void;
    /**
      * Initializes a new instance of the {@link ProjectArgs} class.
      * @param geometries The geometries.
      * @param outputSpatialReference The Spatial Reference for the output.
      * @param callback The success handler.
      * @param errback The error handler.
      * @param transformation The optional transformation.
      */
    constructor(geometries: esri.geometry.Geometry[], callback: (geometries: esri.geometry.Geometry[]) => void, errback: (error: Error) => void, outputSpatialReference?: esri.SpatialReference, transformation?: {
        wkid?: number;
        wkt?: string;
    });
}

}
declare module "geocortex/infrastructure/commandArgs/PushpinArgs" {
import { Feature } from "geocortex/infrastructure/Feature";
export interface PushpinArgs {
    feature: Feature;
    tag: string;
}
export function isPushpinArgs(a: any): a is PushpinArgs;

}
declare module "geocortex/infrastructure/commandArgs/RenameSelectionArgs" {
import { SelectionArgs } from "geocortex/infrastructure/commandArgs/SelectionArgs";
export interface RenameSelectionArgs extends SelectionArgs {
    /** The new name to use for the selection. */
    newName: string;
}

}
declare module "geocortex/infrastructure/commandArgs/RunReportArgs" {
import { Report } from "geocortex/essentials/Report";
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
import { FeatureSet } from "geocortex/infrastructure/FeatureSet";
import { Feature } from "geocortex/infrastructure/Feature";
import { ReportParameters } from "geocortex/essentials/ReportParameters";
/**
 * Arguments for the `RunReport` command.
 */
export interface RunReportArgs {
    /** The report to run. */
    report: Report;
    /** The group of features that the report shall be run upon. */
    reportable: FeatureSetCollection | FeatureSet | Feature | Feature[];
    /** ReportParameters passed along to the REST endpoint. FYI: If this is provided, the `RunReport` command implementation will impose some forced and default values overwriting onto its properties. */
    reportParameters?: ReportParameters;
}

}
declare module "geocortex/infrastructure/commandArgs/SelectionArgs" {
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
export interface SelectionArgs {
    /** The name of the selection. */
    name: string;
    /** The {@link FeatureSetCollection} backing the results to save, modify or delete. */
    featureSetCollection?: FeatureSetCollection | string;
    /** A callback to execute upon success. */
    successCallback?: () => void;
    /** A callback to execute when there is an error. */
    errorCallback?: (error: Error) => void;
}

}
declare module "geocortex/infrastructure/commandArgs/ShowMapElementArgs" {
import { ViewBase } from "geocortex/framework/ui/ViewBase";
export class ShowMapElementArgs {
    /**
     * The caller assigned ID of the map element to show.  New map elements will be created for each
     * unique ID, so if you want to replace the contents of a map element, then use the ID of that element.
     * If you want to create a new map element, then use a new unique ID here.
     * @type String
     * @ignore
     */
    elementID: string;
    /**
     * The ESRI map point to show the content at.
     * @type esri.geometry.Point
     * @ignore
     */
    mapPoint: esri.geometry.Point;
    /**
     * The content to show on the map.  This can be be either an HTML Element, a String containing any valid HTML,
     * or a geocortex.framework.ui.ViewBase.
     * @type Object
     * @ignore
     */
    content: HTMLElement | ViewBase | string;
    /**
     * The title to show, if displaying in a map callout. This can either be a string, or a geocortex.framework.ui.ViewBase.
     * The title may also come from the geocortex.framework.ui.ViewBase specified for "content".
     * If this property is specified, it will take precedence.
     * @type Object
     * @ignore
     */
    title: HTMLElement | ViewBase | string;
    /**
     * Whether to destroy the child content view when this view is destroyed.  Leave this false if the view is going
     * to be reused (for instance as part of a module).  Set this to true if the view was created manually
     * with ViewManeger.createView() and then forgotten about.
     */
    destroyContentView: boolean;
    /** @private */
    delay: number;
    /**
     * Initializes a new instance of the {@link ShowMapElementArgs} class.
     * `ShowMapElementArgs` defines the arguments passed to a command relating to a showing an HTML view or element on the map.
     * This class can be used for showing content in a map tip, or for attaching arbitrary HTML content to the map.
     * The content property may be any of the following types:
     * - An HTML DOM Element.
     * - A framework view, inheriting from {@link framework.ui.ViewBase}.
     * - An HTML content string.
     * @param elementId The ID to use when referring to the newly created element, e.g. when updating or removing it.
     * @param mapPoint The point (in map space) to anchor the element to.
     * @param content Arbitrary content to display in the map element.
     * @param title Title of the element.
     */
    constructor(elementId: string, mapPoint?: esri.geometry.Point, content?: any, title?: any);
    /**
     * Gets the HTML element node, based on the content property.
     */
    getNode(): HTMLElement;
    /**
     * Gets the HTML element node, based on the title property.
     */
    getTitleNode(): HTMLElement;
    /**
     * Determines if the content property is a {@link geocortex.framework.ui.ViewBase}.
     */
    contentIsView(): boolean;
    /**
     * Determines if the title property is a {@link geocortex.framework.ui.ViewBase}.
     */
    titleIsView(): boolean;
}

}
declare module "geocortex/infrastructure/commandArgs/ShowOfflineProfileEditorArgs" {
import { OfflineMap } from "geocortex/infrastructure/offline/OfflineMap";
/**
 * Argument of the ShowOfflineMapEditor command.
 */
export interface ShowOfflineMapEditorArgs {
    /**
     * Optional existing OfflineMap to prepopulate the fields with.
     */
    existingOfflineMap?: OfflineMap;
}

}
declare module "geocortex/infrastructure/commandArgs/TapToDismissArgs" {
import { ViewBase } from "geocortex/framework/ui/ViewBase";
export interface TapToDismissArgs {
    view: ViewBase;
    onOtherInteracted?: (evt?: Event) => void;
    onElementInteracted?: (evt?: Event) => void;
}

}
declare module "geocortex/infrastructure/commandArgs/UpdateGraphicsArgs" {
import { EditInMemoryArgs } from "geocortex/infrastructure/commandArgs/EditInMemoryArgs";
/**
 * Describes the arguments for updating graphics in memory.
 */
export interface UpdateGraphicsArgs extends EditInMemoryArgs {
    /**
     * The geometries used to update the graphics. You must have the same number of geometries as graphics.
     */
    geometries?: esri.geometry.Geometry[];
}

}
declare module "geocortex/infrastructure/commandArgs/UpdateMetadataForSelectionArgs" {
import { SelectionMetadata } from "geocortex/infrastructure/selection/SelectionMetadata";
export interface UpdateMetadataForSelectionArgs {
    /** The metadata to set. */
    metadata: SelectionMetadata;
    /** A callback to execute upon success. */
    successCallback?: () => void;
    /** A callback to execute when there is an error. */
    errorCallback?: (error: Error) => void;
}

}
declare module "geocortex/infrastructure/commandArgs/VisualizationArgs" {
import { Layer } from "geocortex/essentials/Layer";
export interface VisualizationArgs {
    /** The Geocortex Layer to remove visualizations from. */
    gcxLayer: Layer;
}

}
declare module "geocortex/infrastructure/coordinates/AngleDirectionSystem" {
/**
* Polar coordinates. 0 degrees points East, angles are measured counter-clockwise.
*/
export const POLAR: string;
/**
* North azimuth. 0 degrees points North, angles are measured clockwise.
*/
export const NORTH_AZIMUTH: string;
/**
* South azimuth. 0 degrees points South, angles are measured clockwise.
*/
export const SOUTH_AZIMUTH: string;

}
declare module "geocortex/infrastructure/coordinates/AngleFormat" {
/**
* Decimal degrees.
*/
export const DD: string;
/**
* Whole degrees with decimal minutes.
*/
export const DDM: string;
/**
* Degrees, minutes, seconds.
*/
export const DMS: string;

}
declare module "geocortex/infrastructure/coordinates/Coordinate" {
import { CoordinateBase } from "geocortex/infrastructure/coordinates/CoordinateBase";
import { CoordinateSystem } from "geocortex/infrastructure/coordinates/CoordinateSystem";
import { GeoCoordinateString } from "geocortex/infrastructure/coordinates/GeoCoordinateString";
/**
 * This interface represents a processed base coordinate, projected and formatted in the target coordinate system.
 */
export interface Coordinate extends CoordinateBase {
    /**
     * The target coordinate system for this coordinate.
     */
    targetCoordinateSystem: CoordinateSystem;
    /**
     * Formatted output - X or Latitude depending on the target coordinate system
     */
    formattedLatitudeOrX?: string;
    /**
    * Formatted output - Y or Longitude depending on the target coordinate system
    */
    formattedLongitudeOrY?: string;
    /**
     * Formatted output - geocoordinate string that's populated if the target coordinate system has an output type as defined in {@link GeoCoordinateStringType).
     */
    formattedGeoCoordString?: GeoCoordinateString;
}

}
declare module "geocortex/infrastructure/coordinates/CoordinateBase" {
import { GeoCoordinateString } from "geocortex/infrastructure/coordinates/GeoCoordinateString";
/**
 * The base input coordinate. This could be a {@link esri.geometry.Point} object.
 */
export interface CoordinateBase {
    /**
     * The 'x' coordinate of the input point.
     */
    x?: number;
    /**
     * The 'y' coordinate of the input point.
     */
    y?: number;
    /**
     * The input geocoordinate string representing the coordinate.
     */
    geoCoordinateString?: GeoCoordinateString;
    /**
     * The spatial reference of the coordinate.
     */
    spatialReference: esri.SpatialReference;
}

}
declare module "geocortex/infrastructure/coordinates/CoordinatesManager" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { CoordinatesModel } from "geocortex/infrastructure/coordinates/CoordinatesModel";
import { CoordinateBase } from "geocortex/infrastructure/coordinates/CoordinateBase";
import { CoordinateSystem } from "geocortex/infrastructure/coordinates/CoordinateSystem";
import { Coordinate } from "geocortex/infrastructure/coordinates/Coordinate";
export const featureSetExtendedProperty = "containsCoordinates";
export const coordinateIdentifierProperty = "coordinateId";
/**
 * The Coordinates Manager manages all the coordinate models registered in the system.
 * Not only does it act as the central repository for coordinate systems, it is also responsible for mapping between the input source
 * coordinate stream and the output coordinate stream when needed - i.e. when there are subscribers to the output coordinate stream.
 */
export class CoordinatesManager {
    /**
     * The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this accessibility manager instance belongs to.
     */
    app: ViewerApplication;
    /** protected variables */
    protected _defaultCoordinatesModel: CoordinatesModel;
    protected _registeredCoordinateModels: string[];
    protected _prevCoord: CoordinateBase;
    /**
     * Initializes a new instance of the {@link CoordinatesManager} class.
     * @param app The {@link framework.application.Application} that this instance belongs to.
     */
    constructor(app: ViewerApplication);
    /**
     * Registers a new {@link CoordinatesModel}
     * @param setDefault If this is true then the currently registered model will be set as default. Please note that if there is only one model registered in hte system, it will automatically
     * be set as default, regardless of this setting.
     * @return The newly created {@link CoordinatesModel} or null on error.
     */
    registerModel(model: CoordinatesModel, setDefault?: boolean): boolean;
    /**
     * Retrieves the coordinates for the provided mapPoint or the current mouse pointer location one time in either the specified Coordinate System or in the currently active one
     * @return Promise<CoordinateInfo> Returns a promise for the coordinate information.
     */
    getCoordinate(inputCoordinate: CoordinateBase, targetCoordinateSystem?: CoordinateSystem, coordinateModelId?: string): Promise<Coordinate>;
    /**
     * Get the specified coordinate model by id. This function will return valid coordinate model instances, whether or not they have been registered with the coordinates manager.
     * @param modelId The unique identifier for the coordinate model.
     * @return Promise<CoordinateModel> A promise for the requested coordinate model, whenever it is registered as a framework object.
     */
    getCoordinatesModel(modelId: string): Promise<CoordinatesModel>;
    /**
     * Tests to see if a coordinates model is registered with the coordinates manager. If no model id is provided, will check if there is a default model registeed else will check to see if the specified
     * model has been registered or not.
     * @param modelId Optional. If provided, will check to see if the specified model is registered, else will check if a default model is registered or not.
     */
    hasRegisteredCoordinatesModel(modelId?: string): boolean;
    protected _validateModelRegistration(coordinatesModel: CoordinatesModel): boolean;
    protected _validateCoordinateSystem(coordSystem: CoordinateSystem): boolean;
    protected _processCoordinatesModel(coordsModel: CoordinatesModel): void;
    /**
     * We'll need to monitor when subscribers subscribe/unsubscribe to the outputStream observable so we can stop unnecessary coordinate tracking when it's no longer needed. This could be done with a
     * modification to Events.ts but that will involve an increased memory footprint for functionality that's currently not used anywhere else in the system. After a discussion with <jscharf>, we've
     * decided to hook into the outputStream bindingEvent subscribe and unsubscribe functions for the time being rather than modify Events.ts to support this. - <sabubaker>
     */
    protected _addModelSubscriptionHooks(coordsModel: CoordinatesModel): void;
    protected _handleModelSubscriptionsChanged(coordsModel: CoordinatesModel, subscriptions: {}): void;
}

}
declare module "geocortex/infrastructure/coordinates/CoordinatesModel" {
import { ViewModelBase } from "geocortex/framework/ui/ViewModelBase";
import { Observable, ObservableCollection } from "geocortex/framework/observables";
import { CoordinateSystem } from "geocortex/infrastructure/coordinates/CoordinateSystem";
import { CoordinateBase } from "geocortex/infrastructure/coordinates/CoordinateBase";
import { Coordinate } from "geocortex/infrastructure/coordinates/Coordinate";
import { CoordinatesModelConfig } from "geocortex/infrastructure/coordinates/CoordinatesModelConfig";
/**
 * Represents a coordinate model. A system can contain multiple coordinate models, each with its own coordinate systems. This model must be processed and registered with the {@link CoordinatesManager}.
 */
export class CoordinatesModel extends ViewModelBase {
    /**
     * An observable boolean indicating whether or not this coordinates model is currently active. Automatically activated when there are subscribers to the output stream.
     */
    isActive: Observable<boolean>;
    /**
     * The coordinate systems supported by this coordinate model.
     */
    coordinateSystems: ObservableCollection<CoordinateSystem>;
    /**
     * The currently selected coordinate system.
     */
    currentCoordinateSystem: Observable<CoordinateSystem>;
    /**
     * The number of fractional digits the output coordinates should be rounded off to.
     */
    fractionalDigits: number;
    /**
     * The default geographic coordinate system to use.
     */
    defaultGcsWkid: number;
    /**
     * A stream of input base (read raw) coordinates. These can be mapPoints.
     */
    inputStream: Observable<CoordinateBase>;
    /**
     * Processed output coordinate stream. The coordinateManager will automatically convert the input stream to output when this model is active.
     */
    outputStream: Observable<Coordinate>;
    /**
     * The configuration settings for this coordinate model. Configuration must be set up by the CoordinateController for the input stream.
     */
    configuration: CoordinatesModelConfig;
    /**
    * A boolean indicating whether or not this coordinates model has been initialized and registered with the Coordinates Manager.
    */
    isRegistered: boolean;
    /**
     * Application of configuration settings will be handled by the (@link mapping.modules.Map.MapCoordinatesController} once the map is initialized. This function is simply provided to enable a CoordinatesModel object to be
     * specified as a view model in the configuration files. In such cases, the initialize function will automatically be invoked with the configuration settings.
     */
    initialize(config: CoordinatesModelConfig): void;
}

}
declare module "geocortex/infrastructure/coordinates/CoordinatesModelConfig" {
import { CoordinateSystem } from "geocortex/infrastructure/coordinates/CoordinateSystem";
/**
 * Configuration options for the {@link CoordinatesModel}.
 */
export interface CoordinatesModelConfig {
    /**
     * Optional string specifying the id of the CoordinatesModel. If initialized as a view model from the desktop/tablet/handheld json config files, the view model ID will be used. If not, it needs to be specified here.
     */
    id?: string;
    /**
     * An array defining which unit(s) the primary map coordinates should be displayed in. The options are "xy" - projected, "dd" - decimal degrees, "ddm" - decimal degrees & minutes,
     * "dms" - decimal degrees, minutes, seconds, "mgrs" - Military Grid Reference System and "usng" - United States National Grid.
     */
    defaultCoordinateDisplayTypes: string[];
    /**
     * An array of custom coordinate systems defined by the user.
     */
    customCoordinateSystems: CoordinateSystem[];
    /**
     * An integer denoting the number of fractional digits to round the coordinates to. Defaults to 5 if not specified.
     */
    fractionalDigits?: number;
    /**
     * The default geographic coordinate system to use. Defaults to 4326 (WGS 1984) if not specified.
     */
    defaultGcsWkid?: number;
    /**
     * Configuration to skip checking the version of ArcGis server hosting the geometry service. If set to false (default), geo coordinate strings like
     * USNG and MGRS will be disabled if either the geometry service version is retrieved and does not support them, or if the geometry service version cannot
     * be retrieved. If true, then all coordinate systems will be loaded irrespective of geometry service version. Optional - defaults to false.
     */
    skipGeometryServiceVersionCheck?: boolean;
}

}
declare module "geocortex/infrastructure/coordinates/CoordinateSystem" {
/**
* Types of supported coordinate system types used by the coordinates infrastructure.
*/
export const CoordinateSystemType: {
    DD: string;
    DDM: string;
    DMS: string;
    XY: string;
    MGRS: string;
    USNG: string;
};
/**
 * Interface representing a coordinate system configured for a specific {@link CoordinatesModel}.
 */
export interface CoordinateSystem {
    /**
     * What is displayed to the user in the coordinate selection menu.
     */
    displayName: string;
    /**
     * The output type for this coordinate system. Can be one of "dd", "ddm", "dms", "xy", "mgrs" or "usng" as defined in {@link CoordinateSystemType}.
     */
    output: string;
    /**
     * The WKID for the coordinate system (if spatial reference is WKID based).
     */
    wkid?: number;
    /**
     * The WKT for the coordinate system (if spatial reference is WKT based).
     */
    wkt?: string;
}

}
declare module "geocortex/infrastructure/coordinates/CoordinateUtils" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { CoordinateSystem } from "geocortex/infrastructure/coordinates/CoordinateSystem";
import { CoordinateBase } from "geocortex/infrastructure/coordinates/CoordinateBase";
import { Coordinate } from "geocortex/infrastructure/coordinates/Coordinate";
import { GeoCoordinateString } from "geocortex/infrastructure/coordinates/GeoCoordinateString";
import { Application } from "geocortex/framework/application/Application";
/**
 * Retrieves the coordinates for the provided mapPoint in the target coordinate system.
 * @param {ViewerApplication} app The Viewer Application.
 * @param {(esri.geometry.Point | GeoCoordinateString)} mapPointOrCoordStr The input map point or Geo Coordinate string.
 * @param {CoordinateSystem} targetCoordSys The target coordinate system.
 * @param {number} [fracDigits=5] Optional Parameter lets you specify the number of digits the resulting formatted coordinate values should be rounded to.
 * @param {number} [geographicCoordSys=4326] Optional Parameter lets your specify the default geographic coordinate system to use. Defaults to GCS_WGS_1984 (4326).
 * @returns {Promise<Coordinate>} Returns a promise for the requested Coordinate.
 */
export function getCoordinate(app: ViewerApplication, mapPointOrCoordStr: esri.geometry.Point | GeoCoordinateString, targetCoordSys: CoordinateSystem, fracDigits?: number, geographicCoordSys?: number): Promise<Coordinate>;
/**
 * Returns the geocoordinate string for the provided map point.
 */
export function toGeoCoordinateString(app: ViewerApplication, inputCoord: CoordinateBase, targetCoordSys: CoordinateSystem, numDigits?: number, roundValues?: boolean, insertSpaces?: boolean): Promise<string>;
/**
 * Converts and returns a map point for the given geo coordinate string.
 */
export function fromGeoCoordinateString(app: ViewerApplication, geoCoordString: GeoCoordinateString): Promise<esri.geometry.Point>;
/**
 * Convert DMS to Decimal Degrees for deciphering manual user input.
 */
export function convertDmsToDecimalDegrees(app: ViewerApplication, deg: string, min: string, sec: string, bearing: string): number;
/**
* Formats an angle for display.
* @param angle The angle to format, in decimal degrees.
* @param format The format to use. One of the AngleFormat constants.
* @param app The Geocortex application.
* @param fractionalDigits The number of digits to display after the decimal point, for formats that display
*     fractional values.
*/
export function formatAngle(angle: number, format: string, app: Application, fractionalDigits?: number): string;
/**
* Formats latitude and longitude numbers for display.
* @param latitude The degrees of latitude.
* @param longitude The degrees of longitude.
* @param format The format to use. One of the AngleFormat constants.
* @param app The Geocortex application.
* @param fractionalDigits The number of digits to display after the decimal point, for formats that display
*     fractional values.
*/
export function formatLatLon(latitude: number, longitude: number, format: string, app: Application, fractionalDigits?: number): {
    latitude: string;
    longitude: string;
};
/**
* Formats a projected coordinate (X/Y value) for display.
* @param coordinate The coordinate to format.
* @param app The Geocortex application.
* @param fractionalDigits The number of digits to display after the decimal point.
*/
export function formatXYCoordinate(coordinate: number, app: Application, fractionalDigits?: number): string;
/**
* Formats an angle in quadrant bearing notation, e.g. "N 48.5° E".
* @param angle The angle to format, specified in decimal degrees using the North azimuth direction system.
* @param format The format to use. One of the AngleFormat constants.
* @param app The Geocortex application.
* @param fractionalDigits The number of digits to display after the decimal point, for formats that display
*     fractional values.
*/
export function formatBearing(angle: number, format: string, app: Application, fractionalDigits?: number): string;
/**
 * Retrieves coordinate string resources from the infrastructure library.
 * @param app The application that this utilities class belongs to.
 * @param resource Input resource name. Can be of the form "language-coordinates-xxx" or simply "xxx".
 */
export function getResource(app: Application, resource: string): string;

}
declare module "geocortex/infrastructure/coordinates/GeoCoordinateString" {
/**
 * Types of supported geocoordinate strings used by the coordinates infrastructure.
 */
export const GeoCoordinateStringType: {
    MGRS: string;
    USNG: string;
};
/**
 * Represents a geocoordinate string (eg. MGRS)
 */
export interface GeoCoordinateString {
    /**
     * Value of the geocoordinate string formatted as per coordinateType.
     */
    coordinateValue: string;
    /**
     * The type of geocoordinate string as defined in {@link GeoCoordinateStringTypes}. Only "mgrs" and "usng" are currently supported.
     */
    coordinateType: string;
}

}
declare module "geocortex/infrastructure/documents/DocumentCollection" {
import { FrameworkObject } from "geocortex/framework/FrameworkObject";
import { QueryParameters, Result, QueryResult } from "geocortex/essentials/documents/Parameters";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { ObservableCollection, Observable } from "geocortex/framework/observables";
import { DocumentCollectionConfig } from "geocortex/infrastructure/documents/DocumentCollectionConfig";
import { DocumentFieldSorter } from "geocortex/infrastructure/documents/DocumentFieldSorter";
export class DocumentCollection<T> extends FrameworkObject {
    protected _pageSize: number;
    protected _queryParams: QueryParameters;
    protected _mapCallback: (result: Result, index: number, array: Result[]) => T;
    app: ViewerApplication;
    /**
     * Whether or not the document collection is successfully initialized.
     */
    isInitialized: boolean;
    /**
     * Whether or not this collection should stop fetching items from the server.
     */
    stopFetching: boolean;
    /**
     * The items of the current page.
     */
    items: ObservableCollection<T>;
    /**
     * The total number of items in the collection.
     */
    numberOfItems: Observable<number>;
    currIndexStart: Observable<number>;
    currIndexStartFromOne: Observable<number>;
    currIndexEnd: Observable<number>;
    currPageNumber: Observable<number>;
    firstPageNumber: Observable<number>;
    lastPageNumber: Observable<number>;
    statusFetching: Observable<boolean>;
    statusOffline: Observable<boolean>;
    constructor(app: ViewerApplication, libraryId: string, mapCallback: (result: Result, index: number, array: Result[]) => T);
    initialize(config?: DocumentCollectionConfig): void;
    /**
     * Get the total length of the collection.
     */
    getLength(): number;
    /**
     * Increments the page number.
     */
    nextPage(): void;
    /**
     * Decrements the page number.
     */
    prevPage(): void;
    /**
     * Refreshes the collection.
     */
    refresh(): void;
    /**
     * Disposes any bindings tracked by this object.
     */
    destroy(): void;
    /**
     * Set the query parameters used to populate the items.
     * @param queryParams The query parameters.
     */
    setQueryParameters(queryParams: QueryParameters): void;
    /**
     * Get the query parameters being used to populate the items.
     */
    getQueryParameters(): QueryParameters;
    /**
     * Adds a filter to the query. Removes any previous filters with the same filter.
     * @param filter The filter to add.
     * @param filterType The type of filter.
     */
    addFilter(filter: geocortex.core.documents.Filter, filterType?: string): void;
    /**
     * Remove filters using a given field.
     * @param field The field of the filters to remove.
     * @param filterType The type of filter.
     */
    removeFilter(field: string, filterType?: string): void;
    /**
     * Sort the documents.
     * @param sorter The sorter that describes how to sort the documents.
     */
    sortBy(sorter: DocumentFieldSorter): void;
    protected _handlePageChanged(): void;
    protected _populateFromDocStore(): void;
    /**
     * Build the query parameters with paging related properties.
     */
    protected _buildQueryParams(): QueryParameters;
    protected _handleQueryResult(queryResult: QueryResult): void;
}

}
declare module "geocortex/infrastructure/documents/DocumentCollectionConfig" {
import { QueryParameters } from "geocortex/essentials/documents/Parameters";
/**
 * Configuration for a Document Collection.
 */
export interface DocumentCollectionConfig {
    /**
     * The file type to filter the documents by.
     */
    fileType?: string;
    pageSize?: number;
    /**
     * The initial query parameters used to search for documents.
     */
    queryParams?: QueryParameters;
}

}
declare module "geocortex/infrastructure/documents/DocumentFieldSorter" {
/**
 * Describes how to sort documents by a field.
 */
export interface DocumentFieldSorter {
    /**
     * The document field names used to sort the documents by, in order of relevance.
     */
    fields: string[];
    /**
     * The configured display name for this field sorter.
     */
    displayName?: string;
    /**
     * Whether or not to sort the documents in descending order.
     */
    descending?: boolean;
}

}
declare module "geocortex/infrastructure/documents/GrantEditorView" {
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { GrantEditorViewModel } from "geocortex/infrastructure/documents/GrantEditorViewModel";
import { MonikerModel } from "geocortex/infrastructure/documents/MonikerModel";
export class GrantEditorView extends ViewBase {
    app: ViewerApplication;
    viewModel: GrantEditorViewModel;
    autoCompleteInput: HTMLElement;
    autoCompleteMinLength: number;
    autoCompleteMaxEntries: number;
    added(widgetViewHost?: ViewBase): void;
    /**
     * Called on search input.
     */
    handleInputChanged(evt: KeyboardEvent, el: HTMLElement, ctx: any): void;
    handleAddMonikerButtonClick(evt: Event, el: HTMLElement, ctx: any): void;
    handleUpdateMoniker(evt: Event, el: HTMLInputElement, ctx: MonikerModel): boolean;
    handleAutoCompleteBlur(evt: FocusEvent, el: HTMLElement, ctx: any): void;
    getSuggestions(request: {
        term: string;
    }, response: (data: any[]) => void): void;
    protected _processMonikers(monikers: any[]): Promise<any[]>;
    protected _setupJQueryAutocomplete(): void;
    protected _handleAutoCompleteSelect(event: any, ui: any): void;
}

}
declare module "geocortex/infrastructure/documents/GrantEditorViewModel" {
import { ViewModelBase } from "geocortex/framework/ui/ViewModelBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { Document } from "geocortex/essentials/documents/Document";
import { ObservableCollection, Observable } from "geocortex/framework/observables";
import { MonikerModel } from "geocortex/infrastructure/documents/MonikerModel";
import { MonikerKindDesc } from "geocortex/infrastructure/documents/MonikerKindDesc";
export class GrantEditorViewModel extends ViewModelBase {
    protected _supportedGrantKinds: string[];
    protected _globalGrantIds: string[];
    protected _allowPublicAccess: boolean;
    protected _lastSearchResults: geocortex.core.documents.Moniker[];
    app: ViewerApplication;
    defaultGrantKind: string;
    userIconUri: string;
    roleIconUri: string;
    /**
     * The underlying document whose grants are being edited.
     */
    document: Document;
    /**
     * The configured grants.
     */
    grants: geocortex.core.documents.Grant[];
    /**
     * The monikers that have grants on the current document.
     */
    monikers: ObservableCollection<MonikerModel>;
    /**
     * Whether or not the current search text maps to a valid moniker.
     */
    isValidMoniker: Observable<boolean>;
    monikerKinds: ObservableCollection<MonikerKindDesc>;
    selectedMonikerKind: Observable<string>;
    selectedMoniker: Observable<geocortex.core.documents.Moniker>;
    searchText: Observable<string>;
    enabled: Observable<boolean>;
    editOwnership: Observable<boolean>;
    constructor(app: ViewerApplication, libraryId?: string);
    initialize(config: any): void;
    onSiteInitialized(): void;
    /**
     * Load a document's grants from the document store and updates the view model state.
     * @param id The ID of the document to load.
     */
    loadById(id: string): Promise<void>;
    /**
     * Add a moniker, updating the document with a grant for the moniker.
     */
    addMoniker(): void;
    /**
     * Add a grant to the document.
     * @param id The global ID of the grant
     * @param kind The kind of grant.
     * @return The grant that was added
     */
    addGrant(id: string, kind: string): geocortex.core.documents.Grant;
    /**
     * Update the moniker by updating the document grants.
     * @param moniker The model of the moniker being updated.
     * @param grantKind The kind of grant to add to the document for the given moniker.
     */
    updateMoniker(moniker: MonikerModel, grantKind: string): void;
    /**
     * Search for monikers using a given search term. These results will
     * be limited by the currently selected moniker kind (users or roles).
     * @param searchTerm The search term to search monikers with.
     * @return A promise containing a list of monikers.
     */
    searchMonikers(searchTerm: string): Promise<geocortex.core.documents.Moniker[]>;
    /**
     * Validates the search input.
     */
    validateSearchInput(): void;
    /**
     * Reset the search options.
     */
    resetOptions(): void;
    /**
     * Set the view model state to defaults.
     */
    reset(): void;
    /**
     * Gets the selected moniker based off the current search text.
     * If the text does not match the selected moniker, it will search
     * through the last search results for monikers.
     */
    protected _getSelectedMoniker(): geocortex.core.documents.Moniker;
    /**
     * Whether a given moniker kind is a user kind.
     * @param monikerKind The moniker kind.
     * @return Whether or not the kind is a user kind.
     */
    protected _isUserKind(monikerKind: string): boolean;
    /**
     * Update the view model with the document of the given ID.
     * @param id The ID of the document to update this model with.
     */
    protected _updateModel(document: Document): void;
    /**
     * Updates the monikers list based off the given grants.
     * @param grants The grants to build the monikers from.
     */
    protected _updateMonikers(grants: geocortex.core.documents.Grant[]): void;
    /**
     * Checks whether or not the moniker already exists based off its ID and aliases.
     * @param moniker The moniker to check whether it exists.
     * @return Whether or not the moniker exists.
     */
    protected _monikerExists(moniker: geocortex.core.documents.Moniker): boolean;
    protected _setMonikerKinds(): void;
    private _setMonikerEnableds();
}

}
declare module "geocortex/infrastructure/documents/GuestLinkModel" {
import { Observable } from "geocortex/framework/observables";
import { GuestLinkModelConfig } from "geocortex/infrastructure/documents/GuestLinkModelConfig";
/**
 * Model for a single guest link of a document.
 */
export class GuestLinkModel {
    /**
     * The name of the guest link.
     */
    name: Observable<string>;
    /**
     * The grant kind of this guest link.
     */
    kind: string;
    /**
     * The grant providing access for this guest link.
     */
    grant: geocortex.core.documents.Grant;
    /**
     * The link parameter used to grant access to the document.
     */
    link: string;
    /**
     * The URL for this guest link.
     */
    linkUrl: Observable<string>;
    constructor(config: GuestLinkModelConfig);
    reset(): void;
}

}
declare module "geocortex/infrastructure/documents/GuestLinkModelConfig" {
/**
 * Configuration for a Guest Link Model.
 */
export interface GuestLinkModelConfig {
    /**
     * The grant kind of the guest link.
     */
    kind?: string;
    /**
     * The name of the guest link.
     */
    name?: string;
}

}
declare module "geocortex/infrastructure/documents/MonikerKindDesc" {
/**
 * Interface for a describing a moniker kind.
 */
export interface MonikerKindDesc {
    /**
     * The moniker kind.
     */
    kind: string;
    /**
     * The display name representing this moniker kind.
     */
    displayName: string;
}

}
declare module "geocortex/infrastructure/documents/MonikerModel" {
import { Observable } from "geocortex/framework/observables";
import { MonikerModelConfig } from "geocortex/infrastructure/documents/MonikerModelConfig";
/**
 * Model for a Moniker which has grants on a document.
 */
export class MonikerModel {
    /**
     * The grants that this moniker has on the document.
     */
    grants: geocortex.core.documents.Grant[];
    /**
     * The ID of the moniker.
     */
    id: string;
    /**
     * The name of the moniker.
     */
    name: string;
    /**
     * The icon URI for the moniker.
     */
    iconUri: string;
    /**
     * Whether or not this moniker represents a global grant.
     */
    isGlobal: boolean;
    /**
     * Whether or not this moniker represents a public grant.
     */
    isPublic: boolean;
    /**
     * Whether or not this moniker has its grants revoked.
     */
    isRevoked: Observable<boolean>;
    /**
     * Whether or not this moniker has a reader grant.
     */
    canRead: boolean;
    /**
     * Whether or not this moniker has a writer grant.
     */
    canWrite: boolean;
    /**
     * Whether or not this moniker has an owner grant.
     */
    canEdit: boolean;
    /**
     * Whether this widget is enabled.  All contained controls will take this value.
     */
    enabled: Observable<boolean>;
    constructor(config: MonikerModelConfig);
    addGrant(grant: geocortex.core.documents.Grant): void;
}

}
declare module "geocortex/infrastructure/documents/MonikerModelConfig" {
/**
 * Configuration for a Moniker Model. Either a grant or ID is required.
 */
export interface MonikerModelConfig {
    /**
     * The grant the moniker view model was constructed from.
     */
    grant?: geocortex.core.documents.Grant;
    /**
     * The ID of the moniker.
     */
    id?: string;
    /**
     * The name of the grant.
     */
    name?: string;
    /**
     * The icon URI for the grant.
     */
    iconUri?: string;
    /**
     * Whether or not this grant is a global grant.
     */
    isGlobal?: boolean;
    /**
     * Whether or not this grant is a public grant.
     */
    isPublic?: boolean;
}

}
declare module "geocortex/infrastructure/eventArgs/ActiveToolChangedEventArgs" {
import { ToolBase } from "geocortex/infrastructure/tools/ToolBase";
export interface ActiveToolChangedEventArgs {
    tool: ToolBase;
    previousTool: ToolBase;
}

}
declare module "geocortex/infrastructure/eventArgs/AuthenticationEventArgs" {
export class AuthenticationEventArgs {
    result: any;
    username: string;
    token: string;
}

}
declare module "geocortex/infrastructure/eventArgs/EditVertexMovedEventArgs" {
import { EditCapabilityBase } from "geocortex/infrastructure/accessibility/EditCapabilityBase";
export interface EditVertexMovedEventArgs {
    /**
     * Reference to the sender.
     */
    sender: EditCapabilityBase;
    /**
     * The coordinates of the mouse pointer in map coordinates.
     */
    mapPoint: esri.geometry.Point;
    /**
     * The coordinates of the mouse pointer in screen coordinates.
     */
    screenPoint: esri.geometry.ScreenPoint;
}

}
declare module "geocortex/infrastructure/eventArgs/FeatureSetManagerEventArgs" {
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
import { CollectionChangedArgs } from "geocortex/framework/events/CollectionChangedArgs";
export class FeatureSetManagerEventArgs {
    /**
     * Reference of the sender
     */
    sender: any;
    /**
     * Collection of feature sets
     */
    featureSetCollection: FeatureSetCollection;
    /**
     * ID of collection of feature sets
     */
    featureSetCollectionId: string;
    /**
     * Describes the change to the collection of feature set objects
     */
    collectionChangedEventArgs: CollectionChangedArgs;
    /**
     * Initializes a new instance of the {@link FeatureSetManagerEventArgs} class.
     * @param args An object consisting of 3 members: `sender`, `featureSetCollection`, and `featureSetCollectionId`.
     */
    constructor(args: {
        sender: any;
        featureSetCollection: FeatureSetCollection;
        featureSetCollectionId: string;
        collectionChangedEventArgs?: CollectionChangedArgs;
    });
}

}
declare module "geocortex/infrastructure/eventArgs/FilterControlEventArgs" {
import { FilterControlItemInfo } from "geocortex/infrastructure/ui/components/FilterControl/FilterControlItemInfo";
export interface FilterControlEventArgs<T> {
    filterControlId: string;
    filterableItems: FilterControlItemInfo<T>[];
}

}
declare module "geocortex/infrastructure/eventArgs/FilterControlQueryChangedEventArgs" {
export interface FilterControlQueryChangedEventArgs {
    filterControlId: string;
    query: string;
}

}
declare module "geocortex/infrastructure/eventArgs/GeolocationEventArgs" {
export class GeolocationEventArgs {
    /** A point in Web Mercator. */
    mapPoint: esri.geometry.Point;
    /** A point in the map's spatial reference. */
    projectedMapPoint: esri.geometry.Point;
    /** A location returned directly from the HTML5 geolocation event. */
    location: Position;
    /** Whether the current geolocation result was from a single geolocate, track, or a follow. */
    typeOfGeolocation: string;
    /** The accuracyThreshold goal that was initially specified for a single point geolocate command. */
    accuracyThreshold: number;
    /** Whether or not the single point geolocation process reached its time limit. */
    timedOut: boolean;
    /**
     * Initializes a new instance of the {@link GeolocationEventArgs} class.
     */
    constructor();
}

}
declare module "geocortex/infrastructure/eventArgs/GeometryChangedEventArgs" {
export interface GeometryChangedEventArgs {
    /**
     * The graphic whose geometry was changed.
     */
    graphic: esri.Graphic;
}

}
declare module "geocortex/infrastructure/eventArgs/GeometryEditCompletedEventArg" {
export interface GeometryEditCompletedEventArg {
    editedGraphic: esri.Graphic;
    originalGraphic: esri.Graphic;
    cancelled: boolean;
}

}
declare module "geocortex/infrastructure/eventArgs/GraphicAttributesChangedEventArgs" {
export interface GraphicAttributesChangedEventArgs {
    graphic: esri.Graphic;
}

}
declare module "geocortex/infrastructure/eventArgs/GraphicDrawActivatedEventArgs" {
export interface GraphicDrawActivatedEventArgs {
    /**
     * Reference to the sender.
     */
    sender: esri.toolbars.Draw;
    /**
     * The type of geometry drawn (e.g. "circle", "ellipse", "rectangle", "polyline", "polygon")
     */
    geometryType: string;
}

}
declare module "geocortex/infrastructure/eventArgs/GraphicDrawDeactivatedEventArgs" {
export interface GraphicDrawDeactivatedEventArgs {
    /**
     * Reference to the sender.
     */
    sender: esri.toolbars.Draw;
    /**
     * The type of geometry drawn (e.g. "circle", "ellipse", "rectangle", "polyline", "polygon")
     */
    geometryType: string;
}

}
declare module "geocortex/infrastructure/eventArgs/GraphicEditActivatedEventArgs" {
export interface GraphicEditActivatedEventArgs {
    /**
     * Reference to the sender.
     */
    sender: esri.toolbars.Edit;
    /**
     * The editing type (e.g. Edit.MOVE | Edit.ROTATE | Edit.SCALE)
     */
    tool: number;
    /**
     * The graphic to edit whose vertices will be edited or moved.
     */
    graphic: esri.Graphic;
}

}
declare module "geocortex/infrastructure/eventArgs/GraphicEditDeactivatedEventArgs" {
export interface GraphicEditDeactivatedEventArgs {
    /**
     * Reference to the sender.
     */
    sender: esri.toolbars.Edit;
    /**
     * The editing type (e.g. Edit.MOVE | Edit.ROTATE | Edit.SCALE)
     */
    tool: number;
    /**
     * The graphic whose vertices were edited or moved.
     */
    graphic: esri.Graphic;
    /**
     * Whether the original graphic was modified.
     */
    isModified?: boolean;
    /**
     * Whether the editing operation has been cancelled.
     */
    cancelled?: boolean;
}

}
declare module "geocortex/infrastructure/eventArgs/GraphicEditingDoneEventArgs" {
export interface GraphicEditingDoneEventArgs {
    old: esri.Graphic;
    new: esri.Graphic;
}

}
declare module "geocortex/infrastructure/eventArgs/GraphicRemovedEventArgs" {
export interface GraphicRemovedEventArgs {
    graphic: esri.Graphic;
    graphicLayer: esri.layers.GraphicsLayer;
}

}
declare module "geocortex/infrastructure/eventArgs/GraphicVertexAddedEventArgs" {
export interface GraphicVertexAddedEventArgs {
    /**
     * Reference to the sender.
     */
    sender: esri.toolbars.Draw;
    /**
     * The coordinates of the mouse pointer in map coordinates.
     */
    mapPoint: esri.geometry.Point;
    /**
     * The coordinates of the mouse pointer in screen coordinates.
     */
    screenPoint: esri.geometry.ScreenPoint;
    /**
     * The coordinates of the snapping point.
     */
    snappingPoint: esri.geometry.Point;
}

}
declare module "geocortex/infrastructure/eventArgs/GraphicVertexMovedEventArgs" {
/**
 * Describes the arguments for an `EditVertexMovedEvent` event.
 */
export interface GraphicVertexMovedEventArgs {
    /**
     * Reference to the sender.
     */
    sender: esri.toolbars.Draw;
    /**
     * The coordinates of the mouse pointer in map coordinates.
     */
    mapPoint: esri.geometry.Point;
    /**
     * The coordinates of the mouse pointer in screen coordinates.
     */
    screenPoint: esri.geometry.ScreenPoint;
    /**
     * The coordinates of the snapping point.
     */
    snappingPoint: esri.geometry.Point;
}

}
declare module "geocortex/infrastructure/eventArgs/LayerDefinitionExpressionAppliedEventArgs" {
import { Layer } from "geocortex/essentials/Layer";
export interface LayerDefinitionExpressionAppliedEventArgs {
    gcxlayer: Layer;
}

}
declare module "geocortex/infrastructure/eventArgs/MapExtentEventArgs" {
export class MapExtentEventArgs {
    /** Supplementary information for when we are able to project */
    /** to 4326 on the client-side (i.e. from Web Mercator) */
    centerLatLon: any;
    currentScale: number;
    currentResolution: number;
    /**
     * Initializes a new instance of the {@link MapExtentEventArgs} class.
     */
    constructor();
}

}
declare module "geocortex/infrastructure/eventArgs/MapServiceLayersChangedEventArgs" {
import { MapService } from "geocortex/essentials/MapService";
import { ServiceLayerInfo } from "geocortex/infrastructure/gis/ServiceLayerInfo";
import { Layer } from "geocortex/essentials/Layer";
export interface MapServiceLayersChangedEventArgs {
    mapService: MapService | ServiceLayerInfo;
    newItems: Layer[];
    oldItems: Layer[];
}

}
declare module "geocortex/infrastructure/eventArgs/MarkerDragEventArgs" {
/**
 * Describes the arguments for a marker drag event.
 */
export interface MarkerDragEventArgs {
    /** The ID of the marker that triggered the event. */
    id: string;
    /** The center point of the graphic being dragged. */
    centerPoint: esri.geometry.Point;
    /** The coordinates of the mouse pointer in map coordinates. */
    mapPoint: esri.geometry.Point;
    /** The coordinates of the mouse pointer in screen coordinates. */
    screenPoint: esri.geometry.ScreenPoint;
}

}
declare module "geocortex/infrastructure/eventArgs/MarkerPointerEventArgs" {
/**
 * Describes the arguments for a marker event.
 */
export interface MarkerPointerEventArgs {
    /** The ID of the marker that triggered the event. */
    id: string;
    /** The graphic of the marker that triggered the event. */
    graphic: esri.Graphic;
    /** The coordinates of the mouse pointer in map coordinates. */
    mapPoint: esri.geometry.Point;
    /** The coordinates of the mouse pointer in screen coordinates. */
    screenPoint: esri.geometry.ScreenPoint;
    /** Indicates which button was pressed on the mouse to trigger the event. */
    button: number;
}

}
declare module "geocortex/infrastructure/eventArgs/OfflineMapEditorFinishedEventArgs" {
import { OfflineMap } from "geocortex/infrastructure/offline/OfflineMap";
/**
 * Payload of the OfflineMapEditorFinishedEvent.
 */
export interface OfflineMapEditorFinishedEventArgs {
    canceled: boolean;
    /**
     * The existing OfflineMap the editor was started with, if any.
     */
    existingOfflineMap?: OfflineMap;
    /**
     * The new values for the OfflineMap, unless editing was canceled.
     */
    newOfflineMap?: OfflineMap;
}

}
declare module "geocortex/infrastructure/eventArgs/OfflineMapEventArgs" {
import { OfflineMap } from "geocortex/infrastructure/offline/OfflineMap";
import { OfflineMapState } from "geocortex/infrastructure/offline/OfflineManager";
export interface OfflineMapsLoadedEventArgs {
    offlineMaps: OfflineMap[];
    activeOfflineMap: OfflineMap;
    offlineMapStates: OfflineMapState[];
}
export interface OfflineMapAddedEventArgs {
    offlineMap: OfflineMap;
}
export interface OfflineMapSyncedEventArgs {
    offlineMap: OfflineMap;
}
export interface OfflineMapSyncErrorEventArgs {
    offlineMap: OfflineMap;
    error: any;
}
export interface OfflineMapRemovedEventArgs {
    offlineMap: OfflineMap;
}
export interface OfflineMapActivatedEventArgs {
    offlineMap: OfflineMap;
    userAction: boolean;
}

}
declare module "geocortex/infrastructure/eventArgs/PlotCoordinatesEventArgs" {
import { Coordinate } from "geocortex/infrastructure/coordinates/Coordinate";
export interface PlotCoordinatesEventArgs {
    sender: any;
    coordinateId: string;
    coordinate: Coordinate;
}

}
declare module "geocortex/infrastructure/eventArgs/PlotCoordinatesIdUpdatedEventArgs" {
export interface PlotCoordinatesIdUpdatedEventArgs {
    sender: any;
    oldId: string;
    updatedId: string;
}

}
declare module "geocortex/infrastructure/eventArgs/ProjectEditorFinishedEventArgs" {
import { Project } from "geocortex/infrastructure/project/Project";
/**
 * Describes the arguments for project editor finishing event.
 */
export interface ProjectEditorFinishedEventArgs {
    /**
     * Whether or not editing the project was canceled.
     */
    canceled: boolean;
    /**
     * The project the editor started with.
     */
    existingProject: Project;
    /**
     * The new values for the Project, unless editing was canceled.
     */
    newProject: Project;
}

}
declare module "geocortex/infrastructure/eventArgs/QueryCompletedEventArgs" {
import { LayerInfo } from "geocortex/infrastructure/gis/LayerInfo";
export interface QueryCompletedEventArgs {
    layer: LayerInfo;
    query: esri.tasks.Query;
    error?: Error;
}

}
declare module "geocortex/infrastructure/eventArgs/ReportResultEventArgs" {
/**
 * The result of a successfully run report.
 */
export interface ReportResultEventArgs {
    /** Whether or not the Report result was asynchronous. */
    isAsync: boolean;
    /** The download URL for the resultant Report file. In async mode, this is the URL to the report progress/download page. */
    href: string;
}

}
declare module "geocortex/infrastructure/eventArgs/ResultsPageChangedEventArgs" {
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
import { ObservableCollection } from "geocortex/framework/observables";
import { Feature } from "geocortex/infrastructure/Feature";
export class ResultsPageChangedEventArgs {
    /**
     * The collection of feature sets the event is occurring for.
     */
    featureSetCollection: FeatureSetCollection;
    /**
     * The new value of the results page.
     */
    newValue: ObservableCollection<Feature>;
    /**
     * Initializes a new instance of the {@link ResultsPageChangedEventArgs} class.
     */
    constructor();
}

}
declare module "geocortex/infrastructure/eventArgs/SearchProgressEventArgs" {
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
export class SearchProgressEventArgs {
    /**
     * The status of the executing search.
     * @type geocortex.essentialsHtmlViewer.mapping.infrastructure.search.Status
     */
    status: string;
    /**
     * The type of search that is being performed (eg. Instant Search, Geocode, etc.).
     * @type String
     */
    searchType: string;
    /**
     * The URL to the search endpoint.
     * @type String
     */
    endpointUrl: string;
    /**
     * Any error that might have been thrown.
     * @type Error
     */
    error: Error;
    /**
     * A message that might be displayed to the user. In the event of an error, then usually error.message
     * @type String
     */
    message: string;
    /**
      * The results of the search.
      * @type geocortex.essentialsHtmlViewer.mapping.infrastructure.FeatureSetCollection
      */
    results: FeatureSetCollection;
    /**
     * The full search query that was used for the search. Only relevant for text-based searches.
     * @type String
     */
    query: string;
    /**
     * Initializes a new instance of the {@link SearchProgressEventArgs} class.
     */
    constructor();
}

}
declare module "geocortex/infrastructure/eventArgs/SelectionChangedEventArgs" {
import { SelectionEventArgs } from "geocortex/infrastructure/eventArgs/SelectionEventArgs";
export interface SelectionChangedEventArgs extends SelectionEventArgs {
    previousName?: string;
}

}
declare module "geocortex/infrastructure/eventArgs/SelectionEventArgs" {
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
export interface SelectionEventArgs {
    name: string;
    featureSetCollection?: FeatureSetCollection;
}

}
declare module "geocortex/infrastructure/eventArgs/SnappingFeedbackEventArgs" {
/**
 * Describes the arguments for a Snapping event.
 */
export class SnappingFeedbackEventArgs {
    /**
     * The snapping point, null if there is none.
     */
    snappingPoint: esri.geometry.Point;
    /**
     * The original input point.
     */
    inputPoint: esri.geometry.Point;
}

}
declare module "geocortex/infrastructure/eventArgs/StateChangedEventArgs" {
import { StateDefinition, ActiveState } from "geocortex/infrastructure/states/State";
export interface StateChangedEventArgs {
    stateDefinition: StateDefinition;
    activeStates: ActiveState[];
    modalState: StateDefinition;
    previousModalState: StateDefinition;
}

}
declare module "geocortex/infrastructure/eventArgs/SyncInfoRefreshedEventArgs" {
import { SyncInfo } from "geocortex/infrastructure/offline/SyncInfo";
import { OfflineMap } from "geocortex/infrastructure/offline/OfflineMap";
export interface SyncInfoRefreshedEventArgs {
    syncInfo: SyncInfo;
    offlineMap: OfflineMap;
}

}
declare module "geocortex/infrastructure/eventArgs/TimeSliderProfileChangingEventArgs" {
import { TimeSliderProfile } from "geocortex/essentials/TimeSliderProfile";
export interface TimeSliderProfileChangingEventArgs {
    profile: TimeSliderProfile;
    isPlayingBack: boolean;
}

}
declare module "geocortex/infrastructure/eventArgs/ToggleButtonStateChangedEventArgs" {
import { ToolbarToggleButtonEntry, ToggleButtonState } from "geocortex/infrastructure/toolbarGroup/types/ToolbarToggleButton";
export interface ToggleButtonStateChangedEventArgs {
    toggleButtonEntry: ToolbarToggleButtonEntry;
    state: ToggleButtonState;
}

}
declare module "geocortex/infrastructure/eventArgs/ToolbarButtonClickedEventArgs" {
export interface ToolbarButtonClickedEventArgs {
    commandName: string;
    commandParameter: string;
    id: string;
    name: string;
    libraryId: string;
}

}
declare module "geocortex/infrastructure/eventArgs/ToolbarTabChangedEventArgs" {
import { ToolbarGroupBase } from "geocortex/infrastructure/toolbarGroup/ToolbarGroupBase";
export interface ToolbarTabChangedEventArgs {
    group: ToolbarGroupBase;
}

}
declare module "geocortex/infrastructure/eventArgs/ToolInputMethodChangedEvent" {
import { ToolBase } from "geocortex/infrastructure/tools/ToolBase";
export interface ToolInputMethodChangedEvent {
    tool: ToolBase;
    previousMethod: string;
    newMethod: string;
}

}
declare module "geocortex/infrastructure/eventArgs/TransientActivatedEventArgs" {
export interface TransientActivatedEventArgs {
    stateName: string;
    viewId?: string;
    regionId?: string;
    widgetId: string;
}

}
declare module "geocortex/infrastructure/eventArgs/UndoRedoEventArgs" {
import { UndoManager } from "geocortex/infrastructure/undo/UndoManager";
import { Undoable } from "geocortex/infrastructure/undo/Undoable";
/**
 * Describes the arguments for an undo/redo event.
 */
export interface UndoRedoEventArgs {
    /** Reference to the sender. */
    sender: UndoManager;
    /** The operation that triggered the event. */
    operation?: Undoable;
}

}
declare module "geocortex/infrastructure/eventArgs/UserEventArgs" {
export class UserEventArgs {
    /**
     * Gets or sets whether the user sign-in/sign-out should be cancelled, or allowed to proceed.
     */
    isCancelled: boolean;
    /**
     * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.eventArgs.UserEventArgs} class.
     */
    constructor();
}

}
declare module "geocortex/infrastructure/featureDetails/FeatureProviderBase" {
import { ViewModelBase } from "geocortex/framework/ui/ViewModelBase";
import { Observable } from "geocortex/framework/observables";
import { Feature } from "geocortex/infrastructure/Feature";
import { Application } from "geocortex/framework/application/Application";
import { FeatureProviderConfig, FeatureProviderViewModeConfig } from "geocortex/infrastructure/featureDetails/FeatureProviderConfig";
import { ViewBase } from "geocortex/framework/ui/ViewBase";
export class FeatureProviderBase extends ViewModelBase {
    /**
     * The current Feature this provider is providing details for
     */
    currentFeature: Observable<Feature>;
    /**
     * Determines whether this provider can function currently or not. This is akin to the 'canExecute' function for commands.
     */
    providerEnabled: Observable<boolean>;
    constructor(app: Application, libraryId?: string);
    initialize(config: any): void;
    /**
     * This is called when the current feature changes, so that we might update our displays. This will likely change when
     * a new result is selected from one of the result views.
     * @param feature A Geocortex Feature that we are displaying.
     */
    handleCurrentFeatureChanged(feature: Feature): void;
    /**
     * Convenience method to update the provider state only if the current feature is available and the state has changed.
     * @param value The current provider state. Provider will be set to enabled only if the current feature is available as well.
     */
    updateProviderState(value: boolean): void;
    /**
     * This method creates attached and data bound views for each markup type (compactView and expandedView - if configured separately) specified in config
     * Override this method if a provider needs to create more than one view (for e.g. DataLinks) for each markup type specified in config.
     * @param featureProviderConfig The configuration for this feature provider
     * @param viewModeRegionConfig: An object that specifies the target region for each view mode for which a view needs to be created. If a view is not specified in the view mode
     * config, it will simply be ignored. If a "default" parameter is supplied, then this will be used if only a single markup is supplied in featureProviderConfig as a string.
     * @param onViewsCreated Optional. A callback function which, if specified, is triggered after the views have been created, with the views as arguments. Useful for asynchronous providers like Datalinks.
     * @param customContext Optional. If provided, will be used as the context for the created views. Otherwise the FeatureProviderBase class will itself be used as the context/viewModel for the views
     */
    createAttachedViews(featureProviderConfig: FeatureProviderConfig, viewModeRegionConfig: FeatureProviderViewModeConfig, onViewsCreated?: (views: ViewBase[]) => void, customContext?: any): void;
}

}
declare module "geocortex/infrastructure/featureDetails/FeatureProviderConfig" {
export interface FeatureProviderConfig {
    /**
     * The type for the feature provider.
     */
    type: string;
    /**
     * The type of view to create.
     */
    viewType: string;
    /**
     * The markup for the view. This could either be a string (if common for all view modes) or an object specifying markup for each view mode.
     */
    markup: FeatureProviderViewModeConfig | string;
    /**
     * Parameter which determines whether this provider is enabled or not.
     */
    enabled?: boolean;
    /**
     * View ID to assign to the view if the provider generates a single view only.
     */
    viewId?: string;
    /**
     * Library ID to assign to the view.
     */
    libraryId?: string;
    /**
     * Icon URI for an icon depicting the provider.
     */
    iconUri?: string;
    /**
     * Title for the provider.
     */
    title?: string;
    /**
     * Additional configuration for the provider.
     */
    config?: any;
    /**
     * Additional configuration for the provider views.
     */
    viewConfig?: any;
    /**
     * Region to target the provider views to. This will override the default configured region for the providers.
     * This is an object mapping each mode whose region needs to be overridden with the new target region.
     */
    targetRegion?: FeatureProviderViewModeConfig;
}
export interface FeatureProviderViewModeConfig {
    [viewMode: string]: string;
}

}
declare module "geocortex/infrastructure/gis/AppInfo" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { MapInfo } from "geocortex/infrastructure/gis/MapInfo";
export class AppInfo {
    gcxApp: ViewerApplication;
    /**
     * The URL of a geometry service to use for the application. For Geocortex Essentials viewer applications,
     * this value should be left blank.
     */
    geometryServiceUrl: string;
    urlParameters: {
        [key: string]: string;
    };
    mapInfo: MapInfo;
    map: esri.Map;
    essentialsVersion: number;
    private _geometryService;
    static fromGeocortexApp(app: ViewerApplication): AppInfo;
    getGeometryService(): esri.tasks.GeometryService;
}

}
declare module "geocortex/infrastructure/gis/DatumTransform" {
/**
 * Describes an object that represents a datum transform for projecting between different spatial references.
* A valid datum tranform requires a parameter of each type (transform, from, and to).
 */
export interface DatumTransform {
    /** The well-known ID of the datum transform to use. */
    transformWkid?: number;
    /** The well-known text of the datum transform to use. This is ignored if `transformWkid` is also specified. */
    transformWkt?: string;
    /** The well-known ID of the spatial reference that you are projecting from. */
    fromWkid?: number;
    /** The well-known text of the spatial reference that you are projecting from. This is ignored if `fromWkid` is also specified. */
    fromWkt?: string;
    /** The well-known ID of the spatial reference that you are projecting to. */
    toWkid?: number;
    /** The well-known text of the spatial reference that you are projecting to. This is ignored if `toWkid` is also specified. */
    toWkt?: string;
}

}
declare module "geocortex/infrastructure/gis/DomainInfo" {
export class DomainInfo {
    domain: esri.layers.Domain;
    constructor();
    static create(domain: esri.layers.Domain): DomainInfo;
    isCodedValueDomain(): boolean;
    getCodedValueDomain(): esri.layers.CodedValueDomain;
    getName(code: any): string;
}

}
declare module "geocortex/infrastructure/gis/FieldInfo" {
import { DomainInfo } from "geocortex/infrastructure/gis/DomainInfo";
import { Field } from "geocortex/essentials/Field";
export class FieldInfo {
    name: string;
    type: string;
    alias: string;
    isVisible: boolean;
    searchable: boolean;
    editable: boolean;
    nullable: boolean;
    length: number;
    esriField: esri.layers.Field;
    domainInfo: DomainInfo;
    domain: esri.layers.Domain;
    isTypeField: boolean;
    format: string;
    timeZoneId: string;
    displayTimeZoneId: string;
    /**
     * A list of the field's domains for each subtype, indexed by type ID.
     */
    subtypeDomains: {
        [typeID: string]: esri.layers.Domain;
    };
    subtypeDomainInfos: {
        [typeID: string]: DomainInfo;
    };
    constructor();
    static fromEsriField(esriField: esri.layers.Field, featureLayer?: esri.layers.FeatureLayer, gcxField?: Field): FieldInfo;
    static fromGcxField(gcxField: Field): FieldInfo;
    isNumeric(): boolean;
    isDate(): boolean;
    isText(): boolean;
    isCodedValueDomain(): boolean;
    hasSubtypeCodedValueDomains(): boolean;
    getCodedValueDomain(): esri.layers.CodedValueDomain;
    getSubtypeCodedValueDomains(): {
        [typeID: string]: esri.layers.CodedValueDomain;
    };
    resolveCodedDomainValue(code: any, typeID?: string): string;
    formatValue(value: any, typeID?: string): string;
    /**
     * Determines if values should be formatted as a number.
     */
    private _isNumericFormat();
}

}
declare module "geocortex/infrastructure/gis/GisUtils" {
export function getServiceLayerType(serviceLayer: esri.layers.Layer): string;

}
declare module "geocortex/infrastructure/gis/LayerInfo" {
import { ServiceLayerInfo } from "geocortex/infrastructure/gis/ServiceLayerInfo";
import { Layer } from "geocortex/essentials/Layer";
import { FieldInfo } from "geocortex/infrastructure/gis/FieldInfo";
export class LayerInfo {
    id: string;
    name: string;
    displayName: string;
    serviceLayerInfo: ServiceLayerInfo;
    esriLayerInfo: esri.layers.LayerInfo;
    gcxLayer: Layer;
    uniqueId: string;
    url: string;
    queryable: boolean;
    fields: FieldInfo[];
    dataProvider: string;
    parentLayerId: string;
    subLayerIds: string[];
    isUserCreated: boolean;
    includeInLayerList: boolean;
    isExpanded: boolean;
    relationships: esri.layers.Relationship[];
    /**
    * Whether the layer represented by this layerInfo object is currently visible or not.
    */
    private _visible;
    private _fieldsRetrieved;
    private _featureLayer;
    constructor();
    static fromEsriLayerInfo(esriLayerInfo: esri.layers.LayerInfo, esriLayer: esri.layers.Layer): LayerInfo;
    static fromEsriFeatureLayer(featureLayer: esri.layers.FeatureLayer): LayerInfo;
    static fromGcxLayer(gcxLayer: Layer): LayerInfo;
    getUrlWithoutParameters(): string;
    getFields(): dojo.Deferred;
    getInitializedFeatureLayer(): Promise<esri.layers.FeatureLayer>;
    setDefinitionExpression(definition: string): void;
    getDefinitionExpression(): string;
    /**
     * Returns whether or not the layer represented by this layerInfo object is currently visible on the map. */
    isVisible(): boolean;
    /**
     * Gets a value representing whether or not all of this layer's ancestors are currently visible in the map. */
    areAllAncestorsVisible(): boolean;
    /**
     * Sets the visibility for this layer.
     * @param visible Specifies if the layer is visible or not
     * @param doNotRefresh An optional parameter which if true, will set the visible layers internally but will not refresh the map automatically. Only applicable for
     * mapServices that support layer visibility. Defaults to false.
     * @param applyDeferredRefresh An optional parameter which if true, will refresh the map after a specified timeout in ms. Only applicable for mapServices that support
     * layer visibility. 'applyDeferredRefresh' will ensure that only once refresh request is sent for all setVisibility requests within the given threshold. Defaults to false.
     * @param refreshTimeoutMs The timeout in ms after which to refresh the map if applyDeferredRefresh is true. Defaults to 150ms.
     */
    setVisibility(visible: boolean, doNotRefresh?: boolean, applyDeferredRefresh?: boolean, refreshTimeoutMs?: number): void;
    setEsriLayerVisibility(visible: boolean, doNotRefresh?: boolean): void;
    getMinScale(): number;
    getMaxScale(): number;
}

}
declare module "geocortex/infrastructure/gis/MapInfo" {
import { ServiceLayerInfo } from "geocortex/infrastructure/gis/ServiceLayerInfo";
import { Map } from "geocortex/essentials/Map";
import { Observable } from "geocortex/framework/observables";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { LayerInfo } from "geocortex/infrastructure/gis/LayerInfo";
export class MapInfo {
    serviceLayers: ServiceLayerInfo[];
    gcxMap: Map;
    map: esri.Map;
    markupLayer: Observable<esri.layers.GraphicsLayer>;
    constructor();
    static fromEsriMap(map: esri.Map): MapInfo;
    static fromViewerApp(app: ViewerApplication): MapInfo;
    static fromEssentialsMap(map: Map): MapInfo;
    getLayerInfos(): LayerInfo[];
    getTableInfos(): LayerInfo[];
    getGraphicsLayers(): esri.layers.GraphicsLayer[];
    findMapServiceById(id: string): ServiceLayerInfo;
}

}
declare module "geocortex/infrastructure/gis/ServiceLayerInfo" {
import { LayerInfo } from "geocortex/infrastructure/gis/LayerInfo";
import { MapService } from "geocortex/essentials/MapService";
export class ServiceLayerInfo {
    layers: LayerInfo[];
    tables: LayerInfo[];
    id: string;
    displayName: string;
    serviceLayer: esri.layers.Layer;
    gcxMapService: MapService;
    serviceLayerFunction: string;
    serviceType: string;
    isUserCreated: boolean;
    includeInLayerList: boolean;
    isExpanded: boolean;
    capabilities: string[];
    _esriLayerStateBackup: any[];
    private _delayedRefreshToken;
    constructor();
    static fromEsriLayer(layer: esri.layers.Layer): ServiceLayerInfo;
    static fromGcxMapService(mapService: MapService): ServiceLayerInfo;
    findLayerById(id: string): LayerInfo;
    /**
     * Gets whether the serviceLayer represented by this ServiceLayerInfo object is currently visible.
     */
    isVisible(): boolean;
    setVisibility(visible: boolean): void;
    /**
     * Gets the opacity of the service.
     */
    opacity(): number;
    /**
     * Sets the opacity of this service.
     */
    setOpacity(opacity: number): void;
    /**
     * Refreshes the map service by making a new request to the server.
     * @param refreshTimeoutMs An optional parameter which if specified, will cause the map refresh to occur after the specified timeout. Any previous refresh timeouts
     * will be cancelled when a new refresh timeout is set - ensuring that only one request goes out within the speicfied threshold. If undefined, the map refreshes immediately.
     * @param disableClientCaching An optional parameter which, if set will disable client caching on the service layer (if supported) prior to refreshing it. Defaults to false.
     */
    refresh(refreshTimeoutMs?: number, disableClientCaching?: boolean): void;
    /**
     * Returns whether or not this service supports layer visibility.
    */
    supportsLayerVisibility(): boolean;
    private _loadedDeferred;
    loaded(): dojo.Deferred;
}

}
declare module "geocortex/infrastructure/highlightedLabel/HighlightedLabelConfig" {
import { HighlightedLabelAnchor } from "geocortex/infrastructure/highlightedLabel/HighlightedLabelGraphic";
/**
 * Interface for the {@link HighlightedLabelGraphic} configuration settings.
 */
export interface HighlightedLabelConfig {
    /**
     * The id for the layer to which the highlighted label should be added.
     */
    layerId: string;
    /**
     * The map point associated with this highlighted label.
     */
    mapPoint: esri.geometry.Point;
    /**
     * The text for the highlighted label. May be separated by a "\n" to span across multiple lines.
     */
    text?: string;
    /**
     * The x-offset for the highlighted label if required.
     */
    labelXoffset?: number;
    /**
     * The y-offset for the highlighted label if required.
     */
    labelYoffset?: number;
    /**
     * The font family to use in the highlighted label. Defaults to "Arial".
     */
    fontFamily?: string;
    /**
     * The font size for the highlighted label text. Defaults to "12px".
     */
    fontSize?: string;
    /**
     * The corner radius if the highlight label is required to have rounded corners.
     */
    cornerRadius?: number;
    /**
     * The angle at which to place the highlighted label.
     */
    angle?: number;
    /**
     * The position to anchor the label in.
     */
    anchor?: HighlightedLabelAnchor;
    /**
     * The text color of the text on the highlight label.
     */
    textColor?: esri.Color;
    /**
     * The highlight color of the highlight label.
     */
    highlightColor?: esri.Color;
    /**
     * An outline symbol if needed for the highlighted label.
     */
    highlightOutlineSymbol?: esri.symbol.SimpleLineSymbol;
    /**
     * A boolean indicating whether this highlighted label will be in the style of a rectangular box or a callout with a circular id tag on the left and with an arrow pointing at the mapPoint.
     */
    calloutWithIdTag?: boolean;
    /**
     * The text that will appear in the id tag placeholder, if this highlight label is a calloutWithIdTag.
     */
    idTagText?: string;
    /**
     * The size (in pixels) of the callout arrow (width) for the highlight label if in callout mode.
     */
    calloutPixelSize?: number;
}

}
declare module "geocortex/infrastructure/highlightedLabel/HighlightedLabelGraphic" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { HighlightedLabelConfig } from "geocortex/infrastructure/highlightedLabel/HighlightedLabelConfig";
import { HighlightedLabelState } from "geocortex/infrastructure/highlightedLabel/HighlightedLabelState";
/**
 * The highlight label anchor modes. The label can be anchored at the bottom left, the center or as a callout.
 */
export enum HighlightedLabelAnchor {
    BOTTOM_LEFT = 0,
    MIDDLE = 1,
    CALLOUT = 2,
}
/**
 * Creates a highlighted label and adds it to a specified graphics layer on the map. The label could be a simple rectangle or a callout with an id text tag and a pointer pointing to the map point associated with this label.
 */
export class HighlightedLabelGraphic {
    app: ViewerApplication;
    highlightGraphic: esri.Graphic;
    highlightIdTagGraphic: esri.Graphic;
    highlightSymbol: esri.symbol.SimpleMarkerSymbol;
    highlightIdTagSymbol: esri.symbol.SimpleMarkerSymbol;
    textGraphics: esri.Graphic[];
    textSymbols: esri.symbol.TextSymbol[];
    graphicsLayer: esri.layers.GraphicsLayer;
    protected _config: HighlightedLabelConfig;
    protected _key: string;
    protected _height: number;
    protected _width: number;
    protected _padding: number;
    protected _calloutSizeWidthFraction: number;
    protected _tagHeightPercentage: number;
    constructor(config: HighlightedLabelConfig, app: ViewerApplication);
    getTextFontFamily(): string;
    getTextFontSize(): string;
    getWidth(): number;
    getTotalWidth(): number;
    getHeight(): number;
    getTotalHeight(): number;
    getMapPoint(): esri.geometry.Point;
    getConfig(): HighlightedLabelConfig;
    addToLayer(show?: boolean): void;
    removeFromLayer(destroy?: boolean): void;
    isVisible(): boolean;
    show(): HighlightedLabelGraphic;
    hide(): HighlightedLabelGraphic;
    update(mapPoint: esri.geometry.Point, text: string): void;
    refresh(newLabelText: string): void;
    moveToTop(): void;
    assignGraphicIdentifierKey(key: string, value: string): void;
    updateIdTagText(newId: string): void;
    setHighlightColor(color: esri.Color): void;
    setTextColor(color: esri.Color): void;
    /**
     * Exports the state of the label graphic, which can be used to recreate it later.
     */
    exportState(app: ViewerApplication): HighlightedLabelState;
    /**
     * Creates a HighlightedLabelGraphic from exported state (see exportState()).
     */
    static fromExportedState(state: HighlightedLabelState, app: ViewerApplication, prototype?: HighlightedLabelGraphic): Promise<HighlightedLabelGraphic>;
    protected _executeSetupRoutine(): void;
    protected setHighlightAnchor(): void;
    protected setTextAnchor(textLineIndex: number, verticalOffset: number): void;
    protected initializeHighlightDimensions(): void;
    protected initializeHighlightGraphic(): void;
    protected initializeHighlighteIdTagGraphic(): void;
    protected configureHighlightSymbol(highlightColor: esri.Color, highlightOutlineSymbol: esri.symbol.SimpleLineSymbol, fontSize: string): void;
    protected configureHighlightIdTagSymbol(highlightColor: esri.Color, fontSize: string): void;
    protected initializeTextGraphicsAndSymbols(): void;
    protected configureTextSymbol(textLineIndex: number, lineText: string, textColor: esri.Color, font: esri.symbol.Font, angle: number, verticalOffset: number): void;
    protected _processConfig(config: HighlightedLabelConfig): boolean;
}

}
declare module "geocortex/infrastructure/highlightedLabel/HighlightedLabelState" {
import { Feature } from "geocortex/infrastructure/webMap/Feature";
import { SimpleMarkerSymbol, TextSymbol, Color, SimpleLineSymbol } from "geocortex/infrastructure/webMap/Symbol";
import { Point } from "geocortex/infrastructure/webMap/Geometry";
import { HighlightedLabelAnchor } from "geocortex/infrastructure/highlightedLabel/HighlightedLabelGraphic";
/**
 * A serializable representation of a highlighted label.
 */
export interface HighlightedLabelState {
    highlightGraphic: Feature;
    highlightSymbol: SimpleMarkerSymbol;
    textGraphics: Feature[];
    textSymbols: TextSymbol[];
    layerId: string;
    mapPoint: Point;
    text?: string;
    labelXoffset?: number;
    labelYoffset?: number;
    fontFamily?: string;
    fontSize?: string;
    cornerRadius?: number;
    angle?: number;
    anchor?: HighlightedLabelAnchor;
    textColor?: Color;
    highlightColor?: Color;
    highlightOutlineSymbol?: SimpleLineSymbol;
}

}
declare module "geocortex/infrastructure/highlightedLabel/HighlightedLabelUtils" {
/**
 * Measures the actual rendered size of a text label in pixels. Adding an actual element to the document is expensive, and since the measurement tool will always ask for dimensions of
 * one single fixed font family and size, we cache dimensions for each letter of a font in a dictionary for later reuse. This ensures  only a limited number of page element additions
 * and removals no matter how many labels are measured (this may be a large number if we're measuring actual features on the map using layer actions).
 * @param labelStr The text label to measure label size for
 * @param fontFamily The font family to be applied to the text
 * @param size The size of the text in pixels
 * @return An object with the width and height of the speciified label
 */
export function getLabelSize(labelStr: string, fontFamily: string, fontSize: string, layerId: string): {
    width: number;
    height: number;
};
export function getTextLines(text: string): string[];
export function generateSvgHighlightLabelPath(width: any, height: any, radius: any, showPointer?: boolean, pointerWidth?: number): string;
export function generateSvgCirclePath(radius: number): string;

}
declare module "geocortex/infrastructure/identify/GraphicsLayerIdentifyProvider" {
import { ClickableLayerInfo } from "geocortex/infrastructure/clickableGraphics/ClickableLayerInfo";
import { IdentifyProviderBase } from "geocortex/infrastructure/identify/IdentifyProviderBase";
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
import { IdentifyArgs } from "geocortex/infrastructure/commandArgs/IdentifyArgs";
/**
 * Performs an identify operation with respect to a graphics layer.
 */
export class GraphicsLayerIdentifyProvider extends IdentifyProviderBase {
    /** Whether the identify operation has been cancelled */
    private _cancelled;
    /** Whether the provider is currently searching */
    private _searching;
    private _delayedFscOpen;
    private _numFractionalDigits;
    private _fscCollectionOpen;
    /**
     * Initialize the provider.
     * @param config The configuration object.
     */
    initialize(config: any): void;
    /**
     * Cancels the last search. May be called repeatedly.
     */
    cancelSearch(): void;
    /**
     * Performs the search. Returns a promise so that map tips can know when all identify tasks are complete.
     * Do not reject the promise even if the task fails, as this would cause other identify tasks to be cancelled.
     * @param fsc Where search results are to go.
     * @param searchText What to search for.
     */
    search(fsc: FeatureSetCollection, args: IdentifyArgs): Promise<any>;
    private _getClickableLayers(context);
    private _processLayerInfos(context);
    private _checkAndReturnLayerRestriction(layer, context);
    /** For each eligible layer, returns all graphics that intersect the supplied geometry */
    private _performSearch(context);
    /** Searches for matches within a graphics layer */
    private _searchGraphicsLayer(graphicsLayer, context);
    /** Intersects the graphics from a GraphicsLayer with identify geometry */
    private _findIntersectedGraphics(graphics, context);
    private _intersects(graphic, args);
    private _findMatchingEssentialsLayer(sourceLayer);
    /** Creates a geocortex feature set for graphics matching the identify parameters */
    private _createFeatureSet(graphics, sourceLayer);
    /** Configures feature attributes for the gcx feature set */
    private _processFeatureSet(featureSet, sourceLayer, context);
    /** Creates the attributes that describe a clickable feature */
    private _createAttributes();
    /** Sets the format strings for feature label and description, and update presentable values for attributes */
    private _processFeature(feature, layerInfo);
    private _addFeatureSetAttributes(attributes);
    private _populateFeatureAttributes(feature, layerInfo?);
    private _populateAttributesForMeasurementMarkup(feature?);
    /** Adds a feature set to the collection of results */
    private _addToResultsCollection(featureSet, fsc);
    private _getLayerInfoFromContext(gl, context);
    protected _getDisplayNameForGraphic(graphic: esri.Graphic, layerInfo?: ClickableLayerInfo): string;
    protected _isMeasurement(graphic: esri.Graphic): boolean;
    protected _clear(): void;
    protected _verifyNotCancelled(): void;
}

}
declare module "geocortex/infrastructure/identify/IdentifiableLayerInfo" {
/**
 * Provides information about the identifiable layers in a map service, or indicates if the map service itself is identifiable.
 * @param mapServiceId The id for the map service in question.
 * @param layerIds An optional parameter which lists all layers within the mapService that are identifiable.
 * @param mapServiceIdentifiable An optional boolean which, if true, indicates that the map service itself is identifiable, which may be in case of image services and the like.
 */
export interface IdentifiableLayerInfo {
    mapServiceId: string;
    layerIds?: string[];
    mapServiceIdentifiable?: boolean;
}

}
declare module "geocortex/infrastructure/identify/IdentifiableLayersInMapService" {
export interface IdentifiableLayersInMapService {
    mapServiceId: string;
    layerIds: string[];
}

}
declare module "geocortex/infrastructure/identify/IdentifyProviderBase" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
import { IdentifyArgs } from "geocortex/infrastructure/commandArgs/IdentifyArgs";
/**
 * Very similar to the SearchProviderBase.
 */
export abstract class IdentifyProviderBase {
    app: ViewerApplication;
    libraryId: string;
    isEnabled: boolean;
    pixelTolerance: number;
    polygonPixelTolerance: number;
    constructor(app: ViewerApplication, libraryId: string);
    /**
     * Initialize the provider.
     * @param config The configuration object.
     */
    abstract initialize(config: any): void;
    /**
     * Performs the search.
     * New implementations should return a promise to take advantage of 2.8 map tip enhancements,
     * though methods that do not will still be supported
     * @param fsc Where search results are to go.
     * @param searchText What to search for.
     */
    abstract search(fsc: FeatureSetCollection, args: IdentifyArgs): void | Promise<any>;
    /**
     * Cancels the last search. May be called repeatedly.
     */
    abstract cancelSearch(): void;
    /**
     * Gets a language resource from the Application's resource dictionary, given a key, and optional locale.
     * Returns null if the resource does not exist.
     * @param key The resource key.
     * @param locale The locale of the resource to fetch. Defaults to the current application locale.
     */
    getResource(resourceKey: string, locale?: string): string;
    /**
     * Creates a tolerance envelope around a point. Only applies to points; other geometries are returned as-is.
     * @param geometry The geometry to create an envelope for.
     * @param pixelTolerance A positive integer that defines the maximum number of pixels away from the point geometry. Determines the width of the generated envelope.
     */
    protected applyTolerance(geometry: esri.geometry.Geometry, pixelTolerance: number): esri.geometry.Geometry;
}

}
declare module "geocortex/infrastructure/identify/IdentifyUtils" {
import { MapService } from "geocortex/essentials/MapService";
import { Layer } from "geocortex/essentials/Layer";
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
import { Application } from "geocortex/framework/application/Application";
/**
 * Takes an Essentials map service object, and figures out all the layers that should be identifiable,
 * and returns a list of layer IDs representing those layers.
 * @param mapService The MapService associated with the layer.
 * @param layerRestriction
 * @param geometryTypes Geometry types to include in the returned collection.
 * @param onlyVisibleLayers Only identify the layers that are currently toggled as visible in the Layer List.
 * @param onlyVisibleMapServices Only identify the mapservices that are currently toggled as visible.
 * @param layersInVisibleScaleRangeOnly Only identify layers within the visible scale range.
 * @param layersToInclude If undefined, all layers are included by default. If defined, functions as an array of the layer IDs we want to explictly
 * check to include - any layer ID not listed is not included regardless of other options.
 */
export function getIdentifyLayerIds(mapService: MapService, layerRestriction: (layer: Layer) => boolean, geometryTypes?: string[], onlyVisibleLayers?: boolean, onlyVisibleMapServices?: boolean, layersInVisibleScaleRangeOnly?: boolean, layersToInclude?: string[], excludeRasterLayers?: boolean): any[];
/**
 * Get all the layer definitions from the mapService for the layers
 * whose ids are in layerIds.
 * @param mapService The MapService
 * @param layerIds The layer Ids
 * @returns An array of layer definitions
 */
export function getLayerDefinitions(mapService: MapService, layerIds: string[]): string[];
/**
 * Get all the dynamic layer infos from the mapService for the layers
 * which ids are in layerIds.
 * @param mapService The MapService
 * @param layerIds The layer ids
 * @returns An array of DynamicLayerInfo
 */
export function getDynamicLayerInfos(mapService: MapService, layerIds: string[]): esri.layers.DynamicLayerInfo[];
/**
 * Converts a set an array of identify results to a feature set collection.
 */
export function appendToFeatureSetCollection(identifyResults: esri.tasks.IdentifyResult[], featureSetCollection: FeatureSetCollection, mapService: MapService, app: Application): FeatureSetCollection;

}
declare module "geocortex/infrastructure/identify/LayerDescriptor" {
/**
 * Identifies a layer or a service layer (mapService) uniquely.
 * @param mapServiceId The id of the map service
 * @param layerId The id of the layer (if applicable). This will not be set in case we're describing a service layer (mapService).
 */
export interface LayerDescriptor {
    mapServiceId: string;
    layerId?: string;
}

}
declare module "geocortex/infrastructure/identify/MapIdentifyTask" {
import { MapService } from "geocortex/essentials/MapService";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { IdentifiableLayerInfo } from "geocortex/infrastructure/identify/IdentifiableLayerInfo";
import { Layer } from "geocortex/essentials/Layer";
export interface MapIdentifyProgressCallback {
    (task: MapIdentifyTask, identifyResults: esri.tasks.IdentifyResult[], service: MapService): void;
}
export interface MapIdentifyCompleteCallback {
    (task: MapIdentifyTask): void;
}
export interface MapIdentifyErrorCallback {
    (task: MapIdentifyTask, error: Error, service: MapService): void;
}
export class MapIdentifyTask {
    private _identifyTaskExecutedCount;
    private _identifyTaskCompletedCount;
    private _identifyTaskErrorCount;
    private _taskExecutionComplete;
    private _isCancelled;
    app: ViewerApplication;
    map: esri.Map;
    tag: any;
    extent: esri.geometry.Extent;
    width: number;
    height: number;
    topMostLayerOnly: boolean;
    returnGeometry: boolean;
    visibleLayersOnly: boolean;
    visibleMapServicesOnly: boolean;
    layersInVisibleScaleRangeOnly: boolean;
    pixelTolerance: number;
    polygonPixelTolerance: number;
    allServicesInError: boolean;
    mapServicesAndLayersToIdentify: IdentifiableLayerInfo[];
    restrictRasterIdentifyToPoint: boolean;
    delayedFSCOpen: any;
    layerRestriction: (layer: Layer) => boolean;
    constructor(map: esri.Map, app?: ViewerApplication);
    private _checkAndReturnLayerRestriction();
    execute(geometry: esri.geometry.Geometry, progressCallback: MapIdentifyProgressCallback, completeCallback: MapIdentifyCompleteCallback, errorCallback: MapIdentifyErrorCallback, previouslySimplified?: boolean): void;
    private _handleWMSLayer(mapService, identifyParams, layerRestriction, progressCallback, completeCallback, errorCallback);
    private _handleLayerLegacy(mapService, baseIdentifyParams, layerRestriction, progressCallback, completeCallback, errorCallback);
    private _handleLayer(mapService, identifyParams, layerRestriction, progressCallback, completeCallback, errorCallback);
    private _assignSpatialReferences(results);
    private _getLayersToIdentifyForMapService(mapService, geometryTypes, layerRestriction, excludeRasterLayers);
    private _handleFeatureLayer(geometry, mapService, featureLayer, identifyParams, layerRestriction, progressCallback, completeCallback, errorCallback);
    private _queryResultToIdentifyResults(result, layerId, layerName, displayFieldName);
    private _conditionallyInvokeCompleteCallback(_this, completeCallback);
    cancel(): void;
}

}
declare module "geocortex/infrastructure/identify/MapIdentifyTaskIdentifyProvider" {
import { IdentifyProviderBase } from "geocortex/infrastructure/identify/IdentifyProviderBase";
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
import { IdentifyArgs } from "geocortex/infrastructure/commandArgs/IdentifyArgs";
import { MapService } from "geocortex/essentials/MapService";
/**
 * An implementation of the IdentifyProvider using the MapIdentifyTask.
 */
export class MapIdentifyTaskIdentifyProvider extends IdentifyProviderBase {
    private _identifyTask;
    protected defaultPixelTolerance: number;
    protected defaultPolygonPixelTolerance: number;
    private _pixelTolerance;
    private _polygonPixelTolerance;
    private _topMostLayerOnly;
    private _returnGeometry;
    private _visibleLayersOnly;
    private _layersInVisibleScaleRangeOnly;
    initialize(config: any): void;
    /**
     * Execute the search. Returns a promise so that map tips can know when all identify tasks are complete.
     * Do not reject the promise even if the task fails, as this would cause other identify tasks to be cancelled.
     */
    search(fsc: FeatureSetCollection, args: IdentifyArgs): Promise<any>;
    identifyTaskProgress(sender: {
        tag: FeatureSetCollection;
    }, results: esri.tasks.IdentifyResult[], mapService: MapService): void;
    identifyTaskComplete(sender: {
        tag: FeatureSetCollection;
    }): void;
    identifyTaskError(sender: {
        tag: FeatureSetCollection;
    }, error: Error, mapService: MapService): void;
    cancelSearch(): void;
}

}
declare module "geocortex/infrastructure/identify/RasterIdentifyTask" {
import { MapService } from "geocortex/essentials/MapService";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { IdentifiableLayerInfo } from "geocortex/infrastructure/identify/IdentifiableLayerInfo";
export interface RasterIdentifyProgressCallback {
    (task: RasterIdentifyTask, identifyResults: esri.tasks.ImageServiceIdentifyResult, service: MapService): void;
}
export interface RasterIdentifyCompleteCallback {
    (task: RasterIdentifyTask): void;
}
export interface RasterIdentifyErrorCallback {
    (task: RasterIdentifyTask, error: Error, service: MapService): void;
}
export class RasterIdentifyTask {
    private _identifyTaskExecutedCount;
    private _identifyTaskCompletedCount;
    private _identifyTaskErrorCount;
    private _taskExecutionComplete;
    private _isCancelled;
    /**
     * Maintains a cache of field metadata (in the form of an esri FeatureLayer object) for each image service
     * that we identify on. This is used for formatting field values for raster catalog items.
     */
    private _featureLayers;
    app: ViewerApplication;
    map: esri.Map;
    tag: any;
    delayedFSCOpen: any;
    mapServicesAndLayersToIdentify: IdentifiableLayerInfo[];
    constructor(map: esri.Map, app?: ViewerApplication);
    getFeatureLayer(imageService: MapService): esri.layers.FeatureLayer;
    execute(geometry: esri.geometry.Geometry, progressCallback: RasterIdentifyProgressCallback, completeCallback: RasterIdentifyCompleteCallback, errorCallback: RasterIdentifyErrorCallback, previouslySimplified?: boolean): void;
    private _getIdentifyGeometry(identifyGeometry);
    private _conditionallyInvokeCompleteCallback(_this, completeCallback);
    cancel(): void;
    protected _fetchFieldMetadata(imageService: MapService): Promise<void>;
}

}
declare module "geocortex/infrastructure/identify/RasterIdentifyTaskIdentifyProvider" {
import { IdentifyProviderBase } from "geocortex/infrastructure/identify/IdentifyProviderBase";
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
import { IdentifyArgs } from "geocortex/infrastructure/commandArgs/IdentifyArgs";
import { MapService } from "geocortex/essentials/MapService";
/**
 * An implementation of the IdentifyProvider using the RasterIdentifyTask.
 */
export class RasterIdentifyTaskIdentifyProvider extends IdentifyProviderBase {
    private _identifyTask;
    initialize(config: any): void;
    search(fsc: FeatureSetCollection, args: IdentifyArgs): Promise<any>;
    identifyTaskProgress(sender: {
        tag: FeatureSetCollection;
    }, results: esri.tasks.ImageServiceIdentifyResult, mapService: MapService): void;
    identifyTaskComplete(sender: {
        tag: FeatureSetCollection;
    }): void;
    identifyTaskError(sender: {
        tag: FeatureSetCollection;
    }, error: Error, mapService: MapService): void;
    cancelSearch(): void;
}

}
declare module "geocortex/infrastructure/identify/RasterIdentifyUtils" {
import { MapService } from "geocortex/essentials/MapService";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
import { EsriFieldTypes } from "geocortex/essentials/Field";
import { Feature } from "geocortex/infrastructure/Feature";
import { Layer } from "geocortex/essentials/Layer";
/**
 * Converts a set an array of identify results to a feature set collection.
 */
export class RasterIdentifyUtils {
    private _mapService;
    private _app;
    private _libraryId;
    includeCatalogItems: boolean;
    includeMosaicDatasetValues: boolean;
    featureLayer: esri.layers.FeatureLayer;
    constructor(ms: MapService, app: ViewerApplication, libraryId: string);
    appendToFeatureSetCollection(imageServiceIdentifyResults: esri.tasks.ImageServiceIdentifyResult, featureSetCollection: FeatureSetCollection): FeatureSetCollection;
    _parseAttributeValue(attributeValue: string, attributeEsriType: EsriFieldTypes): number;
    _getFieldTypeInformation(attributeValue: string): EsriFieldTypes;
    _createAndAddGcxFeatureSet(displayFieldName: string, fsc: FeatureSetCollection, features: esri.Graphic[], geometryType: string, sr: esri.SpatialReference, featuresLabelFormat: string, fieldsOverride: esri.layers.Field[]): void;
    _createAndAddGcxFeatureSetFromEsriFeatureSet(efs: esri.tasks.FeatureSet, featuresLabelFormat: string, fsc: FeatureSetCollection, fieldsOverride: esri.layers.Field[]): void;
    _convertEsriFeatureToGcxFeature(labelFormat: string, graphic: esri.Graphic, layer?: Layer, resolveLayerFields?: boolean, allowUnsafeContent?: boolean): Feature;
}

}
declare module "geocortex/infrastructure/identify/WorkflowIdentifyTask" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { Workflow } from "geocortex/essentials/Workflow";
import { FeatureSet } from "geocortex/infrastructure/FeatureSet";
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
export interface WorkflowIdentifyProgressCallback {
    (task: WorkflowIdentifyTask, features: FeatureSet, workflow: Workflow): void;
}
export interface WorkflowIdentifyCompleteCallback {
    (task: WorkflowIdentifyTask): void;
}
export interface WorkflowIdentifyErrorCallback {
    (task: WorkflowIdentifyTask, error: Error, workflow: Workflow): void;
}
export class WorkflowIdentifyTask {
    app: ViewerApplication;
    delayFSCOpen: boolean;
    fsc: FeatureSetCollection;
    guid: string;
    private _isCancelled;
    /**
     * Maintains a cache of field metadata (in the form of an esri FeatureLayer object) for each image service
     * that we identify on. This is used for formatting field values for raster catalog items.
     */
    private _featureLayers;
    private _workflows;
    constructor(app: ViewerApplication, workflows: Workflow[], fsc: FeatureSetCollection);
    execute(geometry: esri.geometry.Geometry, progressCallback: WorkflowIdentifyProgressCallback, completeCallback: WorkflowIdentifyCompleteCallback, errorCallback: WorkflowIdentifyErrorCallback): void;
    cancel(): void;
}

}
declare module "geocortex/infrastructure/identify/WorkflowIdentifyTaskIdentifyProvider" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { IdentifyProviderBase } from "geocortex/infrastructure/identify/IdentifyProviderBase";
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
import { FeatureSet } from "geocortex/infrastructure/FeatureSet";
import { IdentifyArgs } from "geocortex/infrastructure/commandArgs/IdentifyArgs";
import { Workflow } from "geocortex/essentials/Workflow";
import { WorkflowIdentifyTask } from "geocortex/infrastructure/identify/WorkflowIdentifyTask";
export class WorkflowIdentifyTaskIdentifyProvider extends IdentifyProviderBase {
    app: ViewerApplication;
    private _identifyTask;
    private _workflows;
    private _workflowSuffix;
    initialize(config: any): void;
    search(fsc: FeatureSetCollection, args: IdentifyArgs): Promise<any>;
    identifyTaskProgress(sender: WorkflowIdentifyTask, fs: FeatureSet, workflow: Workflow): void;
    identifyTaskComplete(sender: WorkflowIdentifyTask): void;
    identifyTaskError(sender: WorkflowIdentifyTask, error: Error, workflow: Workflow): void;
    cancelSearch(): void;
}

}
declare module "geocortex/infrastructure/integration/ComponentFrameInfo" {
/**
 * Describes a remote component to listen to component messages from.
 */
export interface ComponentFrameInfo {
    /** The html element selector to target this specific component.  */
    elementSelector: string;
    /** The id of the integration provider that is hosted by this component. */
    name: string;
    /** The transport name of the messages, if applicable. */
    transportName?: string;
    /** The window hosting the component, if applicable. */
    contentWindow?: Window;
    /** The uri of the viewpoint indicator for 3rd party maps, if applicable. */
    viewpointIndicatorUri?: string;
}

}
declare module "geocortex/infrastructure/integration/ComponentIndicatorUpdatedMessage" {
export interface ComponentIndicatorUpdatedMessage {
    /** The id of the indicator that was updated */
    id: string;
    /** The center of the indicator */
    geometry: esri.geometry.Geometry;
}

}
declare module "geocortex/infrastructure/integration/ComponentInitializationMessage" {
import { MapViewpointMessage } from "geocortex/infrastructure/integration/MapViewpointMessage";
/**
 * Represents a message that the viewer can send to a component when it is initializing.
 */
export interface ComponentInitializationMessage {
    /** Whether or not this component has a previous state or it is opening for the first time. */
    hasPreviousState: boolean;
    /** The previous positional state of the 3rd-party component, provided when the component is not synced. */
    viewpoint: MapViewpointMessage;
    /** Whether or not the component is in sync with the viewer. */
    sync: boolean;
}

}
declare module "geocortex/infrastructure/integration/ComponentStateMessage" {
import { ComponentViewpointMessage } from "geocortex/infrastructure/integration/ComponentViewpointMessage";
/**
 * Represents a message that a 3rd-party component can send to notify the viewer
 * of the component state when disconnecting.
 */
export interface ComponentStateMessage {
    /** The name of the component. */
    id: string;
    /** Whether or not the component is in sync with the viewer. */
    sync: boolean;
    /** The positional state of the 3rd-party component. */
    viewpoint: ComponentViewpointMessage;
}

}
declare module "geocortex/infrastructure/integration/ComponentUpdateGraphicMessage" {
export interface ComponentUpdateGraphicMessage {
    /** The id of the graphic to add/update */
    id: string;
    /** The geometry of the graphic */
    geometry: esri.geometry.Geometry;
    /** The symbol of the graphic */
    symbol: esri.symbol.Symbol;
}

}
declare module "geocortex/infrastructure/integration/ComponentViewpointMessage" {
import { MapPosition } from "geocortex/infrastructure/integration/MapPosition";
/**
 * Represents a message that a 3rd-party component can send to notify the viewer (and other components)
 * of changes to positional state.
 */
export interface ComponentViewpointMessage {
    /** The name of the component doing the update. */
    updaterName: string;
    /** The centerpoint of the components viewpoint. */
    center: MapPosition;
    /** The scale of the current viewpoint. */
    scale: number;
    /** The 2-dimensional extent of the viewpoint, if applicable. */
    extent?: esri.geometry.Extent;
    /** Heading value for the current viewpoint, if applicable. */
    heading?: number;
    /** Pitch value for the current viewpoint, if applicable. */
    pitch?: number;
}

}
declare module "geocortex/infrastructure/integration/MapPosition" {
/**
 * Describes a simple format for 2D or 3D positions to be transmitted in.
 */
export interface MapPosition {
    /** The `x` coordinate of the position. */
    x: number;
    /** The `y` coordinate of the position. */
    y: number;
    /** The `z` coordinate of the position, if applicable. */
    z?: number;
    /**
     * The {@link esri.SpatialReference} of the position.
     * Describes the coordinate system that the point is represented in.
     */
    spatialReference?: esri.SpatialReference;
}

}
declare module "geocortex/infrastructure/integration/MapViewpointMessage" {
import { MapPosition } from "geocortex/infrastructure/integration/MapPosition";
/**
 * Represents the viewpoint of the viewer's map.
 */
export interface MapViewpointMessage {
    /** The component that last updated the viewpoint. */
    updaterName: string;
    /** The current extent of the viewer's map in its own {@link esri.SpatialReference}. */
    extent: esri.geometry.Extent;
    /** The 2- or 3- dimensional position of the viewpoint's center. */
    position: MapPosition;
    /** The scale of the current viewpoint. */
    scale: number;
    /** The heading of the current viewpoint. */
    heading: number;
    /** The pitch of the viewpoint. */
    pitch: number;
    /** The time that the viewpoint message originated. */
    timestamp?: number;
}

}
declare module "geocortex/infrastructure/layerCatalog/LayerCatalogFilterProviderBase" {
import { Observable, ObservableCollection } from "geocortex/framework/observables";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
/** An interface representing an item in a layer catalog. */
export interface ILayerCatalogEntry {
    id: string;
    displayName: string;
    type: string;
    parent: ILayerCatalogEntry;
    expanded: Observable<boolean>;
    visible: Observable<boolean>;
    entries: ObservableCollection<ILayerCatalogEntry>;
}
/** A base class for providing custom filtering logic for a layer catalog. */
export class LayerCatalogFilterProviderBase {
    app: ViewerApplication;
    libraryId: string;
    constructor(app: ViewerApplication, libraryId: string);
    /**
     * Initialize the provider.
     * @param config The configuration object.
     */
    initialize(config: any): void;
    /**
     * Performs the search.
     * @param text The text to filter the catalog entries on.
     * @param entries The catalog entries to filter.
     */
    filter(text: string, entries: ObservableCollection<ILayerCatalogEntry>): Promise<void>;
}

}
declare module "geocortex/infrastructure/layerList/LayerList" {
import { LayerListNode } from "geocortex/infrastructure/layerList/LayerListNode";
import { AppInfo } from "geocortex/infrastructure/gis/AppInfo";
import { MapInfo } from "geocortex/infrastructure/gis/MapInfo";
import { LayerListFolderItem } from "geocortex/infrastructure/layerList/LayerListFolderItem";
import { ServiceLayerInfo } from "geocortex/infrastructure/gis/ServiceLayerInfo";
import { LayerListConfigurationParams } from "geocortex/infrastructure/layerList/LayerListConfigurationParams";
import { MapService } from "geocortex/essentials/MapService";
import { LayerListItem } from "geocortex/infrastructure/layerList/LayerListItem";
import { Layer } from "geocortex/essentials/Layer";
import { FilterControlComponent } from "geocortex/infrastructure/ui/components/FilterControl/FilterControlComponent";
/**
 * Represents the site's layer list, also known as table of contents.
 */
export class LayerList extends LayerListNode {
    /** Whether or not the layer list was successfully initialized. */
    layerListInitialized: boolean;
    /**
     * The exception that occurred if the layer list could not be initialized.
     */
    layerListInitializationFailure: Error;
    /**
     * Occurs when initialization of the layer list fails.
     * @event
     */
    onLayerListInitializationFailed: (error: Error) => void;
    /**
     * Occurs when initialization of the layer list succeeds with a response from the REST endpoint. Depending on the API,
     * this response may actually be an error message served as a correct HTTP response.
     * @event
     */
    onLayerListInitialized: (sender: LayerList) => void;
    /**
     * A boolean indicating whether legend integration should be enabled for this layer list
     */
    enableLegendIntegration: boolean;
    /**
     * A boolean indicating whether swatches are to be shown for invisible layers for this layer list
     */
    onlyShowSwatchesOnVisibleLayers: boolean;
    /**
     * A boolean indicating whether visibility all parent items should be automatically activated/set to true when the
     * visibility of an item is set to true. In effect, this setting ensures that an item when set to visible will necessarily
     * be effectively visible as well.
     */
    autoActivateAncestorVisibilities: boolean;
    /**
     * The icon Uri to be set if a layer fails to initialize. This is an optional property and will only be used if configured during initialization
     */
    serviceLoadFailureIconUri: string;
    /**
     * The icon tooltip to be set if a layer fails to initialize. This is an optional property and will only be used if configured during initialization
     */
    serviceLoadFailureIconTooltip: string;
    /**
     * The swatch element to be displayed if an item contains multiple legend items. If only one legend item exists, that will be used as the swatch element. If
     * multiple swatch elements exist but this parameter is not configured, the first legend item swatch element will be used.
     */
    multiLegendSwatchElement: string;
    /**
     * The legend icon tooltip to use when only a single legend item exists for a layer. This is optional and will be used only if set.
     */
    singleLegendIconTooltip: string;
    /**
    * The legend icon tooltip to use when only a single legend item exists for a layer. This is optional and will be used only if set.
    */
    multiLegendIconTooltip: string;
    /**
     * Determines whether layer icons are enabled or not. False by default. If true, layer icons will be populated for layer items which have them configured and
     * which do not have a legend
     */
    enableLayerIcons: boolean;
    /**
     * The intermediary application info object for the layer list. Compatible with WAB
     */
    appInfo: AppInfo;
    /**
     * The intermediary map info object for the layer list. Compatible with WAB.
     */
    mapInfo: MapInfo;
    /**
     * The filter control view model.
     */
    filterControlComponent: FilterControlComponent<LayerListItem>;
    /**
     * The url for the layer list rest endpoint. If null or undefined, the configurable layer list will default to standard simple layer list behaviour
     */
    url: string;
    /**
     * If set to true, then changing items' visibilities will not update the map until this setting is turned off,
     * at which point all the new visibility settings will be applied. This setting is useful when changing the
     * visibilities of mulitple items at once, since it avoid unnecessary map updates.
     */
    suspendMapUpdates: boolean;
    /** Internal members */
    _libraryId: string;
    _addedFolderReferences: LayerListFolderItem[];
    _handledMapServiceReferences: ServiceLayerInfo[];
    _allMapServiceReferences: ServiceLayerInfo[];
    _outOfFolderMapServiceReferences: ServiceLayerInfo[];
    /** Private members */
    private _initializing;
    private _groupByOperationalAndBase;
    /** User added layers destination folder. */
    private _userAddedLayersFolder;
    private _userAddedLayersDestinationId;
    private _layerListRestEndpoint;
    private _suspendMapUpdates;
    private _itemsExpandedByFilter;
    private _filterControlId;
    /**
     * Creates a new instance of the (@link LayerList} class
     * @param map The {@link geocortex.essentials.models.MapInfo} that the layer list belongs to
     * @param url Optional. The URL for the essentials layer list rest endpoint if the layer list rest endpoint is not available
     * @param layerListRestEndpoint Optional. The layer list rest endpoint if available. If this is available, the url will not be used
     * @param options Optional. An object containing options to configure the layer list
     */
    constructor(appInfo: AppInfo, url?: string, layerListRestEndpoint?: RestLayerList, options?: LayerListConfigurationParams);
    /**
     * Initializes this instance of the {@link LayerList} class.
     * This is an asynchronous method, you may subscribe to the {@link onLayerListInitialized}
     * and {@link onLayerListInitializationFailed} events for completion information.
     */
    initialize(): void;
    /**
     * Adds a user-added layer to the Layer List. Returns true if the layer was added, false otherwise.
     */
    addUserAddedServiceLayer(serviceLayer: MapService | esri.layers.Layer | ServiceLayerInfo, index?: number): boolean;
    /**
     * Removes the specified service layer from the layer list. Since the layer list is configurable, the sub layers of a particular service layer may be spread out across
     * the list so we need to check all items to ensure that the service layer is completely removed from the list. Returns true if the layer was found and removed, false otherwise.
     */
    removeServiceLayer(servicelayer: MapService): boolean;
    removeServiceLayer(serviceLayer: esri.layers.Layer): boolean;
    removeServiceLayer(servicelayer: ServiceLayerInfo): boolean;
    private _isItemSafeToBeRemoved(listItem, sl);
    /**
     * Updates the layer list with the adds and removes for the given service. It will not add duplicate items.
     * @param mapService The {@link essentials.MapService} or {@link: infrastructure.gis.ServiceLayerInfo} that contains the updates.
     * @param newItems An array of {@link essentials.Layer} items that are being added to the layer list.
     * @param oldItems An array of {@link essentials.Layer} items that are being removed from the layer list.
     * @returns A boolean of whether or not the update was successful.
     */
    updateServiceLayer(mapService: MapService | ServiceLayerInfo, newItems?: Layer[], oldItems?: Layer[]): boolean;
    /**
     * Updates the legend items in the layer list for a given map service. Returns true if the layer was added, false otherwise.
     * @param mapService That map service that needs to have its layer list item updated.
     */
    updateServiceLayerLegendSwatch(mapService: MapService): boolean;
    /**
     * Obtains the index value within the user-added layers folder for a given service layer. Returns the value of the index.
     * If the index value does not exist, returns null.
     * @param serviceLayer That service layer whose index number within the user-added layers folder needs to be determined.
     */
    getUserAddedLayersFolderIndex(serviceLayer: any): number;
    /**
     * This is an internal function, though not private to this class. The configurable layer list initializes all layers and filters layer visibilities based on configuration settings
     * and preset rules. In order to avoid flickers on the map and excessive visibility requests, all visibilities are applied at once after processing is complete. This function
     * should be invoked in order to finally apply these visibilities after all processing is completed.
     * @private
     */
    _applyDeferredItemVisibilities(LLItemArray: LayerListItem[]): void;
    private _enableDeferredItemVisibilities(items);
    /** @private */
    private _layerListInitializationErrorHandler(error);
    /** @private */
    private _layerListInitializationHandler(result);
    /** @private */
    private _configureLayerListFromMapInfo(mapInfo, successCallback, errorCallback);
    /**
     * Apply configuration from the layer list's REST endpoint.
     * @param rest The serialized layer list configuration from the rest endpoint.
     * @param successCallback Called when the configuration is successfully applied to this layer list.
     * @param errorCallback Called when an error occurs while attempting to apply the configuration to this layer list.
     * @private
     */
    private _configureLayerListFromRestResponse(rest, successCallback, errorCallback);
    /**
     * Creates one or more layer list items from the service layer information for the item(s). Multiple items are possible only when the parent mapService is configured
     * to not be included in the layer list whereas it's children are included. This is an edge case we need to support for backwards compatibility.
     * @param jsonRestItem The JSON rest item.
     * @param parent The {@link LayerListNode} representing the parent of the created item. If provided, the item's parent will be set to this value.
     * @param isUserAddedLayer A boolean indicating if this is a user added layer. If it is then it will be included in all themes. Default is false.
     * @return A new {@link LayerList} item corresponding to the input.
     */
    private _generateLayerListItemsFromServiceLayer(serviceLayerInfo, parent?, isUserAddedLayer?);
    private _handleGraphicsLayerItem(serviceLayerInfo, listItem);
    /**
     * Creates a layer list item from the JSON representation of the item.
     * @param jsonRestItem The JSON rest item.
     * @param parent The {@link LayerListNode} representing the parent of the created item. If provided, the item's parent will be set to this value.
     * @return A new {@link LayerList} item corresponding to the input.
     */
    private _createLayerListItemFromRestResult(jsonRestItem, parent?);
    /** @private */
    private _subItemIncludedInLayerList(subItems);
    /**
     * @private Performs any processing that may be needed for items
     */
    private _processItem(item, jsonRestItem);
    /**
     * @private Edge case: If a tiled map service has nested sublayers, then intermediary layers will be converted into folders. These folders should have "canNotAssignVisibility"
     * set to true because all their children will be layers for which we cannot assign visibility and which in effect, cannot be controlled by the parent.
     */
    private _disableFolderIfParentTiled(item);
    /** @private */
    private _generateThemeSettingsForCoreFolder(folder, isUserDefinedLayersFolder?);
    /** @private */
    private _applyInitialLayerTheme();
    private _processEligibleSingleMapServiceFolders();
    private _setupOpacityBindingsForParentsOfHiddenItemsWithOpacityBindings();
    /**
     * Indicates whether the given item is effectively visible in the layer list.
     */
    private isEffectivelyDisplayed(item);
    private _getFoldersContainingSingleMapService();
    private _filterEligibleSingleMsFolders(sourceFolders);
    private _filterTopLevelFolders(sourceFolders);
    private _selectDeepestLevelSingleMapServiceFolders(sourceFolders);
    private _allFoldersDescendantsOf(targetFolder, foldersToCheck);
    private _allFoldersAncestorsOf(targetFolder, foldersToCheck);
    private _allFoldersAncestorsOrDescendantsOf(targetFolder, foldersToCheck);
    private _noChildItemsWithMapService(ms, foldersToCheck);
    private _onlyFolderItems(items);
    /** See comments on GVH-4329 */
    private _processUnhandledMapServices();
    /**
     * Add layer list items to the indexed position in the user added layers folder.
     * If no index parameter is included, add the item to the top of the folder.
     * If the user added layers folder is not designated, items will just be added to the top of the layer list.
     * @private
     * @param items Array of layer list items.
     * @returns Boolean for whether or not all items were added successfully (passing validation).
     */
    private _addItemsToUserAddedFolder(items, index?);
    private _handleFilterChanged(args);
}

}
declare module "geocortex/infrastructure/layerList/LayerListConfigurationParams" {
export interface LayerListConfigurationParams {
    /**
    * A boolean indicating whether legend integration should be enabled for this layer list
    */
    enableLegendIntegration: boolean;
    /**
    * A boolean indicating whether displaying swatches solely for visible layers should be enabled for this layer list
    */
    onlyShowSwatchesOnVisibleLayers: boolean;
    /**
     * A boolean indicating whether visibility all parent items should be automatically activated/set to true when the
     * visibility of an item is set to true. In effect, this setting ensures that an item when set to visible will necessarily
     * be effectively visible as well.
     */
    autoActivateAncestorVisibilities: boolean;
    /**
     * A boolean indicating whether to group items by operational and base maps. Only applicable for Essentials < v4.2 - i.e. in non 'configurable' mode
     */
    groupByOperationalAndBase: boolean;
    /**
     * A boolean which etermines whether layer icons are enabled or not. False by default. If true, layer icons will be populated for layer items which have
     * them configured and which do not have a legend
     */
    enableLayerIcons: boolean;
    /**
     * The icon uri to be set if a layer fails to initialize. This is an optional property and will only be used if configured during initialization
     */
    serviceLoadFailureIconUri: string;
    /**
     * The icon tooltip to be set if a layer fails to initialize. This is an optional property and will only be used if configured during initialization
     */
    serviceLoadFailureIconTooltip: string;
    /**
     * The legend icon tooltip to use when only a single legend item exists for a layer. This is optional and will be used only if set.
     */
    singleLegendIconTooltip: string;
    /**
    * The legend icon tooltip to use when only a single legend item exists for a layer. This is optional and will be used only if set.
    */
    multiLegendIconTooltip: string;
    /**
    * The swatch element to be displayed if an item contains multiple legend items. If only one legend item exists, that will be used as the swatch element. If
    * multiple swatch elements exist but this parameter is not configured, the first legend item swatch element will be used.
    */
    multiLegendSwatchElement: string;
}

}
declare module "geocortex/infrastructure/layerList/LayerListFolderItem" {
import { LayerListItem } from "geocortex/infrastructure/layerList/LayerListItem";
import { LayerThemeSetting } from "geocortex/essentials/LayerThemeSetting";
import { ServiceLayerInfo } from "geocortex/infrastructure/gis/ServiceLayerInfo";
import { LayerList } from "geocortex/infrastructure/layerList/LayerList";
import { LayerTheme } from "geocortex/essentials/LayerTheme";
/**
 * A category (a.k.a. folder) item in the layer list.
 */
export class LayerListFolderItem extends LayerListItem {
    /**
     * A collection containing the layer theme settings for this category. Theme settings for mapServices and layers will reside in their respective geocortex layers.
     */
    layerThemeSettings: LayerThemeSetting[];
    /**
     * An array of mapServices this folder contains. This information is important for establishing mapService visibility bindings and deciding if transparency sliders should be displayed
     */
    containedMapServices: ServiceLayerInfo[];
    /**
     * A boolean indicating whether this folder item was originally configured visible or not. We need to know what state to return to while applying layer themes
     */
    configuredVisible: boolean;
    /**
     * A boolean indicating if this folder has been user created (not to be confused with the User Added Layers folder)
     * If a folder has been user created, we do not apply theme changes to it. The state of this folder remains consistant across layer theme changes
     */
    isUserCreated: boolean;
    private _layerVisibilityHandle;
    private _themeChangingHandle;
    private _themeChangedHandle;
    /**
     * Initializes a new instance of the {@link LayerListFolderItem} class.
     */
    constructor(id: string, name: string, layerList: LayerList);
    /**
     * Set the visibility of this category in the layer list
     */
    setVisibility(visible: boolean): void;
    refreshOnDemandItemCollection(expanded?: boolean): void;
    /**
     * Links the current folder with a mapService so we can perform specialized operations like listening for mapService visibility changes, showing transparency sliders etc.
     */
    linkWithMapService(mapService: ServiceLayerInfo): void;
    /** @private */
    _setupOpacityBindings(): void;
    /**
     * Remove any bindings and perform any necessary logic for item removal
     */
    cleanUp(): void;
    /** @protected */
    protected _handleLayerThemeChangingEvent(args: {
        currTheme: LayerTheme;
        prevTheme: LayerTheme;
    }): void;
    /** @protected */
    protected _handleLayerThemeChangedEvent(args: {
        currTheme: LayerTheme;
        prevTheme: LayerTheme;
    }): void;
    /**
     * When a layer theme is changed, all folder visibilities are initially set to true so the layer list will
     * respect the visibility change events fired by the javascript api on theme change.
     * The javascript api however, has no notion of folders. Subsequently, when folder settings are applied, the
     * correct state is activated by the layer list. This causes a problem when a folder is a mutually exclusive
     * radio item. The UI will only allow one item to remain checked.... so if there are two items A and B where
     * B is a folder and is turned on, the UI flicks off A though the layer list state may have it turned on.
     * Subsequently, due to theme settings, if the layer list turns B off, the UI does not update the state of A
     * automatically. We'll need to pulse A if it's visible.
     * @private
     */
    private _refreshMutuallyExclusiveItemVisibilities();
    /** @private */
    private _setInActiveThemeIfChildrenPresent();
    /** @private */
    private _recursivelyConfirmChildrenInActiveTheme(children);
}

}
declare module "geocortex/infrastructure/layerList/LayerListGraphicsLayerItem" {
import { LayerListLayerItem } from "geocortex/infrastructure/layerList/LayerListLayerItem";
import { LayerInfo } from "geocortex/infrastructure/gis/LayerInfo";
import { LayerList } from "geocortex/infrastructure/layerList/LayerList";
/**
 * An item in the layer list that corresponds to a layer.
 */
export class LayerListGraphicsLayerItem extends LayerListLayerItem {
    /**
     * Creates a new instance of the {@link LayerListLayerItem} class.
     */
    constructor(id: string, layer: LayerInfo, layerList: LayerList);
}

}
declare module "geocortex/infrastructure/layerList/LayerListItem" {
import { LayerListNode } from "geocortex/infrastructure/layerList/LayerListNode";
import { Observable, ObservableCollection } from "geocortex/framework/observables";
import { LegendItem } from "geocortex/infrastructure/legend/LegendItem";
import { LayerList } from "geocortex/infrastructure/layerList/LayerList";
import { ServiceLayerInfo } from "geocortex/infrastructure/gis/ServiceLayerInfo";
export enum LayerListItemType {
    FOLDER = 0,
    MAPSERVICE = 1,
    LAYER = 2,
    GRAPHICSLAYER = 3,
    KMLFOLDER = 4,
}
/**
 * An item that appears in the {@link LayerList}
 */
export class LayerListItem extends LayerListNode {
    /**
     * The type of item this object represents
     */
    type: LayerListItemType;
    /**
     * The name of this item as it appears in the layer list.
     */
    name: Observable<string>;
    /**
    * Indicates whether this {@link LayerListItem} is currently set to visible or not.
    */
    isVisible: Observable<boolean>;
    /**
     * Indicates whether this {@link LayerListItem} is currently effectively visible. An item is only effectively visible if it, and all it's ancestors are set visible
     */
    isEffectivelyVisible: Observable<boolean>;
    /**
     * Indicates whether the legend swatch for this {@link LayerListItem} is visible when the "onlyShowSwatchesOnVisibleLayers" configuration option has been selected.
     */
    legendIsVisible: Observable<boolean>;
    /**
     * Indicates whether this item's parent is currently effectively visible or not
     */
    parentEffectivelyVisible: Observable<boolean>;
    /**
    * Indicates whether this {@link LayerListItem} is expanded or not.
    */
    isExpanded: Observable<boolean>;
    /**
     * Observable indicating whether this LayerListItem is in the active theme or not.
     */
    inActiveTheme: Observable<boolean>;
    /**
     * Observable indicating whether this LayerListItem is to be displayed in the layer list or not
     */
    displayItem: Observable<boolean>;
    /**
     * The icon Uri for this layer (if applicable). Will be set if available during mapService / layer addition.
     */
    iconUri: Observable<string>;
    /**
    * Tooltip for this Layer's icon, if any
    */
    iconTooltip: Observable<string>;
    /**
     * A collection of child items that are populated on the fly - only when the user expands a given folder. This is for memory and performance reasons
     */
    onDemandItemCollection: ObservableCollection<LayerListItem>;
    /**
    * Description of layer folder expand/collapse button with name of layer.
    */
    layerFolderToggleTooltip: Observable<string>;
    /**
    * Description of toggle button with name of layer.
    */
    layerToggleTooltip: Observable<string>;
    /**
    * Description of layer actions element with name of layer.
    */
    layerActionsTooltip: Observable<string>;
    /**
    * Description of map service actions element with name of service.
    */
    mapServiceActionsTooltip: Observable<string>;
    /**
     * A Collection of legends associated with this Layer List item
     */
    legendItems: ObservableCollection<LegendItem>;
    /**
     * The legend icon Uri or swatch element - if there is only one legend item associated with this item, then this will be the swatch element for that legend item
     */
    legendSwatch: Observable<string>;
    /**
    * Tooltip for the icon representing the legend item(s), if any
    */
    legendTooltip: Observable<string>;
    /**
    * Whether the legend has multiple items or not to display. Used to determine whether legend element should be tabbable or not.
    */
    legendHasMultipleItems: Observable<boolean>;
    /**
     * Indicates whether the legend items for this item are displayed or not
     */
    expandLegend: Observable<boolean>;
    /**
     * Indicates whether this item is mutually exclusive, i.e. whether toggling the visibility of this item on will
     * toggle off the visibility of its siblings.
     */
    isMutuallyExclusive: Observable<boolean>;
    /**
     * Indicates whether this item should have a radio toggle control next to it instead of a checkbox. In some rare cases,
     * an item may be configured as mutually exclusive (see {@link isMutuallyExclusive}), yet should still show with a
     * check box. For example, when there is only one visible item in a mutually exclusive group.
     */
    hasRadioToggle: Observable<boolean>;
    /**
     * The name of the mutually exclusive group that this item belongs to, if any. Toggling on an item within this
     * group will toggle off other mutually exclusive items that belong to the same group.
     */
    radioGroup: Observable<string>;
    /**
     * Indicates if all ancestors of this item are visible or not. This item will be effectively visible only if all its ancestors are visible as well.
     */
    allAncestorsVisible: boolean;
    /**
     * Indicates whether this item has one or more children that are displayed in the layer list.
     */
    hasDisplayedChildren: Observable<boolean>;
    /**
     * A reference to the {@link infrastructure.layerList.LayerList} object that contains this LayerListItem
     */
    layerList: LayerList;
    /**
    * The mapService associated with the current node - if any
    */
    mapService: ServiceLayerInfo;
    /**
     * Determines whether or not the visibility of a LayerList item can be controlled. False by default
     */
    canNotAssignVisibility: Observable<boolean>;
    /**
     * Determines if the opacity of this item can be adjusted or not.
     */
    canAdjustOpacity: Observable<boolean>;
    /**
     * Determines whether the item can be displayed in the layer list.
     */
    canDisplayItem: Observable<boolean>;
    /**
     * The current opacity of the associated mapService. This will remain undefined unless the opacity of this LayerList item can be adjusted.
     */
    opacity: Observable<number>;
    /**
     * A boolean which indicates whether this item should be setup to handle layer actions. False by default.
     */
    enableLayerActions: boolean;
    /**
     * A boolean which indicates whether this item should be setup to handle map service actions. False by default.
     */
    enableMapServiceActions: boolean;
    /**
     * A boolean which indicates whether this item represents a layer or service that was created by the user at runtime. False by default.
     */
    isUserCreated: boolean;
    /**
     * A boolean indicating that this item is the originator of the current user click. It will remain false at all other times.
     */
    currentUserClickOriginator: boolean;
    /**
    * Indicates if this item is visible at the current map scale.
    */
    inVisibleScaleRange: Observable<boolean>;
    /**
    * The deferred visibility to be applied to this item after the complete layer list model is set up and ready - i.e. after processing all visibilities,
    * startup workflows, parameters etc. This will be applied and then the variable deleted, when the applyDeferredInitialVisibility function is called.
    */
    _deferredVisibilitySetting: boolean;
    private _opacityChangeHandle;
    private _parentExpandedStateBeforeFilter;
    /**
     * Creates a new instance of the {@link LayerListItem} class
     */
    constructor(id: string, type: LayerListItemType, layerList: LayerList);
    /**
     * Updates inActiveTheme when it changes in the underlying geocortex map service or layer (if available)
     */
    bindToActiveTheme(): void;
    /**
     * Removes the binding to the active theme
     */
    unbindFromActiveTheme(): void;
    /**
     * Remove any bindings and perform any necessary logic for item removal
     */
    cleanUp(): void;
    notifyActiveThemeChanged(childrenInActiveTheme: boolean): void;
    /**
     * Set the visibility of this item in the layer list. This is a special function which should be called in preference to setting isVisible directly, since
     * it also keeps track of whether this item is the originator of the current user click.
     */
    setItemVisibility(visible: boolean): void;
    /**
     * Set the visibility of the service associated with this item in the layer list
     */
    setVisibility(visible: boolean): void;
    /**
     * Sets the ancestor visibility. This should be set to true only if all ancestors are set visible
     * NOTE: This function call will not check to see if all ancestors are actually visible or not. Use with caution.
     */
    setAncestorVisibility(ancestorVisibility: boolean): void;
    /**
     * Manages the on demand item collection. This collection is only populated when the needed - i.e. when the respective layer list folder is expanded. When not
     * needed, it's pulled out from the collection and from the dom. This has a slight insignificant penalty for smaller layer lists but a huge benefit for large ones
     */
    refreshOnDemandItemCollection(expanded?: boolean): void;
    /**
    * Populates the containedMapServices array of any parent folder. This method must be invoked manually when needed.
    */
    populateMapServicesInParentFolders(): void;
    updateDisplayItem(): void;
    /**
     * Returns true if a given layer list item is either not a folder but in the active theme, or if it is a folder, has at least one non-folder item in it's sub tree
     * which is in the active theme and can be displayed in the layer list OR is hidden but participates in the layer list.
     * @param item Optional parameter. If specified, will perform computation on the given item, otherwise will defau8lt to this layer list item.
     */
    displayInLayerList(item?: LayerListItem): boolean;
    /**
     * Applies the previously deferred visibility (if any) to this item after the complete layer list model is set up and ready
     */
    _applyDeferredInitialVisibility(): void;
    _setupOpacityBindings(): void;
    protected _updateDisplayItem(): void;
    private _onActiveThemeChanged(value);
    private _processLegendVisibility();
    /**
     * Set up the descriptive tooltips to include the name of the layer and to state whether the layer is in visible range.
     * This is done for WCAG purposes.
     */
    protected _setTooltips(): void;
    protected _updateFilterControlComponent(): void;
}

}
declare module "geocortex/infrastructure/layerList/LayerListItemCollection" {
import { ObservableCollection } from "geocortex/framework/observables";
import { LayerListItem } from "geocortex/infrastructure/layerList/LayerListItem";
import { LayerList } from "geocortex/infrastructure/layerList/LayerList";
/**
 * A collection of child items belonging to a node in the layer list.
 */
export class LayerListItemCollection extends ObservableCollection<LayerListItem> {
    private _parent;
    layerList: LayerList;
    /**
     * Creates a new instance of the {@link LayerListItemCollection} class.
     */
    constructor(parent: LayerListItem, childItemArray?: LayerListItem[]);
    /**
     * Adds an item to the collection. Overriding base class method so parent can automatically be set while inserting
     */
    addItem(item: LayerListItem): void;
    /**
     * Adds an item after performing validation. Returns true if successful, false otherwise.
     */
    validateAndAddItem(item: LayerListItem): boolean;
    /**
     * Adds multiple items to the collection. Overriding base class method so parent can automatically be set while inserting
     */
    addItems(items: LayerListItem[]): void;
    /**
     * Adds multiple items after validating all of them. Will either add all or none. Returns true on success, false otherwise.
     */
    validateAndAddItems(items: LayerListItem[]): boolean;
    /**
     * Inserts an item into the collection at the specified index. Overriding base class method so parent can be automatically set while inserting
     */
    insertItem(position: number, item: LayerListItem): void;
    /**
     * Inserts multiple item into the collection at the specified index. Overriding base class method so parent can be automatically set while inserting
     */
    insertItems(position: number, items: LayerListItem[]): void;
    /**
     * Inserts an item into the collection at a specified index if the item passes validation.
     */
    validateAndInsertItem(position: number, newItem: LayerListItem): boolean;
    /**
     * Validates and inserts multiple items into the collection at a specified index. Will either insert all if validated, or none at all.
     */
    validateAndInsertItems(position: number, items: LayerListItem[]): boolean;
    /**
     * Remove item by reference. Overriding base class method so parent can automatically be set to null on removal
     */
    removeItem(item: LayerListItem): void;
    /**
     * Remove item by index. Overriding base class method so parent can automatically be set to null on removal
     */
    removeAt(position: number): void;
    /**
     * Removes a range of items from the collection. Overriding base class method so parent can automatically be set to null on removal
     */
    removeRange(from: number, to?: number): void;
    /**
     * Clears the collection after first setting the parents to null
     */
    clear(): void;
    /**
     * Private method that sets item properties like its parent and observable bindings before its added to this collection
     */
    private _prepItemForAddition(item);
    /**
     * Any processing that might be needed for an item post addition
     */
    private _processItemPostAddition(item);
    /**
     * Private method that removes/resets item properties like its parent and observable bindings before its removed from this collection
     */
    private _prepItemForRemoval(item);
    /**
     * Convenience method to prep multiple items for addition simultaneously
     */
    private _prepItemsForAddition(items);
    /**
     * Convenience method to process multiple items simultaneously post addition
     */
    private _processItemsPostAddition(items);
    /**
     * Convenience method to prep multiple items for removal simultaneously
     */
    private _prepItemsForRemoval(items);
    /**
     * Invoked just before adding an item as a child of this node. Validates if it can be added or not.
     */
    private _validateCanAdd(newItem);
}

}
declare module "geocortex/infrastructure/layerList/LayerListKmlFolderItem" {
import { LayerListItem } from "geocortex/infrastructure/layerList/LayerListItem";
import { LayerList } from "geocortex/infrastructure/layerList/LayerList";
/**
 * A item in the layer list representing a folder in a KML service.
 */
export class LayerListKmlFolderItem extends LayerListItem {
    /**
     * The esri KMLLayer that this folder belongs to.
     */
    private _kmlLayer;
    /**
     * The esri KMLFolder object that this layer list item is associated with.
     */
    private _kmlFolder;
    /**
     * Initializes a new instance of the {@link LayerListKmlFolderItem} class.
     * @param id The unique ID for the item.
     * @param layerList The layer list
     * @param kmlLayer The {@link esri.layers.KMLLayer} object that contains the folder.
     * @param kmlFolder The {@link esri.layers.KMLFolder} object that this layer list item is associated with.
     */
    constructor(id: string, layerList: LayerList, kmlLayer: esri.layers.KMLLayer, kmlFolder: esri.layers.KMLFolder);
    /**
     * Set the visibility of this item in the layer list. This is a special function which should be called in preference to setting isVisible directly, since
     * it also keeps track of whether this item is the originator of the current user click.
     */
    setItemVisibility(visible: boolean): void;
}

}
declare module "geocortex/infrastructure/layerList/LayerListLayerItem" {
import { LayerListItem, LayerListItemType } from "geocortex/infrastructure/layerList/LayerListItem";
import { LayerInfo } from "geocortex/infrastructure/gis/LayerInfo";
import { LayerList } from "geocortex/infrastructure/layerList/LayerList";
/**
 * An item in the layer list that corresponds to a layer.
 */
export class LayerListLayerItem extends LayerListItem {
    private _themeSyncHandle;
    private _layerVisibilityHandle;
    private _zoomEndHandle;
    private _deferRefreshTimeoutMs;
    _forceSetAncestorVisibilityOperationActive: boolean;
    layer: LayerInfo;
    /**
     * Creates a new instance of the {@link LayerListLayerItem} class.
     */
    constructor(id: string, layer: LayerInfo, layerList: LayerList, type?: LayerListItemType);
    /**
     * Set the visibility of this layer in the layer list
     */
    setVisibility(visible: boolean, forceSetAncestorVisibility?: boolean): void;
    /**
     * Updates the legend items including the legend swatch for a layer item.
     */
    updateLegendItems(): void;
    /**
     * Updates inActiveTheme when it changes in the underlying geocortex layer (if available)
     */
    bindToActiveTheme(): void;
    /**
     * Removes the binding to the active theme
     */
    unbindFromActiveTheme(): void;
    /**
     * Remove any bindings and perform any necessary logic for item removal
     */
    cleanUp(): void;
    /** @private */
    private _subscribeEvents();
    /** @private */
    private _onServiceLayerProcessed();
    /** @private */
    private _handleLayerVisibilityChange(results);
    /** @private */
    private _populateLegendItem(item);
    /** @private */
    private _setupIconUri();
    /**
     * @private
     * Sets up geocortex layer bindings if the layer is available. The layer will not be available if we're operating in a WAB environment
     */
    private _setupGcxBindingsIfAvailable();
    /** @private */
    private _updateVisibilityAtCurrentScale();
}

}
declare module "geocortex/infrastructure/layerList/LayerListMapServiceItem" {
import { LayerListItem } from "geocortex/infrastructure/layerList/LayerListItem";
import { ServiceLayerInfo } from "geocortex/infrastructure/gis/ServiceLayerInfo";
import { LayerList } from "geocortex/infrastructure/layerList/LayerList";
/**
 * In case of the configurable Layer List this class represents a layer list item that corresponds directly to an "atomic" map service, i.e.
 * one whose visibility is toggled as a whole rather than changing the visibility of individual layers.
 * In case of a standard layer list or AWAB, this class will behave like a normal map service.
 */
export class LayerListMapServiceItem extends LayerListItem {
    private _themeSyncHandle;
    private _layerVisibilityHandle;
    private _forceSetAncestorVisibilityOperationActive;
    /**
     * Creates a new instance of the {@link LayerListMapServiceItem} class.
     */
    constructor(id: string, mapService: ServiceLayerInfo, layerList: LayerList);
    /**
     * Set the visibility of this mapService item in the layer list
     * @param visible The visibility of this map service item
     * @param forceSetAncestorVisibility If true, will force ancestor visibilities to sync up with this map service item
     */
    setVisibility(visible: boolean, forceSetAncestorVisibility?: boolean): void;
    /**
     * Updates inActiveTheme when it changes in the underlying geocortex map service (if available)
     */
    bindToActiveTheme(): void;
    /**
     * Removes the binding to the active theme
     */
    unbindFromActiveTheme(): void;
    /**
     * Remove any bindings and perform any necessary logic for item removal
     */
    cleanUp(): void;
    /** @private */
    private _subscribeEvents();
    /** @private */
    private _setupIconUri();
    private _syncChildVisibilitiesIfApplicable(visible);
    /**
     * @private
     * Sets up bindings.
     */
    private _setupBindings();
    /**
     * For KML map services only. Called when the KML service layer is loaded.
     * @param kmlLayer The newly-loaded KML layer.
     */
    private _kmlLayerLoadHandler(kmlLayer);
    /**
     * Recursively creates KML folder layer list items from folders defined in a KML service.
     * @param item The layer list item to add the folder to.
     * @param folder The {@link esri.layers.KMLFolder} object representing the folder to add.
     * @param kmlLayer The root {@link esri.layers.KMLLayer} object that owns the folder.
     */
    private _createKmlFolders(item, folder, kmlLayer);
    private _updateVisibilityAtCurrentScale();
    /**
     * Set up the descriptive tooltips to include the name of the layer and to state whether the layer is in visible range.
     * This is done for WCAG purposes.
     */
    protected _setTooltips(): void;
}

}
declare module "geocortex/infrastructure/layerList/LayerListNode" {
import { Observable } from "geocortex/framework/observables";
import { LayerListItemCollection } from "geocortex/infrastructure/layerList/LayerListItemCollection";
import { LayerListItem } from "geocortex/infrastructure/layerList/LayerListItem";
/**
 * A node in the layer list hierarchy.
 * In addition to layer list items, the layer list itself is considered to be a node,
 * specifically it acts as the root node in the hierarchy.
 */
export class LayerListNode {
    /**
    * The unique identifier for this layer list item. Will be "GCXLayerListRootNode-[random string]" if this is the root node.
    */
    id: Observable<string>;
    /**
     * A {@link LayerListItemCollection} object, representing the current node's children
     */
    children: LayerListItemCollection;
    /**
     * The current node's parent - if any
     */
    parent: LayerListNode;
    /**
     * Visibility binding token (if any), used by the {@link LayerListItemCollection} class to manage visibilities
     */
    _visibilityBindingToken: string;
    /**
     * Binding token for {@link LayerListItem.displayItem} (if any), used by the {@link LayerListItemCollection} class.
     */
    _displayItemBindingToken: string;
    /**
     * Initializes a new instance of the {@link LayerListNode} class.
     * @param id The unique string identifier for this node
     * @param parentNode This node's parent node if any
     */
    constructor(id?: string, parentNode?: LayerListNode);
    /**
    * Gets the root node in the layer list hierarchy.
    */
    getRoot(): LayerListNode;
    /**
     * Gets the collection of ancestor nodes, ordered from nearest to farthest.
     */
    getAncestors(): LayerListNode[];
    /**
     * Gets this node, as well as it's ancestors, ordered from nearest to farthest
     */
    getSelfAndAncestors(): LayerListNode[];
    /**
     * Gets all of this node's siblings, in the order that they appear in the layer list.
     * @param includSelf A boolean which when set to true will return siblings with this node in the correct position. Defaults to false
     */
    getSiblings(includeSelf?: boolean): LayerListNode[];
    /**
     * Gets all of this node's descendant items, in depth-first traversal order.
     */
    getDescendants(): LayerListItem[];
    /**
     * Gets this node, as well as it's descendants, in depth-first traversal order
     */
    getSelfAndDescendants(): LayerListNode[];
}

}
declare module "geocortex/infrastructure/layerList/LayerVisibilityType" {
/** The visibility type of a layer list item's sub-items. */
export class LayerVisibilityType {
    /** Any number of items can be visible at a time. */
    static Default: string;
    /** Only one item can be visible at a time. */
    static MutuallyExclusive: string;
}

}
declare module "geocortex/infrastructure/layerselector/LayerSelector" {
import { AppInfo } from "geocortex/infrastructure/gis/AppInfo";
import { LayerSelectorLayerItem } from "geocortex/infrastructure/layerselector/LayerSelectorLayerItem";
import { LayerSelectorServiceLayerItem } from "geocortex/infrastructure/layerselector/LayerSelectorServiceLayerItem";
import { LayerSelectorFolderItem } from "geocortex/infrastructure/layerselector/LayerSelectorFolderItem";
import { ObservableCollection } from "geocortex/framework/observables";
import { LayerSelectorItem } from "geocortex/infrastructure/layerselector/LayerSelectorItem";
import { LayerSelectorConfiguration } from "geocortex/infrastructure/layerselector/LayerSelectorConfiguration";
import { MapService } from "geocortex/essentials/MapService";
import { ServiceLayerInfo } from "geocortex/infrastructure/gis/ServiceLayerInfo";
import { LayerInfo } from "geocortex/infrastructure/gis/LayerInfo";
import { Layer } from "geocortex/essentials/Layer";
export class LayerSelector {
    appInfo: AppInfo;
    layerFilter: (layerSelectorItem: LayerSelectorLayerItem | LayerSelectorServiceLayerItem) => boolean;
    layerStateChangeHandler: (layerSelectorItem: LayerSelectorLayerItem | LayerSelectorServiceLayerItem) => void;
    enableAllLayersHandler: () => void;
    disableAllLayersHandler: () => void;
    onInitializedHandler: (layerSelector: LayerSelector) => void;
    /**
     * Called when a new LayerSelectorFolderItem is created.
     * @param folderItem The item created.
     */
    onLayerSelectorFolderItemCreated: (folderItem: LayerSelectorFolderItem) => void;
    /**
     * Called when a new LayerSelectorLayerItem is created.
     * @param layerItem The item created.
     */
    onLayerSelectorLayerItemCreated: (layerItem: LayerSelectorLayerItem) => void;
    /**
     * Called when a new LayerSelectorServiceLayerItem is created.
     * @param layerItem The item created.
     */
    onLayerSelectorServiceLayerItemCreated: (layerItem: LayerSelectorServiceLayerItem) => void;
    items: ObservableCollection<LayerSelectorItem>;
    initialized: boolean;
    /**
     * A flat list of the filtered LayerSelectorServiceLayer and LayerSelectorLayer items.
     */
    filteredLayerSelectorLayerItems: (LayerSelectorLayerItem | LayerSelectorServiceLayerItem)[];
    /**
    * A flat list of the unfiltered LayerSelectorServiceLayer and LayerSelectorLayer items.
    */
    unfilteredLayerSelectorLayerItems: (LayerSelectorLayerItem | LayerSelectorServiceLayerItem)[];
    itemTypes: {
        FOLDER: string;
        LAYER: string;
        SERVICELAYER: string;
    };
    protected _infrastructureLibraryId: string;
    protected _unfilteredItems: LayerSelectorItem[];
    protected _suspendLayerStateChangeHandler: boolean;
    /** Placeholder folder for user-added layers */
    protected _userAddedLayersFolder: LayerSelectorFolderItem;
    /**
     * Creates a new instance of the (@link LayerSelector} class.
     * @param appInfo The {@link gis.AppInfo} that the layer selector belongs to
     * @param options Optional. An object containing options to configure the layer selector
     */
    constructor(appInfo: AppInfo, options?: LayerSelectorConfiguration);
    initialize(): void;
    applyFilter(itemFilter?: (layerSelectorItem: LayerSelectorLayerItem | LayerSelectorServiceLayerItem) => boolean): void;
    /**
     * Reapply the last used layer filter.
     */
    reapplyFilter(): void;
    setLayerStateChangeHandler(layerStateChangeHandler?: (layerSelectorItem: LayerSelectorLayerItem | LayerSelectorServiceLayerItem) => void): void;
    setEnableAllLayersHandler(enableAllLayersHandler?: () => void): void;
    setDisableAllLayersHandler(disableAllLayersHandler?: () => void): void;
    enableAllLayers(): void;
    disableAllLayers(): void;
    addUserAddedServiceLayer(mapService: MapService | ServiceLayerInfo): boolean;
    removeServiceLayer(mapService: MapService | ServiceLayerInfo): boolean;
    updateServiceLayer(mapService: MapService | ServiceLayerInfo, newItems?: Layer[], oldItems?: Layer[]): boolean;
    protected _removeItemFromUnfilteredCollections(item: LayerSelectorItem): void;
    protected _loadLayerSelectorItems(): void;
    protected _loadSelectorItemsNotInLayerList(): void;
    protected _createFolderItemFromRestItem(item: RestLayerListItem, isEnabled: boolean, isExpanded: boolean): LayerSelectorFolderItem;
    protected _creatFolderItemFromServiceLayer(srcItem: LayerSelectorServiceLayerItem, isEnabled: boolean, isExpanded: boolean): LayerSelectorFolderItem;
    protected _createLayerItemFromLayer(layer: LayerInfo, isEnabled: boolean, isExpanded: boolean): LayerSelectorLayerItem;
    protected _createServiceLayerItemFromServiceLayer(serviceLayer: ServiceLayerInfo, isEnabled: boolean, isExpanded: boolean): LayerSelectorServiceLayerItem;
    /**
     * Generates a clone of a folder or service layer item, set to enabled and minus its items. This is so we can filter items with children based on any filter that's applied
     * without actually modifying the original layer/folder item.
     */
    protected _generateItemCloneForFilter(srcItem: LayerSelectorFolderItem | LayerSelectorServiceLayerItem): LayerSelectorItem;
    protected _setTooltips(item: LayerSelectorItem): void;
}

}
declare module "geocortex/infrastructure/layerselector/LayerSelectorConfiguration" {
import { LayerSelectorLayerItem } from "geocortex/infrastructure/layerselector/LayerSelectorLayerItem";
import { LayerSelectorServiceLayerItem } from "geocortex/infrastructure/layerselector/LayerSelectorServiceLayerItem";
import { LayerSelector } from "geocortex/infrastructure/layerselector/LayerSelector";
import { LayerSelectorFolderItem } from "geocortex/infrastructure/layerselector/LayerSelectorFolderItem";
export interface LayerSelectorConfiguration {
    layerFilter?: (layerSelectorLayerItem: LayerSelectorLayerItem | LayerSelectorServiceLayerItem) => boolean;
    layerStateChangeHandler?: (layerSelectorLayerItem: LayerSelectorLayerItem | LayerSelectorServiceLayerItem) => void;
    enableAllLayersHandler?: () => void;
    disableAllLayersHandler?: () => void;
    onInitializedHandler?: (layerSelector: LayerSelector) => void;
    onLayerSelectorFolderItemCreated?: (folderItem: LayerSelectorFolderItem) => void;
    onLayerSelectorLayerItemCreated?: (layerItem: LayerSelectorLayerItem) => void;
    onLayerSelectorServiceLayerItemCreated?: (layerItem: LayerSelectorServiceLayerItem) => void;
}

}
declare module "geocortex/infrastructure/layerselector/LayerSelectorFolderItem" {
import { LayerSelectorItem } from "geocortex/infrastructure/layerselector/LayerSelectorItem";
export interface LayerSelectorFolderItem extends LayerSelectorItem {
    properties?: {
        [propName: string]: any;
    };
}

}
declare module "geocortex/infrastructure/layerselector/LayerSelectorItem" {
import { Observable, ObservableCollection } from "geocortex/framework/observables";
export interface LayerSelectorItem {
    name: Observable<string>;
    iconUri: Observable<string>;
    iconTooltip: Observable<string>;
    isExpanded: Observable<boolean>;
    expanderTooltip: Observable<string>;
    isEnabled: Observable<boolean>;
    stateToggleTooltip: Observable<string>;
    isFolder: boolean;
    items: ObservableCollection<LayerSelectorItem>;
    itemType: string;
}

}
declare module "geocortex/infrastructure/layerselector/LayerSelectorLayerItem" {
import { LayerSelectorItem } from "geocortex/infrastructure/layerselector/LayerSelectorItem";
import { LayerInfo } from "geocortex/infrastructure/gis/LayerInfo";
export interface LayerSelectorLayerItem extends LayerSelectorItem {
    layer: LayerInfo;
    properties?: {
        [propName: string]: any;
    };
}

}
declare module "geocortex/infrastructure/layerselector/LayerSelectorServiceLayerItem" {
import { LayerSelectorItem } from "geocortex/infrastructure/layerselector/LayerSelectorItem";
import { ServiceLayerInfo } from "geocortex/infrastructure/gis/ServiceLayerInfo";
export interface LayerSelectorServiceLayerItem extends LayerSelectorItem {
    serviceLayer: ServiceLayerInfo;
    properties?: {
        [propName: string]: any;
    };
}

}
declare module "geocortex/infrastructure/layerselector/LayerSelectorViewBase" {
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { LayerSelectorViewModelBase } from "geocortex/infrastructure/layerselector/LayerSelectorViewModelBase";
import { LayerSelectorLayerItem } from "geocortex/infrastructure/layerselector/LayerSelectorLayerItem";
export class LayerSelectorViewBase extends ViewBase {
    app: ViewerApplication;
    viewModel: LayerSelectorViewModelBase;
    selectAllLayers(evt: MouseEvent, el: HTMLElement, context: any): void;
    clearAllLayers(evt: MouseEvent, el: HTMLElement, context: any): void;
    handleExpanderClick(evt: MouseEvent, el: HTMLElement, context: LayerSelectorLayerItem): void;
}

}
declare module "geocortex/infrastructure/layerselector/LayerSelectorViewModelBase" {
import { ViewModelBase } from "geocortex/framework/ui/ViewModelBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { AppInfo } from "geocortex/infrastructure/gis/AppInfo";
import { LayerSelector } from "geocortex/infrastructure/layerselector/LayerSelector";
import { ObservableCollection, Observable } from "geocortex/framework/observables";
import { LayerSelectorItem } from "geocortex/infrastructure/layerselector/LayerSelectorItem";
import { LayerSelectorFolderItem } from "geocortex/infrastructure/layerselector/LayerSelectorFolderItem";
import { LayerSelectorLayerItem } from "geocortex/infrastructure/layerselector/LayerSelectorLayerItem";
import { LayerSelectorServiceLayerItem } from "geocortex/infrastructure/layerselector/LayerSelectorServiceLayerItem";
import { MapService } from "geocortex/essentials/MapService";
import { MapServiceLayersChangedEventArgs } from "geocortex/infrastructure/eventArgs/MapServiceLayersChangedEventArgs";
export class LayerSelectorViewModelBase extends ViewModelBase {
    app: ViewerApplication;
    appInfo: AppInfo;
    layerSelector: LayerSelector;
    items: ObservableCollection<LayerSelectorItem>;
    selectAllButtonText: Observable<string>;
    clearAllButtonText: Observable<string>;
    private _layerSelectorInitialized;
    selectAllButtonTitle: Observable<string>;
    clearAllButtonTitle: Observable<string>;
    constructor(app: ViewerApplication, libraryId?: string);
    initialize(config: any): void;
    /**
     * This handler fires exactly once when the layer selector is initialized. Override this method in a sub class to define the handler.
     */
    onInitialized(layerSelector: LayerSelector): void;
    /**
     * Called when a new LayerSelectorFolderItem is created.
     * Override this method in a sub class to define the handler.
     * @param folderItem The item created.
     */
    onLayerSelectorFolderItemCreated(folderItem: LayerSelectorFolderItem): void;
    /**
     * Called when a new LayerSelectorLayerItem is created.
     * Override this method in a sub class to define the handler.
     * @param layerItem The item created.
     */
    onLayerSelectorLayerItemCreated(layerItem: LayerSelectorLayerItem): void;
    /**
     * Called when a new LayerSelectorServiceLayerItem is created.
     * Override this method in a sub class to define the handler.
     * @param layerItem The item created.
     */
    onLayerSelectorServiceLayerItemCreated(layerItem: LayerSelectorServiceLayerItem): void;
    /**
     * The filter based on which the layers are included in the 'items' collection. Can be modified at runtime. Override this
     * method in a sub class to define the filter.
     */
    filter(layerSelectorLayerItem: LayerSelectorLayerItem | LayerSelectorServiceLayerItem): boolean;
    /**
     * The handler for a layer state change event. Override this method in a sub class to define the handler.
     */
    handleLayerStateChange(layerSelectorLayerItem: LayerSelectorLayerItem | LayerSelectorServiceLayerItem): void;
    /**
     * The handler that is invoked when all layers are set to enabled. Override this method in a sub class to define the handler.
     */
    handleAllLayersEnabled(): void;
    /**
     * The handler that is invoked when all layers are disabled. Override this method in a sub class to define the handler.
     */
    handleAllLayersDisabled(): void;
    /**
     * Recursively walks the tree of items and returns a flat array of all items.
     * @returns all LayerSelectorItems of any depth.
     */
    getAllItems(): LayerSelectorItem[];
    /**
     * Recursively walks the tree of the given items and returns a flat array of all items.
     * @returns all LayerSelectorItems of any depth.
     */
    private static _expandItems(items);
    protected _setupLayerSelector(): void;
    protected _subscribeEvents(): void;
    protected _handleMapServicesAdded(ms: MapService): void;
    protected _handleMapServiceRemoved(ms: MapService): void;
    protected _handleMapServiceLayersChanged(args: MapServiceLayersChangedEventArgs): void;
    protected _waitUntilLayerSelectorInitialized(): Promise<void>;
}

}
declare module "geocortex/infrastructure/legend/LegendItem" {
import { Layer } from "geocortex/essentials/Layer";
import { Observable, ObservableCollection } from "geocortex/framework/observables";
export class LegendItem {
    templateType: string;
    numChildren: number;
    esriLayer: esri.layers.Layer;
    essLayer: Layer;
    sublayerId: string;
    swatchElement: string;
    isCluster: boolean;
    label: Observable<string>;
    description: Observable<string>;
    isVisible: Observable<boolean>;
    isVisibleInLayerListLegend: Observable<boolean>;
    expanded: Observable<boolean>;
    expanderClass: Observable<string>;
    children: ObservableCollection<LegendItem>;
    parent: LegendItem;
    constructor(layer: esri.layers.Layer, useThrottledCollection?: boolean);
}

}
declare module "geocortex/infrastructure/legend/LegendItemProvider" {
import { LegendItemProviderResponse } from "geocortex/infrastructure/legend/LegendItemProviderResponse";
export interface LegendItemProvider {
    supportsOffline(): boolean;
    provide(layer: esri.layers.Layer): LegendItemProviderResponse;
    useThrottledCollections?: boolean;
}

}
declare module "geocortex/infrastructure/legend/LegendItemProviderEntry" {
import { LegendItemProvider } from "geocortex/infrastructure/legend/LegendItemProvider";
export interface LegendItemProviderConstructor {
    (layer: esri.layers.Layer): any;
}
export class LegendItemProviderEntry {
    identifier: string;
    private _provider;
    constructor(identifier: string, provider: LegendItemProvider);
}

}
declare module "geocortex/infrastructure/legend/LegendItemProviderFactory" {
import { LegendItemProvider } from "geocortex/infrastructure/legend/LegendItemProvider";
import { LegendItem } from "geocortex/infrastructure/legend/LegendItem";
import { LayerInfo } from "geocortex/infrastructure/gis/LayerInfo";
export class LegendItemProviderFactory {
    private static _providers;
    private static _legendItemInfos;
    private static _legendItemCallbacks;
    static registerLegendItemProvider(provider: LegendItemProvider): void;
    static getProviders(): Array<LegendItemProvider>;
    /**
     * Convenience method to get legend item using a layerInfo object instance
     */
    static getLegendItemWhenAvailable(layer: LayerInfo, callback: (legendItem: LegendItem) => void): void;
    /**
     * This function will invoke the provided callback only when (and if) the legend Item in question is retrieved. If it's not retrieved because of the legend
     * module not being loaded or in case of some unforeseen error, it will simply do nothing. Programmers should be aware of this while calling this function.
     * @param uniqueId A uniqueId parameter which is of the form <mapServiceId.layerId> for layers or simply the mapService id in case of map services
     * @param callback A callback function which will be invoked if, and when, the requested legend item becomes available.
     */
    static getLegendItemByIdWhenAvailable(uniqueId: string, callback: (legendItem: LegendItem) => void): void;
}

}
declare module "geocortex/infrastructure/legend/LegendItemProviderResponse" {
import { Observable } from "geocortex/framework/observables";
import { LegendItem } from "geocortex/infrastructure/legend/LegendItem";
export enum LegendItemProviderResponseCode {
    NotFound = 0,
    Rendered = 1,
    Show = 2,
    Hide = 3,
    Pending = 4,
    Error = 5,
}
export class LegendItemProviderResponse {
    code: Observable<number>;
    item: LegendItem;
    constructor(code: LegendItemProviderResponseCode, item: LegendItem);
}

}
declare module "geocortex/infrastructure/native/MessageClient" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { CancellationToken } from "geocortex/infrastructure/CancellationToken";
import { NativeMessage } from "geocortex/infrastructure/native/NativeMessage";
/**
 * Communication channel for sending messages to GMAF. Includes handling of long running jobs, progress reporting, and cancellation.
 * @private
 */
export class MessageClient {
    app: ViewerApplication;
    private _handlers;
    constructor(app: ViewerApplication);
    /**
     * Intended to be called by GMAF only.
     * @private
     */
    _postMessage(messageType: string, content: string): void;
    subscribe(messageType: string, handler: (message: NativeMessage<any>) => void): void;
    unsubscribe(messageType: string, handler: (message: NativeMessage<any>) => void): void;
    /**
     * Sends a message to GMAF and returns a Promise that will be resolved when the operation is complete.
     * Operations can be short running (if there is no cancellation token) or long running (if there is a cancellation token).
     */
    message(messageType: string, payload: any, cancellationToken?: CancellationToken, progress?: (status: any) => void): Promise<any>;
    private cancel(jobId);
}

}
declare module "geocortex/infrastructure/native/NativeManager" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { CancellationToken } from "geocortex/infrastructure/CancellationToken";
import { ResourceInfo } from "geocortex/infrastructure/native/ResourceInfo";
export class NativeManager {
    app: ViewerApplication;
    private _nativeInitializedPromise;
    private _nativeInitializedResolve;
    private _messageClient;
    private _capabilities;
    /**
     * Indicates whether native is initialized.  For a check with an asynchronous
     * callback use onNativeInitialized().
     */
    nativeInitialized: boolean;
    constructor(app: ViewerApplication);
    isNative(): boolean;
    isWindowsNative(): boolean;
    isIosNative(): boolean;
    xhrGet(dojoArgs: any): Promise<any>;
    xhrPost(dojoArgs: any): Promise<any>;
    xhrPostUnsecured(dojoArgs: any): any;
    appendAuthorizationHeader(dojoArgs: any): void;
    /**
     * Sends a message to GMAF and returns a Promise that will be resolved when the operation is complete.
     * Operations can be short running (if there is no cancellation token) or long running (if there is a cancellation token).
     */
    message(messageType: string, body: any, cancellationToken?: CancellationToken, progress?: (status: any) => void): Promise<any>;
    /**
     * Subscribe to messages sent from GMAF.
     */
    subscribe(messageType: string, handler: (message: any) => void): void;
    /**
     * Gets a promise that will be resolved when the "native ready" message has been received from the native
     * layer, which indicates that the native infrastructure has been initialized.
     */
    onNativeInitialized(): Promise<void>;
    /**
     * To be called once by the module that handles the native initialize to indicate that native initialization
     * is complete. Causes the promise returned by onNativeInitialized() to be resolved.
     */
    signalNativeInitialized(): void;
    /**
     * Gets the resource info for a viewer resource.
     * @param fileName The name of the file on the server to get the resource info for.
     */
    getViewerResourceInfo(fileName: string): Promise<ResourceInfo>;
    /**
     * Tests to see if the app has a certain native capability. Example "editing".
     */
    hasNativeCapability(capability: string): Promise<boolean>;
}

}
declare module "geocortex/infrastructure/native/NativeMessage" {
export interface NativeMessage<T> {
    type: string;
    parameters: T;
}

}
declare module "geocortex/infrastructure/native/ResourceInfo" {
export interface ResourceInfo {
    name: string;
    exists: boolean;
    length?: number;
    lastAccessTime?: Date;
    lastWriteTime?: Date;
}

}
declare module "geocortex/infrastructure/menus/BatchItemConfig" {
/**
 * Configuration interface for individual batch items contained within a batch in the menu item config.
 */
export interface BatchItemConfig {
    /** The name of the command associated with this batch item. */
    command: string;
    /** The command parameter for the command associated with this batch item. */
    commandParameter?: any;
    /** Boolean which determines whether or not the entire batch will be terminated if this batch item fails to execute. */
    abortBatchOnFailure?: boolean;
}

}
declare module "geocortex/infrastructure/menus/BatchItemModel" {
import { Application } from "geocortex/framework/application/Application";
import { TypedCommand } from "geocortex/framework/commands/TypedCommand";
import { BatchItemConfig } from "geocortex/infrastructure/menus/BatchItemConfig";
/**
 * BatchItemModel provides a general purpose, loosely coupled model for individual batch items within a batch.
 */
export class BatchItemModel {
    /** The Application that this batch item instance belongs to. */
    app: Application;
    /** The command associated with this batch item. */
    command: TypedCommand<any>;
    /** The command parameter (if any) being passed to the command associated with this batch item. */
    commandParameter: any;
    /** Whether or not failure to execute this batch item should prevent subsequent items from executing. */
    abortBatchOnFailure: boolean;
    /**
     * Initializes a new instance of the BatchItemModel class.
     * @param app The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this batch item belongs to.
     * @param config A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.BatchItemConfig} object to configure this batch item.
     */
    constructor(app: Application, config: BatchItemConfig);
}

}
declare module "geocortex/infrastructure/menus/MenuConfig" {
import { MenuEntryConfig } from "geocortex/infrastructure/menus/MenuEntryConfig";
/**
 * The main menu module configuration interface. Menus declared using this format can be registered with the MenuRegistry by any module.
 */
export interface MenuConfig {
    /** The menu entries contained in the viewer configuration files. */
    menus: MenuEntryConfig[];
}

}
declare module "geocortex/infrastructure/menus/MenuEntryConfig" {
import { MenuItemConfig } from "geocortex/infrastructure/menus/MenuItemConfig";
/**
 * Configuration interface for an individual menu.
 */
export interface MenuEntryConfig {
    /** The unique menu ID. */
    id: string;
    /** The menu items contained in this menu. */
    items: MenuItemConfig[];
    /** The menu title. */
    title?: string;
    /** The menu description. */
    description?: string;
    /** The default icon URI for this menu. */
    defaultIconUri?: string;
}

}
declare module "geocortex/infrastructure/menus/MenuItemConfig" {
import { BatchItemConfig } from "geocortex/infrastructure/menus/BatchItemConfig";
/**
 * Configuration interface for an individual menu item within a menu.
 */
export interface MenuItemConfig {
    /** The name of the command associated with this menu item. */
    command: string;
    /** The id of this menuItem */
    id?: string;
    /** Command Parameter associated with the menu item. This could be a string or a complex object. */
    commandParameter?: any;
    /** The name of the command associated when this menu item gets focussed. */
    onFocusCommand?: string;
    /** Command Parameter associated when this menu item gets focussed. This could be a string or a complex object. */
    onFocusCommandParameter?: any;
    /** Array of batch items to execute for this menu item. If specified, this will have precedence over the command and commandParameter combination. */
    batch?: BatchItemConfig[];
    /** The name of this menu item. */
    text?: string;
    /** Short Description for this menu item. */
    description?: string;
    /**
     * Optional value that if specified indicates the library the strings will be grabbed from.
     * If not specified the library of the module loading the strings will be used.
     */
    libraryId?: string;
    /** Visibility status of the menu item when disabled. Defaults to false if not specified. */
    hideOnDisable?: boolean;
    /** URI of the image associated to this menu item if any. */
    iconUri?: string;
}

}
declare module "geocortex/infrastructure/menus/MenuItemModel" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { MenuModel } from "geocortex/infrastructure/menus/MenuModel";
import { BatchItemModel } from "geocortex/infrastructure/menus/BatchItemModel";
import { TypedCommand } from "geocortex/framework/commands/TypedCommand";
import { MenuItemConfig } from "geocortex/infrastructure/menus/MenuItemConfig";
import { BatchItemConfig } from "geocortex/infrastructure/menus/BatchItemConfig";
/**
 * MenuItemModel provides a general purpose, loosely coupled model for an individual menu item contained in a menu.
 */
export class MenuItemModel {
    /** The ViewerApplication that this menu item instance belongs to. */
    app: ViewerApplication;
    /** The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuModel} that this MenuItemModel is a member of. */
    menuModel: MenuModel;
    /** The id of this menu item ( optional ) */
    id: string;
    /** The name of this menu item. */
    text: string;
    /** Short Description of this menu item. */
    description: string;
    /** URI of the icon associated with this menu item (if any). */
    iconUri: string;
    /** Visibility status of menu item when disabled. */
    hideOnDisable: boolean;
    /** An array of BatchItemModel's constituting a batch (if applicable). */
    batchItems: BatchItemModel[];
    /** The executable command object associated with this menu item. */
    command: TypedCommand<any>;
    /** The executable command object associated when this menu item gets focussed. */
    onFocusCommand?: TypedCommand<any>;
    /** The command Parameter associated with the menu item. This could be a string or a complex object. */
    commandParameter: any;
    /** The command Parameter associated when this menu item gets focussed. This could be a string or a complex object. */
    onFocusCommandParameter?: any;
    /**
     * Initializes a new instance of the MenuItemModel class.
     * @param menuModel The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuModel} that this MenuItemModel is a member of.
     * @param config The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuItemConfig} configuration for this MenuItemModel.
     */
    constructor(menuModel: MenuModel, config: MenuItemConfig);
    /**
     * Sets the batch items for the menu item.
     * @param batch A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.BatchItemConfig} object to provide configuration details for
     *              the batch commands (if any) associated with this menu item.
     */
    protected _setBatchItems(batch: BatchItemConfig[]): void;
}

}
declare module "geocortex/infrastructure/menus/MenuItemViewModel" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { Observable } from "geocortex/framework/observables";
import { MenuViewModel } from "geocortex/infrastructure/menus/MenuViewModel";
import { MenuItemModel } from "geocortex/infrastructure/menus/MenuItemModel";
import { Event as GeocortexEvent } from "geocortex/framework/events/Event";
/**
 * A general purpose, reusable and loosely coupled view model representing a menu item within a menu view model.
 */
export class MenuItemViewModel {
    app: ViewerApplication;
    /** The name of this menu item. */
    text: Observable<string>;
    /** Short Description of this menu item. */
    description: Observable<string>;
    /** URI of the icon associated to this menu item (if any). */
    iconUri: Observable<string>;
    /** The main menu view model which contains this menu item. */
    menuViewModel: MenuViewModel;
    /** The MenuItemModel object for this menu item. */
    menuItem: MenuItemModel;
    /** Whether or not this menu item is executable or not. Factors in simple as well as batch menu items. */
    canExecute: Observable<boolean>;
    protected _canExecuteChangedBindingTokens: {
        canExecuteEvent: GeocortexEvent;
        token: string;
    }[];
    protected _contextPropertyBindingTokens: {
        [contextPropertyKey: string]: string;
    };
    /**
    * Initializes a new instance of the MenuItemViewModel class.
    * @param menuVm The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuViewModel} that this MenuItemViewModel is a memeber of.
    * @param menuItem The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuItemModel} for this MenuItemViewModel.
    */
    constructor(menuVm: MenuViewModel, menuItem: MenuItemModel);
    /**
     * Execute this menu item if it can be executed. Could be a simple menu item or multiple batch menu items.
     */
    execute(): void;
    /**
     * Execute the onFocus for this menu item if it can be executed.
     */
    executeOnFocus(): void;
    /**
     * Returns the canExecute status of the related menuItem in real time.
     * @return A boolean which returns true if the menu item backing this menu item view model can be executed.
     */
    computeCanExecute(): boolean;
    /**
    * Re-computes and resets the canExecute observable for this MenuItemViewModel.
    */
    refreshCanExecute(): void;
    /**
     * Unsubscribes from subscriptions and bindings tracked by this MenuItemViewModel
     */
    destroy(): void;
    /**
     * Sets up the canExecute changed bindings for both simple and batch menu items so the menu can update it's state automatically
     */
    protected _setupBindings(): void;
    /**
    * Static function that omputes a command parameter to pass to a menu item.
    * @param menuItemVm The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuItemViewModel} that's requesting the parameter to be resolved.
    * @param parameter The parameter to resolve against the menu context.
    * @return An object or string representing the resolved command parameter.
    */
    protected static _computeCommandParameter(menuItemVm: MenuItemViewModel, parameter: any): any;
}

}
declare module "geocortex/infrastructure/menus/MenuModel" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { MenuItemModel } from "geocortex/infrastructure/menus/MenuItemModel";
import { MenuEntryConfig } from "geocortex/infrastructure/menus/MenuEntryConfig";
import { MenuItemConfig } from "geocortex/infrastructure/menus/MenuItemConfig";
/**
 * MenuModel provides a general purpose, loosely coupled model for defining menus that can be accessed by any module.
 */
export class MenuModel {
    /** The ViewerApplication that this menu model instance belongs to. */
    app: ViewerApplication;
    /** The unique id of this menu. */
    id: string;
    /** Array of menu items contained in this menu. */
    items: MenuItemModel[];
    /** Title (if any) of this menu. */
    title: string;
    /** Description (if any) of this menu. */
    description: string;
    /** Default URI for an icon (if any), used if a menu item does not have one defined. */
    defaultIconUri: string;
    /**
     * Initializes a new instance of the MenuModel class.
     * @param app The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this menu belongs to.
     * @param entry A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuEntryConfig} object to configure this menu.
     */
    constructor(app: ViewerApplication, entry: MenuEntryConfig);
    /**
     * Create menu items and populate the menu model based on the given configuration.
     * @param items An array of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuItemConfig} objects to configure the menu items.
     * @return An array of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuItemModel}  objects created based on the provided configuration.
     */
    protected _createMenuItems(items: MenuItemConfig[]): MenuItemModel[];
}

}
declare module "geocortex/infrastructure/menus/MenuRegistry" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { MenuModel } from "geocortex/infrastructure/menus/MenuModel";
import { MenuWidgetParameters } from "geocortex/infrastructure/menus/MenuWidgetParameters";
import { MenuEntryConfig } from "geocortex/infrastructure/menus/MenuEntryConfig";
import { MenuConfig } from "geocortex/infrastructure/menus/MenuConfig";
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { BindingExpression } from "geocortex/framework/ui/BindingExpression";
import { MenuView } from "geocortex/infrastructure/menus/MenuView";
/**
 * MenuRegistry is a central management component for creating and accessing menu's from any module across the viewer.
 */
export class MenuRegistry {
    /** The ViewerApplication that this menu registry belongs to. */
    app: ViewerApplication;
    /** An array containing references to all the menus registered in the system. */
    menuList: MenuModel[];
    /** Array of viewId's mapped to their contained menu widget parameters. */
    protected _viewMenuEntries: {
        [viewId: string]: MenuWidgetParameters[];
    };
    /** Array of configurations for each Menu. */
    protected _menuConfig: MenuEntryConfig[];
    /**
     * Initializes a new instance of the MenuRegistry class.
     * @param app The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this menu registry belongs to.
     */
    constructor(app: ViewerApplication);
    /**
    * Creates and registers menu's based on the passed in configuration.
    * @param config A {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuConfig} configuration object.
    */
    loadMenus(config: MenuConfig): void;
    /**
    * Registers a menu, given from either a MenuEntryConfig or MenuModel object.
    * @param menu The instance of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuModel} or {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuEntryConfig} to be registered.
    */
    register(menu: MenuModel | MenuEntryConfig): void;
    /**
     * Unregisters a menu.
     * @param menuId The ID of the menu to be unregistered.
     */
    unregister(menuId: string): void;
    /**
     * Fetches a menu by id.
     * @param {string} Unique id of the menu.
     * @return The requested {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuModel} object or null if not found.
     */
    getMenu(id: string): MenuModel;
    /**
     * Fetches the default icon URI for a given menu.
     * @param {string} Id of the menu.
     * @return the URI of default icon for given menu.
     */
    getDefaultIconUri(id: string): string;
    /**
     * Given a view, returns descriptors of any menu widgets created by that view.
     * @param view The {@link framework.ui.ViewBase} object whose associated menu widget(s) we want to retrieve.
     * @return An array of {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuWidgetParameters} objects containing the requested widget(s).
     */
    getMenuWidgetsForView(view: ViewBase): MenuWidgetParameters[];
    /**
     * Generates a menu view based on dom attributes. The attributes that should be present on the DOM element being passed in are:
     * - data-menu-id: (Required) This defines the menu to populate within the created menu view
     * - data-menu-template: (Optional) If provided, this will be used as the template for the menu view being created. Default is Mapping/infrastructure/menus/MenuView.html
     * - data-menu-type: (Optional) If provided, this will be used as the code behind for the menu view being created. Default is geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuView
     * - data-menu-library-id: (Optional) If provided, this will be used as the library id for this menu View. This will override the manual libraryId input parameter if specified.
     * - data-menu-hoist-disabled: (Optional) If present, the menu will not be hoisted.
     * @param view The view that is requesting the menu widget.
     * @param context The current context of the widget, if available.
     * @param binding The binding expression passed in to the 'resolveWidget' method from which this method will typically be called.
     * @param libraryId The library ID for the created menu widget.
     * @param dynamicMenuId An optional id for the menu to be passed at runtime
     * @return A {@link geocortex.framework.ui.ViewBase}, bound, view widget object.
     */
    createMenuWidget(view: ViewBase, context: any, binding: BindingExpression, libraryId?: string, dynamicMenuId?: string): ViewBase;
    /**
     * Destroys the menu widget and all it's associated view model bindings and subscriptions. Automatically called when the widget view is destroyed.
     * @param menuWidgetView The menu widget view to destroy.
     */
    destroyMenuWidget(menuWidgetView: MenuView): void;
    /**
     * Checks if a given menu id is valid or not. For a menu id to be valid, it should be unique i.e. there should be no exisiting menu's registered with the same name.
     * @param id The menu ID to check for validity.
     * @return A boolean which returns true if the given menu ID is valid; false otherwise.
     */
    protected _validMenuId(id: string): boolean;
    /**
     * Validates a given menu model to ensure that it meets the minimum requirements for a valid menu.
     * @param menuModel The {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.menus.MenuModel} object to validate.
     * @return A boolean that returns true if the given MenuModel is valid; false otherwise.
     */
    protected _validateMenuModel(menuModel: MenuModel): boolean;
}

}
declare module "geocortex/infrastructure/menus/MenuView" {
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { MenuViewModel } from "geocortex/infrastructure/menus/MenuViewModel";
import { MenuItemViewModel } from "geocortex/infrastructure/menus/MenuItemViewModel";
/**
 * A generic and flexible menu view that binds to configured menus of commands and provides functionality to hide and show menu items
 * conditionally based on the `canExecute` status of the bound commands.
 */
export class MenuView extends ViewBase {
    /** @inherited */
    app: ViewerApplication;
    /** @inherited */
    viewModel: MenuViewModel;
    /** @inherited */
    attach(viewModel?: MenuViewModel): void;
    /**
     * Handles the click event of individual menu items.
     * @param evt The event.
     * @param element The element associated with this event.
     * @param menuItem The menu item that was clicked.
     */
    handleMenuItemClick(event: Event, element: HTMLElement, menuItem: MenuItemViewModel): void;
    /**
     * Handles the onfocus of individual menu items.
     * @param evt The event.
     * @param element The element associated with this event.
     * @param menuItem The menu item that was focussed.
     */
    handleMenuItemFocus(event: Event, element: HTMLElement, menuItem: MenuItemViewModel): void;
    /**
    * Handle showing the description, if the context has one.
    * @param evt The event.
    * @param element The element associated with this event.
    * @param context The context related to this event.
    */
    getDescription(event: Event, element: HTMLElement, context: any): void;
    /**
     * Destroy associated widget view model and bindings when this menu view is destroyed
     */
    onDestroy(): void;
}

}
declare module "geocortex/infrastructure/menus/MenuViewModel" {
import { ViewModelBase } from "geocortex/framework/ui/ViewModelBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { Observable, ObservableCollection } from "geocortex/framework/observables";
import { MenuItemViewModel } from "geocortex/infrastructure/menus/MenuItemViewModel";
import { ViewBase } from "geocortex/framework/ui/ViewBase";
/**
 * Holds information and state about an instance of a particular menu.
 */
export class MenuViewModel extends ViewModelBase {
    /** The default menu context parameter name. */
    static DefaultParameterName: string;
    /** @inherited */
    app: ViewerApplication;
    /** The unique ID of the menu. */
    menuId: string;
    /** The title of this menu, which may be used for presentation purposes. */
    menuTitle: Observable<string>;
    /** The description of this menu. */
    menuDescription: Observable<string>;
    /** Menu items associated with this menu. */
    menuItems: ObservableCollection<MenuItemViewModel>;
    /** Menu items that are currently executable or are currently non-executable but have their "hideOnDisable" setting set to false. */
    visibleMenuItems: ObservableCollection<MenuItemViewModel>;
    /** A boolean which is`true` if the menu has any executable menu items, `false` if not. */
    hasExecutableMenuItems: Observable<boolean>;
    /** The source view which has currently invoked this menu, or the view to which this menu 'belongs. */
    menuSourceView: ViewBase;
    /**
     * Context associated with the menu. If `commandParameter` is not specified on a menu item, it is passed the `menuContext`
     * itself upon invocation. If `commandParameter` is specified, it is passed to the specified command.
     * If `commandParameter` has properties with string value tokens in the format of `{{SomeProperty}}`, these properties will
     * be resolved against properties of the `menuContext` itself.
     */
    menuContext: Observable<any>;
    constructor(app: ViewerApplication, libraryId?: string);
    /**
     * Initializes this menu view model based on the provided configuration
     * @param config The configuration for this menu view model
     */
    initialize(config: any): void;
    /**
     * Retrieves the menu for this view model from the menu registry and sets it up. This is done only when the view requests it as part of it's attach routine.
     * @param id the id of the menu to set up this view model for
     */
    setupMenu(menuId?: string): void;
    /**
     * Clean up when this menu view model is destroyed
     */
    onDestroy(): void;
    /**
     * This function executes when the `canExecute` of any of the menu items changes, or a new element is added to the list.
     */
    protected _computeExecutableMenuItems(): void;
    /**
    * Applies menu context changes to all items in the menu.
    * @param context The new context to be applied to this menu.
    */
    protected _handleContextChanged(menuContext: any): void;
    /**
    * When the collection changes, we'll need to decide how to handle the elements. Removals and clears remove from the executable list,
    * Additions need only re execute canExecuteChanged to decide whether to display or not.
    * @param changedArgs Indicate the type of change made to the menu items.
    */
    protected _handleMenuItemsChanged(changedArgs: any): void;
}

}
declare module "geocortex/infrastructure/menus/MenuWidgetParameters" {
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { MenuView } from "geocortex/infrastructure/menus/MenuView";
import { MenuViewModel } from "geocortex/infrastructure/menus/MenuViewModel";
/**
 * Parameters associated with the menu widget created by the menu registry.
 */
export interface MenuWidgetParameters {
    /** The view that is hosting the menu widget. */
    view: ViewBase;
    /** The created and attached menu widget view. */
    widgetView: MenuView;
    /** The menu widget view model. */
    widgetViewModel: MenuViewModel;
    /** The source context to which the MenuViewModel context is sync'ed, if it's an observable, or the source context itself if it's not. */
    context: any;
    /** The ID of the menu represented by this menu widget. */
    menuId: string;
    /** Whether the menu should be hoisted. */
    hoistMenu: boolean;
    /** Reference to the DOM element where this menu widget is hosted. */
    domElement: HTMLElement;
}

}
declare module "geocortex/infrastructure/offline/BasemapDeleting" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { OfflineMapBasemap } from "geocortex/infrastructure/offline/OfflineMap";
/**
 * Delete basemaps from the device.  Takes an OfflineMapBasemap array instead of an OfflineMap because
 * the geometry isn't needed and it makes sense to delete a subset of the basemaps.
 * @param app
 * @param basemaps
 * @param cancellationToken
 * @param progress
 */
export function deleteBasemaps(app: ViewerApplication, basemaps: OfflineMapBasemap[]): Promise<void>;

}
declare module "geocortex/infrastructure/offline/BasemapDownloading" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { OfflineMap } from "geocortex/infrastructure/offline/OfflineMap";
import { OfflineMapProgress } from "geocortex/infrastructure/offline/OfflineMapProgressClient";
import { CancellationToken } from "geocortex/infrastructure/CancellationToken";
import { Progress } from "geocortex/infrastructure/offline/Progress";
/**
 * Downloads all OfflineBasemaps in the OfflineMap as necessary.
 * @param offlineMap
 * @param progress
 * @private
 */
export function downloadBasemaps(app: ViewerApplication, offlineMap: OfflineMap, state: OfflineMapProgress, cancellationToken: CancellationToken, progress?: (progress: Progress) => void): Promise<void>;
/**
 * Gets the service token for a secured map service. If not secured, function returns an empty string
 * @param uri The esri map service URI.
 */
export function getServiceTokenForMapService(app: ViewerApplication, uri: string): string;

}
declare module "geocortex/infrastructure/offline/OfflineManager" {
import { OfflineMap } from "geocortex/infrastructure/offline/OfflineMap";
import { AreaOfInterestMask } from "geocortex/infrastructure/AreaOfInterestMask";
import { SyncInfo } from "geocortex/infrastructure/offline/SyncInfo";
import { Observable } from "geocortex/framework/observables";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { Progress } from "geocortex/infrastructure/offline/Progress";
/**
 * Manages offline state.  Chief among the offline state is the offline map
 * which defines what data will be available offline and how offline requests
 * are handled.  Offline profiles that are added may be activated when offline.
 */
export class OfflineManager {
    app: ViewerApplication;
    libraryId: string;
    /**
     * A promise for the last offline map operation.  Chain .finally() off this for all operations
     * that touch the list of profiles or storage to keep the list consistent.  Recursion will
     * cause deadlocks so keep it simple.
     */
    private _lastOperation;
    private _activeOfflineMapId;
    private _isCancelling;
    private _previousActiveOfflineMapId;
    private _cancellationTokenSource;
    private _offlineMaps;
    private _bundleManager;
    private _progressClient;
    /** The mask that hides everything outside of the offline map area of interest. Can be configured. */
    aoiMask: AreaOfInterestMask;
    /** Information about the currently active offline map. */
    syncInfo: SyncInfo;
    /** Whether or not the current job can be canceled */
    canCancel: Observable<boolean>;
    /**
     * An indiciator of whether or not there is an active offline map.
     * This property is preferable to app.isOffline (which is deprecated) because it more accurately describes
     * the state of the application. There is no binary online/offline switch, so app.isOffline is misleading.
     * Even though an offline map is active, the device may still have internet connectivity.
     */
    isOfflineMapActive: Observable<boolean>;
    /**
     * The current operation being performed by the OfflineManager.
     */
    currentOperation: OfflineManagerOperation;
    constructor(app: ViewerApplication, libraryId: string);
    /**
     * Add an offline map.  The site information and features are downloaded.
     * @param offlineMap The offline map to add.
     * @param progress An optional callback for a stream of progress messages.
     */
    addOfflineMap(offlineMap: OfflineMap, progress?: (progress: Progress) => void): Promise<void>;
    /**
     * Remove an offline map.  The site information and feature data is deleted.
     * @param offlineMap The offline map to remove, or its ID.
     * @param progress An optional callback for a stream of progress messages.
     */
    removeOfflineMap(offlineMap: string | OfflineMap, progress?: (message: string) => void): Promise<void>;
    /**
 * Remove an offline map.  The site information and feature data is deleted.
 * @param offlineMap The offline map to remove, or its ID.
 * @param progress An optional callback for a stream of progress messages.
 */
    removeOfflineMapPartialData(offlineMap: OfflineMap, firstDownload: boolean): Promise<void>;
    /**
     * Remove an offline map right now, without waiting for the previous operation to complete.
     */
    private _removeOfflineMapNow(offlineMapOrId, progress?);
    syncFeatureData(offlineMaps: OfflineMap[], totalProgress?: (progress: Progress) => void): Promise<void[]>;
    /**
     * Sync an offline map.  Edits are sent to the server, then feature data redownloaded,
     * then the site data is redownloaded.
     * @param offlineMapOrId The offline map to sync, or its ID.
     * @param progress An optional callback for a stream of progress messages.
     */
    syncOfflineMap(offlineMapOrId: string | OfflineMap, progress?: (progress: Progress) => void, syncSteps?: SyncSteps): Promise<void>;
    /**
     * Updates the bundle for an offline map without syncing.
     * @param offlineMap The offline map to sync, or its ID.
     */
    updateBundle(offlineMap: string | OfflineMap): Promise<void>;
    /**
     * Make an offline map active.  When offline this is the data from which offline
     * data is served.
     * @param offlineMap The offline map to make active, or its ID.
     * @param userAction Set to true if the activation is happening as a result of the user
     * explicitly clicking a button to activate the offline map. Set to false if the activation
     * is happening automatically without the user explicitly activating the offline map.
     */
    activateOfflineMap(offlineMapOrId: string | OfflineMap, userAction?: boolean): Promise<void>;
    /**
     * Make no offline map active.  This will succeed even if there is no
     * active profile.
     * @param userAction Set to true if the activation is happening as a result of the user
     * explicitly clicking a button to activate the offline map. Set to false if the activation
     * is happening automatically without the user explicitly activating the offline map.
     */
    deactivateOfflineMap(userAction?: boolean): Promise<void>;
    /**
     * Cancels the current sync or download.
     */
    cancel(): Promise<void>;
    /**
     * Clears out the last operation, so that the next operation can just go ahead without waiting for the last operation to complete.
     * This should be used with caution, only called in extreme circumstances - for example if the last operation is hung.
     */
    forgetLast(): void;
    /**
     * Get the offline map with the given ID or null if not found.
     * @param offlineMapId
     */
    getOfflineMapById(offlineMapId: string): OfflineMap;
    /**
     * Get the offline map state with the given ID or null if not found.
     * @param offlineMapId
     */
    getOfflineMapWithStateById(offlineMapId: string): {
        state: OfflineMapState;
        offlineMap: OfflineMap;
        syncInfoPromise: Promise<SyncInfo>;
    };
    /**
     * Get all offline maps.
     */
    getOfflineMaps(): OfflineMap[];
    /**
     * Get all offline maps with state and sync info.
     */
    getOfflineMapsWithState(): {
        state: OfflineMapState;
        offlineMap: OfflineMap;
        syncInfoPromise: Promise<SyncInfo>;
    }[];
    /**
     * Get the currently active offline map or null if none.
     */
    getActiveOfflineMap(): OfflineMap;
    /**
     * Get the currently active offline map with state or null if none.
     */
    getActiveOfflineMapWithState(): {
        state: OfflineMapState;
        offlineMap: OfflineMap;
        syncInfoPromise: Promise<SyncInfo>;
    };
    /**
     * Refresh the sync info object.
     */
    refreshSyncInfo(offlineMapParam?: string | OfflineMap): Promise<SyncInfo>;
    private _getOfflineMapInfo(offlineMapParam?);
    /**
     * Save the state of the OfflineManager to storage.  This goes in the promise chain of anything that
     * changes the state.
     */
    private _save();
    /**
     * Load the state of the OfflineManager from storage.  This should only be called on start up.
     */
    load(): Promise<any>;
    /**
     * Gets a resource from the store with the specified key, for the specified offline map.
     */
    setStoreResource(offlineMap: OfflineMap, key: string, value: string): Promise<void>;
    /**
     * Gets a resource from the store with the specified key, for the specified offline map.
     */
    getStoreResource(offlineMap: OfflineMap, key: string): Promise<string>;
    /**
     * Checks to see if the host can be accessed, indicating that there is connectivity
     * @returns An object whose result indicates if there is connectivity to the site's host
     */
    hasInternetCheck(): Promise<any>;
    /**
     * Creates a priority sequence of offline map ids whereby we should use the first one that is workable.
     */
    private _prioritizeOfflineMaps(state, offlineMaps);
    /**
     * Employs some intelligence to determine which offline map should be loaded, if any.
     * This method is recursive and will keep trying to initialize with the offline map ids
     * in the sequence provided until it finds one that is workable.
     */
    private _initializeMap(offlineMapIds);
    /**
     * Updates the site principal for each offline map that matches the current site.
     */
    updatePrincipal(): Promise<void[]>;
    /**
     * Waits for the last operation to complete, absorbing any errors in the process, because we don't care
     * about errors from the last operation when starting a new operation.
     */
    private _waitForLast();
    /**
     * Throws an error if cancellation has been requested.
     */
    private _throwIfCanceled();
    private _throwIfNotNativeInitialized();
    /**
     * Load an OfflineMap from storage.  Offline profiles are kept in memory so this
     * is only necessary on start up.
     * @param offlineMapId
     */
    private _loadOfflineMapFromStorage(offlineMapId);
    /**
     * There could be user added layers that were stored in the offline map that aren't in the map at startup
     * We are going to add those layers.
     * Currently those layers are not removed from the map when the offline map is deactivated. This could be added later.
     * @param offlineMapId
     */
    private _restoreOfflineUserAddedLayers(offlineMap);
    /**
     * Get the index of the OfflineMap.  The index of an OfflineMap is never
     * exposed outside this class.
     * @param offlineMap The offline map or its ID.
     */
    private _getOfflineMapIx(offlineMap);
    /**
     * Get the array with information mapping map service URLs to downloaded tpk filename.
     * @param offlineMap
     */
    private _getOfflineMapBasemapMapping(offlineMap);
    /**
     * Get the key to retrieve the offline map content from the store.
     * @param offlineMap The offline map ID or the offline map itself.
     */
    private _getOfflineMapKey(offlineMap);
    /**
     * Get from the store in promise form.  This will hopefully be moved into Store in 3.0.
     * @param key
     */
    private _appStoreGetPromise(key);
    /**
     * Set to the store in promise form.  This will hopefully move into Store in 3.0.
     * @param key
     * @param value
     */
    private _appStoreSetPromise(key, value);
    /**
     * Remove from the store in promise form.  This will hopefully move into Store in 3.0.
     * @param key
     */
    private _appStoreRemovePromise(key);
    getResource(key: string): string;
    private _setOfflineMap(state, offlineMap);
}
export interface OfflineMapState {
    id: string;
    isDownloaded: boolean;
    hasProgress: boolean;
}
export enum OfflineManagerOperation {
    Download = 1,
    Sync = 2,
    Remove = 3,
    Activate = 4,
    Deactivate = 5,
    RemovePartial = 6,
}
export interface SyncSteps {
    featureDataSync: boolean;
    basemapDownloads: boolean;
    updateBundle: boolean;
    refreshMap: boolean;
}

}
declare module "geocortex/infrastructure/offline/OfflineMap" {
import { Document } from "geocortex/essentials/documents/Document";
export interface OfflineMap extends Document {
    content?: OfflineMapContent;
}
export interface OfflineMapContent {
    /**
     * The geometry to include in the OfflineMap.  This is the JSON representation
     * of an esri Polygon.
     */
    geometry: {
        /**
         * Each ring is represented as an array of points. The first point of each ring is
         * always the same as the last point. And each point in the ring is represented as
         * a 2-element array. The 0-index is the x-coordinate and the 1-index is the y-coordinate.
         */
        rings: number[][][];
        /**
         * The spatial reference must be specified using a well-known ID (wkid) or well-known text (wkt).
         */
        spatialReference: {
            wkid?: number;
            wkt?: string;
        };
    };
    /**
     * The layers to include in the offline data.
     */
    layers: OfflineMapLayer[];
    /**
     * The basemaps to include in the offline data.
     */
    basemaps: OfflineMapBasemap[];
    /**
     * Whether to incluide attachments in the offline data.
     */
    includeAttachments: boolean;
}
export interface OfflineMapLayer {
    /**
     * The identifier for the layer.
     * see: geocortex.essentialsHtmlViewer.mapping.infrastructure.gis.LayerInfo
     */
    layerInfoUniqueId: string;
    /**
     * An optional definition expression to be applied to the query that downloads data.
     * This is not the same as a where clause on the layer itself, as it is for this offline map only.
     */
    definitionExpression?: string;
    isUserCreated?: boolean;
    layerJson?: any;
    serviceInfo?: OfflineServiceInfo;
}
export interface OfflineServiceInfo {
    url: string;
    capabilities: string[];
}
export interface OfflineMapBasemap {
    /**
     * The identifier for the BaseMap.
     * see: geocortex.essentials.BaseMap
     */
    baseMapId: string;
    /**
     * The type of the source of the TPK.  This determines how the TPK is downloaded.
     * see OfflineMapBasemap.Type.
     */
    sourceType: string;
    /**
     * The URL to download the TPK or exportTiles.
     */
    url: string;
    /**
     * The name of the file the basemap should be downloaded to.
     */
    filename: string;
    /**
     * The size of the basemap in bytes.  This is an estimate for dynamically created TPKs,
     * and an exact value for static.
     */
    size: number;
    /**
     * The minimum level to use in the basemap.  Doesn't apply to static type.
     */
    minLevel?: number;
    /**
     * The maximum level to use in the basemap.  Doesn't apply to static type.
     */
    maxLevel?: number;
    /**
     * Period in days a TPK is valid before it should be refreshed.
     */
    refreshInterval?: number;
}
export module OfflineMap {
    /**
     * Perform basic verification on the OfflineMap.  Throws errors if the OfflineMap
     * is malformed.
     * @param offlineMap The OfflineMap to verify.
     */
    function verify(offlineMap: OfflineMap): void;
    /**
     * Compare the two offline maps and return an object containing only the values
     * that are different in offlineMapB.
     * @param offlineMapA The offline map to compare from.
     * @param offlineMapB The offline map to compare to, where differing values will come from.
     * @return An offline map-like object containing only the differences.
     */
    function diff(offlineMapA: OfflineMap, offlineMapB: OfflineMap): OfflineMap;
}
export module OfflineMapBasemap {
    var Type: {
        EXPORT_TILES: string;
        PREGENERATED: string;
    };
}

}
declare module "geocortex/infrastructure/offline/OfflineMapProgressClient" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
/**
 * @private
 */
export class OfflineMapProgressClient {
    app: ViewerApplication;
    constructor(app: ViewerApplication);
    getLastOperationProgress(offlineMapId: string): Promise<OfflineMapProgress>;
    resetOfflineMapProgress(offlineMapId: string): Promise<any>;
    setOfflineBasemapProgress(offlineMapId: string, basemapProgress: BasemapProgress): Promise<any>;
}
export function wasOfflineMapSyncInterupted(state: OfflineMapProgress): boolean;
/**
 * @private
 */
export interface OfflineMapProgress {
    referenceId: string;
    layers: LayerProgress[];
    basemaps: BasemapProgress[];
}
/**
 * @private
 */
export interface LayerProgress {
    url: string;
    status: ProgressStatus;
    errorMessage: string;
}
/**
 * @private
 */
export interface BasemapProgress {
    referenceId: string;
    status: ProgressStatus;
    errorMessage?: string;
    type: string;
    statusUrl?: string;
    filename?: string;
}
/**
 * @private
 */
export type ProgressStatus = "notStarted" | "inProgress" | "complete" | "error";
/**
 * @private
 */
export const ProgressStatus: {
    NotStarted: ProgressStatus;
    InProgress: ProgressStatus;
    Complete: ProgressStatus;
    Error: ProgressStatus;
};

}
declare module "geocortex/infrastructure/offline/Progress" {
/**
 * A progress status update message, internal to the offline namespace.
 * @private
 */
export interface Progress {
    message: string;
    percentage: number;
    isWarning?: boolean;
}

}
declare module "geocortex/infrastructure/offline/StringFormatting" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
/**
 * @private
 */
export function formatByteTransferRateString(app: ViewerApplication, bSec: number): string;
/**
 * @private
 */
export function formatBytesString(app: ViewerApplication, bytes: number): string;

}
declare module "geocortex/infrastructure/offline/SyncEngine" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { SyncInfo } from "geocortex/infrastructure/offline/SyncInfo";
import { SyncParameters } from "geocortex/infrastructure/offline/SyncParameters";
import { CancellationToken } from "geocortex/infrastructure/CancellationToken";
import { SyncProgress } from "geocortex/infrastructure/offline/SyncProgress";
export class SyncEngine {
    static STATUS_IN_PROGRESS: string;
    static STATUS_SUCCESS: string;
    static STATUS_ERROR: string;
    static getSyncInfo(app: ViewerApplication, profileName: string): Promise<SyncInfo>;
    static sync(app: ViewerApplication, parameters: SyncParameters, cancellationToken: CancellationToken, progress: (progress: SyncProgress) => void): Promise<SyncProgress>;
    private static _sync(app, options, cancellationToken, progress);
    private static _cancel(app);
    static deleteData(app: ViewerApplication, profile: string): Promise<any>;
    static deletePartialData(app: ViewerApplication, profile: string, firstDownload: boolean): Promise<any>;
    private static _unregisterOfflineDeletedReplicas(app);
    private static _getFeatureServiceTokenInfo(app);
}

}
declare module "geocortex/infrastructure/offline/SyncInfo" {
export interface SyncInfoJson {
    servers: SyncServerInfo[];
    lastSyncNotificationDate: Date;
}
export interface SyncServerInfo {
    /** The URL of the server, not including the layer id - ie. up to /MapServer or /FeatureServer. */
    featureServiceUrl: string;
    /** A collection of layers *and* tables that are synced. */
    layers: SyncLayerInfo[];
    /** The local server URL that replaces the online feature server when offline. */
    localServerUrl: string;
    /** Whether attachments have been downloaded or not. */
    attachmentsDownloaded: boolean;
    /** Number of offline feature adds (new records). */
    numberOfAdds: number;
    /** Number of offline feature edits. */
    numberOfEdits: number;
    /** Number of offline deleted records. */
    numberOfDeletes: number;
    /** The size of the database used for storing this data offline. */
    totalSizeInBytes: number;
    /** The last sync time. */
    lastSyncTime: Date;
}
export interface SyncLayerInfo {
    id: number;
    canAddAttachments: boolean;
    canEdit: boolean;
}
export class SyncInfo implements SyncInfoJson {
    servers: SyncServerInfo[];
    lastSyncNotificationDate: Date;
    constructor(syncInfo: SyncInfoJson);
    isSynced(url: string): boolean;
    findLayerOrTable(url: string): SyncLayerInfo;
    getOldestSyncTime(): Date;
}

}
declare module "geocortex/infrastructure/offline/SyncParameters" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { OfflineMap } from "geocortex/infrastructure/offline/OfflineMap";
/**
 * Parameters to the SyncEngine.sync call.
 */
export interface SyncParameters {
    profile: string;
    featureServices: FeatureServiceParameters[];
    geometry: esri.geometry.Geometry;
    includeAttachments: boolean;
    mapSpatialReference: esri.SpatialReference;
}
/**
 * Feature service parameters in the SyncParameters object.
 */
export interface FeatureServiceParameters {
    url: string;
    layers: LayerSyncParameter[];
    capabilities: string[];
    token?: string;
}
export interface LayerSyncParameter {
    id: number;
    displayName: string;
    where?: string;
    layerDrawingOptions?: any;
    dynamicLayerInfo?: any;
}
export module SyncParameters {
    /**
     * Builds a SyncParameters object from an OfflineMap.
     * @param app The app from which the map and appInfo are derived.
     * @param offlineMap The OfflineMap to build SyncParameters from.
     */
    function buildSyncParameters(app: ViewerApplication, offlineMap: OfflineMap): SyncParameters;
}

}
declare module "geocortex/infrastructure/offline/SyncProgress" {
export interface SyncProgress {
    state: string;
    text: string;
    serviceProgress?: number;
    overallProgress?: number;
    serviceUrl: string;
    editsSentToServer?: boolean;
    warnings: string[];
}

}
declare module "geocortex/infrastructure/offline/TokenRefresher" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
export class TokenRefresher {
    /**
     * @private
     */
    static ensureAllTokensAreUpToDate(app: ViewerApplication): Promise<void>;
}

}
declare module "geocortex/infrastructure/offline/WorkCalculator" {
import { OfflineMap } from "geocortex/infrastructure/offline/OfflineMap";
import { SyncSteps } from "geocortex/infrastructure/offline/OfflineManager";
/**
 * @private
 */
export interface WorkDescription {
    saveProfileWork: number;
    bundleWork: number;
    featureLayerWork: number;
    basemapWork: number;
}
/**
 * Utility class to calculate work being done for sync.
 * @private
 */
export class WorkCalculator {
    static calculateFirstDownloadWork(profile: OfflineMap): WorkDescription;
    static calculateSyncWork(profile: OfflineMap, syncSteps: SyncSteps): WorkDescription;
    static noWork(): WorkDescription;
    static calculatePercentageComplete(completedWork: WorkDescription, totalWork: WorkDescription): number;
    private static _calculateTotalWork(work);
}

}
declare module "geocortex/infrastructure/project/BaseMapLayer" {
import { BaseMapLayer } from "geocortex/infrastructure/webMap/BaseMapLayer";
import { ServiceLayer } from "geocortex/infrastructure/project/ServiceLayer";
import { Layer } from "geocortex/infrastructure/project/Layer";
export interface BaseMapLayer extends BaseMapLayer, ServiceLayer {
    layers: Layer[];
}

}
declare module "geocortex/infrastructure/project/CoordinateSystem" {
export interface CoordinateSystem {
    /** The WKID for the coordinate system. */
    wkid?: number;
    /** The WKT for the coordinate system. */
    wkt?: string;
    output: string;
}

}
declare module "geocortex/infrastructure/project/DrawingInfo" {
import { DrawingInfo } from "geocortex/infrastructure/webMap/DrawingInfo";
import { Color } from "geocortex/infrastructure/webMap/Symbol";
export interface DrawingInfo extends DrawingInfo {
    /** Settings used for feature clustering visualization. */
    clustering?: {
        radius: number;
        backgroundColor: Color;
        labelColor: Color;
        maximumFeatures: number;
        enabled: boolean;
    };
    /** Whether labels for the layer are visible. The default is true. */
    showLabels?: boolean;
    /** labelingInfo for customizeable labels **/
    labelingInfo?: LabelClass[];
}
export interface LabelClass extends DrawingInfo {
    labelClass?: {
        fieldInfos: Object[];
        labelExpression: string;
        labelExpressionInfo: Object;
        labelPlacement: string;
        maxScale: number;
        minScale: number;
        sizeInfo: Object;
        symbol: {
            align: string;
            angle: number;
            color: {
                a: number;
                b: number;
                g: number;
                r: number;
            };
            decoration: string;
            font: {
                decoration: string;
                family: string;
                size: number;
                style: string;
                variant: string;
                weight: string;
            };
            haloColor: {
                a: number;
                b: number;
                g: number;
                r: number;
            };
            haloSize: number;
            horizontalAlignment: string;
            kerning: boolean;
            rotated: boolean;
            text: string;
            type: string;
            verticalAlignment: string;
            xoffset: number;
            yoffset: number;
        };
        useCodedValues: boolean;
        where: string;
    };
}

}
declare module "geocortex/infrastructure/project/Feature" {
import { Feature } from "geocortex/infrastructure/webMap/Feature";
import { Layer } from "geocortex/infrastructure/project/Layer";
import { ServiceLayer } from "geocortex/infrastructure/project/ServiceLayer";
import { FeatureSet } from "geocortex/infrastructure/project/FeatureSet";
import { Color } from "geocortex/infrastructure/webMap/Symbol";
export interface Feature extends Feature {
    /** The Essentials layer associated with the feature. Only necessary if {@link featureSet} is not specified. */
    layer?: Layer;
    /**
     * The primary key value for the feature. If specified, {@link layer} must also be specified.
     * In this case, the {@link webMap.Feature.attributes} and {@link webMap.Feature.geometry} should not be specified. Instead,
     * they will be fetched by querying the layer.
     */
    id?: any;
    /**
     * The Esri feature layer containing field metadata for formatting attribute data. Only necessary when
     * the feature is not associated with an Essentials Layer.
     */
    featureLayer?: ServiceLayer;
    featureSet: FeatureSet;
    allowUnsafeContent?: boolean;
    extendedProperties?: {
        [name: string]: any;
    };
    defaultNumberFormat?: string;
    defaultDateFormat?: string;
    timeZoneId?: string;
    displayTimeZoneId?: string;
    borderColor?: Color;
    fillColor?: Color;
    borderWidth?: number;
}

}
declare module "geocortex/infrastructure/project/FeatureCollection" {
import { FeatureCollection } from "geocortex/infrastructure/webMap/FeatureCollection";
import { Layer } from "geocortex/infrastructure/project/Layer";
export interface FeatureCollection extends FeatureCollection {
    layers: Layer[];
}

}
declare module "geocortex/infrastructure/project/FeatureSet" {
import { FeatureSet } from "geocortex/infrastructure/webMap/FeatureSet";
import { Feature } from "geocortex/infrastructure/project/Feature";
import { Layer } from "geocortex/infrastructure/project/Layer";
export interface FeatureSet extends FeatureSet {
    id?: string;
    features: Feature[];
    allowUnsafeContent?: boolean;
    extendedProperties?: {
        [name: string]: any;
    };
    layer?: Layer;
    displayName?: string;
    iconUri?: string;
}

}
declare module "geocortex/infrastructure/project/FeatureSetCollection" {
import { FeatureSet } from "geocortex/infrastructure/project/FeatureSet";
export interface FeatureSetCollection {
    id: string;
    displayName: string;
    featureSets: FeatureSet[];
    sourceName: string;
    tag: any;
    extendedProperties?: {
        [name: string]: any;
    };
}

}
declare module "geocortex/infrastructure/project/Layer" {
import { Layer } from "geocortex/infrastructure/webMap/Layer";
import { ServiceLayer } from "geocortex/infrastructure/project/ServiceLayer";
import { LayerDefinition } from "geocortex/infrastructure/project/LayerDefinition";
import { FeatureSet } from "geocortex/infrastructure/project/FeatureSet";
export interface Layer extends Layer {
    serviceLayer: ServiceLayer;
    layerDefinition?: LayerDefinition;
    featureSet?: FeatureSet;
    /** Whether the layer is a dynamic layer. If this is true, then layerDefinition should be specified as well. */
    isDynamic?: boolean;
    /** The id of the currently enabled layer style, if any. */
    layerStyleId?: string;
    /** Whether or not the layer was created by a user at runtime **/
    isUserCreated?: boolean;
    /**
     * The type of user created layer, if any. One of:
     *  - LayerAddition - the layer was added by browsing/searching for services and layers in a dialog
     *  - LayerCatalog - the layer was added from a catalog
     *  - Upload - the layer was added by uploading a file
     *
     * Only applies to layers created at runtime.
     */
    userLayerType?: string;
    /** The geocortex layer definition as returned from essentials.Layer.toJson(). Used for user-added layers. */
    gcxLayerDefinition?: any;
}

}
declare module "geocortex/infrastructure/project/LayerDefinition" {
import { LayerDefinition } from "geocortex/infrastructure/webMap/LayerDefinition";
import { DrawingInfo } from "geocortex/infrastructure/project/DrawingInfo";
export interface LayerDefinition extends LayerDefinition {
    drawingInfo: DrawingInfo;
}

}
declare module "geocortex/infrastructure/project/ModuleState" {
/**
 * Base interface for a module's persistent state.
 */
export interface ModuleState {
    /**
     * Identifies the version of the serialized project data. The default is 1.
     * Modules should increment this number whenever there are breaking changes to the
     * model that need special handling.
     */
    serialVersion?: number;
}

}
declare module "geocortex/infrastructure/project/OperationalLayer" {
import { OperationalLayer } from "geocortex/infrastructure/webMap/OperationalLayer";
import { ServiceLayer } from "geocortex/infrastructure/project/ServiceLayer";
import { Layer } from "geocortex/infrastructure/project/Layer";
import { FeatureCollection } from "geocortex/infrastructure/project/FeatureCollection";
import { LayerDefinition } from "geocortex/infrastructure/project/LayerDefinition";
export interface OperationalLayer extends OperationalLayer, ServiceLayer {
    layers: Layer[];
    featureCollection: FeatureCollection;
    layerDefinition: LayerDefinition;
}

}
declare module "geocortex/infrastructure/project/Project" {
import { Point } from "geocortex/infrastructure/webMap/Geometry";
import { ModuleState } from "geocortex/infrastructure/project/ModuleState";
import { Document } from "geocortex/essentials/documents/Document";
export interface ApplicationState {
    /** The map's center point. */
    mapCenter?: Point;
    /** The map's scale. */
    mapScale?: number;
    /** The project state for each module. */
    moduleState: {
        [moduleName: string]: ModuleState;
    };
    /**
     * Determines whether special pointers within the project data have been decoded back into shared object references.
     * See {@link ProjectManager.encodeReferences} and {@link ProjectManager.decodeReferences}.
     */
    isDecoded?: boolean;
}
export interface Project extends Document {
    content?: ApplicationState;
}

}
declare module "geocortex/infrastructure/project/ProjectConverter" {
import { WebMapConverter } from "geocortex/infrastructure/webMap/WebMapConverter";
import { MapService } from "geocortex/essentials/MapService";
import { ServiceLayer } from "geocortex/infrastructure/project/ServiceLayer";
import { Layer } from "geocortex/essentials/Layer";
import { Layer as ProjectLayer } from "geocortex/infrastructure/project/Layer";
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
import { FeatureSetCollection as ProjectFeatureSetCollection } from "geocortex/infrastructure/project/FeatureSetCollection";
import { FeatureSet } from "geocortex/infrastructure/FeatureSet";
import { FeatureSet as ProjectFeatureSet } from "geocortex/infrastructure/project/FeatureSet";
import { Feature, NameValueProperty } from "geocortex/infrastructure/Feature";
import { Feature as ProjectFeature } from "geocortex/infrastructure/project/Feature";
import { Layer as WebMapLayer } from "geocortex/infrastructure/webMap/Layer";
import { ServiceLayer as WebMapServiceLayer } from "geocortex/infrastructure/webMap/ServiceLayer";
import { LayerDefinition } from "geocortex/infrastructure/webMap/LayerDefinition";
import { DrawingInfo } from "geocortex/infrastructure/project/DrawingInfo";
import { Feature as WebMapFeature } from "geocortex/infrastructure/webMap/Feature";
import { ObservableCollection } from "geocortex/framework/observables";
export const PROPERTY_MEASUREMENT_ID = "measurementId";
export const PROPERTY_HIGHLIGHT_ID = "__gcxHlId";
/**
 * Provides methods for converting between Geocortex/Esri API objects and their project equivalents.
 *
 * Note that once an input object has been converted, any additional attempts to convert it again will always return
 * a reference to the same result object (this is a form of the Identity Map pattern). To reset this mapping, use clearCache().
 */
export class ProjectConverter extends WebMapConverter {
    /**
     * A filter that determines which properties to save and restore for user-added layers.
     */
    protected _gcxLayerDefinitionFilter: Object;
    /**
     * A filter that determines which properties to save and restore for user-added map services.
     */
    protected _gcxMapServiceDefinitionFilter: Object;
    /**
     * Maps a result type to a cache of excluded Geocortex/Esri API objects for that type.
     * Excluded objects are not converted to their project equivalents.
     */
    private _exclusionCache;
    exclude(object: any, destType: string): void;
    clearExclusionCache(): void;
    clearCache(): void;
    fromGcxMapService(mapService: MapService): ServiceLayer;
    fromGcxLayer(layer: Layer): ProjectLayer;
    fromGcxFeatureSetCollection(fsc: FeatureSetCollection): ProjectFeatureSetCollection;
    fromGcxFeatureSet(featureSet: FeatureSet): ProjectFeatureSet;
    fromEsriFeatureSet(featureSet: esri.tasks.FeatureSet): ProjectFeatureSet;
    fromEsriLayer(layer: esri.layers.Layer): ServiceLayer;
    fromGcxFeature(feature: Feature): ProjectFeature;
    fromEsriGraphic(graphic: esri.Graphic): ProjectFeature;
    toGcxFeatureSetCollection(fsc: ProjectFeatureSetCollection): Promise<FeatureSetCollection>;
    protected _canCreateGcxLayer(layer: WebMapLayer, mapService: MapService): boolean;
    protected _canCreateGcxMapService(serviceLayer: WebMapServiceLayer): boolean;
    protected _createGcxMapService(serviceLayer: WebMapServiceLayer): Promise<MapService>;
    protected _createGcxLayer(layer: WebMapLayer, mapService: MapService): Promise<Layer>;
    protected _getMapServiceDefinition(serviceLayer: WebMapServiceLayer): any;
    protected _getWebMapLayerDefinitionFromDynamicLayer(dynamicServiceLayer: esri.layers.ArcGISDynamicMapServiceLayer, layerId: number): LayerDefinition;
    protected _applyDynamicLayerInfo(layer: ProjectLayer, index: number, gcxLayer: Layer): void;
    protected _applyDrawingInfo(drawingInfo: DrawingInfo, mapService: MapService): Promise<void>;
    protected _setGraphicsLayerRenderer(serviceLayer: esri.layers.GraphicsLayer, renderer: esri.renderer.Renderer): void;
    protected _applyWebMapLayerToGcxLayer(layer: WebMapLayer, index: number, gcxLayer: Layer): Promise<boolean>;
    protected _toGcxLayer(layer: WebMapLayer, serviceLayer: WebMapServiceLayer): Promise<Layer>;
    protected _toGcxFeatureSetCollection(fsc: ProjectFeatureSetCollection): Promise<FeatureSetCollection>;
    protected _toGcxFeatureSet(featureSet: ProjectFeatureSet): Promise<FeatureSet>;
    protected _toGcxFeature(feature: ProjectFeature): Promise<Feature>;
    protected _createGcxFeature(feature: ProjectFeature): Promise<Feature>;
    protected _applyFeatureToGcxFeature(feature: ProjectFeature, gcxFeature: Feature): Promise<void>;
    protected _findMatchingGcxFeature(feature: ProjectFeature, gcxFeatureSet: FeatureSet): Promise<Feature>;
    protected _queryFeatures(features: ProjectFeature[], featureSet: ProjectFeatureSet): Promise<esri.Graphic[]>;
    protected _toEsriGraphic(feature: WebMapFeature): Promise<esri.Graphic>;
    protected _toEsriFeatureSet(featureSet: ProjectFeatureSet): Promise<esri.tasks.FeatureSet>;
    protected _fromGcxMapService(mapService: MapService): ServiceLayer;
    protected _fromGcxlayer(layer: Layer): ProjectLayer;
    protected _fromGcxFeatureSetCollection(fsc: FeatureSetCollection): ProjectFeatureSetCollection;
    protected _fromGcxFeatureSet(featureSet: FeatureSet): ProjectFeatureSet;
    protected _fromGcxFeature(feature: Feature): ProjectFeature;
    protected _fromEsriGraphic(graphic: esri.Graphic): WebMapFeature;
    protected _toGcxExtendedProperties(extendedProperties: {
        [name: string]: any;
    }, owner: string): Promise<NameValueProperty[]>;
    protected _fromGcxExtendedProperties(extendedProperties: ObservableCollection<NameValueProperty>): {
        [name: string]: any;
    };
    /**
     * Determines whether a feature can be serialized using only its ID, rather than storing all of
     * its attribute and geometry data. In this case, the original layer will be re-queried during
     * deserialization to restore the data.
     */
    protected _canRequeryFeatureData(feature: Feature): boolean;
}

}
declare module "geocortex/infrastructure/project/ProjectFilter" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { WebMapFilter } from "geocortex/infrastructure/webMap/WebMapFilter";
import { Validator } from "geocortex/infrastructure/validation/Validator";
import { BaseMapLayer } from "geocortex/infrastructure/project/BaseMapLayer";
import { OperationalLayer } from "geocortex/infrastructure/project/OperationalLayer";
import { ServiceLayer } from "geocortex/infrastructure/project/ServiceLayer";
import { Layer } from "geocortex/infrastructure/project/Layer";
/**
 * Provides a set of filters for use with {@link: ObjectFilter.filter} corresponding to common project interfaces.
 */
export class ProjectFilter {
    app: ViewerApplication;
    private _coordinateSystem;
    private _drawingInfo;
    private _feature;
    private _featureCollection;
    private _featureSet;
    private _featureSetCollection;
    private _graphic;
    private _layerDefinition;
    protected _webMapFilter: WebMapFilter;
    private _numberValidator;
    private _urlValidator;
    private _serviceDiscoveryUrlValidator;
    private _xssHtmlValidator;
    constructor(app: ViewerApplication);
    readonly baseMap: any;
    baseMapLayer: (baseLayer: BaseMapLayer) => any;
    readonly bookmark: any;
    readonly color: any;
    readonly coordinateSystem: any;
    readonly domain: any;
    readonly inheritedDomain: any;
    readonly rangeDomain: any;
    readonly codedValueDomain: any;
    readonly drawingInfo: any;
    readonly feature: any;
    readonly featureCollection: any;
    readonly featureSet: any;
    readonly featureSetCollection: any;
    readonly field: any;
    readonly geometry: any;
    readonly graphic: any;
    readonly point: any;
    readonly multiPoint: any;
    readonly polyline: any;
    readonly polygon: any;
    readonly extent: any;
    layer: (lyr: Layer) => any;
    readonly layerDefinition: any;
    operationalLayer: (opLayer: OperationalLayer) => any;
    readonly renderer: any;
    serviceLayer: (svcLayer: ServiceLayer) => any;
    readonly simpleRenderer: any;
    readonly uniqueValueRenderer: any;
    readonly classBreaksRenderer: any;
    readonly heatmapRenderer: any;
    readonly spatialReference: any;
    readonly symbol: any;
    readonly simpleMarkerSymbol: any;
    readonly simpleLineSymbol: any;
    readonly simpleFillSymbol: any;
    readonly pictureMarkerSymbol: any;
    readonly pictureFillSymbol: any;
    readonly textSymbol: any;
    readonly template: any;
    readonly type: any;
    /**
     * A generic filter for objects whose schema is unknown.
     */
    object: any;
    protected readonly _serviceLayerCommon: any;
    /**
     * Gets an appropriate url validator instance based on the supplied layer or service.
     */
    protected _getUrlValidator(layerOrService: Layer | ServiceLayer): Validator<string>;
    private _getUserLayerType(layerOrService);
    private _isFeatureCollection(serviceLayer);
    private _isKmlLayer(serviceLayer);
    private _isLayerCatalogService(serviceLayer);
}

}
declare module "geocortex/infrastructure/project/ProjectManager" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { ProjectConverter } from "geocortex/infrastructure/project/ProjectConverter";
import { ProjectFilter } from "geocortex/infrastructure/project/ProjectFilter";
import { Project, ApplicationState } from "geocortex/infrastructure/project/Project";
import { MapService } from "geocortex/essentials/MapService";
export const PROJECT_TYPE = "gvh-project";
export const SITE_ID_PROPERTY_NAME = "siteID";
export const VIEWER_ID_PROPERTY_NAME = "viewerID";
export const PROJECT_QUERY_STRING_KEY = "project";
export const VIEWER_QUERY_STRING_KEY = "viewer";
export class ProjectManager {
    app: ViewerApplication;
    convert: ProjectConverter;
    filter: ProjectFilter;
    /** The project that is currently loaded (or in the process of loading). */
    current: Project;
    /** Whether project state is currently being applied. */
    isLoading: boolean;
    /** Reference to the service discovery API */
    private _serviceDiscovery;
    constructor(app: ViewerApplication);
    /**
     * Creates a new, empty project.
     */
    createEmpty(name: string): Project;
    /**
     * Creates a new project containing the current state of the application.
     */
    create(name: string): Promise<Project>;
    /**
     * Updates an existing project with the current state of the application.
     */
    update(project: Project): Promise<void>;
    /**
     * Removes a project.
     * @param project Either the project ID, or the actual project to remove.
     */
    remove(project: string | Project): Promise<any>;
    /**
     * Saves a project by updating the application state then writing to storage.
     * @param project The project to save.
     */
    save(project: Project, updateApplicationState?: boolean): Promise<void>;
    /**
     * Loads a project.
     * @param project Either the project ID, or the actual project to load.
     */
    load(project: string | Project): Promise<void>;
    /**
     * Writes a project file to storage.
     */
    write(project: Project): Promise<Project>;
    /**
     * Reads a project from storage.
     * @param id The project ID.
     * @param Whether or not to include the project content if retrieving it from the document store.
     */
    read(id: string, includeContent?: boolean): Promise<Project>;
    /**
     * Gets the given project.
     * @param project Either the project ID, or the actual project.
     * @param Whether or not to include the project content if retrieving it from the document store.
     * @return A promise containing the project.
     */
    getProject(project: string | Project, includeContent?: boolean): Promise<Project>;
    /**
     * Gets the ID of the given project.
     * @param project Either the project ID, or the actual project.
     * @return The project ID.
     */
    getProjectID(project: string | Project): string;
    /**
     * Gets the URL for the given project, or null if the project does not have an ID.
     * @param project The project to get the URL for.
     * @return The project URL or null.
     */
    getProjectUrl(project: Project): string;
    /**
     * Gets the Essentials site ID that the given project is associated with.
     */
    getSiteID(project: Project): string;
    /**
     * Gets the Essentials viewer ID that the given project is associated with.
     */
    getViewerID(project: Project): string;
    /**
     * Validates whether or not the given project is owned by the current user.
     * @param The project to verify ownership of.
     * @return A promise containing the project being validated.
     */
    validateProjectOwnership(project: Project): Promise<Project>;
    protected _initializeDiscoveryProvider(): Promise<void>;
    /**
     * Validates whether or not the given map service is in the service discovery URL whitelist.
     */
    protected _validateAgainstServiceDiscovery(mapService: MapService): Promise<{
        mapService: MapService;
        trusted: boolean;
    }>;
    /**
     * Provides an opportunity to exclude certain objects from being stored in projects.
     */
    protected _excludeUnsafeState(): Promise<void>;
    /**
     * Gets the current state of the application.
     */
    protected _exportState(): Promise<ApplicationState>;
    /**
     * Applies the given state to the viewer.
     */
    protected _applyState(state: ApplicationState): Promise<void>;
    /**
     * Applies the project's extent to the application's map.
     */
    protected _applyMapExtent(project: Project): void;
    protected _getResource(resource: string): string;
    /**
     * Gets all loaded the modules, keyed by name.
     */
    protected _getModules(): {
        [moduleName: string]: any;
    };
    _beginLoad(project: Project): Promise<void>;
    _finishLoad(): void;
    /**
     * Filters application state according to the filter defined by each module.
     * @param state The application state to filter.
     */
    _filterApplicationState(state: ApplicationState): Promise<ApplicationState>;
    /**
     * Replaces shared references within the object graph with special strings that act as "pointers" to
     * the shared object. When the object graph is serialized as JSON, this reduces the serialized footprint
     * and also allows cycles within the object graph, which would normally cause an error.
     * @param state The application state to encode.
     */
    protected encodeReferences(state: ApplicationState): void;
    /**
     * Performs the inverse of encodeReferences(), i.e. turns "pointers" back into shared object references.
     * @param state The application state to decode.
     */
    decodeReferences(state: ApplicationState): void;
}

}
declare module "geocortex/infrastructure/project/ServiceLayer" {
import { ServiceLayer } from "geocortex/infrastructure/webMap/ServiceLayer";
import { Layer } from "geocortex/infrastructure/project/Layer";
export interface ServiceLayer extends ServiceLayer {
    layers: Layer[];
    /** Whether or not the service was created by a user at runtime **/
    isUserCreated?: boolean;
    /**
     * The type of user created layer, if any. One of:
     *  - LayerAddition - the layer was added by browsing/searching for services and layers in a dialog
     *  - LayerCatalog - the layer was added from a catalog
     *  - Upload - the layer was added by uploading a file
     *
     * Only applies to layers created at runtime.
     */
    userLayerType?: string;
    /** The geocortex map service definition as returned from essentials.MapService.toJson(). Used for user-added map services. */
    gcxMapServiceDefinition?: any;
}

}
declare module "geocortex/infrastructure/search/SearchHintItem" {
import { Observable } from "geocortex/framework/observables";
export class SearchHintItem {
    /**
     * Unsafe HTML that must be sanitized before being injected into the DOM.
     * @type {String}
     */
    text: Observable<string>;
    /**
     * Sanitized plain-text version of the unsafe HTML.
     * @type {String}
     */
    plainText: Observable<string>;
    /**
     * Sanitized version of the unsafe HTML.
     * @type {String}
     */
    safeText: Observable<string>;
    /**
     * The {@link Observable} icon URI associated with this search hint.
     * Can be null if no icon is available.
     * @observable
     * @type {String}
     */
    iconUri: Observable<string>;
    /**
     * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.search.SearchHintItem} class.
     * @class
     * The text that comes back from a search hint provider might have embedded markup.
     * We bind these highlights to an items source on an autocomplete box.
     * We however want the selection from the autocomplete to not contain
     * embedded markup.
     * That is the purpose of this class - to provide two views of the hints - with and without markup.
     * @param text The text (with markup) to initialize
     * @param options Optional parameter that sets the options for emphasizing text that might also contain unsafe HTML content.
     */
    constructor(text: string, options?: {
        emphasisBeginTag?: string;
        emphasisEndTag?: string;
    });
    sanitizeText(value: string): string;
    toString(): string;
}

}
declare module "geocortex/infrastructure/search/SearchHintProvider" {
import { ObservableCollection } from "geocortex/framework/observables";
import { SearchHintItem } from "geocortex/infrastructure/search/SearchHintItem";
/**
 * Interface for providing search hints given a search string. Not to be confused with actual
 * search results, search hints are simply strings of things that are related to or match the
 * provided search text. A typical use of search hints is in an auto-complete drop down box.
 *
 * This interface is a companion to SearchProviderBase. If a class extends SearchProviderBase,
 * then it might optionally implement this interface to provide search hints. It's up to the
 * consumer of the search provider to actually make use of this functionality. In the
 * HTML5 viewer, SearchManager manages the search providers and exposes the associated
 * SearchHintProvider implementations.
 */
export interface SearchHintProvider {
    /**
     * Returns a collection of strings that match or are related to the provided search text.
     * This is typically used for auto complete dropdown boxes.
     * @param hints The collection of hints. This collection should be manipulated (added) to by the implementation.
     * @param searchText The text the user is searching on.
     */
    getSearchHints(hints: ObservableCollection<SearchHintItem>, searchText: string): void;
}

}
declare module "geocortex/infrastructure/search/SearchManager" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { ObservableCollection } from "geocortex/framework/observables";
import { SearchHintItem } from "geocortex/infrastructure/search/SearchHintItem";
import { SearchProgressEventArgs } from "geocortex/infrastructure/eventArgs/SearchProgressEventArgs";
export module Status {
    var IDLE: string;
    var SEARCHING: string;
    var ERROR: string;
}
export class SearchManager {
    /**
     * The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this search manager instance belongs to.
     */
    app: ViewerApplication;
    /** @private */
    private _searchProviders;
    /** @private */
    private _fscRootID;
    /** @private */
    private _fsc;
    /** @private */
    private _count;
    /** @private */
    private _fscSourceName;
    /**
     * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.search.SearchManager} class.
     * @class
     * <p>The search manager is the central access point for all things search within the viewer.
     * The idea is that various search providers will be registered with the search manager
     * and will all be used when a search takes place (if enabled).</p>
     * @constructs
     * @memberOf geocortex.essentialsHtmlViewer.mapping.infrastructure.search
     * @param app The {@link geocortex.framework.application.Application} instance that this SearchManager belongs to.
     */
    constructor(app: ViewerApplication);
    _resetFeatureSetCollection(): void;
    /**
     * Returns a collection of strings that match or are related to the provided search text.
     * This is typically used for auto-complete dropdown boxes.
     * @param hints The collection of hints. This collection should be manipulated (added) to by the implementation.
     * @param searchText The text the user is searching on.
     */
    getSearchHints(hints: ObservableCollection<SearchHintItem>, searchText: string): void;
    /** @private Registers some view-related commands. */
    private _registerCommands();
    /** @private Registers a provider if not already registered.
    * @param searchProvider An array of search providers
    */
    private _registerProvider(searchProvider);
    /** @private Return an array of providers that are currently enabled and if offline, that support offline searches. */
    private _enabledProviders();
    /** @private Indicates if any of the registered provider is currently searching. */
    private _isSearching();
    /** @private Handler to cancel a search */
    private _cancelSearch();
    /** @private Clear all the search results */
    private _clearSearch();
    /**
     * @private Handler to start a search
     * @param searchText Text to be searched
     */
    private _search(searchText);
    /**
     * @private Handles the search progress event
     * @param searchProgress Indicates the status of search operation
     */
    _searchProgress(searchProgress: SearchProgressEventArgs): void;
}

}
declare module "geocortex/infrastructure/search/SearchProviderBase" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
export class SearchProviderBase {
    /**
     * The {@link geocortex.framework.application.Application} that this view belongs to.
     */
    app: ViewerApplication;
    libraryId: string;
    /**
     * The ID of the provider.
     * @type String
     */
    id: string;
    /**
     * The name of the provider - may be displayed in the viewer.
     * @type String
     */
    name: string;
    /**
     * The description of the provider.
     * @type String
     */
    description: string;
    /**
     * Indicates that the provider can support offline searching.
     * @type Boolean
     */
    supportsOffline: boolean;
    /**
     * Indicates whether or not this layer supports the search hints.
     * @type Boolean
     */
    supportsHints: boolean;
    /**
     * Indicates whether the provider is enabled or not.
     * @type Boolean
     */
    isEnabled: boolean;
    /**
     * Current search status.
     * @type geocortex.essentialsHtmlViewer.mapping.infrastructure.search.Status
     */
    status: string;
    /**
     * Create a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.search.SearchProviderBase} class.
     * @class
     * <p>The base class for all search provider.</p>
     * @constructs
     * @memberOf geocortex.essentialsHtmlViewer.mapping.infrastructure.search
     * @param app The {@link geocortex.framework.application.Application} that this base class belongs to.
     */
    constructor(app: ViewerApplication, libraryId: string);
    /**
     * Initialize the provider.
     * @param config The configuration object.
     */
    initialize(config: any): void;
    /**
     * Performs the search.
     * @param targetFsc Where search results are to go.
     * @param searchText What to search for.
     */
    search(targetFsc: FeatureSetCollection, searchText: string): void;
    /**
     * Cancel a search.
     */
    cancelSearch(): void;
    /**
     * Gets a language resource from the Application's resource dictionary, given a key, and optional locale.
     * Returns null if the resource does not exist.
     * @param key The resource key.
     * @param locale The locale of the resource to fetch. Defaults to the current application locale.
     */
    getResource(resourceKey: string, locale?: string): string;
}

}
declare module "geocortex/infrastructure/results/FeatureSetCollectionResultsLabelView" {
import { FeatureSet } from "geocortex/infrastructure/FeatureSet";
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { FeatureSetCollectionResultsLabelViewModel } from "geocortex/infrastructure/results/FeatureSetCollectionResultsLabelViewModel";
export class FeatureSetCollectionResultsLabelView extends ViewBase {
    featureSetLabel: HTMLElement;
    featuresCount: HTMLElement;
    viewModel: FeatureSetCollectionResultsLabelViewModel;
    constructor(app: ViewerApplication, libraryId?: string);
    attach(fs: FeatureSet): Promise<void>;
    handleClick(evt: MouseEvent, element: HTMLElement, context: FeatureSetCollectionResultsLabelViewModel): boolean;
}

}
declare module "geocortex/infrastructure/results/FeatureSetCollectionResultsLabelViewModel" {
import { ViewModelBase } from "geocortex/framework/ui/ViewModelBase";
import { Observable } from "geocortex/framework/observables";
import { Application } from "geocortex/framework/application/Application";
import { FeatureSet } from "geocortex/infrastructure/FeatureSet";
export class FeatureSetCollectionResultsLabelViewModel extends ViewModelBase {
    featureSet: Observable<FeatureSet>;
    featuresCount: Observable<string>;
    featureSetLabel: Observable<string>;
    iconUri: Observable<string>;
    constructor(app: Application, libraryId?: string);
}

}
declare module "geocortex/infrastructure/results/FeatureSetCollectionResultsView" {
import { ResultsViewBase } from "geocortex/infrastructure/results/ResultsViewBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { FeatureSetCollectionResultsViewModel } from "geocortex/infrastructure/results/FeatureSetCollectionResultsViewModel";
import { Application } from "geocortex/framework/application/Application";
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
import { BindingExpression } from "geocortex/framework/ui/BindingExpression";
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { ResultsState } from "geocortex/infrastructure/results/ResultsState";
import { ApplyResultsViewStateArgs } from "geocortex/infrastructure/results/ResultsModule";
import { FeatureSet } from "geocortex/infrastructure/FeatureSet";
export class FeatureSetCollectionResultsView extends ResultsViewBase {
    private _invisibleClassName;
    private _visibleClassName;
    private _openUpActionsMenuClassName;
    private _defaultDetectAutomaticDrillInDelay;
    app: ViewerApplication;
    viewModel: FeatureSetCollectionResultsViewModel;
    /**
    We say that a feature set is active when its actions menu button has been clicked and the flyout is open.
    This HTML element corresponds to the <li> of the feature set itself.
    **/
    currentActiveFeatureSetElement: HTMLElement;
    private _subscriptions;
    constructor(app: Application, libraryId?: string);
    activated(): void;
    deactivated(): void;
    attach(viewModel?: any): void;
    showResultsList(fsc: FeatureSetCollection): void;
    getDescription(evt: Event, el: HTMLElement, ctx: any): void;
    scrollViewTop(position?: number): void;
    handleFeatureSetCollectionFeatureSetActionsClick(evt: MouseEvent, element: HTMLElement, context: FeatureSet): void;
    resolveWidget(widgetId: string, context: any, binding: BindingExpression): ViewBase;
    protected _handleShowResultsTable(): void;
    protected _switchToTabularResultsViewImpl(): void;
    protected _canExecuteSwitchToTabularResultsView(): boolean;
    /** Fire event only if the view container is active in the data frame */
    protected _dataFrameOpenedEventHandler(): void;
    /** Fire event only if the view container is active in the data frame */
    protected _dataFrameClosedEventHandler(): void;
    /** Invokes the stored delegates to unsubscribe from events. */
    protected _unsubscribeFromEvents(): void;
    protected _exportState(resultsState: ResultsState): void;
    private _clearIsSelected();
    protected _applyState(args: ApplyResultsViewStateArgs): void;
}

}
declare module "geocortex/infrastructure/results/FeatureSetCollectionResultsViewModel" {
import { ResultsViewModel } from "geocortex/infrastructure/results/ResultsViewModel";
import { ObservableCollection, Observable } from "geocortex/framework/observables";
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
import { FeatureDescriptionPresenterView } from "geocortex/infrastructure/FeatureDescriptionPresenterView";
import { Application } from "geocortex/framework/application/Application";
import { ResultsState } from "geocortex/infrastructure/results/ResultsState";
import { ApplyResultsViewStateArgs } from "geocortex/infrastructure/results/ResultsModule";
import { FeatureSet } from "geocortex/infrastructure/FeatureSet";
export class FeatureSetCollectionResultsViewModel extends ResultsViewModel {
    featureSets: ObservableCollection<FeatureSet>;
    searchSuggestion: Observable<string>;
    isViewActive: Observable<boolean>;
    /**
    Drill in by default. It might be the case that results are not coming from search or identify
    and we still want to be able to drill in if only 1 feature set is available.
    */
    private _automaticDrillIn;
    private _featuresInCollectionCount;
    private _featureSetsBindingToken;
    private _boundFeatureSetCollection;
    private _featureViewMap;
    private _identifyTaskCompleteToken;
    private _featureSetsLoadTimer;
    private _performAutomaticDrillInDelay;
    private _loadingMessageDismissed;
    detectAutomaticDrillInDelay: number;
    constructor(app: Application, libraryId?: string);
    handleCollectionChanged(collection: FeatureSetCollection): void;
    private _showLoadingMessage();
    private _onLoadingMessageDismissed();
    private _startAutomaticDrillInTimer();
    private _clearAutomaticDrillInTimer();
    private _tryAutomaticDrillIn();
    private _performAutomaticDrillIn();
    updateHeaderText(count: number): void;
    protected _destroyViewForToken(token: string): void;
    protected _showResultsList(fsc: any): void;
    private _loadFeatureSetCollection(fsc);
    protected _switchToTabularResultsViewImpl(): void;
    protected _canExecuteSwitchToTabularResultsView(): boolean;
    protected _executeRemoveFeatureSetFromResults(fs: FeatureSet): void;
    protected _canRemoveFeatureSetFromResults(fs: FeatureSet): boolean;
    protected _removeFeatureSetFromResults(fs: FeatureSet): void;
    protected _existsInCollection(fs: FeatureSet, collection: FeatureSetCollection): boolean;
    protected _notifyFeatureSetCollectionChanged(itemNumber: number): void;
    getFeatureView(token: string): FeatureDescriptionPresenterView;
    setFeatureView(token: string, view: FeatureDescriptionPresenterView): void;
    unbindFeatureSet(): void;
    exportState(resultsState: ResultsState): void;
    applyState(args: ApplyResultsViewStateArgs): void;
    _pulseFeatureSetsInCollection(): void;
    protected _clearResetUnderlyingCollection(unbindFeatureSet: boolean): void;
}

}
declare module "geocortex/infrastructure/results/FeatureSetResultsView" {
import { ResultsViewBase } from "geocortex/infrastructure/results/ResultsViewBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { FeatureSetResultsViewModel } from "geocortex/infrastructure/results/FeatureSetResultsViewModel";
import { Application } from "geocortex/framework/application/Application";
import { BindingExpression } from "geocortex/framework/ui/BindingExpression";
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { ResultsState } from "geocortex/infrastructure/results/ResultsState";
import { ApplyResultsViewStateArgs } from "geocortex/infrastructure/results/ResultsModule";
import { Feature } from "geocortex/infrastructure/Feature";
export class FeatureSetResultsView extends ResultsViewBase {
    private _invisibleClassName;
    private _visibleClassName;
    private _openUpActionsMenuClassName;
    /**
    We say that a feature is active when its actions menu button has been clicked and the flyout is open.
    This HTML element corresponds to the <li> of the feature itself.
    **/
    currentActiveFeatureElement: HTMLElement;
    app: ViewerApplication;
    viewModel: FeatureSetResultsViewModel;
    featureClickedEventName: string;
    featurePressedEventName: string;
    featureHoveredEventName: string;
    featureHoverEndEventName: string;
    itemClass: string;
    private _subscriptions;
    private _viewModelFSCBindingToken;
    private _scrollTop;
    private _highlightMode;
    constructor(app: Application, libraryId?: string);
    activated(): void;
    deactivated(): void;
    attach(viewModel?: any): void;
    private _showFeaturesList(fs);
    handlePageFirst(evt: Event, el: HTMLElement, ctx: any): void;
    handlePagePrev(evt: Event, el: HTMLElement, ctx: any): void;
    handlePageNext(evt: Event, el: HTMLElement, ctx: any): void;
    handlePageLast(evt: Event, el: HTMLElement, ctx: any): void;
    handleScrollChange(evt: Event, el: HTMLElement, ctx: any): void;
    getDescription(evt: Event, el: HTMLElement, ctx: any): void;
    scrollViewTop(position?: number): void;
    resolveWidget(widgetId: string, context: any, binding: BindingExpression): ViewBase;
    protected _handleShowResultsTable(): void;
    /** Fire event only if the view container is active in the data frame */
    protected _dataFrameOpenedEventHandler(): void;
    /** Fire event only if the view container is active in the data frame */
    protected _dataFrameClosedEventHandler(): void;
    /** Invokes the stored delegates to unsubscribe from events. */
    protected _unsubscribeFromEvents(): void;
    protected _exportState(resultsState: ResultsState): void;
    protected _applyState(args: ApplyResultsViewStateArgs): void;
    private _hideFeatureSetResults();
    handleFeatureSetFeatureActionClick(evt: MouseEvent, element: HTMLElement, context: Feature): void;
}

}
declare module "geocortex/infrastructure/results/FeatureSetResultsViewModel" {
import { ResultsViewModel } from "geocortex/infrastructure/results/ResultsViewModel";
import { ObservableCollectionAggregator } from "geocortex/framework-ui/ObservableCollectionAggregator";
import { Feature } from "geocortex/infrastructure/Feature";
import { ObservableCollection, Observable } from "geocortex/framework/observables";
import { FeatureDescriptionPresenterView } from "geocortex/infrastructure/FeatureDescriptionPresenterView";
import { Application } from "geocortex/framework/application/Application";
import { CollectionChangedArgs } from "geocortex/framework/events/CollectionChangedArgs";
import { ResultsState } from "geocortex/infrastructure/results/ResultsState";
import { ApplyResultsViewStateArgs } from "geocortex/infrastructure/results/ResultsModule";
import { FeatureSet } from "geocortex/infrastructure/FeatureSet";
export class FeatureSetResultsViewModel extends ResultsViewModel {
    /**
    This Feature Set is maintained just to use it in the context for the hoisted action menu in the FeatureSetResultsView.
    Setting this property won't trigger any bindings for the presentable collection.
    **/
    featureSet: Observable<FeatureSet>;
    results: ObservableCollectionAggregator<Feature>;
    resultsPage: ObservableCollection<Feature>;
    pageControlsEnabled: Observable<boolean>;
    resultsList: Observable<string>;
    pagingControlClassName: Observable<string>;
    contentField: Observable<string>;
    private _featureViewMap;
    private _resultsPageBindingToken;
    private _presentableResultsBindingToken;
    private _underlyingFeatureSetsChangedSubscriptionToken;
    private _featureChangedEventSubscriptionToken;
    private _featureDeletedEventSubscriptionToken;
    private _featureRemovedFromResultsSubscriptionToken;
    private _presentableResultsNumberOfItemsBindingToken;
    private _deleteClickableFeatureStartedSubscriptionToken;
    constructor(app: Application, libraryId?: string);
    protected _updateHeaderText(count: number): void;
    /**
    The base class will call this method at construction times.
    However we only want to subscribe when the FeatureSetResultsView is active so we will manage
    the subscription to events ourselves from the View.
    **/
    subscribeEvents(): void;
    /**
    * Handles changes in the Results Page.  This is intended to keep the FeatureViewMap from getting overloaded
    * with deprecated views.
    */
    handlePageResultsChange(changeArgs?: CollectionChangedArgs): void;
    /**
    * Handles a dataLink resolved event to update the display for the given feature.
    * This was done so that tokens would be added asynchronously as they arrive
    * @param context The feature that was updated
    */
    handleFeatureChanged(context: Feature): void;
    protected _destroyViewForToken(token: string): void;
    showFeaturesList(fs: FeatureSet): void;
    clearCurrentHighlights(): void;
    private _clearSpecificHighlight(feature);
    getFeatureView(token: string): FeatureDescriptionPresenterView;
    setFeatureView(token: string, view: FeatureDescriptionPresenterView): void;
    exportState(resultsState: ResultsState): void;
    applyState(args: ApplyResultsViewStateArgs): void;
    private _hideIfNoFeaturesLeft(f);
    private _pulseUnderlyingCollection();
    protected _clearResetUnderlyingCollection(): void;
    /**
    The subclass will call the updateHeaderText to update the header text.
    The method will be called with the Feature Set COLLECTION count.
    Since we are in the FeatureSetResultsView we want to ignore that update
    because in the FeatureSetResultsView we want to show the count of the
    CURRENT Feature Set. To ignore it we intercept the call and return.
    **/
    updateHeaderText(count: number): void;
    bindUnderlyingCollection(): void;
    unbindUndelryingCollection(): void;
    private _bindObservables();
    private _unbindObservables();
    subscribeToEvents(): void;
    unsubscribeFromEvents(): void;
}

}
declare module "geocortex/infrastructure/results/FlatResultsViewModel" {
import { ResultsViewModel } from "geocortex/infrastructure/results/ResultsViewModel";
import { ObservableCollectionAggregator } from "geocortex/framework-ui/ObservableCollectionAggregator";
import { Feature } from "geocortex/infrastructure/Feature";
import { ObservableCollection, Observable } from "geocortex/framework/observables";
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
import { FeatureDescriptionPresenterView } from "geocortex/infrastructure/FeatureDescriptionPresenterView";
import { Application } from "geocortex/framework/application/Application";
import { CollectionChangedArgs } from "geocortex/framework/events/CollectionChangedArgs";
import { ResultsState } from "geocortex/infrastructure/results/ResultsState";
import { ApplyResultsViewStateArgs } from "geocortex/infrastructure/results/ResultsModule";
export class FlatResultsViewModel extends ResultsViewModel {
    results: ObservableCollectionAggregator<Feature>;
    resultsPage: ObservableCollection<Feature>;
    pageControlsEnabled: Observable<boolean>;
    resultsList: Observable<string>;
    pagingControlClassName: Observable<string>;
    contentField: Observable<string>;
    private _featureSetsBindingToken;
    private _resultsPageBindingToken;
    private _presentableResultsBindingToken;
    private _boundFeatureSetCollection;
    private _featureViewMap;
    /**
     * FlatResultsViewModel flattens the feature set collections and presents the data as a single
     * ObservableCollection.
     */
    constructor(app: Application, libraryId?: string);
    subscribeEvents(): void;
    handleCollectionChanged(collection: FeatureSetCollection): void;
    handleFeatureSetsChanged(changedArgs: CollectionChangedArgs): void;
    /**
    * Handles changes in the Results Page.  This is intended to keep the FeatureViewMap from getting overloaded
    * with deprecated views.
    */
    handlePageResultsChange(changeArgs?: CollectionChangedArgs): void;
    /**
    * Handles a dataLink resolved event to update the display for the given feature.
    * This was done so that tokens would be added asynchronously as they arrive
    * @param context The feature that was updated
    */
    handleFeatureChanged(context: Feature): void;
    protected _destroyViewForToken(token: string): void;
    showResultsList(fsc: FeatureSetCollection): void;
    showResultsList(fscId: string): void;
    clearCurrentHighlights(): void;
    protected _switchToTabularResultsViewImpl(): void;
    protected _canExecuteSwitchToTabularResultsView(): boolean;
    getFeatureView(token: string): FeatureDescriptionPresenterView;
    setFeatureView(token: string, view: FeatureDescriptionPresenterView): void;
    unbindFeatureSet(): void;
    exportState(resultsState: ResultsState): void;
    applyState(args: ApplyResultsViewStateArgs): void;
    _pulseFeatureSetsInCollection(): void;
    protected _clearResetUnderlyingCollection(unbindFeatureSet: boolean): void;
    bindUnderlyingCollection(): void;
    unbindUndelryingCollection(): void;
    private _bindObservables();
    private _unbindObservables();
}

}
declare module "geocortex/infrastructure/results/ResultsAttributeHeaderViewModel" {
import { Observable } from "geocortex/framework/observables";
import { FeatureAttribute } from "geocortex/infrastructure/FeatureAttribute";
import { PresentableCollection } from "geocortex/framework-ui/PresentableCollection";
import { Feature } from "geocortex/infrastructure/Feature";
export class ResultsAttributeHeaderViewModel {
    displayName: Observable<string>;
    sortState: Observable<number>;
    sortClass: Observable<string>;
    _sharedState: SharedState;
    _sortingPredicate: (a: any, b: any) => number;
    _reverseSortingPredicate: (a: any, b: any) => number;
    constructor(sharedState: SharedState, attribute: FeatureAttribute, type: string, index: number);
    buildSortingFunction(index: number): (a: any, b: any) => number;
    buildReverseSortingFunction(index: number): (a: any, b: any) => number;
    buildDateSortingFunction(index: number): (a: any, b: any) => number;
    buildReverseDateSortingFunction(index: number): (a: any, b: any) => number;
    onSortStateChange(state: number): void;
}
/**
 * Manual comparison function. Slower than native.
 */
export var manualCollator: (a: any, b: any) => number;
/**
 * The fastest comparison function available.
 */
export var collator: (x: string, y: string) => number;
/**
 * Holds state shared between columns.
 */
export class SharedState {
    ignoreStateChange: boolean;
    lastSortedColumn: any;
    presentableResults: PresentableCollection<Feature>;
    unsortedClass: string;
    sortedClass: string;
    reverseSortedClass: string;
    constructor(presentableResults: PresentableCollection<Feature>, unsortedClass: string, sortedClass: string, reverseSortedClass: string);
    reset(): void;
}

}
declare module "geocortex/infrastructure/results/ResultsFeatureActionsView" {
import { ViewBase } from "geocortex/framework/ui/ViewBase";
export class ResultsFeatureActionsView extends ViewBase {
    handleMenuItemClick(event: any, element: any, context: any): void;
    handleGetDescription(event: any, element: any, context: any): void;
}

}
declare module "geocortex/infrastructure/results/ResultsListView" {
import { ResultsViewBase } from "geocortex/infrastructure/results/ResultsViewBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { FlatResultsViewModel } from "geocortex/infrastructure/results/FlatResultsViewModel";
import { Application } from "geocortex/framework/application/Application";
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
import { BindingExpression } from "geocortex/framework/ui/BindingExpression";
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { ResultsState } from "geocortex/infrastructure/results/ResultsState";
import { ApplyResultsViewStateArgs } from "geocortex/infrastructure/results/ResultsModule";
export class ResultsListView extends ResultsViewBase {
    app: ViewerApplication;
    viewModel: FlatResultsViewModel;
    featureClickedEventName: string;
    featurePressedEventName: string;
    featureHoveredEventName: string;
    featureHoverEndEventName: string;
    itemClass: string;
    private _subscriptions;
    private _scrollTop;
    constructor(app: Application, libraryId?: string);
    activated(): void;
    deactivated(): void;
    attach(viewModel?: any): void;
    showResultsList(fsc: FeatureSetCollection): void;
    handlePageFirst(evt: Event, el: HTMLElement, ctx: any): void;
    handlePagePrev(evt: Event, el: HTMLElement, ctx: any): void;
    handlePageNext(evt: Event, el: HTMLElement, ctx: any): void;
    handlePageLast(evt: Event, el: HTMLElement, ctx: any): void;
    handleScrollChange(evt: Event, el: HTMLElement, ctx: any): void;
    getDescription(evt: Event, el: HTMLElement, ctx: any): void;
    scrollViewTop(position?: number): void;
    resolveWidget(widgetId: string, context: any, binding: BindingExpression): ViewBase;
    protected _handleShowResultsTable(): void;
    protected _switchToTabularResultsViewImpl(): void;
    protected _canExecuteSwitchToTabularResultsView(): boolean;
    /** Fire event only if the view container is active in the data frame */
    protected _dataFrameOpenedEventHandler(): void;
    /** Fire event only if the view container is active in the data frame */
    protected _dataFrameClosedEventHandler(): void;
    /** Invokes the stored delegates to unsubscribe from events. */
    protected _unsubscribeFromEvents(): void;
    protected _exportState(resultsState: ResultsState): void;
    protected _applyState(args: ApplyResultsViewStateArgs): void;
}

}
declare module "geocortex/infrastructure/results/ResultsModule" {
import { ResultsState } from "geocortex/infrastructure/results/ResultsState";
import { ModuleBase } from "geocortex/framework/application/ModuleBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
import { FeatureSetManagerEventArgs } from "geocortex/infrastructure/eventArgs/FeatureSetManagerEventArgs";
export interface ApplyResultsViewStateArgs {
    state: ResultsState;
    promises: Promise<void>[];
}
export class ResultsModule extends ModuleBase {
    app: ViewerApplication;
    resultMappings: any;
    schema: any;
    _lastCommand: any;
    _supportedFormats: string[];
    _showInvisibleAttributes: boolean;
    _enableDataLinkObjectIdFieldOnExport: boolean;
    _featureIndexName: string;
    _featureIndexRoundUpPerFeatureSet: number;
    _includeDataLinksOnExport: boolean;
    initialize(config: any): void;
    getStateFilter(): any;
    exportState(): Promise<ResultsState>;
    applyState(state: ResultsState): Promise<void>;
    wireUpResultMapping(): void;
    fsmCollectionOpenedHandler(args: FeatureSetManagerEventArgs): void;
    fsmCollectionSetCommand(sourceName: string, command: string): void;
    exportTo(params: {
        fsc: FeatureSetCollection;
        format: string;
    }): void;
    exportToSuccess(data: any, format: string): void;
    exportToError(error: Error, statusMsgId: string, format: string): void;
    exportToCanExecute(args: any): boolean;
    private getFields(gcxFs);
    private getFieldsFromEsriLayer(esriLayer, gcxFs?);
    private getFieldsFromEssentialsLayer(essentialsLayer);
    private getFieldsFromGcxFeatureSetAttributes(gcxFeatureSetAttributes, gcxFs);
    private getFieldsFromGcxFeatureAttributes(gcxFeatureAttributes, gcxFs);
    private getFieldsFromEsriFeatureAttributeValues(esriFeatures);
    private getFieldsFromGcxFeatureAttributeValues(gcxFeatures);
    private getTypeFromEsriFeatures(features, attributeIndex);
    private getTypeFromGcxFeatures(features, attributeIndex);
    private getEsriTypeFromValue(value);
    private _getDataLinksAsFscItems(gcxFeatureSet);
    private _generateFscCollItem(name, table, featureSetCollItems, gcxOidColumnName?);
    private _getFieldName(inp);
    private getFeatureSets(fsc, includeDataLinks?);
    private fscToJson(fsc, includeDataLinks?);
}

}
declare module "geocortex/infrastructure/results/ResultsState" {
import { ModuleState } from "geocortex/infrastructure/project/ModuleState";
import { FeatureSetCollection } from "geocortex/infrastructure/project/FeatureSetCollection";
import { FeatureSet } from "geocortex/infrastructure/project/FeatureSet";
export interface ResultsState extends ModuleState {
    featureSetCollections: FeatureSetCollection[];
    /** The current results in the results view. */
    results?: FeatureSetCollection;
    /** One of "list" or "table" or "grouplist". */
    viewMode?: string;
    /** The current page number of flatlist aka ResultsListView  or FeatureSetResultsView*/
    page?: number;
    tableOptions?: {
        /** The column index that the data is sorted by. */
        sortColumn?: number;
        /** One of "asc" or "desc". */
        sortDirection?: string;
    };
    /**
    * The serial version of the ResultState.
    */
    serialVersion: number;
    /** Denotes the current featureset open when FeatureSetResultsView is open or Denotes the tab open in table */
    openedFeatureSet?: FeatureSet;
}

}
declare module "geocortex/infrastructure/results/ResultsTableView" {
import { ResultsViewBase } from "geocortex/infrastructure/results/ResultsViewBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { TabbedResultsViewModel } from "geocortex/infrastructure/results/TabbedResultsViewModel";
import { Application } from "geocortex/framework/application/Application";
import { BindingExpression } from "geocortex/framework/ui/BindingExpression";
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
import { ResultsState } from "geocortex/infrastructure/results/ResultsState";
import { ApplyResultsViewStateArgs } from "geocortex/infrastructure/results/ResultsModule";
export class ResultsTableView extends ResultsViewBase {
    app: ViewerApplication;
    viewModel: TabbedResultsViewModel;
    featureClickedEventName: string;
    featurePressedEventName: string;
    featureHoveredEventName: string;
    featureHoverEndEventName: string;
    scrollContainerElement: HTMLDivElement;
    tabContainerElement: HTMLDivElement;
    tabElements: HTMLElement;
    scrollTabLeftElement: HTMLElement;
    scrollTabRightElement: HTMLElement;
    private _fsBindingToken;
    private _boundFs;
    constructor(app: Application, libraryId?: string);
    deactivated(): void;
    activated(): void;
    attach(viewModel?: any): void;
    resolveWidget(widgetId: string, context: any, binding: BindingExpression): any;
    showResultsTable(fsc: FeatureSetCollection): void;
    private _refreshTabControlVisibility();
    handleTabClick(evt: Event, el: HTMLElement, ctx: any): void;
    handlePageFirst(evt: Event, el: HTMLElement, ctx: any): void;
    handlePagePrev(evt: Event, el: HTMLElement, ctx: any): void;
    handlePageNext(evt: Event, el: HTMLElement, ctx: any): void;
    handlePageLast(evt: Event, el: HTMLElement, ctx: any): void;
    handleTabScrollBack(evt: Event, el: HTMLElement, ctx: any): void;
    handleTabScrollForward(evt: Event, el: HTMLElement, ctx: any): void;
    handleClickFeature(evt: Event, el: HTMLElement, ctx: any): void;
    handleColumnHeadClick(evt: Event, el: HTMLElement, ctx: any): void;
    protected _handleShowResultsList(): void;
    protected _canExecuteSwitchToListResultsView(): boolean;
    protected _updateScrollTabDisabledStatus(): void;
    protected _unbindFromPrevFeatureSet(): void;
    protected _exportState(resultsState: ResultsState): void;
    protected _applyState(args: ApplyResultsViewStateArgs): void;
}

}
declare module "geocortex/infrastructure/results/ResultsUtils" {
import { ResultsViewBase } from "geocortex/infrastructure/results/ResultsViewBase";
import { Application } from "geocortex/framework/application/Application";
export function showResultsStatusMessage(app: Application, numberOfFeatures?: number): void;
/**
Deals with the logic of properly showing the in-line flyout menu for each result element.
It makes sure that no more that one result element actions menu is open at any given time and that
the menus are exclusive with the activation of the hoisted menu as well.
**/
export function handleInlineMenuActionClick(evt: MouseEvent, element: HTMLElement, currentActiveElement: HTMLElement, container: HTMLElement, currentView: ResultsViewBase): void;

}
declare module "geocortex/infrastructure/results/ResultsViewBase" {
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { Application } from "geocortex/framework/application/Application";
import { Feature } from "geocortex/infrastructure/Feature";
export class ResultsViewBase extends ViewBase {
    featureClickedEventName: string;
    featurePressedEventName: string;
    featureHoveredEventName: string;
    featureHoverEndEventName: string;
    isCollapsed: boolean;
    isContainerCollapsed: boolean;
    itemClass: string;
    private _longPressTimer;
    private _pressStartTime;
    private _pressLengthMs;
    private _hoverTimerToken;
    private _hoverDelayMs;
    private _hoveredFeature;
    private _firedTouchOrPress;
    private _pressYStart;
    private _lastTouchY;
    private _scrollYDeltaThreshold;
    private _firstEvent;
    constructor(app: Application, libraryId?: string);
    activated(): void;
    deactivated(): void;
    handleTouchStart(evt: Event, el: HTMLElement, ctx: any): boolean;
    handleTouchMove(evt: Event, el: HTMLElement, ctx: any): boolean;
    handleTouchEnd(evt: Event, el: HTMLElement, ctx: any): boolean;
    handleTouchCancel(evt: Event, el: HTMLElement, ctx: any): boolean;
    handleMouseDown(evt: Event, el: HTMLElement, ctx: any): boolean;
    handleClick(evt: Event, el: HTMLElement, ctx: any): boolean;
    handleMouseUp(evt: Event, el: HTMLElement, ctx: any): boolean;
    handleMouseOver(evt: Event, el: HTMLElement, ctx: Feature): void;
    handleMouseOut(evt: Event, el: HTMLElement, ctx: Feature): void;
    private _beginHover(ctx);
    private _cancelHover();
    private _tryFireHoverStop(ctx);
    private _beginLongPress(ctx);
    private _cancelLongPress();
    /**
     * If this view is hosted within a ViewContainer (and it's currently active), we want to notify listeners that
     * the container has been activated or deactivated.
     * NOTE: Child views hosted within a ViewContainerView are not activated/deactivated when the container is
     * activated/deactivated so this gives someone a chance to know that a view has been "hidden" because its
     * container was deactivated.
     */
    private _isViewHostedInContainer(container);
    scrollView(pos: number): void;
}

}
declare module "geocortex/infrastructure/results/ResultsViewModel" {
import { ViewModelBase } from "geocortex/framework/ui/ViewModelBase";
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { Observable, ObservableCollection } from "geocortex/framework/observables";
import { MenuItemModel } from "geocortex/infrastructure/menus/MenuItemModel";
import { Feature } from "geocortex/infrastructure/Feature";
import { PresentableCollection } from "geocortex/framework-ui/PresentableCollection";
import { Application } from "geocortex/framework/application/Application";
import { CollectionChangedArgs } from "geocortex/framework/events/CollectionChangedArgs";
import { FeatureSetManagerEventArgs } from "geocortex/infrastructure/eventArgs/FeatureSetManagerEventArgs";
export class ResultsViewModel extends ViewModelBase {
    private _emptyFeatureSetCollection;
    private _count;
    /** Stores binding event subscription tokens so we can unsubscribe later */
    private _watchHandles;
    app: ViewerApplication;
    headerText: Observable<string>;
    searchSuggestion: Observable<string>;
    featureSetCollection: Observable<FeatureSetCollection>;
    featureActions: ObservableCollection<MenuItemModel>;
    currentFeature: Observable<Feature>;
    hasFeatureSets: Observable<boolean>;
    isBusy: Observable<boolean>;
    presentableResults: PresentableCollection<Feature>;
    /** Whether the feature set collection has been modified */
    isModified: Observable<boolean>;
    defaultIsPaged: boolean;
    defaultPageSize: number;
    constructor(app: Application, libraryId?: string);
    subscribeEvents(): void;
    handleCollectionChanged(collection: FeatureSetCollection): void;
    handleFeatureSetsChanged(changedArgs: CollectionChangedArgs): void;
    /** Updates the header text.  Can be overridden by subclasses. */
    updateHeaderText(count: number): void;
    private _featureSetsHaveFeatures(featureSets);
    protected _openFSC(args: FeatureSetManagerEventArgs): void;
    protected _closeFSC(args: FeatureSetManagerEventArgs): void;
    protected _removeFSC(args: FeatureSetManagerEventArgs): void;
    protected _changeFSC(args: FeatureSetManagerEventArgs): void;
    _getEmptyFeatureSetCollection(): FeatureSetCollection;
    registerCommands(): void;
    getResultsFeatureActions(): void;
    protected _pulseFeatureSetsInCollection(): void;
    protected _watchDisplayNameChanges(): dojo.RemovableHandle;
    protected _unwatchDisplayNameChanges(): void;
    protected _watchIsModifiedChanges(): dojo.RemovableHandle;
    protected _unwatchIsModifiedChanges(): void;
}

}
declare module "geocortex/infrastructure/results/TabbedResultsViewModel" {
import { ResultsViewModel } from "geocortex/infrastructure/results/ResultsViewModel";
import { Observable, ObservableCollection } from "geocortex/framework/observables";
import { FeatureSet } from "geocortex/infrastructure/FeatureSet";
import { PresentableCollection } from "geocortex/framework-ui/PresentableCollection";
import { Feature } from "geocortex/infrastructure/Feature";
import { SharedState, TableColumnHeaderViewModel } from "geocortex/infrastructure/ui/components/Table/TableColumnHeaderViewModel";
import { Application } from "geocortex/framework/application/Application";
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
import { CollectionChangedArgs } from "geocortex/framework/events/CollectionChangedArgs";
import { ResultsState } from "geocortex/infrastructure/results/ResultsState";
import { ApplyResultsViewStateArgs } from "geocortex/infrastructure/results/ResultsModule";
export class TabbedResultsViewModel extends ResultsViewModel {
    curFeatureSet: Observable<FeatureSet>;
    currPageWithinTab: {
        [featureSetId: string]: number;
    };
    currScrollPosWithinTab: {
        [featureSetId: string]: number;
    };
    presentableResults: PresentableCollection<Feature>;
    resultsPage: ObservableCollection<Feature>;
    pageControlsEnabled: Observable<boolean>;
    tabControlsEnabled: Observable<boolean>;
    resultsTable: Observable<string>;
    columnSharedState: SharedState;
    columnHeaders: ObservableCollection<TableColumnHeaderViewModel>;
    leftScrollTabDisabled: Observable<boolean>;
    rightScrollTabDisabled: Observable<boolean>;
    _firstVisibleTab: number;
    private _emptyFeatureSet;
    private _boundFeatureSets;
    private _featureSetsBindingToken;
    private _curFeatureSetBindingToken;
    private _presentableResultsBindingToken;
    private _resultsPageBindingToken;
    /**
     * TabbedResultsViewModel leaves the feature set collections separate to be
     * presented as tabs (or whatever).
     */
    constructor(app: Application, libraryId?: string);
    handleCollectionChanged(collection: FeatureSetCollection): void;
    handleCurrentFeatureSetChanged(featureSet: FeatureSet): void;
    handleFeatureSetsChanged(changedArgs: CollectionChangedArgs): void;
    showResultsTable(fsc: FeatureSetCollection | string): void;
    clearCurrentHighlights(): void;
    protected _switchToListResultsViewImpl(): void;
    protected _canExecuteSwitchToListResultsView(): boolean;
    setCurrentSelectedFeatureSet(featureSet: FeatureSet): void;
    unbindFeatureSets(): void;
    buildColumnHeaders(featureSet: FeatureSet): void;
    setCurrentPageWithinTab(featureSetId: string): void;
    updateCurrentPageAndScrollPosWithinTab(page: number, pos: number): void;
    exportState(resultsState: ResultsState): void;
    applyState(args: ApplyResultsViewStateArgs): void;
    protected _handlePageResultsChange(changeArgs?: CollectionChangedArgs): void;
    private _pulseUnderlyingCollection();
    bindUnderlyingCollections(): void;
    unbindUnderlyingCollections(): void;
    private _bindObservables();
    private _unbindObservables();
}

}
declare module "geocortex/infrastructure/selection/CombineMode" {
/** Describes how features from one collection should be combined with existing features in another collection. */
export module CombineMode {
    /** Replaces the values in one collection with the values from another. */
    const REPLACE = "replace";
    /** Produces the set union, which means unique elements that appear in either of two collections. */
    const UNION = "union";
    /** Produces the set difference, which means the elements of one collection that do not appear in a second collection. */
    const SUBTRACT = "subtract";
    /** Produces the set intersection, which means elements that appear in each of two collections. */
    const INTERSECT = "intersect";
}

}
declare module "geocortex/infrastructure/selection/CombineResultsResponse" {
import { FeatureSetCollection } from "geocortex/infrastructure/FeatureSetCollection";
export interface CombineResultsResponse {
    updatedCollection: FeatureSetCollection;
    combineMode: string;
    modified: boolean;
}

}
declare module "geocortex/infrastructure/selection/SelectionMetadata" {
export interface SelectionMetadata {
    id: string;
    name: string;
    featureSetCollectionId?: string;
    count?: number;
    modified?: boolean;
    timeCreated?: number;
    timeModified?: number;
    timeExpiration?: number;
}

}
declare module "geocortex/infrastructure/selection/SelectionMetadataQuery" {
/**
 * Represents a query that is passed in to the {@link SelectionMetadataStore} to search for selection metadata.
 */
export interface SelectionMetadataQuery {
    /**
     * The latest create date, inclusive, that all search results must match, unless the value is null.
     */
    dateCreatedMax?: Date;
    /**
     * The earliest create date, inclusive, that all search results must match, unless the value is null.
     */
    dateCreatedMin?: Date;
    /**
     * The latest expiration date, inclusive, that all search results must match, unless the value is null.
     */
    dateExpirationMax?: Date;
    /**
     * The earliest expiration date, inclusive, that all search results must match, unless the value is null.
     */
    dateExpirationMin?: Date;
    /**
     * The latest modified date, inclusive, that all search results must match, unless the value is null.
     */
    dateModifiedMax?: Date;
    /**
     * The earliest modified date, inclusive, that all search results must match, unless the value is null.
     */
    dateModifiedMin?: Date;
    /**
     * An array of IDs that all search results must match one of, unless the array is empty.
     */
    ids?: string[];
    /**
     * An array of feature set collection IDs that all search results must match one of, unless the array is empty.
     */
    featureSetCollectionIds?: string[];
    /**
     * A string that should be contained in the name of all search results, unless it is null.
     */
    name?: string;
}

}
declare module "geocortex/infrastructure/selection/SelectionMetadataStore" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { Dictionary } from "geocortex/infrastructure/Dictionary";
import { SelectionMetadata } from "geocortex/infrastructure/selection/SelectionMetadata";
import { SelectionMetadataQuery } from "geocortex/infrastructure/selection/SelectionMetadataQuery";
/**
 * Helper class that models a storage facility for selection metadata.
 */
export class SelectionMetadataStore {
    /**
     * The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this search manager instance belongs to.
     */
    app: ViewerApplication;
    /** Internal state holding metadata about saved selections */
    protected _store: Dictionary<SelectionMetadata>;
    constructor(app: ViewerApplication);
    findByName(name: string): SelectionMetadata;
    findByCollectionId(fscId: string): SelectionMetadata;
    findById(id: string): SelectionMetadata;
    findAll(): SelectionMetadata[];
    find(queryParameters?: SelectionMetadataQuery): SelectionMetadata[];
    add(metadata: SelectionMetadata): string;
    updateById(id: string, values: SelectionMetadata): void;
    removeById(id: string): void;
    clear(): void;
    protected _update(metadata: SelectionMetadata, values: SelectionMetadata): void;
    protected _generateId(): string;
}

}
declare module "geocortex/infrastructure/sharing/SharingLinkProviderBase" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
/** Describes the priority of link providers that modify the map extent. */
export enum ExtentLinkPriority {
    /**
     * Scale must be applied first, or else its value is lost
     * when scale is recalculated upon changing the center or extent.
    */
    SCALE = 0,
    CENTER = 1,
    EXTENT = 2,
}
/** Describes the priority of link providers that modify the layer list. */
export enum LayerListLinkPriority {
    /**
     * Layer theme must be applied first or it will override
     * changes from the layer url parameter.
     */
    LAYERTHEME = 0,
    LAYERS = 1,
}
/**
 * The base class for all sharing link providers.
 */
export class SharingLinkProviderBase {
    app: ViewerApplication;
    libraryId: string;
    /** The name of the sharing link provider to be used in the url. */
    name: string;
    /** Whether the sharing link provider will apply a url parameter on startup. */
    acceptParameter: boolean;
    /** Whether the sharing link provider will produce a parameter when generating a url. */
    generateParameter: boolean;
    /** The priority for this sharing link provider when being applying on startup. */
    priority: number;
    /**
     * Create a new instance of the {@link SharingLinkProviderBase} class.
     * @param app The {@link ViewerApplication} that this command belongs to.
     * @param libraryId The ID of the library this component belongs to.
     */
    constructor(app: ViewerApplication, libraryId: string);
    /**
     * Initialize the provider.
     * @param config The configuration object.
     */
    initialize(config: any): void;
    /**
     * Generate the url parameter.
     */
    generate(): string;
    /**
     * Apply the url parameter.
     * @param urlParameter The url parameter to apply.
     */
    apply(urlParameter: string): void;
    /**
     * Gets a language resource from the Application's resource dictionary, given a key, and optional locale.
     * Returns null if the resource does not exist.
     * @param key The resource key.
     * @param locale The locale of the resource to fetch. Defaults to the current application locale.
     */
    getResource(resourceKey: string, locale?: string): string;
}

}
declare module "geocortex/infrastructure/snapping/SnappingLocations" {
/**
 * Descrbes what type of geometry locations a layer can be snapped on.
 */
export interface SnappingLocations {
    /**
     * Can snap to the edge of a geometry.
     */
    edge: boolean;
    /**
     * Can snap to the point geometry.
     */
    point: boolean;
    /**
     * Can snap to the vertex of a geometry.
     */
    vertex: boolean;
}

}
declare module "geocortex/infrastructure/snapping/SnappingProvider" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { Layer } from "geocortex/essentials/Layer";
import { SnappingLocations } from "geocortex/infrastructure/snapping/SnappingLocations";
import { AppInfo } from "geocortex/infrastructure/gis/AppInfo";
import { LayerInfo } from "geocortex/infrastructure/gis/LayerInfo";
/**
 * An interface used to describe the required components to implement a {@link SnappingProvider} which provides snapping information to the application.
 */
export interface SnappingProvider {
    /**
     * The {@link geocortex.framework.application.Application} that this provider belongs to.
     */
    app: ViewerApplication;
    /**
     * The library that this provider belongs to.
     */
    libraryId: string;
    /**
     * The ID of the provider.
     */
    id: string;
    /**
     * The name of the provider - may be displayed in the viewer.
     */
    name: string;
    /**
     * The configuration used to load the snapping provider.
     */
    providerConfiguration: any;
    /**
     * Initializes the {@link SnappingProvider} with configuration options.
     * @param config A configuration object.
     */
    initialize(config?: any): void;
    /**
     * Activates the {@link SnappingProvider} with a radius.
     * @param radius The radius of snapping in pixels.
     */
    activate(radius: number): void;
    /**
     * Deactivates the {@link SnappingProvider}.
     */
    deactivate(): void;
    /**
     * Provides a snapping point for a given location.
     * @param screenPoint The location.
     * @returns A promise which when resolved will have a snapping point or `null` if not found.
     */
    provideSnappingPoint(screenPoint: esri.geometry.ScreenPoint): Promise<esri.geometry.Point>;
    /**
     * Registers a layer for snapping.
     * @param layer The layer to register.
     * @param options The snapping locations.
     * @returns A boolean if the layer was added or not.
     */
    registerLayer(layer: Layer, options?: SnappingLocations): boolean;
    /**
     * Unregisters a layer from the {@link SnappingProvider}.
     * @param layer The layer to unregister.
     */
    unregisterLayer(layer: Layer): void;
    /**
     * Signals the {@link SnappingProvider} that it must refresh for a new extent.
     * @param extent The new map extent.
     */
    loadForExtent(extent: esri.geometry.Extent): void;
    /**
     * Returns information about which layers can be snapped to.
     * @param appInfo The application info to parse.
     * @returns An array of layer info.
     */
    getSnappableLayers(appInfo: AppInfo): LayerInfo[];
    /**
     * Pauses snapping in the {@link SnappingProvider}.
     */
    pauseSnapping(): void;
    /**
     * Continues snapping in the {@link SnappingProvider}.
     */
    continueSnapping(): void;
}

}
declare module "geocortex/infrastructure/states/State" {
/**
 * Represents a command/event that triggered a state.
 */
export interface CommandOrEventInstance {
    /**
     * The name of the command/event.
     */
    name: string;
    /**
     * The parameter associated with the execution of this command/event.
     */
    parameter?: string;
}
/**
 * Represents a currently active instance of a state.
 */
export class ActiveState {
    /**
     * The definition of the state that is active.
     */
    stateDefinition: StateDefinition;
    /**
     * Information about the command/event that caused the state to become active.
     */
    protected activatedBy: CommandOrEventInstance;
    constructor(stateDefinition: StateDefinition, activatedBy?: CommandOrEventInstance);
}
/**
 * Definition of a state that is placed into an ActiveState once it becomes active.
 * No variables within a StateDefinition should be changed after instantiation.
 */
export interface StateDefinition {
    /**
     * The name of the state. Used to reference it.
     */
    name: string;
    /**
     * The state that this state depends on. If the parent state is not active then this state is not active either.
     * However, if the parent state is reactivated and this state was sitting dormant (active but w/ no parent) then this
     * state will be considered active.
     */
    parentState?: string;
    /**
     * A human-readable description of what this state represents.
     */
    description: string;
    /**
     * If a state is modal than it means that no other modal states can be running at the same time.
     */
    isModal: boolean;
    /**
     * Events that will trigger the state as being active.
     */
    enterEvents?: CommandOrEventInstance[];
    /**
     * Events that will make the state become inactive.
     */
    exitEvents?: CommandOrEventInstance[];
    /**
     * Commands that will trigger the state as being active.
     */
    enterCommands?: CommandOrEventInstance[];
    /**
     * Commands that will make the state become inactive.
     */
    exitCommands?: CommandOrEventInstance[];
}

}
declare module "geocortex/infrastructure/states/StateManager" {
import { CommandOrEventInstance, StateDefinition, ActiveState } from "geocortex/infrastructure/states/State";
import { Application } from "geocortex/framework/application/Application";
/**
 * Used to associate a token with a command or event so that they can be unsubscribed on class destruction.
 */
export interface CommandOrEventToken {
    instance: CommandOrEventInstance;
    token: string;
}
export class StateManager {
    app: Application;
    libraryId: string;
    registeredStates: StateDefinition[];
    protected activeStates: ActiveState[];
    protected modalState: StateDefinition;
    protected previousModalState: StateDefinition;
    protected commandTokens: CommandOrEventToken[];
    protected eventTokens: CommandOrEventToken[];
    constructor(app: Application, libraryId: string);
    /**
     * Used to load the states into the registry. Does not allow for duplicate states.
     * @param newState The state to add to the registry.
     */
    registerState(newState: StateDefinition): void;
    /**
     * Run when the State Manager is destroyed.
     */
    onDestroy(): void;
    /**
     * Returns an array of the currently active states. Does not return children that currently lack
     * an active parent.
     */
    getActiveStates(): ActiveState[];
    /**
     * Returns a state from the manager's registry.
     * @param stateName The name of the state to retrieve from the registry.
     */
    getStateByName(stateName: string): StateDefinition;
    /**
     * Returns the currently active modal state, if any. Returns null if there is no state.
     */
    getModalState(): StateDefinition;
    /**
     * Returns whether a modal state is currently active or not.
     */
    isModalStateActive(): boolean;
    /**
     * Returns whether a state is currently active or not.
     * @param stateName The name of the state that is being checked.
     */
    isCurrentlyActive(stateName: string): boolean;
    /**
     * Returns an array with the names of all states in the registry.
     */
    getAllStateNames(): string[];
    /**
     * Run whenever a state is entered.
     * @param state The state this is being entered.
     * @param commandOrEvent The command/event instance that is associated with this state.
     * @param commandOrEventArgs The command/event's arguments (if any). Only strings are supported.
     */
    protected _stateEntered(state: StateDefinition, commandOrEvent: CommandOrEventInstance, commandOrEventArgs: any): void;
    /**
     * Run whenever a state is exited.
     * @param state The state to exit.
     * @param commandOrEvent The command/event instance that is associated with this state.
     * @param commandOrEventArgs The command/event's arguments (if any). Only strings are supported.
     */
    protected _stateExited(state: StateDefinition, commandOrEvent: CommandOrEventInstance, commandOrEventArgs: any): void;
    /**
     * Deactivates the current state.
     * Needs to exist outside of _stateExited() as it is also called on state activation in case there is a modal state active.
     * @param state The state to deactivate.
     * @param commandOrEvent The command/event instance that is associated with this state.
     * @param commandOrEventParameter The command/event's arguments (if any). Only strings are supported.
     */
    protected _exitState(state: StateDefinition, commandOrEvent: CommandOrEventInstance, commandOrEventParameter: string): void;
    /**
     * Exits any child states that should be exiting on the same command/event as the parent state.
     * @param state The state to deactivate.
     * @param commandOrEvent The command/event instance that is associated with this state.
     * @param commandOrEventParameter The command/event's arguments (if any). Only strings are supported.
     */
    protected _exitChildStates(state: StateDefinition, commandOrEvent: CommandOrEventInstance, commandOrEventParameter: string): void;
}

}
declare module "geocortex/infrastructure/states/States" {
import { StateDefinition } from "geocortex/infrastructure/states/State";
export var definedStates: StateDefinition[];

}
declare module "geocortex/infrastructure/symbology/AttributeSymbologySettingsConfig" {
import { RangeConfiguration } from "geocortex/infrastructure/ui/components/NumericInput/RangeConfiguration";
import { SymbologySettingsConfig } from "geocortex/infrastructure/symbology/SymbologySettingsConfig";
/**
 * Configuration for the widget.
 */
export interface AttributeSymbologySettingsConfig {
    /** Maximum allowable renderer classes */
    maxRenderClasses?: number;
    /** Maximum samples to use to create the classes */
    maxSamples?: number;
    /** Show slider along with native numeric inputs? */
    showSliders?: boolean;
    /** Default color to use for points that fall outside renderer classes */
    defaultPointColor?: number[];
    /** Default size of points that fall outside of renderer classes */
    defaultPointSize?: number;
    /** Default color to use for lines that fall outside renderer classes */
    defaultLineColor?: number[];
    /** Default line width to use for features that fall outside renderer classes */
    defaultLineWidth?: number;
    /** Default color to use for polygons that fall outside renderer classes */
    defaultFillColor?: number[];
    /** Range configuration for a transparency slider. */
    transparency?: RangeConfiguration;
    /** Default configuration for each class symbology selector widget. Settings also taken for global sliders. */
    classSymbolizationConfig?: SymbologySettingsConfig;
}

}
declare module "geocortex/infrastructure/symbology/AttributeSymbologySettingsView" {
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { AttributeSymbologySettingsViewModel } from "geocortex/infrastructure/symbology/AttributeSymbologySettingsViewModel";
import { AttributeSymbologySettingsConfig } from "geocortex/infrastructure/symbology/AttributeSymbologySettingsConfig";
/** Base string for creating unique ids for each symbology widget container */
export const WIDGET_ID_BASE: string;
/**
 * The symbology settings widget view.
 */
export class AttributeSymbologySettingsView extends ViewBase {
    /** The viewer application */
    app: ViewerApplication;
    /** Display name for binding to a picker */
    displayName: string;
    /** Configuration for the symbology settings widget. */
    configuration: AttributeSymbologySettingsConfig;
    /** View-model of the symbology settings widget. */
    viewModel: AttributeSymbologySettingsViewModel;
    /** Attribute selector dropdown. */
    attributeInput: HTMLSelectElement;
    /** Marker style dropdown. */
    private markerStyleInput;
    /** Container element that wraps around all symbology settings. */
    private container;
    /**
     * Attach this view to its view-model.
     */
    attach(viewModel: AttributeSymbologySettingsViewModel): void;
    /**
     * This widget attaches a reference to itself onto the parent view.
     */
    added(parentView: AttributeSymbologySettingsParentView): void;
    /**
     * Get the current settings of this widget as an esri.renderer.Renderer in JSON string form
     */
    getRenderer(): string;
    /**
     * Set this widget from a renderer
     * @param renderer An esri.renderer.Renderer in JSON string form
     */
    setFromRenderer(renderer: esri.renderer.Renderer): void;
    /**
     * Restore this widget's settings to the default
     */
    reset(): void;
    /**
     * Handle user changing marker style
     */
    handleMarkerStyle(): void;
    /**
     * Set view-model observables and populate the `symbols` object based on any changes here in the view.
     */
    applySettings(): void;
    private _updateClasses(attribute);
    private _updateColorGradient();
    /**
     * Hide / Show symbology widget and set class as selected / unselected
     * If a selected item is clicked, remove the symbology widget and unselect it
     * If an unselected item is clicked, show the symbology widget and unselect the currently selected.
     * The selected color from the widget will be propagated to the swatch in the class list at this point.
     */
    handleSymbolClassSelected(event: Event): void;
}
/**
 * The parent view of this widget contains a reference to this widget.
 */
export interface AttributeSymbologySettingsParentView extends ViewBase {
    /** Parent's reference to the child symbology widget view. */
    attributeSettingsView?: AttributeSymbologySettingsView;
}

}
declare module "geocortex/infrastructure/symbology/AttributeSymbologySettingsViewModel" {
import { Field } from "geocortex/essentials/Field";
import { FieldInfo } from "geocortex/infrastructure/gis/FieldInfo";
import { SymbologySettingsStyle } from "geocortex/infrastructure/symbology/SymbologySettingsViewModel";
import { ViewModelBase } from "geocortex/framework/ui/ViewModelBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { ObservableCollection, Observable } from "geocortex/framework/observables";
import { SymbologySettingsView } from "geocortex/infrastructure/symbology/SymbologySettingsView";
import { ColorPickerViewModel } from "geocortex/infrastructure/ui/components/ColorPicker/ColorPickerViewModel";
import { NumericInputViewModel } from "geocortex/infrastructure/ui/components/NumericInput/NumericInputViewModel";
import { AttributeSymbologySettingsConfig } from "geocortex/infrastructure/symbology/AttributeSymbologySettingsConfig";
/**
 * View-model for the attribute symbology settings widget.
 */
export class AttributeSymbologySettingsViewModel extends ViewModelBase {
    /** The viewer application */
    app: ViewerApplication;
    /** Configuration for the symbology settings view-model. */
    config: AttributeSymbologySettingsConfig;
    /** Attributes to symbolize on */
    attributes: ObservableCollection<Field>;
    currentAttribute: Observable<string>;
    /** What kind of symbolization is it? */
    classBreaksMode: Observable<boolean>;
    /** What kind of field is it? Numeric fields are sometimes unique value renderers if data is limited. */
    isNumericAttribute: Observable<boolean>;
    /** Symbology class info for binding to view */
    symbologyClasses: ObservableCollection<SymbolClassInfo>;
    /** The currently selected symbology class */
    selectedClass: string;
    /** The widgets used to configure the symbology for each class */
    classSymbolWidgets: SymbologySettingsView[];
    /** Maximum allowable number of renderer classes */
    maxRenderClasses: number;
    /** Max number of samples to use in class creation */
    maxSamples: number;
    /** Default symbols for data that does not fall within generated classes */
    defaultPointSymbol: esri.symbol.SimpleMarkerSymbol;
    defaultLineSymbol: esri.symbol.SimpleLineSymbol;
    defaultPolygonSymbol: esri.symbol.SimpleFillSymbol;
    /** Type of feature being symbolized. One of 'Point' 'Line' or 'Polygon' */
    featureType: string;
    /** The colors used in the symbology */
    startColor: ColorPickerViewModel;
    endColor: ColorPickerViewModel;
    /** Observable for the selected number of class breaks. */
    numBreaks: Observable<number>;
    /** View model for the class breaks selector widget. */
    classBreaksInput: NumericInputViewModel;
    /** Observable for the user-selected marker size. */
    markerSize: Observable<number>;
    /** View model for the marker size selector widget */
    markerSizeInput: NumericInputViewModel;
    /** Observable for the user-selected line width. */
    lineWidth: Observable<number>;
    /** View model for the line width selector widget */
    lineWidthInput: NumericInputViewModel;
    /** Observable for the user-selected fill transparency. */
    transparency: Observable<number>;
    /** View model for the transparency selector widget */
    transparencyInput: NumericInputViewModel;
    /** Disables availability of marker related options. */
    noMarker: Observable<boolean>;
    /** The currently selected markerStyle */
    markerStyleIndex: number;
    /** Styles available to point markers. */
    markerStyles: ObservableCollection<SymbologySettingsStyle>;
    /** These are used to translate style ids from Esri JS API to Esri REST API form */
    markerStyleIdLookup: {
        [id: string]: string;
    };
    /** Flag to stop change events from being applied while configuring */
    configuring: boolean;
    /** Bindings that fire after class creation is begun but before it completes need to know not to kick this off again */
    creatingClasses: boolean;
    /** Don't unnecessarily try to create class breaks renderers that won't work */
    numericAttributeIsUniqueValue: boolean;
    /**
     * Temporary cache of ArcGIS Server query responses created by symbolization. Indexed by a hash of url + field + extent. Cleared when changing layers.
     *
     * Some configurations of layer extent, map extent and renderer type will cause multiple query requests with the same parameters to occur.
     * This is bad for two reasons:
     *
     * 1:  Requests to ArcGIS Server are often sent with no-cache headers, so the identical requests cannot be counted on to 304.
     *     But it's ok if they do, as they are separated only by milliseconds in practice.
     *
     * 2:  When the requests *do* 304, a strange bug is exposed in *Chrome only* where the esri (dojo) request will timeout
     *     and not recieve results even though it is an immediate 304. This causes the code to hang for a full minute *before* dropping into the error handler.
     *     Hopefully this will be fixed in the future, as I can't figure out at all why this should occur, or which part of the stack is at fault here.
     */
    queryResults: esri.tasks.FeatureSet[];
    /**
     * Initialize the widget based on configuration.
     */
    initialize(configuration?: AttributeSymbologySettingsConfig): void;
    /**
     * Restores settings to the default state
     * PRIVATE: Call 'reset' on AttributeSymbologySettingsView
     */
    _reset(): void;
    /**
     * Returns a renderer based on the current widget setttings as a JSON string
     * PRIVATE: Call 'getRenderer' on AttributeSymbologySettingsView
     */
    _getRenderer(): string;
    /**
     * Sets the state of the widget based on a supplied class breaks or unique value renderer
     * PRIVATE: Call 'setFromRenderer' on AttributeSymbologySettingsView
     * @param renderer
     */
    _setFromRenderer(renderer: esri.renderer.Renderer): void;
    /**
     * Set the state of this widget from a supplied ClassBreaksRenderer
     * @param renderer esri.renderer.ClassBreaksRenderer as a WebMap/Rest API JSON object
     * @param fieldInfo field used to configure this renderer
     */
    private _setFromClassBreaksRenderer(renderer, fieldInfo);
    /**
     * Set the state of this widget from a supplied UniqueValueRenderer
     * @param renderer esri.renderer.UniqueValueRenderer as a WebMap/REST API JSON object
     * @param fieldInfo the field used to configure the renderer
     */
    private _setFromUniqueValueRenderer(renderer, fieldInfo);
    /**
     * Sets the global configuration of this widget from the supplied symbol
     * @param symbol
     */
    private _setFromSymbol(symbol);
    /**
     * Global sliders are geared towards symbology made from *markersymbols so there isn't really much to do here
     * @param symbol
     */
    private _setFromPictureMarkerSymbol(symbol);
    /**
     * Given a quantitative value field, automatically create a set of class breaks to use for a renderer
     * PRIVATE: Internal method of this widget
     * @param attribute
     */
    _createClassBreaks(attribute: AttributeInfo): void;
    /**
     * Given a string field, automatically create a set of unique values to use for a renderer
     * PRIVATE: Internal method of this widget
     * @param attribute
     */
    _createUniqueValues(attribute: AttributeInfo): void;
    /**
     * Assign default colors to classes and configure the symbology widgets
     * PRIVATE: Only call from this widget.
     * @param attribute
     */
    _createRendererClasses(): void;
    /**
     * Set up the query task, then return a promise of the results
     * @param attribute
     */
    private _executeQuery(attribute, extent);
    /**
     * Query successively larger extents until the desired number of features return, or no more features are available.
     * Each query will double the size of the extent used.
     * @param attribute
     * @param extent
     */
    private _executeExtentQuery(attribute, extent);
    /**
     * For unique values we want to stop increasing the extent when we have reached the maximum number of unique values allowed.
     * @param attribute
     * @param extent
     */
    private _executeUniqueValueExtentQuery(attribute, extent);
    /**
     * For class breaks we want to keep increasing the extent until we have reached the maximum number of samples allowed.
     */
    private _executeClassBreaksExtentQuery(attribute, extent);
    /**
     * Sorts symbol classes by count and closeness to the user, and constrains the collection to 'maxRenderClasses' items
     * @param results
     */
    private _constrainToMaxClasses(attribute);
    /**
     * Resets a symbology picker and configures it from a symbol
     * @param symbolWidget
     */
    private _configureSymbolWidget(symbolWidget, symbol);
    /**
     * Returns distinct values for an attribute in a feature set
     * Note that a distinct value query using esri's API methods does not work on some layers, specifically FeatureService feature layers
     * @param featureSet
     * @param attribute
     */
    private _findDistinctValues(featureSet, attribute);
    /**
     * Given an essentials field, get the fieldInfo object used for formatting and resolving domains
     * PRIVATE: Internal method of this widget
     * @param field
     */
    _getFieldInfo(field: Field): Promise<FieldInfo>;
    /**
     * Looking for coded domains *just* on the ESRI field...
     * fieldInfo.isCodedValueDomain() returns false positives, as it creates fake 'domains' when there is a subtype defined.
     * @param fieldInfo
     */
    private _hasCodedDomain(fieldInfo);
    private _isPictureMarkerSymbol(symbol);
}
/**
 * An object to hold the settings for each rendered class in class breaks or unique value mode
 */
export interface SymbolClassInfo {
    name: string;
    value?: string;
    min?: number;
    max?: number;
    count?: number;
    displayColor: string;
    selected: boolean;
    isImage: Observable<boolean>;
    imageSrc: string;
    widgetId: string;
}
/**
 * Wrapper for a field + fieldInfo (used for formatting and coded values)
 */
export interface AttributeInfo {
    field: Field;
    fieldInfo: FieldInfo;
}

}
declare module "geocortex/infrastructure/symbology/DataClassificationUtils" {
/**
* Ckmeans clustering is an improvement on heuristic-based clustering
* approaches like Jenks. The algorithm was developed by
* Haizhou Wang and Mingzhou Song (http://journal.r-project.org/archive/2011-2/RJournal_2011-2_Wang+Song.pdf)
* as a dynamic programming(https://en.wikipedia.org/wiki/Dynamic_programming) approach
* to the problem of clustering numeric data into groups with the least
* within-group sum-of-squared-deviations.
*
* Minimizing the difference within groups - what Wang & Song refer to as
* `withinss`, or within sum-of-squares, means that groups are optimally
* homogenous within and the data is split into representative groups.
* This is very useful for visualization, where you may want to represent
* a continuous variable in discrete color or style groups. This function
* can provide groups that emphasize differences between data.
*
* From the JavaScript implementation by Tom MacWright
* https://github.com/simple-statistics
* Original copyright notice follows:
*
* Copyright (c) 2014, Tom MacWright
*
* Permission to use, copy, modify, and/or distribute this software for any
* purpose with or without fee is hereby granted, provided that the above
* copyright notice and this permission notice appear in all copies.
*
* THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
* REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
* FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
* INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
* LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
* OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
* PERFORMANCE OF THIS SOFTWARE.
*
* @param data The data to classify
* @param numClusters The number of desired classes
*/
export function ckmeans(data: number[], numClusters: number): number[][];
/**
 * Create a new column x row matrix.
 */
export function createMatrix(columns: number, rows: number): number[][];
/**
 * For a sorted input, counting the number of unique values
 * is possible in constant time and constant memory. This is
 * a simple implementation of the algorithm.
 *
 * Values are compared with `===`, so objects and non-primitive objects
 * are not handled in any special way.
 */
export function uniqueCountSorted(input: any[]): number;
/**
 * Attempts to find a reasonable number of significant digits for the created breaks
 * Probably not possible to be 100% correct with all possible data sets,
 * but should err on the side of too much significance, rather than too little.
 * @param numbers
 */
export function findSignificanceFactor(numbers: number[]): number;
/**
 * Gets the internationalized decimal separator
 */
export function getDecimalSeparator(): string;

}
declare module "geocortex/infrastructure/symbology/MarkupTemplates" {
import { Observable } from "geocortex/framework/observables";
import { LazyObservable } from "geocortex/framework-ui/LazyObservable";
/**
 * Markup templates are bound to views, and provide the ability to create the symbol that they represent.
 * @param type The symbol type. One of {@link SymbolType}, should always correctly reflect the subtype of the template.
 * @param name The name of this symbol. Will be read in from the 'name' property in the supplied symbol JSON.
 * @param hash Lazy Observable that returns a unique hash for this template. Used to match edited symbols with templates.
 * @param selected Is this template currently selected? Used when bound to a view in groups.
 * @param toSymbol A method which produces the symbol this template represents.
 * @param toJsonString A method which produces the JSON string representing this template's symbol
 */
export interface MarkupTemplate {
    type: string;
    name: string;
    hash: LazyObservable<number>;
    selected: Observable<boolean>;
    toSymbol: () => esri.symbol.Symbol;
    toJsonString: () => string;
}
/**
 * Variant of MarkupTemplate for point markup
 * @param style The esri.symbol.SimpleMarkerSymbol style for this symbol
 * @param size The size of the point
 * @param color The color of the point as a numeric array
 * @param outlineColor The color of the point's outline, if any.
 * @param outlineStyle The esri.symbol.SimpleLineSymbol style for the outline
 * @param outlineWidth The width of the outline.
 */
export interface PointTemplate extends MarkupTemplate {
    style: string;
    size: number;
    color: number[];
    outlineColor?: number[];
    outlineStyle?: string;
    outlineWidth?: number;
}
/**
 * Variant of MarkupTemplate for polyline markup
 * @param style The esri.symbol.SimpleLineSymbol style for this symbol
 * @param color The color of the line as a numeric array
 * @param width The width of the line
 */
export interface PolylineTemplate extends MarkupTemplate {
    style: string;
    color: number[];
    width: number;
}
/**
 * Variant of MarkupTemplate for polygon markup
 * @param borderStyle The esri.symbol.SimpleLineSymbol style for the border
 * @param fillStyle The esri.symbol.SimpleFillSymbol style for the fill
 * @param borderWidth The width of the border
 * @param borderColor The color of the border as a numeric array
 * @param fillColor The color of the fill as a numeric array
 */
export interface PolygonTemplate extends MarkupTemplate {
    borderStyle: string;
    fillStyle: string;
    borderWidth: number;
    borderColor: number[];
    fillColor: number[];
}
/**
 * Variant of MarkupTemplate for text markup
 * @param textFamily The font family used
 * @param style The esri.symbol.Font style used.
 * @param weight The esri.symbol.Font font weight used.
 * @param size The size of the font. Can be a number (px) or string (eg: "12pt")
 * @param color The color of the font as a numeric array
 * @param haloSize The width of the font halo
 * @param halocolor The color of the halo as a numeric array
 */
export interface TextTemplate extends MarkupTemplate {
    textFamily: string;
    style: string;
    weight: string;
    decoration: string;
    size: string | number;
    color: number[];
    haloSize: number;
    haloColor: number[];
}
/**
 * Variant of MarkupTemplate used for PictureMarkerSymbols
 * @param url The image to use. Can be a http or data url.
 * @param size The size of the image. For rectangular images this will be the height.
 * @param widthRatio The ratio of the width to the height. Stored this way so images can be easily scaled
 * @param xoffset The x offset of the image's anchor point. Stored as a ratio of offset to image width for scaling.
 * @param yoffset The y offset of the image's anchor point. Stored as a ratio of offset to image height for scaling.
 */
export interface ImageTemplate extends MarkupTemplate {
    url: string;
    size: number;
    widthRatio: number;
    xoffset: number;
    yoffset: number;
    angle: number;
    id: string;
}

}
declare module "geocortex/infrastructure/symbology/SymbolColor" {
/**
 * Encapulates some common color operations useful for making symbology.
 * Primary use is to generate the RGB hexidecimal color code for a color in HSV (hue, saturation, value) color space.
 * This is far preferable to using RGB for mapping applications, as random colors generated
 * in RGB will trend towards the dark and unsaturated, and often look quite similar.
 * To use, supply a number between 0 and 1 for each of hue, saturation, and value.
 * To generate a series of random colors with a consistent tone, supply a random number for 'hue' only.
 */
export class SymbolColor {
    hue: number;
    value: number;
    saturation: number;
    alpha: number;
    /**
     * SymbolColor can be instantiated with HSV values, RGB values, or a string (either RGBA or hex)
     * Most raw values supplied should be in the range 0..1, though RGB can also be supplied in byte form
     * The intent is not to have to worry about what kind of color representation you have -- just toss it in here and it works
     * @param color
     */
    constructor(color: HSV | RGB | string | esri.Color);
    /**
     * Returns a hexidecimal string representing the color.
     */
    toHex(): string;
    /**
     * Returns a string like "rgba(255, 255, 255, 1)" representing the color.
     */
    toRGBAString(): string;
    /**
     * Convert to an instance of esri.Color
     */
    toEsriColor(includeAlpha?: boolean): esri.Color;
    /**
     * Darkens the color by an amount and returns a hex string
     * @param amount ranges from 0..1
     */
    darken(amount: number, includeAlpha?: boolean): SymbolColor;
    /**
     * Lightens the color by an amount and returns a hex string
     * @param amount ranges from 0..1
     */
    lighten(amount: number, includeAlpha?: boolean): SymbolColor;
    /**
     * Blend this color with another by an amount and return a new color
     * Uses linear interpolation in the RGB colorspace.
     * @param amount ranges from 0..1
     * @param color another instance of SymbolColor
     */
    blend(amount: number, color: SymbolColor): SymbolColor;
    /**
     * Returns the raw RGB values of the color
     * See https://en.wikipedia.org/wiki/HSL_and_HSV#Converting_to_RGB for a detailed discussion of this algorithm.
     */
    toRGB(): RGB;
    /**
     * Is this color the same as the supplied color?
     * @param color
     */
    equals(color: SymbolColor): boolean;
    /**
     * Return a new SymbolColor with the transparency set to alpha
     */
    setAlpha(alpha: number): SymbolColor;
    /**
     * Converts raw RGB values to their HSV equivalents. Reverse of the above
     * Also discussed on this page: https://en.wikipedia.org/wiki/HSL_and_HSV
     * @param color
     */
    private _fromRGB(color);
    /**
     * Convert an instance of an esri.Color
     * @param color
     */
    private _fromEsriColor(color);
    /**
     * Convert raw RGB values to a hex string
     * @param color
     */
    private _rgbToHex(color);
    /**
     * Returns rgb values from 0..1 given an RGB hex string. Short format is acceptable.
     * See: http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
     * @param hex
     */
    private _hexToRGB(hex);
    /**
     * Clamp a number between two values
     * @param n
     * @param min
     * @param max
     */
    private _clamp(n, min, max);
    /**
     * Custom type guard for raw values in HSV format
     * @param a
     */
    private _isHSV(a);
    /**
     * Custom type guard for raw values in RGB format
     * @param a
     */
    private _isRGB(a);
}
export interface RGB {
    r: number;
    g: number;
    b: number;
    a?: number;
}
export interface HSV {
    h: number;
    s: number;
    v: number;
    a?: number;
}

}
declare module "geocortex/infrastructure/symbology/SymbolEditorView" {
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { SymbolEditorViewModel } from "geocortex/infrastructure/symbology/SymbolEditorViewModel";
import { SymbologyWidget } from "geocortex/infrastructure/symbology/widgets/SymbologyWidget";
export class SymbolEditorView extends ViewBase implements SymbologyWidget {
    app: ViewerApplication;
    viewModel: SymbolEditorViewModel;
    /** Display name of this view to be bound in a selector */
    displayName: string;
    /** Handle changes to symbology */
    onChange: (symbol: string) => void;
    customSymbolCreated: {
        [markupType: string]: boolean;
    };
    parentView: ViewBase;
    constructor(app: ViewerApplication, libraryId?: string);
    /**
     * Initialize widget
     * @param viewModel
     */
    attach(viewModel: SymbolEditorViewModel): void;
    setSymbolType(type: string): void;
    setFromSymbol(symbol: esri.symbol.Symbol): void;
    /**
     * Current configured symbol as a JSON string
     */
    getSymbol(): string;
    applySettings(): void;
    /**
     * Calling 'reset' on this widget reverts the viewmodel to the default state
     */
    reset(): void;
    /**
     * This widget attaches a reference to itself onto the parent view.
     */
    added(parentView: SymbolEditorParentView): void;
    private _selectWidget(widgetId);
}
/**
 * The parent view of this widget contains a reference to this widget.
 */
export interface SymbolEditorParentView extends ViewBase {
    /** Parent's reference to the child symbology widget view. */
    symbolEditorWidget?: SymbolEditorView;
}

}
declare module "geocortex/infrastructure/symbology/SymbolEditorViewModel" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { ViewModelBase } from "geocortex/framework/ui/ViewModelBase";
import { Observable } from "geocortex/framework/observables";
import { SimpleSymbolWidget } from "geocortex/infrastructure/symbology/widgets/SimpleSymbolWidget";
import { TextSymbolWidget } from "geocortex/infrastructure/symbology/widgets/TextSymbolWidget";
import { PictureSymbolWidget } from "geocortex/infrastructure/symbology/widgets/PictureSymbolWidget";
export class SymbolEditorViewModel extends ViewModelBase {
    app: ViewerApplication;
    config: any;
    initialized: boolean;
    /** Type of markup currently being configured. */
    markupType: Observable<string>;
    showSymbologySelectorMenu: Observable<boolean>;
    selectorMode: Observable<string>;
    symbolWidget: SimpleSymbolWidget;
    textSymbolWidget: TextSymbolWidget;
    pictureSymbolWidget: PictureSymbolWidget;
    regionName: string;
    constructor(app: ViewerApplication, libraryId: string);
    initialize(config: any): void;
    _reset(): void;
}

}
declare module "geocortex/infrastructure/symbology/SymbologySettingsConfig" {
import { SimpleSymbolWidgetConfig } from "geocortex/infrastructure/symbology/widgets/SimpleSymbolWidgetConfig";
import { PictureSymbolWidgetConfig } from "geocortex/infrastructure/symbology/widgets/PictureSymbolWidgetConfig";
/**
 * Configuration for the widget.
 */
export interface SymbologySettingsConfig {
    /** Whether to allow selecting an image for point markup */
    enableImageSelector?: boolean;
    /** Settings for the simple symbology widget */
    symbologyConfig?: SimpleSymbolWidgetConfig;
    /** Settings for the picture symbology widget */
    pictureSymbologyConfig?: PictureSymbolWidgetConfig;
}

}
declare module "geocortex/infrastructure/symbology/SymbologySettingsView" {
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { SymbologySettingsViewModel } from "geocortex/infrastructure/symbology/SymbologySettingsViewModel";
import { SimpleSymbolWidget } from "geocortex/infrastructure/symbology/widgets/SimpleSymbolWidget";
import { PictureSymbolWidget } from "geocortex/infrastructure/symbology/widgets/PictureSymbolWidget";
import { SymbologyWidget } from "geocortex/infrastructure/symbology/widgets/SymbologyWidget";
/**
 * The symbology settings widget view.
 */
export class SymbologySettingsView extends ViewBase implements SymbologyWidget {
    app: ViewerApplication;
    /** View-model of the symbology settings widget. */
    viewModel: SymbologySettingsViewModel;
    /** Display name for binding to a selector */
    displayName: string;
    /** Widget for symbology settings. */
    symbologyWidget: SimpleSymbolWidget;
    /** Widget for picture symbology settings. */
    pictureSymbologyWidget: PictureSymbolWidget;
    /** Container element that wraps around all symbology settings. */
    container: HTMLDivElement;
    constructor(app: ViewerApplication, libraryId: string);
    attach(viewModel: SymbologySettingsViewModel): void;
    /**
     * This widget attaches a reference to itself onto the parent view.
     */
    added(parentView?: SymbologySettingsParentView): void;
    /**
     * The PictureMarker symbology widget is optional. We'll resolve it (or not) here to avoid loading it unneccessarily
     */
    resolveWidget(widgetId: string, context: any, binding: any): any;
    /**
     * Apply the current settings of this widget to create the resulting symbol
     */
    applySettings(updateSubWidgets?: boolean): void;
    /**
     * Set the feature type currently configured by this widget
     * @param type One of "point", "polyline" or "polygon"
     */
    setFeatureType(type: string): void;
    /**
     * Get the symbol currently configured by this widget as a JSON  string
     */
    getSymbol(): string;
    /**
     * Sets the configuration of this widget from a supplied esri.symbol.Symbol
     * @param symbol Must be of a type supported by this widget: Simple***Symbol or PictureMarkerSymbol
     */
    setFromSymbol(symbol: esri.symbol.Symbol): void;
    /**
     * Sets the configuration of this widget from the symbol contained in the supplied esri.renderer.Renderer
     * @param renderer
     */
    setFromRenderer(renderer: esri.renderer.Renderer): void;
    /**
     * Calling 'reset' on this widget reverts to the default state
     */
    reset(): void;
    /**
     * Get the currently active widget. If no widget yet selected return the simple symbology widget.
     */
    private _getCurrentWidget();
}
/**
 * The parent view of this widget contains a reference to this widget.
 */
export interface SymbologySettingsParentView extends ViewBase {
    /** Parent's reference to the child symbology widget view. */
    symbologySettingsWidget?: SymbologySettingsView;
}

}
declare module "geocortex/infrastructure/symbology/SymbologySettingsViewModel" {
import { ViewModelBase } from "geocortex/framework/ui/ViewModelBase";
import { Observable, ObservableCollection } from "geocortex/framework/observables";
import { PictureSymbolWidget } from "geocortex/infrastructure/symbology/widgets/PictureSymbolWidget";
import { SimpleSymbolWidget } from "geocortex/infrastructure/symbology/widgets/SimpleSymbolWidget";
import { SymbologyWidget } from "geocortex/infrastructure/symbology/widgets/SymbologyWidget";
import { SymbologySettingsConfig } from "geocortex/infrastructure/symbology/SymbologySettingsConfig";
/**
 * View-model for the symbology settings view.
 */
export class SymbologySettingsViewModel extends ViewModelBase {
    /** Configuration for the symbology settings view-model. */
    config: SymbologySettingsConfig;
    /** The complete set of symbols produced by this widget */
    symbols: SymbologySettingsSymbols;
    /** Disables availability of marker related options. DEPRECATED @ 2.8 */
    noMarker: Observable<boolean>;
    /** Disables availability of fill related options. DEPRECATED @ 2.8 */
    noFill: Observable<boolean>;
    /** Set relevant observables to configure, or use 'setFeatureType()' to configure for a single feature type */
    isPoint: Observable<boolean>;
    isLine: Observable<boolean>;
    isPolygon: Observable<boolean>;
    /** Whether to show the dropdown selector. Currently only used to switch between picture and simple markup point types */
    showSymbologySelectorMenu: Observable<boolean>;
    /** Observable to control visibility of the two views */
    symbolizeWithImagery: Observable<boolean>;
    /** The available symbology widgets */
    symbologyWidgets: ObservableCollection<SymbologyWidget>;
    /** The currently active widget */
    currentWidget: Observable<SymbologyWidget>;
    /** The picture marker symbol widget */
    imageSelector: PictureSymbolWidget;
    /** The symbol selector widget */
    symbolSelector: SimpleSymbolWidget;
    /**
     * Initialize the widget based on configuration.
     */
    initialize(configuration?: SymbologySettingsConfig): void;
    /**
     * Returns the widget to the default state (as defined by the configuration object)
     * PRIVATE: Call 'reset' on SymbologySettingsView
     */
    _reset(): void;
    /**
     * Set the feature type of this widget to point, line, polygon
     * PRIVATE: Call 'setFeatureType' on SymbologySettingsView
     * @param featureType
     */
    _setFeatureType(featureType: string): void;
    /**
     * Returns a renderer based on the current widget setttings as a JSON string
     * PRIVATE: Call 'getRenderer' on SymbologySettingsView
     */
    _getRenderer(): string;
    /**
     * Returns a symbol as a json string, based on the current widget settings
     * PRIVATE: Call 'getSymbol' on SymbologySettingsView
     */
    _getSymbol(): string;
    /**
     * Sets the state of the widget based on a supplied simple renderer
     * PRIVATE: Call 'setFromRenderer' on SymbologySettingsView
     * @param renderer
     */
    _setFromRenderer(renderer: esri.renderer.Renderer): void;
    /**
     * Sets the state of the widget based on a supplied symbol
     * PRIVATE: Call 'setFromSymbol' on SymbologySettingsView
     * @param symbol
     */
    _setFromSymbol(symbol: esri.symbol.Symbol): void;
}
/**
 * Symbol style available for a user to select from a dropdown.
 */
export interface SymbologySettingsStyle {
    /** Internationalized name for this symbol style. */
    label: string;
    /** Shape of the symbol. One of the `(SimpleMarkerSymbol|SimpleLineSymbol|SimpleFillSymbol).STYLE_*` constants. */
    style: string;
}
/**
 * Final resultant symbols offered by the widget.
 */
export interface SymbologySettingsSymbols {
    marker: esri.symbol.SimpleMarkerSymbol | esri.symbol.PictureMarkerSymbol;
    line: esri.symbol.SimpleLineSymbol;
    fill: esri.symbol.SimpleFillSymbol;
}

}
declare module "geocortex/infrastructure/symbology/SymbolType" {
/**
 * Types and styles of symbols used in symbolization and markup
 */
export class SymbolType {
    static POINT: string;
    static MULTIPOINT: string;
    static POLYLINE: string;
    static POLYGON: string;
    static TEXT: string;
}

}
declare module "geocortex/infrastructure/toolbarGroup/ToolbarGroupBase" {
import { ToolbarGroupItemBaseEntry, ToolbarGroupItemBase } from "geocortex/infrastructure/toolbarGroup/ToolbarGroupItemBase";
import { ObservableCollection, Observable } from "geocortex/framework/observables";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
export interface ToolbarGroupBaseEntry {
    name: string;
    id: string;
    type?: string;
    tooltip?: string;
    isDefault?: boolean;
    libraryId?: string;
    items?: ToolbarGroupItemBaseEntry[];
}
export function registerToolbarFactoryMethod(typeName: string, delegate: (app, lib, entry) => ToolbarGroupItemBase): void;
export function createToolbarItem(app: any, libraryId: string, entry: ToolbarGroupItemBaseEntry): ToolbarGroupItemBase;
export class ToolbarGroupBase {
    items: ObservableCollection<ToolbarGroupItemBase>;
    app: ViewerApplication;
    libraryId: string;
    id: string;
    name: Observable<string>;
    tooltip: Observable<string>;
    type: string;
    isDefault: boolean;
    isActive: Observable<boolean>;
    disabled: Observable<boolean>;
    cssClass: Observable<string>;
    constructor(app: ViewerApplication, libraryId: string, entry?: ToolbarGroupBaseEntry);
    getToolbarGroupItems(items: ToolbarGroupItemBaseEntry[]): ObservableCollection<ToolbarGroupItemBase>;
}

}
declare module "geocortex/infrastructure/toolbarGroup/ToolbarGroupItemBase" {
import { Observable, ObservableCollection } from "geocortex/framework/observables";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { CommandViewModel } from "geocortex/infrastructure/CommandViewModel";
import { ToolBase } from "geocortex/infrastructure/tools/ToolBase";
export interface ToolbarGroupItemBaseEntry {
    id: string;
    type: string;
    name: string;
    tooltip?: string;
    libraryId?: string;
    hideOnDisable?: boolean;
}
export class ToolbarGroupItemBase {
    type: string;
    name: Observable<string>;
    id: string;
    /**
     * The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this menu instance belongs to.
     */
    app: ViewerApplication;
    /**
     * The library used for resource obtaining.
     */
    libraryId: string;
    /**
     * True if the item is active
     */
    isActive: Observable<boolean>;
    /**
     * True if the item has an associated transient that is currently visible.
     */
    activeTransient: Observable<boolean>;
    /**
     * True if disabled
     */
    disabled: Observable<boolean>;
    /**
      * True if disabled and hideOnDisable = true
    */
    hidden: Observable<boolean>;
    /**
     * Hide this item entirely if disabled.
     */
    hideOnDisable: Observable<boolean>;
    /**
     * Tooltip for mouseover.
     */
    tooltip: Observable<string>;
    /**
     * Associated css class.
     */
    cssClass: Observable<string>;
    subscriptionToken: string;
    /*************************************************************************************************
     * Below variables are associated with subclasses but not used by this class.
     * They are here as sometimes a ToolbarItemBase will be a button, so it will need 'command', etc.
     *************************************************************************************************/
    /**
     * Associated command to execute.
     */
    command: CommandViewModel;
    /**
     * Icon for display in toolbar.
     */
    iconUri: Observable<string>;
    /**
     * The actual tool stored.
     */
    tool: ToolBase;
    /**
     * Name of the ToolbarRegion Region.
     */
    regionName: string;
    /**
     * Collection of items for the Toolbar.
     */
    items: ObservableCollection<ToolbarGroupItemBase>;
    /**
     * Whether the tool has the ability to be displayed as small..
     */
    hasSmallLayout: Observable<boolean>;
    /**
     * Currently selected tool. (Flyout specific)
     */
    selectedTool: Observable<ToolbarGroupItemBase>;
    /**
     * Whether the multitool flyout is open. (Flyout specific)
     */
    toolChangeActive: Observable<boolean>;
    constructor(app: ViewerApplication, libraryId: string, entry?: ToolbarGroupItemBaseEntry);
    areAllHidden(items: ObservableCollection<ToolbarGroupItemBase>): boolean;
    setHidden(): void;
    execute(): void;
    activate(): void;
    deactivate(): void;
    onDestroy(): void;
}

}
declare module "geocortex/infrastructure/toolbarGroup/ToolbarGroupRegistry" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { ObservableCollection } from "geocortex/framework/observables";
import { ToolbarGroupBase, ToolbarGroupBaseEntry } from "geocortex/infrastructure/toolbarGroup/ToolbarGroupBase";
export class ToolbarGroupRegistry {
    /**
     * The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this toolbargroup instance belongs to.
     */
    app: ViewerApplication;
    /**
     * An array consisting of all referenced toolbargroups
     * @type {geocortex.essentialsHtmlViewer.mapping.infrastructure.toolbar.toolbarGroupBase}
     */
    toolbarGroupList: ObservableCollection<ToolbarGroupBase>;
    /**
     * Config object containing toolbar groups configuration
     * @private
     */
    private _toolbarGroupsConfig;
    constructor(app: ViewerApplication);
    /**
     * Fetch a new instance of toolbar group instance by id
     * @param id Id of the toolbarGroup
     */
    getToolbarGroupById(id: string): ToolbarGroupBase;
    /**
     * Registers a toolbar group
     */
    registerToolbarGroups(toolbarGroups: ToolbarGroupBaseEntry[], libraryId?: string): void;
    /**
     * Unregister the group with the given id if it is registered.
     * @param id {String} Id of the toolbar group to be unregistered
     */
    unregisterToolbarGroup(id: string): void;
    /**
     * Fetches the position of toolbar group in the list
     * @param id {String} Id of the toolbar group whose position is to be determined
     */
    getPosition(id: string): number;
}

}
declare module "geocortex/infrastructure/tools/DisablingMapTool" {
import { MapTool } from "geocortex/infrastructure/tools/MapTool";
import { Observable } from "geocortex/framework/observables";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
/**
 * An extension of MapTool that implements ToolBase's ```enabled: Observable<boolean>``` by calling
 * the command's canExecute with no arguments.  This is playing fast and loose with what 'canExecute'
 * means because of course the command can't actually execute without the geometry input.  However
 * we don't have that geometry until after the tool executes so it's a chicken and egg problem.
 * This functionality is not in MapTool because not all Commands do (should?) follow this convention.
 */
export class DisablingMapTool extends MapTool {
    enabled: Observable<boolean>;
    constructor(app: ViewerApplication, mixin: any);
}

}
declare module "geocortex/infrastructure/tools/DrawMode" {
export class DrawMode {
    static POINT: string;
    static MULTI_POINT: string;
    static LINE: string;
    static POLYGON: string;
    static FREEHAND_POLYGON: string;
    static POLYLINE: string;
    static FREEHAND_POLYLINE: string;
    static RECTANGLE: string;
    static TRIANGLE: string;
    static CIRCLE: string;
    static ELLIPSE: string;
    static ARROW: string;
    static LEFT_ARROW: string;
    static RIGHT_ARROW: string;
    static UP_ARROW: string;
    static DOWN_ARROW: string;
    static EXTENT: string;
}

}
declare module "geocortex/infrastructure/tools/MapTool" {
import { ToolBase } from "geocortex/infrastructure/tools/ToolBase";
import { MapToolConfig } from "geocortex/infrastructure/tools/MapToolConfig";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
export interface MouseHoverCoordinates {
    clientX: number;
    clientY: number;
}
export class MapTool extends ToolBase implements MapToolConfig {
    /**
     * The Esri drawing surface.
     */
    _drawObject: esri.toolbars.Draw;
    /**
     * The activate state of the Esri drawing surface.
     * The Esri drawing surface does not provide an indication of whether it is active or not. We'll keep
     * track of this state ourselves so that we don't call deactivate unnecessarily.
     */
    _drawIsActive: boolean;
    /**
     * The command name associated with this tool.
     * @type {string}
     */
    command: string;
    /**
     * The draw mode of this tool.
     */
    drawMode: string;
    /**
     * Whether this tool is sticky.
     * @type {boolean}
     */
    isSticky: boolean;
    /**
     * @private: Handler Tokens
     */
    private _drawEndHandlerToken;
    protected _inputMethodChangeHandle: dojo.RemovableHandle;
    /**
     * @private: Handle to map hover for auto panning.
     */
    private _mapMouseHoverToken;
    /**
     * @private: Handle to map right-click to auto-deactivate the tool.
     */
    private _mapMouseDownToken;
    /**
     * @private: Pixel area from edge of map to trigger auto pan.
     */
    private _autoPanPixelTolerance;
    /**
     * @private: Percentage of map to pan when triggering auto pan.
     */
    private _autoPanStep;
    /**
     * @private: Draw modes which don't support auto panning.
     */
    private _unsupportedAutoPanDrawModes;
    /**
     * @private: Whether the tool's draw end handler is suspended (see GVH-4732)
     */
    private _drawEndSuspended;
    /**
     * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.tools.MapTool} class.
     * @class
     * <p>MapTool provides a general purpose, loosely coupled model for creating components that require map interaction.</p>
     * @constructs
     * @memberOf geocortex.essentialsHtmlViewer.mapping.infrastructure.tools
     * @param app The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this tool belongs to.
     * @param mixin An object to provide additional configuration of this tool.
     */
    constructor(app: ViewerApplication, mixin: MapToolConfig);
    private _createDrawObject();
    private _activateToolbar();
    /**
     * Deactivates the drawing surface
     * @private
     */
    private _deactivateToolbar();
    /**
     * Called when the tool is activated.
     */
    onActivated(): boolean;
    /**
     * Called when the tool is deactivated.
     */
    onDeactivated(): void;
    /**
     * Called when drawing completes.
     */
    onDrawEnd(geometry: esri.geometry.Geometry): void;
    /**
     * Called when the input method (e.g. keyboard, mouse) for the drawing component has changed.
     */
    onInputMethodChange(result: {
        previousMethod: string;
        newMethod: string;
    }): void;
    onMapMouseDown(evt: MouseEvent): void;
    onMapMouseHover(mouseHoverCoords: MouseHoverCoordinates): void;
}

}
declare module "geocortex/infrastructure/tools/MapToolConfig" {
import { ToolConfig } from "geocortex/infrastructure/tools/ToolConfig";
export interface MapToolConfig extends ToolConfig {
    /**
     * The command to execute after completing the tool.
     */
    command: string;
    /**
     * The mode for drawing on the map.
     */
    drawMode: string;
    /**
     * Whether the tool is sticky.  Defaults to false.
     */
    isSticky?: boolean;
}

}
declare module "geocortex/infrastructure/tools/ToolBase" {
import { ToolConfig } from "geocortex/infrastructure/tools/ToolConfig";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { Observable } from "geocortex/framework/observables";
export class ToolBase implements ToolConfig {
    /**
     * The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this tool instance belongs to.
     */
    app: ViewerApplication;
    /**
     * The name of this tool.
     * @type {string}
     */
    name: string;
    /**
     * Whether this tool is active.
     * @type {boolean}
     */
    isActive: boolean;
    /**
     * Status text to display while the tool is active.  Can be i18ned.
     */
    statusText: string;
    /**
     * Optional, alternate status text to display for keyboard users.  Can be i18ned.
     */
    keyboardStatusText: string;
    /**
     * Library to look up i18n string keys from.  Required to display i18n strings.
     */
    libraryId: string;
    /**
     * Optional URI of the icon to display with the status.
     */
    iconUri: string;
    /**
     * Optional title for the close tool UI element.  Defaults to "Deactivate Tool".
     */
    closeTitle: string;
    /**
     * Optional CSS class for the status displayed for this tool.
     */
    statusClass: string;
    /**
     * Whether the tool is enabled (can be used).  The tool will be assumed to not support disabling
     * if left undefined.
     */
    enabled: Observable<boolean>;
    /**
     * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.tools.ToolBase} class.
     * @class
     * <p>ToolBase provides a general purpose, loosely coupled model for creating components that have tool-like behavior.</p>
     * @constructs
     * @memberOf geocortex.essentialsHtmlViewer.mapping.infrastructure.tools
     * @param app The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this tool belongs to.
     * @param mixin An object to provide additional configuration of this tool.
     */
    constructor(app: ViewerApplication, mixin: ToolConfig);
    /**
     * Sets the active state of the tool.
     * @param {boolean} active The desired active state of the tool.
     */
    setActive(active: boolean): void;
    /**
     * Called when the tool is activated.
     */
    onActivated(): void;
    /**
     * Called when the tool is deactivated.
     */
    onDeactivated(): void;
}

}
declare module "geocortex/infrastructure/tools/ToolConfig" {
export interface ToolConfig {
    /**
     * Optional type name for the tool being constructed.  The default is MapTool.
     */
    typeName?: string;
    /**
     * The command to execute after completing the tool.  Not all tools have a command.
     * The command may be associated with a tool type.
     */
    command?: string;
    /**
     * The name of the tool.
     */
    name: string;
    /**
     * Optional status text to display while the tool is active.  Can be i18ned.
     */
    statusText?: string;
    /**
     * Optional, alternate status text to display for keyboard users.  Can be i18ned.
     */
    keyboardStatusText?: string;
    /**
     * Library to look up i18n string keys from.  Required to display i18n strings.
     */
    libraryId?: string;
    /**
     * Optional URI of the icon to display with the status.
     */
    iconUri?: string;
    /**
     * Optional title for the close tool UI element.  Defaults to "Deactivate Tool".
     */
    closeTitle?: string;
    /**
     * Optional CSS class for the status displayed for this tool.
     */
    statusClass?: string;
}

}
declare module "geocortex/infrastructure/tools/ToolRegistry" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { ToolBase } from "geocortex/infrastructure/tools/ToolBase";
import { ToolConfig } from "geocortex/infrastructure/tools/ToolConfig";
export class ToolRegistry {
    /**
     * The {@link geocortex.framework.application.Application} that this tool registry belongs to.
     * @private
     */
    private app;
    /**
     * An object map of all referenced tools.
     */
    tools: {
        [name: string]: ToolBase;
    };
    /**
     * An object map of all event subscriptions for tools.
     * @private
     */
    private _subscriptions;
    /**
     * A map of commands and their associated commands.
     * @private
     */
    private _toolTypes;
    /**
     * Initializes a new instance of the {@link geocortex.essentialsHtmlViewer.mapping.infrastructure.tools.ToolRegistry} class.
     * @class
     * <p>ToolRegistry provides safe, loosely-coupled access to tools.</p>
     * <p>A ToolRegistry instance should always be used when referencing tools.</p>
     * @constructs
     * @memberOf geocortex.essentialsHtmlViewer.mapping.infrastructure.tools
     * @param app The {@link geocortex.essentialsHtmlViewer.ViewerApplication} that this tool registry belongs to.
     */
    constructor(app: ViewerApplication);
    /**
     * Registers the tool registry command implementations.
     * @private
     */
    private _registerCommands();
    protected _setActiveToolCanExecute(toolName: any): boolean;
    /**
     * Clears the active tool.
     */
    clearActiveTool(): void;
    /**
     * Gets the active tool.
     */
    getActiveTool(): ToolBase;
    /**
     * Sets the active tool.
     * @param {string} name The name of the tool to activate.
     */
    setActiveTool(name: string): void;
    /**
     * Fetches a tool by name.
     * @param {string} name The name of the tool to fetch.
     */
    tool(name: string): ToolBase;
    /**
     * Registers a tool. The tool must specify a name.
     * @param tool The tool to register.
     */
    register(tool: ToolBase): void;
    /**
     * Unregisters a tool.
     * @param tool The tool to unregister.
     */
    unregister(tool: ToolBase): void;
    /**
     * Unregisters all tools in the registry.
     */
    clear(): void;
    /**
     * Creates and optionally registers the tools specified by a configuration block. Only named tools will be registered.
     * @param config An array of tool configuration objects.
     * @param {boolean} registerTools A flag indicating whether to register the tool with the registry.
     * @return An array of tool objects.
     */
    createTools(config: ToolConfig[], registerTools: boolean): ToolBase[];
    /**
     * Associates a command with a tool type, allowing tool subtypes to be created and invoked for certain tool commands.
     * @param commandName The name of the command to associate with a tool subtype.
     * @param toolTypeName The name of the tool type to associate with the command.
     */
    registerToolTypeForCommand(commandName: string, toolTypeName: string): void;
}

}
declare module "geocortex/infrastructure/undo/TransactionManager" {
import { UndoTransaction } from "geocortex/infrastructure/undo/UndoTransaction";
/**
 * The {@link TransactionManager} interface defines methods to manage undo transactions.
 */
export interface TransactionManager {
    /** Commits the provided transaction. */
    commitTransaction(transaction: UndoTransaction): Promise<void>;
    /** Rolls back the provided transaction. */
    rollbackTransaction(transaction: UndoTransaction): Promise<void>;
}

}
declare module "geocortex/infrastructure/undo/TransactionStatus" {
/** Indicates the status of the {@link UndoTransaction} */
export module TransactionStatus {
    var PENDING: string;
    var COMMITTING: string;
    var COMMITTED: string;
    var ABORTING: string;
    var ABORTED: string;
}

}
declare module "geocortex/infrastructure/undo/Undoable" {
import { UndoTransaction } from "geocortex/infrastructure/undo/UndoTransaction";
/**
 * A function signature for asynchronous undo redo operations that return a promise.
 * @docs-hide-from-nav
 */
export interface UndoRedoDelegate {
    (state?: any, transaction?: UndoTransaction): Promise<void>;
}
/**
 * The {@link Undoable} interface defines operations that can be added to the {@link UndoManager}. Implement this interface to create custom operations.
 */
export interface Undoable {
    state?: any;
    /** Re-performs the last undo operation. */
    performRedo: UndoRedoDelegate;
    /** Reverses the operation. */
    performUndo: UndoRedoDelegate;
}

}
declare module "geocortex/infrastructure/undo/UndoManager" {
import { TransactionManager } from "geocortex/infrastructure/undo/TransactionManager";
import { Application } from "geocortex/framework/application/Application";
import { UndoTransaction } from "geocortex/infrastructure/undo/UndoTransaction";
import { Undoable } from "geocortex/infrastructure/undo/Undoable";
import { UndoManagerState } from "geocortex/infrastructure/undo/UndoManagerState";
/** Indicates the status of the {@link UndoManager} */
export module Status {
    /** The {@link UndoManager} is idle. */
    var IDLE: string;
    /** The {@link UndoManager} is undoing. */
    var UNDOING: string;
    /** The {@link UndoManager} is redoing. */
    var REDOING: string;
    /** The {@link UndoManager} is committing an open transaction. */
    var COMMITTING: string;
    /** The {@link UndoManager} is rolling back an open transaction. */
    var ROLLINGBACK: string;
}
export interface UndoManagerOptions {
    /** The maximum number of operations the {@link UndoManager} can perform. If a number less than or equal to zero is provided the number of operations is unlimited. */
    maxOperations?: number;
}
/**
 * The UndoManager is a utility object that allows you to easily build applications with undo/redo functionality.
 * Use the UndoManager to add actions (edits, navigation changes, graphics drawing) to the stack. The API includes
 * a set of edit operations (add, delete, update, cut and union), created by inheriting from the {@link Undoable} class.
 * You can inherit from the {@link Undoable} class to create custom operations that take advantage of undo/redo.
 */
export class UndoManager implements TransactionManager {
    /** The {@link framework.application.Application} that this undo manager instance belongs to. */
    app: Application;
    /** The maximum number of operations the {@link UndoManager} can perform. If a number less than or equal to zero is provided the number of operations is unlimited. */
    maxOperations: number;
    /** Whether the recording of {@link Undoable} instances in the undo history has been suspended using the Suspend method. */
    isSuspended: boolean;
    /** Whether the {@link UndoManager} is undoing. */
    isUndoing: boolean;
    /** Whether the {@link UndoManager} is redoing. */
    isRedoing: boolean;
    /** When true, there are redo operations available on the stack. */
    canRedo: boolean;
    /** When true, there are undo operations available on the stack. */
    canUndo: boolean;
    /** The number of operations stored in the history stack. */
    length: number;
    /** The current operation position. */
    position: number;
    /** Returns the outermost current open transaction or null if there is currently no transaction open. */
    rootTransaction: UndoTransaction;
    protected _status: string;
    protected _historyStack: Undoable[];
    /**
     * Initializes a new instance of the {@link UndoManager} class.
     * @param app The {@link framework.application.Application} that this instance belongs to.
     * @param options Optional configuration settings for this instance.
     */
    constructor(app: Application, options?: UndoManagerOptions);
    registerCommands(): void;
    /** Suspends the recording of {@link Undoable} instances in the undo history. */
    suspend(): void;
    /** Resumes the recording of {@link Undoable} instances in the undo history. */
    resume(): void;
    /**
     * Sets the maximum number of operations the {@link UndoManager} can perform.
     * If a number less than or equal to zero is provided the number of operations is unlimited.
     * @param limit The operation limit
     */
    setMaxOperations(limit: number): void;
    /**
     * Returns an object with the following properties that describe the current state of the {@link UndoManager}: `historyStack`, `position`.
     */
    getCurrentState(): UndoManagerState;
    /**
     * Adds an undo operation to the stack and clears the redo stack.
     * The redo stack’s contents last as long as undo and redo are performed successively.
     * However, because applying a new change to an object invalidates the previous changes,
     * as soon as a new undo operation is registered, any existing redo stack is cleared.
     * This prevents redo from returning objects to an inappropriate prior state.
     * @param operation An operation to add to the stack.
     */
    add(operation: Undoable): void;
    /**
     * Moves the current position to the next undo operation and calls the operation's `performUndo` method.
     */
    undo(): Promise<void>;
    /**
     * Moves the current position to the next redo operation and calls the operation's `performRedo` method.
     */
    redo(): Promise<void>;
    /**
     * Gets the next undo operation from the stack.
     */
    peekUndo(): Undoable;
    /**
     * Gets the next redo operation from the stack.
     */
    peekRedo(): Undoable;
    /**
     * Clears the undo stack.
     */
    clearUndo(): void;
    /**
     * Clears the redo stack.
     */
    clearRedo(): void;
    /**
     * Gets the specified operation from the stack.
     * @param index The index of the operation to return.
     */
    getAt(index: number): Undoable;
    /**
     * Removes the specified operation from the stack.
     * If the index is not valid or out of bounds, then nothing happens.
     * @param index The index of the operation to remove.
     */
    removeAt(index: number): void;
    /**
     * Starts a transaction for recording undo operations. Undo operations recorded while a {@link UndoTransaction} is open, are added
     * to the {@link UndoManager} only if the transaction is committed. A rollback will undo, then discard the changes which where registered
     * while the transaction was open.
     * @param name A short string describing the transaction.
     * @param parent The parent transaction (for nested transactions)
     */
    beginTransaction(name?: string, parent?: UndoTransaction): UndoTransaction;
    /**
     * Commits the provided transaction. Undo operations recorded while the {@link UndoTransaction} is open,
     * are added to the {@link UndoManager} only if the transaction is committed. Committing a transaction will
     * commit all transactions nested below it as well.
     * You cannot roll back a transaction once it has been committed.
     * @param transaction The transaction to commit.
     */
    commitTransaction(transaction?: UndoTransaction): Promise<void>;
    /**
     * Rolls back (aborts) a transaction from a pending state. A rollback will undo, then discard the changes which where registered
     * while the transaction was open. Rolling back a nested transaction will roll back its parent transaction as well.
     * A transaction can only be rolled back from a pending state (after `beginTransaction` has been called, but before `commitTransaction` is called).
     * @param transaction The transaction to roll back.
     */
    rollbackTransaction(transaction?: UndoTransaction): Promise<void>;
    /**
     * Destroys this instance. Sets the history stack to null and cleans up all references.
     */
    destroy(): void;
    /** Save changes into undo redo stack for top-level transactions. */
    protected _onTransactionCommitted(tx: UndoTransaction): void;
    /** Undo the transaction changes, then remove it from the parent. */
    protected _onTransactionAborted(tx: UndoTransaction): void;
    protected _checkAvailability(): void;
    protected _updateStatus(status: string): void;
}

}
declare module "geocortex/infrastructure/undo/UndoManagerState" {
import { Undoable } from "geocortex/infrastructure/undo/Undoable";
import { UndoTransaction } from "geocortex/infrastructure/undo/UndoTransaction";
export interface UndoManagerState {
    historyStack: Undoable[];
    position: number;
    rootTransaction: UndoTransaction;
    status: string;
}

}
declare module "geocortex/infrastructure/undo/UndoTransaction" {
import { Undoable } from "geocortex/infrastructure/undo/Undoable";
import { TransactionManager } from "geocortex/infrastructure/undo/TransactionManager";
/**
 * An {@link UndoTransaction} is used to group one or more undo operations into a single item in the undo/redo history.
 * Multiple undo operations can be added to a transaction's private stack. When a transaction is committed, the whole transaction
 * will be pushed to the top of the undo stack of the {@link UndoManager}. Rolling back a transaction will invoke all contained
 * undo operations, but they won't be pushed to the undo history of the {@link UndoManager}.
 */
export class UndoTransaction implements Undoable {
    /** Details about the operation, for example: "Update" may be the display name for an edit operation that updates features. */
    displayName: string;
    /** The {@link TransactionManager} for this transaction. */
    owner: TransactionManager;
    /** The parent transaction containing this instance. The value will be null for top-level transactions. */
    parentTransaction: UndoTransaction;
    /** The status of this transaction (e.g. None, Committed, Aborted) */
    transactionStatus: string;
    /** The list of changes collected during a transaction. The changes are stored in order of occurrence. You should not modify this list. */
    changes: Undoable[];
    /** User state object */
    state: any;
    constructor(owner: TransactionManager, name?: string, state?: any);
    /** Whether this is a top-level transaction. Top-level transactions have no parent and thus are not nested. */
    isTopLevel(): boolean;
    /** Whether we can add more undo operations to the list of changes for this transaction. */
    isComplete(): boolean;
    /** Whether this transaction was aborted (rolled back) */
    isAborted(): boolean;
    /** Whether this transaction was committed. */
    isCommitted(): boolean;
    /**
     * Records an undo operation as part of this transaction. Transactions are undone (or redone) as a single atomic operation.
     * @param undoable The undo operation to record within this transaction.
     */
    add(name: string, undoable: Undoable, state?: any): void;
    protected _wrapInTransaction(name: string, undoable: Undoable, state?: any): UndoTransaction;
    /** Returns a boolean value indicating whether any undo operations have been recorded for this transaction. */
    hasChanges(): boolean;
    /** Commits the undo operation of this {@link UndoTransaction} */
    commit(): Promise<void>;
    /** Rolls back (aborts) the transaction and calls the undo operations to recover the state before the {@link UndoTransaction} was created. */
    rollback(): Promise<void>;
    /** Invokes the `performUndo` method for all contained {@link Undoable}s in the reverse of the order in which they were added. */
    performUndo(state?: any, transaction?: UndoTransaction): Promise<void>;
    /** Invokes the `performRedo` method for all contained {@link Undoable}s in the order in which they were added. */
    performRedo(state?: any, transaction?: UndoTransaction): Promise<void>;
}

}
declare module "geocortex/infrastructure/validation/NumberValidator" {
import { Validator, ValidationResult } from "geocortex/infrastructure/validation/Validator";
/**
 * Validates that a value is a number. The context may specify a flag "invalidNumbersAsNaN", in which
 * case values that aren't numbers will be converted to NaN instead of being rejected.
 */
export class NumberValidator implements Validator<number> {
    validate(value: number, context?: any): Promise<ValidationResult<number>>;
}

}
declare module "geocortex/infrastructure/validation/ServiceDiscoveryUrlValidator" {
import { Validator, ValidationResult } from "geocortex/infrastructure/validation/Validator";
import { SiteUrlValidator } from "geocortex/infrastructure/validation/SiteUrlValidator";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { ServiceDiscoveryProvider } from "geocortex/essentials/serviceDiscovery/ServiceDiscoveryProvider";
/**
 * A validator that determines whether the input is a URL that is allowed by the Service Discovery whitelist as defined by the administrator.
 * It extends {@link SiteUrlValidator} so site URL validation rules apply as well
 * (i.e. the URL either matches a service connection, the site endpoint or one of its services).
 */
export class ServiceDiscoveryUrlValidator extends SiteUrlValidator implements Validator<string> {
    app: ViewerApplication;
    /** Reference to the service discovery API */
    protected _serviceDiscovery: ServiceDiscoveryProvider;
    constructor(app: ViewerApplication, discoveryProvider?: ServiceDiscoveryProvider);
    getDiscoveryProvider(): ServiceDiscoveryProvider;
    setDiscoveryProvider(provider: ServiceDiscoveryProvider): void;
    validate(value: string, context?: any): Promise<ValidationResult<string>>;
    protected _validate(value: string, context?: any): Promise<ValidationResult<string>>;
    protected _initializeDiscoveryProvider(): Promise<void>;
}

}
declare module "geocortex/infrastructure/validation/SiteUrlValidator" {
import { Validator, ValidationResult } from "geocortex/infrastructure/validation/Validator";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
/**
 * A validator that determines whether the input is a URL that is defined by the Essentials site
 * (i.e. the URL either matches the site endpoint or one of its services).
 */
export class SiteUrlValidator implements Validator<string> {
    app: ViewerApplication;
    private _allowedUrls;
    constructor(app: ViewerApplication);
    executeClearTrustedUrls(): void;
    validate(value: string, context?: any): Promise<ValidationResult<string>>;
    tryValidateSynchronously(value: string): boolean;
    protected _isMatch(allowedUrl: Location, testUrl: Location): boolean;
    protected _initializeAllowedUrls(): Promise<void>;
    protected _allowUrl(url: string): void;
    protected _extractUrls(text: string): string[];
}

}
declare module "geocortex/infrastructure/validation/Validator" {
export interface ValidationResult<T> {
    /**
     * The result of validation. Generally the validated value will be the same as the input value, however
     * the validator is free to process the original value in some way. For example, an HTML validator may
     * accept an input string as valid HTML, but may strip out <script> tags.
     */
    validatedValue: T;
}
/**
 * An object that performs validation on a set of input values.
 */
export interface Validator<T> {
    /**
     * Determines whether a given value is valid.
     * @param value The input value to validate
     * @param context Arbitrary data that provides context for the validation. Some validators may
     *   change their behaviour based on the context.
     * @return A promise of a validation result. If the input is invalid, this will be a rejected promise.
     */
    validate(value: T, cotext?: any): Promise<ValidationResult<T>>;
}

}
declare module "geocortex/infrastructure/validation/XssHtmlValidator" {
import { Validator, ValidationResult } from "geocortex/infrastructure/validation/Validator";
import { ContentPolicy } from "geocortex/infrastructure/ContentPolicy";
import { SanitizeOptions, UriDetails } from "geocortex/infrastructure/FilterUtils";
/**
 * Validator which sanitizes HTML content to eliminate XSS (cross-site scripting) security risks.
 * This validator has some special functionality surrounding the handling of URIs as they are sanitized:
 *  - When the HTML is sanitized, we place all URIs into an array, replacing them in the HTML with replacement tokens.
 *  - The URIs are then run through the Content Policy instance, which asynchronously determines the fate of each URI. At this point, the user might be prompted about allowing dangerous URIs. The Content Policy overwrites the URIs in-place.
 *  - The manipulated URIs are then injected back into the sanitized HTML, and in the correct locations (token replacement).
 *  - The final sanitized HTML string is returned in the ValidationResult.
 */
export class XssHtmlValidator implements Validator<string> {
    /**
     * Overriding content policy for this validator.
     * Takes precedence over the content policy specified as context to validate().
     */
    protected _contentPolicy: ContentPolicy;
    protected _tokenLeft: string;
    protected _tokenRight: string;
    protected _tokenLeftEscaped: string;
    protected _tokenRightEscaped: string;
    /**
     * Construct an XSS HTML Validator.
     * @param options {@link XssHtmlValidatorOptions}
     */
    constructor(options?: XssHtmlValidatorConstructorOptions);
    /**
     * Sanitize a string of HTML to eliminate XSS risks.
     *  - Use FilterUtils to sanitize the HTML. Compile all URIs into an array, and replace them in the HTML with replacement tokens.
     *  - Pass URIs through the Content Policy (which rewrites them), and insert them back into the HTML (token replacement).
     *  - Return the sanitized HTML.
     * @param html The string HTML which needs to be sanitized.
     * @return String of sanitized HTML.
     */
    validate(html: string, context?: XssHtmlValidatorContext): Promise<ValidationResult<string>>;
    /**
     * Escape the HTML prior to the upcoming insertion of token replacements.
     */
    protected _escape(process: XssHtmlValidatorProcess): XssHtmlValidatorProcess;
    /**
     * Sanitize the HTML.
     * Compile all URIs into an array.
     * Replace all URIs in the HTML with replacement tokens.
     */
    protected _sanitize(process: XssHtmlValidatorProcess, sanitizeOptions?: SanitizeOptions): XssHtmlValidatorProcess;
    /**
     * Pass URIs through the Content Policy.
     */
    protected _runUrisThroughContentPolicy(process: XssHtmlValidatorProcess): Promise<XssHtmlValidatorProcess>;
    /**
     * Insert the rewritten URIs into the HTML (token replacement).
     */
    protected _applyUris(process: XssHtmlValidatorProcess): XssHtmlValidatorProcess;
    /**
     * Unescape data after replacing tokens.
     */
    protected _unescape(process: XssHtmlValidatorProcess): XssHtmlValidatorProcess;
    /**
     * Turn an index number into a replacement token.
     */
    protected _tokenize(index: number): string;
}
/**
 * State involved with performing an XSS HTML validation.
 */
export interface XssHtmlValidatorProcess {
    /** HTML being sanitized. */
    html: string;
    /** Collection of details about each URI. */
    uris: UriDetails[];
    /** Content policy that will be used. */
    contentPolicy: ContentPolicy;
}
/**
 * Filter context provided to the validate() method.
 */
export interface XssHtmlValidatorContext {
    sanitizeOptions?: SanitizeOptions;
    XssHtmlValidator?: {
        /** Content policy to be used if one hasn't been provided in the validator's constructor. */
        defaultContentPolicy?: ContentPolicy;
    };
}
/**
 * Options for the {@link XssHtmlValidator} constructor.
 */
export interface XssHtmlValidatorConstructorOptions {
    /** Content policy that is specific to this validator, overriding the content policy given as context to validate(). */
    contentPolicy?: ContentPolicy;
}

}
declare module "geocortex/infrastructure/visualization/VisualizationProviderBase" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { Observable } from "geocortex/framework/observables";
import { Layer } from "geocortex/essentials/Layer";
import { VisualizationProviderConfig } from "geocortex/infrastructure/visualization/VisualizationProviderConfig";
/**
 * Information about an individual visualization
 */
export interface VisualizationInfo {
    provider: VisualizationProviderBase;
    name: string;
    id: string;
}
/**
 * Base implementation of a {@link VisualizationProviderBase}.
 * Not implemented.
 */
export class VisualizationProviderBase {
    /**
     * The {@link geocortex.framework.application.Application} that this provider belongs to.
     */
    app: ViewerApplication;
    /**
     * The ID of the library that this provider belongs to.
     */
    libraryId: string;
    /**
     * The ID of the view handling the visualization options for this provider.
     */
    viewId: string;
    /**
     * The display name for this provider.
     */
    displayName: string;
    /**
     * The information about the visualizations provided by this provider in the visualization options.
     */
    visualizations: VisualizationInfo[];
    /**
     * The currently enabled visualization for this provider, if any
     */
    enabledVisualization: VisualizationInfo;
    /**
     * The current geocortex layer this provider is providing visualization options for.
     */
    currentLayer: Observable<Layer>;
    /**
     * Whether or not this provider is enabled for the current layer.
     */
    isEnabled: Observable<boolean>;
    /**
     * Whether or not this provider is supported for the current layer.
     */
    isSupported: Observable<boolean>;
    constructor(app: ViewerApplication, libraryId: string);
    /**
     * Initialize the provider.
     * @param config The configuration object.
     */
    initialize(config: VisualizationProviderConfig): void;
    /**
     * Whether or not the given layer supports this visualization provider.
     * @param gcxLayer The layer to check if it supports this visualization.
     */
    canSupport(gcxLayer: Layer): boolean;
    /**
     * Handles updating the provider settings for the layer being set. This involves
     * setting whether this visualization is enabled and supported for the given layer.
     * @param gcxLayer The current layer.
     */
    handleCurrentLayerChanged(gcxLayer: Layer): void;
    /**
     * Handles how to activate the visualization for the current layer.
     */
    handleActivate(visualization?: VisualizationInfo): void;
    /**
     * Handles how to apply the visualization settings for the current layer.
     */
    handleApply(): void;
}

}
declare module "geocortex/infrastructure/visualization/VisualizationProviderConfig" {
/**
 * Configuration for the {@link VisualizationProviderBase}.
 */
export interface VisualizationProviderConfig {
    /**
      * The type of the visualization provider.
      */
    type: string;
    /**
     * The ID of the library that this provider belongs to.
     */
    libraryId?: string;
    /**
     * The ID of the view handling the visualization options for this provider.
     */
    viewId?: string;
    /**
     * The display name for this provider in the visualization options.
     */
    displayName?: string;
}

}
declare module "geocortex/infrastructure/webMap/BaseMap" {
import { BaseMapLayer } from "geocortex/infrastructure/webMap/BaseMapLayer";
/**
 * Defines the basemap for the map.
 *
 * Part of the Esri web map specification. See http://resources.arcgis.com/en/help/arcgis-web-map-json/.
 */
export interface BaseMap {
    /** An array of BaseMapLayer objects defining the basemaps used in the web map. */
    baseMapLayers: BaseMapLayer[];
    /** A string title for the basemap that can be used in a table of contents. */
    title: string;
}

}
declare module "geocortex/infrastructure/webMap/BaseMapLayer" {
import { ServiceLayer } from "geocortex/infrastructure/webMap/ServiceLayer";
/**
 * Constants for well-known basemap types.
 */
export module BaseMapType {
    const OPEN_STREET_MAP = "OpenStreetMap";
    const BING_AERIAL = "BingMapsAerial";
    const BING_ROAD = "BingMapsRoad";
    const BING_HYBRID = "BingMapsHybrid";
    const WEB_TILED = "WebTiledLayer";
}
/**
 * A layer within a basemap.
 *
 * Part of the Esri web map specification. See http://resources.arcgis.com/en/help/arcgis-web-map-json/.
 */
export interface BaseMapLayer extends ServiceLayer {
    /**
     * A special string identifier used when the basemap is from Bing Maps or OpenStreetMap.
     * When this property is included, the url property is not required. One of the BaseMapType constants.
     */
    type?: string;
    /**
     * Determines whether the basemap layer appears on top of all operational layers (true) or beneath all operational layers (false).
     * Typically, this value is set to true on reference layers such as road networks, labels, or boundaries. The default value is false.
     */
    isReference?: boolean;
    /** Not defined in the official spec, but used by AGOL for web tiled layers. */
    templateUrl?: string;
}

}
declare module "geocortex/infrastructure/webMap/Bookmark" {
import { Extent } from "geocortex/infrastructure/webMap/Geometry";
/**
 * A saved geographic extent within a webmap.
 *
 * Part of the Esri web map specification. See http://resources.arcgis.com/en/help/arcgis-web-map-json/.
 */
export interface Bookmark {
    /** A string name for the bookmark. */
    name: string;
    /** An extent defining the rectangular area of the bookmark. */
    extent: Extent;
}

}
declare module "geocortex/infrastructure/webMap/CsvLayer" {
import { OperationalLayer } from "geocortex/infrastructure/webMap/OperationalLayer";
import { LocationInfo } from "geocortex/infrastructure/webMap/LocationInfo";
/**
 * A CSV web map layer.
 *
 * Part of the Esri web map specification. See http://resources.arcgis.com/en/help/arcgis-web-map-json/.
 */
export interface CsvLayer extends OperationalLayer {
    /**
     * A string defining the character used to separate columns in a CSV file. You can set this property
     * using any of the following: ",", " ", ";", "|", "\t". Used with CSV layers only.
     */
    columnDelimiter: string;
    /**
     * A LocationInfo object defining how location information will be retrieved from a CSV file. Used with CSV layers only.
     */
    locationInfo: LocationInfo;
}

}
declare module "geocortex/infrastructure/webMap/Domain" {
export module DomainType {
    const INHERITED = "inherited";
    const RANGE = "range";
    const CODED_VALUE = "codedValue";
}
/**
 * A domain specifies the set of valid values for a field.
 *
 * Part of the Esri ArcGIS Server REST API (see http://resources.arcgis.com/en/help/rest/apiref/).
 */
export interface Domain {
    /** One of the DomainType constants. */
    type: string;
}
export interface InheritedDomain extends Domain {
}
/**
 * Range domain specifies a range of valid values for a field.
 */
export interface RangeDomain extends Domain {
    /** The name of the domain. */
    name: string;
    /** An array in the format [<minValue>, <maxValue>]. */
    range: number[];
}
/**
 * Coded value domain specifies an explicit set of valid values for a field. Each valid value is assigned a unique name.
 */
export interface CodedValueDomain extends Domain {
    /** The name of the domain. */
    name: string;
    /** The set of valid coded values. */
    codedValues: CodedValue[];
}
export interface CodedValue {
    /** The human-readable name for the coded value. */
    name: string;
    /** The unique code for the coded value. */
    code: any;
}

}
declare module "geocortex/infrastructure/webMap/DrawingInfo" {
import { Renderer } from "geocortex/infrastructure/webMap/Renderer";
/**
 * The drawingInfo object contains drawing information for a feature collection or a single layer in a map service. This object is used in LayerDefinition.
 *
 * Part of the Esri web map specification. See http://resources.arcgis.com/en/help/arcgis-web-map-json/.
 */
export interface DrawingInfo {
    /** A renderer object that provides the symbology for the layer. */
    renderer?: Renderer;
    /**
     * Indicates whether symbols should stay the same size in screen units as you zoom in.
     * A value of true means the symbols stay the same size in screen units regardless of the map scale.
     */
    fixedSymbols?: boolean;
}

}
declare module "geocortex/infrastructure/webMap/Feature" {
import { Geometry } from "geocortex/infrastructure/webMap/Geometry";
/**
 * A feature of the map.
 *
 * Part of the Esri ArcGIS Server REST API. See http://resources.arcgis.com/en/help/rest/apiref/.
 */
export interface Feature {
    /**
     * The feature attributes. It is a JSON object that contains a dictionary of name-value pairs.
     * The names are the feature field names. The values are the field values and they can be any of the
     * standard JSON types - string, number and boolean. Note that date values are encoded as numbers.
     * The number represents the number of milliseconds since epoch (January 1, 1970) in UTC.
     */
    attributes?: {
        [name: string]: any;
    };
    /** The feature geometry. */
    geometry?: Geometry;
}

}
declare module "geocortex/infrastructure/webMap/FeatureCollection" {
import { Layer } from "geocortex/infrastructure/webMap/Layer";
/**
 * Defines a layer of features whose geometry and attributes will be stored directly within the web map.
 *
 * Part of the Esri web map specification. See http://resources.arcgis.com/en/help/arcgis-web-map-json/.
 */
export interface FeatureCollection {
    /** An array of Layer objects defining all the styling, geometry, and attribute information for the features. */
    layers: Layer[];
    /**  Indicates if this layer should be shown in the legend in client applications. The default is true. */
    showLegend: boolean;
}

}
declare module "geocortex/infrastructure/webMap/FeatureSet" {
import { Feature } from "geocortex/infrastructure/webMap/Feature";
/**
 * Contains the geometry and attributes of features in a layer. This object is used with feature collections only. For more information, see Layer.
 *
 * Part of the Esri web map specification. See http://resources.arcgis.com/en/help/arcgis-web-map-json/.
 */
export interface FeatureSet {
    /** An array of Feature objects, each one containing geometry and a set of attributes. */
    features: Feature[];
    /** One of the GeometryType constants. */
    geometryType: string;
}

}
declare module "geocortex/infrastructure/webMap/Field" {
import { Domain } from "geocortex/infrastructure/webMap/Domain";
/**
 * Contains information about an attribute field. This field could come from a feature collection or a single layer in a map service. Used in layerDefinition.
 *
 * Part of the Esri web map specification. See http://resources.arcgis.com/en/help/arcgis-web-map-json/.
 */
export interface Field {
    /** The field alias (human-readable name). */
    alias: string;
    /** A domain object that provides the attribute domain information for the field, if a domain exists. */
    domain?: Domain;
    /** Whether this field is editable. */
    editable: boolean;
    /** A number defining how many characters are allowed in a string field. */
    length?: number;
    /** A string defining the field name. */
    name: string;
    /** Whether this field can have a null value. */
    nullable: boolean;
    /** One of the EsriFieldTypes constants defined in the Essentials API. */
    type: string;
}

}
declare module "geocortex/infrastructure/webMap/Geometry" {
import { SpatialReference } from "geocortex/infrastructure/webMap/SpatialReference";
/**
 * Geometry type constants used in ArcGIS REST API and web map specifications.
 */
export module GeometryType {
    const POINT = "esriGeometryPoint";
    const MULTIPOINT = "esriGeometryMultipoint";
    const POLYLINE = "esriGeometryPolyline";
    const POLYGON = "esriGeometryPolygon";
    const EXTENT = "esriGeometryEnvelope";
    /**
     * Converts from geometry type constants used in the esri JavaScript API to their web map equivalents.
     */
    function fromEsriGeometryType(type: string): string;
}
/**
 * A geometry as defined in the ArcGIS REST API and web map specifications.
 *
 * See http://resources.arcgis.com/en/help/rest/apiref/geometry.html.
 */
export interface Geometry {
    spatialReference?: SpatialReference;
}
export interface Point extends Geometry {
    x: number;
    y: number;
    z?: number;
    m?: number;
}
export interface MultiPoint extends Geometry {
    hasM?: boolean;
    hasZ?: boolean;
    points: number[][];
}
export interface Polyline extends Geometry {
    hasM?: boolean;
    hasZ?: boolean;
    paths: number[][][];
}
export interface Polygon extends Geometry {
    hasM?: boolean;
    hasZ?: boolean;
    rings: number[][][];
}
export interface Extent extends Geometry {
    xmin?: number;
    xmax?: number;
    ymin?: number;
    ymax?: number;
    zmin?: number;
    zmax?: number;
    mmin?: number;
    mmax?: number;
}

}
declare module "geocortex/infrastructure/webMap/Layer" {
import { FeatureSet } from "geocortex/infrastructure/webMap/FeatureSet";
import { LayerDefinition } from "geocortex/infrastructure/webMap/LayerDefinition";
import { PopupInfo } from "geocortex/infrastructure/webMap/PopupInfo";
/**
 * This object allows overrides on pop-up content and drawing behavior for individual layers of a web service.
 * When used with a feature collection, this object also contains geographic features and their attributes.
 *
 * Part of the Esri web map specification. See http://resources.arcgis.com/en/help/arcgis-web-map-json/.
 */
export interface Layer {
    /** A featureSet object containing the geometry and attributes of the features in the layer.Used with feature collections only. */
    featureSet?: FeatureSet;
    /** A number indicating the index position of the layer in the WMS or map service. */
    id?: number;
    /** An array of LayerDefinition objects defining the attribute schema and drawing information for the layer. */
    layerDefinition?: LayerDefinition;
    /**
     * A URL to a service that should be used for all queries against the layer. Used with hosted tiled map services on
     * ArcGIS Online when there is an associated feature service that allows for queries.
     */
    layerUrl?: string;
    /** A URL to a legend graphic for the layer.Used with WMS layers.The URL usually contains a GetLegendGraphic request. */
    legendUrl?: string;
    /** A unique name for the layer. Used with WMS layers, where it can sometimes be derived from the layer's index position. */
    name?: string;
    /** A user-friendly title for the layer that can be used in a table of contents. Used with WMS layers. */
    title?: string;
    /** A popupInfo object defining the pop-up window content for the layer. */
    popupInfo?: PopupInfo;
}

}
declare module "geocortex/infrastructure/webMap/LayerDefinition" {
import { DrawingInfo } from "geocortex/infrastructure/webMap/DrawingInfo";
import { Field } from "geocortex/infrastructure/webMap/Field";
import { Template } from "geocortex/infrastructure/webMap/Template";
import { Type } from "geocortex/infrastructure/webMap/Type";
/**
 * The LayerDefinition object defines the attribute schema and drawing information for a layer drawn using
 * client-side graphics. This could include a feature collection, a CSV file referenced through the web, or
 * a single layer in an ArcGIS map service. Also used for dynamic layers.
 *
 * Part of the Esri web map specification. See http://resources.arcgis.com/en/help/arcgis-web-map-json/.
 */
export interface LayerDefinition {
    /** An optional SQL-based definition expression that narrows down the data to be displayed in the layer. Used with ArcGIS Server map services. */
    definitionExpression?: string;
    /** The name of the field that best summarizes the feature. Values from this field are used by default as the titles for pop-up windows. */
    displayField?: string;
    /** A drawingInfo object containing drawing, labeling, and transparency information for the layer. */
    drawingInfo?: DrawingInfo;
    /** An array of Field objects containing information about the attribute fields for the feature collection or layer. */
    fields?: Field[];
    /** The type of geometry used in the layer definition. One of the GeometryType constants. */
    geometryType?: string;
    /** Indicates whether attachments should be loaded for the layer. */
    hasAttachments?: boolean;
    /**
     * A number representing the maximum scale at which the layer definition will be applied. The number is the scale's
     * denominator; thus, a value of 2400 represents a scale of 1/2,400. A value of 0 indicates that the layer definition
     * will be applied no matter how far you zoom in.
     */
    maxScale?: number;
    /**
     * A number representing the minimum scale at which the layer definition will be applied. The number is the scale's
     * denominator; thus, a value of 2400 represents a scale of 1/2,400.
     */
    minScale?: number;
    /**
     * A string containing a unique name for the layer that could be displayed in a legend.
     */
    name?: string;
    /**
     * Indicates the name of the object ID field in the dataset.
     */
    objectIdField?: string;
    /**
     * An array of template objects describing features that can be created in this layer.
     * Templates are used with map notes, other feature collections, and editable web-based CSV layers.
     * They are not used with ArcGIS feature services, which already have feature templates defined in the service.
     *
     * Templates are defined as a property of the layer definition when there are no types defined; otherwise, templates
     * are defined as properties of the types.
     */
    templates?: Template[];
    /** Indicates whether the layerDefinition applies to a "Feature Layer" or a "Table". */
    type?: string;
    /**
     * The name of the field holding the type ID for the features, if types exist for the dataset. Each available type has an ID,
     * and each feature's typeIdField can be read to determine the type for each feature.
     */
    typeIdField?: string;
    /**
     * An array of Type objects available for the dataset. This is used when the typeIdField is populated.
     *
     * Types contain information about the combinations of attributes that are allowed for features in the dataset. Each feature
     * in the dataset can have a type, indicated in its typeIdField.
     */
    types?: Type[];
    /** Not documented in spec, but supported by ArcGIS online. Used for dynamic layers. */
    source?: {
        type: string;
        mapLayerId?: number;
    };
}

}
declare module "geocortex/infrastructure/webMap/LocationInfo" {
/**
 * Defines how location information will be retrieved from a CSV file referenced through the web.
 *
 * Part of the Esri web map specification. See http://resources.arcgis.com/en/help/arcgis-web-map-json/.
 */
export interface LocationInfo {
    /** A string whose value is always "coordinates". */
    locationType: string;
    /** A string defining the field name that holds the latitude (Y) coordinate. */
    latitudeFieldName: string;
    /** A string defining the field name that holds the longitude (X) coordinate. */
    longitudeFieldName: string;
}

}
declare module "geocortex/infrastructure/webMap/OperationalLayer" {
import { ServiceLayer } from "geocortex/infrastructure/webMap/ServiceLayer";
import { FeatureCollection } from "geocortex/infrastructure/webMap/FeatureCollection";
import { LayerDefinition } from "geocortex/infrastructure/webMap/LayerDefinition";
import { Layer } from "geocortex/infrastructure/webMap/Layer";
import { PopupInfo } from "geocortex/infrastructure/webMap/PopupInfo";
export module OperationalLayerType {
    const CSV = "CSV";
    const WMS = "WMS";
    const KML = "KML";
    const WFS = "WFS";
    const STREAM = "STREAM";
}
/**
 * An operational layer in a web map.
 *
 * Part of the Esri web map specification. See http://resources.arcgis.com/en/help/arcgis-web-map-json/.
 */
export interface OperationalLayer extends ServiceLayer {
    /**
     * If the layer is referenced through a URL, but is not an ArcGIS web service, then this parameter can be supplied to denote the layer type.
     * One of the OperationalLayerType constants.
     */
    type?: string;
    /**
     * A comma-separated string listing which editing operations are allowed on an editable feature service.
     * Available operations include: Create | Delete | Query | Update | Editing.
     */
    capabilities?: string;
    /**
     * A featureCollection object defining a layer of features whose geometry and attributes will be stored directly within the web map.
     * This is only used when no url property is supplied.
     */
    featureCollection?: FeatureCollection;
    /**
     * Optional string containing the item ID of the service if it is registered on ArcGIS Online or your organization's portal.
     * The web map applies any styling and pop-up information contained in the saved item.
     */
    itemId?: string;
    /** A LayerDefinition object defining the attribute schema and drawing information for the layer. Used with CSV and feature layers. */
    layerDefinition?: LayerDefinition;
    /** An array of Layer objects, allowing overrides on pop-up content and drawing behavior for the individual layers of a map service. Used with map services. */
    layers?: Layer[];
    /**
     * A number representing the maximum scale at which the layer will be visible. The number is the scale's denominator; thus,
     * a value of 2400 represents a scale of 1/2,400. A value of 0 indicates that the layer will be visible no matter how far
     * you zoom in.
     */
    maxScale?: number;
    /**
     * A number representing the minimum scale at which the layer will be visible. The number is the scale's denominator; thus,
     * a value of 2400 represents a scale of 1/2,400.
     */
    minScale?: number;
    /**
     * Used with ArcGIS feature services and individual layers in ArcGIS map services, this property determines how the features
     * are retrieved from the server. This property is represented as 0, 1, or 2.
     *
     *   0—Snapshot mode. Immediately retrieves all features when the map is loaded.
     *   1—On-demand mode. Features within the current view extent are retrieved as the user navigates the map. This is the default and the most common way to use feature services in web maps.
     *   2—Selection-only mode. No features are initially retrieved. This mode is used when you have a map service and a feature service from the same parent URL that are working together in the same map, with the map service being used for display and the feature service used for editing.
     */
    mode?: number;
    /**
     * A PopupInfo object defining the content of pop-up windows when you click or query a feature.
     */
    popupInfo?: PopupInfo;
    /** A user-friendly title for the layer that can be used in a table of contents. If this is not included, then a title is derived from the service. */
    title: string;
    /**
     * An array of layers that should appear visible. Used with ArcGIS map services that are not tiled and WMS layers.
     * Will be an array of numbers for ArcGIS map services, and an array of strings for WMS.
     */
    visibleLayers?: any[];
}

}
declare module "geocortex/infrastructure/webMap/PopupInfo" {
/**
 * Defines the look and feel of pop-up windows when users click or query a feature.
 *
 * Part of the Esri web map specification. See http://resources.arcgis.com/en/help/arcgis-web-map-json/.
 */
export interface PopupInfo {
}

}
declare module "geocortex/infrastructure/webMap/Renderer" {
import { Symbol, SimpleFillSymbol, Color } from "geocortex/infrastructure/webMap/Symbol";
export module RendererType {
    const SIMPLE = "simple";
    const UNIQUE_VALUE = "uniqueValue";
    const CLASS_BREAKS = "classBreaks";
    const HEATMAP = "heatmap";
}
export module NormalizationType {
    const BY_FIELD = "esriNormalizeByField";
    const BY_LOG = "esriNormalizeByLog";
    const BY_PERCENT_OF_TOTAL = "esriNormalizeByPercentOfTotal";
}
export module ClassificationMethod {
    const NATURAL_BREAKS = "esriClassifyNaturalBreaks";
    const EQUAL_INTERVAL = "esriClassifyEqualInterval";
    const QUANTILE = "esriClassifyQuantile";
    const STANDARD_DEVIATION = "esriClassifyStandardDeviation";
    const GEOMETRICAL_INTERVAL = "esriClassifyGeometricalInterval";
}
/**
 * Defines how features are rendered on the map.
 *
 * Part of the Esri ArcGIS REST API (see http://resources.arcgis.com/en/help/rest/apiref/renderer.html).
 */
export interface Renderer {
    /** The type of renderer. One of the RendererType constants. */
    type: string;
}
/**
 * A renderer that uses one symbol only.
 *
 * Part of the Esri ArcGIS REST API (see http://resources.arcgis.com/en/help/rest/apiref/renderer.html).
 */
export interface SimpleRenderer extends Renderer {
    symbol: Symbol;
    label: string;
    description: string;
}
/**
 * A unique value renderer symbolizes groups of features that have matching field values.
 *
 * Part of the Esri ArcGIS REST API (see http://resources.arcgis.com/en/help/rest/apiref/renderer.html).
 */
export interface UniqueValueRenderer extends Renderer {
    field1: string;
    field2?: string;
    field3?: string;
    fieldDelimiter?: string;
    defaultSymbol?: Symbol;
    defaultLabel?: string;
    uniqueValueInfos: UniqueValueInfo[];
}
export interface UniqueValueInfo {
    value: any;
    label?: string;
    description?: string;
    symbol: Symbol;
}
/**
 * A class breaks renderer symbolizes each feature based on the value of some numeric field.
 *
 * Part of the Esri ArcGIS REST API (see http://resources.arcgis.com/en/help/rest/apiref/renderer.html).
 */
export interface ClassBreaksRenderer extends Renderer {
    field: string;
    /** One of the ClassificationMethod constants. */
    classificationMethod: string;
    /** One of the NormalizationType constants. */
    normalizationType?: string;
    /** Used when normalizationType is NormalizationType.BY_FIELD. */
    normalizationField?: string;
    /** Used when normalizationType is NormalizationType.BY_FIELD. */
    normalizationTotal?: number;
    defaultSymbol: Symbol;
    defaultLabel: string;
    /** Supported only for polygon features. */
    backgroundFillSymbol?: SimpleFillSymbol;
    minValue?: number;
    classBreakInfos: ClassBreakInfo[];
}
export interface ClassBreakInfo {
    classMinValue?: number;
    classMaxValue: number;
    label?: string;
    description?: string;
    symbol: Symbol;
}
export interface HeatmapRenderer extends Renderer {
    blurRadius: number;
    field?: string;
    maxPixelIntensity: number;
    minPixelIntensity: number;
    colorStops: ColorStop[];
}
export interface ColorStop {
    ratio: number;
    color: Color;
}

}
declare module "geocortex/infrastructure/webMap/ServiceLayer" {
/**
 * Base class for web map operational layers and basemap layers.
 *
 * Part of the Esri web map specification. See http://resources.arcgis.com/en/help/arcgis-web-map-json/.
 */
export interface ServiceLayer {
    /** A unique identifying string for the layer. */
    id: string;
    /** The URL to the layer. For well-known basemap types such as Bing Aerial, the URL should be empty. */
    url?: string;
    /** Determines whether the layer is initially visible in the web map. */
    visibility?: boolean;
    /** The degree of transparency applied to the layer on the client side, where 0 is full transparency and 1 is no transparency. */
    opacity?: number;
    /** Not in official spec, but present in some newer web maps. */
    layerType?: string;
}

}
declare module "geocortex/infrastructure/webMap/SpatialReference" {
/**
 * Spatial references are defined using a well-known ID (wkid) or well-known text (wkt).
 *
 * Part of the Esri ArcGIS REST API (see http://resources.arcgis.com/en/help/rest/apiref/geometry.html).
 */
export interface SpatialReference {
    wkid: number;
    wkt: string;
}

}
declare module "geocortex/infrastructure/webMap/Symbol" {
/**
 * A Color is an array of numbers specifying R,G,B, and A.
 * The Alpha value can be from 0 - 255.
 * Esri's API also often accepts CSS color strings in the form rbga(255,0,100,0.5) etc
 */
export type Color = number[];
export module SymbolType {
    const SIMPLE_MARKER = "esriSMS";
    const SIMPLE_LINE = "esriSLS";
    const SIMPLE_FILL = "esriSFS";
    const PICTURE_MARKER = "esriPMS";
    const PICTURE_FILL = "esriPFS";
    const TEXT = "esriTS";
}
export module SimpleMarkerStyle {
    const CIRCLE = "esriSMSCircle";
    const CROSS = "esriSMSCross";
    const DIAMOND = "esriSMSDiamond";
    const SQUARE = "esriSMSSquare";
    const X = "esriSMSX";
    const TRIANGLE = "esriSMSTriangle";
    const PATH = "esriSMSPath";
}
export module SimpleLineStyle {
    const DASH = "esriSLSDash";
    const DASH_DOT = "esriSLSDashDot";
    const DASH_DOT_DOT = "esriSLSDashDotDot";
    const DOT = "esriSLSDot";
    const NONE = "esriSLSNull";
    const SOLID = "esriSLSSolid";
}
export module SimpleFillStyle {
    const BACKWARD_DIAGONAL = "esriSFSBackwardDiagonal";
    const CROSS = "esriSFSCross";
    const DIAGONAL_CROSS = "esriSFSDiagonalCross";
    const FORWARD_DIAGONAL = "esriSFSForwardDiagonal";
    const HORIZONTAL = "esriSFSHorizontal";
    const NONE = "esriSFSNull";
    const SOLID = "esriSFSSolid";
    const VERTICAL = "esriSFSVertical";
}
export module VerticalAlignment {
    const BASELINE = "baseline";
    const TOP = "top";
    const MIDDLE = "middle";
    const BOTTOM = "bottom";
}
export module HorizontalAlignment {
    const LEFT = "left";
    const RIGHT = "right";
    const CENTER = "center";
    const JUSTIFY = "justify";
}
export module FontStyle {
    const ITALIC = "italic";
    const NORMAL = "normal";
    const OBLIQUE = "oblique";
}
export module FontWeight {
    const BOLD = "bold";
    const BOLDER = "bolder";
    const LIGHTER = "lighter";
    const NORMAL = "normal";
}
export module TextDecoration {
    const LINE_THROUGH = "line-through";
    const UNDERLINE = "underline";
    const NONE = "none";
}
/**
 * A symbol representing a feature on the map.
 *
 * Part of the Esri ArcGIS REST API (see http://resources.arcgis.com/en/help/rest/apiref/symbol.html).
 */
export interface Symbol {
    /** The type of symbol. One of the SymbolType constants. */
    type: string;
}
/**
 * Simple marker symbols can be used to symbolize point geometries.
 *
 * Part of the Esri ArcGIS REST API (see http://resources.arcgis.com/en/help/rest/apiref/symbol.html).
 */
export interface SimpleMarkerSymbol extends Symbol {
    /** One of the SimpleMarkerStyle constants. */
    style: string;
    color: Color;
    size: number;
    angle: number;
    path?: string;
    xoffset: number;
    yoffset: number;
    outline?: SimpleLineSymbol;
}
/**
 * Simple line symbols can be used to symbolize polyline geometries or outlines for polygon fills.
 *
 * Part of the Esri ArcGIS REST API (see http://resources.arcgis.com/en/help/rest/apiref/symbol.html).
 */
export interface SimpleLineSymbol extends Symbol {
    /** One of the SimpleLineStyle constants. */
    style: string;
    color: Color;
    width: number;
}
/**
 * Simple fill symbols can be used to symbolize polygon geometries.
 *
 * Part of the Esri ArcGIS REST API (see http://resources.arcgis.com/en/help/rest/apiref/symbol.html).
 */
export interface SimpleFillSymbol extends Symbol {
    /** One of the SimpleFillStyle constants. */
    style: string;
    color: Color;
    outline?: SimpleLineSymbol;
}
/**
 * Picture marker symbols can be used to symbolize point geometries.
 *
 * Part of the Esri ArcGIS REST API (see http://resources.arcgis.com/en/help/rest/apiref/symbol.html).
 */
export interface PictureMarkerSymbol extends Symbol {
    /** Relative URL for static layers and full URL for dynamic layers. Access relative URL using http://<mapservice-url>/<layerId1>/images/<imageUrl11> */
    url: string;
    /** Base64 encoded. */
    imageData: string;
    contentType: string;
    width: number;
    height: number;
    angle: number;
    xoffset: number;
    yoffset: number;
}
/**
 * Picture fill symbols can be used to symbolize polygon geometries.
 *
 * Part of the Esri ArcGIS REST API (see http://resources.arcgis.com/en/help/rest/apiref/symbol.html).
 */
export interface PictureFillSymbol extends Symbol {
    /** Relative URL for static layers and full URL for dynamic layers. Access relative URL using http://<mapservice-url>/<layerId1>/images/<imageUrl11> */
    url: string;
    /** Base64 encoded. */
    imageData: string;
    contentType: string;
    outline?: SimpleLineSymbol;
    width: number;
    height: number;
    angle: number;
    xoffset: number;
    yoffset: number;
    xscale: number;
    yscale: number;
}
/**
 * Text symbols are used to add text to a feature (labeling).
 *
 * Part of the Esri ArcGIS REST API (see http://resources.arcgis.com/en/help/rest/apiref/symbol.html).
 */
export interface TextSymbol extends Symbol {
    color: Color;
    backgroundColor: Color;
    borderLineSize: number;
    borderLineColor: Color;
    haloSize: number;
    haloColor: Color;
    /** One of the VerticalAlignment constants. */
    verticalAlignment: string;
    /** One of the HorizontalAlignment constants. */
    horizontalAlignment: string;
    rightToLeft: boolean;
    angle: number;
    xoffset: number;
    yoffset: number;
    kerning: boolean;
    font: {
        family: string;
        size: number;
        /** One of the FontStyle constants. */
        style: string;
        /** One of the FontWeight constants. */
        weight: string;
        /** One of the TextDecoration constants. */
        decoration: string;
    };
    /** Only applicable when specified as a client-side graphic. */
    text?: string;
}

}
declare module "geocortex/infrastructure/webMap/Template" {
import { Feature } from "geocortex/infrastructure/webMap/Feature";
/**
 * Templates describe features that can be created in a layer. Templates are used with
 * map notes, other feature collections, and editable web-based CSV layers. They are not
 * used with ArcGIS feature services, which already have feature templates defined in the service.
 *
 * Templates are defined as a property of the layer definition when there are no types defined;
 * otherwise, templates are defined as properties of the types.
 *
 * Part of the Esri web map specification. See http://resources.arcgis.com/en/help/arcgis-web-map-json/.
 */
export interface Template {
    /** A detailed description of the template. */
    description?: string;
    /** An optional string that can define a client-side drawing tool to be used with this feature. See the web map specification for more details. */
    drawingTool?: string;
    /** A string containing a user-friendly name for the template. This name could appear on a menu of feature choices displayed in the client editing environment. */
    name: string;
    /** A feature object representing a prototypical feature for the template. */
    prototype: Feature;
}

}
declare module "geocortex/infrastructure/webMap/Type" {
import { Domain } from "geocortex/infrastructure/webMap/Domain";
import { Template } from "geocortex/infrastructure/webMap/Template";
/**
 * Types contain information about the combinations of attributes allowed for features in the dataset.
 * Each feature in the dataset can have a type, indicated in its typeIdField, which is used in LayerDefinition.
 *
 * Part of the Esri web map specification. See http://resources.arcgis.com/en/help/arcgis-web-map-json/.
 */
export interface Type {
    /** A set of domain objects for each domain in the type. */
    domains: {
        [fieldName: string]: Domain;
    };
    /** A unique numerical ID for the type. */
    id: number;
    /** A string containing a user-friendly name for the type. This might be shown on a menu of feature types that editors can create in the collection. */
    name: string;
    /**
     * An array of template objects describing features that can be created in this layer. Templates are used with map notes,
     * other feature collections, and editable web-based CSV layers. They are not used with ArcGIS feature services, which
     * already have feature templates defined in the service.
     *
     * Templates are defined as a property of the layer definition when there are no types defined; otherwise, templates are
     * defined as properties of the types.
     *
     * You might have more than one template per type if the attributes of available features vary slightly. For example,
     * you might have a type named Copper pipe containing two templates: one whose DIAMETER property is 12 and another whose
     * DIAMETER property is 10.
     */
    templates: Template[];
}

}
declare module "geocortex/infrastructure/webMap/WebMap" {
import { OperationalLayer } from "geocortex/infrastructure/webMap/OperationalLayer";
import { BaseMap } from "geocortex/infrastructure/webMap/BaseMap";
import { Bookmark } from "geocortex/infrastructure/webMap/Bookmark";
/**
 * An Esri web map.
 *
 * Part of the Esri web map specification. See http://resources.arcgis.com/en/help/arcgis-web-map-json/.
 */
export interface WebMap {
    /**
     * The set of operational layers in the web map.
     * Layers are drawn based on the index position in the array; The first layer in the array is
     * the first layer drawn, the next layer in the array is drawn on top of it, and so on.
     */
    operationalLayers: OperationalLayer[];
    /**
     * The map's basemap layer(s).
     * Layers are drawn based on the index position in the array; The first layer in the array is
     * the first layer drawn, the next layer in the array is drawn on top of it, and so on.
     */
    baseMap: BaseMap;
    /**
     * Bookmarks that are saved with the map.
     */
    bookmarks?: Bookmark[];
    /** The web map specification version. At the time of this writing, this should be "1.7". */
    version: string;
    /**
     * An arbitrary collection of name/value pairs used to store application data.
     * Not part of the official web map specification, but used with AGOL.
     */
    applicationProperties?: {
        [name: string]: any;
    };
}

}
declare module "geocortex/infrastructure/webMap/WebMapConverter" {
import { Symbol, Color } from "geocortex/infrastructure/webMap/Symbol";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { MapService } from "geocortex/essentials/MapService";
import { ServiceLayer } from "geocortex/infrastructure/webMap/ServiceLayer";
import { Layer } from "geocortex/essentials/Layer";
import { Layer as WebMapLayer } from "geocortex/infrastructure/webMap/Layer";
import { FeatureSet } from "geocortex/infrastructure/FeatureSet";
import { FeatureSet as WebMapFeatureSet } from "geocortex/infrastructure/webMap/FeatureSet";
import { Feature } from "geocortex/infrastructure/Feature";
import { Feature as WebMapFeature } from "geocortex/infrastructure/webMap/Feature";
import { Geometry } from "geocortex/infrastructure/webMap/Geometry";
import { Renderer } from "geocortex/infrastructure/webMap/Renderer";
import { SpatialReference } from "geocortex/infrastructure/webMap/SpatialReference";
import { LayerDefinition } from "geocortex/infrastructure/webMap/LayerDefinition";
import { OperationalLayer } from "geocortex/infrastructure/webMap/OperationalLayer";
import { DrawingInfo } from "geocortex/infrastructure/webMap/DrawingInfo";
import { FeatureCollection } from "geocortex/infrastructure/webMap/FeatureCollection";
export const CONVERSION_TYPE_PROPERTY = "__conversionType";
/**
 * Constants for the layerType property of service layers. This field and its possible values
 * isn't officially documented by esri, however it's used in ArcGIS online web maps.
 */
export module LayerType {
    const StreamLayer = "StreamLayer";
    const FeatureLayer = "ArcGISFeatureLayer";
    const MapService = "ArcGISMapServiceLayer";
    const TiledMapService = "ArcGISTiledMapServiceLayer";
    const ImageService = "ArcGISImageServiceLayer";
    const BingAerial = "BingMapsAerial";
    const BingHybrid = "BingMapsHybrid";
    const BingRoad = "BingMapsRoad";
    const OpenStreetMap = "OpenStreetMap";
    const WebTiled = "WebTiledLayer";
    const KML = "KML";
    const WMS = "WMS";
    const WFS = "WFS";
}
/**
 * Constants for target types that are handled by WebMapConverter.
 */
export module ConversionType {
    const WEB_MAP_SERVICE_LAYER = "webMapServiceLayer";
    const WEB_MAP_LAYER = "webMapLayer";
    const WEB_MAP_FEATURE_SET = "webMapFeatureSet";
    const WEB_MAP_FEATURE = "webMapFeature";
    const WEB_MAP_GEOMETRY = "webMapGeometry";
    const WEB_MAP_SYMBOL = "webMapSymbol";
    const WEB_MAP_RENDERER = "webMapRenderer";
    const WEB_MAP_SPATIAL_REFERENCE = "webMapSpatialReference";
    const WEB_MAP_COLOR = "webMapColor";
    const WEB_MAP_DATA = "webMapData";
    const GCX_MAP_SERVICE = "gcxMapService";
    const GCX_LAYER = "gcxLayer";
    const GCX_FEATURE_SET = "gcxFeatureSet";
    const GCX_FEATURE = "gcxFeature";
    const ESRI_LAYER = "esriLayer";
    const ESRI_FEATURE_SET = "esriFeatureSet";
    const ESRI_GRAPHIC = "esriGraphic";
    const ESRI_GEOMETRY = "esriGeometry";
    const ESRI_SYMBOL = "esriSymbol";
    const ESRI_RENDERER = "esriRenderer";
    const ESRI_SPATIAL_REFERENCE = "esriSpatialReference";
    const ESRI_COLOR = "esriColor";
    const OBJECT = "object";
}
/**
 * Provides methods for converting between Geocortex/Esri API objects and their ArcGIS web map equivalents.
 *
 * Note that once an input object has been converted, any additional attempts to convert it again will always return
 * a reference to the same result object (this is a form of the Identity Map pattern). To reset this mapping, use clearCache().
 */
export class WebMapConverter {
    app: ViewerApplication;
    /**
     * Maps a result type to a cache of conversion results for that type. Each cache in turn maps input objects to result objects.
     * Note that it's possible for the same input object to convert to different result types, which is why the cache has this structure.
     */
    private _resultCache;
    /**
     * The next available unique ID to assign to a symbol object.
     */
    private _nextSymbolId;
    private _nestingLevel;
    private _hasReferences;
    private _converting;
    constructor(app: ViewerApplication);
    fromGcxMapService(mapService: MapService): ServiceLayer;
    fromGcxLayer(layer: Layer): WebMapLayer;
    fromGcxFeatureSet(featureSet: FeatureSet): WebMapFeatureSet;
    fromGcxFeature(feature: Feature): WebMapFeature;
    fromEsriLayer(layer: esri.layers.Layer): ServiceLayer;
    fromEsriFeatureSet(featureSet: esri.tasks.FeatureSet): WebMapFeatureSet;
    fromEsriGraphic(graphic: esri.Graphic): WebMapFeature;
    fromEsriGeometry(geometry: esri.geometry.Geometry): Geometry;
    fromEsriSymbol(symbol: esri.symbol.Symbol): Symbol;
    fromEsriRenderer(renderer: esri.renderer.Renderer): Renderer;
    fromEsriSpatialReference(spatialReference: esri.SpatialReference): SpatialReference;
    fromEsriColor(color: esri.Color): Color;
    /**
     * Converts an arbitrary object graph to a format that can be stored in a web map.
     */
    fromObject(object: any): any;
    toGcxMapService(serviceLayer: ServiceLayer): Promise<MapService>;
    toGcxLayer(layer: WebMapLayer, service: ServiceLayer): Promise<Layer>;
    toGcxFeatureSet(featureSet: WebMapFeatureSet): Promise<FeatureSet>;
    toGcxFeature(feature: WebMapFeature): Promise<Feature>;
    toEsriLayer(serviceLayer: ServiceLayer): Promise<esri.layers.Layer>;
    toEsriFeatureSet(featureSet: WebMapFeatureSet): Promise<esri.tasks.FeatureSet>;
    toEsriGraphic(feature: WebMapFeature): Promise<esri.Graphic>;
    toEsriGeometry(geometry: Geometry): esri.geometry.Geometry;
    toEsriSymbol(symbol: Symbol): esri.symbol.Symbol;
    toEsriRenderer(renderer: Renderer): esri.renderer.Renderer;
    toEsriSpatialReference(spatialReference: SpatialReference): esri.SpatialReference;
    toEsriColor(color: Color): esri.Color;
    /**
     * Converts serialized web map data back into the original API objects wherever possible. This only
     * works if the object graph was serialized using fromObject(). Note that prototype chains for object
     * types other than the specific Geocortex/Esri types handled by this class will NOT be preserved by
     * toObject(fromObject(someObject)).
     */
    toObject(data: any): Promise<any>;
    clearCache(): void;
    /**
     * A wrapper for conversion methods that implements the Identity Map behaviour.
     */
    protected _convert(source: any, destType: string, doConversion: (any) => any, args?: any[]): any;
    /**
     * Resolves references that were added by _convert() due to cycles in the conversion input.
     */
    private _resolveReferences(object);
    protected _getWebMapLayerDefinitionFromFeatureLayer(featureLayer: esri.layers.FeatureLayer): LayerDefinition;
    protected _getWebMapLayerDefinitionFromDynamicLayer(dynamicServiceLayer: esri.layers.ArcGISDynamicMapServiceLayer, layerId: number): LayerDefinition;
    /**
     * Applies a web map service layer configuration to an Essentials map service.
     */
    protected _applyWebMapServiceLayerToMapService(serviceLayer: ServiceLayer, mapService: MapService): Promise<void>;
    /**
     * Applies web map layer configuration to a map service's layers. Returns a boolean indicating whether the map service
     * will need to be refreshed as a result.
     */
    protected _applyWebMapLayersToGcxLayers(serviceLayer: OperationalLayer, mapService: MapService): Promise<boolean>;
    /**
     * Applies web map configuration to an Essentials layer. Returns a boolean indicating whether the map service
     * will need to be refreshed as a result.
     */
    protected _applyWebMapLayerToGcxLayer(layer: WebMapLayer, index: number, gcxLayer: Layer): Promise<boolean>;
    protected _applyDrawingInfo(drawingInfo: DrawingInfo, mapService: MapService): Promise<void>;
    protected _setGraphicsLayerRenderer(serviceLayer: esri.layers.GraphicsLayer, renderer: esri.renderer.Renderer): void;
    protected _findMatchingGcxMapService(serviceLayer: ServiceLayer): MapService;
    protected _findMatchingGcxLayer(layer: WebMapLayer | number | string, mapService: MapService): Layer;
    protected _findOrCreateMatchingGcxLayer(layer: WebMapLayer, mapService: MapService): Promise<Layer>;
    protected _findOrCreateMatchingGcxMapService(serviceLayer: ServiceLayer): Promise<MapService>;
    /**
     * Determines whether a new Essentials Layer object can be created for the given web map layer if
     * no existing layer matches.
     */
    protected _canCreateGcxLayer(layer: WebMapLayer, mapService: MapService): boolean;
    /**
     * Invoked when a new Essentials Layer object needs to be created from the given web map layer.
     */
    protected _createGcxLayer(layer: WebMapLayer, mapService: MapService): Promise<Layer>;
    /**
     * Determines whether a new Essentials MapService object can be created for the given web map service
     * layer if no existing map service matches.
     */
    protected _canCreateGcxMapService(serviceLayer: ServiceLayer): boolean;
    /**
     * Invoked when a new Essentials MapService object needs to be created from the given web map service layer.
     */
    protected _createGcxMapService(serviceLayer: ServiceLayer): Promise<MapService>;
    /** Gets the Essentials map service definition from a service layer for use with _createGcxMapService(). */
    protected _getMapServiceDefinition(serviceLayer: ServiceLayer): any;
    protected _isFeatureCollection(serviceLayer: ServiceLayer): boolean;
    protected _isKmlLayer(serviceLayer: ServiceLayer): boolean;
    protected _isGraphicsLayer(serviceLayer: ServiceLayer): boolean;
    protected _isLayerCatalogService(serviceLayer: ServiceLayer): boolean;
    /**
     * Adds a property to a converted object that identifies the type of the original source object.
     */
    protected _addSourceType(sourceType: string, object: any): any;
    /**
     * Get the value to use for the "layerType" property on a service layer. This property is not part of the
     * web map specification, but is used by AGOL.
     */
    private _getWebMapLayerType(layer);
    /**
     * Infers the type of an attribute from a given set of Graphic objects.
     */
    protected _inferAttributeType(graphics: esri.Graphic[], attributeName: string): string;
    /**
     * Sets a map service's visible layers based on the settings in a web map operational layer. Returns a
     * boolean indicating whether the service needs to be refreshed, i.e. whether any layer visibilities
     * have changed.
     */
    protected _setVisibleLayers(serviceLayer: OperationalLayer, mapService: MapService): boolean;
    protected _toGcxMapService(serviceLayer: ServiceLayer): Promise<MapService>;
    protected _toGcxLayer(layer: WebMapLayer, serviceLayer: ServiceLayer): Promise<Layer>;
    protected _toGcxFeatureSet(featureSet: WebMapFeatureSet): Promise<FeatureSet>;
    protected _toEsriLayer(serviceLayer: ServiceLayer): Promise<esri.layers.Layer>;
    protected _toEsriGraphicsLayer(serviceLayer: OperationalLayer): Promise<esri.layers.Layer>;
    protected _toEsriFeatureLayer(serviceLayer: OperationalLayer): Promise<esri.layers.Layer>;
    protected _toEsriFeatureSet(featureSet: WebMapFeatureSet): Promise<esri.tasks.FeatureSet>;
    protected _toGcxFeature(feature: WebMapFeature): Promise<Feature>;
    protected _toEsriGraphic(feature: WebMapFeature): Promise<esri.Graphic>;
    protected _toEsriGeometry(geometry: Geometry): esri.geometry.Geometry;
    protected _toEsriSymbol(symbol: Symbol): esri.symbol.Symbol;
    protected _toEsriRenderer(renderer: Renderer): esri.renderer.Renderer;
    protected _toEsriSpatialReference(spatialReference: SpatialReference): esri.SpatialReference;
    protected _toEsriColor(color: Color): esri.Color;
    protected _toObject(object: any): Promise<any>;
    protected _fromGcxMapService(mapService: MapService): ServiceLayer;
    protected _esriFeatureLayerToFeatureCollection(featureLayer: esri.layers.FeatureLayer): FeatureCollection;
    protected _fromGcxlayer(layer: Layer): WebMapLayer;
    protected _fromGcxFeatureSet(featureSet: FeatureSet): WebMapFeatureSet;
    protected _fromEsriLayer(layer: esri.layers.Layer): ServiceLayer;
    protected _fromEsriGraphicsLayer(layer: esri.layers.GraphicsLayer): ServiceLayer;
    protected _fromEsriFeatureLayer(layer: esri.layers.FeatureLayer): ServiceLayer;
    protected _fromEsriFeatureSet(featureSet: esri.tasks.FeatureSet): WebMapFeatureSet;
    protected _fromGcxFeature(feature: Feature): WebMapFeature;
    protected _fromEsriGraphic(graphic: esri.Graphic): WebMapFeature;
    protected _fromEsriGeometry(geometry: esri.geometry.Geometry): Geometry;
    protected _fromEsriSymbol(symbol: esri.symbol.Symbol): Symbol;
    protected _fromEsriRenderer(renderer: esri.renderer.Renderer): Renderer;
    protected _fromEsriSpatialReference(spatialReference: esri.SpatialReference): SpatialReference;
    protected _fromEsriColor(color: esri.Color): Color;
    protected _fromObject(object: any): any;
}

}
declare module "geocortex/infrastructure/webMap/WebMapFilter" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
/**
 * Provides a set of filters for use with {@link: ObjectFilter.filter} corresponding to web map interfaces.
 */
export class WebMapFilter {
    app: ViewerApplication;
    private _numberValidator;
    private _urlValidator;
    private _baseMap;
    private _baseMapLayer;
    private _bookmark;
    private _color;
    private _csvLayer;
    private _domain;
    private _inheritedDomain;
    private _rangeDomain;
    private _codedValueDomain;
    private _drawingInfo;
    private _feature;
    private _featureCollection;
    private _featureSet;
    private _field;
    private _geometry;
    private _point;
    private _multipoint;
    private _polyline;
    private _polygon;
    private _extent;
    private _layer;
    private _layerDefinition;
    private _locationInfo;
    private _operationalLayer;
    private _renderer;
    private _simpleRenderer;
    private _uniqueValueRenderer;
    private _classBreaksRenderer;
    private _heatmapRenderer;
    private _serviceLayer;
    private _spatialReference;
    private _symbol;
    private _simpleMarkerSymbol;
    private _simpleLineSymbol;
    private _simpleFillSymbol;
    private _pictureMarkerSymbol;
    private _pictureFillSymbol;
    private _textSymbol;
    private _template;
    private _type;
    private _webMap;
    private _wmsLayer;
    private _unknown;
    constructor(app: ViewerApplication);
    readonly baseMap: any;
    readonly baseMapLayer: any;
    readonly bookmark: any;
    readonly color: any;
    readonly csvLayer: any;
    readonly domain: any;
    readonly inheritedDomain: any;
    readonly rangeDomain: any;
    readonly codedValueDomain: any;
    readonly drawingInfo: any;
    readonly feature: any;
    readonly featureCollection: any;
    readonly featureSet: any;
    readonly field: any;
    readonly geometry: any;
    readonly point: any;
    readonly multiPoint: any;
    readonly polyline: any;
    readonly polygon: any;
    readonly extent: any;
    readonly layer: any;
    readonly layerDefinition: any;
    readonly locationInfo: any;
    readonly operationalLayer: any;
    readonly popupInfo: any;
    readonly renderer: any;
    readonly serviceLayer: any;
    readonly simpleRenderer: any;
    readonly uniqueValueRenderer: any;
    readonly classBreaksRenderer: any;
    readonly heatmapRenderer: any;
    protected readonly _serviceLayerCommon: any;
    readonly spatialReference: any;
    readonly symbol: any;
    readonly simpleMarkerSymbol: any;
    readonly simpleLineSymbol: any;
    readonly simpleFillSymbol: any;
    readonly pictureMarkerSymbol: any;
    readonly pictureFillSymbol: any;
    readonly textSymbol: any;
    readonly template: any;
    readonly type: any;
    readonly webMap: any;
    readonly wmsLayer: any;
    /**
     * A generic filter for objects whose schema is unknown.
     */
    object: any;
}

}
declare module "geocortex/infrastructure/webMap/WebMapManager" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { WebMapConverter } from "geocortex/infrastructure/webMap/WebMapConverter";
import { WebMapFilter } from "geocortex/infrastructure/webMap/WebMapFilter";
import { WebMap } from "geocortex/infrastructure/webMap/WebMap";
export class WebMapManager {
    app: ViewerApplication;
    convert: WebMapConverter;
    filter: WebMapFilter;
    constructor(app: ViewerApplication);
    /**
     * Exports the current state of the viewer to ArcGIS web map format.
     */
    create(): Promise<WebMap>;
}

}
declare module "geocortex/infrastructure/webMap/WmsLayer" {
import { OperationalLayer } from "geocortex/infrastructure/webMap/OperationalLayer";
import { Extent } from "geocortex/infrastructure/webMap/Geometry";
/**
 * A WMS web map layer.
 *
 * Part of the Esri web map specification. See http://resources.arcgis.com/en/help/arcgis-web-map-json/.
 */
export interface WmsLayer extends OperationalLayer {
    /** A string containing copyright and access information for a WMS layer. This is copied from the capabilities document exposed by the WMS. */
    copyright: string;
    /** The rectangular map extent that should be requested from the service, given in the format [[xmin, ymin],[xmax,ymax]]. */
    extent: Extent;
    /**
     * An optional string containing the image format to be requested from a WMS. The default is png,
     * and this property only needs to be specified if a different image format will be requested, such as jpg.
     */
    format: string;
    /** The URL of the WMS map. You should also supply the url property, which is the URL of the WMS capabilities document. */
    mapUrl: string;
    /** A number defining the maximum height, in pixels, that should be requested from the service. */
    maxHeight?: number;
    /** A number defining the maximum width, in pixels, that should be requested from the service. */
    maxWidth?: number;
    /** An array of numbers containing well-known IDs for spatial references supported by the service. */
    spatialReferences: [number];
    /** A string containing the version number of the service. */
    version: string;
}

}
declare module "geocortex/infrastructure/webSocket/Protocol" {
export interface IncomingMessage {
    type: string;
}
export interface IncomingErrorMessage extends IncomingMessage {
    message: string;
}
export interface IncomingEventMessage extends IncomingMessage {
    name: string;
    args: any[];
}
export interface OutgoingMessage {
    type: string;
}
export interface OutgoingCommandMessage extends OutgoingMessage {
    name: string;
    args: any[];
}

}
declare module "geocortex/infrastructure/webSocket/SendMessageOptions" {
/**
 * Optional arguments to WebSocketServer's sendMessage() method.
 */
export interface SendMessageOptions {
    /**
     * Whether to queue the message if it can't be send to the server immediately.
     * Defaults to true.
     */
    queue?: boolean;
    /**
     * The maximum number of milliseconds the message should be queued for, after which
     * it will not be sent to the server.  If left undefined/falsey it will not expire
     * based on time.  Has no effect unless ```queue``` is false.
     */
    maxAgeQueuedMillis?: number;
}

}
declare module "geocortex/infrastructure/webSocket/WebSocketCommand" {
import { Command } from "geocortex/framework/commands/Command";
import { WebSocketConnection } from "geocortex/infrastructure/webSocket/WebSocketConnection";
/**
 * Commands are sent to the server.  They can be executed but never registered for.
 */
export class WebSocketCommand {
    name: string;
    ws: WebSocketConnection;
    /**
     * Whether to queue the command if it cannot be sent to the server.
     */
    queue: any;
    /**
     * The maximum number of milliseconds the command should be queued for, after which
     * it will not be sent to the server.  If left undefined/falsey it will not expire
     * based on time.
     */
    maxAgeQueuedMillis: number;
    private _syncedCommands;
    constructor(name: string, ws: WebSocketConnection);
    execute(parameters: any[]): void;
    /**
     * Execute this WebSocketCommand when the given framework Command is executed.
     */
    sync(command: Command): void;
}
export class CommandRegistrationEntry {
    impl: Function;
    scope: any;
    constructor(impl: Function, scope: any);
}

}
declare module "geocortex/infrastructure/webSocket/WebSocketConnection" {
import { WebSocketCommand } from "geocortex/infrastructure/webSocket/WebSocketCommand";
import { SendMessageOptions } from "geocortex/infrastructure/webSocket/SendMessageOptions";
import { OutgoingMessage } from "geocortex/infrastructure/webSocket/Protocol";
import { Observable } from "geocortex/framework/observables";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
export class WebSocketConnection {
    app: ViewerApplication;
    /**
     * The minimum number of milliseconds between retry attempts.
     */
    reconnectionMin: number;
    /**
     * The maximum number of milliseconds between retry attempts.
     */
    reconnectionMax: number;
    /**
     * The growth rate between retry attempts.  The time to the next connection
     * attempt is the time to the previous reconnection attempt multiplied by the
     * growth factor.
     */
    reconnectionGrowthFactor: number;
    /**
     * The maximum number of messages to queue up to send to the server on reconnect.
     */
    maxMessageQueueLength: number;
    private _commands;
    private _connectionString;
    private _queuedMessages;
    private _reconnectionWait;
    private _ws;
    isConnected: Observable<boolean>;
    constructor(app: ViewerApplication);
    /**
     * Check whether the browser supports the web socket
     */
    static hasBrowserSupport(): boolean;
    /**
     * Connect to the given server.  This should only be called once.  Disconnecting and connecting
     * to another server is not supported because I don't see any use for it.
     */
    connect(connectionString: string): void;
    /**
     * Send a raw message to the server.  Not generally recommended.  Use command(name).execute() instead.
     * @param message The message object to send to the server.
     * @param options Options.  If not specified all values are default.  See the interface for more information.
     */
    sendMessage(message: OutgoingMessage, options?: SendMessageOptions): void;
    /**
     * Get a command object that can be used to send commands to the server.
     */
    command(name: string): WebSocketCommand;
    private _connectWebSocket();
    /**
     * Called when the connection is lost to start trying to reconnect.
     */
    private _reconnectWebSocket();
    private _onOpen(ev);
    private _onClose(ev);
    private _onError(ev);
    private _onMessage(ev);
    private _onEventMessage(msg);
    private _onErrorMessage(msg);
}

}
declare module "geocortex/infrastructure/offline/bundle/Bundle" {
import { RoutingRule } from "geocortex/infrastructure/offline/bundle/RoutingRule";
import { BundleResourceEntry } from "geocortex/infrastructure/offline/bundle/BundleResourceEntry";
/**
 * The Bundle contains the RoutingRules and some resources for an offline
 * profile.
 */
export interface Bundle {
    /**
     * The ID of the bundle.
     */
    id: string;
    /**
     * Local time that the bundle was generated.
     */
    timestamp: number;
    /**
     * Routing rules that redirect requests to resources in this bundle.
     */
    routingRules: RoutingRule[];
    /**
     * The resources that make up this bundle.
     */
    resources: BundleResourceEntry[];
}

}
declare module "geocortex/infrastructure/offline/bundle/BundleBuilder" {
import { BundleBuilderContext } from "geocortex/infrastructure/offline/bundle/BundleBuilderContext";
import { Bundle } from "geocortex/infrastructure/offline/bundle/Bundle";
import { MapService } from "geocortex/essentials/MapService";
import { BundleResourceEntry } from "geocortex/infrastructure/offline/bundle/BundleResourceEntry";
/**
 * Builds an offline Bundle.
 * @return a promise of the Bundle.
 * @private
 */
export function buildBundle(context: BundleBuilderContext): Promise<Bundle>;
/**
 * Builds an OfflineResourceEntry for an object.
 */
export function buildJsonEntry(key: string, value: Object, encode?: boolean): BundleResourceEntry;
export function cleanUpMapServiceUrl(context: BundleBuilderContext, mapService: MapService): string;
export function cleanUpRestUrl(context: BundleBuilderContext, url: string): string;
/**
 * Turns a well-formed URL into a regex pattern, which could also be a key for a resource.
 */
export function urlToPattern(url: string): string;

}
declare module "geocortex/infrastructure/offline/bundle/BundleBuilderContext" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { SyncInfo } from "geocortex/infrastructure/offline/SyncInfo";
import { Progress } from "geocortex/infrastructure/offline/Progress";
/**
 * Context passed in to the BundleBuilder.
 */
export interface BundleBuilderContext {
    /**
     * The application.
     */
    app: ViewerApplication;
    /**
     * The ID that will be given to the bundle being generated.
     */
    bundleId: string;
    /**
     * Mapping of requests URL to how to fetch it locally.
     */
    basemaps: BundleBuilderContextBasemap[];
    /**
     * Information about the data synced to the device.
     */
    featureLayerSyncInfo: SyncInfo;
    /**
     * Progress callback.
     */
    progress?: (progress: Progress) => void;
}
/**
 * Configured mapping of basemap map service URL to
 * local map service path (partial URL without host).
 */
export interface BundleBuilderContextBasemap {
    url: string;
    localServicePath: string;
}

}
declare module "geocortex/infrastructure/offline/bundle/BundleManager" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { BundleBuilderContextBasemap } from "geocortex/infrastructure/offline/bundle/BundleBuilderContext";
import { Principal } from "geocortex/essentials/Principal";
import { Progress } from "geocortex/infrastructure/offline/Progress";
/**
 * Builds a bundle of rules on what to do while an offline map is active and applies
 * them to outgoing network traffic.
 */
export class BundleManager {
    app: ViewerApplication;
    libraryId: string;
    private _activeBundle;
    private _router;
    private _esriRequestHacker;
    private _esriLayerHacker;
    private _serveResourceHandler;
    constructor(app: ViewerApplication, libraryId: string);
    /**
     * Download Offline Resources.
     * @param bundleId the ID that will be given to this bundle.
     * @param basemaps information on how to direct basemap requests.
     */
    createBundle(bundleId: string, basemaps: BundleBuilderContextBasemap[], progress?: (progress: Progress) => void): Promise<void>;
    /**
     * Delete all resources stored for the given bundle.
     * @param bundleId The ID of the existing bundle.
     */
    deleteBundle(bundleId: string): Promise<void>;
    /**
     * Update all resources stored for the given bundle.
     * @param bundleId The ID of the existing bundle.
     * @param basemaps information on how to direct basemap requests.
     */
    updateBundle(bundleId: string, basemaps: BundleBuilderContextBasemap[], progress?: (progress: Progress) => void): Promise<void>;
    /**
     * Make the bundle with the given ID the active bundle.  After the returned promise
     * resolves future offline routing and resources will come from the bundle.
     * @param bundleId
     */
    loadBundle(bundleId: string): Promise<void>;
    /**
     * Return to a default state with no active bundle available.
     * This should always be safe.
     */
    unloadBundle(): Promise<void>;
    /**
     * Updates the principal in the bundle and persists it.
     */
    updatePrincipal(bundleId: string, principal: Principal): Promise<any>;
    /**
     * Generate the bundle for this viewer.
     * @param bundleId the ID that will be given to this bundle.
     * @param basemaps information on how to direct basemap requests.
     */
    private _buildBundle(bundleId, basemaps, progress?);
    /**
     * Adds bundle resources to the offline store.  Does not activate it.
     * @param bundle The bundle to store.
     */
    private _storeBundle(bundle);
    /**
     * Get the bundle with the given ID from storage.  Does not make it active.
     * @param bundleId The ID of the bundle to retrieve.
     */
    private _getBundle(bundleId);
    /**
     * Get the storage key for the given bundle or bundle ID.
     * @param bundle
     */
    private _getBundleKey(bundle);
    getStoreResource(bundleId: string, key: string): Promise<any>;
    setStoreResource(bundleId: string, key: string, value: string): Promise<void>;
    /**
     * Get from the store in promise form.  This will hopefully be moved into Store in 3.0.
     * @param key
     */
    private _appStoreGetPromise(key);
    /**
     * Set to the store in promise form.  This will hopefully move into Store in 3.0.
     * @param key
     * @param value
     */
    private _appStoreSetPromise(key, value);
    /**
     * Remove from the store in promise form.  This will hopefully move into Store in 3.0.
     * @param key
     */
    private _appStoreRemovePromise(key);
    getResource(key: string): string;
}

}
declare module "geocortex/infrastructure/offline/bundle/BundleResourceEntry" {
/**
 * A resource that is stored and can be served while offline.  Typically these
 * are responses from REST endpoints served by the "ServeResource" routing rule.
 */
export class BundleResourceEntry {
    /**
     * Is the value base64 encoded.
     */
    isEncoded: boolean;
    /**
     * Is the value JSON.stringified.
     */
    isJson: boolean;
    /**
     * The key for the resource.  For the "ServeResource" routing rule this matches the
     * "key" parameter.
     */
    key: string;
    /**
     * The resource, possibly base64 encoded, possibly JSON.stringified.
     */
    value: string;
    constructor(mixin?: BundleResourceEntry);
}

}
declare module "geocortex/infrastructure/offline/bundle/EsriLayerHacker" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
/**
 * Applies dirty hacks to the Esri layers to make requests work offline.
 * This relies upon undocumented functionality and may break between releases.
 * (But rarely has!  Whew.)
 */
export class EsriLayerHacker {
    app: ViewerApplication;
    urlRewriter: (url: string) => string;
    /**
     * Callback for errors produced by invalid requests.
     */
    errorReporter: (error: string) => void;
    private _hooked_BingMaps_getTileUrl;
    private _hooked_esri_getTileUrl;
    private _hooked_esri_getImageUrl;
    private _hooked_ogc_getImageUrl;
    private _hooked_ogc_getWMTSTileUrl;
    private _hooked_WebTiledLayer_getTileUrl;
    private _bingMaps__tileLoadHandler;
    private _ogc__tileLoadHandler;
    private _webTiledLayer__tileLoadHandler;
    /**
     * Constructor.
     * @param urlRewriter The function that rewrites tile requests, or returns null to not rewrite it.
     *                    Can be set on the fly.
     */
    constructor(app: ViewerApplication, urlRewriter: (url: string) => string);
    private _captureHooks();
    /**
     * @private Extend ESRI layers for offline functionality
     */
    private _extendEsriLayers();
}

}
declare module "geocortex/infrastructure/offline/bundle/EsriRequestHacker" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { EsriRequest, EsriRequestOptions } from "geocortex/infrastructure/offline/bundle/RequestContext";
/**
 * Applies dirty hacks to esri.request to make requests work offline.
 * This may break between Esri API releases.
 */
export class EsriRequestHacker {
    app: ViewerApplication;
    requestHandler: (request: EsriRequest, options: EsriRequestOptions) => dojo.Deferred;
    private _hooked_esri_request;
    private _isEnabled;
    /**
     * Calls to esri.request will be redirected to the given requestHandler while enabled.
     * @param app
     * @param requestHandler
     */
    constructor(app: ViewerApplication, requestHandler: (request: EsriRequest, options: EsriRequestOptions) => dojo.Deferred);
    unhackedRequest(request: EsriRequest, options: EsriRequestOptions): dojo.Deferred;
    /**
     * Bypass the hack and allow traffic to flow through normally.
     */
    disable(): void;
    /**
     * Re-engage the hack.
     */
    enable(): void;
    /**
     * @private Hook into esri.request. This is for REST requests.
     */
    private _setupEsriRequestHooks();
}

}
declare module "geocortex/infrastructure/offline/bundle/OfflineRouter" {
import { Observable } from "geocortex/framework/observables";
import { OfflineHandler } from "geocortex/infrastructure/offline/bundle/offlineHandlers/OfflineHandler";
import { RoutingRule } from "geocortex/infrastructure/offline/bundle/RoutingRule";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { EsriRequest, EsriRequestOptions } from "geocortex/infrastructure/offline/bundle/RequestContext";
/**
 * Routes offline requests through request handlers.  This is done by hacking esri.request.
 * The "Rewrite" request handler is the only handler installed by default.
 */
export class OfflineRouter {
    app: ViewerApplication;
    isReady: Observable<boolean>;
    private _handlers;
    private _rules;
    private _defaultHandler;
    constructor(app: ViewerApplication);
    /**
     * Add a request handler.  The handler function will be called to handle requests
     * when a rule matching the given name has a pattern matching the request.
     * @param handlerName The name of the handler.  This matches the RoutingRule handlerName.
     * @param handler The handling function for the rule.
     */
    addHandler(handler: OfflineHandler): void;
    /**
     * Remove a request handler.
     * @param handlerName The name of the handler.
     * @return Whether a handler was found and removed.
     */
    removeHandler(handlerName: string): boolean;
    /**
     * Set the handler to use when no other handlers match.  The handler will be called with
     * rule and matches as null, as there is no rule that matched.
     * @param handler
     */
    setDefaultHandler(handler: OfflineHandler): void;
    /**
     * Set the rules that determine how (offline) requests are routed.
     * @param rules
     */
    setRoutingRules(rules: RoutingRule[]): void;
    /**
     * Set the rules that determine how (offline) requests are routed from a promise.
     * @param routingRulesJsonStringPromise
     */
    setRoutingRulesFromPromise(routingRulesJsonStringPromise: Promise<string>): void;
    /**
     * Remove all routing rules.
     */
    clearRoutingRules(): void;
    /**
     * Check the tile URL against any "Rewrite" rules in the offline manifest and return
     * the rewritten URL if there is a match.  Return null otherwise.
     * @param url The URL to rewrite.
     * @return The rewritten URL or null.
     */
    rewriteUrl(url: string): string;
    /**
     * Handles (routes) an offline request.
     */
    handle(request: EsriRequest, options: EsriRequestOptions): dojo.Deferred;
    _whenReady(callback: () => void): void;
    /**
     * Strips out possible proxy prefix from an offline request.
     */
    private _stripOutProxy(url);
}

}
declare module "geocortex/infrastructure/offline/bundle/RequestContext" {
/**
 * Not included in esri's d.ts file.
 */
export interface EsriRequest {
    callbackParamName: string;
    content?: any;
    form?: any;
    handleAs?: string;
    timeOut?: number;
    url: string;
}
/**
 * Not included in esri's d.ts file.
 */
export interface EsriRequestOptions {
    disableIdentityLookup?: boolean;
    usePost?: boolean;
    useProxy?: boolean;
}
export class RequestContext implements EsriRequest {
    dfd: dojo.Deferred;
    options: EsriRequestOptions;
    callbackParamName: string;
    content: any;
    form: any;
    handleAs: string;
    timeOut: number;
    url: string;
    constructor(mixin: EsriRequest, dfd: dojo.Deferred, options: EsriRequestOptions);
}

}
declare module "geocortex/infrastructure/offline/bundle/RoutingRule" {
/**
 * A rule for handling an offline request.  When this rule matches a request
 * it is passed to the OfflineHandler registered with the handlerName,
 * which then handles the request.  Multiple rules may match the same handler.
 */
export interface RoutingRule {
    /**
     * The name of the handler.  There can be (should be) many handlers with the same
     * name.  The difference in how they function is the parameters to this rule
     * and the matches captured from the pattern.
     */
    handlerName: string;
    /**
     * A pattern for when to attempt to apply the handler code to the rule.
     * The code may still refuse to handle the request so this is necessary
     * but not sufficient.
     */
    pattern: string;
    /**
     * A lookup for matching on the 'content' of a request - ie. request parameters.
     * The key is the name of the parameter, and the result is an object with a regex pattern for the match.
     */
    queryParameterPatterns?: {
        [name: string]: {
            pattern: string;
        };
    };
    /**
     * Parameters for this rule that dictate behaviour of the handler code.
     */
    parameters: {
        [key: string]: string;
    };
}

}
declare module "geocortex/infrastructure/offline/bundle/RoutingRulesBuilder" {
import { BundleBuilderContext } from "geocortex/infrastructure/offline/bundle/BundleBuilderContext";
import { RoutingRule } from "geocortex/infrastructure/offline/bundle/RoutingRule";
/**
 * Builds an array of routing rules in the bundle.
 * @return a dojo.Deferred<RoutingRule[]>
 */
export function buildRoutingRules(context: BundleBuilderContext): RoutingRule[];

}
declare module "geocortex/infrastructure/offline/bundle/WorkflowExtractor" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
/**
 * @private
 */
export class WorkflowExtractor {
    static getWorkflowEntries(app: ViewerApplication): string[];
    private static _getWorkflowEntriesForSite(site);
    private static _getWorkflowEntriesForModel(configModel);
    private static _extractFromMarkup(value);
    /**
     * Returns Html encoded quotes to their non-html forms
     * @param input the string to replace the quotes to non html quotes
     * @return String
     */
    private static decodeHtmlQuotes(input);
    /**
     * Returns Html encoded ampersands to their non-html forms
     * @param input the string to replace the ampersands to non html ampersands
     * @return String
     */
    private static decodeHtmlAmpersands(input);
    private static _parseCommandArgument(commandName, arg);
    private static _toDownloadableUrl(url);
}

}
declare module "geocortex/infrastructure/symbology/widgets/MarkupStyleWidget" {
import { ViewBase } from "geocortex/framework/ui/ViewBase";
/**
 * Interface of a widget for picking markup styles
 * @param displayName The display name of this widget
 * @param updateSymbol Update the symbol configured by this widget
 */
export interface MarkupStyleWidget extends ViewBase {
    displayName: string;
    updateSymbol: (symbol: esri.symbol.Symbol, update?: boolean) => Promise<boolean>;
    getSymbol: () => string;
}

}
declare module "geocortex/infrastructure/symbology/widgets/PictureSymbolWidget" {
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { MarkupStyleWidget } from "geocortex/infrastructure/symbology/widgets/MarkupStyleWidget";
import { SymbologyWidget } from "geocortex/infrastructure/symbology/widgets/SymbologyWidget";
import { PictureSymbolWidgetViewModel } from "geocortex/infrastructure/symbology/widgets/PictureSymbolWidgetViewModel";
/**
 * This symbology widget is unique in that it does double duty as a markup style view.
 * A wrapper could be created in the Markup module to implement this, but the changes required are very minimal.
 */
export class PictureSymbolWidget extends ViewBase implements MarkupStyleWidget, SymbologyWidget {
    app: ViewerApplication;
    viewModel: PictureSymbolWidgetViewModel;
    /** Text to bind to a selector */
    displayName: string;
    /** Attach a callback here to respond to symbology changes in real time */
    onChange: (style: string) => void;
    /** This view does double duty as a symbology and markup picker. We need to know whether or not it should change the current markup symbol */
    isMarkupView: boolean;
    /** Tokens for binding changes to symbology */
    private _imageSizeToken;
    private _imageRotationToken;
    /**
     * Attach the viewModel to this view
     * @param viewModelArgs
     */
    attach(viewModel: PictureSymbolWidgetViewModel): void;
    /**
     * Bind the size and rotation sliders
     */
    bindSymbolSettings(): void;
    /**
     * This widget attaches a reference to itself onto the parent view.
     */
    added(parentView?: PictureSymbolWidgetParentView): void;
    /**
     * On activation the current library is checked and loaded if needed
     */
    activated(): void;
    /**
     * Implementation of the MarkupStyleView interface
     * @param symbol
     */
    updateSymbol(symbol: esri.symbol.Symbol): Promise<boolean>;
    /**
     * Reset this widget to the default state
     */
    reset(): void;
    /**
     * Get the symbol currently configured by this widget as a JSON string
     */
    getSymbol(): string;
    /**
     * Set the state of this widget from the supplied symbol
     * @param symbol
     */
    setFromSymbol(symbol: esri.symbol.Symbol): void;
    /**
     * Get a renderer containing the symbol configured by this widget as a JSON string
     */
    getRenderer(): string;
    /**
     * Sets the state of the widget based on a supplied simple renderer
     * @param renderer
     */
    setFromRenderer(renderer: esri.renderer.Renderer): void;
    /**
     * Handles any change to the symbology produced by this widget
     */
    applySettings(): void;
    /**
     * Event handler for a click event on an image swatch
     * @param event
     */
    handleClickSwatch(event: Event): void;
    private _isSwatchVisible(el);
}
/**
 * The parent view of this widget can contain a reference to this widget.
 */
export interface PictureSymbolWidgetParentView extends ViewBase {
    pictureSymbologyWidget?: PictureSymbolWidget;
}

}
declare module "geocortex/infrastructure/symbology/widgets/PictureSymbolWidgetConfig" {
import { RangeConfiguration } from "geocortex/infrastructure/ui/components/NumericInput/RangeConfiguration";
/**
 * Configuration for the PictureSymbol widget
 * @param imageLibraries An array of image library names. These must be configured in Essentials.
 * @param imageSize Configuration for the image size slider
 * @param showSliders Show sliders on numeric inputs
 */
export interface PictureSymbolWidgetConfig {
    imageLibraries?: string[];
    imageSize?: RangeConfiguration;
    showSliders?: boolean;
}

}
declare module "geocortex/infrastructure/symbology/widgets/PictureSymbolWidgetViewModel" {
import { ViewModelBase } from "geocortex/framework/ui/ViewModelBase";
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { Observable, ObservableCollection } from "geocortex/framework/observables";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { NumericInputViewModel } from "geocortex/infrastructure/ui/components/NumericInput/NumericInputViewModel";
import { ImageTemplate } from "geocortex/infrastructure/symbology/MarkupTemplates";
import { PictureSymbolWidgetConfig } from "geocortex/infrastructure/symbology/widgets/PictureSymbolWidgetConfig";
export class PictureSymbolWidgetViewModel extends ViewModelBase {
    app: ViewerApplication;
    config: PictureSymbolWidgetConfig;
    viewRoot: HTMLElement;
    initialized: boolean;
    /** Current markup symbol */
    markupSymbol: esri.symbol.Symbol;
    /** Names of the image libraries to use */
    imageLibraries: ObservableCollection<string>;
    currentLibrary: Observable<string>;
    /** Flag for the error state of no valid libraries */
    noLibraries: Observable<boolean>;
    /** Collection of templates found in libraries */
    imageTemplates: {
        [id: string]: ImageTemplate[];
    };
    currentImages: ObservableCollection<ImageTemplate>;
    /** Flag to hide/show the picker to switch libraries */
    showLibrarySwitcher: Observable<boolean>;
    /** Stops multiple image loads from being started at the same time */
    loading: boolean;
    /** View model for the user-selected image size. */
    imageSize: Observable<number>;
    imageSizeViewModel: NumericInputViewModel;
    /** View model for the user-selected rotation */
    imageRotation: Observable<number>;
    imageRotationViewModel: NumericInputViewModel;
    /** Track these values separately as they will change with image size */
    imageHeight: Observable<number>;
    imageWidth: Observable<number>;
    /** A string used to create unique ids for the image swatches */
    imageSwatchIdBase: string;
    /** The currently selected image swatch */
    currentImage: Observable<ImageTemplate>;
    /** If this view makes up part of a symbology configuration view the parent can be attached here */
    parentSymbologyView: ViewBase;
    constructor(app: ViewerApplication, libraryId: string);
    initialize(configuration?: PictureSymbolWidgetConfig): void;
    loadAllLibraries(): Promise<any>;
    /**
     * Set the state of the widget from a supplied picturemarkersymbol.
     * If a symbol with an identical url already exists in the widget it will be selected.
     * If the symbol appears to be new, it will be added to the widget's collection and selected.
     * Private: Call the method on PictureSymbolWidget instead
     * @param symbol
     */
    _setFromSymbol(symbol: esri.symbol.PictureMarkerSymbol): Promise<any>;
    /**
     * Checks for a supplied symbol in loaded libraries, returns the template if found
     * A found template will also be selected
     * Private: Call 'setFromSymbol' on PictureSymbolWidget
     * @param symbol
     */
    _checkForSymbol(symbol: esri.symbol.PictureMarkerSymbol): ImageTemplate;
    /**
     * Handles the edge case of a symbol being sent in that does not exist in any library
     * This could happen when loading a project.
     * In this case the symbol will be inserted into the current library so it can be used.
     * @param symbol
     */
    private _addNewTemplateFromSymbol(symbol);
    /**
     * This will be updated to load images from an Essentials hosted library
     * Private: Don't call this directly
     */
    _loadImages(library: string): Promise<ImageTemplate[]>;
    _handleInvalidLibrary(library: string): void;
    /**
     * Returns a renderer based on the current widget settings as a JSON string
     * Private: Call 'getRenderer' on PictureSymbolWidget
     */
    _getRenderer(): string;
    /**
     * Reset the widget to the initial state
     * Private: Call 'reset' on PictureSymbolWidget
     */
    _reset(): void;
    /**
     * Creates a unique hash to represent the given symbol
     * @param symbol
     */
    private _getHashForSymbol(symbol);
    /**
     * Transforms an image template into a picturemarkersymbol according to the settings of the viewModel
     */
    private _imageTemplateToSymbol(template);
}

}
declare module "geocortex/infrastructure/symbology/widgets/SimpleSymbolWidget" {
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { SimpleSymbolWidgetViewModel } from "geocortex/infrastructure/symbology/widgets/SimpleSymbolWidgetViewModel";
import { SymbologyWidget } from "geocortex/infrastructure/symbology/widgets/SymbologyWidget";
/**
 * The simple symbology settings widget view.
 */
export class SimpleSymbolWidget extends ViewBase implements SymbologyWidget {
    /** View-model of the simple symbology settings widget. */
    viewModel: SimpleSymbolWidgetViewModel;
    /** Display name for binding to a selector */
    displayName: string;
    /** Container element that wraps around all symbology settings. */
    container: HTMLDivElement;
    /** Attach a callback here to respond to symbology changes in real time */
    onChange: (style: string) => void;
    /** Marker style dropdown. */
    markerStyleInput: HTMLSelectElement;
    /** Line style dropdown. */
    lineStyleInput: HTMLSelectElement;
    /** Fill style dropdown. */
    fillStyleInput: HTMLSelectElement;
    /**
     * Attach this view to its view-model.
     */
    attach(viewModel: SimpleSymbolWidgetViewModel): void;
    /**
     * This widget attaches a reference to itself onto the parent view.
     */
    added(parentView: SimpleSymbolWidgetParentView): void;
    /**
     * Pulse widget observables on activation to ensure initialization
     */
    activated(): void;
    /**
     * Calling 'reset' on this widget reverts the viewmodel to the default state
     */
    reset(): void;
    /**
     * Gets the current symbol configured by this widget
     */
    getSymbol(): string;
    /**
     * Set the configuration of this widget from a supplied symbol
     * @param symbol
     */
    setFromSymbol(symbol: esri.symbol.Symbol, update?: boolean): void;
    /**
     * Get a renderer containing the configured symbol as a JSON string
     */
    getRenderer(): string;
    /**
     * Set the configuration of this widget from the symbol contained in a supplied renderer
     * @param renderer
     */
    setFromRenderer(renderer: esri.renderer.Renderer): void;
    /**
     * Set the feature type of this widget to point, line, polygon
     * @param featureType
     */
    setFeatureType(featureType: string): void;
    /**
     * Handle user changing marker style
     */
    handleMarkerStyle(): void;
    /**
     * Handle user changing line style
     */
    handleLineStyle(): void;
    /**
     * Handle user changing fill style
     */
    handleFillStyle(): void;
    /**
     * Creates a symbol from the current configuration of the widget
     */
    applySettings(): void;
    /**
     * Given the fill color and the selected outline color (if any) return a valid outline color
     * @param fillColor
     * @param outlineColor
     */
    private _getOutlineColor(fillColor, outlineColor);
}
/**
 * The parent view of this widget contains a reference to this widget.
 */
export interface SimpleSymbolWidgetParentView extends ViewBase {
    /** Parent's reference to the child symbology widget view. */
    symbologyWidget?: SimpleSymbolWidget;
}

}
declare module "geocortex/infrastructure/symbology/widgets/SimpleSymbolWidgetConfig" {
import { RangeConfiguration } from "geocortex/infrastructure/ui/components/NumericInput/RangeConfiguration";
import { SymbologySettingsStyle } from "geocortex/infrastructure/symbology/SymbologySettingsViewModel";
/**
 * Configuration for the SimpleMarkerSymbol, SimpleLineSymbol and SimpleFillSymbol widget.
 */
export interface SimpleSymbolWidgetConfig {
    /** Whether to allow the outline color to be selected, or auto-generated */
    userSelectedOutlineColor?: boolean;
    /** If the fill color is dark the outline is light and vice versa. Use when not allowing independent outline selection */
    adaptOutlineToFill?: boolean;
    /** @DEPRECATED: 2.8 Use Essentials symbology libraries to configure. The style of markers for points. */
    markerStyles?: SymbologySettingsStyle[];
    /** @DEPRECATED: 2.8 Use Essentials symbology libraries to configure. The style of outlines and polylines. */
    lineStyles?: SymbologySettingsStyle[];
    /** @DEPRECATED: 2.8 Use Essentials symbology libraries to configure. The style of polygon fills. */
    fillStyles?: SymbologySettingsStyle[];
    /** Range configuration for the marker size slider. */
    markerSize?: RangeConfiguration;
    /** Range configuration for the marker size slider. */
    lineWidth?: RangeConfiguration;
    /** Show slider along with native numeric inputs? */
    showSliders?: boolean;
}

}
declare module "geocortex/infrastructure/symbology/widgets/SimpleSymbolWidgetViewModel" {
import { ViewModelBase } from "geocortex/framework/ui/ViewModelBase";
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { Observable, ObservableCollection } from "geocortex/framework/observables";
import { ColorPickerViewModel } from "geocortex/infrastructure/ui/components/ColorPicker/ColorPickerViewModel";
import { NumericInputViewModel } from "geocortex/infrastructure/ui/components/NumericInput/NumericInputViewModel";
import { SymbologySettingsSymbols, SymbologySettingsStyle } from "geocortex/infrastructure/symbology/SymbologySettingsViewModel";
import { SimpleSymbolWidgetConfig } from "geocortex/infrastructure/symbology/widgets/SimpleSymbolWidgetConfig";
/**
 * View-model for the simple symbology settings widget.
 * Line symbolization options are always needed (of course for polylines, but also for points and polygons as outlines).
 * Marker and fill symbolization options are optional.
 */
export class SimpleSymbolWidgetViewModel extends ViewModelBase {
    /** Configuration for the symbology settings view-model. */
    config: SimpleSymbolWidgetConfig;
    /** Configuring the widget will produce events that should be ignored */
    configuring: boolean;
    /** Configure the widget to display appropriate options */
    isPoint: Observable<boolean>;
    isLine: Observable<boolean>;
    isPolygon: Observable<boolean>;
    /** Allow the selection of outline styles */
    showLineStyles: Observable<boolean>;
    /** Allow the user to select outline color independently of fill */
    showOutlineColor: Observable<boolean>;
    /** Independantly of configuration, hides the outline swatch for symbols that do not support this (X and +) */
    noOutlineSymbol: Observable<boolean>;
    /** Final resultant symbols, the end-product of this widget. */
    symbols: SymbologySettingsSymbols;
    /** If this view makes up part of a symbology configuration view the parent can be attached here */
    parentSymbologyView: ViewBase;
    /** A method to get the symbol from the text widget */
    getTextSymbol: () => string;
    /** View model for the user-selected marker size widget. */
    markerSize: Observable<number>;
    markerSizeViewModel: NumericInputViewModel;
    /** The currently selected markerStyle */
    markerStyleIndex: number;
    /** Observable for the user-selected line width. */
    lineWidth: Observable<number>;
    lineWidthViewModel: NumericInputViewModel;
    /** The currently selected line style  */
    lineStyleIndex: number;
    /** The currently selected polygon fill style */
    fillStyleIndex: number;
    /** The colors used in the symbology. */
    fill: ColorPickerViewModel;
    outline: ColorPickerViewModel;
    /** View model has been configured and is ready to go */
    initialized: boolean;
    /** These are used to translate style ids from Esri JS API to Esri REST API form */
    markerStyleIdLookup: {
        [id: string]: string;
    };
    lineStyleIdLookup: {
        [id: string]: string;
    };
    fillStyleIdLookup: {
        [id: string]: string;
    };
    /** Styles available to point markers. */
    markerStyles: ObservableCollection<SymbologySettingsStyle>;
    /** Styles available to lines. */
    lineStyles: ObservableCollection<SymbologySettingsStyle>;
    /** Styles available to polygon fills. */
    fillStyles: ObservableCollection<SymbologySettingsStyle>;
    /**
     * Initialize the widget based on configuration.
     */
    initialize(configuration?: SimpleSymbolWidgetConfig): void;
    /**
     * Returns the widget to the default state (as defined by the configuration object)
     * Private: Call 'reset' on SimpleSymbolWidget
     */
    _reset(): void;
    /**
     * Set the feature type of this widget to point, line, polygon
     * Private: Call 'setFeatureType' on SimpleSymbolWidget
     * @param featureType
     */
    _setFeatureType(featureType: string): void;
    /**
     * Returns a renderer based on the current widget setttings as a JSON string
     * Private: Call 'getRenderer' on SimpleSymbolWidget
     */
    _getRenderer(): string;
    /**
     * Returns a symbol as a json string, based on the current widget settings
     * Private: Call 'getSymbol' on SimpleSymbolWidget
     */
    _getSymbol(): string;
    /**
     * Sets the state of the widget based on a supplied simple renderer
     * Private: Call 'setFromRenderer' on SimpleSymbolWidget
     * @param renderer
     */
    _setFromRenderer(renderer: esri.renderer.Renderer): void;
    /**
     * Sets the state of the widget based on a supplied symbol
     * Private: Call 'setFromSymbol' on SimpleSymbolWidget
     * @param symbol
     */
    _setFromSymbol(symbol: esri.symbol.Symbol): void;
    /**
     * Set this widget from an ESRI symbol JSON object (web map specification)
     * @param so
     */
    private _setFromSymbolObject(s);
}

}
declare module "geocortex/infrastructure/symbology/widgets/SymbologyWidget" {
import { ViewBase } from "geocortex/framework/ui/ViewBase";
/**
 * Interface of a symbology widget
 * @param displayName The display name of the widget
 * @param handleChange An optional callback for handling symbology changes in real time
 * @param applyConfiguration Applies configuration and creates the symbol that the widget produces
 * @param reset Reset the widget to the original state
 * @param getSymbol Get the symbol produced by this widget as a JSON string
 * @param setFromSymbol Set the state of the widget from the supplied symbol
 */
export interface SymbologyWidget extends ViewBase {
    displayName: string;
    applySettings: () => void;
    reset: () => void;
    getSymbol: () => string;
    setFromSymbol: (symbol: esri.symbol.Symbol) => void;
}

}
declare module "geocortex/infrastructure/symbology/widgets/TextSymbolWidget" {
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { TextSymbolWidgetViewModel } from "geocortex/infrastructure/symbology/widgets/TextSymbolWidgetViewModel";
import { SymbologyWidget } from "geocortex/infrastructure/symbology/widgets/SymbologyWidget";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
/**
 * The text symbology settings widget view.
 */
export class TextSymbolWidget extends ViewBase implements SymbologyWidget {
    app: ViewerApplication;
    viewModel: TextSymbolWidgetViewModel;
    /** Display name of this widget */
    displayName: string;
    /** Attach a callback here to respond to symbology changes in real time */
    onChange: (style: string) => void;
    /** This will only be set by the MarkupStyleView. It exists to prevent editing text markup from changing the global markup style */
    editingMarkup: boolean;
    /** Font family dropdown. */
    protected fontFamilyInput: HTMLSelectElement;
    /**
     * Attach this view to its view-model.
     */
    attach(viewModel: TextSymbolWidgetViewModel): void;
    /**
     * This widget attaches a reference to itself onto the parent view, if one exists.
     * You can initialize this widget as a regular view/viewModel, in which case it doesn't have a parent
     */
    added(parentView?: TextSymbolWidgetParentView): void;
    activated(): void;
    /**
     * Calling 'reset' on this widget reverts the viewmodel to the default state
     */
    reset(): void;
    /**
     * Get the current symbol configured by this widget
     */
    getSymbol(update?: boolean): string;
    /**
     * Set the state of this widget from a supplied esri.symbol.TextSymbol
     * @param symbol
     */
    setFromSymbol(symbol: esri.symbol.Symbol, update?: boolean): void;
    /**
     * Set view-model observables and populate the `symbol` object based on any changes here in the view.
     */
    applySettings(update?: boolean): void;
}
/**
 * The parent view of this widget contains a reference to this widget.
 */
export interface TextSymbolWidgetParentView extends ViewBase {
    /** Parent's reference to the child symbology widget view. */
    textSymbologySettingsWidget?: TextSymbolWidget;
}

}
declare module "geocortex/infrastructure/symbology/widgets/TextSymbolWidgetConfig" {
import { RangeConfiguration } from "geocortex/infrastructure/ui/components/NumericInput/RangeConfiguration";
/**
 * Configuration for the TextSymbol widget.
 */
export interface TextSymbolWidgetConfig {
    /** Whether to allow the halo size to be configured */
    haloSizeIsVisible?: boolean;
    /** Whether to allow the halo color to be configured */
    haloColorIsVisible?: boolean;
    /** Whether to allow the font size to be configured */
    fontSizeIsVisible?: boolean;
    /** Whether to allow the font style to be configured */
    fontStyleIsVisible?: boolean;
    /** Whether to allow the font color to be configured */
    fontColorIsVisible?: boolean;
    /** Whether to allow the font family to be configured */
    fontFamiliesIsVisible?: boolean;
    /** Whether to allow the text angle to be configured */
    textAngleIsVisible?: boolean;
    /** Whether to allow the symbol text to be input */
    textIsVisible?: boolean;
    /** The style of markers for points. */
    fontFamilies?: string[];
    /** Range configuration for a transparency slider. */
    fontSize?: RangeConfiguration;
    /** Range configuration for the marker size slider. */
    haloSize?: RangeConfiguration;
    /** Show slider along with native numeric inputs? */
    showSliders?: boolean;
}

}
declare module "geocortex/infrastructure/symbology/widgets/TextSymbolWidgetViewModel" {
import { ViewModelBase } from "geocortex/framework/ui/ViewModelBase";
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { Observable, ObservableCollection } from "geocortex/framework/observables";
import { TextSymbol } from "geocortex/infrastructure/webMap/Symbol";
import { ColorPickerViewModel } from "geocortex/infrastructure/ui/components/ColorPicker/ColorPickerViewModel";
import { NumericInputViewModel } from "geocortex/infrastructure/ui/components/NumericInput/NumericInputViewModel";
import { TextSymbolWidgetConfig } from "geocortex/infrastructure/symbology/widgets/TextSymbolWidgetConfig";
/**
 * View-model for the text symbology settings widget.
 */
export class TextSymbolWidgetViewModel extends ViewModelBase {
    /** Configuration for the symbology settings view-model. */
    config: TextSymbolWidgetConfig;
    /** The symbol currently configured by this widget */
    symbol: esri.symbol.TextSymbol;
    /** View model for the user-selected font size widget. */
    fontSize: Observable<number>;
    fontSizeViewModel: NumericInputViewModel;
    /** User-selected halo size. */
    haloSize: Observable<number>;
    haloSizeViewModel: NumericInputViewModel;
    /** Text angle configuration */
    textAngle: Observable<number>;
    textAngleViewModel: NumericInputViewModel;
    /** The currently selected font family */
    fontFamily: Observable<string>;
    /** Text of the current symbol. Optional unless editing a symbol with existing text */
    symbolText: Observable<string>;
    /** The colors used in the symbology. */
    fontColor: ColorPickerViewModel;
    fontHalo: ColorPickerViewModel;
    /** Font families available for picking. */
    fontFamilies: ObservableCollection<string>;
    /** Font Styles */
    fontIsBold: Observable<boolean>;
    fontIsItalic: Observable<boolean>;
    fontIsUnderline: Observable<boolean>;
    /** GVH-14249: As of esri's jsapi 3.20, halo's on text markup cause IE11 to crash. We'll disable them if its IE11. */
    isIE9or11: boolean;
    /** Some things which can be configured to be visible or not */
    showHaloSize: Observable<boolean>;
    showHaloColor: Observable<boolean>;
    showFontStyle: Observable<boolean>;
    showFontSize: Observable<boolean>;
    showFontColor: Observable<boolean>;
    showFontFamilies: Observable<boolean>;
    showTextAngle: Observable<boolean>;
    showText: Observable<boolean>;
    /** View model has been configured and is ready to go */
    initialized: boolean;
    /** Prevent bindings from firing when configuring the widget */
    configuring: boolean;
    /** If this view makes up part of a symbology configuration view the parent can be attached here */
    parentSymbologyView: ViewBase;
    /**
     * Initialize the widget based on configuration.
     */
    initialize(configuration?: TextSymbolWidgetConfig): void;
    /**
     * Returns the widget to the default state (as defined by the configuration object)
     */
    reset(): void;
    /**
     * Returns a symbol as a json string, based on the current widget settings
     * Intended to be private. Call the method on TextSymbolWidget instead.
     */
    _getSymbol(): string;
    /**
     * Sets the state of the widget based on a supplied symbol
     * Intended to be private. Call the method on TextSymbolWidget instead.
     * @param symbol
     */
    _setFromSymbol(symbol: esri.symbol.TextSymbol): void;
    protected _setFromSymbolObject(ts: TextSymbol): void;
}

}
declare module "geocortex/infrastructure/toolbarGroup/types/ToolbarButton" {
import { ToolbarGroupItemBaseEntry, ToolbarGroupItemBase } from "geocortex/infrastructure/toolbarGroup/ToolbarGroupItemBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
export interface ToolbarButtonEntry extends ToolbarGroupItemBaseEntry {
    command?: string;
    commandParameter?: string;
    iconUri?: string;
}
export class ToolbarButton extends ToolbarGroupItemBase {
    constructor(app: ViewerApplication, libraryId: string, entry: ToolbarButtonEntry);
    execute(): void;
    protected _raiseCommandCanExecuteChanged(): void;
}

}
declare module "geocortex/infrastructure/toolbarGroup/types/ToolbarFlyout" {
import { ToolbarGroupItemBaseEntry, ToolbarGroupItemBase } from "geocortex/infrastructure/toolbarGroup/ToolbarGroupItemBase";
import { ToolbarGroup } from "geocortex/infrastructure/toolbarGroup/types/ToolbarGroup";
import { Observable } from "geocortex/framework/observables";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { ActiveToolChangedEventArgs } from "geocortex/infrastructure/eventArgs/ActiveToolChangedEventArgs";
export interface ToolbarFlyoutEntry extends ToolbarGroupItemBaseEntry {
    items?: ToolbarGroupItemBaseEntry[];
    layout?: string;
}
export class ToolbarFlyout extends ToolbarGroup {
    flyoutButtonDescription: Observable<string>;
    constructor(app: ViewerApplication, libraryId: string, entry: ToolbarFlyoutEntry);
    protected _seeIfActiveToolIsInFlyout(currentToolItemBase: ToolbarGroupItemBase, args: ActiveToolChangedEventArgs): boolean;
    toggleFlyout(): void;
    switchActiveFlyoutTool(ctx: ToolbarGroupItemBase): void;
    getToolbarItemType(item: ToolbarGroupItemBaseEntry): ToolbarGroupItemBase;
}

}
declare module "geocortex/infrastructure/toolbarGroup/types/ToolbarGroup" {
import { ToolbarGroupItemBaseEntry, ToolbarGroupItemBase } from "geocortex/infrastructure/toolbarGroup/ToolbarGroupItemBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
export interface ToolbarGroupEntry extends ToolbarGroupItemBaseEntry {
    items?: ToolbarGroupItemBaseEntry[];
    layout?: string;
}
export class ToolbarGroup extends ToolbarGroupItemBase {
    constructor(app: ViewerApplication, libraryId: string, entry?: ToolbarGroupEntry);
    getToolbarItemType(entry: ToolbarGroupItemBaseEntry): ToolbarGroupItemBase;
}

}
declare module "geocortex/infrastructure/toolbarGroup/types/ToolbarRegion" {
import { ToolbarGroupItemBaseEntry, ToolbarGroupItemBase } from "geocortex/infrastructure/toolbarGroup/ToolbarGroupItemBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
export interface ToolbarRegionEntry extends ToolbarGroupItemBaseEntry {
    regionName?: string;
}
export class ToolbarRegion extends ToolbarGroupItemBase {
    constructor(app: ViewerApplication, libraryId: string, entry?: ToolbarRegionEntry);
}

}
declare module "geocortex/infrastructure/toolbarGroup/types/ToolbarToggleButton" {
import { ToolbarGroupItemBaseEntry, ToolbarGroupItemBase } from "geocortex/infrastructure/toolbarGroup/ToolbarGroupItemBase";
import { CommandViewModel } from "geocortex/infrastructure/CommandViewModel";
import { Observable } from "geocortex/framework/observables";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
export interface ToggleStateConfig {
    name?: string;
    command: string;
    commandParameter?: string;
    iconUri?: string;
    tooltip?: string;
    hideOnDisable?: boolean;
}
export interface ToolbarToggleButtonEntry extends ToolbarGroupItemBaseEntry {
    iconUri?: string;
    toggleOn: ToggleStateConfig;
    toggleOff: ToggleStateConfig;
    /**
     * The name of the (optional) state that will alter the toggle state of the button.
     */
    toggleStateName?: string;
}
export enum ToggleButtonState {
    TOGGLE_BUTTON_OFF = 0,
    TOGGLE_BUTTON_ON = 1,
}
export class ToolbarToggleButton extends ToolbarGroupItemBase {
    toggleButtonEntry: ToolbarToggleButtonEntry;
    toggleOnCommand: CommandViewModel;
    toggleOffCommand: CommandViewModel;
    state: Observable<ToggleButtonState>;
    isToggledOn: Observable<boolean>;
    private _toggleOnCommandCanExecuteBindingToken;
    private _toggleOffCommandCanExecuteBindingToken;
    private _toggleOnCommandPostExecSubscriptionToken;
    private _toggleOffCommandPostExecSubscriptionToken;
    constructor(app: ViewerApplication, libraryId: string, entry: ToolbarToggleButtonEntry);
    execute(): void;
    setState(state: ToggleButtonState): void;
    onDestroy(): void;
    protected _setUpBindings(): void;
    protected _disconnectBindings(): void;
    protected _handleToggleOnCommandPostExecute(commandParameter: string): void;
    protected _handleToggleOffCommandPostExecute(commandParameter: string): void;
    protected _handleCommandCanExecuteChanged(source: CommandViewModel, state: boolean): void;
}

}
declare module "geocortex/infrastructure/toolbarGroup/types/ToolbarTool" {
import { ToolbarGroupItemBaseEntry, ToolbarGroupItemBase } from "geocortex/infrastructure/toolbarGroup/ToolbarGroupItemBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
export interface ToolbarToolEntry extends ToolbarGroupItemBaseEntry {
    iconUri?: string;
}
export class ToolbarTool extends ToolbarGroupItemBase {
    constructor(app: ViewerApplication, libraryId: string, entry?: ToolbarToolEntry);
    execute(): void;
    private _initializeTool(formattedConfig);
}

}
declare module "geocortex/infrastructure/ui/components/ProviderConfiguration" {
/**
 * Common configuration for components that are instantiated with a provider in code
 */
export interface ProviderConfiguration {
    /** The type name of the provider to use to display the widget. Requires a shim. */
    provider: string;
}

}
declare module "geocortex/infrastructure/offline/bundle/offlineHandlers/FailHandler" {
import { OfflineHandler } from "geocortex/infrastructure/offline/bundle/offlineHandlers/OfflineHandler";
import { RequestContext } from "geocortex/infrastructure/offline/bundle/RequestContext";
import { RoutingRule } from "geocortex/infrastructure/offline/bundle/RoutingRule";
import { CancellationToken } from "geocortex/infrastructure/CancellationToken";
/**
 * Rejects all matching requests.
 */
export class FailHandler implements OfflineHandler {
    name: string;
    handle(request: RequestContext, rule: RoutingRule, matches: RegExpExecArray, cancellationToken: CancellationToken): boolean;
}

}
declare module "geocortex/infrastructure/offline/bundle/offlineHandlers/OfflineHandler" {
import { RequestContext } from "geocortex/infrastructure/offline/bundle/RequestContext";
import { RoutingRule } from "geocortex/infrastructure/offline/bundle/RoutingRule";
import { CancellationToken } from "geocortex/infrastructure/CancellationToken";
/**
 * A handler for offline requests.  The handler is only called when a rule
 * with the same name matches a request.  The handler may still refuse to handle
 * the request.
 */
export interface OfflineHandler {
    /**
     * The name of the handler.
     */
    name: string;
    /**
     * Applies a routing rule to the given request.  The rule will have a name
     * matching the name passed in to OfflineRouter.addHandler() and the rule
     * pattern will match the request.
     * @param request The request to handle.
     * @param rule The rule matching the request.
     * @param matches Regexp capturing groups from the rule pattern.
     * @return Whether the rule successfully handled the request.
     */
    handle(request: RequestContext, rule: RoutingRule, matches: RegExpExecArray, cancellationToken: CancellationToken): boolean;
}
/**
 * A useful util function.  Sets the load and error callbacks onto the deferred
 * object used by request. This is due to the change from _request
 * to request. _serveResourceImpl does not hook load and errors itself.
 */
export function hookDeferredCallbacks(request: RequestContext): void;

}
declare module "geocortex/infrastructure/offline/bundle/offlineHandlers/PassthroughHandler" {
import { OfflineHandler } from "geocortex/infrastructure/offline/bundle/offlineHandlers/OfflineHandler";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { EsriRequest, EsriRequestOptions, RequestContext } from "geocortex/infrastructure/offline/bundle/RequestContext";
import { RoutingRule } from "geocortex/infrastructure/offline/bundle/RoutingRule";
import { CancellationToken } from "geocortex/infrastructure/CancellationToken";
/**
 * Doesn't actually handle anything and just pushes it through to online.
 */
export class PassthroughHandler implements OfflineHandler {
    app: ViewerApplication;
    unhackedRequesthandler: (request: EsriRequest, options: EsriRequestOptions) => dojo.Deferred;
    name: string;
    constructor(app: ViewerApplication, unhackedRequesthandler: (request: EsriRequest, options: EsriRequestOptions) => dojo.Deferred);
    handle(request: RequestContext, rule: RoutingRule, matches: RegExpExecArray, cancellationToken: CancellationToken): boolean;
}

}
declare module "geocortex/infrastructure/offline/bundle/offlineHandlers/RewriteHandler" {
import { OfflineHandler } from "geocortex/infrastructure/offline/bundle/offlineHandlers/OfflineHandler";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { EsriRequest, EsriRequestOptions, RequestContext } from "geocortex/infrastructure/offline/bundle/RequestContext";
import { RoutingRule } from "geocortex/infrastructure/offline/bundle/RoutingRule";
import { CancellationToken } from "geocortex/infrastructure/CancellationToken";
/**
 * Rewrites requests and then passes them through the unhackedRequesthandler.
 */
export class RewriteHandler implements OfflineHandler {
    app: ViewerApplication;
    unhackedRequesthandler: (request: EsriRequest, options: EsriRequestOptions) => dojo.Deferred;
    constructor(app: ViewerApplication, unhackedRequesthandler: (request: EsriRequest, options: EsriRequestOptions) => dojo.Deferred);
    name: string;
    handle(request: RequestContext, rule: RoutingRule, matches: RegExpExecArray, cancellationToken: CancellationToken): boolean;
    /**
     * Rewrites a request's URL.
     */
    rewriteRequest(ctx: RequestContext, rule: RoutingRule, matches: RegExpExecArray): string;
    /**
     * Takes a url, and appends the local server token as a URL parameter to create a new URL.
     */
    private _appendLocalServerToken(url);
}

}
declare module "geocortex/infrastructure/offline/bundle/offlineHandlers/ServeResourceHandler" {
import { OfflineHandler } from "geocortex/infrastructure/offline/bundle/offlineHandlers/OfflineHandler";
import { Observable } from "geocortex/framework/observables";
import { Bundle } from "geocortex/infrastructure/offline/bundle/Bundle";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { RequestContext } from "geocortex/infrastructure/offline/bundle/RequestContext";
import { RoutingRule } from "geocortex/infrastructure/offline/bundle/RoutingRule";
import { BundleResourceEntry } from "geocortex/infrastructure/offline/bundle/BundleResourceEntry";
import { CancellationToken } from "geocortex/infrastructure/CancellationToken";
/**
 * Serves resources stored in the bundle.  Some resources are removed from the bundle
 * and stored separately to shrink what needs to be kept in memory.
 */
export class ServeResourceHandler implements OfflineHandler {
    app: ViewerApplication;
    resourceGetter: (key: string) => Promise<string>;
    resourceSetter: (key: string, value: string) => Promise<void>;
    resourceRemover: (key: string) => Promise<void>;
    /** The resource length at which it will be put in storage rather than kept in memory. */
    private static _resourceCachingLength;
    name: string;
    isReady: Observable<boolean>;
    private _bundle;
    constructor(app: ViewerApplication, resourceGetter: (key: string) => Promise<string>, resourceSetter: (key: string, value: string) => Promise<void>, resourceRemover: (key: string) => Promise<void>);
    /**
     * Serve the request using the given rule from the bundle.
     * @param request The request to serve.
     * @param rule The rule from the bundle that matches the request.
     * @param matches Regex capturing groups.
     * @return Whether the request was successfully handled.
     */
    handle(request: RequestContext, rule: RoutingRule, matches: RegExpExecArray, cancellationToken: CancellationToken): boolean;
    /**
     * Serve all future requests with resources from the given bundle.
     * @param bundle The bundle to serve from.
     */
    loadBundle(bundle: Bundle): void;
    /**
     * Clear all known resources.
     */
    clear(): void;
    /**
     * Strip large values out of the bundle and store them separately.  This does not make the
     * bundle active.  That is done with loadBundle.
     * @param bundle The bundle to process.
     * @return a promise of the bundle that was passed in, after it is processed.
     */
    stripAndStoreBundle(bundle: Bundle): Promise<Bundle>;
    /**
     * Unstore all entries stored by stripAndStoreBundle.  The values are not returned to
     * the bundle.  It's assumed we're just going to throw it away.
     * @param bundle The bundle to process.
     * @return a promise of the bundle that was passed in, after it is processed.
     */
    unstoreBundle(bundle: Bundle): Promise<Bundle>;
    /**
     * Updates an entry in the bundle.
     */
    updateEntry(bundleId: string, entry: BundleResourceEntry): Promise<void>;
    /**
     * Get the resouce for the given key.
     * @param key
     */
    getResourceValue(key: string): Promise<any>;
    /**
     * Get the resource from the given entry.
     * @param entry
     */
    private _getResourceValue(entry);
    static getResourceStorageKey(bundleId: string, entryKey: string): string;
}

}
declare module "geocortex/infrastructure/offline/bundle/offlineHandlers/SiteHandler" {
import { OfflineHandler } from "geocortex/infrastructure/offline/bundle/offlineHandlers/OfflineHandler";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { EsriRequest, EsriRequestOptions, RequestContext } from "geocortex/infrastructure/offline/bundle/RequestContext";
import { RoutingRule } from "geocortex/infrastructure/offline/bundle/RoutingRule";
import { CancellationToken } from "geocortex/infrastructure/CancellationToken";
/**
 * Handles requests for the site specially to inject the true principal if the user is authed.
 */
export class SiteHandler implements OfflineHandler {
    app: ViewerApplication;
    siteJsonGetter: (key: string) => Promise<any>;
    siteJsonSetter: (key: string, value: string) => Promise<void>;
    unhackedRequesthandler: (request: EsriRequest, options: EsriRequestOptions) => dojo.Deferred;
    name: string;
    /**
     * @param siteJsonGetter Gets the stored site JSON.  The key passed in comes from the rule parameter.
     * @param unhackedRequesthandler Unhacked esri.request.
     */
    constructor(app: ViewerApplication, siteJsonGetter: (key: string) => Promise<any>, siteJsonSetter: (key: string, value: string) => Promise<void>, unhackedRequesthandler: (request: EsriRequest, options: EsriRequestOptions) => dojo.Deferred);
    handle(request: RequestContext, rule: RoutingRule, matches: RegExpExecArray, cancellationToken: CancellationToken): boolean;
    private _hasToken(request);
    private _getOnlineSitePrincipal(request);
    /**
     * Get a faked up principal object from GMAF using the security information it has.
     * This only works to present a security context while offline in GMAF, that can be
     * refreshed automatically when going online.
     * @param request
     */
    private _getGmafPrincipal(storedPrincipal);
}

}
declare module "geocortex/infrastructure/ui/components/ColorPicker/ColorPickerProviderBase" {
import { SymbolColor } from "geocortex/infrastructure/symbology/SymbolColor";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { ColorPickerWidget } from "geocortex/infrastructure/ui/components/ColorPicker/ColorPickerWidget";
/**
 * Base implementation of a {@link ColorPickerProviderBase}.
 * Not implemented.
 */
export class ColorPickerProviderBase {
    /**
     * The {@link geocortex.framework.application.Application} that this provider belongs to.
     */
    app: ViewerApplication;
    /**
     * The ID of the library that this provider belongs to.
     */
    libraryId: string;
    /**
     * The color of the colorpicker
     */
    color: SymbolColor;
    constructor(app: ViewerApplication, libraryId: string);
    initialize(widget: ColorPickerWidget): void;
    setColor(color: SymbolColor): void;
}

}
declare module "geocortex/infrastructure/ui/components/ColorPicker/ColorPickerViewModel" {
import { Observable } from "geocortex/framework/observables";
import { SymbolColor } from "geocortex/infrastructure/symbology/SymbolColor";
/**
 * View model for a color picker widget. The supplied observable will be synced with the current color picked in the widget.
 * @param color The color selected in the widget
 */
export interface ColorPickerViewModel {
    color: Observable<SymbolColor>;
}

}
declare module "geocortex/infrastructure/ui/components/ColorPicker/ColorPickerWidget" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { SymbolColor } from "geocortex/infrastructure/symbology/SymbolColor";
import { ColorPickerProviderBase } from "geocortex/infrastructure/ui/components/ColorPicker/ColorPickerProviderBase";
import { ColorPickerViewModel } from "geocortex/infrastructure/ui/components/ColorPicker/ColorPickerViewModel";
import { ProviderConfiguration } from "geocortex/infrastructure/ui/components/ProviderConfiguration";
/**
 * A wrapper for a third party color picker that plays nice with framework bindings.
 */
export class ColorPickerWidget extends ViewBase {
    viewModel: ColorPickerViewModel;
    /** Configuration for the color picker widget */
    configuration: ProviderConfiguration;
    /** Provider of the color picker */
    provider: ColorPickerProviderBase;
    /** Binding token for color updates */
    bindingToken: string;
    colorInput: HTMLInputElement;
    constructor(app: ViewerApplication, libraryId?: string);
    added(): void;
    /**
     * The ColorPickerWidget is initialized with the type of the provider to use. The provider must extend ColorPickerProviderBase.
     * @param config
     */
    initialize(config: ProviderConfiguration): void;
    /**
     * This method will be called by the specific ColorPickerProvider when the user has changed the color in the picker
     * @param color
     */
    updateColor(color: SymbolColor): void;
}

}
declare module "geocortex/infrastructure/ui/components/ColorPicker/KendoColorPickerProvider" {
import { SymbolColor } from "geocortex/infrastructure/symbology/SymbolColor";
import { ColorPickerProviderBase } from "geocortex/infrastructure/ui/components/ColorPicker/ColorPickerProviderBase";
import { ColorPickerWidget } from "geocortex/infrastructure/ui/components/ColorPicker/ColorPickerWidget";
/**
 * Implementation of the kendo color picker widget.
 */
export class KendoColorPickerProvider extends ColorPickerProviderBase {
    colorpicker: kendo.ui.ColorPicker;
    widget: ColorPickerWidget;
    constructor(app: any, libraryId: string);
    /**
     * The provider is initialized with the color picker widget after attachment to the DOM
     * @param widget
     */
    initialize(widget: ColorPickerWidget): void;
    /**
     * This method changes the native color input provided in ColorPickerWidget.html into a kendo color picker
     * The color picker *must* be attached to the DOM in its final location before you call this.
     */
    instantiate(): void;
    /**
     * Call this method to programmatically change the color of the picker
     * @param color
     */
    setColor(color: SymbolColor): void;
    /**
     * This event handler is called when the user changes the color using the picker
     * @param evt
     */
    protected updateColor(evt: kendo.ui.ColorPickerChangeEvent): void;
}

}
declare module "geocortex/infrastructure/ui/components/FilterControl/FilterControlComponent" {
import { FilterControlItemInfo } from "geocortex/infrastructure/ui/components/FilterControl/FilterControlItemInfo";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
export class FilterControlComponent<T> {
    app: ViewerApplication;
    filterControlId: string;
    private _filterableItems;
    private _currentQuery;
    constructor(app: ViewerApplication, filterControlId: string);
    registerFilterableItem(item: T, filterData?: string[]): void;
    removeRegisteredItem(item: T): boolean;
    clear(): void;
    getFilterableItem(item: T): FilterControlItemInfo<T>;
    setFilterData(item: T, filterData: string[]): void;
    queryMatched(item: T): boolean;
    filter(item: FilterControlItemInfo<T>, filterQuery: string): boolean;
    applyQuery(filterQuery: string): void;
    private _applyFilterControlQueryImpl(args);
}

}
declare module "geocortex/infrastructure/ui/components/FilterControl/FilterControlItemInfo" {
/**
 * The interface for a {link @FilterControlItemInfo} object item.
 */
export interface FilterControlItemInfo<T> {
    /**
     * The item that this {link @FilterableItemInfo} object represents.
     */
    item: T;
    /**
     * The string field values associated with the Filterable Item to apply the filter query against.
     */
    filterData: string[];
    /**
     * The query currently applied against the filter data.
     */
    filterQuery?: string;
    /**
     * A boolean indicating whether the current query matches the supplied filter data. This will be true by default when the filterQuery is not defined or null.
     */
    queryMatched?: boolean;
}

}
declare module "geocortex/infrastructure/ui/components/FilterControl/FilterControlViewBase" {
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { FilterControlViewModelBase } from "geocortex/infrastructure/ui/components/FilterControl/FilterControlViewModelBase";
export class FilterControlViewBase<T> extends ViewBase {
    viewModel: FilterControlViewModelBase<T>;
    handleFilterTextClear(evt: Event, el: HTMLElement, ctx: FilterControlViewModelBase<T>): void;
    handleFilterButtonClick(evt: Event, el: HTMLElement, ctx: FilterControlViewModelBase<T>): void;
}

}
declare module "geocortex/infrastructure/ui/components/FilterControl/FilterControlViewModelBase" {
import { ViewModelBase } from "geocortex/framework/ui/ViewModelBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { Observable } from "geocortex/framework/observables";
import { FilterControlComponent } from "geocortex/infrastructure/ui/components/FilterControl/FilterControlComponent";
/**
 * This class is the base view model for the filter control widget. Contains no business logic for the filter operation.
 */
export class FilterControlViewModelBase<T> extends ViewModelBase {
    filterText: Observable<string>;
    showBusyIcon: Observable<boolean>;
    filterInputPlaceholder: Observable<string>;
    filterButtonText: Observable<string>;
    private _filterControlComponent;
    private _filterTextSettleDelayMs;
    private _filterTextTimeoutToken;
    constructor(app: ViewerApplication, libraryId: string, filterControlComponent?: FilterControlComponent<T>);
    setFilterControlComponent(fcc: FilterControlComponent<T>): boolean;
    getFilterControlComponent(): FilterControlComponent<T>;
    /**
     * This function will work provided a filter control componet has been set for this view model. If this view model is intended to be used without
     * a filter control component (i.e. using other means to achieve filtration), this function should be overridden for the desired functionality.
     */
    handleFilterTextInput(val: string): boolean;
    private _processFilterTextChanged(val);
    private _handleFilterQueryChangedEvent(args);
}

}
declare module "geocortex/infrastructure/ui/components/Forms/AutoCompleteBoxFormItemView" {
import { FormItemViewBase } from "geocortex/infrastructure/ui/components/Forms/FormItemViewBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { AutoCompleteBoxFormItem } from "geocortex/forms/items/AutoCompleteBoxFormItem";
export class AutoCompleteBoxFormItemView extends FormItemViewBase {
    app: ViewerApplication;
    viewModel: AutoCompleteBoxFormItem;
    textElement: HTMLElement;
    dropDownContainerElement: HTMLHtmlElement;
    dropDownListElement: HTMLElement;
    timer: number;
    positionIndex: number;
    lastKeyEvent: number;
    keyTraverseInterval: number;
    closeTimer: number;
    _queryCancelled: boolean;
    _searchFocus: boolean;
    constructor(app: ViewerApplication, libraryId?: string);
    attach(viewModel?: AutoCompleteBoxFormItem): void;
    handleInputBlurEvent(evt: Event, el: HTMLElement, ctx: any): void;
    handleInputClickEvent(evt: any, el: any, ctx: any): void;
    handleInputFocusEvent(evt: any, el: any, ctx: any): void;
    handleDropdownFocusEvent(evt: Event, el: HTMLElement, ctx: any): boolean;
    handleDropdownBlurEvent(evt: Event, el: Element, ctx: any): boolean;
    handleClickItem(evt: Event, el: Element, ctx: any): void;
    openDropDown(): void;
    closeDropDown(): void;
    setDropDownPosition(position: number): void;
    handleDropdownKeyDown(evt: MouseEvent, el: HTMLElement, ctx: any): boolean;
    handleKeyEvent(evt: KeyboardEvent, el: HTMLElement, ctx: any): boolean;
    trigger(): void;
    filter(cascade: boolean): void;
}

}
declare module "geocortex/infrastructure/ui/components/Forms/CheckBoxFormItemView" {
import { FormItemViewBase } from "geocortex/infrastructure/ui/components/Forms/FormItemViewBase";
import { CheckBoxFormItem } from "geocortex/forms/items/CheckBoxFormItem";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
export class CheckBoxFormItemView extends FormItemViewBase {
    viewModel: CheckBoxFormItem;
    constructor(app: ViewerApplication, libraryId?: string);
    attach(viewModel?: CheckBoxFormItem): void;
}

}
declare module "geocortex/infrastructure/ui/components/Forms/ContainerFormItemView" {
import { FormItemViewBase } from "geocortex/infrastructure/ui/components/Forms/FormItemViewBase";
import { ContainerFormItem } from "geocortex/forms/items/ContainerFormItem";
import { Observable } from "geocortex/framework/observables";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
export class ContainerFormItemView extends FormItemViewBase {
    viewModel: ContainerFormItem;
    attached_style: Observable<string>;
    attached_isHorizontal: Observable<boolean>;
    private resultChangeSubscription;
    constructor(app: ViewerApplication, libraryId?: string);
    attach(viewModel?: ContainerFormItem): void;
    private _attachVisibilityControls(viewModel);
    onDestroy(): void;
}

}
declare module "geocortex/infrastructure/ui/components/Forms/DatePickerFormItemView" {
import { TimePickerFormItemView } from "geocortex/infrastructure/ui/components/Forms/TimePickerFormItemView";
import { DatePickerFormItem } from "geocortex/forms/items/DatePickerFormItem";
import { Observable, ObservableCollection } from "geocortex/framework/observables";
export class DatePickerFormItemView extends TimePickerFormItemView {
    static localizedJqueryDatepicker: boolean;
    viewModel: DatePickerFormItem;
    attached_pickerType: Observable<string>;
    attached_days: ObservableCollection<number>;
    attached_months: ObservableCollection<{
        value: number;
        name: string;
    }>;
    attached_years: ObservableCollection<number>;
    attached_day: Observable<number>;
    attached_month: Observable<number>;
    attached_year: Observable<number>;
    selectElementCount: number;
    /**
     * The hidden input that the jQuery date/time picker is attached to.
     */
    jQueryPicker: HTMLElement;
    private _jQueryPickerInitialized;
    /**
     * The visible input that the user interacts with when using a jQuery date/time picker.
     */
    jQueryFormattedInput: HTMLElement;
    private _lastClearedDate;
    private _daysPerMonth;
    private _dateTimePickerType;
    private _dateFormat;
    attach(viewModel?: DatePickerFormItem): void;
    private _syncComboBoxes();
    private _isLeapYear(year);
    private _calcTime();
    setPickerDateTime(dt: Date): void;
    handleChangeComboBoxTime(): void;
    handleChangeComboBoxTimeWithNativeDate(): void;
    _createjQueryPicker(): void;
    /**
     * Updates the date shown in the jQuery picker input that we control.
     */
    private _updatejQueryFormattedInput(date);
    /**
    * Load localication settings for the datepicker and the timepicker from the language string store.
    * Generally getResource is used to return strings but actually it can hold arbitrary JSON.  The JSON
    * we're storing there matches files such as
    * https://raw.github.com/jquery/jquery-ui/master/ui/i18n/jquery.ui.datepicker-fr.js
    * and
    * https://raw.github.com/trentrichardson/jQuery-Timepicker-Addon/master/src/i18n/jquery-ui-timepicker-fr.js
    * for datepicker and timepicker respectively.
    */
    _localizeJqueryDatepicker(): void;
    _buildComboBoxes(viewModel: DatePickerFormItem): void;
    handleClickSetNull(): void;
    handleClickSetNotNull(): void;
    handleJqueryDatePickerTextChanged(evt: Event, element: HTMLElement, context: any): void;
    handleJqueryTimePickerTextChanged(evt: Event, element: HTMLElement, context: any): void;
    /**
     * Handle a click event on the fake date picker button.
     * Create a JQuery datepicker widget at this time and present it to the user.
     * @param evt
     * @param element
     * @param context
     */
    handleJqueryDatePickerInitializeClick(evt: Event, element: HTMLElement, context: any): void;
}

}
declare module "geocortex/infrastructure/ui/components/Forms/FilePickerFormItemView" {
import { FormItemViewBase } from "geocortex/infrastructure/ui/components/Forms/FormItemViewBase";
import { FilePickerFormItem } from "geocortex/forms/items/FilePickerFormItem";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
export class FilePickerFormItemView extends FormItemViewBase {
    viewModel: FilePickerFormItem;
    constructor(app: ViewerApplication, libraryId?: string);
    attach(viewModel?: FilePickerFormItem): void;
    handleChange(evt: Event, el: HTMLElement, context: any): void;
    handleClearClick(evt: Event, el: HTMLElement, context: any): void;
}

}
declare module "geocortex/infrastructure/ui/components/Forms/FormItemViewBase" {
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { AbstractFormItem } from "geocortex/forms/items/FormItem";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
export class FormItemViewBase extends ViewBase {
    viewModel: AbstractFormItem;
    constructor(app: ViewerApplication, libraryId?: string);
    attach(viewModel?: AbstractFormItem): void;
    calculateIndicatorDisplay(): void;
}

}
declare module "geocortex/infrastructure/ui/components/Forms/FormsUtils" {
import { Observable } from "geocortex/framework/observables";
export class FormsUtils {
    private static patterns;
    static convertToHTMLSyntax(textValue: Observable<String>): void;
    /**
     * Formats a list item value for display in a list, combobox, autocomplete, etc.
     */
    static formatListItem(value: any, type: string): string;
}

}
declare module "geocortex/infrastructure/ui/components/Forms/GroupBoxFormItemView" {
import { ContainerFormItemView } from "geocortex/infrastructure/ui/components/Forms/ContainerFormItemView";
import { GroupBoxFormItem } from "geocortex/forms/items/GroupBoxFormItem";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
export class GroupBoxFormItemView extends ContainerFormItemView {
    viewModel: GroupBoxFormItem;
    constructor(app: ViewerApplication, libraryId?: string);
    attach(viewModel?: GroupBoxFormItem): void;
}

}
declare module "geocortex/infrastructure/ui/components/Forms/HyperlinkFormItemView" {
import { FormItemViewBase } from "geocortex/infrastructure/ui/components/Forms/FormItemViewBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { HyperlinkFormItem } from "geocortex/forms/items/HyperlinkFormItem";
export class HyperlinkFormItemView extends FormItemViewBase {
    app: ViewerApplication;
    viewModel: HyperlinkFormItem;
    constructor(app: ViewerApplication, libraryId?: string);
    attach(viewModel?: HyperlinkFormItem): void;
    handleClick(evt: Event, element: HTMLAnchorElement, context: any): boolean;
}

}
declare module "geocortex/infrastructure/ui/components/Forms/ListBoxFormItemView" {
import { FormItemViewBase } from "geocortex/infrastructure/ui/components/Forms/FormItemViewBase";
import { ListBoxFormItem } from "geocortex/forms/items/ListBoxFormItem";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
export class ListBoxFormItemView extends FormItemViewBase {
    viewModel: ListBoxFormItem;
    selectionChangedTimer: number;
    selectedBindingToken: string;
    selectionBindingToken: string;
    constructor(app: ViewerApplication, libraryId?: string);
    attach(viewModel?: ListBoxFormItem): void;
    handleSelectionChanged(evt: Event, el: HTMLElement, context: any): boolean;
}

}
declare module "geocortex/infrastructure/ui/components/Forms/MarkdownFormItemView" {
import { FormItemViewBase } from "geocortex/infrastructure/ui/components/Forms/FormItemViewBase";
import { MarkdownFormItem } from "geocortex/forms/items/MarkdownFormItem";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
export class MarkdownFormItemView extends FormItemViewBase {
    viewModel: MarkdownFormItem;
    markdownElement: HTMLElement;
    constructor(app: ViewerApplication, libraryId?: string);
    attach(viewModel?: MarkdownFormItem): void;
}

}
declare module "geocortex/infrastructure/ui/components/Forms/RadioButtonFormItemView" {
import { FormItemViewBase } from "geocortex/infrastructure/ui/components/Forms/FormItemViewBase";
import { RadioButtonFormItem } from "geocortex/forms/items/RadioButtonFormItem";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
export class RadioButtonFormItemView extends FormItemViewBase {
    viewModel: RadioButtonFormItem;
    constructor(app: ViewerApplication, libraryId?: string);
    attach(viewModel?: RadioButtonFormItem): boolean;
}

}
declare module "geocortex/infrastructure/ui/components/Forms/TextEntryFormItemView" {
import { FormItemViewBase } from "geocortex/infrastructure/ui/components/Forms/FormItemViewBase";
import { TextBoxFormItem } from "geocortex/forms/items/TextBoxFormItem";
export class TextEntryFormItemView extends FormItemViewBase {
    viewModel: TextBoxFormItem;
    attach(viewModel?: TextBoxFormItem): void;
    handleBlurControl(): void;
}

}
declare module "geocortex/infrastructure/ui/components/Forms/TimePickerFormItemView" {
import { FormItemViewBase } from "geocortex/infrastructure/ui/components/Forms/FormItemViewBase";
import { Observable, ObservableCollection } from "geocortex/framework/observables";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { AbstractFormItem } from "geocortex/forms/items/FormItem";
export class TimePickerFormItemView extends FormItemViewBase {
    attached_time: Observable<any>;
    attached_seconds: ObservableCollection<number>;
    attached_minutes: ObservableCollection<number>;
    attached_hours: ObservableCollection<{
        val: number;
        desc: string;
    }>;
    attached_second: Observable<number>;
    attached_minute: Observable<number>;
    attached_hour: Observable<number>;
    selectContainerElement: HTMLElement;
    private _lastClearedTime;
    constructor(app: ViewerApplication, libraryId?: string);
    attach(viewModel?: AbstractFormItem): void;
    _buildComboBoxes(viewModel: AbstractFormItem): void;
    setPickerDateTime(dt: Date): void;
    handleChangeComboBoxTime(): void;
    handleClickSetNull(): void;
    handleClickSetNotNull(): void;
}

}
declare module "geocortex/infrastructure/ui/components/MultiPane/MultiPaneView" {
import { SmartPanelView } from "geocortex/infrastructure/ui/components/SmartPanel/SmartPanelView";
import { PaneView } from "geocortex/infrastructure/ui/components/MultiPane/PaneView";
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { MultiPaneViewModel } from "geocortex/infrastructure/ui/components/MultiPane/MultiPaneViewModel";
import { SelectorViewModel } from "geocortex/framework-ui/Selector/SelectorViewModel";
import { Application } from "geocortex/framework/application/Application";
export class MultiPaneView extends SmartPanelView {
    protected _panes: PaneView[];
    protected _selectorView: ViewBase;
    viewModel: MultiPaneViewModel;
    selector: SelectorViewModel<any>;
    containerElement: HTMLElement;
    headerElement: HTMLElement;
    constructor(app: Application, libraryId?: string);
    /**
     * Called when the view has been activated.
     */
    activated(): void;
    /**
     * Called when the view has been deactivated.
     */
    deactivated(): void;
    /**
     * Displays the default panes on the container view.
     * Only runs if no other panes are currently shown.
     */
    addDefaultPanes(): void;
    /**
     * Add a pane item with the specified ID to the layout by creating a new pane and loading the specified pane item.
     * @param paneItemId The ID of the pane item to add.
     */
    addPaneItemById(paneItemId: string): void;
    /**
     * Add a pane item to the layout by creating a new pane and loading the specified pane item.
     * @param paneItem The pane item to be added to the layout.
     */
    addPaneItem(paneItem: any): PaneView;
    canAddPaneItem(paneItem: any): boolean;
    /**
     * Removes a pane item with the specified ID from the layout.
     * @param paneItemId The ID of the pane item to remove.
     */
    destroyPaneItemById(paneItemId: string): void;
    /**
     * Remove a pane item from the layout.
     * @param paneItem The pane item to remove from the layout.
     */
    destroyPaneItem(paneItem: any): boolean;
    canDestroyPaneItem(paneItem: any): boolean;
    /**
     * Removes all pane items from the multi pane view.
     */
    clearPaneItems(): void;
    handleSelectPane(paneItem: any): void;
    handleUnSelectPane(paneItem: any): void;
    handleClickClose(): void;
    handleApplicationResizedEvent(): void;
    handleViewDeactivatedEvent(view: ViewBase): void;
    findPaneForPaneItem(paneItem: any): PaneView;
    protected _executeShowMultiPaneView(): void;
}

}
declare module "geocortex/infrastructure/ui/components/MultiPane/MultiPaneViewModel" {
import { SmartPanelViewModel } from "geocortex/infrastructure/ui/components/SmartPanel/SmartPanelViewModel";
import { ObservableCollection, Observable } from "geocortex/framework/observables";
import { MultiPaneViewModelConfig } from "geocortex/infrastructure/ui/components/MultiPane/MultiPaneViewModelConfig";
export class MultiPaneViewModel extends SmartPanelViewModel {
    /**
     * The collection of available pane items.
     */
    paneItems: ObservableCollection<any>;
    /**
     * The collection of pane items to display by default whenever the multi pane view is activated.
     */
    defaultPaneItems: ObservableCollection<any>;
    /**
     * The collection of pane items currently being displayed in the multi pane view.
     */
    displayedPaneItems: ObservableCollection<any>;
    /**
     * Whether the multi pane view is expanded (active).
     */
    expanded: Observable<boolean>;
    headerIsVisible: Observable<boolean>;
    showXButton: Observable<boolean>;
    selectorIconUri: Observable<string>;
    selectorText: Observable<string>;
    initialize(config: MultiPaneViewModelConfig): void;
    findPaneItemById(paneItemId: string): any;
    findDisplayedPaneItemById(paneItemId: string): any;
}

}
declare module "geocortex/infrastructure/ui/components/MultiPane/MultiPaneViewModelConfig" {
/**
 * Configuration for the Multi Pane view model.
 */
export interface MultiPaneViewModelConfig {
    /** Whether or not to show the header at the top of the multi pane view. */
    headerIsVisible?: boolean;
    /** Whether or not to display a button to close the multi pane view. */
    showXButton?: boolean;
    /** The text to label the drop-down list of pane items. */
    selectorText?: string;
    /** An image URI for an icon to display at the left side of the drop-down selector. */
    selectorIconUri?: string;
}

}
declare module "geocortex/infrastructure/ui/components/MultiPane/PaneView" {
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { PaneViewModel } from "geocortex/infrastructure/ui/components/MultiPane/PaneViewModel";
/**
 * This class provides a single container view designed to host a pane.
 */
export class PaneView extends ViewBase {
    protected _isDestroyed: boolean;
    /**
     * The ViewModel backing this view.
     */
    viewModel: PaneViewModel;
    /**
     * Clean up the pane item while destroying this view.
     */
    destroy(): void;
    /**
     * Invoked when the pane is closed.
     * @event
     */
    onClose(paneItem: any): void;
    handleClickClose(evt: Event, el: HTMLElement, ctx: any): void;
}

}
declare module "geocortex/infrastructure/ui/components/MultiPane/PaneViewModel" {
import { ViewModelBase } from "geocortex/framework/ui/ViewModelBase";
import { Observable } from "geocortex/framework/observables";
import { PaneViewModelConfig } from "geocortex/infrastructure/ui/components/MultiPane/PaneViewModelConfig";
export class PaneViewModel extends ViewModelBase {
    /**
     * The panel item being displayed in this container view.
     */
    currentPaneItem: Observable<any>;
    headerIsVisible: Observable<boolean>;
    showXButton: Observable<boolean>;
    initialize(config: PaneViewModelConfig): void;
    onDestroy(): void;
}

}
declare module "geocortex/infrastructure/ui/components/MultiPane/PaneViewModelConfig" {
/**
 * Configuration for the Pane view model.
 */
export interface PaneViewModelConfig {
    /** Whether or not to show the header at the top of the pane view. */
    headerIsVisible?: boolean;
    /** Whether or not to display a button to close the pane view. */
    showXButton?: boolean;
}

}
declare module "geocortex/infrastructure/ui/components/NumericInput/KendoSliderProvider" {
import { SliderProviderBase } from "geocortex/infrastructure/ui/components/NumericInput/SliderProviderBase";
import { NumericInputWidget } from "geocortex/infrastructure/ui/components/NumericInput/NumericInputWidget";
/**
 * Implementation of a numeric slider.
 */
export class KendoSliderProvider extends SliderProviderBase {
    slider: kendo.ui.Slider;
    widget: NumericInputWidget;
    constructor(app: any, libraryId: string);
    /**
     * The provider is initialized with the NumericInputWidget it is associated with
     * @param widget
     */
    initialize(widget: NumericInputWidget): void;
    /**
     * This method changes one of the native numeric inputs provided in NumericInputwidget.html into a kendo slider.
     */
    instantiate(): void;
    /**
     * Call this method to programmatically change the color of the picker
     * @param color
     */
    setValue(value: number): void;
    /**
     * This event handler is called when the user changes the value of the slider
     * @param evt
     */
    protected updateValue(evt: kendo.ui.SliderChangeEvent): void;
}

}
declare module "geocortex/infrastructure/ui/components/NumericInput/NumericInputViewModel" {
import { Observable } from "geocortex/framework/observables";
/**
 * View model for a numeric input widget. The supplied observable will be synced with the current value picked in the widget.
 * @param range Similar to the configuration of this widget {@link RangeConfiguration} but with the value replaced by an {@link Observable}.
 * Set or get the observable to interact with the widget.
 * @param showSlider Show the associated slider?
 * @param updateOnDrag Updates fire when dragging the slider if this is true, only when released if false
 */
export interface NumericInputViewModel {
    range: {
        min: number;
        max: number;
        value: Observable<number>;
        step: number;
    };
    showSlider: boolean;
    updateOnDrag: boolean;
}

}
declare module "geocortex/infrastructure/ui/components/NumericInput/NumericInputWidget" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { SliderProviderBase } from "geocortex/infrastructure/ui/components/NumericInput/SliderProviderBase";
import { NumericInputViewModel } from "geocortex/infrastructure/ui/components/NumericInput/NumericInputViewModel";
import { ProviderConfiguration } from "geocortex/infrastructure/ui/components/ProviderConfiguration";
/**
 * A wrapper for a numeric input widget that plays nice with framework bindings.
 */
export class NumericInputWidget extends ViewBase {
    viewModel: NumericInputViewModel;
    /** Configuration for the color picker widget */
    configuration: ProviderConfiguration;
    /** Provider of the color picker */
    provider: SliderProviderBase;
    /** Binding token for color updates */
    bindingToken: string;
    numericInput: HTMLInputElement;
    nativeInput: HTMLInputElement;
    constructor(app: ViewerApplication, libraryId?: string);
    attach(viewModel: NumericInputViewModel): void;
    /**
     * The NumericInputWidget is initialized with the type of the slider provider to use. The provider must extend SliderProviderBase.
     * @param config
     */
    initialize(config: ProviderConfiguration): void;
    /**
     * This method will be called by the specific SliderProvider when the user has changed the value using the slider
     * @param value
     */
    updateValue(value: number): void;
    setValue(value: number): void;
    validate(value: number): number;
    validateInput(): void;
}

}
declare module "geocortex/infrastructure/ui/components/NumericInput/RangeConfiguration" {
/**
 * Generic definition for the boundaries and default of a numerical range.
 * @param min Minimum value of the range
 * @param max Maximum value of the range
 * @param value Initial value
 * @param step Value to increment by
 */
export interface RangeConfiguration {
    min: number;
    max: number;
    value: number;
    step: number;
}

}
declare module "geocortex/infrastructure/ui/components/NumericInput/SliderProviderBase" {
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { NumericInputWidget } from "geocortex/infrastructure/ui/components/NumericInput/NumericInputWidget";
/**
 * Base implementation of a {@link SliderProviderBase}.
 * Not implemented.
 */
export class SliderProviderBase {
    /**
     * The {@link geocortex.framework.application.Application} that this provider belongs to.
     */
    app: ViewerApplication;
    /**
     * The ID of the library that this provider belongs to.
     */
    libraryId: string;
    /**
     * The value of the slider
     */
    value: number;
    constructor(app: ViewerApplication, libraryId: string);
    initialize(widget: NumericInputWidget): void;
    setValue(value: number): void;
}

}
declare module "geocortex/infrastructure/ui/components/PagingControls/PagingControlsView" {
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { PagingControlsViewModel } from "geocortex/infrastructure/ui/components/PagingControls/PagingControlsViewModel";
export class PagingControlsView extends ViewBase {
    app: ViewerApplication;
    viewModel: PagingControlsViewModel;
    libraryId: string;
    attach(viewModel?: PagingControlsViewModel): void;
    handlePageFirst(evt: Event, el: HTMLElement, ctx: any): void;
    handlePagePrev(evt: Event, el: HTMLElement, ctx: any): void;
    handlePageNext(evt: Event, el: HTMLElement, ctx: any): void;
    handlePageLast(evt: Event, el: HTMLElement, ctx: any): void;
}

}
declare module "geocortex/infrastructure/ui/components/PagingControls/PagingControlsViewModel" {
import { ViewModelBase } from "geocortex/framework/ui/ViewModelBase";
import { PresentableCollection } from "geocortex/framework-ui/PresentableCollection";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
export class PagingControlsViewModel extends ViewModelBase {
    collectionViewModel: any;
    presentableResults: PresentableCollection<Object>;
    numberOfItems: number;
    libraryId: string;
    constructor(app: ViewerApplication, collectionViewModel: any);
}

}
declare module "geocortex/infrastructure/ui/components/Slider/SliderConfig" {
/**
 * The configuration for a {link @Slider} object.
 */
export interface SliderConfig {
    /**
     * Optional. If true, the slider will have two handles representing a range. Default is false.
     */
    range?: boolean;
    /**
     * Optional. If true, animation will be enabled for the slider. Defaults to false.
     */
    animate: boolean;
    /**
     * Disables snapping to data items or labels altogether. Will only work when the slider is in numeric mode i.e. all data item values are numeric. Defaults to true.
     */
    disableSnappingForNumericValues?: boolean;
    /**
     * If true, and if the slider is in range mode, locks the first slider handle at the slider min val. Defaults to false.
     */
    lockMinSliderHandleAtMinVal?: boolean;
    /**
     * A language string to be applied to the aria-label of the slider min handle if in range mode. This is for WCAG compliance. If not defined, the currently selected time will be set as the label.
     */
    sliderMinHandleAriaLabel?: string;
    /**
    * A language string to be applied to the aria-label of the slider max handle if in range mode. This is for WCAG compliance. If not defined, the currently selected time will be set as the label.
    */
    sliderMaxHandleAriaLabel?: string;
    /**
    * A language string to be applied to the aria-label of the slider handle if it is not in range mode. This is for WCAG compliance. If not defined, the currently selected time will be set as the label.
    */
    sliderSingleHandleAriaLabel?: string;
}

}
declare module "geocortex/infrastructure/ui/components/Slider/SliderItem" {
/**
 * The interface for a {link @Slider} object item.
 */
export interface SliderItem<T> {
    /**
     * The value this slider item represents.
     */
    value: T | number;
    /**
     * The label for this slider item.
     */
    label: string;
    /**
     * Indicates whether this data item is currently active i.e. selectable on the slider or not. This will be updated based on
     * the itemActivePredicate each time this item is selected in the slider. Defaults to true.
     */
    active: boolean;
}

}
declare module "geocortex/infrastructure/ui/components/Slider/SliderViewBase" {
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { SliderViewModelBase } from "geocortex/infrastructure/ui/components/Slider/SliderViewModelBase";
/**
 * A  generic slider with the ability to be displayed horizontally or vertically in any target region.
 */
export class SliderViewBase<T> extends ViewBase {
    /**
     * The view model backing this view.
     */
    viewModel: SliderViewModelBase<T>;
    /**
     * A reference to the actual slider element in the DOM.
     */
    sliderElement: HTMLElement;
    /**
     * The HTML element reference for the slider min label.
     */
    sliderMinLabelElement: HTMLElement;
    /**
     * The HTML element reference for the slider max label.
     */
    sliderMaxLabelElement: HTMLElement;
    /**
     * The current raw values for the slider handles.
     */
    protected _sliderCurrentRawValues: number[];
    protected _sliderCurrentHandlePos: number[];
    protected _widgetHostElement: ViewBase;
    protected _minHandleBindingToken: string;
    protected _maxHandleBindingToken: string;
    protected _isEnabledBindingToken: string;
    protected _isAdded: boolean;
    protected _minHnadleLocked: boolean;
    protected _maxHandleLocked: boolean;
    protected _minHandleTag: string;
    protected _maxHandleTag: string;
    protected _currPosForComputedDirection: number[];
    /** @inherited */
    attach(viewModel: SliderViewModelBase<T>): void;
    added(widgetViewHost?: ViewBase): void;
    onDestroy(): void;
    refreshLabelPositions(): void;
    protected _setupViewModelBindings(): void;
    protected _generateJQuerySlider(): void;
    protected _applyInitViewModelState(options: any): void;
    protected _handleSliderRawValueChange(event: Event, ui: {
        handle: HTMLElement;
        value: number;
        values?: number[];
    }): boolean;
    protected _dateModeRawValueSlide(event: JQueryEventObject, ui: {
        handle: HTMLElement;
        value: number;
        values?: number[];
    }): boolean;
    protected _handleSliderRawValueSlide(event: JQueryEventObject, ui: {
        handle: HTMLElement;
        value: number;
        values?: number[];
    }, directionRight?: boolean): boolean;
    protected _getSliderHandleIndex(ui: {
        handle: HTMLElement;
        value: number;
        values?: number[];
    }): number;
    /**
     * Sets the raw slider value if different from the current value and updates the label positions. This function is intended to be invoked automatically
     * via data binding whenever the selected item is updated in the view model.
     * @param handleIndex The index of the handle to update.
     * @param rawValue The raw value to set.
     */
    protected _setSliderValueAndUpdateLabels(handleIndex: number, rawValue: number): void;
    /**
     * Updates the slider raw value for the given handle, if different from what the current value is.
     * @param handleIndex The index of the handle to update.
     * @param rawValue The raw value to set.
     */
    protected _setSliderRawValue(handleIndex: number, rawValue: number): void;
    protected _updateSliderHandleAttributes(handleIndex: number): void;
    private _updateLabelPosition(handleIndex);
    /**
     * Updates the label for the given handle. This will be invoked automatically when the currently selected item is updated in the view model.
     * @param handleIndex The index of the handle whose label we wish to update.
     */
    private _updateLabelPositionImpl(handleIndex);
    protected _processInitRoutine(): void;
    protected _initializeIfEnabled(val: boolean): void;
    protected _cleanUp(clearIsEnabledBinding?: boolean): void;
    protected _wireInKeyboardSupport(): void;
}

}
declare module "geocortex/infrastructure/ui/components/Slider/SliderViewModelBase" {
import { ViewModelBase } from "geocortex/framework/ui/ViewModelBase";
import { ObservableCollection, Observable } from "geocortex/framework/observables";
import { SliderItem } from "geocortex/infrastructure/ui/components/Slider/SliderItem";
import { TimeUnits } from "geocortex/essentials/TimeUnits";
import { SliderConfig } from "geocortex/infrastructure/ui/components/Slider/SliderConfig";
import { Application } from "geocortex/framework/application/Application";
import { CollectionChangedArgs } from "geocortex/framework/events/CollectionChangedArgs";
export interface SliderTick {
    position: string;
}
/**
 * The view model for the Slider widget.
 */
export class SliderViewModelBase<T> extends ViewModelBase {
    /**
     * The items that participate in this slider. This collection is automatically set when an underlying collection is attached to.
     * It need not be set if the slider is configured to display an integer range. This includes a date range measured as milliseconds from epoch.
     */
    items: ObservableCollection<SliderItem<T>>;
    /**
    * The label for the slider's minimum value.
    */
    sliderMinLabel: Observable<string>;
    /**
    * The label for the slider's maximum value.
    */
    sliderMaxLabel: Observable<string>;
    /**
     * The currently selected label for the first slider handle.
     */
    sliderMinHandleLabel: Observable<string>;
    /**
    * The currently selected label for the second slider handle (if configured as a range slider).
    */
    sliderMaxHandleLabel: Observable<string>;
    /**
     * The item currently associated with the min slider handle.
     */
    sliderMinHandleCurrentItem: Observable<SliderItem<T>>;
    /**
     * The item currently associated with the max slider handle if range mode is active.
     */
    sliderMaxHandleCurrentItem: Observable<SliderItem<T>>;
    /**
     * Indicates whether this slider should be a range slider (two handles) or a solo slider. Defaults to false.
     */
    range: boolean;
    /**
     * Indicates whether snapping to data items or labels is disabled altogether when the slider is in numeric mode - i.e. all data item values are numeric. Defauls to true.
     */
    disableSnappingForNumericValues: boolean;
    /**
     * If true, will lock the min slider handle at the min value, provided the slider is in range mode. Ineffective in non-range mode.
     */
    lockMinSliderHandleAtMinVal: boolean;
    /**
     * Indicates whether the generated slider is animated or not. Defaults to false.
     */
    animate: boolean;
    /**
     * Indicates whether this slider contains numeric data only or other types of objects.
     */
    isNumeric: boolean;
    /**
     * Indicates whether the slider is dealing with dates.
     */
    isDateMode: boolean;
    /**
     * Defines the steps the time slider will take if the data is numeric. This may be overridden if the next available item is not active.
     */
    numericSliderStep: number;
    /**
     * The min value for the slider if in numeric mode.
     */
    numericSliderMinVal: number;
    /**
     * The max value for the slider if in numeric mode.
     */
    numericSliderMaxVal: number;
    /**
    * The label generator function which, if defined, will be applied to compute the labels corresponding to each item in the underlying collection.
    */
    labelGenerator: (item: T | number, index: number) => string;
    /**
    * The predicate which, will be applied to compute whether an item is active (i.e. selectable) each time it is selected in the slider. Returns true by default.
    */
    itemActivePredicate: (item: T | number, index: number) => boolean;
    /**
     * The start labels for the slider handles when the slider is in non-numeric mode.
     */
    sliderHandleStartLabels: string[];
    /**
     * The numeric start values for the slider handles when the slider is in numeric mode.
     */
    numericSliderHandleStartValues: number[];
    /**
     * The ticks for the slider.
     */
    sliderTicks: ObservableCollection<SliderTick>;
    /**
     * Enable or disable the slider.
     */
    isEnabled: Observable<boolean>;
    /**
     * The time interval for this slider if it has been invoked in date mode.
     */
    dateModeTimeInterval: number;
    /**
     * The time interval unit for this slider if it has been invoked in date mode.
     */
    dateModeTimeIntervalUnit: TimeUnits;
    /**
     * A language string to be applied to the aria-label of the slider min handle if in range mode. This is for WCAG compliance. If not defined, the currently selected time will be set as the label.
     */
    sliderMinHandleAriaLabel: string;
    /**
    * A language string to be applied to the aria-label of the slider max handle if in range mode. This is for WCAG compliance. If not defined, the currently selected time will be set as the label.
    */
    sliderMaxHandleAriaLabel: string;
    /**
    * A language string to be applied to the aria-label of the slider handle if it is not in range mode. This is for WCAG compliance. If not defined, the currently selected time will be set as the label.
    */
    sliderSingleHandleAriaLabel: string;
    /**
     * The underlying collection of observable items, if any, that this slider is bound to.
     * WARNING: Do not modify this collection in any manner whatsoever since it is a reference to an external observableCollection we're binding to.
     */
    protected _underlyingCollection: ObservableCollection<T>;
    /**
     * The token representing the binding to the underlying collection.
     */
    protected _underlyingCollectionBindingToken: string;
    /**
     * The configuration options for this slider.
     */
    protected _config: SliderConfig;
    /**
     * The default label generator for a number series.
     */
    protected _defaultNumericLabelGenerator: (item: number, index: number) => string;
    /**
     * The default predicate which determines whether a slider item is active (ie selectable) in the slider or not. This function will be executed each time an item is selected.
     */
    protected _defaultItemActivePredicate: (item: T | number, index: number) => boolean;
    /**
     * In numeric mode, the items collection is kept empty. We create SliderItems based on the actual numeric value the user selects. This is an internal cache of previously created SliderItem
     * objects so we can reuse older objects once they've been created.
     */
    protected _numericSliderItemCache: {};
    protected _maxSliderTicks: number;
    protected _defaultSliderDivisions: number;
    protected _snappableDatePoints: number[];
    /**@inherited */
    constructor(app: Application, libraryId: string, sliderConfig?: SliderConfig);
    /**
     * Initializes the slider configuration. Can either be initialized using the "initialize" method or by passing in the config object directly during instantiation.
     * Explicitly initializing will overwrite any previous configuration settings that may have been applied during slider instantiation.
     */
    initialize(config: SliderConfig): void;
    /**
     * Triggered on every mouse-move during slide. The value provided represents the value that the handle will have as a result of the current movement.
     * @param value The SliderItem corresponding to the current slider value.
     * @param handleIndex The index of the handle which has currently been slid. This will possible values of 0 or 1.
     */
    sliderHandleSlide(value: SliderItem<T>, handleIndex: number): void;
    setNextSliderItem(handleIndex: number): boolean;
    setPreviousSliderItem(handleIndex: number): boolean;
    /**
     * Set the selected slider item for the specified handle in the view model. This function is intended to be invoked by the view code behind and does not update the slider UI widget itself.
     * @param handleIndex The index of the slider handle for which to set the selected slider item.
     * @param item The SliderItem to update the selected handle value to.
     */
    setSelectedSliderItem(handleIndex: number, item: SliderItem<T>): void;
    /**
     * Attaches to an ObservableCollection and automatically generates relevant SliderItems.
     * @param collection The collection to attach to.
     * @param labelGenerator Optional function which will be called for each item in the collection. Generates a string label for the item. For example (item: Feature, index: number) => `${index + 1}: ${item.label.get()}`;
     * @param itemActivePredicate Optional. A function which determines whether the current item is active (ie is selectable in the slider) or not. This function will be executed each time an item is selected. If not specified, returns true.
     * @param startItemLabels Optional. An array of strings containing one or two values, depicting the start labels of the handle (or handles if in range mode) of the slider.  These values will be applied on a best effort basis:
     *                          1) At slider creation time:: If the startup label values are valid, they will be applied.
     *                          2) When an attached collection is updated:: If the startup label value has not yet been applied and the slider handle has not been moved manually by the user at the point in time
     *                          when the collection is updated, the startup label values will be applied provided they are valid. Once the user moves either one of the slider handles manually, the startup label values will
     *                          no longer be respected. If no startup label values are provided, the handles will start at the first and second data points respectively by default.
     */
    attachToCollection(collection: ObservableCollection<T>, labelGenerator?: (item: T, index: number) => string, itemActivePredicate?: (item: T, index: number) => boolean, startItemLabels?: string[]): void;
    /**
     * Puts the slider into numeric mode. This will clear out all underlying attached collections if attached previously and convert the slider into a vanilla
     * jQuery numeric slider, albeit with configurable labels. The items collection will remain empty and so will the underlying collection.
     * @param minVal The minimum value of the numveric range this slider will represent.
     * @param maxVal The maximum value fo the numeric range this slider will represent.
     * @param steps Optional parameter defining the number of steps between two data items. If not provided, a default value of 1 will be used for values over 1. 0.1 will be used for values below 1.
     * @param labelGenerator Optional parameter defining the rules by which labels should be generated. If not provided, the label will be a string representation of the number itself.
     * @param itemActivePredicate Optional. A function which determines whether the current item is active (ie is selectable in the slider) or not. This function will be executed each time an item is selected. If not specified, returns true.
     * @param startItemValues Optional. An array of numbers containing one or two values, depicting the start values of the handle (or handles if in range mode) of the slider. These values will be applied on a best effort basis:
     *                          1) At slider creation time:: If the startup values are valid, they will be applied.
     *                          2) When an attached collection is updated:: If the startup value has not yet been applied and the slider handle has not been moved manually by the user at the point in time
     *                          when the collection is updated, the startup values will be applied provided they are valid. Once the user moves either one of the slider handles manually, the startup values will
     *                          no longer be respected. If no startup values are provided, the handles will start at the first and second data points respectively by default.
     */
    setupNumericSlider(minVal: number, maxVal: number, steps?: number, labelGenerator?: (item: number, index: number) => string, itemActivePredicate?: (item: number, index: number) => boolean, startItemValues?: number[]): void;
    setupDateSlider(minDateMsSinceEpoch: number, maxDateMsSinceEpoch: number, timeInterval: number, timeIntervalUnit: TimeUnits, labelGenerator?: (item: number, index: number) => string, itemActivePredicate?: (item: number, index: number) => boolean, startItemValues?: number[]): void;
    /**
     * Retrieve the updated slider item corresponding to the raw slider value. Returns the slider item if found, null otherwise.
     * @param sliderValue The raw numeric value returned by the slider. This will represent the index of the item in the items collection if the slider is non numeric and the actual numeric value if it's numeric.
     */
    getSliderItemByRawSliderValue(rawSliderValue: number, autoSnapNumericValsToMinMax?: boolean): SliderItem<T>;
    /**
     * Retrieve the updated slider item corresponding to the given slider label. Returns the slider item if found, null otherwise. If more than one item exists with the same label, we'll return the first match.
     * @param label
     */
    getSliderItemByItemLabel(label: string): SliderItem<T>;
    /**
     * Retrieve the updated slider item corresponding to the given item value. Returns the slider item if found, null otherwise.
     * @param value
     */
    getSliderItemByItemValue(value: T | number): SliderItem<T>;
    /**
    * Get the next slider item.
    * @param sliderItem The current slider item with respect to which we want to find the next item.
    */
    getNextSliderItem(sliderItem: SliderItem<T>): SliderItem<T>;
    /**
     * Get the next active slider item.
     * @param sliderItem The current slider item with respect to which we want to find the next active item.
     */
    getNextActiveSliderItem(sliderItem: SliderItem<T>): SliderItem<T>;
    /**
     * Get the next inactive slider item.
     * @param sliderItem The current slider item with respect to which we want to find the next inactive item.
     */
    getNextInactiveSliderItem(sliderItem: SliderItem<T>): SliderItem<T>;
    /**
   * Get the previous slider item.
   * @param sliderItem The current slider item with respect to which we want to find the previous item.
   */
    getPreviousSliderItem(sliderItem: SliderItem<T>): SliderItem<T>;
    /**
     * Get the previous active slider item.
     * @param sliderItem The current slider item with respect to which we want to find the previous active item.
     */
    getPreviousActiveSliderItem(sliderItem: SliderItem<T>): SliderItem<T>;
    /**
     * Get the previous inactive slider item.
     * @param sliderItem The current slider item with respect to which we want to find the previous inactive item.
     */
    getPreviousInactiveSliderItem(sliderItem: SliderItem<T>): SliderItem<T>;
    /**
     * Get the nearest date item snapped to a computed date interval. This will work only in date mode.
     * @param sliderItem The slider item for which the nearest date item needs to be computed.
     * @param searchDirection A string - "next" or "prev" - defining which direction to search in.
     * @param doNotReturnOriginal A boolean which if true will prevent the function from returning the original item if it's already snapped to interval.
     * @return The closest date item if found. Null otherwise.
     */
    getClosestDateItemSnappedToInterval(sliderItem: SliderItem<number>, searchDirection?: string, doNotReturnOriginal?: boolean): SliderItem<number>;
    /**
     * Get the raw slider value for a give slider item. Returns the raw slider value or null if the item does not exist.
     * @param sliderItem
     */
    getRawSliderValueForItem(sliderItem: SliderItem<T>): number;
    cleanUp(): void;
    protected _setNextOrPreviousSliderItem(handleIndex: number, qualifier: string): boolean;
    protected _initializeUIObservables(): void;
    protected _setupSliderTicks(): void;
    protected _setupSliderMinMaxLabels(): void;
    /**
     * Internal implementation to get the next or previous active slider item. Returns the item if it exists, null otherwise.
     * @param sliderItem The slider item for which we want to retrieve the next or previous active slider item.
     * @param position May have two distinct values - "next" for the next active slider item or "prev" for the previous active slider item. Defaults to "next"
     * @param status May have three distinct values - "active" for active slider item, "inactive" for inactive slider item or "any" for a slider item with any status. Defaults to "any".
     */
    protected _getAdjacentSliderItem(sliderItem: SliderItem<T>, position?: string, status?: string): SliderItem<T>;
    protected _getAdjacentNumericItemRawValue(rawValue: number, position?: string, autoSnapNumericValsToMinMax?: boolean): number;
    protected _resetTimeIntervalBasedOnSliderStep(): void;
    protected _getClosestDateItemRawValueSnappedToInterval(rawValue: number, searchDirection?: string, doNotReturnOriginal?: boolean): number;
    protected _generateDateModeSnappablePoints(): void;
    /**
     * Apply configuration settings or defaults if no settings are available.
     */
    protected _applyConfig(config: SliderConfig): void;
    /**
     * Update the items collection as the underlying collection changes.
     */
    protected _handleUnderlyingCollectionChanges(args: CollectionChangedArgs): void;
    /**
     * Create a SliderItem for the given underlying item.
     */
    protected _createSliderItem(item: T | number, index: number): SliderItem<T>;
    /**
     * Get the label for the current item
     */
    protected _getItemLabel(item: T | number, index: number): string;
    protected _updateSliderItem(item: SliderItem<T>, index: number): SliderItem<T>;
    /**
     * Retrieve a numeric slider item by value and update the numeric item cache so subsequent retrievals return the same object.
     */
    protected _getUpdatedNumericItemAndUpdateCache(value: number, index: number): SliderItem<T>;
}

}
declare module "geocortex/infrastructure/ui/components/SmartPanel/SmartPanelView" {
import { ViewContainerView } from "geocortex/framework-ui/ViewContainer/ViewContainerView";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { SmartPanelViewModel } from "geocortex/infrastructure/ui/components/SmartPanel/SmartPanelViewModel";
import { MenuView } from "geocortex/infrastructure/menus/MenuView";
import { RegionAdapterBase } from "geocortex/framework/ui/RegionAdapterBase";
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { BindingExpression } from "geocortex/framework/ui/BindingExpression";
import { MenuViewModel } from "geocortex/infrastructure/menus/MenuViewModel";
/**
 * Interface that contains all relevant information when a panel is being resized.
 */
export interface ResizeInformation {
    initialPanelWidth?: number;
    initialPanelHeight?: number;
    minWidth?: number;
    maxWidth?: number;
    minHeight?: number;
    maxHeight?: number;
    initialX?: number;
    initialY?: number;
    currentX?: number;
    currentY?: number;
}
/**
 * A Smart Panel is an extension of {@link framework.ui.ViewContainer.ViewContainerView} that adds the ability to "hoist" menu widgets
 * from views within the panel's managed region.
 * When a menu is "hoisted" from a view, a new menu view is created for the same menu, and a button appears in the panel's header that
 * will activate the menu view.
 * While a menu is hoisted, it is hidden in the originating view.
 * Any menu created via {@link menus.MenuRegistry.createMenuWidget} can be hoisted.
 */
export class SmartPanelView extends ViewContainerView {
    static HoistedClassName: string;
    /** @inherited */
    app: ViewerApplication;
    /** @inherited */
    viewModel: SmartPanelViewModel;
    /** The ID of the menu most recently hoisted. */
    hoistedMenuId: string;
    /** The view of the currently hoisted menu. */
    hoistedMenuOwnerView: MenuView;
    /** The menu button element. */
    menuButtonElement: HTMLElement;
    /** The container area */
    containerElement: HTMLElement;
    /** The header area */
    headerElement: HTMLElement;
    /** The optional status message region */
    statusRegionElement: HTMLElement;
    /** The scroll area */
    scrollRegionElement: HTMLElement;
    /** The footer area */
    footerElement: HTMLElement;
    /** The parent region that is actually resized when the panel is resized */
    resizableRegion: HTMLElement;
    /** An element used to show the changing dimensions panel during resizing */
    resizePreviewElement: HTMLElement;
    /** Whether the panel is able to be resized vertically */
    resizeY: boolean;
    /** Whether the panel is able to be resized horizontally */
    resizeX: boolean;
    /** Set to `true` if the currently active view in the managed region is itself an instance of {@link SmartPanelView}. */
    protected _activeViewIsASmartPanel: boolean;
    /** The parent panel of this one, if this view is hosted in a region controlled by another instance of {@link SmartPanelView}. */
    protected _parentPanel: SmartPanelView;
    /** Menu views created by this component, tracked to ensure we don't "leak" any instances of {@link MenuView}. */
    protected _menuViews: {
        [viewId: string]: MenuView;
    };
    /** Subscription token for the binding event for the menu item invoked event */
    protected _menuItemInvokedSubscriptionToken: string;
    /** @inherited */
    attach(viewModelArg?: any): void;
    protected _initializeEvents(): void;
    /** When status messages are shown (or dismissed), the position of the scroll region element should be recalculated */
    protected _handleRegionActivatedOrDeactivated(region: RegionAdapterBase): void;
    protected _togglePanelMaximized(viewId: String, operation: String): void;
    protected _canExecuteMaximizeRestoreOperations(): boolean;
    /** @inherited */
    protected _handleViewActivatedInContainerEvent(view: ViewBase): void;
    /** @inherited */
    activated(): void;
    /** @inherited */
    deactivated(): void;
    /** @inherited */
    destroy(): void;
    /**
     * Opens the hoisted menu as its own view in a particular region.
     * @param regionName The name of the region to activate the menu view in.
     */
    openHoistedMenuInRegion(regionName: string): void;
    /** @inherited */
    resolveWidget(widgetId: string, context: any, binding: BindingExpression): any;
    /**
     * Creates a new instance of {@link menus.MenuView} with the default menu template.
     * @param viewModel The view model for the new menu view.
     */
    createMenuView(viewModel: MenuViewModel): MenuView;
    /**
     * Handles a click or a tap on the hoisted menu button and opens the menu either as a popup, or as a new view in a region
     * whose name provided in configuration for the view model.
     */
    handleTapMenuButton(): void;
    /**
     * "Hoists" the first menu found in a given view, hosting a copy of the menu either as a popup/dropdown menu in the header,
     * or as a new view that will be activated in a region specified in view model configuration.
     * @param view The view to try hoisting a menu from.
     */
    hoistMenuForView(view: ViewBase): void;
    /**
     * Sets the parent panel of this one. This allows for nested panels to perform hoisting.
     * @param parentPanel The panel considered the parent of this one.
     */
    setParentPanel(parentPanel: SmartPanelView): void;
    /**
     * Handles the maximize or minimize click events
     * @param evt The triggering event.
     * @param el The targeted element.
     * @ctx ctx The current context.
     */
    handleMaximizeToggleClick(evt: Event, el: HTMLElement, ctx: any): void;
    /**
     * Maximizes the panel.
     */
    maximizePanel(): void;
    /**
     * Minimizes the panel.
     */
    minimizePanel(): void;
    private _unsubscribeMenuItemInvokedSubscription();
    handleHeaderMouseDown(evt: MouseEvent, el: HTMLElement, ctx: any): boolean;
    handleHeaderTouchStart(evt: any, el: HTMLElement, ctx: any): boolean;
    /** @inherited */
    resize(): void;
    resizeSmartPanel(initialX: number, initialY: number): void;
    protected _handleResizeEnd(evt: JQueryEventObject, resizeInformation: ResizeInformation): void;
    protected _resizeAccordingToSizeConstraints(resizeInformation: ResizeInformation, elementToResize: HTMLElement): void;
    protected _destroyHoistedMenuOwnerViewIfExists(): void;
}

}
declare module "geocortex/infrastructure/ui/components/SmartPanel/SmartPanelViewModel" {
import { ViewContainerViewModel } from "geocortex/framework-ui/ViewContainer/ViewContainerViewModel";
import { MenuViewModel } from "geocortex/infrastructure/menus/MenuViewModel";
import { Observable } from "geocortex/framework/observables";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
/**
 * Default view model for a {@link SmartPanelView}.
 */
export class SmartPanelViewModel extends ViewContainerViewModel {
    /** An empty menu view model to use when no hoisted menu is available. */
    static emptyMenuViewModel: MenuViewModel;
    /**
     * The view model for the currently hoisted menu.
     * When there is no hoisted menu present, this should be set to {@link emptyMenuViewModel}.
     */
    hoistedMenuViewModel: Observable<MenuViewModel>;
    /** Whether or not a menu is available for presentation as a hoisted menu. */
    hasHoistedMenu: Observable<boolean>;
    /** Whether or not the currently hoisted menu (if present) has any executable menu items. */
    hasExecutableMenuItems: Observable<boolean>;
    /**
     * An option region name specifying a region to activate menu views in.
     * If specified in configuration, new menu views will be created and activated in this region rather than being dropdowns.
     */
    menuRegion: string;
    /** Whether or not the inline menu is open. */
    inlineMenuIsOpen: Observable<boolean>;
    /** Whether or not this panel is currently maximized */
    panelMaximized: Observable<boolean>;
    /** Whether to display the maximize button on this smart panel. Defaults to false */
    showingMaximizeButton: Observable<boolean>;
    /** Whether the views that are linked to this are able to be resized on the x axis */
    resizeX: boolean;
    /** Whether the views that are linked to this are able to be resized on the y axis */
    resizeY: boolean;
    /**
     * Optional region where status messages related to this smart panel are to be shown.
     * If specified in configuration, the status messages will be created and activated in this region.
     */
    statusRegion: string;
    /** The region type for status messages. Defaults to `geocortex.framework.ui.DivRegionAdapter` */
    statusRegionType: string;
    /** @inherited */
    constructor(app: ViewerApplication, libraryId: string);
    /** @inherited */
    initialize(config: any): void;
}

}
declare module "geocortex/infrastructure/ui/components/Table/SortState" {
export enum SortState {
    UNSORTED = 0,
    ASCENDING = 1,
    DESCENDING = 2,
}

}
declare module "geocortex/infrastructure/ui/components/Table/TableColumnHeaderViewModel" {
import { TableColumnHeaderViewModelInterface } from "geocortex/infrastructure/ui/components/Table/TableColumnHeaderViewModelInterface";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { Observable } from "geocortex/framework/observables";
import { PresentableCollection } from "geocortex/framework-ui/PresentableCollection";
/**
 * Default view model for a {@link TableView}.
 */
export class TableColumnHeaderViewModel implements TableColumnHeaderViewModelInterface {
    app: ViewerApplication;
    libraryId: string;
    visible: Observable<boolean>;
    value: Observable<any>;
    presentableValue: Observable<string>;
    displayAsUrl: boolean;
    columnDescriptor: Observable<string>;
    sortState: Observable<number>;
    sortClass: Observable<string>;
    _sharedState: SharedState;
    _sortingPredicate: (a: any, b: any) => number;
    _reverseSortingPredicate: (a: any, b: any) => number;
    constructor(app: ViewerApplication, libraryId: string, sharedState: SharedState, displayName: string, type: string, index: number);
    private buildSortingFunction(index);
    private buildReverseSortingFunction(index);
    private buildDateSortingFunction(index);
    private buildReverseDateSortingFunction(index);
    private onSortStateChange(state);
}
/**
 * Manual comparison function. Slower than native.
 */
export var manualCollator: (a: any, b: any) => number;
/**
 * The fastest comparison function available.
 */
export var collator: (x: string, y: string) => number;
/**
 * Holds state shared between columns.
 */
export class SharedState {
    ignoreStateChange: boolean;
    lastSortedColumn: any;
    presentableResults: PresentableCollection<any>;
    unsortedClass: string;
    sortedClass: string;
    reverseSortedClass: string;
    constructor(presentableResults: PresentableCollection<any>, unsortedClass: string, sortedClass: string, reverseSortedClass: string);
    reset(): void;
}

}
declare module "geocortex/infrastructure/ui/components/Table/TableColumnHeaderViewModelInterface" {
import { TableColumnViewModelInterface } from "geocortex/infrastructure/ui/components/Table/TableColumnViewModelInterface";
import { Observable } from "geocortex/framework/observables";
export class TableColumnHeaderViewModelInterface extends TableColumnViewModelInterface {
    /**
     * The CSS class to be applied depending on which sorting state is selected for the columns
     */
    sortClass: Observable<string>;
}

}
declare module "geocortex/infrastructure/ui/components/Table/TableColumnViewModelInterface" {
import { Observable } from "geocortex/framework/observables";
export class TableColumnViewModelInterface {
    /**
    * A boolean observable indicating whether this column is visible or not. Defaults to true
    */
    visible: Observable<boolean>;
    /**
     * An observable containing the value of this column.
     */
    value: Observable<any>;
    /**
     * An obervable string containing the presentable value of this column.
     */
    presentableValue: Observable<string>;
    /**
     * Indicates whether this value should be rendered as a hyperlink in the table.
     */
    displayAsUrl: boolean;
}

}
declare module "geocortex/infrastructure/ui/components/Table/TableRowViewModelInterface" {
import { ObservableCollection } from "geocortex/framework/observables";
import { TableColumnViewModelInterface } from "geocortex/infrastructure/ui/components/Table/TableColumnViewModelInterface";
export interface TableRowViewModelInterface {
    /**
     * An observable collection containing the columns for this row. This should match the number of defined column headers
     */
    attributes: ObservableCollection<TableColumnViewModelInterface>;
}

}
declare module "geocortex/infrastructure/ui/components/Table/TableView" {
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { TableViewModel } from "geocortex/infrastructure/ui/components/Table/TableViewModel";
import { TableColumnHeaderViewModel } from "geocortex/infrastructure/ui/components/Table/TableColumnHeaderViewModel";
import { TableRowViewModelInterface } from "geocortex/infrastructure/ui/components/Table/TableRowViewModelInterface";
import { FeatureAttribute } from "geocortex/infrastructure/FeatureAttribute";
import { Feature } from "geocortex/infrastructure/Feature";
export class TableView extends ViewBase {
    /** @inherited */
    app: ViewerApplication;
    /** @inherited */
    viewModel: TableViewModel;
    /** The reference to the element containing this table */
    tableContainerElement: HTMLDivElement;
    private _itemClass;
    private _longPressTimer;
    private _pressStartTime;
    private _firedTouchOrPress;
    private _hoverTimerToken;
    private _hoveredFeature;
    private _pressYStart;
    private _lastTouchY;
    private _scrollYDeltaThreshold;
    private _firstEvent;
    handleColumnHeadClick(evt: Event, el: HTMLElement, ctx: TableColumnHeaderViewModel): void;
    handleMouseDown(evt: Event, el: HTMLElement, ctx: TableRowViewModelInterface): boolean;
    handleMouseUp(evt: Event, el: HTMLElement, ctx: TableRowViewModelInterface): boolean;
    handleMouseOver(evt: Event, el: HTMLElement, ctx: Feature): void;
    handleMouseOut(evt: Event, el: HTMLElement, ctx: Feature): void;
    handleTouchStart(evt: Event, el: HTMLElement, ctx: TableRowViewModelInterface): boolean;
    handleTouchMove(evt: Event, el: HTMLElement, ctx: TableRowViewModelInterface): boolean;
    handleTouchEnd(evt: Event, el: HTMLElement, ctx: TableRowViewModelInterface): boolean;
    handleClick(evt: Event, el: HTMLElement, ctx: TableRowViewModelInterface): boolean;
    handleClickAttributelink(event: Event, element: HTMLAnchorElement, attribute: FeatureAttribute): boolean;
    private _beginLongPressIfNoEventsInProgress(ctx, eventName);
    private _cancelLongPressIfEventInProgress(eventName);
    private _beginLongPress(ctx);
    private _cancelLongPress();
    private _beginHover(ctx);
    private _cancelHover();
    private _tryFireHoverStop(ctx);
}

}
declare module "geocortex/infrastructure/ui/components/Table/TableViewModel" {
import { ViewModelBase } from "geocortex/framework/ui/ViewModelBase";
import { ObservableCollection } from "geocortex/framework/observables";
import { TableColumnHeaderViewModel } from "geocortex/infrastructure/ui/components/Table/TableColumnHeaderViewModel";
import { TableRowViewModelInterface } from "geocortex/infrastructure/ui/components/Table/TableRowViewModelInterface";
import { PresentableCollection } from "geocortex/framework-ui/PresentableCollection";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
/**
 * Default view model for a {@link TableView}.
 */
export class TableViewModel extends ViewModelBase {
    /**
     * An observable collection of column headers for the table
     */
    columnHeaders: ObservableCollection<TableColumnHeaderViewModel>;
    /**
     * The various records (rows) contained in this table
     */
    records: ObservableCollection<TableRowViewModelInterface>;
    /**
     * The Presentable Collection, if any, backing this table. This is optional and a module may choose to manipulate the 'records' parameter directly as well.
     */
    presentableRecordCollection: PresentableCollection<TableRowViewModelInterface>;
    /**
     * The events to fire when a particular record is clicked with the particular record as context parameter
     */
    recordClickEvents: string[];
    /**
    * The events to fire when a particular record is pressed for a preset duration (1000ms default) with the particular record as context parameter
    */
    recordLongPressEvents: string[];
    /**
    * The events to fire when a particular record is hovered on for a preset duration (300ms default) with the particular record as context parameter
    */
    recordHoverEvents: string[];
    /**
    * The events to fire when a particular ceases to be hovered upon.
    */
    recordHoverEndEvents: string[];
    /**
     * The amount of time (in milliseconds) after which a press on a record is considered a long press. Defaults to 1000ms.
     */
    recordLongPressDuration: number;
    /**
    * The amount of time (in milliseconds) after which a hover on a record is considered a hover. Defaults to 0ms.
    */
    recordHoverDuration: number;
    /** @inherited */
    constructor(app: ViewerApplication, libraryId: string);
    /** Optional */
    attachToPresentableCollection(source: PresentableCollection<TableRowViewModelInterface>): void;
    addRecordClickEvents(eventName: string[]): void;
    addRecordClickEvents(eventName: string): void;
    addRecordLongPressEvents(eventName: string[]): void;
    addRecordLongPressEvents(eventName: string): void;
    addRecordHoverEvents(eventName: string[]): void;
    addRecordHoverEvents(eventName: string): void;
    addRecordHoverEndEvents(eventName: string[]): void;
    addRecordHoverEndEvents(eventName: string): void;
    /**
     * Mode: 0 adds click events. Mode 1 adds long press events
     */
    private _executeAddEvents(eventName, mode);
}

}
declare module "geocortex/infrastructure/ui/components/WizardPanel/ValidationHandler" {
/**
 * Interface definition for user input validation.
 */
export interface ValidationHandler {
    /**
     * Performs validation on a dialog, and populates the validation problems observable of the view-model.
     * @return `true` if the form validates, `false` if it fails.
     */
    validate(options?: any): boolean;
}
/**
 * A validation problem is a reason for why a validator fails.
 */
export interface ValidationProblem {
    /** Human-readable (internationalized) string serving as the name/label of the validation problem. */
    title: string;
    /** Human-readable (internationalized) string serving as the explanatory description of the validation problem. */
    message: string;
}
/** A validator is a function that returns an array of validation problems. */
export type Validator = () => ValidationProblem[];

}
declare module "geocortex/infrastructure/ui/components/WizardPanel/WizardFragmentView" {
import { ViewBase } from "geocortex/framework/ui/ViewBase";
import { ValidationHandler, ValidationProblem } from "geocortex/infrastructure/ui/components/WizardPanel/ValidationHandler";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { WizardFragmentViewModel } from "geocortex/infrastructure/ui/components/WizardPanel/WizardFragmentViewModel";
import { WizardPanelView } from "geocortex/infrastructure/ui/components/WizardPanel/WizardPanelView";
/**
 * A wizard fragment is a piece of user interface (i.e. a view) that can be placed within a wizard container.
 */
export class WizardFragmentView extends ViewBase implements ValidationHandler {
    /** Reference to the viewer application. */
    app: ViewerApplication;
    /** The View Model backing this view. */
    viewModel: WizardFragmentViewModel;
    /** Collection of problems that occurred during the form validation process. */
    validationProblems: ValidationProblem[];
    /** The container view that is the parent of this wizard fragment. */
    protected parentContainer: WizardPanelView;
    /** Token for the event subscription to the modal region's X button. */
    protected _viewContainerActivatedEventToken: string;
    /**
    * Initializes a new instance of the {@link WizardFragmentView} class.
    * @param app The {@link geocortex.framework.application.Application} that this view belongs to.
    * @param libraryId
    */
    constructor(app: ViewerApplication, libraryId?: string);
    /**
     * Associates this view with its view model and its parental ViewContainerView.
     */
    attach(viewModel: any): void;
    /**
     * Determines whether this view is hosted within the supplied view container.
     */
    protected _isViewHostedInContainer(container: ViewBase): boolean;
    /**
     * Completes the wizard.
     */
    finishWizard(): void;
    /**
     * Cancels the wizard and discards any data that has been entered so far.
     */
    cancelWizard(): void;
    /**
     * Cleans up the ViewContainerActivatedEvent subscription.
     */
    destroy(): void;
    /**
     * Validator function that is dedicated to this dialog.
     * Override this method to provide your own validation rules.
     * @return Array of validation problems.
     */
    protected _validator(): ValidationProblem[];
    /**
     * Performs validation on a dialog, and populates the validation problems observable of the view-model.
     * @param options Optional parameters to use while validating this dialog.
     * @return `true` if the form validates, `false` if it fails.
     */
    validate(options?: any): boolean;
    /**
     * Derived classes might override this method to reset a dialog to its default state. Allows dialogs to be reused.
     */
    reset(): void;
    /**
     * Derived classes might override to this method to fetch data that is to be presented by this wizard fragment.
     */
    loadState(): void;
    /**
     * Derived classes might override to this method to save the data captured within this wizard fragment.
     */
    saveState(...args: any[]): void;
    /**
     * Advances the wizard to the next step. Usually involves activating a new dialog and closing the current one.
     * Must be overridden in derived classes.
     */
    goNext(...args: any[]): void;
    /**
     * Takes the wizard one step back.
     * Must be overridden in derived classes.
     */
    goBack(...args: any[]): void;
}

}
declare module "geocortex/infrastructure/ui/components/WizardPanel/WizardFragmentViewModel" {
/**
 * A wizard fragment represents a single page (or step) in the wizard.
 */
export interface WizardFragmentViewModel {
    /** Override this method to reset a wizard fragment to its default state. */
    reset(): void;
}

}
declare module "geocortex/infrastructure/ui/components/WizardPanel/WizardPanelView" {
import { SmartPanelView } from "geocortex/infrastructure/ui/components/SmartPanel/SmartPanelView";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
import { WizardPanelViewModel } from "geocortex/infrastructure/ui/components/WizardPanel/WizardPanelViewModel";
/**
 * A Wizard Panel is an extension of {@link infrastructure.ui.components.SmartPanel.SmartPanelViewModel} that adds the ability to
 * create simple step-by-step wizards within the panel's managed region.
 *
 * The container header displays a "Back" button along with a "Close" button. The "Back" button takes the wizard back one step.
 * The "Close" button quits the wizard and discards any data that has been entered so far. The "Back" button is disabled on the first step.
 *
 * It is up to the originating views to define what "Next" means. Typically you would activate the dialog for the next step.
 */
export class WizardPanelView extends SmartPanelView {
    /** Reference to the viewer application. */
    app: ViewerApplication;
    /** The View Model backing this view. */
    viewModel: WizardPanelViewModel;
    /**
     * Completes the wizard.
     */
    finish(): void;
    /**
     * Cancels the wizard and discards any data that has been entered so far.
     */
    cancel(): void;
    handleClickBack(evt: Event, el: HTMLElement, ctx: any): void;
    handleClickClose(evt: Event, el: HTMLElement, ctx: any): void;
}

}
declare module "geocortex/infrastructure/ui/components/WizardPanel/WizardPanelViewModel" {
import { SmartPanelViewModel } from "geocortex/infrastructure/ui/components/SmartPanel/SmartPanelViewModel";
import { ViewerApplication } from "geocortex/infrastructure/Viewer";
/**
 * Default view model for a {@link WizardPanelView}.
 */
export class WizardPanelViewModel extends SmartPanelViewModel {
    constructor(app: ViewerApplication, libraryId?: string);
    /**
     * Provides custom logic for showing "Back" and "Close" buttons.
     */
    showOrHideCloseButtons(): void;
    /**
     * Removes all views from the container region.
     */
    closeAllViews(abort?: boolean): void;
    protected _isWizardFragment(x: any): boolean;
}

}